[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  solve\n  def solve: Unit = {\n    val line = readLine.trim\n    if (line == \".\") return\n    line.toList match {\n      case b Bool Nil ⇒ println(Combination.all.count(c ⇒ b(c) == True))\n      case _ ⇒ ???\n    }\n    solve\n  }\n  object Combination {\n    def all: List[Combination] = List.tabulate(3){_ ⇒ List(True, False, Unknown)}.foldLeft(Nil::Nil:List[List[Bool]]){(l, r) ⇒ l.flatMap(list ⇒ r.map(_::list))}.map{case p::q::r::Nil ⇒ Combination(p, q, r); case _ ⇒ ???}\n  }\n  case class Combination(p: Bool, q: Bool, r: Bool)\n  sealed trait Bool {\n    def unary_- : Bool\n    def *(that: Bool): Bool\n    def +(that: Bool): Bool\n  }\n  object Bool {\n    def unapply(arg: List[Char]): Option[(Combination ⇒ Bool, List[Char])] = {\n      arg match {\n        case l Term rest ⇒ rest match {\n          case Nil ⇒ Some(l, Nil)\n          case '+'::(r Term t) ⇒ Some(c ⇒ l(c) + r(c), t)\n          case '*'::(r Term t) ⇒ Some(c ⇒ l(c) * r(c), t)\n          case _ ⇒ None\n        }\n        case _ ⇒ None\n      }\n    }\n  }\n\n  object True extends Bool {\n    def unapply(arg: List[Char]): Option[(Bool, List[Char])] = {\n      arg match {\n        case '2'::t ⇒ Some(True, t)\n        case _ ⇒ None\n      }\n    }\n    override def unary_- : Bool = False\n    override def * (that: Bool): Bool = that\n    override def + (that: Bool): Bool = True\n  }\n  object False extends Bool {\n    def unapply(arg: List[Char]): Option[(Bool, List[Char])] = {\n      arg match {\n        case '0'::t ⇒ Some(False, t)\n        case _ ⇒ None\n      }\n    }\n    override def unary_- : Bool = True\n    override def * (that: Bool): Bool = False\n    override def + (that: Bool): Bool = that\n  }\n  object Unknown extends Bool {\n    def unapply(arg: List[Char]): Option[(Bool, List[Char])] = {\n      arg match {\n        case '1'::t ⇒ Some(Unknown, t)\n        case _ ⇒ None\n      }\n    }\n    override def unary_- : Bool = Unknown\n    override def * (that: Bool): Bool = that match {\n      case False ⇒ False\n      case _ ⇒ Unknown\n    }\n    override def + (that: Bool): Bool = that match {\n      case True ⇒ True\n      case _ ⇒ Unknown\n    }\n  }\n  object Variable {\n    def unapply(arg: List[Char]): Option[(Combination ⇒ Bool, List[Char])] = {\n      arg match {\n        case 'P'::t ⇒ Some(_.p, t)\n        case 'Q'::t ⇒ Some(_.q, t)\n        case 'R'::t ⇒ Some(_.r, t)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Term {\n    def unapply(arg: List[Char]): Option[(Combination ⇒ Bool, List[Char])] = {\n      arg match {\n        case '-'::(b Term t) ⇒ Some(c ⇒ -b(c), t)\n        case '('::(b Bool ')'::t) ⇒ Some(b, t)\n        case b True t ⇒ Some(_ ⇒ b, t)\n        case b False t ⇒ Some(_ ⇒ b, t)\n        case b Unknown t ⇒ Some(_ ⇒ b, t)\n        case v Variable t ⇒ Some(v, t)\n        case _ ⇒ None\n      }\n    }\n  }\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstring S;\nint cur = 0;\n\nint P,Q,R;\n\nint formula() {\n  if (S[cur] == '0' || S[cur] == '1' || S[cur] == '2') {\n    return S[cur++] - '0';\n  } else if (S[cur] == 'P') {\n    cur++;\n    return P;\n  } else if (S[cur] == 'Q') {\n    cur++;\n    return Q;\n  } else if (S[cur] == 'R') {\n    cur++;\n    return R;\n  } else if (S[cur] == '-') {\n    cur++;\n    return 2-formula();\n  } else {\n    assert(S[cur] == '(');\n    cur++;\n    int a = formula();\n    char op = S[cur++];\n    int b = formula();\n    assert(S[cur] == ')');\n    cur++;\n    if (op == '*') {\n      if (a == 2 && b == 2) {\n\treturn 2;\n      } else if (a == 0 || b == 0) {\n\treturn 0;\n      } else {\n\treturn 1;\n      }\n    } else {\n      assert(op == '+');\n      if (a == 0 && b == 0) {\n\treturn 0;\n      } else if (a == 2 || b == 2) {\n\treturn 2;\n      } else {\n\treturn 1;\n      }      \n    }\n  }\n}\n\nint main() {\n  while(cin >> S && S != \".\") {\n    int ans = 0;\n    for(P = 0; P <= 2; P++) {\n      for(Q = 0; Q <= 2; Q++) {\n\tfor(R = 0; R <= 2; R++) {\n\t  cur = 0;\n\t  int aa = formula();\n\t  assert(cur == (int)S.length());\n\t  if (aa == 2) {\n\t    ans++;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define vec vector\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n\nint cal(char a, int d1, int d2)\n{\n\tif (a == '*') {\n\t\treturn min(d1, d2);\n\t} else {\n\t\treturn max(d1, d2);\n\t}\n}\n\nint ret(int a, int minus)\n{\n\tif (minus % 2) return 2 - a;\n\telse return a;\n}\n\nint solve(vec<char> formula, int p, int q, int r)\n{\n\tstack<int> ans;\n\tint minus = 0;\n\trep(i, formula.size()) {\n\t\tchar get = formula[i];\n\t\tif (get == '0' || get == '1' || get == '2'){\n\t\t   \tans.push((int)get - '0');\n\t\t}\n\t\telse if (get == 'P') ans.push(p);\n\t\telse if (get == 'Q') ans.push(q);\n\t\telse if (get == 'R') ans.push(r);\n\t\telse if (get == '-') {\n\t\t\tint a = ans.top();\n\t\t\tans.pop();\n\t\t\tans.push(2 - a);\n\t\t} else {\n\t\t\tint d1, d2;\n\t\t\td1 = ans.top();\n\t\t\tans.pop();\n\t\t\td2 = ans.top();\n\t\t\tans.pop();\n\t\t\tans.push(ret(cal(get, d1, d2), minus));\n\t\t}\n\t\tif (get != '-') minus = 0;\n\t}\n\tif (ans.top() == 2) return 1;\n\telse return 0;\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s == \".\") break;\n\n\t\tstack<char> keep;\n\t\tvec<char> formula;\n\t\trep(i, s.length()) {\n\t\t\tif (s[i] == '-' || s[i] == '+' || s[i] == '(' || s[i] == '*') keep.push(s[i]);\n\t\t\telse if (s[i] == ')') {\n\t\t\t\twhile(1) {\n\t\t\t\t\tchar get = keep.top();\n\t\t\t\t\tkeep.pop();\n\t\t\t\t\tif (get == '(') break;\n\t\t\t\t\tformula.push_back(get);\n\t\t\t\t}\n\t\t\t\twhile(!keep.empty() && keep.top() == '-') {\n\t\t\t\t\tkeep.pop();\n\t\t\t\t\tformula.push_back('-');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tformula.push_back(s[i]);\n\t\t\t\twhile(!keep.empty() && keep.top() == '-') {\n\t\t\t\t\tkeep.pop();\n\t\t\t\t\tformula.push_back('-');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\trep(p, 3) rep(q, 3) rep(r, 3) num += solve(formula, p, q, r); \n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nchar *pp;\n\nint minus(int x) {\n    return 2-x;\n}\n\nint myand(int x, int y) {\n    if(x*y == 0)\n        return 0;\n    else if((--x)*(--y) == 0)\n        return 1;\n    return 2;\n}\n\nint myor(int x, int y) {\n    if((x-2)*(y-2) == 0)\n        return 2;\n    return x|y;\n}\n\nint formula(void) {\n    switch(*pp) {\n        case '0':\n        case '1':\n        case '2':\n            return *(pp++)-'0';\n        case 'P':\n        case 'Q':\n        case 'R':\n            // error\n            return -999;\n        case '-':\n            pp++;\n            return minus(formula());\n        case '(':\n            int res1, res2;\n            int(*op)(int,int);\n            pp++;\n            res1 = formula();\n            op = *pp++ == '*' ? myand : myor;\n            res2 = formula();\n            pp++;\n            return op(res1,res2);\n        default:\n            // error\n            return -999;\n    }\n}\n\nint main(void) {\n    while(1) {\n        char s[100];\n        scanf(\"%s\",s);\n        if(s[0] == '.') break;\n\n        int res=0;\n        for(int p=0; p<=2; p++)\n            for(int q=0; q<=2; q++)\n                for(int r=0; r<=2; r++) {\n                    char buf[100];\n                    strcpy(buf, s);\n                    for(char *pb=buf; *pb; pb++) {\n                        switch(*pb) {\n                            case 'P':\n                                *pb = '0' + p;\n                                break;\n                            case 'Q':\n                                *pb = '0' + q;\n                                break;\n                            case 'R':\n                                *pb = '0' + r;\n                                break;\n                        }\n                    }\n                    pp=buf;\n                    res += formula() == 2;\n                }\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nstring::const_iterator it;\n\nint memo[3] = {0};\n\nint solve();\nint calc();\nint fact();\nint num();\nvoid consume(char x, char y);\n\nint main() {\n  while(1) {\n    cin >> s;\n    if(s == \".\") break;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 0; i < 3; ++i)\n    for(int j = 0; j < 3; ++j)\n      for(int k = 0; k < 3; ++k) {\n        memo[0] = i;\n        memo[1] = j;\n        memo[2] = k;\n        it = s.begin();\n        if(fact() == 2) ++ans;\n      }\n  return ans;\n}\n\nint calc() {\n  int ans = fact();\n  while(it != s.end()) {\n    int now = 0;\n    bool option = 0;\n    if(*it == '+')\n      option = 1;\n    else if(*it == '*')\n      option = 0;\n    else\n      break;\n    ++it;\n    now = fact();\n    if(option) {\n      if(now == 2 || ans == 2)\n        ans = 2;\n      else\n        ans = (now + ans) > 0;\n    }\n    else {\n      if(now == 0 || ans == 0)\n        ans = 0;\n      else\n        ans = 1 + (now * ans == 4);\n    }\n  }\n  return ans;\n}\n\nint fact() {\n  int ans = 0;\n  if(*it == '(') {\n    ++it;\n    ans = calc();\n    ++it;\n  }\n  else if(*it == '-') {\n    ++it;\n    ans = 2 - fact();\n  }\n  else\n    ans = num();\n  return ans;\n}\n\nint num() {\n  int ans = 0;\n  if(isdigit(*it))\n    ans = *it - '0';\n  else\n    ans = memo[*it - 'P'];\n  ++it;\n  return ans;\n}\n\nvoid consume(char x, char y) {\n  if(*it >= x && *it <= y)\n    ++it;\n  else {\n    cerr << \"error\" << endl;\n    cerr << *it << \" \" << x << \" \" << y << endl;\n    while(it != s.end()) cerr << *it++;\n    cerr << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid replace(string &s, const string &from, const string &to)\n{\n    string::size_type pos = 0;\n\n    while (pos = s.find(from, pos), pos != string::npos) {\n        s.replace(pos, from.length(), to);\n        pos += to.length();\n    }\n}\n\nvoid char_replace(string &s, const char &from, const char &to)\n{\n    for (int i = 0; i < s.size(); i++)\n        if (s[i] == from)\n            s[i] = to;\n}\n\nstring check(string &s)\n{\n    while (s.size() > 1) {\n        replace(s, \"-0\", \"2\"), replace(s, \"-1\", \"1\"), replace(s, \"-2\", \"0\");\n        replace(s, \"(0*0)\", \"0\"), replace(s, \"(0*1)\", \"0\"), replace(s, \"(0*2)\", \"0\");\n        replace(s, \"(1*0)\", \"0\"), replace(s, \"(1*1)\", \"1\"), replace(s, \"(1*2)\", \"1\");\n        replace(s, \"(2*0)\", \"0\"), replace(s, \"(2*1)\", \"1\"), replace(s, \"(2*2)\", \"2\");\n        replace(s, \"(0+0)\", \"0\"), replace(s, \"(0+1)\", \"1\"), replace(s, \"(0+2)\", \"2\");\n        replace(s, \"(1+0)\", \"1\"), replace(s, \"(1+1)\", \"1\"), replace(s, \"(1+2)\", \"2\");\n        replace(s, \"(2+0)\", \"2\"), replace(s, \"(2+1)\", \"2\"), replace(s, \"(2+2)\", \"2\");\n    }\n\n    return s;\n}\n\nint main()\n{\n    string s;\n\n    while (cin >> s, s != \".\") {\n        int cnt = 0;\n\n        for (char p = '0'; p <= '2'; p++)  \n            for (char q = '0'; q <= '2'; q++)\n                for (char r = '0'; r <= '2'; r++) {\n                    string re = s;\n\n                    char_replace(re, 'P', p);\n                    char_replace(re, 'Q', q);\n                    char_replace(re, 'R', r);\n                    \n                    if (check(re) == \"2\")\n                        cnt++;\n                }\n                    \n        cout << cnt << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nstring s;\nint i;\nint P, Q, R;\n\nint formula() {\n  if (s[i] == '(') {\n    i++;\n    int A = formula();\n    char op = s[i++];\n    int B = formula();\n    int tmp;\n    if (op == '*') {\n      if (A == 0 || B == 0) tmp = 0;\n      else if (A == 1 || B == 1) tmp = 1;\n      else tmp = 2;\n    } else {\n      if (A == 2 || B == 2) tmp = 2;\n      else if (A == 1 || B == 1) tmp = 1;\n      else tmp = 0;\n    }\n    i++;\n    return tmp;\n  } else if (s[i] == '-') {\n    i++;\n    int tmp = formula();\n    if (tmp == 0) return 2;\n    if (tmp == 1) return 1;\n    if (tmp == 2) return 0;\n  } else {\n    char ch = s[i];\n    i++;\n    if (ch == 'P') return P;\n    if (ch == 'Q') return Q;\n    if (ch == 'R') return R;\n    return ch - '0';\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> s, s != \".\") {\n    int ans = 0;\n    for (P = 0; P <= 2; P++) {\n      for (Q = 0; Q <= 2; Q++) {\n        for (R = 0; R <= 2; R++) {\n          i = 0;\n          int tmp = formula();\n          ans += tmp == 2;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nchar tmp[100];\nint place;\n\nint m_minus(int num){\n\treturn 2 - num;\n}\n\nint m_op(int a,int b,char c){\n\tif(c == '*')return min(a,b);\n\telse return max(a,b);\n}\n\nint dfs(){\n\tif(tmp[place] == '-'){\n\t\tplace++;\n\t\treturn m_minus(dfs());\n\t}\n\telse if(tmp[place] == '('){\n\t\tplace++;\n\t\tint a = dfs();\n\t\tchar c = tmp[place];\n\t\tplace++;\n\t\tint b = dfs();\n\t\tplace++;\n\t\treturn m_op(a,b,c);\n\t}\n\telse{\n\t\tint ret = tmp[place] - '0';\n\t\tplace++;\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\t\n\tstring str;\n\twhile(cin >> str,str[0] != '.'){\t\t\t\n\t\tint ans = 0;\n\t\t\n\t\tREP(i,3){\n\t\t\tREP(j,3){\n\t\t\t\tREP(k,3){\n\t\t\t\t\tREP(l,str.size()){\n\t\t\t\t\t\tif(str[l] == 'P'){\n\t\t\t\t\t\t\ttmp[l] = '0' + i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(str[l] == 'Q'){\n\t\t\t\t\t\t\ttmp[l] = '0' + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(str[l] == 'R'){\n\t\t\t\t\t\t\ttmp[l] = '0' + k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse tmp[l] = str[l];\n\t\t\t\t\t}\n\t\t\t\t\tplace = 0;\n\t\t\t\t\tif(dfs() == 2){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvoid change(string &s, char x, char b) {\n\trep(i, 0, s.size()) {\n\t\tif (s[i] == x) {\n\t\t\ts[i] = b;\n\t\t}\n\t}\n}\nvector<vector<int>>AND({ { 0,0,0 }, { 0,1,1 }, { 0,1,2 } }), OR({ {0,1,2},{1,1,2},{2,2,2} });\nvector<int>NOT({ 2,1,0 });\nvector<char>vc{ 'P', 'Q', 'R' };\n\nint eval(string &s, int &k) {\n\tdump(s.substr(k));\n\tdump(k);\n\tif (isdigit(s[k])) {\n\t\treturn s[k] - '0';\n\t}\n\telse if (s[k] == '-') {\n\t\treturn NOT[eval(s, ++k)];\n\t}\n\telse if (s[k] == '(') {\n\t\tk++;\n\t\tint a = eval(s, k);\n\t\tdump(a);\n\t\tk++;\n\t\tchar op = s[k];\n\t\tdump(op);\n\t\tk++;\n\t\tint b = eval(s, k);\n\t\tk++;\n\t\tdump(b);\n\t\tif (op == '*') return AND[a][b];\n\t\telse if (op == '+')return OR[a][b];\n\t}\n}\n\nsigned main() {\n\tstring s;\n\twhile (cin >> s, s != \".\") {\n\t\tint cnt(0);\n\t\tfor (char P = '0'; P <= '2'; P++) {\n\t\t\tfor (char Q = '0'; Q <= '2'; Q++) {\n\t\t\t\tfor (char R = '0'; R <= '2'; R++) {\n\t\t\t\t\tstring ex(s);\n\n\t\t\t\t\tchange(ex, 'P', P);\n\t\t\t\t\tchange(ex, 'Q', Q);\n\t\t\t\t\tchange(ex, 'R', R);\n\n\t\t\t\t\tint k(0);\n\t\t\t\t\tif (eval(ex, k) == 2)cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nstring s;\n\nbool is_num(char c) {\n    if ((c >= '0' && c <= '2') || (c >= 'P' && c <= 'R')) return true;\n    else return false;\n}\n\nint func(string t) {\n    for (int i = 0; i < t.size(); i++) {\n        if (t[i] == '-') {\n            t[i-1] = '0'+('2' - t[i-1]);\n            t = t.substr(0,i) + t.substr(i+1); \n            i -= 1;\n        }\n        else if (t[i] == '+') {\n            t[i-2] = '0' + max(t[i-2]-'0', t[i-1]-'0');\n            t = t.substr(0,i-1) + t.substr(i+1);\n            i -= 2;\n        }\n        else if (t[i] == '*') {\n            t[i-2] = '0' + min(t[i-2]-'0', t[i-1]-'0');\n            t = t.substr(0,i-1) + t.substr(i+1);\n            i -= 2;\n        }\n    }\n    return t[0]-'0';\n}\n\nint main(void){\n    while (cin>>s && s != \".\") {\n        for (int i = 0; i < s.size()-1; i++) {\n            if (s[i] == '-' && s[i+1] == '-') s = s.substr(0,i) + s.substr(i+2);\n        }\n        stack<char> st;\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) {\n            if (is_num(s[i])) t += s[i];\n            if (s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '(') st.push(s[i]);\n            if (s[i] == ')') {\n                while (st.top() != '(') t += st.top(), st.pop();\n                st.pop();\n            }\n            if (is_num(s[i]) && st.top() == '-') t += st.top(), st.pop();\n        }\n        s = t;\n        \n        int ans = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    t = s;\n                    for (int l = 0; l < t.size(); l++) {\n                        if (t[l] == 'P') t[l] = '0'+i;\n                        if (t[l] == 'Q') t[l] = '0'+j;\n                        if (t[l] == 'R') t[l] = '0'+k;\n                    }\n                    if (func(t) == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calcNot(int x){\n    if(x == 0){\n        return 2;\n    }\n    if(x == 1){\n        return 1;\n    }\n    return 0;\n}\n\nint calcAnd(int x, int y){\n    if(x == 0 || y == 0){\n        return 0;\n    }\n    if(x == 2 && y == 2){\n        return 2;\n    }\n    return 1;\n}\n\nint calcOr(int x, int y){\n    if(x == 2 || y == 2){\n        return 2;\n    }\n    if(x == 0 && y == 0){\n        return 0;\n    }\n    return 1;\n}\n\nint calc(string s){\n    if((int)s.size() == 1){\n        return stod(s);\n    }\n\n    if(s[0] == '-'){\n        return calcNot(calc(s.substr(1, (int)s.size() - 1)));\n    }\n\n    int lhsStart = 0;\n    int lhsLen = 0;\n    int rhsStart = 0;\n    int rhsLen = 0;\n    int depth = 0;\n    for(int i = 0; i < (int)s.size(); i++){\n\n        char temp = s[i];\n        if(temp == '('){\n            depth++;\n        }\n        else if(temp == ')'){\n            depth--;\n        }\n        else if(depth == 1 && temp == '+'){\n            return calcOr(calc(s.substr(1, i - 1)), calc(s.substr(i + 1, (int)s.size() - i - 2)));\n        }\n        else if(depth == 1 && temp == '*'){\n            return calcAnd(calc(s.substr(1, i - 1)), calc(s.substr(i + 1, (int)s.size() - i - 2)));\n        }\n    }\n\n    return 0;\n}\n\nint main(){\n\n    while(true){\n        string s;\n        cin >> s;\n        if(s == \".\"){\n            break;\n        }\n\n        int ans = 0;\n        for(int p = 0; p <= 2; p++){\n            for(int q = 0; q <= 2; q++){\n                for(int r = 0; r <= 2; r++){\n                    string tempStr = s;\n                    replace(tempStr.begin(), tempStr.end(), 'P', (char)('0' + p));\n                    replace(tempStr.begin(), tempStr.end(), 'Q', (char)('0' + q));\n                    replace(tempStr.begin(), tempStr.end(), 'R', (char)('0' + r));\n\n                    int temp = calc(tempStr);\n                    if(temp == 2){\n                        ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint p, q, r;\n\nint mOr(int x, int y) {\n  if (x == 2 || y == 2) {\n    return 2;\n  }\n  if (x == 0 && y == 0) {\n    return 0;\n  }\n  return 1;\n}\n\nint mAnd(int x, int y) {\n  if (x == 0 || y == 0) {\n    return 0;\n  }\n  if (x == 2 && y == 2) {\n    return 2;\n  }\n  return 1;\n}\n\nint mNot(int x) {\n  if (x == 0) {\n    return 2;\n  }else if (x == 1) {\n    return 1;\n  }else {\n    return 0;\n  }\n}\n\nint solve(string str) {\n  int ret = 0;\n  if (str == \"R\") {\n    return r;\n  }\n  if (str == \"P\") {\n    return p;\n  }\n  if (str == \"Q\") {\n    return q;\n  }\n  if (str == \"2\") {\n    return 2;\n  }\n  if (str == \"1\") {\n    return 1;\n  }\n  if (str == \"0\") {\n    return 0;\n  }\n\n  if (str[0] == '(') {\n    int cnt = 0;\n    string lstr = \"\", rstr = \"\";\n    for (int i = 1; i < str.size(); i++) {\n      if (cnt == 0) {\n\tif (str[i] == '+') {\n\t  int x = solve(lstr);\n\t  for (int j = i+1; j < str.size()-1; j++) {\n\t    rstr += str[j];\n\t  }\n\t  int y = solve(rstr);\n\t  return mOr(x, y);\n\t}\n\tif (str[i] == '*') {\n\t  int x = solve(lstr);\n\t  for (int j = i+1; j < str.size()-1; j++) {\n\t    rstr += str[j];\n\t  }\n\t  int y = solve(rstr);\n\t  return mAnd(x, y);\n\t}\n\tif (str[i] == '(') {\n\t  lstr += str[i];\n\t  cnt++;\n\t}else {\n\t  lstr += str[i];\n\t}\n      }else if (str[i] == '(') {\n\tlstr += str[i];\n\tcnt++;\n      }else if (str[i] == ')') {\n\tlstr += str[i];\n\tcnt--;\n      }else {\n\tlstr += str[i];\n      }\n    }\n  }\n\n  if (str[0] == '-') {\n    ret = mNot(solve(str.substr(1)));\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    string str;\n    cin >> str;\n    if (str == \".\") break;\n\n    int ans = 0;\n    for (int i = 0; i <= 2; i++) {\n      for (int j = 0; j <= 2; j++) {\n\tfor (int k = 0; k <= 2; k++) {\n\t  p = i;\n\t  q = j;\n\t  r = k;\n\t  if (solve(str) == 2) {\n\t    ans++;\n\t  }\n\t}\n      }\n    }\n\n    std::cout << ans << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint P, Q, R;\nconst char *p;\n\nint formula() {\n  \n  p++;\n\n  switch( *p ) {\n  case '-':\n    switch( formula() ) {\n    case 2: return 0;\n    case 1: return 1;\n    case 0: return 2;\n    }\n  case 'P':\n    return P;\n  case 'Q':\n    return Q;\n  case 'R':\n    return R;\n  case '0':\n    return 0;\n  case '1':\n    return 1;\n  case '2':\n    return 2;\n    \n  case '(':\n    int form1 = formula();\n    int form2;\n    p++;\n    switch( *p ) {\n    case '*':\n      form2 = formula();\n      p ++;\n      if( form1 == 0 || form2 == 0 ) return 0;\n      if( form1 == 1 || form2 == 1 ) return 1;\n      else return 2;\n    case '+':\n      form2 = formula();\n      p++;\n      if( form1 == 2 || form2 == 2 ) return 2;\n      if( form1 == 1 || form2 == 1 ) return 1;\n      else return 0;\n    }\n  }\n  \n  return 0;\n}\n\nint main() {\n  string str;\n  \n  while(getline(cin, str)) {\n    int cnt = 0;\n    if( str == \".\" ) break;\n    for(int i=0; i<3; i++) {\n      for(int j=0; j<3; j++) {\n\tfor(int k=0; k<3; k++) {\n\t  P = i, Q = j, R = k;\n\t  p = &str[0]-1;\n\t  if( formula() == 2 ) cnt ++;\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstring s;\nint p;\nint value[128];\n\nint multiply(int x, int y) {\n  if(x == 2 && y == 2) return 2;\n  else if(min(x,y) == 0) return 0;\n  else return 1;\n}\n\nint add(int x, int y) {\n  if(x == 0 && y == 0) return 0;\n  else if(max(x,y) == 2) return 2;\n  else return 1;\n}\n\nint form() {\n  if(s[p] == '-') {\n    ++p;\n    return 2-form();\n  } else if(s[p] == '(') {\n    ++p;\n    int x = form();\n    char c = s[p++];\n    int y = form();\n    ++p;\n    if(c == '*') { // *\n      return multiply(x,y);\n    } else { // +\n      return add(x,y);\n    }\n  } else {\n    return value[s[p++]];\n  }\n}\n\nint main() {\n  value['0'] = 0;\n  value['1'] = 1;\n  value['2'] = 2;\n  while(cin >> s && s != \".\") {\n    s += \"$\";\n    int res = 0;\n    for(int P = 0; P <= 2; ++P) {\n      for(int Q = 0; Q <= 2; ++Q) {\n        for(int R = 0; R <= 2; ++R) {\n          value['P'] = P;\n          value['Q'] = Q;\n          value['R'] = R;\n          p = 0;\n          res += form() == 2;\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n\nusing namespace std;\n\nstruct Node {\n    char v;\n    Node* l = nullptr;\n    Node* r = nullptr;\n    Node(char c)\n        : v{c}\n    {\n    }\n};\n\nint main()\n{\n    while (true) {\n        char ss[100];\n        scanf(\"%s\", ss);\n        if (ss[0] == '.') {\n            break;\n        }\n        string s{ss};\n        int n = 0;\n        function<Node*(const string&)> parse = [&parse, &n](const string& s) {\n            // printf(\"%s\\n\", s.c_str() + n);\n            auto ss = string(\"012PQR\");\n            if (ss.find(s[n]) != string::npos) {\n                auto a = new Node(s[n]);\n                n += 1;\n                return a;\n            }\n            else if (s[n] == '-') {\n                auto a = new Node('-');\n                n += 1;\n                a->l = parse(s);\n                return a;\n            }\n            else if (s[n] == '(') {\n                n += 1;\n                auto l = parse(s);\n                // printf(\"left %c\\n\", l->v);\n                auto v = new Node(s[n]);\n                n += 1;\n                auto r = parse(s);\n                n += 1;\n                v->l = l;\n                v->r = r;\n                return v;\n            }\n            return new Node('!');\n        };\n        auto r = parse(s);\n        function<void(Node*)> p = [&p](Node* n) {\n            if (!n) {\n                return;\n            }\n            if (n->v == '+') {\n                putchar('(');\n                p(n->l);\n                putchar('+');\n                p(n->r);\n                putchar(')');\n            }\n            else if (n->v == '*') {\n                putchar('(');\n                p(n->l);\n                putchar('*');\n                p(n->r);\n                putchar(')');\n            }\n            else if (n->v == '-') {\n                putchar('-');\n                p(n->l);\n            }\n            else {\n                putchar(n->v);\n            }\n        };\n        auto pn = [&p](Node* n) {\n            printf(\"result: \");\n            p(n);\n            putchar('\\n');\n        };\n        // pn(r);\n\n        function<int(const Node*, int, int, int)> f = [&f](const Node* n, int p,\n                                                           int q, int r) {\n            auto and_ = [](int lhs, int rhs) {\n                if (lhs == 0 || rhs == 0) {\n                    return 0;\n                }\n                else if (lhs == 1 || rhs == 1) {\n                    return 1;\n                }\n                else {\n                    return 2;\n                }\n            };\n            auto not_ = [](int lhs) {\n                if (lhs == 0) {\n                    return 2;\n                }\n                else if (lhs == 2) {\n                    return 0;\n                }\n                else {\n                    return 1;\n                }\n            };\n            auto or_ = [](int lhs, int rhs) {\n                if (lhs == 2 || rhs == 2) {\n                    return 2;\n                }\n                else if (lhs == 1 || rhs == 1) {\n                    return 1;\n                }\n                else {\n                    return 0;\n                }\n            };\n            if (n == nullptr) {\n                return 2;\n            }\n            else if (n->v == '*') {\n                return and_(f(n->l, p, q, r), f(n->r, p, q, r));\n            }\n            else if (n->v == '+') {\n                return or_(f(n->l, p, q, r), f(n->r, p, q, r));\n            }\n            else if (n->v == '-') {\n                return not_(f(n->l, p, q, r));\n            }\n            else if (n->v == 'P') {\n                return p;\n            }\n            else if (n->v == 'Q') {\n                return q;\n            }\n            else if (n->v == 'R') {\n                return r;\n            }\n\n            return n->v - '0';\n        };\n        auto count = 0;\n        for (auto i = 0; i <= 2; ++i) {\n            for (auto j = 0; j <= 2; ++j) {\n                for (auto k = 0; k <= 2; ++k) {\n                    auto rr = f(r, i, j, k);\n                    // printf(\"%d %d %d %d\\n\", i, j, j, rr);\n                    if (rr == 2) {\n                        ++count;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\n// <formula> ::= 0 | 1 | 2 | P | Q | R |\n// -<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n\nint eval(string &s,int &i,int P,int Q,int R){\n    char c = s[i];\n    i++;\n    if(isdigit(c)) return c-'0';\n    if(isalpha(c)) return  c=='P' ? P : c=='Q' ? Q : R;\n    if(c == '-') return 2-eval(s,i,P,Q,R);\n    int lv = eval(s,i,P,Q,R);\n    char op = s[i];\n    i++;\n    int rv = eval(s,i,P,Q,R);\n    i++;\n    if(op == '*'){\n        if(lv*rv == 0) return 0;\n        if(lv*rv == 4) return 2;\n        return 1;\n    }\n    if(op == '+'){\n        if(lv+rv == 0) return 0;\n        if(lv== 2 || rv == 2) return 2;\n        return 1;\n    }\n    assert(false);\n}\n\nint main(void){\n    string s;\n    while(cin>>s, s!=\".\"){\n        int cnt = 0;\n        rep(p,3)rep(q,3)rep(r,3){\n            int i = 0;\n            if(eval(s,i,p,q,r)==2) cnt++;\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n//入力\nstring s;\n\nint eval(const string& s, int& pos) {\n\t// 定数の場合\n\tif (s[pos] == '0' || s[pos] == '1' || s[pos] == '2') {\n\t\tint v = s[pos] - '0';\n\t\tpos++;\n\t\treturn v;\n\t}\n\t\n\t// マイナス符号の場合\n\tif (s[pos] == '-') {\n\t\tpos++;\n\t\tint v = eval(s, pos);\n\t\treturn 2 - v;\n\t}\n\t\n\tif (s[pos] == '(') {\n\t\tint v;\n\t\tpos++;\n\t\tint tmp1 = eval(s, pos);\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tint tmp2 = eval(s, pos);\n\t\t\tv = max(tmp1, tmp2);\n\t\t} else if (s[pos] == '*') {\n\t\t\tpos++;\n\t\t\tint tmp2 = eval(s, pos);\n\t\t\tv = min(tmp1, tmp2);\n\t\t}\n\t\tpos++;\n\t\treturn v;\n\t}\n}\n\nvoid solve() {\n\tint ans = 0;\n\t\n\tfor (int p = 0; p <= 2; p++) {\n\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\tstring tmp = s;\n\t\t\t\tfor (int i = 0; i < (int)tmp.length(); i++) {\n\t\t\t\t\t// P, Q, Rを定数0, 1, 2に置換する\n\t\t\t\t\tif (tmp[i] == 'P') {\n\t\t\t\t\t\ttmp[i] = p + '0';\n\t\t\t\t\t} else if (s[i] == 'Q') {\n\t\t\t\t\t\ttmp[i] = q + '0';\n\t\t\t\t\t} else if (s[i] == 'R') {\n\t\t\t\t\t\ttmp[i] = r + '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint pos = 0;\n\t\t\t\t//cout << tmp << endl;\n\t\t\t\tint result = eval(tmp, pos);\n\t\t\t\tif (result == 2) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn;\n}\n\nint main() {\n\twhile (true) {\n\t\tgetline(cin, s);\n\t\tif (s[0] == '.') {\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nmap<char,int> logic;\nstring s;\nint ind;\nint atom()\n{\n  int tmp=logic[s[ind]];\n  ++ind;\n  return tmp;\n}\nint formula()\n{\n  if(s[ind]=='-'){\n    ++ind;\n    return 2-formula();\n  }else if(s[ind]=='('){\n    ++ind;\n    int tmpl=formula();\n    int tmp;\n    if(s[ind]=='+') tmp=0;\n    if(s[ind]=='*') tmp=1;\n    ++ind;\n    int tmpr=formula();\n    ++ind;\n    return tmp ? min(tmpl,tmpr) : max(tmpl,tmpr);\n  }else return atom();\n}\n\nint main(void)\n{\n  int n;\n  REP(i,3)logic['0'+i]=i;\n  while(getline(cin,s)){\n    if(s==\".\") break;\n    int ans=0;\n    REP(p,3) REP(q,3) REP(r,3){\n      logic['P']=p;\n      logic['Q']=q;\n      logic['R']=r;\n      ind=0;\n      if(formula()==2) ++ans;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nconst int se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint number(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tif (isdigit(s[idx]) || s[idx]=='-')\n\t\treturn number(s, idx);\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\treturn val;\n}\nint number(string& s, int &idx) {\n\tint not= 0;\n\twhile (s[idx]=='-')\n\t{\n\t\tnot++;\n\t\tidx++;\n\t}\n\tint val = s[idx] - '0';\n\tidx++;\n\tif (not% 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2){\n\t\t\t\tif(r == 0)\n\t\t\t\t\tr = 2;\n\t\t\t\telse if(r == 2)\n\t\t\t\t\tr = 0;\n\t\t\t}\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2){\n\t\t\t\tif(l == 0)\n\t\t\t\t\tl = 2;\n\t\t\t\telse if(l == 2)\n\t\t\t\t\tl = 0;\n\t\t\t}\n\t\t\tst.pop();\n\t\t\n\t\t\t\n\t\t\tif(o == '*')\n\t\t\t\tst.push((char)(AND[r][l]+'0'));\n\t\t\telse\n\t\t\t\tst.push((char)(OR[r][l]+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\t\n\tif(st.top() == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\t\t\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\t\t\t\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint v[3],now;\nstring s;\n\nint fomula(){\n  now++;\n  if(s[now-1]=='('){\n    int res=fomula();\n    now++;\n    if(s[now-1]=='+')res=max(res,fomula());\n    if(s[now-1]=='*')res=min(res,fomula());\n    now++;\n    return res;\n  }\n  if(isdigit(s[now-1]))return s[now-1]-'0';\n  if(isupper(s[now-1]))return v[s[now-1]-'P'];\n  if(s[now-1]=='-')return 2-fomula();\n}\n\nint main(void){\n\n  while(cin >> s,s!=\".\"){\n    int cnt=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3){\n      now=0;\n      cnt+=2==fomula();\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint inv[3]={2,1,0};\nint sum[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint prod[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nstring s;\nint i;\nint f(int p,int q,int r)\n{\n\tif(s[i]=='-')\n\t{\n\t\ti++;\n\t\treturn inv[f(p,q,r)];\n\t}\n\telse if(s[i]!='(')\n\t{\n\t\tif(s[i]=='P'){i++;return p;}\n\t\telse if(s[i]=='Q'){i++;return q;}\n\t\telse if(s[i]=='R'){i++;return r;}\n\t\telse{i++;return s[i-1]-'0';}\n\t}\n\telse\n\t{\n\t\ti++;\n\t\tint a=f(p,q,r);\n\t\tchar c=s[i++];\n\t\tint b=f(p,q,r);\n\t\ti++;\n\t\tif(c=='*')return prod[a][b];\n\t\telse return sum[a][b];\n\t}\n}\nmain()\n{\n\twhile(cin>>s,s!=\".\")\n\t{\n\t\tint cnt=0;\n\t\tfor(int p=0;p<3;p++)for(int q=0;q<3;q++)for(int r=0;r<3;r++)\n\t\t{\n\t\t\ti=0;\n\t\t\tcnt+=f(p,q,r)==2;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint P, Q, R;\nstring str;\nint pos;\n\nint formula() {\n  pos ++;\n  int f;\n  if(str[pos] == '(') {\n    f = formula(); pos ++;\n    if(str[pos] == '+') {\n      f = max(f, formula());\n    }\n    if(str[pos] == '*') {\n      f = min(f, formula());\n    }\n    pos ++;\n    return f;\n  }\n  \n  if(str[pos] == '-') {\n    return 2-formula();\n  }\n  \n  if(isdigit(str[pos])) {\n    return str[pos]-'0';\n  }\n  \n  if(str[pos] == 'P') return P;\n  if(str[pos] == 'Q') return Q;\n  if(str[pos] == 'R') return R;\n    \n}\n\nint main() {\n  while(cin >> str && str != \".\") {\n    int cnt = 0;\n    for(P=0; P<=2; P++)\n      for(Q=0; Q<=2; Q++)\n\tfor(R=0; R<=2; R++) {\n\t  pos = -1;\n\t  if(formula() == 2) cnt ++;\n\t}\n    \n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring str;\n\nvoid a() {\n  for(int i = 0; i < str.length(); ++i) {\n    if(str[i] != '-') continue;\n    int j;\n    for(j = i+1; j < str.length() && str[j] == '-'; ++j);\n    if(j == i+1) continue;\n    if((j-i) % 2 == 0)\n      str = str.substr(0, i) + str.substr(j, str.length()-j);\n    else\n      str = str.substr(0, i+1) + str.substr(j, str.length()-j);\n  }\n}\n\nvoid b(string &s) {\n  for(int i = 0; i < s.length(); ++i) {\n    if(s[i] == '-') {\n      s = s.substr(0, i) + s.substr(i+1, s.length()-(i+1));\n      s[i] = '2'-(s[i]-'0');\n    }\n  }\n}\n\nint rec(string &, int);\nint rec2(string &, int);\nint rec3(string &, int);\nint pos;\n\nint rec3(string &s, int ans) {\n  int tmp = pos++;\n  if(tmp < s.length() && s[tmp] == '+') return max(ans, rec(s, 0));\n  return ans;\n}\n\nint rec2(string &s, int ans) {\n  int tmp = pos++;\n  if(tmp < s.length() && s[tmp] == '*') return min(ans, rec(s, 0));\n  pos--;\n  return rec3(s, ans);\n}\n\nint rec(string &s,  int ans) {\n  int tmp = pos++;\n  if(tmp < s.length() && s[tmp] == '(') return rec2(s, rec(s, ans));\n  return rec2(s, s[tmp]-'0');\n}\n\nint solve() {\n  int cnt = 0;\n  a();\n  for(char p = '0'; p <= '2'; ++p) {\n    for(char q = '0'; q <= '2'; ++q) {\n      for(char r = '0'; r <= '2'; ++r) {\n\tstring tmp = str;\n\tfor(int i = 0; i < tmp.length(); ++i) {\n\t  if(tmp[i] == 'P') tmp[i] = p;\n\t  if(tmp[i] == 'Q') tmp[i] = q;\n\t  if(tmp[i] == 'R') tmp[i] = r;\n\t}\n\tpos = 0;\n\tb(tmp);\n\tif(rec(tmp, 0) == 2) {\n\t  cnt++;\n\t}\n      }\n    }\n  }\n  return cnt;\n}\n\nmain() {\n  while((cin >> str) && str != \".\") {\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include <vector>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n//構文を実際に計算する\nbool play(const string& s) {\n\tstack<char> info;\n\tfor (const char& c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(const string& formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\nusing namespace std;\n\nstring s,t;\nint a,p;\n\nint A(int x){return x==2?0:x==1?1:2;}\nint B(int x,int y){return x==0||y==0?0:x==1||y==1?1:2;}\nint C(int x,int y){return x==2||y==2?2:x==1||y==1?1:0;}\nint E(){\n\twhile(s[p]==')')p++;\n\tif(s[p]!='('){\n\t\tint q=p;\n\t\twhile(s[p]=='-')p++;\n\t\tq=(p-q)%2;\n\t\tif(s[p]=='(') return q?A(E()):E();\n\t\telse return q?A(s[p]-'0'):s[p]-'0';\n\t}\n\tint x,y;char z;\n\tp++;x=E();p++;z=s[p];p++;y=E();p++;\n\treturn z!='+'?B(x,y):C(x,y);\n}\n\nint main(){\n\twhile(cin>>t,t!=\".\"){\n\t\ta=0;\n\t\trep(i,3)rep(j,3)rep(k,3){\n\t\t\tp=0;\n\t\t\ts=t;\n\t\t\trep(v,s.size())s[v]=s[v]=='P'?'0'+i:s[v]=='Q'?'0'+j:s[v]=='R'?'0'+k:s[v];\n\t\t\tif(E()==2)a++;\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\npair<int,int> val(std::string f) {\n  if(f[0] == '-') {\n    auto p = val(f.substr(1));\n    return mp(2-p.first,p.second+1);\n  }else if(f[0] == '(') {\n    auto p1 = val(f.substr(1));\n    auto p2 = val(f.substr(p1.second+2));\n    if(f[p1.second+1] == '*') {\n      return mp(min(p1.first,p2.first),p1.second+p2.second+3);\n    }else{\n      return mp(max(p1.first,p2.first),p1.second+p2.second+3);\n    }\n  }else{\n    int v = f[0] - '0';\n    return mp(v,1);\n  }\n}\n\nint main(void) {\n  while(1) {\n    string str;\n    cin>>str;\n    if(str==\".\")break;\n    int count =0;\n    REP(i,3)REP(j,3)REP(k,3){\n      string cp = str;\n      for(char& c : cp){\n        switch(c){\n          case 'P':\n          c=i+'0';\n          break;\n          case 'Q':\n          c=j+'0';\n          break;\n          case 'R':\n          c=k+'0';\n          break;\n        }\n      }\n      if(val(cp).first == 2)\n        ++count;\n    }\n    cout<<count<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstring s;\nint i,j,k,p,ans;\n \nint calc(){\n  char c=s[p++];\n  if('0'<=c&&c<='9')return (c-'0');\n  else if(c=='P')return i;\n  else if(c=='Q')return j;\n  else if(c=='R')return k;\n  else if(c=='-'){\n    return 2-calc();\n  }else if(c=='('){\n    int a=calc();\n    char ch=s[p++];\n    int b=calc();\n    p++;\n    if(ch=='*')return min(a,b);\n    else if(ch=='+')return max(a,b);\n  }\n  return 0;\n}\n \n \nvoid solve(){\n  p=0;\n  if(calc()==2)ans++;\n}\nint main(){\n  while(1){\n    cin>>s;\n    if(s==\".\")break;\n    ans=0;\n    for(i=0;i<3;i++)\n      for(j=0;j<3;j++)\n        for(k=0;k<3;k++)\n          solve();\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nint P, Q, R;\nconst char *p;\n \nint formula() {\n   \n  p++;\n \n  switch( *p ) {\n  case '-': return 2 - formula();\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  case '0': return 0;\n  case '1': return 1;\n  case '2': return 2;\n     \n  case '(':\n    int form1 = formula();\n    int form2;\n    p++;\n    switch( *p ) {\n    case '*':\n      form2 = formula();\n      p ++;\n      return min( form1, form2 );\n    case '+':\n      form2 = formula();\n      p++;\n      return max( form1, form2 );\n    }\n  }\n   \n  return 0;\n}\n \nint main() {\n  string str;\n   \n  while(getline(cin, str)) {\n    int cnt = 0;\n    if( str == \".\" ) break;\n    for(int i=0; i<3; i++) {\n      for(int j=0; j<3; j++) {\n    for(int k=0; k<3; k++) {\n      P = i, Q = j, R = k;\n      p = &str[0]-1;\n      if( formula() == 2 ) cnt ++;\n    }\n      }\n    }\n     \n    cout << cnt << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,n) for(int i=a;i<n;i++)\n#define REP(i,n) FOR(i,0,n)\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\n#define ALL(a) a.begin(),a.end()\n\nint mynot(int n){\n\tswitch(n){\n\tcase 0:return 2;\n\tcase 1:return 1;\n\tcase 2:return 0;\n\tdefault:assert(0);\n\t}\n}\nint myand(int x,int y){\n\tswitch(x){\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn (y==0?0:1);\n\tcase 2:\n\t\treturn y;\n\tdefault:\n\t\tassert(0);\n\t}\n}\nint myor(int x,int y){\n\tswitch(x){\n\tcase 0:\n\t\treturn y;\n\tcase 1:\n\t\treturn (y==2?2:1);\n\tcase 2:\n\t\treturn 2;\n\tdefault:\n\t\tassert(0);\n\t}\n}\nint n;\nint go(string s,int p,int q,int r){\n\tint a,b,sign,v;\n\tswitch(s[n]){\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\t\tv=s[n];\n\t\tn++;\n\t\treturn v-'0';\n\tcase 'P':\n\t\tn++;\n\t\treturn p;\n\tcase 'Q':\n\t\tn++;\n\t\treturn q;\n\tcase 'R':\n\t\tn++;\n\t\treturn r;\n\tcase '-':\n\t\tn++;\n\t\treturn mynot(go(s,p,q,r));\n\tcase '(':\n\t\tn++;\n\t\ta=go(s,p,q,r);\n\t\tsign=s[n];\n\t\tn++;\n\t\tb=go(s,p,q,r);\n\t\tn++;\n\t\tswitch(sign){\n\t\tcase '*':\n\t\t\treturn myand(a,b);\n\t\tcase '+':\n\t\t\treturn myor(a,b);\n\t\t}\n\tcase ')':\n\tdefault:\n\t\tassert(0);\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\".\"){\n\t\tint ans=0;\n\t\tREP(p,3)REP(q,3)REP(r,3){\n\t\t\tn=0;\n\t\t\tif(go(s,p,q,r)==2){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include\"bits/stdc++.h\"\n#define INF          1e9\n#define INFLL        1e18\n#define EPS          1e-9\n#define MOD          1000000007\n#define REP(i,n)     for(ll i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)    for(ll i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)    for(ll i=(n)-1;i>=0;--i)\n#define REPR1(i,n)   for(ll i=(n);i>0;--i)\n#define REPC(i,obj)  for(auto i:obj)\n#define ALL(obj)     (obj).begin(),(obj).end()\n#define SETP(n)      cout<<fixed<<setprecision(n)\n#define VV(T,h,w)    vector<vector<T>>(h,vector<T>(w))\n#define VVI(T,h,w,i) vector<vector<T>>(h,vector<T>(w,i))\nusing namespace std;\nusing ll = long long;\ntemplate<typename T = ll>inline T in() { T ret; cin >> ret; return ret; }\n\nusing state=string::const_iterator;\nll expr(state &);\nll term(state &);\nll fuct(state &);\nll expr(state &s)\n{\n    ll ret = term(s);\n    while (true) {\n        char opr = *(s++);\n        if (opr == '+') {\n            ll arg = term(s);\n            if (ret == 2 || arg == 2)ret = 2;\n            else if (ret == 1 || arg == 1)ret = 1;\n            else ret = 0;\n        } else if (opr == '*') {\n            ll arg = term(s);\n            if (ret == 0 || arg == 0)ret = 0;\n            else if (ret == 1 || arg == 1)ret = 1;\n            else ret = 2;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\nll term(state & s)\n{\n    if (*s == '-') {\n        ++s;\n        return 2 - term(s);\n    } else {\n        return fuct(s);\n    }\n}\nll fuct(state & s)\n{\n    if (*s == '(') {\n        ++s;\n        ll ret = expr(s);\n        return ret;\n    } else if (isdigit(*s)) {\n        ll ret = *s - '0';\n        ++s;\n        return ret;\n    }\n}\nint main()\n{\n    while (true) {\n        string inp = in<string>();\n        if (inp[0] != '.') {\n            ll ans = 0;\n            for (char p = '0'; p <= '2'; ++p) {\n                for (char q = '0'; q <= '2'; ++q) {\n                    for (char r = '0'; r <= '2'; ++r) {\n                        string exstr = inp;\n                        replace(ALL(exstr), 'P', p);\n                        replace(ALL(exstr), 'Q', q);\n                        replace(ALL(exstr), 'R', r);\n                        auto s = exstr.cbegin();\n                        ans += expr(s) == 2;\n                    }\n                }\n            }\n            cout << ans << endl;\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint rev[3] = {2,1,0};\nint seki[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint wa[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nint f(const string &s, int b, int e){ // [begin,end]\n    int ind = -1;\n    int nest = 0;\n    loop(i,b,e){\n        if(s[i] == '(') nest++;\n        if(s[i] == ')') nest--;\n        if((s[i] == '*' || s[i] == '+') && nest == 0)  ind = i;\n    }\n    int ret = -1;\n    if(ind < 0){\n        if(s[b] == '(' && s[e] == ')'){\n            return f(s, b+1, e-1);\n        }\n        int t = 0;\n        while(s[b] == '-')b++,t++;\n        if(s[b] == '(')\n            ret = f(s,b+1,e);\n        else\n            ret = s[b] - '0';\n        if(t%2)ret = rev[ret];\n        //cout << b <<\" \" << e << \" \" <<ret <<endl;\n        return ret;\n    }else{\n        ret = f(s, b, ind-1);\n        if(s[ind] == '+') ret = wa[ret][f(s,ind+1,e)];\n        else ret = seki[ret][f(s,ind+1,e)];\n    //    cout << b << \" \" << e <<\" \" <<ret << endl;\n        return ret;\n    }\n}\n\nint solve(string s, int a, int b, int c){\n    int n = s.size();\n    rep(i,n){\n        if(s[i] == 'P') s[i] = '0' + a;\n        if(s[i] == 'Q') s[i] = '0' + b;\n        if(s[i] == 'R') s[i] = '0' + c;\n    }\n    //cout << s << endl;\n    int ret = f(s, 0, n-1);\n    //cout << ret << endl;\n    return ret;\n}\n\nint main(void) {\n  string s;\n  while(cin >> s, s != \".\"){\n      int ans = 0;\n      rep(i,3)rep(j,3)rep(k,3){\n          //cout << i << \" \" << j << \" \" << k <<endl;\n          if(solve(s,i,j,k) == 2)ans++;\n        //  cout << solve(s,i,j,k) << endl;\n      }\n      cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\n\nvoid assume(State &begin, char expected) {\n    // cerr << \"assume: \" << *begin << \" \" << expected << endl;\n    assert(*begin == expected);\n    begin++;\n}\n\nint term(State&, vi);\nint formula(State&, vi);\n\nint term(State &begin, vi v) {\n    // cerr << \"term: \" << *begin << endl;\n    int ret = formula(begin, v);\n\n    if (*begin == '*') {\n        begin++;\n        ret = min(ret, formula(begin, v));\n    } else {\n        assume(begin, '+');\n        ret = max(ret, formula(begin, v));\n    }\n\n    return ret;\n}\n\nint formula(State &begin, vi v) {\n    // cerr << \"formula: \" << *begin << endl;\n    int ret;\n\n    if (isdigit(*begin)) {\n        ret = *begin - '0';\n        begin++;\n    } else if (isalpha(*begin)) {\n        ret = v[*begin - 'P'];\n        begin++;\n    } else if (*begin == '-') {\n        begin++;\n        ret = 2 - formula(begin, v);\n    } else {\n        assume(begin, '(');\n        ret = term(begin, v);\n        assume(begin, ')');\n    }\n\n    return ret;\n}\n\nint solve(string s) {\n    int ret = 0;\n    rep(i, 27) {\n        // cerr << \"i = \" << i << \":\" << endl;\n        State begin = s.begin();\n        vi v({i % 3, (i / 3) % 3, i / 9});\n        if (formula(begin, v) == 2) {\n            ret++;\n        }\n    }\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    int t = 0;\n    while (cin >> s, s[0] - '.') {\n        // cerr << \"--- t = \" << t++ << \" ---\"<< endl;\n        cout << solve(s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint ans=0;\n\ntypedef string::const_iterator State;\n\n\nll andop(ll l,ll r){\n\tif(l==0||r==0)return 0;\n\tif(l==1||r==1)return 1;\n\treturn 2;\n}\n\nll orop(ll l,ll r){\n\tif(l==2||r==2)return 2;\n\tif(l==1||r==1)return 1;\n\treturn 0;\n}\n\nll notop(ll l){\n\tif(l==0)return 2;\n\tif(l==2)return 0;\n\treturn 1;\n}\n\nll exp(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tll left = exp(begin);\n\t\tchar op = *begin;\n\t\tbegin++;\n\t\tll right= exp(begin);\n\t\tbegin++;\t//read ')'\n\t\tif(op=='*'){\n\t\t\treturn andop(left,right);\n\t\t}else if(op=='+'){\n\t\t\treturn orop(left,right);\n\t\t}\n\t}else if(*begin=='-'){\n\t\tbegin++;\n\t\treturn notop(exp(begin));\n\t}else{\n\t\tassert(isdigit(*begin));\n\t\tll ret = *begin-'0';\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tans=0;\n\t\trep(i,3){\n\t\t\trep(j,3){\n\t\t\t\trep(k,3){\n\t\t\t\t\tstring tmp = s;\n\t\t\t\t\trep(l,tmp.size()){\n\t\t\t\t\t\tif(tmp[l]=='P')tmp[l]='0'+i;\n\t\t\t\t\t\tif(tmp[l]=='Q')tmp[l]='0'+j;\n\t\t\t\t\t\tif(tmp[l]=='R')tmp[l]='0'+k;\n\t\t\t\t\t}\n\t\t\t\t\tState begin = tmp.begin();\n\t\t\t\t\tif(exp(begin)==2)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p, q, r, cursor;\nstring s;\n\nint Not(int a) {\n\treturn 2 - a;\n}\n\nint and(int a, int b) {\n\tif(a == 0 || b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint or(int a, int b) {\n\tif(a == 2 || b == 2) return 2;\n\tif(a == 1 || b == 1) return 1;\n\treturn 0;\n}\n\nint f() {\n\tchar c = s[cursor];\n\tcursor++;\n\tif(c == '0') return 0;\n\tif(c == '1') return 1;\n\tif(c == '2') return 2;\n\tif(c == 'P') return p;\n\tif(c == 'Q') return q;\n\tif(c == 'R') return r;\n\tif(c == '-') return Not(f());\n\tif(c == '(') {\n\t\tint a = f();\n\t\tchar op = s[cursor];\n\t\tcursor++;\n\t\tint b = f();\n\t\tcursor++;\n\t\tif(op == '*') {\n\t\t\treturn and(a, b);\n\t\t}\n\t\telse {\n\t\t\treturn or(a, b);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> s, s[0] != '.') {\n\t\tint ans = 0;\n\t\tfor(p = 0; p <= 2; p++) {\n\t\t\tfor(q = 0; q <= 2; q++) {\n\t\t\t\tfor(r = 0; r <= 2; r++) {\n\t\t\t\t\tcursor = 0;\n\t\t\t\t\tif(f() == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar sb[100];\nchar s[100];\nbool ch(int,int,int);\nint stsy(char*,int,int,int);\nint pr(int,int);\nint ka(int,int);\nint main(){\n  while(1){\n    cin >> sb;\n    if(s[0]=='.')break;\n    int co=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<100;l++){\n\t    s[l]=sb[l];\n\t  }\n\t  int ans;\n\t  ans=stsy(s,i,j,k);\n\t  if(ans==2)\n\t    co++;\n\t}\n      }\n    }\n    cout << co << endl;\n  }\n  return 0;\n}\n/*bool ch(int a,int b,int c){\n  int re;\n  re=stsy(s,0,1,2);\n  cout << a <<\" \"<< b <<\" \"<<c <<\" \" << re << endl;\n  if(re==2)return 1;\n  return 0;\n}\n*/\nint stsy(char* cp,int p,int q,int r){\n  //static int cou=0;\n  //cou++;\n  //cout << cou<< endl;\n  int d=-1;\n  int d2=-1;\n  int mi=0;\n  int t=0;\n  int x=0;\n  while(1){\n    //cout << *cp << endl;\n    if(*cp==')'||*cp=='\\0')return d2;\n    else if(*cp=='('){\n      d=stsy(cp+1,p,q,r);\n      for(;*cp!=')';cp++);\n      *cp='x';\n      cp++;\n    }\n    else if(*cp=='-'){\n      if(mi==0)mi=1;\n      else mi=0;\n    }\n    else if(*cp=='P')d=p;\n    else if(*cp=='Q')d=q;\n    else if(*cp=='R')d=r;\n    else if(*cp=='0')d=0;\n    else if(*cp=='1')d=1;\n    else if(*cp=='2')d=2;\n    else if(*cp=='+')t=1;\n    else if(*cp=='*')x=1;\n    //\n    if(d!=-1&&mi==1){\n      if(d==2)d=0;\n      else if(d==0)d=2;\n    }\n    if(t==1&&d!=-1){\n      d2=pr(d,d2);\n      d=-1;\n      t=0;\n    }\n    if(x==1&&d!=-1){\n      d2=ka(d,d2);\n      d=-1;\n      x=0;\n    }\n    if(d!=-1){\n      d2=d;\n    }\n    d=-1;\n    cp++;\n  }    \n}\nint pr(int a,int b){\n  // cout << \"tasu\" << endl;\n  if(a==0)return b;\n  if(a==2||b==2)return 2;\n  return 1;\n}\nint ka(int a,int b){\n  //  cout << \"kakeru\" << endl;\n  // cout << a << b << endl;\n  if(a==0||b==0)return 0;\n  if(a==2&&b==2)return 2;\n  return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\nint eval(const string& s, int &pos)\n{\n\tif(s[pos] == '0') { ++pos; return 0; }\n\tif(s[pos] == '1') { ++pos; return 1; }\n\tif(s[pos] == '2') { ++pos; return 2; }\n\tif(s[pos] == '-') { ++pos; int v = eval(s, pos); return 2 - v;}\n\tif(s[pos] == '(') {\n\t\t++pos;\n\t\tint a = eval(s,pos);\n\t\t// evalの値には計算済みの値が帰ってくるはずだ\n\t\tchar c = s[pos++];\n\t\tint b = eval(s,pos);\n\t\t++pos;\n\t\tif(c == '*') {return (a * b + 1) / 2; }\n\t\tif(c == '+') {return max(a, b); }\n\t\tcout << s[pos];\n\t\tabort();\n\t}\n\treturn 2;\n}\n\n\n\nint main (void)\n{\n\twhile(true)\n\t{\n\t\tstring s, temp;\n\t\tcin >> s;\n\t\tif(s == \".\") break;\n\t\tstring p, q, r;\n\t\tint count = 0;\n\t\tint pos;\n\t\t\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tif(j == 0) p = '0'; if(j == 1) p = '1'; if(j == 2) p = '2';\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tif(k == 0) q = '0'; if(k == 1) q = '1'; if(k == 2) q = '2';\n\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\tif(l == 0) r = '0'; if(l == 1) r = '1'; if(l == 2) r = '2';\n\t\t\t\t\ttemp = s;\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\t\t\t\tif(s.at(i) == 'P') { temp.replace(i, 1, p); }\n\t\t\t\t\t\tif(s.at(i) == 'Q') { temp.replace(i, 1, q); }\n\t\t\t\t\t\tif(s.at(i) == 'R') { temp.replace(i, 1, r); }\n\t\t\t\t\t}\n\t\t\t\t\tif(eval(temp, pos) == 2) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint p,q,r;\n\nchar perse(string x){\n  string tmp;\n  int n,c;\n  char op,a,b;\n  if(x[0] == '-'){\n    x.erase(x.begin());\n    return '0' + '2' - perse(x);\n  }\n  if(x[0] == '('){\n    tmp.clear();\n    n = 1;\n    c = 0;\n    while( c || (x[n] != '+' && x[n] != '*') ){\n      if(x[n] == '(')c++;\n      if(x[n] == ')')c--;\n      tmp.push_back(x[n]);\n      n++;\n    }\n    a = perse(tmp);\n    op = x[n];\n\n    tmp.clear();\n    n++;\n    while( c || x[n] != ')' ){\n      if(x[n] == '(')c++;\n      if(x[n] == ')')c--;\n      tmp.push_back(x[n]);\n      n++;\n    }\n    b = perse(tmp);\n\n    if(op == '+'){\n      if(a=='2' || b=='2')return '2';\n      else if(a=='1' || b=='1')return '1';\n      else return '0';\n    }else if(op == '*'){\n      if(a=='0' || b=='0')return '0';\n      else if(a=='1' || b=='1')return '1';\n      else return '2';\n    }\n  }\n\n  if(x[0] == 'P')return '0' + p;\n  if(x[0] == 'Q')return '0' + q;\n  if(x[0] == 'R')return '0' + r;\n\n  return x[0];\n}\n \nint main(){\n\n  int c;\n  string s;\n\n  while(1){\n    cin >> s;\n    if(s==\".\")break;\n\n    c = 0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  if(perse(s) == '2')c++;\n\t}\n      }\n    }\n\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\nint oror(int x,int y)\n{\n\tif(x==2 || y==2)\n\t\treturn 2;\n\telse\n\t\treturn x|y;\n}\n\nint andand(int x,int y)\n{\n\tif(x==1 && y==1)\n\t\treturn 1;\n\telse\n\t\treturn x*y/2;\n}\n\nint notnot(int x)\n{\n\tswitch(x)\n\t{\n\t\tcase 0:\n\t\treturn 2;\n\t\tcase 1:\n\t\treturn 1;\n\t\tcase 2:\n\t\treturn 0;\n\t}\n\treturn x;\n}\n\n//1重の()で囲われた式を計算する\nP hyouka(string s,int ind,int a,int b,int c)\n{\n\tint ret=0;\n\twhile(ind<s.size())\n\t{\n\t\t//cerr<<ind<<endl;\n\t\tif(s[ind]=='(')\n\t\t{\n\t\t\t//()演算の場合\n\t\t\tind++;\n\t\t\tP p=hyouka(s,ind,a,b,c);//これで左辺が取れる\n\t\t\tint hi=p.first;\n\t\t\tbool op=true;\n\t\t\tif(s[p.second]=='+')\n\t\t\t\top=true;\n\t\t\telse if(s[p.second]=='*')\n\t\t\t\top=false;\n\t\t\tind=p.second+1;\n\t\t\tp=hyouka(s,ind,a,b,c);//右辺を取る\n\t\t\tint mi=p.first;\n\t\t\tind=p.second;\n\t\t\tif(op)\n\t\t\t\tret=oror(hi,mi);\n\t\t\telse\n\t\t\t\tret=andand(hi,mi);\n\t\t}else if(s[ind]=='-'){\n\t\t\t//-の場合\n\t\t\tP p=hyouka(s,ind+1,a,b,c);\n\t\t\tret=notnot(p.first);\n\t\t\tind=p.second;\n\t\t}else if(s[ind]=='P'){\n\t\t\t//変数の場合\n\t\t\tret=a;\n\t\t\tind++;\n\t\t}else if(s[ind]=='Q'){\n\t\t\tret=b;\n\t\t\tind++;\n\t\t}else if(s[ind]=='R'){\n\t\t\tret=c;\n\t\t\tind++;\n\t\t}else if(s[ind]>='0' && s[ind]<='2'){\n\t\t\t//定数の場合\n\t\t\tret+=s[ind]-'0';\n\t\t\tind++;\n\t\t}else if(s[ind]==')'){\n\t\t\tind++;\n\t\t\tbreak;\n\t\t}else{\n\t\t\t//記号の場合\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn P(ret,ind);\n}\n\nint main()\n{\n\tstring s;\n\twhile(1)\n\t{\n\t\tcin>>s;\n\t\tint ans=0;\n\t\tif(s==\".\")\n\t\t\tbreak;\n\t\t//cerr<<hyouka(s,0,1,1,1).first<<endl;\n\t\tfor(int p=0;p<3;p++)\n\t\t{\n\t\t\tfor(int q=0;q<3;q++)\n\t\t\t{\n\t\t\t\tfor(int r=0;r<3;r++)\n\t\t\t\t{\n\t\t\t\t\tif(hyouka(s,0,p,q,r).first==2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nstring in;\nint pos;\nint p,q,r;\n\nint formula(){\n  if(isdigit(in[pos])){\n    return in[pos++]-'0';\n  }\n\n  switch(in[pos]){\n  case 'P':++pos; return p;\n  case 'Q':++pos; return q;\n  case 'R':++pos; return r;\n  }\n\n  if(in[pos]=='-'){\n    ++pos;\n    return 2-formula();\n  }\n  ++pos;\n  int a=formula();\n  char cc=in[pos++];\n  int b=formula();\n  pos++;\n  if(cc=='+'){\n    if(a==2 || b==2)return 2;\n    if(!a && !b)return 0;\n    return 1;\n  }\n  if(!a || !b)return 0;\n  if(a==2 && b==2)return 2;\n  return 1;\n}\n\n\nmain(){\n  while(cin>>in){\n    if(in==\".\")break;\n    int ans=0;\n    for(p=0;p<3;p++)for(q=0;q<3;q++)for(r=0;r<3;r++){\n      pos=0;\n      if(formula()==2)++ans;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp\n\n \n\tsorce: ICPC Domestic 2008\t\n\n\t構文解析の問題。\n\n\t<formula> ::= 0 | 1 | 2 | P | Q | R |\n              -<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n\n\t下のように書き換え\n\n\t<expr>::=<term1><op><term1>|<term1>\n\t<term1>::='-'<term1>|<term2>\n\t<term2>::='('<expr>')'|0|1|2\n\n\t文字の部分は数字に置き換え、全探索。\n*/\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int _and[3][3] = { \n\t\t\t\t{ 0, 0, 0 },\n\t\t\t\t{ 0, 1, 1 },\n\t\t\t\t{ 0, 1, 2 } };\nconst int _or[3][3] = {\n\t\t\t\t{ 0, 1, 2 },\n\t\t\t\t{ 1, 1, 2 },\n\t\t\t\t{ 2, 2, 2 } };\n\nconst int _not[3] = { 2, 1, 0 };\nstring s;\nint idx;\n\nint term1 (void );\nint term2 (void );\nint expr (void );\n\nint term1 (void ){\n\tif (s[idx] == '-' ){\n\t\tidx++;\n\t\treturn _not[term1()];\n\t}else return term2();\n}\n\nint term2 (void ){\n\tint res = 0;\n\tif (s[idx] == '(' ){\n\t\tidx++;\n\t\tres = expr ();\n\t\tidx++;\n\t}else{\n\t\treturn (s[idx] - '0' );\n\t} // end if\n\n\treturn res;\n}\n\nint expr (void ){\n\tint a = term1 ();\n\twhile (idx < s.size() && s[idx] != ')' ){\n\t\tchar op = s[idx++];\n\t\tint b = term1 ();\n\t\tswitch (op ){\n\t\t\tcase '*': a = _and[a][b]; break;\n\t\t\tcase '+': a = _or[a][b]; break;\n\t\t} // end switch\n\t} // end if\n\n\treturn a;\n}\n\nint parse (void ){\n\t\n\tidx = 0;\n\tint res = expr ();\n\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\n\tstring str = \"\";\n\twhile (cin >> str, str != \".\" ){\n\t\tint res = 0;\n\t\tint n = str.length();\n\t\trep (p, 3 ){\n\t\t\tstring s1 = str;\n\t\t\trep (i, n ) if (s1[i] == 'P' ) s1[i] = (char)('0'+p);\n\t\t\trep (q, 3 ){\n\t\t\t\tstring t1 = s1;\n\t\t\t\trep (i, n ) if (t1[i] == 'Q' ) t1[i] = (char)('0'+q);\n\t\t\t\trep (r, 3 ){\n\t\t\t\t\ts = t1;\n\t\t\t\t\trep (i, n ) if (s[i] == 'R' ) s[i] = (char )('0'+r);\n\t\t\t\t\tint ans = parse ();\n//\t\t\t\t\tcerr << s << '=' << ans << endl;\n\t\t\t\t\tif (ans == 2 ) res++;\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tcout << res << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef int value;\n\nstring s;\nsize_t cur = 0;\nvalue P, Q, R;\nint ans = 0;\n\nvalue formula();\n\nvalue not(){\n\tassert(s[cur] == '-');\n\tcur++;\n\treturn 2 - formula();\n}\nvalue and(value a, value b){\n\treturn (a<b) ? a : b;\n}\nvalue or(value a, value b){\n\treturn (a<b) ? b : a;\n}\nvalue formula(){\n\tvalue a, b, f;\n\tchar op;\n\tswitch (s[cur]){\n\tcase ('0') :\n\tcase ('1') :\n\tcase ('2') :\n\t\t\t   f = s[cur] - '0';\n\t\tcur++;\n\t\tbreak;\n\tcase ('P') :\n\t\tf = P;\n\t\tcur++;\n\t\tbreak;\n\tcase ('Q') :\n\t\tf = Q;\n\t\tcur++;\n\t\tbreak;\n\tcase ('R') :\n\t\tf = R;\n\t\tcur++;\n\t\tbreak;\n\tcase ('-') :\n\t\tf = not();\n\t\tbreak;\n\tcase ('(') :\n\t\tcur++;\n\t\ta = formula();\n\t\tassert(s[cur] == '*' || s[cur] == '+');\n\t\top = s[cur];\n\t\tcur++;\n\t\tb = formula();\n\t\tf = (op == '*') ? and(a, b) : or(a, b);\n\t\tassert(s[cur] == ')');\n\t\tcur++;\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t\tbreak;\n\t}\n\treturn f;\n}\nint main(){\n\tcin >> s;\n\twhile (s != \".\"){\n\t\tfor (P = 0; P <= 2; P++)\n\t\t\tfor (Q = 0; Q <= 2; Q++)\n\t\t\t\tfor (R = 0; R <= 2; R++){\n\t\t\t\t\tif (formula() == 2)ans++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tcin >> s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) { ll d = euclid(b, a % b, y, x);\n        return y -= a/b * x, d; }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1) ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1); return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e) return Mod(1);\n        Mod r = *this ^ (e / 2); r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nstruct th {\n    int a, b, c;\n    const bool operator<(const th& t) const {\n        return a != t.a ? a < t.a : b != t.b ? b < t.b : c < t.c;\n    }\n};\n\nchar neg(char x) {\n    return '0' + (2 - (x - '0'));\n}\nchar add(char x, char y) {\n    return max(x, y);\n}\nchar mul(char x, char y) {\n    return min(x, y);\n}\n\nint eval(string expr, int p, int q, int r) {\n    for (char &c : expr) switch(c) {\n        case 'P': c = '0' + p; break;\n        case 'Q': c = '0' + q; break;\n        case 'R': c = '0' + r; break;\n    }\n//    cout << expr << endl;\n    vector<char> sym;\n    for (char c : expr) {\n        if (c == '(') sym.push_back(c);\n        if (c == ')') sym.erase(sym.end() - 2);\n        if (c == '-') {\n            if (sym.size() && sym.back() == '-') sym.pop_back();\n            else sym.push_back('-');\n        }\n        if (c == '+') sym.push_back('+');\n        if (c == '*') sym.push_back('*');\n        if (c == '0' || c == '1' || c == '2') {\n            sym.push_back(c);\n        }\n        bool nomod = false;\n        while (!nomod && sym.size() && (sym.back() == '0' || sym.back() == '1' || sym.back() == '2')) {\n            char c = sym.back(); sym.pop_back();\n            if (sym.size() && sym.back() == '-') sym.pop_back(), c = neg(c);\n            if (sym.size() && sym.back() == '+') {\n                sym.pop_back();\n                c = add(sym.back(), c);\n                sym.pop_back();\n                sym.push_back(c);\n            }\n            else if (sym.size() && sym.back() == '*') {\n                sym.pop_back();\n                c = mul(sym.back(), c);\n                sym.pop_back();\n                sym.push_back(c);\n            }\n            else sym.push_back(c), nomod = true;\n        }\n//        for (char d : sym) cout << d; cout << \" -> \";\n    }\n//    cout << endl;\n    return sym.back() - '0';\n}\n\nint main() {\n    cin.sync_with_stdio(0); cin.tie(0); cin.exceptions(cin.failbit);\n\n    while (true) {\n        string s; cin >> s;\n        if (s == \".\") break;\n        int ans = 0;\n        rep(p, 0, 3) rep(q, 0, 3) rep(r, 0, 3) ans += eval(s, p, q, r) == 2;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\n \nstring s;\nint it;\n\n\nint kakko(){\n\tif(s[it]=='('){\n\t\n\tit++;\n\t\tint r=kakko();\n\t\tchar c=s[it];\n\t\tit++;\n\t\tint rr=kakko();\n\t\tit++;\n\t\t\n\t\tif(c=='*') return min(r,rr);\n\t\telse return max(r,rr);\n\t}\n\telse if(s[it]=='-'){\n\t\tit++;\n\t\treturn 2-kakko();\n\t}\n\telse {\n\t\tit++;\n\t\treturn s[it-1]-'0';\n\t}\n}\n\n\nsigned main(){\n\n\twhile(1){\n\t\tstring t;\n\t\tcin>>t;\n\t\tint ans=0;\n\t\t\n\t\tif(t==\".\") return 0;\n\t\t\n\t\tint l=t.length();\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++){\n\t\t\ts=t;\n\t\t\tit=0;\n\t\t\t\n\t\t\tfor(int h=0;h<l;h++){\n\t\t\t\tif(s[h]=='P') s[h]= '0'+i;\n\t\t\t\tif(s[h]=='Q') s[h]= '0'+j;\n\t\t\t\tif(s[h]=='R') s[h]= '0'+k;\n\t\t\t}\n\t\t\t\n\t\t\tif(kakko()==2) ans++;\n\t\t\t\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\nusing namespace std;\n\nstring s,t;\nint a,p;\n\nint A(int x){return x==2?0:x==1?1:2;}\nint B(int x,int y){return x==0||y==0?0:x==1||y==1?1:2;}\nint C(int x,int y){return x==2||y==2?2:x==1||y==1?1:0;}\nint D(){\n\tint z=p;\n\twhile(s[p]=='-')p++;\n\tz=(p-z)%2;\n\treturn z?A(s[p]-'0'):s[p]-'0';\n}\nint E(){\n\tif(s[p]!='(')return D();\n\tint x,y;char z;\n\tp++;x=E();p++;z=s[p];p++;y=E();p++;\n\treturn z!='+'?B(x,y):C(x,y);\n}\n\nint main(){\n\twhile(cin>>t,t!=\".\"){\n\t\ta=0;\n\t\trep(i,3)rep(j,3)rep(k,3){\n\t\t\tp=0;\n\t\t\ts=t;\n\t\t\trep(v,s.size())s[v]=s[v]=='P'?'0'+i:s[v]=='Q'?'0'+j:s[v]=='R'?'0'+k:s[v];\n\t\t\tif(E()==2)a++;\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n\nusing namespace std;\nstring str;\nint p, q, r, pos;\n\nint formula(){\n    if (isdigit(str[pos])) {return str[pos++] - '0';}\n    if (str[pos] == 'P') {pos++; return p;}\n    if (str[pos] == 'Q') {pos++; return q;}\n    if (str[pos] == 'R') {pos++; return r;}\n    \n    int res = 0;\n    if (str[pos] == '-') {pos++; return 2 - formula();}\n    if (str[pos] == '(') {\n        pos++;\n        res = formula();\n        if (str[pos] == '*') {\n            pos++;\n            res = min(res, formula());\n        }\n        else if (str[pos] == '+') {\n            pos++;\n            res = max(res, formula());\n        }\n        pos++;\n        return res;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> str;\n        if (str == \".\") {\n            break;\n        }\n        int cnt = 0;\n        for (p = 0; p <= 2; p++) {\n            for (q = 0; q <= 2; q++) {\n                for (r = 0; r <= 2; r++) {\n                    pos = 0;\n                    if (formula() == 2) {\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n \nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n \nconst int INF = 1001001001;\n \nint formula(const string& str, int& cur)\n{\n//  puts(str.substr(cur).c_str());\n    if(isdigit(str[cur])){\n        ++cur;\n        return str[cur-1] - '0';\n    }\n    if(str[cur] == '-'){\n        ++cur;\n        return 2 - formula(str, cur);\n    }\n \n    ++cur;\n    int a = formula(str, cur);\n    char op = str[cur];\n    ++cur;\n    int b = formula(str, cur);\n    ++cur;\n    if(op == '+')\n        return max(a, b);\n    else\n        return min(a, b);\n}\n \nint main()\n{\n    char str[128];\n    while(scanf(\"%s\", str), str[0]!='.'){\n        int n = strlen(str);\n        int cnt = 0;\n        rep(p, 3) rep(q, 3) rep(r, 3){\n            string tmp = str;\n            rep(i, n){\n                if(tmp[i] == 'P') tmp[i] = p + '0';\n                if(tmp[i] == 'Q') tmp[i] = q + '0';\n                if(tmp[i] == 'R') tmp[i] = r + '0';\n            }\n            int cur = 0;\n            cnt += formula(tmp, cur) == 2;\n        }\n \n        printf(\"%d\\n\", cnt);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint formula(string const& s, int P, int Q, int R, int& p) {\n    if(s[p] == 'P') {\n        p++;\n        return P;\n    } else if(s[p] == 'Q') {\n        p++;\n        return Q;\n    } else if(s[p] == 'R') {\n        p++;\n        return R;\n    } else if('0' <= s[p] && s[p] <= '2') {\n        return s[p++] - '0';\n    } else if(s[p] == '-') {\n        int res = formula(s, P, Q, R, ++p);\n        if(res == 0) {\n            return 2;\n        } else if(res == 1) {\n            return 1;\n        } else {\n            return 0;\n        }\n    } else { // '('\n        int val = formula(s, P, Q, R, ++p);\n        char op = s[p++];\n        int val2 = formula(s, P, Q, R, p);\n        p++;\n        if(op == '*') {\n            if(val == 0 || val2 == 0) {\n                return 0;\n            } else if(val == 1 || val2 == 1) {\n                return 1;\n            } else {\n                return 2;\n            }\n        } else {\n            if(val == 2 || val2 == 2) {\n                return 2;\n            } else if(val == 1 || val2 == 1) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\n\nint main() {\n    string s;\n    while(cin >> s, s != \".\") {\n        int res = 0;\n        for(int p=0; p<=2; ++p) {\n            for(int q=0; q<=2; ++q) {\n                for(int r=0; r<=2; ++r) {\n                    int pos = 0;\n                    if(formula(s, p, q, r, pos) == 2) {\n                        res++;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst int tbl_n[3] = {2, 1, 0};\nconst int tbl_m[3][3] = { {0, 0, 0}, {0, 1, 1}, {0, 1, 2} };\nconst int tbl_p[3][3] = { {0, 1, 2}, {1, 1, 2}, {2, 2, 2} };\n\nint v[3];\nstring s;\nunsigned ix;\n\nint expr();\nint parse(int p, int q, int r) {\n    v[0]=p, v[1]=q, v[2]=r;\n    ix = 0;\n    return expr();\n}\n\nint expr() {\n    const char ch = s[ix++];\n    if('0'<=ch && ch<='2') return ch-'0';\n    else if('P'<=ch && ch<='R') return v[ch-'P'];\n    else if(ch=='-') return tbl_n[expr()];\n    else {\n        const int l = expr();\n        const char op = s[ix++];\n        const int r = expr();\n        ix++;\n        if(op=='+') return tbl_p[l][r];\n        if(op=='*') return tbl_m[l][r];\n    }\n    log(false);\n}\n\nint main() {\n    for(;;) {\n        getline(cin, s);\n        log(s);\n        if(s[0]=='.') return 0;\n        int ans = 0;\n        rep(p, 3) rep(q, 3) rep(r, 3) {\n            if(parse(p, q, r)==2) ans++;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define pb push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint P,Q,R;\n\nint add(int a,int b){\n    if(a==0) return b;\n    if(a==1) return (b==2? 2 : 1);\n    if(a==2) return 2;\n}\n\nint mul(int a,int b){\n    if(a==0) return 0;\n    if(a==1) return (b==0?0:1);\n    if(a==2) return b;\n}\n\nint formula(string& s){\n    //cout << \"formula : \" << s << endl;\n    string tmp = s;\n    if('0'<=s[0] and s[0]<='2'){\n        int ret = s[0]-'0';\n        s = s.substr(1);\n        //cout << tmp  << \"  before return:\" << s << endl;\n        return ret;\n    }else if(s[0]=='-'){\n        s = s.substr(1);\n        int v=formula(s);\n        //cout << tmp  << \"  before return:\" << s << endl;\n        return 2-v;\n    }else if(s[0]=='('){\n        s = s.substr(1);\n        //cout << \"2 operator(1)= \" << s << endl;\n        int v1 = formula(s);\n        char com = s[0];\n        s = s.substr(1);\n        //cout << \"2 operator(2)= \" << s << endl;\n        int v2 = formula(s);\n        s = s.substr(1);\n        //cout << tmp  << \"  before return:\" << s << endl;\n        if(com=='+') return add(v1,v2);\n        if(com=='*') return mul(v1,v2);\n        assert(false);\n    }else{\n        //cout << \"error:\" << s << endl;\n        assert(false);\n    }\n}\n\nvoid solve(string s){\n    //cout << \"----- \" << s << \" -----\" << endl;\n    int ans=0;\n\n    for(P=0;P<=2;P++) for(Q=0;Q<=2;Q++) for(R=0;R<=2;R++){\n        string tmp = s;\n        for(int i=0;i<sz(tmp);i++){\n            if(tmp[i]=='P') tmp[i]=P+'0';\n            if(tmp[i]=='Q') tmp[i]=Q+'0';\n            if(tmp[i]=='R') tmp[i]=R+'0';\n        }\n//        cout << P << \" \" << Q << \" \" << R << endl;\n        int val = formula(tmp);\n        //cout << \"val=\" << val << endl;\n        if(val==2) ans++;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    string s;\n    while(cin>>s){\n        if(s==\".\") break;\n        solve(s);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstring S;\n\nint and3(int s1, int s2) {\n  if(s1 == 2 && s2 == 2) return 2;\n  if(s1 == 0 || s2 == 0) return 0;\n  return 1;\n}\n\nint or3(int s1, int s2) {\n  if(s1 == 0 && s2 == 0) return 0;\n  if(s1 == 2 || s2 == 2) return 2;\n  return 1;\n}\n\nint calc(int p, int q, int r) {\n  stack<char> stk;\n\n  REP(i, 0, S.length()) {\n    if(S[i] == '(' || S[i] == '-' || S[i] == '*' || S[i] == '+') stk.push(S[i]);\n    if(('0' <= S[i] && S[i] <= '2') || ('P' <= S[i] && S[i] <= 'R')) {\n      int d;\n      if('0' <= S[i] && S[i] <= '2') d = S[i] - '0';\n      if(S[i] == 'P') d = p;\n      if(S[i] == 'Q') d = q;\n      if(S[i] == 'R') d = r;\n      while(!stk.empty() && stk.top() == '-') {\n        stk.pop();\n        d = 2 - d;\n      }\n      stk.push(d);\n    }\n    if(S[i] == ')') {\n      int s2 = stk.top(); stk.pop();\n      int op = stk.top(); stk.pop();\n      int s1 = stk.top(); stk.pop();\n      stk.pop();\n      int d;\n      if(op == '*') d = and3(s1, s2);\n      if(op == '+') d = or3(s1, s2);\n      while(!stk.empty() && stk.top() == '-') {\n        stk.pop();\n        d = 2 - d;\n      }\n      stk.push(d);\n    }\n  }\n\n  return stk.top();\n}\n\nint main(void) {\n  while(cin >> S, S != \".\") {\n    int cnt = 0;\n    REP(p, 0, 3) REP(q, 0, 3) REP(r, 0, 3) if(calc(p, q, r) == 2) cnt++;\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[200];\nint cnt=0;\nint Minus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    Minus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  int tm=0;\n    cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[tm++]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[tm++]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[tm++]=k+'0';\n\t    }else{\n\t      tmp[tm++]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nqueue<char> convert(string formula){\n  queue<char> qu;\n  stack<char> st;\n  stack<char> m_rp;\n  \n  bool b_minus = false;\n  for(char c : formula){\n    switch(c){\n      case '(':\n        if(b_minus == true) {\n          m_rp.push('-');\n          b_minus = false;\n        }\n        m_rp.push('(');\n        break;\n      case '0': case '1': case '2': case 'P': case 'Q': case 'R':\n        qu.push(c);\n        if(b_minus == true){\n          qu.push('-');\n          b_minus = false;\n        }\n        break;\n      case '*': case '+':\n        st.push(c);\n        break;\n      case '-':\n           b_minus = true;\n        break;\n      case ')':\n        qu.push(st.top());\n        st.pop();\n        m_rp.pop();\n        if(!m_rp.empty() && m_rp.top() == '-'){\n          qu.push(m_rp.top());\n          m_rp.pop();\n        }\n        break;\n      }\n  }\n  return qu;\n}\n\nint lAnd(int a, int b){\n  if(a == 0 || b == 0) return 0;\n  else if(a == 2 && b == 2) return 2;\n  else return 1;\n}\n\nint lOr(int a, int b){\n  if(a == 2 || b == 2) return 2;\n  else if(a == 0 && b == 0) return 0;\n  else return 1;\n}\n\nint lNot(int a){\n  if(a == 0) return 2;\n  else if(a == 1) return 1;\n  else return 0;\n}\n\nint cal(queue<char> quc, int p, int q, int r){\n  stack<int> stc;\n  int a,b;\n  while(!quc.empty()){\n    char c = quc.front();\n    quc.pop();\n    switch(c){\n      case '0':\n      case '1':\n      case '2':\n        stc.push(c-'0');\n        break;\n      case 'P':\n        stc.push(p);\n        break;\n      case 'Q':\n        stc.push(q);\n        break;\n      case 'R':\n        stc.push(r);\n        break;\n      case '+':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lOr(a,b));\n        break;\n      case '*':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lAnd(a,b));\n        break;\n      case '-':\n        a = stc.top(); stc.pop();\n        stc.push(lNot(a));\n        break;\n    }\n  }\n  return stc.top();\n}\n\nint main(void){\n  string d = \"\";\n  int ans;\n  while(true){\n    cin >> d;\n    if(d == \".\") break;\n    d = regex_replace(d, std::regex(\"(--)\"), \"\");\n    \n    queue<char> t = convert(d);\n    ans = 0;\n    for(int i=0;i<=2;i++){\n      for(int j=0;j<=2;j++){\n        for(int k=0;k<=2;k++){\n          if(cal(t,i,j,k) == 2) ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n\n    // while(!t.empty()){\n    //   cout << t.front();\n    //   t.pop();\n    // }\n    // cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint BIT(int C1,bool C2);\nint MINUS(int C3);\nint KAKE(int C4,int C5);\nint PLUS(int C6,int C7);\nstring TSTRING(int C8);\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[MAX_N];\n\nint BIT(int C1,bool C2){\n\tif(C2==true){return C1;}\n\treturn MINUS(C1);\n}\n\nint MINUS(int C3){\n\treturn 2-C3;\n}\nint PLUS(int C4,int C5){\n\treturn max(C4,C5);\n}\nint KAKE(int C6,int C7){\n\treturn max(C6,C7);\n}\n\nstring TSTRING(int C8)\n{\n\tif(C8==0)\n\t{\n\t\treturn \"0\";\n\t}\n\tif(C8==1)\n\t{\n\t\treturn \"1\";\n\t}\n\treturn \"2\";\n}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\tif(ok==false){ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=BIT(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=BIT(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=BIT(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=BIT(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=BIT(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=BIT(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return PLUS(ans,ans2);}\n\treturn KAKE(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=TSTRING((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tsum=0;\n\t\tif(S==\".\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc (string exp) {\n    if (exp[0] == '(') {\n        int count = 0;\n        string lhs_;\n        for (int i = 1; count || (exp[i] != '*' && exp[i] != '+'); i++) {\n            lhs_ += exp[i];\n            if (exp[i] == '(') count++;\n            if (exp[i] == ')') count--;\n        }\n        int lhs = calc(lhs_);\n        char op = exp[lhs_.size() + 1];\n        count = 0;\n        string rhs_;\n        for(int i = lhs_.size()+2;; i++) {\n            if (exp[i] == '(') count++;\n            if (exp[i] == ')') if (count == 0) break; else count--;\n            rhs_ += exp[i];\n        }\n        int rhs = calc(rhs_);\n        if (op == '*') return min(lhs,rhs);\n        else return max(rhs,lhs);\n\n    } else {\n        if (exp[exp.size()-1] == '1') return 1;\n        if ((exp.size()-1) % 2) {\n            return exp[exp.size()-1] == '2' ? 0 : 2;\n        } else return exp[exp.size()-1] == '2' ? 2 : 0;\n    }\n}\n\nint main () {\n    string str;\n    while (cin >> str, str != \".\") {\n        int res = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string tmp(str.begin(), str.end());\n                    for (int c = 0; c < str.size(); c++) {\n                        if (tmp[c] == 'P') tmp[c] = ('0' + i);\n                        if (tmp[c] == 'Q') tmp[c] = ('0' + j);\n                        if (tmp[c] == 'R') tmp[c] = ('0' + k);\n                    }\n                    if (calc(tmp) == 2) res++;\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n//#include <stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n#include<fstream>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\ntypedef string::const_iterator State;\n\nint dy[5] = { 0,0,1,-1,0 };\nint dx[5] = { 1,-1,0,0 ,0 };\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint count = 0;\n\t\tint calc, first, second;\n\t\tint tmp;\n\t\tbool flag = false;\n\t\tbool check = false;\n\t\tstring s;\n\t\t\n\n\t\tcin >> s;\n\t\tif (s == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(p, 0, 2) {\n\t\t\tFOR(q, 0, 2) {\n\t\t\t\tFOR(r, 0, 2) {\n\t\t\t\t\tflag = false;//true 反転\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tstack<int>sta;\n\t\t\t\t\tsta.push(-4);\n\n\t\t\t\t\tFOR(i, 0, s.size() - 1) {\n\t\t\t\t\t\tswitch (s[i]) {\n\t\t\t\t\t\tcase 'P':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(p);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(q);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(r);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')':\n\t\t\t\t\t\t\tfirst = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\ttmp = sta.top();\n\t\t\t\t\t\t\tif (tmp == -3) {\n\t\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\t\tswitch (first) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tfirst = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcalc = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\tsecond = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\ttmp = sta.top();\n\t\t\t\t\t\t\tif (tmp == -3) {\n\t\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\t\tswitch (second) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsecond = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsecond = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch (calc) {\n\t\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\t\tif (first == 2 || second == 2) {\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (first == 0 && second == 0) {\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase -2:\n\t\t\t\t\t\t\t\tif (first == 2 && second == 2) {\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (first == 0 || second == 0) {\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tsta.push(-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tsta.push(-2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '0':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(0);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '2':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfirst = sta.top();\n\t\t\t\t\tsta.pop();\n\t\t\t\t\ttmp = sta.top();\n\t\t\t\t\tif (tmp == -3) {\n\t\t\t\t\t\tswitch (first) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tfirst = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (first == 2) {\n\t\t\t\t\t\t//cout << p << \" \" << q << \" \" << r << endl;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nstring ts;\nstring s;\nint idx;\n\nint NOT[] = {2,1,0};\nint AND[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint OR[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nint solve();\n\nint getDigit(){\n  int cnt = 0;\n  while(s[idx] == '-'){\n    cnt++;\n    idx++;\n  }\n\n  int digit = -1;\n  if(s[idx] == '('){\n    idx++;\n    digit = solve();\n  }\n  else{\n    digit = s[idx] - '0';\n    idx++;\n  }\n\n  if(cnt % 2 == 1){\n    return NOT[digit];\n  }\n  return digit;\n}\n\nint solve(){\n  int res = 0;\n\n  //cout<<\":\"<<idx<<endl;\n\n  int left = -1;\n  int right = -1;\n\n  if(s[idx] == '('){\n    idx++;\n    left = solve();\n  }\n  else{\n    left = getDigit();\n  }\n\n  if(idx < s.length()){\n    if(s[idx] == '*'){\n      idx++;\n      if(s[idx] == '('){\n        idx++;\n        right = solve();\n      }\n      else{\n        right = getDigit();\n      }\n\n      res = AND[left][right];\n    }\n    else if(s[idx] == '+'){\n      idx++;\n      if(s[idx] == '('){\n        idx++;\n        right = solve();\n      }\n      else{\n        right = getDigit();\n      }\n\n      res = OR[left][right];\n    }\n  }\n  idx++;\n\n  if(right == -1){\n    return left;\n  }\n  else{\n    return res;\n  }\n}\n\nvoid replace(int R,int P,int Q){\n  s = \"\";\n  rep(i,ts.size()){\n    if(ts[i] == 'R') s += (char)('0' + R);\n    else if(ts[i] == 'P') s += (char)('0' + P);\n    else if(ts[i] == 'Q') s += (char)('0' + Q);\n    else{\n      s += ts[i];\n    }\n  }\n}\n\nint main(){\n  while(cin>>ts,ts!=\".\"){\n    int ans = 0;\n    rep(R,3) rep(P,3) rep(Q,3){\n      replace(R,P,Q);\n      idx = 0;\n      if(solve() == 2) ans++;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<deque>\n#include<stack>\n#include<algorithm>\n#include<cstring>\n#include<cctype>\nusing namespace std;\nint T(char*s)\n{\n\tchar*p,a[2]=\"@\",c;\n\tstack<char> o;\n\tdeque<char> d;\n\tfor(p=s;*p;++p)\n\t{\n\t\ta[0]=*p;\n\t\tif(isdigit(*p))\n\t\t{\n\t\t\td.push_back(*p);\n\t\t\twhile(o.size()&&o.top()=='-')o.pop(),d.push_back('-');\n\t\t}\n\t\tif(strpbrk(a,\"(+*\"))o.push(*p);\n\t\tif(*p=='-')o.push(*p);\n\t\tif(*p==')')while(c=o.top(),o.pop(),c-'(')d.push_back(c);\n\t}\n\tfor(int i=1;i<d.size();)\n\t{\n\t\tif(d[i]=='-')d[i-1]=-(d[i-1]-'1')+'1',d.erase(d.begin()+i);\n\t\telse if(d[i]=='*')d[i-2]=min(d[i-2],d[i-1]),d.erase(d.begin()+i-1,d.begin()+i+1),--i;\n\t\telse if(d[i]=='+')d[i-2]=max(d[i-2],d[i-1]),d.erase(d.begin()+i-1,d.begin()+i+1),--i;\n\t\telse ++i;\n\t}\n\treturn d.front()=='2';\n}\nint main()\n{\n\tchar s[84],t[84],*p,i[3];\n\twhile(scanf(\"%s\",s),s[0]-'.')\n\t{\n\t\tint r=0;\n\t\tfor(i[0]='0';i[0]<'3';++i[0])for(i[1]='0';i[1]<'3';++i[1])for(i[2]='0';i[2]<'3';++i[2])\n\t\t{\n\t\t\tstrcpy(t,s);\n\t\t\twhile(p=strpbrk(t,\"PQR\"))*p=i[*p-'P'];\n\t\t\tr+=T(t);\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint t;\n\nint fomula(string str, int p, int q, int r)\n{\n\tint v = 1;\n\tif(str[t] == 'P'){\n\t\tt++;\n\t\tv = p;\n\t} else if(str[t] == 'Q'){\n\t\tt++;\n\t\tv = q;\n\t} else if(str[t] == 'R'){\n\t\tt++;\n\t\tv = r;\n\t} else if('0' <= str[t] && str[t] <= '2'){\n\t\tv = (int)(str[t]-'0');\n\t\tt++;\n\t} else if(str[t] == '-'){\n\t\tt++;\n\t\tv = 2-fomula(str, p, q, r);\n\t} else {\n\t\tt++;\n\t\tint v1 = fomula(str, p, q, r);\n\t\tchar w = str[t++];\n\t\tint v2 = fomula(str, p, q, r);\n\t\tt++;\n\t\tif(w == '+'){\n\t\t\tif(v1 == 2 || v2 == 2){\n\t\t\t\tv = 2;\n\t\t\t} else if(v1 == 0 && v2 == 0){\n\t\t\t\tv = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif(v1 == 0 || v2 == 0){\n\t\t\t\tv = 0;\n\t\t\t} else if(v1 == 2 && v2 == 2){\n\t\t\t\tv = 2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn v;\n}\n\nint main()\n{\n\tint c;\n\tstring str;\n\t\n\twhile(cin>>str && str != \".\"){\n\t\tc = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tt = 0;\n\t\t\t\t\tif(fomula(str, i, j, k) == 2){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << c << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, const char*>\nconst int INF = INT_MAX / 2;\nconst int N = 500000;\n\nstring str;\n\nint min(int n){\n    if(n == 0) return 2;\n    if(n == 1) return 1;\n    if(n == 2) return 0;\n}\n\nint multi(int n, int m){\n    if(n == 0 || m == 0) return 0;\n    if(n == 1 || m == 1) return 1;\n    return 2;\n}\n\nint add(int n, int m){\n    if(n == 2 || m == 2) return 2;\n    if(n == 1 || m == 1) return 1;\n    return 0;\n}\n\nP formula(const char *p, int np, int nq, int nr){\n    if(*p == '0') return P(0, p + 1);\n    else if(*p == '1') return P(1, p + 1);\n    else if(*p == '2') return P(2, p + 1);\n    else if(*p == 'P') return P(np, p + 1);\n    else if(*p == 'Q') return P(nq, p + 1);\n    else if(*p == 'R') return P(nr, p + 1);\n    else if(*p == '-'){\n        P tmp = formula(p + 1, np, nq, nr);\n        int n = tmp.first;\n        return P(min(n), tmp.second);\n    }\n    else if(*p == '('){\n        P tmp = formula(p + 1, np, nq, nr);\n        int left = tmp.first;\n        p = tmp.second;\n        char op = *p;\n        tmp = formula(p + 1, np, nq, nr);\n        int right = tmp.first;\n        //debug\n        //cout <<left <<\" \" <<op <<\" \" <<right <<endl;\n        if(op == '*') return P(multi(left, right), tmp.second + 1);\n        else if(op == '+') return P(add(left, right), tmp.second + 1);\n    }\n}\n\nint main(){\n    while(cin >>str){\n        if(str == \".\") break;\n        int cnt = 0;\n        REP(p, 3){\n            REP(q, 3){\n                REP(r, 3){\n                    int tmp = formula(str.c_str(), p, q, r).first;\n                    //cout <<p <<\", \" <<q <<\", \" <<r <<\" = \" <<tmp <<endl;\n                    if(tmp == 2){\n                        //cout <<\"!\" <<endl;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout <<cnt <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nstring s;\nint P, Q, R;\n\nint formula( State & );\nint factor( State & );\n\nint main() {\n    while ( cin >> s, s != \".\" ) {\n        int ans = 0;\n        rep ( i, 3 ) rep ( j, 3 ) rep ( k, 3 ) {\n            P = i, Q = j, R = k;\n            State begin = s.begin();\n            int tmp = formula( begin );\n            ans += (tmp == 2);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\nint factor( State & begin ) {\n    if ( *begin == '(' ) {\n        begin++;\n        int ret = formula( begin );\n        begin++;\n        return ret;\n    }\n    else if ( *begin == '-' ) {\n        begin++;\n        return ( 2 - factor( begin ) );\n    }\n    else {\n        int ret = 0;\n        if ( '0' <= *begin && *begin <= '2' ) {\n            ret = *begin - '0';\n            begin++;\n        }\n        else if ( 'P' <= *begin && *begin <= 'R' ) {\n            if ( *begin == 'P' ) ret = P;\n            if ( *begin == 'Q' ) ret = Q;\n            if ( *begin == 'R' ) ret = R;\n            begin++;\n        }\n        return ret;\n    }\n}\n\nint formula( State & begin ) {\n    int ret = factor( begin );\n    if ( *begin == '*' ) {\n        begin++;\n        ret = min( ret, formula( begin ) );\n    }\n    else if ( *begin == '+' ) {\n        begin++;\n        ret = max( ret, formula( begin ) );\n    }\n    else {\n\n    }\n    return ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint stk(string s,int p,int q,int r){\n    int count=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')count++;\n        else if(s[i]==')')count--;\n        if(!count){\n            if(s[i]=='*'){\n                return min(stk(s.substr(0,i),p,q,r),stk(s.substr(i+1,s.size()-i-1),p,q,r));\n            }\n            if(s[i]=='+'){\n                return max(stk(s.substr(0,i),p,q,r),stk(s.substr(i+1,s.size()-i-1),p,q,r));\n            }\n        }\n    }\n    if(s[0]=='('){\n        count=1;\n        for(int i=1;i<s.size();i++){\n            if(s[i]=='(')count++;\n            else if(s[i]==')')count--;\n            if(!count){\n                return stk(s.substr(1,i-1),p,q,r);\n            }\n        }\n    }\n     if(s[0]=='-'){\n        return 2-(stk(s.substr(1,s.size()-1),p,q,r));\n    }\n    else if(s[0]=='0'){\n        return 0;\n    }\n    else if(s[0]=='1'){\n        return 1;\n    }\n    else if(s[0]=='2'){\n        return 2;\n    }\n    else if(s[0]=='P'){\n        return p;\n    }\n    else if(s[0]=='Q'){\n        return q;\n    }\n    else if(s[0]=='R'){\n        return r;\n    }\n    return 0;\n}\n\nvoid solve(string str){\n    int ans=0;\n    for(int p=0;p<3;p++){\n        for(int q=0;q<3;q++){\n            for(int r=0;r<3;r++){\n                if(stk(str,p,q,r)==2){\n                    ans++;\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n\nint main(void){\n    string s;\n    while(cin>>s,s[0]!='.'){\n        solve(s);\n    }    \n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint check(char op, int x, int y) {\n    switch (op) {\n    case '*':\n        return min(x, y);\n    case '+':\n        return max(x, y);\n    }\n    assert(0);\n}\n\nint formula(string& form, int& idx) {\n    switch (form[idx]) {\n    case '0':\n    case '1':\n    case '2':\n        ++idx;\n        return form[idx-1] - '0';\n    case '-':\n        ++idx;\n        return 2 - formula(form, idx);\n    case '(':\n        ++idx;\n        int x = formula(form, idx);\n        char op = form[idx];\n        ++idx;\n        int y = formula(form, idx);\n        ++idx;\n        return check(op, x, y);\n    }\n    assert(0);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \".\") {\n            break;\n        }\n\n        int n = 0;\n        REP(p, 3) REP(q, 3) REP(r, 3) {\n            string tmp = line;\n            REP(i, tmp.length()) {\n                switch (tmp[i]) {\n                case 'P':\n                    tmp[i] = p + '0';\n                    break;\n                case 'Q':\n                    tmp[i] = q + '0';\n                    break;\n                case 'R':\n                    tmp[i] = r + '0';\n                    break;\n                }\n            }\n            int idx = 0;\n            if (formula(tmp, idx) == 2) {\n                n++;\n            }\n        }\n        cout << n << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint p,q,r;\n\nint formula(string & str , int & i){\n    int rtn;\n    char c = str[i++];\n    switch (c){\n    case '0':\n    case '1':\n    case '2':\n        rtn = c - '0';\n        break;\n    case 'P':\n        rtn = p;\n        break;\n    case 'Q':\n        rtn = q;\n        break;\n    case 'R':\n        rtn = r;\n        break;\n    case '-':\n        rtn = 2 - formula(str,i);\n        break;\n    case '(':\n        int rhs = formula(str,i);\n        //i++; // )\n        char op = str[i++];\n        //i++;\n        int lhs = formula(str,i);\n        if(op == '+') rtn = max(rhs,lhs);\n        if(op == '*') rtn = min(rhs,lhs);\n        i++;\n        break;\n    }\n    return rtn;\n}\n\nint main(){\n    string str;\n    while(cin >> str , str != \".\"){\n        int c=0;\n        for(p=0; p<3; p++){\n            for(q=0; q<3; q++){\n                for(r=0; r<3; r++){\n                    int i=0;\n                    if(formula(str,i) == 2) c++;\n                }\n            }\n        }\n        cout << c << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nchar NOT(char a)\n{\n  if(a=='0')return '2';\n  if(a=='1')return '1';\n  return '0';\n}\n\nchar OR(char a,char b)\n{\n  if(a=='0' && b=='0')return '0';\n  if(a=='2' || b=='2')return '2';\n  return '1';\n}\n\nchar AND(char a,char b)\n{\n  if(a=='2' && b=='2')return '2';\n  if(a=='0' || b=='0')return '0';\n  return '1';\n}\n\nchar Check(int x,int y,int z,string s)\n{\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='P')s[i]='0'+x;\n    if(s[i]=='Q')s[i]='0'+y;\n    if(s[i]=='R')s[i]='0'+z;\n  }\n  char a,b,c;\n  stack<char> S;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='0' || s[i]=='1' || s[i]=='2'){\n      S.push(s[i]);\n      while(1){\n\tif(S.size()==1)break;\n\ta = S.top();\n\tS.pop();\n\tc = S.top();\n\tif(c=='('){\n\t  S.push(a);\n\t  break;\n\t}\n\tS.pop();\n        if(c=='+'){\n\t  b=S.top();S.pop();\n\t  S.push(OR(b,a));\n\t}\n\telse if(c=='*'){\n\t  b=S.top();S.pop();\n\t  S.push(AND(b,a));\n\t}\n\telse{\n\t  S.push(NOT(a));\n\t}\n      }\n    }\n    else if(s[i]==')'){\n      while(1){\n\ta = S.top();S.pop();\n        c = S.top();S.pop();\n\tif(c=='('){\n          S.push(a);\n\t  break;\n\t}\n        else if(c=='+'){\n\t  b=S.top();S.pop();\n\t  S.push(OR(b,a));\n\t}\n\telse if(c=='*'){\n\t  b=S.top();S.pop();\n\t  S.push(AND(b,a));\n\t}\n\telse{\n\t  S.push(NOT(a));\n\t}\n      }\n    }\n    else S.push(s[i]);\n  }\n  return S.top();\n}\n\nint main()\n{\n  string s;\n  int ans;\n  while(1){\n    cin>>s;\n    if(s[0]=='.')break;\n    ans=0;\n    s='('+s+')';\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  if(Check(i,j,k,s)=='2')ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nconst string CHARS(\"PQR\");\n\nconst int not_[] = {2, 1, 0};\n\nconst int and_[3][3] = {\n\t{0, 0, 0},\n\t{0, 1, 1},\n\t{0, 1, 2}\n};\n\nconst int or_[3][3] = {\n\t{0, 1, 2},\n\t{1, 1, 2},\n\t{2, 2, 2}\n};\n\nPII solve(string &str, int pos);\n\nPII ope(string &str, int pos) {\n//\tcout << \"-- \" << pos << \" \" << str[pos] << endl;\n\tPII l = solve(str, pos);\n\tPII r;\n\tint v;\n\n\tswitch (str[l.fst]) {\n\t\tcase '*':\n\t\t\tr = solve(str, l.fst + 1);\n\t\t\tv = and_[l.snd][r.snd];\n\t\t\treturn MP(r.fst, v);\n\n\t\tcase '+':\n\t\t\tr = solve(str, l.fst + 1);\n\t\t\tv = or_[l.snd][r.snd];\n\t\t\treturn MP(r.fst, v);\n\t}\n\n\treturn MP(-1, -1);\n}\n\nPII solve(string &str, int pos) {\n\tint n = str.size();\n\n\tif (pos >= n) {\n\t\treturn MP(pos, -1);\n\t}\n\n//\tcout << pos << \" \" << str[pos] << endl;\n\n\tchar c = str[pos];\n\n\tPII tmp;\n\n\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\treturn MP(pos + 1, c - '0');\n\n\t\tcase '-':\n\t\t\ttmp = solve(str, pos + 1);\n\t\t\treturn MP(tmp.fst, not_[tmp.snd]);\n\t\t\t\n\t\tcase '(':\n\t\t\ttmp = ope(str, pos + 1);\n\t\t\treturn MP(tmp.fst + 1, tmp.snd);\n\n\t\tdefault:\n\t\t\tcout << \"!!! error !!!\" << endl;\n\t\t\tcout << str << endl;\n\t\t\tcout << pos << \" \" << c << endl;\n\t\t\texit(1);\n\t}\n\n\treturn MP(0, 0);\n}\n\nint main(void) {\n\tVVI ps;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tps.PB(VI({i, j, k}));\n\t\t\t}\n\t\t}\n\t}\n\tint psn = ps.size();\n\n\tstring str0;\n\n\twhile (cin >> str0, str0 != \".\") {\n\t\tint cnt = 0;\n\t\t\n\t\tfor (int i = 0; i < psn; i++) {\n\t\t\tstring str = str0;\n\t\t\t// replace\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\treplace(ALL(str), CHARS[j], (char)('0' + ps[i][j]));\n\t\t\t}\n\n//\t\t\tcout << endl << \"case: \" << i << \" \" << str << endl;\n\t\t\tauto tmp = solve(str, 0);\n//\t\t\tcout << tmp.fst << \" \" << tmp.snd << endl;\n\t\t\tcnt += tmp.snd == 2;\n\t\t}\n\n\t\tcout << cnt << endl; \n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=(int)(k);i<=(int)(n);i++)\nusing namespace std;\n\nstring s;\nint g;\n//どれもy,xの順番\nconst int mi[3] = {2,1,0};\nconst int mul[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nconst int plu[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\nint p,r,q;\nint cal(){\n    int res = 0;\n    int mm = 0;\n    char cc = '.';\n    bool flag = false;\n    while(g < s.size()){\n        int rres = 0;\n        switch(s[g]){\n            case '-':\n                mm++;\n                g++;\n                break;\n            case ')':\n                g++;\n                if(mm%2==1) return mi[res];\n                return res;\n            case '*':\n                cc = '*';\n                g++;\n                break;\n            case '+':\n                cc = '+';\n                g++;\n                break;\n            case '(':\n                g++;\n                rres = cal();\n                flag = true;\n                break;\n            case 'P':\n            case 'Q':\n            case 'R':\n                if(s[g] == 'P') rres = p;\n                if(s[g] == 'Q') rres = q;\n                if(s[g] == 'R') rres = r;\n                flag = true;\n                g++;\n                break;\n            default:\n\n                rres = s[g]-'0';\n                flag = true;\n                g++;\n                break;\n        }\n        if(flag){\n            if(mm%2==1){\n                rres = mi[rres];\n                mm=0;\n            }\n//            cout << rres << \" \" << res << endl;\n            if(cc == '*') res = mul[rres][res];\n            if(cc == '+') res = plu[rres][res];\n            if(cc == '.') res = rres;\n            cc = '.';\n            flag = false;\n        }\n    }\n    if(mm%2==1) return mi[res];\n    else return res;\n}\n\nint main(){\n    while(cin >> s,s[0]!='.'){\n        int res = 0;\n        rep(pp,3)rep(rr,3)rep(qq,3){\n            g = 0;\n            p = pp;\n            r = rr;\n            q = qq;\n            if(cal()==2) res += 1;\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint p, q, r, pos;\nstring in;\n\nint Formula();\nint Seki(int, int);\nint Wa(int, int);\nint Not(int);\nint Num();\nmain(){\n\n  while(1){\n    cin >> in;\n    if(in==\".\") break;\n\n    int ans=0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  pos=0;\n\t  int tmp=Formula();\n\t  if(tmp==2) ans++;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint Formula(){\n  int x;\n  if(in[pos]=='('){\n    pos++;\n    x=Formula();\n    pos++;\n  }else if(in[pos]=='-'){\n    int count=0;\n    while(in[pos]=='-'){\n      count++;\n      pos++;\n    }\n    x=Num();\n    for(int i=0;i<count;i++){\n      x=(Not(x));\n    }\n  }else{\n    x=Num();\n  }\n\n  if(in[pos+1]=='*'){\n    pos+=2;\n    x=Seki(x, Formula());\n  }else if(in[pos+1]=='+'){\n    pos+=2;\n    x=Wa(x, Formula());\n  }\n  \n  return x;\n}\n\nint Seki(int a, int b){\n  if(a==0){\n    return 0;\n  }else if(a==1){\n    if(b==0) return 0;\n    else return 1;\n  }else{\n    return b;\n  }\n}\n\nint Wa(int a, int b){\n  if(a==0){\n    return b;\n  }else if(a==1){\n    if(b==2) return 2;\n    else return 1;\n  }else{\n    return 2;\n  }\n}\n\nint Not(int a){\n  if(a==0) return 2;\n  if(a==2) return 0;\n  return 1;\n}\n\nint Num(){\n  int x;\n  if(in[pos]=='P'){\n    x=p;\n  }else if(in[pos]=='Q'){\n    x=q;\n  }else if(in[pos]=='R'){\n    x=r;\n  }else if(in[pos]=='0'){\n    x=0;\n  }else if(in[pos]=='1'){\n    x=1;\n  }else if(in[pos]=='2'){\n    x=2;\n  }\n  return x;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define rep2(i, s, n) for(int i=s; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T>\nusing priority_queue_rev = priority_queue<T, vector<T>, greater<T> >;\n\nstatic const int INTINF = (2147483647 >> 1); // 10^9 + 5000\nstatic const ll LLINF = (9223372036854775807 >> 1);\nstatic const int MAX = 1e5+1;\nstatic const ll MOD = 1e9+7;\n\nnamespace Kunitaka{\n    template<\n        typename TYPE,\n        std::size_t SIZE\n    >\n    std::size_t array_length(const TYPE (&array)[SIZE])\n    {\n        return SIZE;\n    }\n\n    template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n    template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n}\nusing namespace Kunitaka;\nnamespace Printer{\n    void br(){\n        cout << endl;\n    }\n\n    void loop_cnt(int i){\n        cout << \"i = \" << i << endl;\n    }\n\n    void loop_cnt(int i, int j){\n        cout << \"i = \" << i << \", \" << \"j = \" << j << endl;\n    }\n\n    template<class T>\n    void print(T x){\n        cout << x << endl;\n    }\n\n    template<class T, class S>\n    void print(T x, S y){\n        cout << x << \",\" << y << endl;\n    }\n\n    template<class T, class S, class U>\n    void print(T x, S y, U z){\n        cout << x << \",\" << y << \",\" << z << endl;\n    }\n\n    template<class T, class S>\n    void print(pair<T, S> p){\n        cout << p.first << \", \" << p.second << endl;\n    }\n\n    template<\n        typename TYPE,\n        std::size_t SIZE\n    >\n    void print(const TYPE (&array)[SIZE]){\n        int lim = array_length(array);\n        for(int i=0; i<lim; i++){\n            if(i) cout << \" \";\n            cout << array[i];\n        }\n        cout << endl;\n    }\n\n    template<class S>\n    void print(vector<S> v){\n        for(int i=0; i<v.size(); i++){\n            if(i) cout << \" \";\n            cout<< v[i];\n        }\n        cout << endl;\n    }\n\n    template<class S>\n    void print(vector<vector<S> > vv){\n        for(int i=0; i<vv.size(); i++){\n            for(int j=0; j<vv[i].size(); j++){\n                if(j) cout << \" \";\n                cout << vv[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    void yesno(bool x){\n        if(x) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n};\nusing namespace Printer;\n\nll hai(ll x){\n    if(x == 0) return 2;\n    if(x == 1) return 1;\n    return 0;\n}\n\nll kake(ll x, ll y){\n    if(!x || !y) return 0;\n    if(x == 1 || y == 1) return 1;\n    return 2;\n}\n\nll plu(ll x, ll y){\n    if(!x && !y) return 0;\n    if(x == 2 || y == 2) return 2;\n    return 1;\n}\n\nll calc(string str){\n    int type = 0;\n    string a = \"\";\n    string b = \"\";\n    if(str[0] == '-'){\n        a = str.substr(1, str.size()-1);\n    }\n    else\n    {\n        int cnt = 0;\n        for(int i=0; i<str.size(); i++){\n            if(str[i] == '('){\n                cnt++;\n            }\n            if(str[i] == ')'){\n                cnt--;\n            }\n            if(cnt == 1){\n                if(str[i] == '*'){\n                    type = 1;\n                    a = str.substr(1, i - 1);\n                    b = str.substr(i + 1, str.size() - (i + 1) - 1);\n                    // cout << a << \" \" << b << endl;\n                    break;\n                }\n                else if(str[i] == '+'){\n                    type = 2;\n                    a = str.substr(1, i - 1);\n                    b = str.substr(i + 1, str.size() - (i + 1) - 1);\n                    // cout << a << \" \" << b << endl;\n                    break;\n                }\n            }\n        }\n    }\n\n    ll res = 0;\n    if(type == 0){\n        if(isdigit(a[0])){\n            res = hai(stoi(a));\n        }\n        else{\n            res = hai(calc(a));\n        }\n    }\n    else if(type == 1){\n        ll res_a = 0;\n        if(isdigit(a[0])) res_a = stoi(a);\n        else res_a = calc(a);\n        ll res_b = 0;\n        if(isdigit(b[0])) res_b  = stoi(b);\n        else res_b = calc(b);\n        res = kake(res_a, res_b);\n    }\n    else{\n        ll res_a = 0;\n        if(isdigit(a[0])) res_a = stoi(a);\n        else res_a = calc(a);\n        ll res_b = 0;\n        if(isdigit(b[0])) res_b  = stoi(b);\n        else res_b = calc(b);\n        res = plu(res_a, res_b);\n    }\n    return res;\n}\n\nll solve(string str){\n    ll res = 0;\n    string ori = str;\n    for(int r=0; r<3; r++){\n        for(int p=0; p<3; p++){\n            for(int q=0; q<3; q++){\n                str = ori;\n                for(int i=0; i<str.size(); i++){\n                    // static_cast<char>(r + '0')\n                    if(str[i] == 'R') str[i]=static_cast<char>(r + '0');\n                    else if(str[i] == 'P') str[i]= static_cast<char>(p + '0');\n                    else if(str[i] == 'Q') str[i]=static_cast<char>(q + '0');\n                }\n                // cout << str << endl;\n\n                if(isdigit(str[0])){\n                    if(str[0] == '2') res++;\n                    continue;\n                }\n                if(calc(str)==2) res++;\n                // cout << res << endl;\n            }\n        }\n    }\n    return res;\n}\n\nint main(int argc, const char * argv[]) {\n    //提出時、消す----//\n    //--------------//\n\n\n    // input\n    cout << fixed << setprecision(10);\n\n\n    // int k = 0;\n    while(1){\n        string str; cin >> str;\n        // cout << k << endl;\n        // k++;\n        if(str[0] == '.') break;\n\n        // cout << static_cast<char>(1 + '0') << endl;\n\n        cout << solve(str) << endl;\n    }\n\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "string in;\nint pos;\nint p,q,r;\n\nint formula(){\n  if(isdigit(in[pos])){\n    return in[pos++]-'0';\n  }\n\n  switch(in[pos]){\n  case 'P':++pos; return p;\n  case 'Q':++pos; return q;\n  case 'R':++pos; return r;\n  }\n\n  if(in[pos]=='-'){\n    ++pos;\n    return 2-formula();\n  }\n  ++pos;\n  int a=formula();\n  char cc=in[pos++];\n  int b=formula();\n  pos++;\n  if(cc=='+'){\n    if(a==2 || b==2)return 2;\n    if(!a && !b)return 0;\n    return 1;\n  }\n  if(!a || !b)return 0;\n  if(a==2 && b==2)return 2;\n  return 1;\n}\n\n\nmain(){\n  while(cin>>in){\n    if(in==\".\")break;\n    int ans=0;\n    for(p=0;p<3;p++)for(q=0;q<3;q++)for(r=0;r<3;r++){\n      pos=0;\n      if(formula()==2)++ans;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing State = string::const_iterator;\n\nstruct E{\n    int x = 0;\n    E(){}\n    E(int x): x(x){}\n    E &operator+=(const E& a){\n        if(x==2 || a.x==2){\n            x = 2;\n        }else if (x==1 || a.x==1){\n            x = 1;\n        }else{\n            x = 0;\n        }\n        return *this;\n    }\n    E &operator*=(const E& a){\n        if(x==0 || a.x==0){\n            x = 0;\n        }else if(x==1 || a.x==1){\n            x = 1;\n        }else{\n            x = 2;\n        }\n    }\n    E &operator-(){\n        x = 2-x;\n        return *this;\n    }\n    E operator+(const E& a){\n        return E(*this) += a;\n    }\n    E operator*(const E& a){\n        return E(*this) *= a;\n    }\n};\n\nE var[3];\n\nE formula(State &itr);\nE variable(State &itr);\n\nE formula(State &itr){\n    E res;\n    if(*itr == '-'){\n        itr++;\n        res = -formula(itr);\n    }else if(*itr == '('){\n        itr++;\n        res = formula(itr);\n        if(*itr == '*'){\n            itr++;\n            res *= formula(itr);\n        }else if(*itr == '+'){\n            itr++;\n            res += formula(itr);\n        }else{\n            // error\n        }\n        itr++; // ')'\n    }else{\n        res = variable(itr);\n    }\n    return res;\n}\n\nE variable(State &itr){\n    E res;\n    if(isdigit(*itr)){\n        res = E(*itr-'0');\n    }else if(isalpha(*itr)){\n        res = var[*itr-'P'];\n    }else{\n        // error\n    }\n    itr++;\n    return res;\n}\n\nint solve(){\n    string s;\n    cin >> s;\n    if(s == \".\") return 1;\n    int cnt = 0;\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++){\n        var[0] = E(i);\n        var[1] = E(j);\n        var[2] = E(k);\n        State begin = s.begin();\n        if(formula(begin).x == 2){\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n\nint main(){\n    while(solve()==0);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// 'P', 'Q', 'R' ツづー '1', '2', '3' ツづ可置ツつォツ環キツつヲツづゥ\nvoid PQR_change(string& s ,char p , char q , char r ){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == 'P' ) s[i] = p;\n\t\tif( s[i] == 'Q' ) s[i] = q;\n\t\tif( s[i] == 'R' ) s[i] = r;\n\t}\n}\n\n// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\" ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_erace(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '-' && s[i-1] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\nint eval(string s, int& pos){\n\tif( s[pos] == '0' ){ pos++; return 0; }\n\tif( s[pos] == '1' ){ pos++; return 1; }\n\tif( s[pos] == '2' ){ pos++; return 2; }\n\tif( s[pos] == '-' ){ pos++; return 2 - eval(s,pos) ; }\n\tif (s[pos] == '(') { \n\t\t++pos; \n\t\tint a = eval(s, pos);\n\t\tchar c = s[pos++];\n\t\tint b = eval(s, pos);\n\t\t++pos;\n\t\tif( c == '*' ){\n\t\t\treturn (a * b + 1) / 2;\n\t\t}else if( c == '+' ){\n\t\t\treturn max(a, b);\n\t\t}\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile( cin >> s , s != \".\" ){\n\t\tint ans = 0;\n\t\tfor(char p = '0' ; p <= '2' ; p++ ){\n\t\t\tfor(char q = '0' ; q <= '2' ; q++ ){\n\t\t\t\tfor(char r = '0' ; r <= '2' ; r++ ){\n\t\t\t\t\tstring ex = s;\n\t\t\t\t\t// 'P', 'Q', 'R' ツづー '1', '2', '3'ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tPQR_change( ex , p , q , r );\n\t\t\t\t\t// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\"ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tminus_erace( ex );\n\t\t\t\t\t\n\t\t\t\t\t// ツ篠ョツづ個評ツ可ソ\n\t\t\t\t\tint t=0;\n\t\t\t\t\tint val = eval( ex , t );\n\t\t\t\t\tif( val == 2 ){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n \n#define rep(i,n) for((i)=0;(i)<(n);i++)\n \nusing namespace std;\n \nint p,q,r,now;\nstring s;\n \nint formula(void){\n     \n    if(isdigit(s[now])){return s[now++]-'0';}\n    if(s[now]=='P'){now++;return p;}\n    if(s[now]=='Q'){now++;return q;}\n    if(s[now]=='R'){now++;return r;}\n     \n    int res=0;\n    if(s[now]=='-'){now++;return 2-formula();}\n    if(s[now]=='('){\n        now++;\n        res=formula();\n        if(s[now]=='*'){now++;res=min(res,formula());}\n        else if(s[now]=='+'){now++;res=max(res,formula());}\n        now++;\n    }\n    return res;\n}\n \nint main(void){\n     \n    while(cin >> s,s!=\".\"){\n         \n        int cnt=0;\n        rep(p,3)rep(q,3)rep(r,3){\n            now=0;\n            if(formula()==2)cnt++;\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nchar NOT[3] = {'2', '1', '0'};\nchar AND[3][3] = {{'0', '0', '0'}, {'0', '1', '1'}, {'0', '1', '2'}};\nchar OR[3][3] = {{'0', '1', '2'}, {'1', '1', '2'}, {'2', '2', '2'}};\n\nchar s[100];\nchar s1[100];\n\nchar getNumber() {\n  char k[100], kLeft[100], kN[100], kNumber = 0, notCounter = 0;\n  char ans;\n  for (char i = 0; s1[i] != 0; i++) {\n    if (s1[i] == '*' || s1[i] == '+') kLeft[kNumber] = s1[i-1] - '0';\n    if (s1[i] == '-') notCounter++;\n    else if (s1[i] == '(') kNumber++;\n    else if (s1[i] == '*') kN[kNumber] = 0;\n    else if (s1[i] == '+') kN[kNumber] = 1;\n    else if (s1[i] == ')') {\n      if (kN[kNumber] == 0) {\n        s1[i] = AND[kLeft[kNumber]][s1[i-1] - '0'];\n      } else {\n        s1[i] = OR[kLeft[kNumber]][s1[i-1] - '0'];\n      }\n      kNumber--;\n      ans = s1[i];\n    } else {\n      if (notCounter % 2 == 1) s1[i] = NOT[s1[i] - '0'];\n      ans = s1[i];\n      notCounter = 0;\n    }\n  }\n  return ans - '0';\n}\n\nchar check(char p, char q, char r) {\n  for (char i = 0; s[i] != 0; i++) {\n    s1[i] = s[i];\n    if (s1[i] == 'P') s1[i] = p + '0';\n    if (s1[i] == 'Q') s1[i] = q + '0';\n    if (s1[i] == 'R') s1[i] = r + '0';\n    s1[i+1] = 0;\n  }\n  if (getNumber() == 2) return 1;\n  return 0;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%s\", s);\n    if (s[0] == '.') break;\n    char ans = 0;\n    for (char p = 0; p < 3; p++)\n      for (char q = 0; q < 3; q++)\n        for (char r = 0; r < 3; r++)\n          ans += check(p, q, r);\n    printf(\"%d\\n\", (int)ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint formula();\nvoid input();  // 終了処理有り\nvoid chkRPar();\nint expression();\nint calcPlus(int, int);\nint calcMul(int, int);\n\nchar ch;\nint pos;\nstring str;\nint P, Q, R;\nint nFlg = 1;  // 1 or -1 をformulaに掛ける。VARIABLEが来て初期化 1\n\nint main(void) {\n  int cnt, res;\n\n  while(1) {\n    cnt = 0;\n    getline(cin, str);\n    //cout << str << endl;\n    for(P = 0; P < 3; P++) {\n      for(Q = 0; Q < 3; Q++) {\n\tfor(R = 0; R < 3; R++) {\n\t  pos = 0;\n\t  res = expression();\n\t  if(res == -1) return 0;\n\t  if(res == 2) cnt++;\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}\n\nvoid chkRPar() {\n  input();\n}\nvoid input() {\n  ch = str[pos++];\n  // cout << \"---\" << ch << endl;\n}\n\nint expression() {\n  int res = 0;\n  \n  input();\n  if (ch == '.') return -1;\n\n  switch (ch) {\n  case '(':\n    res = expression();\n    input();\n    switch(ch) {\n    case '+':\n      res = calcPlus(res, expression());\n      break;\n    case '*':\n      res = calcMul(res, expression());\n      break;\n    }\n    chkRPar();\n    break;\n\n  default:\n    switch(ch) {\n    case '-':\n      res = 2 - expression();\n      break;\n    default:\n      res = formula();\n    }\n    break;\n  }\n\n  return res;\n}\n\nint formula() {\n\n  if(isdigit(ch)) return ch - '0';\n\n  switch(ch) {\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  }\n}\n\nint calcPlus(int d1, int d2) {\n  switch(d1) {\n  case 0:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 2;\n    }\n\n  case 1:\n    switch(d2) {\n    case 0: return 1;\n    case 1: return 1;\n    case 2: return 2;\n    }\n\n  case 2:\n    switch(d2) {\n    case 0: return 2;\n    case 1: return 2;\n    case 2: return 2;\n    }\n  }\n}\n\nint calcMul(int d1, int d2) {\n  switch(d1) {\n  case 0:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 0;\n    case 2: return 0;\n    }\n\n  case 1:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 1;\n    }\n\n  case 2:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 2;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\ntypedef string::const_iterator State;\nint p,q,r;\n\nint number(State &begin);\nint term(State &begin);\nint expr(State &begin);\nint factor(State &begin);\n\n\nint NOT(int x){\n  if(x==0)return 2;\n  else if(x==1)return 1;\n  else return 0;\n}\n\nint AND(int x,int y){\n  if(x==0||y==0)return 0;\n  else if(x==2&&y==2)return 2;\n  else return 1;\n}\n\nint OR(int x,int y){\n  if(x==0&&y==0)return 0;\n  else if(x==2||y==2)return 2;\n  else return 1;\n}\n\nint main(){\n  string s;\n  int ans=0;\n  while(cin>>s){\n    if(s==\".\")break;\n    ans=0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  State begin=s.begin();\n\t  if(expr(begin)==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nint number(State &begin){\n  int ret=-1;\n  if(isdigit(*begin)) ret=(*begin-'0');\n  else if(*begin=='P') ret=p;\n  else if(*begin=='Q') ret=q;\n  else if(*begin=='R') ret=r;\n  begin++;\n  return ret;\n}\n\nint term(State &begin){\n  if(*begin=='-'){\n    begin++;\n    return NOT(term(begin));\n  }else{\n    return factor(begin);\n  }\n}\n\nint expr(State &begin){\n  int ret=term(begin);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret=OR(ret,term(begin));\n    }else if(*begin=='*'){\n      begin++;\n      ret=AND(ret,term(begin));\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  int ret=0;\n  if(*begin=='('){\n    begin++;\n    ret=expr(begin);\n    begin++;\n  }else{\n    ret=number(begin);\n  }\n  return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n\nstring input, ss;\nint a[3], it, cnt;\n\nint Not(int x) {\n    return 2-x;\n}\n\nint And(int x, int y) {\n    if (x*y == 0) return 0;\n    if (x == 2 && y == 2) return 2;\n    return 1;\n}\n\nint Or(int x, int y) {\n    if (x == 2 || y == 2) return 2;\n    if (x == 1 || y == 1) return 1;\n    return 0;\n}\n\nint parse() {\n    char c = ss[it++];\n    if ('0' <= c && c <= '2') return c-'0';\n    if (c == '-') return Not(parse());\n\n    int x = parse();\n    c = ss[it++];\n    int y = parse();\n    ++it;\n    return c == '*' ? And(x, y) : Or(x, y);\n}\n\nint main() {\n    while (cin >> input && input != \".\") {\n        rep (i,3) a[i] = i;\n        cnt = 0;\n        rep (i,3) rep (j,3) rep (k,3) {\n            a[0] = i; a[1] = j; a[2] = k;\n            ss = input;\n            for (char& c : ss) {\n                if (c == 'P') c = a[0]+'0';\n                if (c == 'Q') c = a[1]+'0';\n                if (c == 'R') c = a[2]+'0';\n            }\n            it = 0;\n            if (parse() == 2) cnt++;\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint a[] = {2, 1, 0}, b[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}}, c[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tREP(p, 3) REP(q, 3) REP(r, 3) {\n\t\t\t//cout << p << \" \" << q << \" \" << r << endl;\n\t\t\t//???????????°??????????????????\n\t\t\tstring t = s;\n\t\t\tREP(i, t.size()) {\n\t\t\t\tif(t[i] == 'P') t[i] = p + '0';\n\t\t\t\tif(t[i] == 'Q') t[i] = q + '0';\n\t\t\t\tif(t[i] == 'R') t[i] = r + '0';\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\t//???????????????\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '-') cnt++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cnt > 0) {\n\t\t\t\t\t\t\tint cc = cnt;\n\t\t\t\t\t\t\tcnt %= 3;\n\t\t\t\t\t\t\tif('0'<=t[i]&&t[i]<'3') {\n\t\t\t\t\t\t\t\tint tmp = t[i] - '0';\n\t\t\t\t\t\t\t\tREP(j, cnt) {\n\t\t\t\t\t\t\t\t\ttmp = a[tmp];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt = t.substr(0, i-cc) + (char)(tmp+'0') + t.substr(i+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????£?????????+??¨*?????????\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '+') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1])) {\n\t\t\t\t\t\t\tint tmp = c[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(t[i] == '*') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1])) {\n\t\t\t\t\t\t\tint tmp = b[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << t << endl;\n\t\t\t\tif(t.size() == 1) break;\n\t\t\t}\n\t\t\tif(t == \"2\") ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tif(s.size()==1)return s[0];\n\tint cnt=0,f,now=-1;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tif(now==-1)now=mt;\n\t\t\telse{\n\t\t\t\tif(f==0)now=_and[now][mt];\n\t\t\t\telse now=_or[now][mt];\n\t\t\t}\n\t\t}\n\t}\n\treturn now+'0';\n}\nchar rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\tchar tt=pyon(s,p,q,r);\n\treturn tt;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tif(rec(s,i,j,k)=='2')cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nstring S;\n\nint notVal(int x){\n    return 2-x;\n}\n\nint changeVal(int a,int b,char op){\n    if(op=='+') return max(a,b);\n    else return min(a,b);\n}\n\nbool judge(int a,int b,int c){\n    char opt[100];\n    vector<int> val[100];\n    int no[100]={};\n\n    int dep=0;\n    for(int i=0;i<S.size();i++){\n        if(S[i]=='(') dep++;\n        else if(S[i]==')'){\n            int va=changeVal(val[dep][0],val[dep][1],opt[dep]);\n            val[dep].clear();\n            if(no[dep-1]) va=notVal(va);\n            no[dep-1]=0;\n            dep--;\n            val[dep].push_back(va);\n        }else if(S[i]=='-'){\n            no[dep]=1-no[dep];\n        }else if(S[i]=='+'){\n            opt[dep]='+';\n        }else if(S[i]=='*'){\n            opt[dep]='*';\n        }else if(S[i]>='0'&&S[i]<='2'){\n            int va=S[i]-'0';\n            if(no[dep]) va=notVal(va);\n            no[dep]=0;\n            val[dep].push_back(va);\n        }else{\n            int va=0;\n            if(S[i]=='P') va=a;\n            else if(S[i]=='Q') va=b;\n            else if(S[i]=='R') va=c;\n\n            if(no[dep]) va=notVal(va);\n            no[dep]=0;\n            val[dep].push_back(va);\n        }\n    }\n\n    if(val[0][0]==2) return true;\n    else return false;\n}\n\nvoid solve(){\n    int ans=0;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                if(judge(i,j,k)) ans++;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    while(1){\n        cin>>S;\n        if(S==\".\") break;\n        solve();\n    }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n \ntypedef int value;\n \nstring s;\nsize_t cur = 0;\nvalue P, Q, R;\nint ans = 0;\n \nstatic value and(value a, value b){\n    return (a<b) ? a : b;\n}\nstatic value or(value a, value b){\n    return (a<b) ? b : a;\n}\nvalue formula(){\n    value a, b, f;\n    char op;\n    switch (s[cur]){\n    case ('0') :\n    case ('1') :\n    case ('2') :\n               f = s[cur] - '0';\n        cur++;\n        break;\n    case ('P') :\n        f = P;\n        cur++;\n        break;\n    case ('Q') :\n        f = Q;\n        cur++;\n        break;\n    case ('R') :\n        f = R;\n        cur++;\n        break;\n    case ('-') :\n        f = 2 - formula();\n        break;\n    case ('(') :\n        cur++;\n        a = formula();\n        assert(s[cur] == '*' || s[cur] == '+');\n        op = s[cur];\n        cur++;\n        b = formula();\n        f = (op == '*') ? and(a, b) : or(a, b);\n        assert(s[cur] == ')');\n        cur++;\n        break;\n    default:\n        assert(false);\n        break;\n    }\n    return f;\n}\nint main(){\n    cin >> s;\n    while (s != \".\"){\n        for (P = 0; P <= 2; P++)\n            for (Q = 0; Q <= 2; Q++)\n                for (R = 0; R <= 2; R++){\n                    if (formula() == 2)ans++;\n                    cur = 0;\n                }\n        cout << ans << endl;\n        ans = 0;\n        cin >> s;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint neg(int v) {\n\tint ret = v;\n\tif (v == 0) {\n\t\tret = 2;\n\t} else if (v == 2) {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nint conj(int lhs, int rhs) {\n\tif (lhs == 0 || rhs == 0) {\n\t\treturn 0;\n\t}\n\tif (lhs == 2 && rhs == 2) {\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nint disj(int lhs, int rhs) {\n\tif (lhs == 2 || rhs == 2) {\n\t\treturn 2;\n\t}\n\tif (lhs == 0 && rhs == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nclass Parser {\n\tprivate:\n\t\tstring line;\n\t\tint pos;\n\tpublic:\n\t\tParser(string _line) {\n\t\t\tline = _line;\n\t\t\tpos = 0;\n\t\t}\n\n\t\tvoid assign(char var, int val) {\n\t\t\tREP (i, line.length()) {\n\t\t\t\tif (line[i] == var) {\n\t\t\t\t\tline[i] = val + '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint formula() {\n\t\t\tif (line[pos] == '0' || line[pos] == '1' || line[pos] == '2') {\n\t\t\t\treturn constant();\n\t\t\t}\n\t\t\tif (line[pos] == '-') {\n\t\t\t\tpos++;\n\t\t\t\treturn neg(formula());\n\t\t\t}\n\t\t\tif (line[pos] == '(') {\n\t\t\t\tpos++;\n\t\t\t\tint lhs = formula();\n\t\t\t\tchar op = line[pos];\n\t\t\t\tpos++;\n\t\t\t\tint rhs = formula();\n\t\t\t\tassert(line[pos] == ')');\n\t\t\t\tpos++;\n\t\t\t\tif (op == '*') {\n\t\t\t\t\treturn conj(lhs, rhs);\n\t\t\t\t} else {\n\t\t\t\t\treturn disj(lhs, rhs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\n\t\tint constant() {\n\t\t\tchar c = line[pos];\n\t\t\tpos++;\n\t\t\treturn c - '0';\n\t\t}\n};\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tstring s;\n\twhile (cin >> s, s != \".\") {\n\t\tint ans = 0;\n\t\tREP (p, 3) {\n\t\t\tREP (q, 3) {\n\t\t\t\tREP (r, 3) {\n\t\t\t\t\tParser parser(s);\n\t\t\t\t\tparser.assign('P', p);\n\t\t\t\t\tparser.assign('Q', q);\n\t\t\t\t\tparser.assign('R', r);\n\t\t\t\t\tif (parser.formula() == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tstring formula = read<string>();\n\t\tconst string to[3] = { \"0\", \"1\", \"2\" };\n\n\t\tif (formula == \".\") { break; }\n\t\t\n\t\tint ok = 0;\n\t\tREP(p, 3) REP(q, 3) REP(r, 3)\n\t\t{\n\t\t\tstring f = formula;\n\t\t\tinplaceReplace(f, \"P\", to[p], true);\n\t\t\tinplaceReplace(f, \"Q\", to[q], true);\n\t\t\tinplaceReplace(f, \"R\", to[r], true);\n\n\t\t\twhile (f.length() > 1)\n\t\t\t{\n\t\t\t\tinplaceReplace(f, \"-0\", \"2\");\n\t\t\t\tinplaceReplace(f, \"-1\", \"1\");\n\t\t\t\tinplaceReplace(f, \"-2\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(0*0)\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(0*1)\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(0*2)\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(1*0)\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(1*1)\", \"1\");\n\t\t\t\tinplaceReplace(f, \"(1*2)\", \"1\");\n\t\t\t\tinplaceReplace(f, \"(2*0)\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(2*1)\", \"1\");\n\t\t\t\tinplaceReplace(f, \"(2*2)\", \"2\");\n\t\t\t\tinplaceReplace(f, \"(0+0)\", \"0\");\n\t\t\t\tinplaceReplace(f, \"(0+1)\", \"1\");\n\t\t\t\tinplaceReplace(f, \"(0+2)\", \"2\");\n\t\t\t\tinplaceReplace(f, \"(1+0)\", \"1\");\n\t\t\t\tinplaceReplace(f, \"(1+1)\", \"1\");\n\t\t\t\tinplaceReplace(f, \"(1+2)\", \"2\");\n\t\t\t\tinplaceReplace(f, \"(2+0)\", \"2\");\n\t\t\t\tinplaceReplace(f, \"(2+1)\", \"2\");\n\t\t\t\tinplaceReplace(f, \"(2+2)\", \"2\");\n\t\t\t}\n\t\t\tif (f == \"2\") { ok++; }\n\t\t}\n\t\twrite(ok);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nvector<int> pqr;\nint form(string &s, int &pos){\n\tif(s[pos]=='-'){\n\t\treturn 2-form(s,++pos);\n\t}else if(s[pos]=='('){\n\t\tint a = form(s,++pos);\n\t\tchar op = s[pos];\n\t\tint b = form(s,++pos);\n\t\tpos++;\n\t\tif(op=='+')return max(a,b);\n\t\telse return min(a,b);\n\t}else{\n\t\tchar c = s[pos];\n\t\tif(c>='0'&&c<='2'){\n\t\t\tpos++;\n\t\t\treturn c-'0';\n\t\t}else{\n\t\t\tpos++;\n\t\t\treturn pqr[c-'P'];\n\t\t}\n\t}\n}\nint solve(){\n\tstring s;\n\tcin >> s;\n\tif(s==\".\")return 1;\n\tint ans = 0;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tpqr.clear();\n\t\t\t\tpqr.pb(i);\n\t\t\t\tpqr.pb(j);\n\t\t\t\tpqr.pb(k);\n\t\t\t\tint pos = 0;\n\t\t\t\tint res = form(s,pos);\n\t\t\t\tif(res==2)ans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef function<int(vector<int>)> node_t;\nsize_t cur; string s;\nnode_t parse() {\n    char c = s[cur++];\n    if(isdigit(c))\n      return [=](vector<int> arg) { return c - '0';};\n    if(isalpha(c))\n      return [=](vector<int> arg) { return arg[c - 'P'];};\n    node_t left = parse();\n    if(c == '-')\n      return [=](vector<int> arg) { return 2 - left(arg);};\n    assert(c == '(');\n    char op = s[cur++];\n    node_t right = parse();\n    ++cur;\n    if(op == '*')\n      return [=](vector<int> arg) {\n          int l = left(arg), r = right(arg);\n          return !l || !r ? 0 : (l == 1 || r == 1 ? 1 : 2);\n      };\n    if(op == '+')\n      return [=](vector<int> arg) {\n          int l = left(arg), r = right(arg);\n          return l == 2 || r == 2 ? 2 : (!l && !r ? 0 : 1);\n      };\n}\n      \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> s && s != \".\") {\n        int count = 0;\n        auto tree = parse();\n        cur = 0;\n        rep(p, 3) rep(q, 3) rep(r, 3) {\n            vector<int> arg = {p, q, r};\n            if(tree(arg) == 2) ++count;\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint p,q,r;\nvoid invert(stack<int> &st){\n    int x;\n    x=st.top();\n    st.pop();\n\tif(st.empty()){\n\t\tst.push(x);\n\t\treturn;\n\t}\n    while(st.top()==-1){\n        st.pop();\n        x=(x-1)*(-1)+1;\n\t//\tcout << st.size();\n    }\n\tst.push(x);\n    return;\n}\n\nvoid calc(stack<int> &st){\n\tint x,y;\n\twhile(true){\n\t\tinvert(st);\n\t\tx=st.top();\n\t\tst.pop();\n\t\tif(st.top()==-4){\n\t\t\tst.pop();\n\t\t\tst.push(x);\n\t\t\tinvert(st);\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tint t=st.top();\n\t\t\tst.pop();\n\t\t\tinvert(st);\n\t\t\tif(t==-2){\n\t\t\t\ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(max(x,y));\n\t\t\t}\n\t\t\telse if(t==-3){\n\t\t\t\ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(min(x,y));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(true){\n\t\tstring str;\n\t\tcin >> str;\n\t\tint ans=0;\n\t\tstack<int> st;\n\t\tif(str[0]=='.')break;\n\t\tfor(p=0;p<3;p++){\n\t\tfor(q=0;q<3;q++){\n\t\tfor(r=0;r<3;r++){\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(str[i]=='(')st.push(-4);\n\t\t\t\telse if(str[i]=='-')st.push(-1);\n\t\t\t\telse if(str[i]=='+')st.push(-2);\n\t\t\t\telse if(str[i]=='*')st.push(-3);\n\t\t\t\telse if(str[i]=='P')st.push(p);\n\t\t\t\telse if(str[i]=='Q')st.push(q);\n\t\t\t\telse if(str[i]=='R')st.push(r);\n\t\t\t\telse if(str[i]==')')calc(st);\n\t\t\t\telse st.push((int)(str[i]-'0'));\n\t\t\t}\t\n\t\t\tif(st.top()==2)ans++;\n\t\t}\n\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint seki[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint wa[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\nint hoge[3] = {2,1,0};\n\nint p,q,r;\nint eval(string s) {\n  //  cout << s << endl;\n  if (s[0]=='-') {\n    int i;\n    for (i=0;s[i]=='-';i++);\n    if (i%2) return hoge[eval(s.substr(i))];\n    else return eval(s.substr(i));\n  }\n  if (s[0]!='(') {\n    int foo;\n    if (isdigit(s[0])) foo = s[0]-'0';\n    if (s[0]=='P') foo = p;\n    if (s[0]=='Q') foo = q;\n    if (s[0]=='R') foo = r;\n    return foo;\n  }\n  int nest = 0;\n  REP(i,s.length()) {\n    if (s[i] == '(') nest++;\n    if (s[i] == ')') nest--;\n    if (nest!=1) continue;\n    if (s[i] == '+') return wa[eval(s.substr(1,i-1))][eval(s.substr(i+1,s.length()-i-2))];\n    if (s[i] == '*') return seki[eval(s.substr(1,i-1))][eval(s.substr(i+1,s.length()-i-2))];\n  }\n}\n\n\nint main() {\n  string s;\n  while(cin>>s,s!=\".\") {\n    int ans = 0;\n    for(p=0;p<3;p++) {\n      for(q=0;q<3;q++) {\n        for(r=0;r<3;r++) {\n          if (eval(s)==2)\n            ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tif(s.size()==1)return s[0];\n\tint cnt=0,f,now=-1;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tif(now==-1)now=mt;\n\t\t\telse{\n\t\t\t\tif(f==0)now=_and[now][mt];\n\t\t\t\telse now=_or[now][mt];\n\t\t\t}\n\t\t}\n\t}\n\treturn now+'0';\n}\nchar rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\tchar tt=pyon(s,p,q,r);\n\treturn tt;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tif(rec(s,i,j,k)=='2')cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p, q, r, cursor;\nstring s;\n\nint not(int a) {\n\treturn 2 - a;\n}\n\nint and(int a, int b) {\n\tif(a == 0 || b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint or(int a, int b) {\n\tif(a == 2 || b == 2) return 2;\n\tif(a == 1 || b == 1) return 1;\n\treturn 0;\n}\n\nint f() {\n\tchar c = s[cursor];\n\tcursor++;\n\tif(c == '0') return 0;\n\tif(c == '1') return 1;\n\tif(c == '2') return 2;\n\tif(c == 'P') return p;\n\tif(c == 'Q') return q;\n\tif(c == 'R') return r;\n\tif(c == '-') return not(f());\n\tif(c == '(') {\n\t\tint a = f();\n\t\tchar op = s[cursor];\n\t\tcursor++;\n\t\tint b = f();\n\t\tcursor++;\n\t\tif(op == '*') {\n\t\t\treturn and(a, b);\n\t\t}\n\t\telse {\n\t\t\treturn or(a, b);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> s, s[0] != '.') {\n\t\tint ans = 0;\n\t\tfor(p = 0; p <= 2; p++) {\n\t\t\tfor(q = 0; q <= 2; q++) {\n\t\t\t\tfor(r = 0; r <= 2; r++) {\n\t\t\t\t\tcursor = 0;\n\t\t\t\t\tif(f() == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(void){\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \".\") return 0;\n        \n        int ans = 0;\n        for (int i = 0; i < 27; i++) {\n            int p = i % 3, q = (i / 3) % 3, r = (i / 9) % 3;\n            \n            int neg = 0, idx = 0;\n            vector<char> ope;\n            vector<int> val[30];\n            for (int j = 0; j < s.size(); j++) {\n                if (char(s[j]) == '-') neg++;\n                else if (char(s[j]) == '+') ope.push_back(1);\n                else if (char(s[j]) == '*') ope.push_back(2);\n                else if (char(s[j]) == 'P') {\n                    if (neg % 2 == 0) val[idx].push_back(p);\n                    else val[idx].push_back(2 - p);\n                    neg = 0;\n                }\n                else if (char(s[j]) == 'Q') {\n                    if (neg % 2 == 0) val[idx].push_back(q);\n                    else val[idx].push_back(2 - q);\n                    neg = 0;\n                }\n                else if (char(s[j]) == 'R') {\n                    if (neg % 2 == 0) val[idx].push_back(r);\n                    else val[idx].push_back(2 - r);\n                    neg = 0;\n                }\n                else if (char(s[j]) == '(') idx++;\n                else if (char(s[j]) == ')') {\n                    idx--;\n                    if (ope[ope.size() - 1] == 1) {\n                        val[idx].push_back(max(val[idx + 1][0], val[idx + 1][1]));\n                    }\n                    else {\n                        val[idx].push_back(min(val[idx + 1][0], val[idx + 1][1]));\n                    }\n                    ope.pop_back();\n                    val[idx + 1].clear();\n                }\n                else {\n                    if (neg % 2 == 0) val[idx].push_back(int(s[j] - '0'));\n                    else val[idx].push_back(2 - int(s[j] - '0'));\n                    neg = 0;\n                }\n            }\n            \n            if (val[0][0] == 2) {\n                ans++;\n            }\n            //cout << p << \" \" << q << \" \" << r << \" \" << val[0][0] << endl;\n            for (int j = 0; j < 20; j++) val[j].clear();\n            ope.clear();\n        }\n        \n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring NEG[]={\"2\",\"1\",\"0\"},AND[][3]={{\"0\",\"0\",\"0\"},{\"0\",\"1\",\"1\"},{\"0\",\"1\",\"2\"}},\nOR[][3]={{\"0\",\"1\",\"2\"},{\"1\",\"1\",\"2\"},{\"2\",\"2\",\"2\"}};\nstring replaceAll(string s,string f,string t) {\n\tstring r;\n\tfor(int p=0;(p=s.find(f))!=s.npos;)r+=s.substr(0,p)+t,s=s.substr(p+f.size());\n\treturn r+s;\n}\nstring replace(string s,string f,string t){\n\tstring r;\n\tint p=s.find(f);\n\tif (p!=s.npos)r+=s.substr(0,p)+t,s=s.substr(p+f.size());\n\treturn r+s;\n}\nint main(){\n\tstring s,t,nt,n,a,o,nm;\n\twhile(cin>>s,s!=\".\"){\n\t\tint c=0;\n\t\trep(p,3)rep(q,3)rep(r,3){\n\t\t\tnm=\" \";nm[0]='0'+p;\n\t\t\tt=replaceAll(s,\"P\",nm);nm[0]='0'+q;\n\t\t\tt=replaceAll(t,\"Q\",nm);nm[0]='0'+r;\n\t\t\tt=replaceAll(t,\"R\",nm);\n\t\t\tfor(nt=t;;t=nt){\n\t\t\t\trep(i,3){\n\t\t\t\t\tn=\"- \",n[1]=i+'0';\n\t\t\t\t\tnt=replaceAll(nt,n,NEG[i]);\n\t\t\t\t\trep(j,3){\n\t\t\t\t\t\ta=\"(X*X)\",a[1]=i+'0',a[3]=j+'0';\n\t\t\t\t\t\to=\"(X+X)\",o[1]=i+'0',o[3]=j+'0';\n\t\t\t\t\t\tnt=replaceAll(nt,a,AND[i][j]);\n\t\t\t\t\t\tnt=replaceAll(nt,o,OR[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t==nt)break;\n\t\t\t}\n\t\t\tif(t==\"2\")c++;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nstring s;\nint p, q, r;\nint pos;\nint get_val(int x, int y, char op)\n{\n    int res;\n    if(op == '*') res = min(x, y);\n    else res = max(x, y);\n    return res;\n}\nint Solve()\n{\n    char op = '#';;\n    if(s[pos] == '(') \n    {\n        pos++;\n        int A = Solve();\n        char op = s[pos];\n        pos++;\n        int B = Solve();\n        pos++;\n        return get_val(A, B, op);\n    }\n    else if(s[pos] == ')') return 0;\n    else if(s[pos] == '-')\n    {\n        pos++;\n        return 2 - Solve();\n    }\n    else\n    {\n        int num;\n        if(s[pos] == 'P') num = p;\n        else if(s[pos] == 'Q') num = q;\n        else if(s[pos] == 'R') num = r;\n        else num = s[pos] - '0';\n        pos++;\n        return num;\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> s)\n    {\n        if(s == \".\") break;\n        int ans = 0;\n        for(p = 0; p < 3; p++)\n        {\n            for(q = 0; q < 3; q++)\n            {\n                for(r = 0; r < 3; r++) \n                {\n                    pos = 0;\n                    if(Solve() == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint Minus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    Minus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  int tm=0;\n    cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[tm++]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[tm++]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[tm++]=k+'0';\n\t    }else{\n\t      tmp[tm++]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::string::const_iterator State;\n\nint Expr(State&);\n\n// Num: '0', '1', '2'\nint Num(State &begin){\n    return *(begin++) - '0';\n}\n\n// Not: '-' Not / Num\nint Not(State &begin){\n    if(*begin == '-'){\n        begin++;\n        int n = Not(begin);\n        return 2-n;\n    }\n    return Num(begin);\n}\n\n// Fact: '(' Expr ')' / Not\nint Fact(State &begin){\n    if(*begin == '('){\n        begin++;\n        int n = Expr(begin);\n        begin++;\n        return n;\n    }\n    return Not(begin);\n}\n\n// Term: Fact '*' Fact\nint Term(State &begin){\n    int res = Fact(begin);\n    if(*begin == '*'){\n        begin++;\n        res = std::min(res, Fact(begin));\n    }\n    return res;\n}\n\n// Expr: Term '+' Term\nint Expr(State &begin){\n    int res = Term(begin);\n    if(*begin == '+'){\n        begin++;\n        res = std::max(res, Fact(begin));\n    }\n    return res;\n}\n\nvoid position(std::string &s, char c, std::vector<int> &v){\n    int pos = 0;\n    while(pos = s.find(c, pos), pos != std::string::npos){\n        v.push_back(pos);\n        pos += 1;\n    }\n}\n\nint main(){\n    std::string s;\n    while(std::cin >> s, s != \".\"){\n        std::vector<int> p_pos, q_pos, r_pos;\n        position(s, 'P', p_pos);\n        position(s, 'Q', q_pos);\n        position(s, 'R', r_pos);\n        \n        int res = 0;\n        REP(p, 3){\n            REP(q, 3){\n                REP(r, 3){\n                    std::string t = s;\n                    REP(i, p_pos.size()){\n                        t[p_pos[i]] = p+'0';\n                    }\n                    REP(i, q_pos.size()){\n                        t[q_pos[i]] = q+'0';\n                    }\n                    REP(i, r_pos.size()){\n                        t[r_pos[i]] = r+'0';\n                    }\n                    // std::cout << t << std::endl;\n                    State state = t.begin();\n                    if(Expr(state) == 2){res++;}\n                }\n            }\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s;\nint p, P, Q, R;\n\nint solve()\n{\n\tif (isdigit(s[p]))\n\t{\n\t\tint n = s[p] - '0';\n\t\tp++;\n\t\treturn n;\n\t}\n\telse if (s[p] == '(')\n\t{\n\t\tp++;\n\t\tint a = solve();\n\t\tchar c = s[p];\n\t\tp++;\n\t\tint b = solve();\n\t\tp++;\n\t\tif (c == '+') return max(a, b);\n\t\telse if(c=='*') return min(a, b);\n\t\treturn 0;\n\t}\n\telse if (s[p] == '-')\n\t{\n\t\tp++;\n\t\tint t = solve();\n\t\treturn 2 - t;\n\t}\n\telse if (s[p] == 'P')\n\t{\n\t\tp++;\n\t\treturn P;\n\t}\n\telse if (s[p] == 'Q')\n\t{\n\t\tp++;\n\t\treturn Q;\n\t}\n\telse if (s[p] == 'R')\n\t{\n\t\tp++;\n\t\treturn R;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile (cin >> s&&s != \".\")\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, 3)REP(j, 3)REP(k, 3)\n\t\t{\n\t\t\tP = i; Q = j; R = k;\n\t\t\tp = 0;\n\t\t\tif (solve() == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nusing namespace std;\ntypedef int tribool;\ntribool tri_negate(tribool x) { return 2 - x; }\ntribool tri_mult(tribool x, tribool y) { return min(x,y); }\ntribool tri_plus(tribool x, tribool y) { return max(x,y); }\nstring s;\nint p, q, r;\nint ix;\ntribool eval() {\n    switch (s[ix]) {\n        case '0':\n        case '1':\n        case '2':\n            ix += 1; return s[ix-1]-'0';\n        case 'P':\n            ix += 1; return p;\n        case 'Q':\n            ix += 1; return q;\n        case 'R':\n            ix += 1; return r;\n        case '-':\n            ix += 1; return tri_negate(eval());\n        case '(': {\n            ix += 1; tribool a = eval();\n            char op = s[ix]; ix += 1;\n            tribool b = eval();\n             ix += 1; // consume ')'\n            switch (op) {\n                case '*':\n                    return tri_mult(a,b);\n                case '+':\n                    return tri_plus(a,b);\n                default:\n                    assert(false);\n            }\n        }\n        default:\n            assert(false);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    while (true) {\n        cin >> s;\n        if (s == \".\") break;\n        int cnt = 0;\n        repeat (i,27) {\n            p = i/9;\n            q = (i/3)%3;\n            r = i%3;\n            ix = 0;\n            if (eval() == 2) {\n                cnt += 1;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nint P, Q, R;\nint tmp1[3] = { 2, 1, 0}, tmp2[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint tmp3[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nint formula(Cursol &c){\n  int ret ;\n  if(*c == 'P') ret = P;\n  else if(*c == 'Q') ret = Q;\n  else if(*c == 'R') ret = R;\n  else if(isdigit(*c)) ret = *c - '0';\n  else if(*c == '-') return tmp1[formula(++c)];\n  else if(*c == '('){\n    ret = formula(++c);\n    if(*c == '*') ret = tmp2[ret][formula(++c)];\n    else if(*c == '+') ret = tmp3[ret][formula(++c)];\n  }\n  c++;\n  return ret;\n}\nint main(){\n\n  string s;\n  Cursol c;\n\n  while( cin >> s, s != \".\"){\n    int ret = 0;\n    for(P = 0 ; P < 3 ; P++ ){\n      for(Q = 0 ; Q < 3 ; Q++ ){\n        for(R = 0 ; R < 3 ; R++ ){\n          c = s.begin();\n          if( 2 == formula(c)) ret++;\n        }\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint P, Q, R;\nconst char *p;\n\nint formula() {\n  \n  p++;\n\n  switch( *p ) {\n  case '-': return 2 - formula();\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  case '0': return 0;\n  case '1': return 1;\n  case '2': return 2;\n    \n  case '(':\n    int form1 = formula();\n    int form2;\n    p++;\n    switch( *p ) {\n    case '*':\n      form2 = formula();\n      p ++;\n      if( form1 == 0 || form2 == 0 ) return 0;\n      if( form1 == 1 || form2 == 1 ) return 1;\n      else return 2;\n    case '+':\n      form2 = formula();\n      p++;\n      if( form1 == 2 || form2 == 2 ) return 2;\n      if( form1 == 1 || form2 == 1 ) return 1;\n      else return 0;\n    }\n  }\n  \n  return 0;\n}\n\nint main() {\n  string str;\n  \n  while(getline(cin, str)) {\n    int cnt = 0;\n    if( str == \".\" ) break;\n    for(int i=0; i<3; i++) {\n      for(int j=0; j<3; j++) {\n\tfor(int k=0; k<3; k++) {\n\t  P = i, Q = j, R = k;\n\t  p = &str[0]-1;\n\t  if( formula() == 2 ) cnt ++;\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define State string::const_iterator\nclass ParseError {};\n\n\nint expression(State &begin);\n//int term(State &begin);\nint number(State &begin);\nint factor(State &begin);\nint denial(State &begin);\nvoid consume(State &begin, char expected);\nint p,q,r;\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '+'){\n            consume(begin, '+');\n            int num = factor(begin);\n            //cout << num << \" + \" << ret;\n            if(ret == 0 && num == 0){\n                ret = 0;\n            }\n            else if(ret == 1 || num == 1){\n                if(ret != 2 && num != 2){\n                    ret = 1;\n                }\n                else{\n                    ret = 2;\n                }\n            }\n            else{\n                ret = 2;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else if(*begin == '*'){\n            consume(begin, '*');\n            int num = factor(begin);\n            //cout << num << \" * \" << ret;\n            if(num == 2 && ret == 2){\n                ret = 2;\n            }\n            else if(num == 0 || ret == 0){\n                ret = 0;\n            }\n            else{\n                ret = 1;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\nint denial(State &begin){\n    if(*begin == '-'){\n\n        consume(begin, '-');\n\n        int ret = denial(begin);\n\n        if(ret == 2){\n            ret = 0;\n        }\n        else if(ret == 0){\n            ret = 2;\n        }\n\n        return ret;\n    }\n    return number(begin);\n}\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\n    if(*begin == 'P'){\n        consume(begin, 'P');\n        return p;\n    }\n    else if(*begin == 'Q'){\n        consume(begin, 'Q');\n        return q;\n    }\n    else if(*begin == 'R'){\n        consume(begin, 'R');\n        return r;\n    }\n\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        int ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return denial(begin);\n    }\n}\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nstring input;\n\nint main() {\n\n   \n    \n    while(true){       \n\n        cin >> input;\n\n        if(input[0] == '.'){\n            break;\n        }\n\n        int ans = 0;\n\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                for(int k=0; k<3; k++){\n                    p = i;\n                    q = j;\n                    r = k;\n                    State s = input.begin();\n                    if(factor(s) == 2){\n                        ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint eval(const string& s, int& k){\n\tif( s[k] == '0' || s[k] =='1' || s[k] == '2' ){\n\t\tint r = s[k] - '0';\n\t\tk++;\n\t\treturn r;\n\t}else if( s[k] == '-' ){\n\t\t++k;\n\t\tint r = eval(s, k);\n\t\tr = 2 - r;\n\t\treturn r;\n\t}else if( s[k] == '(' ){\n\t\t++k;\n\t\tint a = eval(s, k);\n\t\tchar op = s[k++];\n\t\tint b = eval(s, k);\n\t\t++k;\n\t\tint r;\n\t\tif( op == '+' ){\n\t\t\tr = max(a, b);\n\t\t}else if( op == '*' ){\n\t\t\tr = (a * b + 1) / 2;\n\t\t}\n\t\treturn r;\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile( cin >> s ){\n\t\tif( s == \".\" ) break;\n\t\t\n\t\tint ans=0;\n\t\tfor(char p='0' ; p <= '2' ; p++ ){\n\t\t\tfor(char q='0' ; q <= '2' ; q++ ){\n\t\t\t\tfor(char r='0' ; r <= '2' ; r++ ){\n\t\t\t\t\tstring ex = s;\n\t\t\t\t\tfor(int i=0 ; i < ex.size() ; i++ ){\n\t\t\t\t\t\tif( ex[i] == 'P' ) ex[i] = p; \n\t\t\t\t\t\tif( ex[i] == 'Q' ) ex[i] = q;\n\t\t\t\t\t\tif( ex[i] == 'R' ) ex[i] = r;\n\t\t\t\t\t}\n\t\t\t\t\tint t=0;\n\t\t\t\t\tint res = eval(ex, t);\n\t\t\t\t\tif( res == 2 ) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nenum {\n\tCONST = 0,\n\tVAR,\n\tNEG,\n\tAND,\n\tOR\n};\n\nint NEG_TABLE[3] = { 2, 1, 0 };\nint AND_TABLE[3][3] = {\n\t{ 0, 0, 0 },\n\t{ 0, 1, 1 },\n\t{ 0, 1, 2 }\n};\nint OR_TABLE[3][3] = {\n\t{ 0, 1, 2 },\n\t{ 1, 1, 2 },\n\t{ 2, 2, 2 }\n};\n\nstruct Node {\n\tNode(int t, int v = 0, Node *l = NULL, Node *r = NULL) : type(t), value(v), left(l), right(r) { }\n\tint type, value;\n\tNode *left, *right;\n};\n\nNode *makeTree(const char **ptr){\n\tif('0' <= **ptr && **ptr <= '2'){\n\t\tNode *node = new Node(CONST, **ptr - '0');\n\t\t++*ptr;\n\t\treturn node;\n\t}\n\tif('P' <= **ptr && **ptr <= 'R'){\n\t\tNode *node = new Node(VAR, **ptr - 'P');\n\t\t++*ptr;\n\t\treturn node;\n\t}\n\tif(**ptr == '-'){\n\t\t++*ptr;\n\t\treturn new Node(NEG, 0, makeTree(ptr));\n\t}\n\t++*ptr;\n\tNode *left = makeTree(ptr);\n\tNode *node = new Node(**ptr == '*' ? AND : OR, 0, left);\n\t++*ptr;\n\tnode->right = makeTree(ptr);\n\t++*ptr;\n\treturn node;\n}\nvoid deleteTree(Node *node){\n\tif(node->left != NULL){ deleteTree(node->left); }\n\tif(node->right != NULL){ deleteTree(node->right); }\n\tdelete node;\n}\nint calculate(Node *node, int p, int q, int r){\n\tif(node->type == CONST){ return node->value; }\n\tif(node->type == VAR){\n\t\tswitch(node->value){\n\t\t\tcase 0: return p;\n\t\t\tcase 1: return q;\n\t\t\tcase 2: return r;\n\t\t}\n\t}\n\tif(node->type == NEG){ return NEG_TABLE[calculate(node->left, p, q, r)]; }\n\tif(node->type == AND){\n\t\treturn AND_TABLE[calculate(node->left, p, q, r)][calculate(node->right, p, q, r)];\n\t}\n\tif(node->type == OR){\n\t\treturn OR_TABLE[calculate(node->left, p, q, r)][calculate(node->right, p, q, r)];\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tstring query;\n\t\tcin >> query;\n\t\tif(query == \".\"){ break; }\n\t\tconst char *ptr = query.c_str();\n\t\tNode *root = makeTree(&ptr);\n\t\tint answer = 0;\n\t\tfor(int p = 0; p < 3; ++p){\n\t\t\tfor(int q = 0; q < 3; ++q){\n\t\t\t\tfor(int r = 0; r < 3; ++r){\n\t\t\t\t\tif(calculate(root, p, q, r) == 2){ ++answer; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdeleteTree(root);\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\ntypedef string::const_iterator State;\nstring s;\nint formula(State& be){\n\tif('0'<=*be && *be<='2'){\n\t\tint ret=*be-'0';\n\t\tbe++;\n\t\treturn ret;\n\t}\n\tif(*be=='-'){\n\t\tbe++;\n\t\treturn 2-formula(be);\n\t}\n\tif(*be=='('){\n\t\tbe++;\n\t\tint a=formula(be),b;\n\t\tif(*be=='*'){\n\t\t\tbe++;\n\t\t\tb=formula(be);\n\t\t\tbe++;\n\t\t\treturn min(a,b);\n\t\t}\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tb=formula(be);\n\t\t\tbe++;\n\t\t\treturn max(a,b);\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> s;\n\t\tif(s[0]=='.') break;\n\t\tvector<int> p,q,r;\n\t\tint n=s.size(),cnt=0;\n\t\trep(i,n){\n\t\t\tif(s[i]=='P') p.pb(i);\n\t\t\tif(s[i]=='Q') q.pb(i);\n\t\t\tif(s[i]=='R') r.pb(i);\n\t\t}\n\t\trep(i,3) rep(j,3) rep(k,3){\n\t\t\trep(l,p.size()) s[p[l]]='0'+i;\n\t\t\trep(l,q.size()) s[q[l]]='0'+j;\n\t\t\trep(l,r.size()) s[r[l]]='0'+k;\n//\t\t\tcout << s << \" \";\n\t\t\tState be=s.begin();\n\t\t\tint ans=formula(be);\n\t\t\tif(ans==2) cnt++;\n//\t\t\tcout << ans << endl;\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n/*\t\tState be=s.begin();\n\t\tint ans=formula(be);\n\t\tcout << ans << endl;*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint v[3],n,c;\nstring s;\n\nint f(){\n  n++;\n  int r;\n  if(s[n-1]=='(')r=f(),n++,r=s[n-1]=='+'?max(r,f()):min(r,f()),n++;\n  else if(s[n-1]=='-')r=2-f();\n  else if(s[n-1]-'P'>=0)r=v[s[n-1]-'P'];\n  else r=s[n-1]-'0';\n  return r;\n}\n\nint main(){ \n  cin >> s;\n  if(s!=\".\"){\n    c=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3)n=0,c+=f()/2;\n    cout << c << endl;\n    main();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint a[3];\n\nint formula(string& s,int& idx){\n    if('0'<=s[idx]&&s[idx]<='2'){\n        int ret = s[idx]-'0';\n        ++idx;\n        return ret;\n    }\n    else if('P'<=s[idx]&&s[idx]<='R'){\n        int ret = a[s[idx]-'P'];\n        ++idx;\n        return ret;\n    }\n    else if(s[idx]=='-'){\n        ++idx;\n        return 2-formula(s,idx);\n    }\n    else if(s[idx]=='('){\n        ++idx;\n        int lhs = formula(s,idx);\n        char op = s[idx];\n        ++idx;\n        int rhs = formula(s,idx);\n        assert(s[idx]==')');\n        ++idx;\n        if(op == '+')return max(lhs, rhs);\n        else return min(lhs, rhs);\n    }\n    else assert(false);\n}\n\nvoid solve(string& s){\n    int ans = 0;\n    rep(i,3)rep(j,3)rep(k,3){\n        a[0]=i;a[1]=j;a[2]=k;\n        int idx = 0;\n        ans += formula(s,idx) == 2;\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    string s;\n    while(cin>>s,s!=\".\")solve(s);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nstring s;\nint p, q, r, id, res;\n\nint rec() {\n\tchar c = s[id++];\n\tif (isdigit(c)) return c-'0';\n\telse if (c=='P') return p;\n\telse if (c=='Q') return q;\n\telse if (c=='R') return r;\n\telse if (c=='-') return 2-rec();\n\telse if (c=='(') {\n\t\tint a = rec();\n\t\tchar d = s[id++];\n\t\tint b = rec();\n\t\tid++;\n\t\tif (d=='*') return min(a,b);\n\t\telse if (d=='+') return max(a,b);\n\t}\n\treturn 0;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> s;\n\t\tif (s==\".\") break;\n\t\tres = 0;\n\t\trep(i,3) rep(j,3) rep(k,3) {\n\t\t\tid = 0, p = i, q = j, r = k;\n\t\t\tif (rec()==2) res++;\n\t\t}\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long int a[3][3] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };\n\nlong long int b[3][3] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\npair< long long int, long long int > kansu( string s, long long int n, long long int p, long long int q, long long int r ) {\n\n  long long int k = 1;\n  bool f = false;\n  bool c = 0;\n\n  while( true ) {\n\n    //    cout << \"n = \" << n << \" : k = \" << k << \" : c = \" << c << endl;\n\n    if ( s[n] == ')' ) break;\n    if ( s[n] == '0' ) {\n      k = 0;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == '1' ) {\n      k = 1;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == '2' ) {\n      k = 2;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == 'P' ) {\n      k = p;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == 'Q' ) {\n      k = q;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == 'R' ) {\n      k = r;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == '-' ) {\n      if ( f == true ) {\n\tf = false;\n      }else {\n\tf = true;\n      }\n    }else if ( s[n] == '*' ) {\n      pair< long long int, long long int > w = kansu( s, n + 1, p, q, r );\n      k = a[k][ w.first ];\n      n = w.second;\n      break;\n    }else if ( s[n] == '+' ) {\n      pair< long long int, long long int > w = kansu( s, n + 1, p, q, r );\n      k = b[k][ w.first ];\n      n = w.second;\n      break;\n    }else if ( s[n] == '(' ) {\n      pair< long long int, long long int > w = kansu( s, n + 1, p, q, r );\n      k = w.first;\n      n = w.second;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }\n    n++;\n\n  }\n\n  return make_pair( k, n );\n\n}\n\nint main() {\n\n  while( true ) {\n\n    string s;\n    cin >> s;\n\n    if ( s == \".\" ) break;\n\n    s = s + \")\";\n\n    long long int ans = 0;\n\n    for ( long long int p = 0; p < 3; p++ ) {\n      for ( long long int q = 0; q < 3; q++ ) {\n\tfor ( long long int r = 0; r < 3; r++ ) {\n\n\t  if ( kansu( s, 0, p, q, r ).first == 2 ) ans++;\n\n\t}\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint fact(string& s, int& i);\nint numb(string& s, int& i);\n\nint expr(string& s, int& i){\n  int val = term(s, i);\n  while(s[i]=='+'){\n    i++;\n    val = max(val, term(s, i));\n  }\n  return val;\n}\n\nint term(string& s, int& i){\n  int val = fact(s, i);\n  while(s[i]=='*'){\n    i++;\n    int x =  fact(s, i);\n    if(min(x, val) == 0) val = 0;\n    else if(min(x, val) == 1) val = 1;\n    else val = 2;\n  }\n  //  cout << val << endl;\n  return val;\n}\n\nint invert(string& s, int& i){\n  if(isdigit(s[i])) return fact(s, i);\n  //    cout << i << endl;\n\n  while(s[i]=='-'){\n    i++;\n    int val2 = invert(s, i);\n    if(val2==2) return 0;\n    else if(val2==0) return 2;\n    return 1;\n  }\n  return 0;\n}\n\nint fact(string& s, int& i){\n  if(s[i]=='-') return invert(s, i);\n  if(isdigit(s[i])) return numb(s, i);\n  \n  i++;\n  int ret = expr(s, i);\n  i++;\n  return ret;\n}\n\nint numb(string& s, int& i){\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n  string S;\n  while(cin >> S, S!=\".\"){\n    int res = 0;\n    rep(i,3) rep(j,3) rep(k,3){\n      string s = S;\n      rep(l,s.size()){\n\tif(s[l]=='P') s[l] = i+'0';\n\tif(s[l]=='Q') s[l] = j+'0';\n\tif(s[l]=='R') s[l] = k+'0';\n      }\n      int l = 0;\n      if(expr(s, l) == 2) res++;\n\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<algorithm>\n\nusing namespace std;\n\n\nbool check(string str,int P,int Q,int R){\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='P')str[i]=P+'0';\n\t\tif(str[i]=='Q')str[i]=Q+'0';\n\t\tif(str[i]=='R')str[i]=R+'0';\n\t}\n\tstack<int> sta[50];\n\tint rank=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='-')sta[rank].push(-1);\n\t\tif(str[i]=='+')sta[rank].push(-2);\n\t\tif(str[i]=='*')sta[rank].push(-3);\n\t\tif(str[i]=='(')rank++;\n\t\tif(str[i]==')'){\n\t\t\tint c=sta[rank].top(),flag2=0;\n\t\t\tsta[rank].pop();\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\trank--;\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsta[rank].push(c);\n\t\t}\n\t\tif(str[i]>='0' && str[i]<='2'){\n\t\t\tint c=str[i]-'0',flag2=0;\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsta[rank].push(c);\n\t\t}\n\t}\n\tif(sta[0].top()==2)return true;\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\".\")break;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(check(str,i,j,k))cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long Int;\ntypedef string::const_iterator Itr;\n\nint P, Q, R;\n\nint expression(Itr &itr);\nint term(Itr &itr);\nint factor(Itr &itr);\nint letter(Itr &itr);\n\nint _not(int n)\n{\n\tif (n == 0)return 2;\n\telse if (n == 1)return 1;\n\telse return 0;\n}\n\nint _star(int x, int y)\n{\n\tif (x == 0 || y == 0)return 0;\n\telse if (x == 1 || y == 1)return 1;\n\telse return 2;\n}\n\nint _plus(int x, int y)\n{\n\tif (x == 0 && y == 0)return 0;\n\telse if (x == 2 || y == 2)return 2;\n\telse return 1;\n}\n\nint expression(Itr &itr) \n{\n\tint ret = term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '*')\n\t\t{\n\t\t\titr++;\n\t\t\tret = _star(ret, term(itr));\n\n\t\t}\n\t\telse if (*itr == '+')\n\t\t{\n\t\t\titr++;\n\t\t\tret = _plus(ret, term(itr));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(Itr &itr)\n{\n\tint ret;\n\n\tif (*itr == '-')\n\t{\n\t\titr++;\n\t\tret = _not(term(itr));\n\t}\n\telse\n\t{\n\t\tret = factor(itr);\n\t}\n\n\treturn ret;\n}\n\nint factor(Itr &itr)\n{\n\tint ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = letter(itr);\n\t}\n\n\treturn ret;\n}\n\nint letter(Itr &itr)\n{\n\tint ret = 0;\n\n\tif (*itr == 'P')\n\t{\n\t\tret = P;\n\t}\n\telse if (*itr == 'Q')\n\t{\n\t\tret = Q;\n\t}\n\telse if (*itr == 'R')\n\t{\n\t\tret = R;\n\t}\n\telse if(isdigit(*itr))\n\t{\n\t\tret = *itr - '0';\n\t}\n\titr++;\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tif (str[0] == '.')break;\n\t\tstr.append(\"_\");\n\t\tint count = 0;\n\t\tREP(i, 3)REP(j, 3)REP(k, 3)\n\t\t{\n\t\t\tP = i;\n\t\t\tQ = j;\n\t\t\tR = k;\n\t\t\tItr begin = str.begin();\n\t\t\tint ans = expression(begin);\n\t\t\tif (ans == 2)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\n\nusing namespace std;\n\nstring s;\n\nint Times[3][3] = { {0,0,0},{0,1,1} ,{0,1,2} };\nint Plus[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\nint gyaku[3][2] = { {0,2},{1,1},{2,0} };\n\nint calc_RPN(string rpn, int P, int Q, int R) {\n\tstack<int> st;\n\tint f = 0;\n\tfor (int idx = 0; idx < rpn.size(); idx++) {\n\t\tif (rpn[idx] == '-')f++;\n\t\telse if(rpn[idx] == '0' || rpn[idx] == '1' || rpn[idx] == '2'){\n\t\t\tst.push(gyaku[rpn[idx] - '0'][(rpn[idx] - '0' + f) % 2]);\n\t\t\tf = 0;\n\t\t}\n\t\telse if (rpn[idx] == '*') {\n\t\t\tint b = st.top(); st.pop();\n\t\t\tint a = st.top(); st.pop();\n\t\t\tst.push(Times[a][b]);\n\t\t}\n\t\telse if (rpn[idx] == '+') {\n\t\t\tint b = st.top(); st.pop();\n\t\t\tint a = st.top(); st.pop();\n\t\t\tst.push(Plus[a][b]);\n\t\t}\n\t}\n\treturn st.top();\n}\n\nint solve(int P, int Q, int R) {\n\tstring RPN;\n\tstack<char> sign_st;\n\tint idx = 0;\n\twhile (idx < s.size()) {\n\t\tif (s[idx] == '0' || s[idx] == '1' || s[idx] == '2') {\n\t\t\tRPN += s[idx];\n\t\t}\n\t\telse if (s[idx] == 'P' || s[idx] == 'Q' || s[idx] == 'R') {\n\t\t\tif (s[idx] == 'P') {\n\t\t\t\tRPN += ('0' + P);\n\t\t\t}\n\t\t\tif (s[idx] == 'Q') {\n\t\t\t\tRPN += ('0' + Q);\n\t\t\t}\n\t\t\tif (s[idx] == 'R') {\n\t\t\t\tRPN += ('0' + R);\n\t\t\t}\n\t\t}\n\t\telse if (s[idx] == '(') {\n\t\t\tsign_st.push('(');\n\t\t}\n\t\telse if (s[idx] == '-') {\n\t\t\tRPN += '-';\n\t\t}\n\t\telse if (s[idx] == '*') {\n\t\t\tsign_st.push('*');\n\t\t}\n\t\telse if (s[idx] == '+') {\n\t\t\tsign_st.push('+');\n\t\t}\n\t\telse if (s[idx] == ')') {\n\t\t\twhile (sign_st.top() != '(') {\n\t\t\t\tchar tmp = sign_st.top(); sign_st.pop();\n\t\t\t\tRPN += tmp;\n\t\t\t}\n\t\t\tsign_st.pop();\n\t\t}\n\t\tidx++;\n\t}\n\n\twhile (sign_st.size()) {\n\t\tRPN += sign_st.top();\n\t\tsign_st.pop();\n\t}\n\n\treturn calc_RPN(RPN, P, Q, R);\n}\n\nint main() {\n\twhile (cin >> s, s != \".\") {\n\t\tint ans = 0;\n\t\tfor (int P = 0; P <= 2; P++) {\n\t\t\tfor (int Q = 0; Q <= 2; Q++) {\n\t\t\t\tfor (int R = 0; R <= 2; R++) {\n\t\t\t\t\tif (solve(P, Q, R) == 2)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nqueue<char> convert(string formula){\n  queue<char> qu;\n  stack<char> st;\n  \n  bool b_minus = false;\n  for(char c : formula){\n    switch(c){\n      case '(':\n        if(b_minus == true) {\n          st.push('-');\n          b_minus = false;\n        }\n        break;\n      case '0': case '1': case '2': case 'P': case 'Q': case 'R':\n        qu.push(c);\n        if(b_minus == true){\n          qu.push('-');\n          b_minus = false;\n        }\n        break;\n      case '*': case '+':\n        st.push(c);\n        break;\n      case '-':\n           b_minus = true;\n        break;\n      case ')':\n        qu.push(st.top());\n        st.pop();\n        if(!st.empty() && st.top() == '-'){\n          qu.push(st.top());\n          st.pop();\n        }\n        break;\n      }\n  }\n  return qu;\n}\n\nint lAnd(int a, int b){\n  if(a == 0 || b == 0) return 0;\n  else if(a == 2 && b == 2) return 2;\n  else return 1;\n}\n\nint lOr(int a, int b){\n  if(a == 2 || b == 2) return 2;\n  else if(a == 0 && b == 0) return 0;\n  else return 1;\n}\n\nint lNot(int a){\n  if(a == 0) return 2;\n  else if(a == 1) return 1;\n  else return 0;\n}\n\nint cal(queue<char> quc, int p, int q, int r){\n  stack<int> stc;\n  int a,b;\n  while(!quc.empty()){\n    char c = quc.front();\n    quc.pop();\n    switch(c){\n      case '0':\n      case '1':\n      case '2':\n        stc.push(c-'0');\n        break;\n      case 'P':\n        stc.push(p);\n        break;\n      case 'Q':\n        stc.push(q);\n        break;\n      case 'R':\n        stc.push(r);\n        break;\n      case '+':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lOr(a,b));\n        break;\n      case '*':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lAnd(a,b));\n        break;\n      case '-':\n        a = stc.top(); stc.pop();      \n        stc.push(lNot(a));\n        break;\n    }\n  }\n  return stc.top();\n}\n\nint main(void){\n  string d = \"\";\n  int ans;\n  while(true){\n    cin >> d;\n    if(d == \".\") break;\n    d = regex_replace(d, std::regex(\"(--)\"), \"\");\n    \n    queue<char> t = convert(d);\n    ans = 0;\n    for(int i=0;i<=2;i++){\n      for(int j=0;j<=2;j++){\n        for(int k=0;k<=2;k++){\n          if(cal(t,i,j,k) == 2) ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n\n    // queue<char> t = convert(d);\n    // while(!t.empty()){\n    //   cout << t.front();\n    //   t.pop();\n    // }\n    // cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i;\n  int p,q,r;\n  int ln,ct;\n  string s,t;\n  while(cin>>s&&s[0]!='.'){\n    ct=0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  t=s;\n\t  ln=t.length();\n\t  for(i=0;i<ln;i++){\n\t    if(0){\n\t    }else if(t[i]=='P'){\n\t      t[i]='0'+p;\n\t    }else if(t[i]=='Q'){\n\t      t[i]='0'+q;\n\t    }else if(t[i]=='R'){\n\t      t[i]='0'+r;\n\t    }\n\t  }\n\t  while((ln=t.length())!=1){\n\t    do{\n\t      h=0;\n\t      for(i=0;i<ln-1;i++){\n\t\tif(t[i]=='-'&&'0'<=t[i+1]&&t[i+1]<='3'){\n\t\t  t.erase(i,1);\n\t\t  t[i]=2-t[i]+'0'+'0';\n\t\t  h=1;\n\t\t}\n\t      }\n\t    }while(h);\n\t    do{\n\t      h=0;\n\t      for(i=0;i<ln-4;i++){\n\t\tif(t[i]=='('&&t[i+4]==')'){\n\t\t  if(0){\n\t\t  }else if(t[i+2]=='*'){\n\t\t    if(0){\n\t\t    }else if(t[i+1]=='0'||t[i+3]=='0'){\n\t\t      t[i+4]='0';\n\t\t    }else if(t[i+1]=='2'&&t[i+3]=='2'){\n\t\t      t[i+4]='2';\n\t\t    }else{\n\t\t      t[i+4]='1';\n\t\t    }\n\t\t    t.erase(i,4);\n\t\t    h=1;\n\t\t  }else if(t[i+2]=='+'){\n\t\t    if(0){\n\t\t    }else if(t[i+1]=='2'||t[i+3]=='2'){\n\t\t      t[i+4]='2';\n\t\t    }else if(t[i+1]=='0'&&t[i+3]=='0'){\n\t\t      t[i+4]='0';\n\t\t    }else{\n\t\t      t[i+4]='1';\n\t\t    }\n\t\t    t.erase(i,4);\n\t\t    h=1;\n\t\t  }\n\t\t}\n\t      }\n\t    }while(h);\n\t  }\n\t  if(t[0]=='2')\n\t    ct++;\n\t}\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring str;\nint p;\n\nint negate_(int f) { return 2 - f; }\n\nint add(int a, int b) {\n  if (a == 2 || b == 2) {\n    return 2;\n  } else if (a == 0 && b == 0) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint mult(int a, int b) {\n  if (a * b == 0) {\n    return 0;\n  } else if (a * b == 4) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nint P, Q, R;\n\nint term(char c) {\n  switch (c) {\n    case 'P':\n     return P;\n    case 'Q':\n      return Q;\n    case 'R':\n      return R;\n  }\n}\n\nint formula() {\n  if (str[p] == '-') {\n    p++; // read -\n    int f = formula();\n    return negate_(f);\n  } else if (isdigit(str[p])) {\n    int f = str[p] - '0';\n    p++; // read [0-2]\n    return f;\n  } else if (isalpha(str[p])) {\n    int f = term(str[p]);\n    p++; // read [P-R]\n    return f;\n  } else {\n    p++; // read (\n    int a = formula();\n    if (str[p] == '*') {\n      p++; // read *\n      int b = formula();\n      p++; // read )\n      return mult(a, b);\n    } else {\n      p++; // read +\n      int b = formula();\n      p++; // read )\n      return add(a, b);\n    }\n  }\n}\n\nint main() {\n  while (cin >> str and str != \".\") {\n    p = 0;\n    int ans = 0;\n    for (P = 0; P < 3; P++) \n      for (Q = 0; Q < 3; Q++)\n        for (R = 0; R < 3; R++)\n          if (p = 0, formula() == 2) \n            ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include\"bits/stdc++.h\"\n#define INF          1e9\n#define INFLL        1e18\n#define EPS          1e-9\n#define MOD          1000000007\n#define REP(i,n)     for(ll i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)    for(ll i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)    for(ll i=(n)-1;i>=0;--i)\n#define REPR1(i,n)   for(ll i=(n);i>0;--i)\n#define REPC(i,obj)  for(auto i:obj)\n#define ALL(obj)     (obj).begin(),(obj).end()\n#define SETP(n)      cout<<fixed<<setprecision(n)\n#define VV(T,h,w)    vector<vector<T>>(h,vector<T>(w))\n#define VVI(T,h,w,i) vector<vector<T>>(h,vector<T>(w,i))\nusing namespace std;\nusing ll = long long;\ntemplate<typename T = ll>inline T in() { T ret; cin >> ret; return ret; }\n\nusing state=string::const_iterator;\nll expr(state &);\nll term(state &);\nll fuct(state &);\nll expr(state &s)\n{\n    ll ret = term(s);\n    while (true) {\n        char opr = *(s++);\n        ll arg = term(s);\n        if (opr == '+') {\n            if (ret == 2 || arg == 2)ret = 2;\n            else if (ret == 1 || arg == 1)ret = 1;\n            else ret = 0;\n        } else if (opr == '*') {\n            if (ret == 0 || arg == 0)ret = 0;\n            else if (ret == 1 || arg == 1)ret = 1;\n            else ret = 2;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\nll term(state & s)\n{\n    if (*s == '-') {\n        ++s;\n        return 2 - term(s);\n    } else {\n        return fuct(s);\n    }\n}\nll fuct(state & s)\n{\n    if (*s == '(') {\n        ++s;\n        ll ret = expr(s);\n        return ret;\n    } else if (isdigit(*s)) {\n        ll ret = *s - '0';\n        ++s;\n        return ret;\n    }\n}\nint main()\n{\n    while (true) {\n        if (string inp = in<string>(); inp[0] != '.') {\n            ll ans = 0;\n            for (char p = '0'; p <= '2'; ++p) {\n                for (char q = '0'; q <= '2'; ++q) {\n                    for (char r = '0'; r <= '2'; ++r) {\n                        string exstr = inp;\n                        replace(ALL(exstr), 'P', p);\n                        replace(ALL(exstr), 'Q', q);\n                        replace(ALL(exstr), 'R', r);\n                        auto s = exstr.cbegin();\n                        ans += expr(s) == 2;\n                    }\n                }\n            }\n            cout << ans << endl;\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tr = 2-r;\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tl = 2-l;\n\t\t\tst.pop();\n\t\t\t\n\t\t\tint tmp;\n\t\t\tif(o == '*')\n\t\t\t\ttmp = AND[r][l];\n\t\t\telse\n\t\t\t\ttmp = OR[r][l];\n\t\t\t\t\n\t\t\tfor(m=0; !st.empty() && st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\ttmp = 2-tmp;\n\n\t\t\tst.push((char)(tmp+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\n\tif(st.top() == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint formula(char *);\nint min(int,int);\nint max(int,int);\n\nint p,q,r;\nint position;\n\nmain(){\n    int count=0;\n    char str[100000];\n    \n    while(1){\n        \n        scanf(\"%s\",str);\n        if(str[0] == '.') break;\n        count = 0;\n        \n    for(p=0; p<3; p++){\n        for(q=0; q<3; q++){\n            for(r=0; r<3; r++){\n                position = 0;\n               if(formula(str) == 2)\n               count++;\n            }\n        }\n    }\n    printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}\n\nint formula(char *str){\n    int result;\n    \n    if(str[position] == '-'){\n        result = 2-formula(str);\n        position++;\n    }   \n    \n    else if(str[position] == '('){\n    position++;\n    result = formula(str);\n    if(str[position] == '*'){\n        position++;\n        result = min(result,formula(str));\n    }\n    else if(str[position] == '+'){\n        position++;\n        result = max(result,formula(str));\n    }\n}\n\nelse{\n    if(str[position] >= '0' && str[position] <= '2')\n    return str[position] - '0';\n    \n    if(str[position] == 'P')\n    return p;\n    else if(str[position] == 'Q')\n    return q;\n    else if(str[position] == 'R')\n    return r;\n    }\n}\n\nint min(int x,int y){\n    if(x > y)\n    return y;\n    else return x;\n}\n\nint max(int x,int y){\n    if(x > y)\n    return x;\n    else return y;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(void){\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \".\") return 0;\n        \n        int ans = 0;\n        for (int i = 0; i < 27; i++) {\n            int p = i % 3, q = (i / 3) % 3, r = (i / 9) % 3;\n            \n            int neg[30], idx = 0;\n            vector<char> ope;\n            vector<int> val[30];\n            for (int i = 0; i < 30; i++) neg[i] = 0;\n            for (int j = 0; j < s.size(); j++) {\n                if (char(s[j]) == '-') neg[idx]++;\n                else if (char(s[j]) == '+') ope.push_back(1);\n                else if (char(s[j]) == '*') ope.push_back(2);\n                else if (char(s[j]) == 'P') {\n                    if (neg[idx] % 2 == 0) val[idx].push_back(p);\n                    else val[idx].push_back(2 - p);\n                    neg[idx] = 0;\n                }\n                else if (char(s[j]) == 'Q') {\n                    if (neg[idx] % 2 == 0) val[idx].push_back(q);\n                    else val[idx].push_back(2 - q);\n                    neg[idx] = 0;\n                }\n                else if (char(s[j]) == 'R') {\n                    if (neg[idx] % 2 == 0) val[idx].push_back(r);\n                    else val[idx].push_back(2 - r);\n                    neg[idx] = 0;\n                }\n                else if (char(s[j]) == '(') idx++;\n                else if (char(s[j]) == ')') {\n                    idx--;\n                    if (ope[ope.size() - 1] == 1) {\n                        if (neg[idx] % 2 == 0) \n                        val[idx].push_back(max(val[idx + 1][0], val[idx + 1][1]));\n                        else val[idx].push_back(2 - max(val[idx + 1][0], val[idx + 1][1]));\n                    }\n                    else {\n                        if (neg[idx] % 2 == 0) \n                        val[idx].push_back(min(val[idx + 1][0], val[idx + 1][1]));\n                        else val[idx].push_back(2 - min(val[idx + 1][0], val[idx + 1][1]));\n                    }\n                    neg[idx] = 0;\n                    ope.pop_back();\n                    val[idx + 1].clear();\n                }\n                else {\n                    if (neg[idx] % 2 == 0) val[idx].push_back(int(s[j] - '0'));\n                    else val[idx].push_back(2 - int(s[j] - '0'));\n                    neg[idx] = 0;\n                }\n            }\n            \n            if (val[0][0] == 2) {\n                ans++;\n            }\n            //cout << p << \" \" << q << \" \" << r << \" \" << val[0][0] << endl;\n            for (int j = 0; j < 30; j++) val[j].clear();\n            ope.clear();\n        }\n        \n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tif (T[pos] == '0') { pos++; return 0; }\n\tif (T[pos] == '1') { pos++; return 1; }\n\tif (T[pos] == '2') { pos++; return 2; }\n\tif (T[pos] == '-') { pos++; return 2 - solve(); }\n\tif (T[pos] == '(') {\n\t\tpos++; int a = solve();\n\t\tpos++; int b = solve();\n\t\tif (T[pos] == '+') return max(a, b);\n\t\tif (T[pos] == '*') return min(a, b);\n\t}\n\treturn 0;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint a[] = {2, 1, 0}, b[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}}, c[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tREP(p, 3) REP(q, 3) REP(r, 3) {\n\t\t\t//cout << p << \" \" << q << \" \" << r << endl;\n\t\t\t//???????????°??????????????????\n\t\t\tstring t = s;\n\t\t\tREP(i, t.size()) {\n\t\t\t\tif(t[i] == 'P') t[i] = p + '0';\n\t\t\t\tif(t[i] == 'Q') t[i] = q + '0';\n\t\t\t\tif(t[i] == 'R') t[i] = r + '0';\n\t\t\t}\n\t\t\t//cout << t << endl;\n\t\t\twhile(true) {\n\t\t\t\t//???????????????\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '-') cnt++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cnt > 0) {\n\t\t\t\t\t\t\tif('0'<=t[i]&&t[i]<'3') {\n\t\t\t\t\t\t\t\tint tmp = t[i] - '0';\n\t\t\t\t\t\t\t\t//cout << \"cnt:\" << cnt << endl << tmp << \" \";\n\t\t\t\t\t\t\t\tREP(j, cnt) {\n\t\t\t\t\t\t\t\t\ttmp = a[tmp];\n\t\t\t\t\t\t\t\t\t//if(p == 0 && q == 0 && r == 0) cout << tmp << \" \";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//if(p == 0 && q == 0 && r == 0) cout << endl;\n\t\t\t\t\t\t\tt = t.substr(0, i-cnt) + (char)(tmp+'0') + t.substr(i+1);\n\t\t\t\t\t\t\ti -= cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << \"i:\" << i << \" cnt:\" << cnt << endl;\n\t\t\t\t}\n\t\t\t\t//?????£?????????+??¨*?????????\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '+') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1])) {\n\t\t\t\t\t\t\tint tmp = c[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t\ti -= 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(t[i] == '*') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1])) {\n\t\t\t\t\t\t\tint tmp = b[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t\ti -= 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << t << endl;\n\t\t\t\tif(t.size() == 1) break;\n\t\t\t}\n\t\t\tif(t == \"2\") ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint p,q,r;\nvoid invert(stack<int> &st){\n    int x;\n    x=st.top();\n    st.pop();\n    while(!st.empty()){\n        if(st.top()!=-1)break;\n\t\tst.pop();\n        x=(x-1)*(-1)+1;\n\t//\tcout << st.size();\n    }\n\tst.push(x);\n    return;\n}\n\nvoid calc(stack<int> &st){\n\tint x,y;\n\twhile(true){\n\t\tinvert(st);\n\t\tx=st.top();\n\t\tst.pop();\n\t\tif(st.top()==-4){\n\t\t\tst.pop();\n\t\t\tst.push(x);\n\t\t\tinvert(st);\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tint t=st.top();\n\t\t\tst.pop();\n\t\t\tinvert(st);\n\t\t\tif(t==-2){\n\t\t\t\ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(max(x,y));\n\t\t\t}\n\t\t\telse if(t==-3){\n\t\t\t\ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(min(x,y));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(true){\n\t\tstring str;\n\t\tcin >> str;\n\t\tint ans=0;\n\t\tstack<int> st;\n\t\tif(str[0]=='.')break;\n\t\tfor(p=0;p<3;p++){\n\t\tfor(q=0;q<3;q++){\n\t\tfor(r=0;r<3;r++){\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(str[i]=='(')st.push(-4);\n\t\t\t\telse if(str[i]=='-')st.push(-1);\n\t\t\t\telse if(str[i]=='+')st.push(-2);\n\t\t\t\telse if(str[i]=='*')st.push(-3);\n\t\t\t\telse if(str[i]=='P')st.push(p);\n\t\t\t\telse if(str[i]=='Q')st.push(q);\n\t\t\t\telse if(str[i]=='R')st.push(r);\n\t\t\t\telse if(str[i]==')')calc(st);\n\t\t\t\telse st.push((int)(str[i]-'0'));\n\t\t\t}\n\t\t\tif(st.size()!=1){\n\t\t\t\tinvert(st);\n\t\t\t}\n\t\t\tif(st.top()==2)ans++;\n\t\t}\n\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint nottable[3] = { 2,1,0 };\nint andtable[3][3] = { {0,0,0},{0,1,1},{0,1,2} };\nint ortable[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\nchar tochar(int num) {\n\tif (num == 0) {\n\t\treturn '0';\n\t}\n\telse if (num == 1) {\n\t\treturn '1';\n\t}\n\telse {\n\t\treturn '2';\n\t}\n}\n\nint solve(string::iterator& iter)\n{\n\tint ret;\n\n\tif (*iter == '0') {\n\t\tret = 0;\n\t}\n\telse if (*iter == '1') {\n\t\tret = 1;\n\t}\n\telse if (*iter == '2') {\n\t\tret = 2;\n\t}\n\telse if (*iter == '-') {\n\t\titer++;\n\t\treturn nottable[solve(iter)];\n\t}\n\telse if (*iter == '(') {\n\t\titer++;\n\t\tret = solve(iter);\n\t\t\n\t\tif (*iter == '+') {\n\t\t\titer++;\n\t\t\tret = ortable[ret][solve(iter)];\n\t\t}\n\t\telse if (*iter == '*') {\n\t\t\titer++;\n\t\t\tret = andtable[ret][solve(iter)];\n\t\t}\n\t}\n\n\titer++;\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (str == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\tstring temp = str;\n\n\t\t\t\t\tfor (int l = 0; l < temp.size(); l++) {\n\t\t\t\t\t\tif (temp[l] == 'P') {\n\t\t\t\t\t\t\ttemp[l] = tochar(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'Q') {\n\t\t\t\t\t\t\ttemp[l] = tochar(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'R') {\n\t\t\t\t\t\t\ttemp[l] = tochar(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (solve(temp.begin()) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n//#include <stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n#include<fstream>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\ntypedef string::const_iterator State;\n\nint dy[5] = { 0,0,1,-1,0 };\nint dx[5] = { 1,-1,0,0 ,0 };\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint count = 0;\n\t\tint calc, first, second;\n\t\tbool flag = false;\n\t\tbool check = false;\n\t\tstring s;\n\t\t\n\n\t\tcin >> s;\n\t\tif (s == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(p, 0, 2) {\n\t\t\tFOR(q, 0, 2) {\n\t\t\t\tFOR(r, 0, 2) {\n\t\t\t\t\tflag = false;//true 反転\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tstack<int>sta;\n\n\t\t\t\t\tFOR(i, 0, s.size() - 1) {\n\t\t\t\t\t\tswitch (s[i]) {\n\t\t\t\t\t\tcase 'P':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tswitch (p) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsta.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tswitch (q) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsta.push(q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsta.push(r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')':\n\t\t\t\t\t\t\tfirst = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\tcalc = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\tsecond = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\n\t\t\t\t\t\t\tswitch (calc) {\n\t\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\t\tif (first == 2 || second == 2) {\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (first == 0 && second == 0) {\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase -2:\n\t\t\t\t\t\t\t\tif (first == 2 && second == 2) {\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (first == 0 || second == 0) {\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tsta.push(-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tsta.push(-2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '0':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '2':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sta.top() == 2) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\n#define MAX (10+300000/7)\n\nint gd[2*MAX];\nint prime[35820];\nint cnt;\nchar *p;\n\nint inv[3] = {2,1,0};\nint mul[3][3]={\n  {0,0,0},\n  {0,1,1},\n  {0,1,2}\n};\nint add[3][3]={\n  {0,1,2},\n  {1,1,2},\n  {2,2,2}\n};\n\nint perse(){\n  int ret;\n  if(*p == '('){\n    p++;\n    int op1 = perse();\n    char op = *p++;\n    int op2 = perse();\n    p++;\n    if(op == '*')\n      ret = mul[op1][op2];\n    else\n      ret = add[op1][op2];\n  }else if(*p == '-'){\n    p++;\n    ret = inv[perse()];\n  }else{\n    ret = *p - '0';\n    p++;\n  }\n  return ret;\n}\n\nint main(){\n  char mapping[255];\n  char buff[100];\n  REP(i,255) mapping[i] = i;\n\n  while(fgets(buff,sizeof(buff),stdin), *buff != '.'){\n    int ans = 0;\n    REP(P,3){\n      mapping['P'] = P+'0';\n      REP(Q,3){\n        mapping['Q'] = Q+'0';\n        REP(R,3){\n          char str[100];\n          mapping['R'] = R+'0';\n          for(int i=0; str[i] = mapping[buff[i]]; i++);\n          p = str;\n          if(perse() == 2){\n            ans++;\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n)       reps (i, 0, n)\n#define reps(i, f, n)   for (int i = f; i < int(n); ++i)\n\nint cur;\nstring str;\n\nint expr(int P, int Q, int R)\n{\n    int a, b, op;\n    switch (str[cur]) {\n        case '0': case '1': case '2': return str[cur++] - '0';\n        case 'P': ++cur; return P;\n        case 'Q': ++cur; return Q;\n        case 'R': ++cur; return R;\n        case '-': ++cur; return 2 - expr(P, Q, R);\n        default:\n            ++cur;\n            a = expr(P, Q, R);\n            op = str[cur++] == '*';\n            b = expr(P, Q, R);\n            ++cur;\n            if (op) return min(a, b);\n            return max(a, b);\n    }\n}\n\nint main()\n{\n    while (cin >> str, str != \".\") {\n        int cnt = 0;\n        rep (P, 3) rep (Q, 3) rep (R, 3) {\n            cur = 0;\n            if (expr(P, Q, R) == 2) ++cnt;\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nint P, Q, R;\nint NOT[3] = {2, 1, 0};\nint AND[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint OR[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\nint calc(int& index) {\n  int ret;\n  if (s[index] == 'P')\n    ret = P;\n  else if (s[index] == 'Q')\n    ret = Q;\n  else if (s[index] == 'R')\n    ret = R;\n  else if (isdigit(s[index])) {\n    ret = s[index] - '0';\n  } else if (s[index] == '-') {\n    return NOT[calc(++index)];\n  } else if (s[index] == '(') {\n    ret = calc(++index);\n    if (s[index] == '*') {\n      ret = AND[ret][calc(++index)];\n    } else {\n      ret = OR[ret][calc(++index)];\n    }\n  }\n  index++;\n  return ret;\n}\n\nint main() {\n  while (cin >> s, s != \".\") {\n    int ans = 0;\n    for (P = 0; P < 3; P++) {\n      for (Q = 0; Q < 3; Q++) {\n        for (R = 0; R < 3; R++) {\n          int c = 0;\n          if (2 == calc(c)) ans++;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nint n;\nchar data[100];\n\nint mul[3][3] = {{0, 0, 0},{0, 1, 1},{0, 1, 2}};\nint plu[3][3] = {{0, 1, 2},{1, 1, 2},{2, 2, 2}};\n\nint P, Q, R;\nint pos;\n\nint back() {\n\tswitch(data[pos++]) {\n\tcase '0':\n\t\treturn 0;\n\t\tbreak;\n\tcase '1':\n\t\treturn 1;\n\t\tbreak;\n\tcase '2':\n\t\treturn 2;\n\t\tbreak;\n\tcase 'P':\n\t\treturn P;\n\t\tbreak;\n\tcase 'Q':\n\t\treturn Q;\n\t\tbreak;\n\tcase 'R':\n\t\treturn R;\n\t\tbreak;\n\tcase '-':\n\t\treturn 2-back();\n\t\tbreak;\n\tcase '(':\n\t\tint A = back();\n\t\tchar c = data[pos++];\n\t\tif(c == ')')\n\t\t\treturn A;\n\t\tint B = back();\n\t\tif(data[pos] == ')') {\n\t\t\tpos++;\n\t\t\tswitch(c){\n\t\t\tcase '*':\n\t\t\t\treturn mul[A][B];\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\treturn plu[A][B];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"=_=;\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tprintf(\"?_?\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\nvoid process() {\n\tint cnt = 0;\n\tfor(P = 0; P <= 2; P++) {\n\t\tfor(Q = 0; Q <= 2; Q++) {\n\t\t\tfor(R = 0; R <= 2; R++) {\n\t\t\t\tpos = 0;\n\t\t\t\tint res = back();\n\t\t\t\tif(res == 2) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt);\n}\n\nint main() {\n\tdata[0] = '(';\n\twhile(true){\n\t\tgets(data+1);\n\t\tn = strlen(data) + 1;\n\t\tdata[n-1] = ')';\n\t\tdata[n] = 0;\n\t\tif(data[1] == '.') break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint Calc(string S, int P, int Q, int R) {\n\t//if (P == 0 && Q == 0 && R == 0) cout << S << endl;\n\tif (S[0] == '-') return 2 - Calc(S.substr(1, S.size() - 1), P, Q, R);\n\tif (S.size() == 1) {\n\t\tif (S[S.size() - 1] == 'P') return P;\n\t\tif (S[S.size() - 1] == 'Q') return Q;\n\t\tif (S[S.size() - 1] == 'R') return R;\n\t\treturn S[S.size() - 1] - '0';\n\t}\n\tint Depth = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (Depth == 1 && S[i] == '+') return max(Calc(S.substr(1, i - 1), P, Q, R), Calc(S.substr(i + 1, S.size() - i - 2), P, Q, R));\n\t\tif (Depth == 1 && S[i] == '*') return min(Calc(S.substr(1, i - 1), P, Q, R), Calc(S.substr(i + 1, S.size() - i - 2), P, Q, R));\n\t\tif (S[i] == '(') Depth++;\n\t\tif (S[i] == ')') Depth--;\n\t}\n}\n\nint main() {\n\tstring S;\n\twhile (cin >> S) {\n\t\tif (S == \".\") return 0;\n\t\tint ANS = 0;\n\t\tfor (int P = 0; P < 3; P++) {\n\t\t\tfor (int Q = 0; Q < 3; Q++) {\n\t\t\t\tfor (int R = 0; R < 3; R++) {\n\t\t\t\t\tif (Calc(S, P, Q, R) == 2) ANS++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ANS << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str;\nint pos;\nint P, Q, R;\n\nint formula() {\n  pos ++;\n  if(str[pos] == '(') {\n    int f = formula();\n    pos ++;\n    if(str[pos] == '*') f = min(f, formula());\n    if(str[pos] == '+') f = max(f, formula());\n    pos ++;\n    return f;\n  }\n  if(str[pos] == '-') return 2-formula();\n  if(isdigit(str[pos])) return str[pos] - '0';\n  if(str[pos] == 'P') return P;\n  if(str[pos] == 'Q') return Q;\n  if(str[pos] == 'R') return R;\n}\n\nint main() {\n  \n  while(cin >> str && str != \".\") {\n    int cnt = 0;\n    for(P = 0; P<=2; P++)\n      for(Q = 0; Q<=2; Q++)\n\tfor(R = 0; R<=2; R++) {\n\t  pos = -1;\n\t  cnt += formula() == 2;\n\t}\n    cout << cnt << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint BIT(int C1,bool C2);\nint MINUS(int C3);\nint KAKE(int C4,int C5);\nint PLUS(int C6,int C7);\nstring TSTRING(int C8);\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[MAX_N];\n\nint BIT(int C1,bool C2){\n\tif(C2==true){return C1;}\n\treturn MINUS(C1);\n}\n\nint MINUS(int C3){\n\treturn 2-C3;\n}\nint PLUS(int C4,int C5){\n\treturn max(C4,C5);\n}\nint KAKE(int C6,int C7){\n\treturn min(C6,C7);\n}\n\nstring TSTRING(int C8)\n{\n\tif(C8==0)\n\t{\n\t\treturn \"0\";\n\t}\n\tif(C8==1)\n\t{\n\t\treturn \"1\";\n\t}\n\treturn \"2\";\n}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\telse{ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=BIT(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=BIT(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=BIT(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=BIT(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=BIT(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=BIT(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return PLUS(ans,ans2);}\n\treturn KAKE(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=TSTRING((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t\tV=X;\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tS='('+S+')';\n\t\tsum=0;\n\t\tif(S==\"(.)\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=S[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstring str;\nint idx;\n\n\nint getn() {\n    char c = str[idx];\n    idx++;\n    return c-'0';\n}\n\nint calc() {\n    char c = str[idx];\n    if (c == '-') {\n        idx++;\n        return 2-calc(); \n    }\n    if (c == '(') {\n        idx++;\n        int r1 = calc();\n        char cc = str[idx];\n        idx++;\n        int r2 = calc();\n        idx++;\n        if (cc == '*') {\n            return min(r1, r2);\n        } else {\n            return max(r1, r2);\n        }\n    } else {\n        return getn();\n    }\n}\n\nint main() {\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \".\") break;\n        int res = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    str = \"\";\n                    for (int i = 0; i < s.size(); i++) {\n                        switch (s[i]) {\n                        case 'P':\n                            str += to_string(p);\n                            break;\n                        case 'Q':\n                            str += to_string(q);\n                            break;\n                        case 'R':\n                            str += to_string(r);\n                            break;\n                        default:\n                            str += s[i];\n                            break;\n                        }\n                    }\n                    str += '=';\n                    idx = 0;\n                    //cerr << str << endl;\n                    if (calc() == 2) {\n                        //cerr << \"asdkfjf\" << endl;\n                        res++;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_int.hpp>\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\ntypedef string::const_iterator State;\nll expr(State &begin);\nll fact(State &begin);\nll posi(State &begin);\nll num(State &begin);\nstring s;\nll t[3];\nll x(ll a,ll b){\n    if(a==2||b==2)return 2;\n    if(a==0&&b==0)return 0;\n    return 1;\n}\nll y(ll a,ll b){\n    if(a==0||b==0)return 0;\n    if(a==2&&b==2)return 2;\n    return 1;\n}\nll num(State &begin){\n    ll res=0;\n    if(isdigit(*begin)){\n        res=*begin-'0';\n        begin++;\n    }else{\n        res=t[*begin-'P'];\n        begin++;\n    }\n    return res;\n}\nll posi(State &begin){\n    ll res=0;\n    if(*begin=='('){\n        begin++;\n        res=expr(begin);\n        begin++;\n    }else{\n        res=num(begin);\n    }\n    return res;\n}\nll fact(State &begin){\n    ll res=0;\n    if(*begin=='-'){\n        begin++;\n        res=2-fact(begin);\n    }else{\n        res=posi(begin);\n    }\n    return res;\n}\nll expr(State &begin){\n    ll res=fact(begin);\n    while(1){\n        if(*begin=='+'){\n            begin++;\n            ll next=fact(begin);\n            res=x(res,next);\n        }else if(*begin=='*'){\n            begin++;\n            ll next=fact(begin);\n            res=y(res,next);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nbool anspro(){\n    ll count=0;\n    rep(i,0,26){\n        ll k=i;\n        rep(j,0,2){\n            t[j]=k%3;\n            k/=3;\n        }\n        State begin=s.begin();\n        if(expr(begin)==2)count++;\n    }\n    cout<<count<<endl;\n    return 0;\n}\n\nint main(){fastio\n    while(1){\n        cin>>s;\n        if(s[0]=='.')break;\n        anspro();\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nstring s;\nint table1[] = { 2,1,0 };\nint table2[3][3] = { { 0,1,2 },\n\t\t\t\t\t { 1,1,2 },\n\t\t\t\t\t { 2,2,2 } };\nint table3[3][3] = { { 0,0,0 },\n\t\t\t\t\t { 0,1,1 },\n\t\t\t\t\t { 0,1,2 } };\nint p, q, r;\n\nint number(int &pos) {\n\tif (s[pos] == '0') {\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif (s[pos] == '1') {\n\t\tpos++;\n\t\treturn 1;\n\t}\n\tif (s[pos] == '2') {\n\t\tpos++;\n\t\treturn 2;\n\t}\n\tif (s[pos] == 'P') {\n\t\tpos++;\n\t\treturn p;\n\t}\n\tif (s[pos] == 'Q') {\n\t\tpos++;\n\t\treturn q;\n\t}\n\tif (s[pos] == 'R') {\n\t\tpos++;\n\t\treturn r;\n\t}\n}\n\nint formula(int &pos) {\n\tif (s[pos] == '-') {\n\t\tpos++;\n\t\treturn table1[formula(pos)];\n\t}\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tint res = formula(pos);\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tres = table2[res][formula(pos)];\n\t\t}\n\t\telse if (s[pos] == '*') {\n\t\t\tpos++;\n\t\t\tres = table3[res][formula(pos)];\n\t\t}\n\t\tpos++;\n\t\treturn res;\n\t}\n\treturn number(pos);\n}\n\nint main() {\n\twhile (cin >> s&&s != \".\") {\n\t\tint ans = 0;\n\t\trep(i, 3) {\n\t\t\trep(j, 3) {\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tp = i;\n\t\t\t\t\tq = j;\n\t\t\t\t\tr = k;\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tif (formula(pos) == 2) {\n\t\t\t\t\t\t//cout << \"!\" << p << \" \" << q << \" \" << r << endl;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint pqr[3];\nint fom(string h, bool f);\nint main(){\n  string h;\n  while(getline(cin,h)){\n    if(h == \".\"){break;}\n    int ans = 0;\n    for(int i=0; i<27; i++){\n      pqr[0] = i%3;\n      pqr[1] = (i/3)%3;\n      pqr[2] = (i/9)%3;\n      if(fom(h,0) == 2){ans++;}\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}\nint fom(string h, bool f){\n  int ans,one,two,dow,an;\n  ans = one = two = dow = an = -1;\n  for(int i=0; i<h.size(); i++){\n    if(h[i] == '0'){dow = 0;}\n    else if(h[i] == '1'){dow = 1;}\n    else if(h[i] == '2'){dow = 2;}\n    else if(h[i] == 'P'){dow = pqr[0];}\n    else if(h[i] == 'Q'){dow = pqr[1];}\n    else if(h[i] == 'R'){dow = pqr[2];}\n    else if(h[i] == '-'){f = (f+1)%2;}\n    else if(h[i] == '+'){an = 0;}\n    else if(h[i] == '*'){an = 1;}\n    else if(h[i] == '('){\n      int j;\n      for(j = 1; j+i<h.size(); j++){\n\tif(h[j+i] == ')'){break;}\n      }\n      dow = fom(h.substr(i+1,j-1),f);\n      i = i+j;\n    }\n    if(dow != -1){\n      if(f){dow = 2-dow;}\n      if(one == -1){one = dow;}\n      else{two = dow;}\n      dow = -1;\n      f = 0;\n    }\n    if(one != -1 && two != -1){\n      if(an == 0){one = max(one,two);}\n      if(an == 1){one = min(one,two);}\n      an = -1;\n      two = -1;\n    }\n  }\n  if(one != -1 && two == -1){ans = one;}\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint fact(string& s, int& i);\nint numb(string& s, int& i);\n\nint expr(string& s, int& i){\n  int val = term(s, i);\n  while(s[i]=='+'){\n    i++;\n    val = max(val, term(s, i));\n  }\n  return val;\n}\n\nint term(string& s, int& i){\n  int val = fact(s, i);\n  while(s[i]=='*'){\n    i++;\n    int x =  fact(s, i);\n    if(min(x, val) == 0) val = 0;\n    else if(min(x, val) == 1) val = 1;\n    else val = 2;\n  }\n  //  cout << val << endl;\n  return val;\n}\n\nint invert(string& s, int& i){\n  if(isdigit(s[i])) return fact(s, i);\n\n  while(s[i]=='-'){\n    i++;\n    int val2 = fact(s, i);\n    if(val2==2) return 0;\n    else if(val2==0) return 2;\n    return 1;\n  }\n  return 0;\n}\n\nint fact(string& s, int& i){\n  if(s[i]=='-') return invert(s, i);\n  if(isdigit(s[i])) return numb(s, i);\n  \n  i++;\n  int ret = expr(s, i);\n  i++;\n  return ret;\n}\n\nint numb(string& s, int& i){\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n  string S;\n  while(cin >> S, S!=\".\"){\n    int res = 0;\n    rep(i,3) rep(j,3) rep(k,3){\n      string s = S;\n      rep(l,s.size()){\n\tif(s[l]=='P') s[l] = i+'0';\n\tif(s[l]=='Q') s[l] = j+'0';\n\tif(s[l]=='R') s[l] = k+'0';\n      }\n      int l = 0;\n      if(expr(s, l) == 2) res++;\n\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint nottable[3] = { 2,1,0 };\nint andtable[3][3] = { {0,0,0},{0,1,1},{0,1,2} };\nint ortable[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\nchar tochar(int num) {\n\tif (num == 0) {\n\t\treturn '0';\n\t}\n\telse if (num == 1) {\n\t\treturn '1';\n\t}\n\telse {\n\t\treturn '2';\n\t}\n}\n\nint solve(string::const_iterator iter)\n{\n\tint ret;\n\n\tif (*iter == '0') {\n\t\tret = 0;\n\t}\n\telse if (*iter == '1') {\n\t\tret = 1;\n\t}\n\telse if (*iter == '2') {\n\t\tret = 2;\n\t}\n\telse if (*iter == '-') {\n\t\titer++;\n\t\treturn nottable[solve(iter)];\n\t}\n\telse if (*iter == '(') {\n\t\titer++;\n\t\tret = solve(iter);\n\t\t\n\t\tif (*iter == '+') {\n\t\t\titer++;\n\t\t\tret = ortable[ret][solve(iter)];\n\t\t}\n\t\telse if (*iter == '*') {\n\t\t\titer++;\n\t\t\tret = andtable[ret][solve(iter)];\n\t\t}\n\t}\n\n\titer++;\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (str == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\tstring temp = str;\n\n\t\t\t\t\tfor (int l = 0; l < temp.size(); l++) {\n\t\t\t\t\t\tif (temp[l] == 'P') {\n\t\t\t\t\t\t\ttemp[l] = tochar(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'Q') {\n\t\t\t\t\t\t\ttemp[l] = tochar(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'R') {\n\t\t\t\t\t\t\ttemp[l] = tochar(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (solve(temp.begin()) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\nint eval(const string& s, int &pos)\n{\n\tif(s[pos] == '0') { ++pos; return 0; }\n\tif(s[pos] == '1') { ++pos; return 1; }\n\tif(s[pos] == '2') { ++pos; return 2; }\n\tif(s[pos] == '-') { ++pos; int v = eval(s, pos); return 2 - v;}\n\tif(s[pos] == '(') {\n\t\tint a = eval(s,pos);\n\t\t// evalの値には計算済みの値が帰ってくるはずだ\n\t\tchar c = s[pos++];\n\t\tint b = eval(s,pos);\n\n\t\tif(c == '*') {return (a * b + 1) / 2; }\n\t\tif(c == '+') {return max(a, b); }\n\t\tabort();\n\t}\n\treturn 2;\n}\n\n\n\nint main (void)\n{\n\tstring s, temp;\n\tcin >> s;\n\tstring p, q, r;\n\tint count = 0;\n\tint zero = 0;\n\t\n\tfor(int j = 0; j < 3; j++){\n\t\tif(j == 0) p = '0';\n\t\tif(j == 1) p = '1';\n\t\tif(j == 2) p = '2';\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tif(j == 0) q = '0';\n\t\t\tif(j == 1) q = '1';\n\t\t\tif(j == 2) q = '2';\n\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\tif(j == 0) q = '0';\n\t\t\t\tif(j == 1) q = '1';\n\t\t\t\tif(j == 2) q = '2';\n\t\t\t\ttemp = s;\n\t\t\t\tzero = 0;\n\t\t\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\t\t\tif(s.at(i) == 'P') { temp.replace(i, 1, p); }\n\t\t\t\t\tif(s.at(i) == 'Q') { temp.replace(i, 1, q); }\n\t\t\t\t\tif(s.at(i) == 'R') { temp.replace(i, 1, r); }\n\t\t\t\t}\n\t\t\t\tif(eval(temp, zero) == 2) count++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << count << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n// #include <boost/foreach.hpp>\n// #include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1e9\n#define LINF 1e18\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define int long long\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n// int dx[]={0,1,0,-1};\n// int dy[]={1,0,-1,0};\nstruct edge{int to,cost;};\n//typedef pair<int,int> P;\n\nconst long long MOD=1000000007LL;\nbool isupper(char c){if('A'<=c&&c<='Z')return 1;return 0;}\nbool islower(char c){if('a'<=c&&c<='z')return 1;return 0;}\nbool isPrime(int x){if(x==1)return 0;if(x==2)return 1;if(x%2==0)return 0;for(int i=3;i*i<=x;i++)if(x%i==0)return 0;return 1;}\nbool iskaibun(string s){for(int i=0;i<s.size()/2;i++)if(s[i]!=s[s.size()-i-1])return 0;return 1;}\nbool isnumber(char c){return ('0'<=c&&c<='9');}\nbool isalpha(char c){return (isupper(c)||islower(c));}\ntemplate<typename T> \nvoid print(vector<T> v){\n    for(int i=0;i<v.size();i++){\n        if(i)cout<<\" \";\n        cout<<v[i];\n    }\n    cout<<endl;\n}\n\ntemplate<typename T>\nvoid printendl(vector<T> v){\n    for(auto date:v)cout<<date<<endl;\n}\n\ntemplate<typename T>\nvoid printvv(vector<vector<T>> v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++){\n            if(j)cout<<\" \";\n            cout<<v[i][j];\n        }\n        cout<<endl;\n    }\n}\nint gcd(int a,int b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    else return gcd(b,a%b);\n}\n\nstruct S{\n    int num,deep;\n};\n\nchar NOT(char x){\n    if(x=='0')return '2';\n    else if(x=='1')return '1';\n    else return '0';\n}\n\nchar AND(char a,char b){\n    char v[3][3]={\n        {'0','0','0'},\n        {'0','1','1'},\n        {'0','1','2'}\n    };\n    return v[a-'0'][b-'0'];\n}\n\nchar OR(char a,char b){\n    char v[3][3]={\n        {'0','1','2'},\n        {'1','1','2'},\n        {'2','2','2'}\n    };\n    return v[a-'0'][b-'0'];\n}\n\nvoid d(stack<char> st){\n    vector<char> v;\n    while(!st.empty()){\n        v.push_back(st.top());\n        st.pop();\n    }\n    print(v);\n    cout<<endl;\n}\n\nsigned main (){\n    string t;\n    while(cin>>t){\n        if(t==\".\")break;\n        int ans=0;\n        rep(p,0,3){\n            rep(q,0,3){\n                rep(r,0,3){\n                    string s=t;\n                    rep(i,0,s.size()){\n                        if(s[i]=='P')s[i]='0'+p;\n                        else if(s[i]=='Q')s[i]='0'+q;\n                        else if(s[i]=='R')s[i]='0'+r;\n                    }\n\n                    stack<char> st;\n                    rep(i,0,s.size()){\n                        //d(st);\n                        if(isnumber(s[i])){\n                            while(!st.empty() and st.top()=='-'){\n                                st.pop();\n                                s[i]=NOT(s[i]);\n                            }\n                            st.push(s[i]);\n                        }else if(s[i]==')'){\n                            //d(st);\n                            char c=st.top(),cc,cmd;\n                            st.pop();\n                            while(st.top()!='('){\n                                //d(st);\n                                cmd=st.top();\n                                st.pop();\n                                cc=st.top();\n                                st.pop();\n                                //d(st);\n                                if(cmd=='*')c=AND(c,cc);\n                                else if(cmd=='+')c=OR(c,cc);\n                            }\n                            st.pop();\n                            while(!st.empty() and st.top()=='-'){\n                                c=NOT(c);\n                                st.pop();\n                            }\n                            st.push(c);\n                        }else {\n                            st.push(s[i]);\n                        }\n                    }\n                    if(st.top()=='2')ans++;\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n/*\n(P*Q)\n(--R+(P*Q))\n(P*-P)\n2\n1\n(-1+(((---P+Q)*(--Q+---R))*(-R+-P)))\n.\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nint pyon(string s,int p,int q,int r){\n\tint cnt=0,f;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tV.PB(mt);\n\t\t}\n\t}\n\tif(f==0)return _and[V[0]][V[1]];\n\telse return _or[V[0]][V[1]];\n}\nint rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=(char)(pyon(t,p,q,r)+'0');\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top;\n\t\t}\n\t}\n\treturn (s[0]-'0');\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tint res=rec(s,i,j,k);\n\t\t\tif(res==2)cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n \ntypedef int value;\n \nstring s;\nsize_t cur = 0;\nvalue P, Q, R;\nint ans = 0;\n\nvalue not();\nvalue and(value a, value b);\nvalue or(value a, value b);\nvalue formula();\n \nvalue not(){\n    assert(s[cur] == '-');\n    cur++;\n    return 2 - formula();\n}\nvalue and(value a, value b){\n    return (a<b) ? a : b;\n}\nvalue or(value a, value b){\n    return (a<b) ? b : a;\n}\nvalue formula(){\n    value a, b, f;\n    char op;\n    switch (s[cur]){\n    case ('0') :\n    case ('1') :\n    case ('2') :\n               f = s[cur] - '0';\n        cur++;\n        break;\n    case ('P') :\n        f = P;\n        cur++;\n        break;\n    case ('Q') :\n        f = Q;\n        cur++;\n        break;\n    case ('R') :\n        f = R;\n        cur++;\n        break;\n    case ('-') :\n        f = not();\n        break;\n    case ('(') :\n        cur++;\n        a = formula();\n        assert(s[cur] == '*' || s[cur] == '+');\n        op = s[cur];\n        cur++;\n        b = formula();\n        f = (op == '*') ? and(a, b) : or(a, b);\n        assert(s[cur] == ')');\n        cur++;\n        break;\n    default:\n        assert(false);\n        break;\n    }\n    return f;\n}\nint main(){\n    cin >> s;\n    while (s != \".\"){\n        for (P = 0; P <= 2; P++)\n            for (Q = 0; Q <= 2; Q++)\n                for (R = 0; R <= 2; R++){\n                    if (formula() == 2)ans++;\n                    cur = 0;\n                }\n        cout << ans << endl;\n        ans = 0;\n        cin >> s;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    string s;\n    cin >> s;\n    if (s == \".\") break;\n    vector<int> v(3);\n    function<int(int &)> dfs = [&](int &i) -> int {\n      if (s[i] == '(') {\n        i++;\n        int e = dfs(i);\n        if (s[i] == '+') {\n          i++;\n          cmax(e, dfs(i));\n        }\n        if (s[i] == '*') {\n          i++;\n          cmin(e, dfs(i));\n        }\n        i++; // ')'\n        return e;\n      }\n      if (s[i] == '-') {\n        i++;\n        return 2 - dfs(i);\n      }\n      if (isdigit(s[i])) return s[i++] - '0';\n      return v[s[i++] - 'P'];\n    };\n    int cnt = 0;\n    for (v[0] = 0; v[0] < 3; v[0]++) {\n      for (v[1] = 0; v[1] < 3; v[1]++) {\n        for (v[2] = 0; v[2] < 3; v[2]++) {\n          int i = 0;\n          cnt += dfs(i) == 2;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#define FOR(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nunordered_map<char, int> term = {{'0', 0}, {'1', 1}, {'2', 2}};\nstring::iterator it;\n\nint formula() {\n  if(*it == '(') {\n    it++;\n    int f = formula();\n    if(*it == '*') ++it, f = min(f, formula());\n    if(*it == '+') ++it, f = max(f, formula());\n    return ++it, f;\n  }\n  else if(*it == '-') return ++it, 2 - formula();\n  else return term[*(it++)];\n  return 0;\n}\n\nint main() {\n  string s;\n  while(cin >> s, s[0] != '.') {\n    int cnt = 0;\n    REP(i, 3) REP(j, 3) REP(k, 3)\n      it = s.begin(),\n      term['P'] = i, term['Q'] = j, term['R'] = k,\n      cnt += (formula() == 2? 1: 0);\n    cout << cnt << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator state;\nstring s;\n\nint expression(state&);\nint number(state &b){\n    int ret=*b-'0';\n    b++;\n    return ret;\n}\n\nint factor(state &b){\n    if(*b=='('){\n        b++;\n        int ret=expression(b);\n        b++;\n        return ret;\n    }\n    return number(b);\n}\n\nint rev(state &b){\n    if(*b=='-'){\n        b++;\n        int ret=rev(b);\n        if(ret==0)return 2;\n        if(ret==2)return 0;\n        return 1;\n    }\n    return factor(b);\n}\n\nint expression(state &b){\n    int ret=rev(b);\n    while(true){\n        if(*b=='+'){\n            b++;\n            ret=max(ret,rev(b));\n        }\n        else if(*b=='*'){\n            b++;\n            ret=min(ret,rev(b));\n        }\n        else break;\n    }\n    return ret;\n}\n\nint main(){\n\n    string t;\n    while(cin>>t,t!=\".\"){\n        s=t+\"=\";\n\n        int ans=0;\n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                for(int k=0;k<3;k++){\n                    for(int l=0;l<t.size();l++){\n                        if(t[l]=='P')s[l]=i+'0';\n                        if(t[l]=='Q')s[l]=j+'0';\n                        if(t[l]=='R')s[l]=k+'0';\n\n                    }\n                    state b=s.begin();\n                    if(expression(b)==2)ans++;\n\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nstring s;\n\nint func(int P, int Q, int R) {\n    bool f = true;\n    while (f) {\n        f = false;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '(' && (s[i+2] == '+' || s[i+2] == '*')&& s[i+4] == ')') {\n                f = true;\n                int a,b,c;\n                a = s[i+1]-'0';\n                b = s[i+3]-'0';\n                c = (s[i+2]=='+'? max(a,b) : min(a,b));\n                s[i+4] = '0'+c;\n                s = s.substr(0,i) + s.substr(i+4);\n            }\n        }\n    }\n    if (s.size() == 3) return s[1]-'0';\n    else return s[0]-'0';\n}\n\nint main(void){\n    while (cin>>s && s != \".\") {\n        for (int i = 0; i < s.size()-1; i++) {\n            if (s[i] == '-' && s[i+1] == '-') s = s.substr(0,i) + s.substr(i+2);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string _s = s;\n                    for (int l = 0; l < s.size(); l++) {\n                        if (s[l] == '-') {\n                            if (s[l+1] == 'P') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'+abs(i-2); \n                            else if (s[l+1] == 'Q') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'+abs(j-2); \n                            else if (s[l+1] == 'R') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'+abs(k-2); \n                            else if (s[l+1] == '0') s = s.substr(0,l) + s.substr(l+1), s[l] = '2'; \n                            else if (s[l+1] == '1') s = s.substr(0,l) + s.substr(l+1); \n                            else if (s[l+1] == '2') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'; \n                        }\n                        else if (s[l] == 'P') s[l] = '0'+i;\n                        else if (s[l] == 'Q') s[l] = '0'+j;\n                        else if (s[l] == 'R') s[l] = '0'+k;\n                    }\n                    \n                    if (func(i,j,k) == 2) ans++;\n                    s = _s;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <array>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <tuple>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <regex>\n#include <cstdint>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\nusing ll = int64_t;\nusing ull = uint64_t;\n\nconstexpr ll INF = 1000000000;/* 1e+9a */\nnamespace utils{\n\n    class Repeater{\n        int st;\n        int ed;\n        int d;\n    public:\n        class rep_iterator{\n            int i; int d;\n        public:\n            rep_iterator(int x, int pd) :i(x), d(pd) {}\n\n            int& operator*(){ return i; }\n            bool operator==(const rep_iterator& k) const { return i == k.i; }\n            bool operator!=(const rep_iterator& k) const { return i != k.i; }\n            rep_iterator& operator++(){ i+=d; return *this; }\n        };\n\n        explicit Repeater(int N) :st(0), ed(N), d(1) {}\n        Repeater(int b, int e) :st(b), ed(e), d(1) {if(st > ed){ st--; ed--; d = -1; } }\n\n        rep_iterator begin() const{ return rep_iterator(st, d); }\n        rep_iterator end() const{ return rep_iterator(ed, d); }\n\n    };\n\n    template<class T, class Compare> using p_queue = priority_queue<T, vector<T>, Compare>;\n    template<class T> using min_queue = p_queue<T, greater<T>>;\n    template<class T> using max_queue = p_queue<T, less<T>>;\n\n    template<class T> bool min_update(T& X, const T& A){ if(X > A) {X = A; return true;} return false; }\n    template<class T> bool max_update(T& X, const T& A){ if(X < A) {X = A; return true;} return false; }\n#define ALL(x) begin(x), end(x)\n#define rALL(x) rbegin(x), rend(x)\n}\nusing namespace utils;\n\nint not3(int x){\n    return x == 0 ? 2\n                  : x == 1 ? 1\n                           : 0;\n}\n\nint and3(int x, int y){\n    return min(x, y);\n}\n\nint or3(int x, int y){\n    return max(x, y);\n}\n\npair<int, int> eval(const string& F, int k, int P, int Q, int R){\n    switch (F[k]) {\n        case '0' : return {0, k+1};\n        case '1' : return {1, k+1};\n        case '2' : return {2, k+1};\n        case 'P' : return {P, k+1};\n        case 'Q' : return {Q, k+1};\n        case 'R' : return {R, k+1};\n        case '-' : {\n            auto X = eval(F, k + 1, P, Q, R);\n            return {not3(X.first), X.second};\n        }\n        case '(' :\n            auto X = eval(F, k+1, P, Q, R);\n            int x = X.first;\n            char op = F[X.second];\n            auto Y = eval(F, X.second+1, P, Q, R);\n            int end = Y.second;\n            assert(F[end] == ')');\n            int val = op == '+' ? or3(x, Y.first) : and3(x, Y.first);\n            return {val, end+1};\n    }\n    assert(0);\n}\n\n\nvoid sub_main(istream &is) {\n    string S;\n    is >> S;\n    if(!is or S[0] == '.') return;\n    int cnt = 0;\n    for (int P = 0; P < 3; ++P) {\n        for (int Q = 0; Q < 3; ++Q) {\n            for (int R = 0; R < 3; ++R) {\n                auto ev = eval(S, 0, P, Q, R);\n                assert(ev.second == S.size());\n                cnt += ev.first == 2 ? 1 : 0;\n            } // end R\n        } // end Q\n    } // end P\n    cout << cnt << endl;\n}\n\nint main(int argc, char *argv[]) {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << setprecision(16) << scientific;\n#ifdef DEBUG\n    string test_cases = \"test_B.txt\";\n    cerr << \"DEBUG MODE\" <<  endl;\n    cerr << test_cases << \" -->\" << endl;\n    auto fs = fstream(test_cases, fstream::in);\n    int lp = 0;\n    while(fs) {\n        lp++;\n        cout << lp <<  \"#------\\n\";\n        sub_main(fs);\n    }\n    cout << \"------#\" << endl;\n    if(lp <= 1) sub_main(cin);\n#else\n    while(cin) sub_main(cin);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\nint kake(int x, int y){ return min(x,y); }\nint pulas(int x, int y){ return max(x,y); }\nint inverse(int x){ return 2-x; }\n\n\nint parse(char *s, int p, int q, int r){\n\t//printf(\"%c\\n\",*s);\n\tswitch(*s){\n\t\tcase '\\0' : return 0;\n\t\tcase 'P' : return p;\n\t\tcase 'Q' : return q;\n\t\tcase 'R' : return r;\n\t\tcase '0' : case '1' : case '2' : return *s-'0';\n\t\t\n\t\tcase '-' :\n\t\t\treturn inverse(parse(s+1,p,q,r));\n\t\tcase '(' :\n\t\t\tint x=1;\n\t\t\tchar *tmp = s+1;\n\t\t\tdo{\n\t\t\t\tif( *tmp=='(' )x++;\n\t\t\t\telse if( *tmp==')' )x--;\n\t\t\t\tif( x==1 ){\n\t\t\t\t\tif( *tmp=='*' || *tmp=='+' ) break;\n\t\t\t\t}\n\t\t\t\t//printf(\"x:%d , %c\\n\",x,*tmp);\n\t\t\t\ttmp++;\n\t\t\t}while(x);\n\t\t\t\n\t\t\t//printf(\"e? : %c\\n\",*tmp);\n\t\t\tif( *tmp=='*' ){\n\t\t\t\treturn kake(parse(s+1,p,q,r),parse(tmp+1,p,q,r));\n\t\t\t}else if( *tmp=='+' ){\n\t\t\t\treturn pulas(parse(s+1,p,q,r),parse(tmp+1,p,q,r));\n\t\t\t}\n\t\t\tputs(\"error\");\n\t}\n\treturn 0;\n}\nint main(){\n\tchar in[128];\n\tint ret;\n\twhile(scanf(\"%s\",in),strcmp(in,\".\")){\n\t\tret = 0;\n\t\trep(p,3)rep(q,3)rep(r,3)if( parse(in,p,q,r)==2 )ret++;\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nchar mns(char c) {\n\tif (c == '0') return '2';\n\tif (c == '1') return '1';\n\treturn '0';\n}\n\nchar multi(char c1, char c2) {\n\tif (c1 == '0' || c2 == '0') return '0';\n\tif (c1 == '2' && c2 == '2') return '2';\n\treturn '1';\n}\n\nchar pls(char c1, char c2) {\n\tif (c1 == '2' || c2 == '2') return '2';\n\tif (c1 == '0' && c2 == '0') return '0';\n\treturn '1';\n}\n\nchar eval(string s) {\n\tif (s[0] != '(') {\n\t\tint i = 0;\n\t\twhile (s[i] == '-') i++;\n\t\tif (i % 2) return mns(s[i]);\n\t\treturn s[i];\n\t}\n\n\ts = s.substr(1, (int)s.size() - 2);\n\t\n\tint cnt = 0;\n\tint pt = 0;\n\twhile (!(cnt == 0 && (s[pt] == '+' || s[pt] == '*'))) {\n\t\tif (s[pt] == '(') cnt++;\n\t\telse if (s[pt] == ')') cnt--;\n\t\tpt++;\n\t}\n\n\tstring a = s.substr(0, pt);\n\tstring b = s.substr(pt + 1);\n\n\tif (s[pt] == '+') return pls(eval(a), eval(b));\n\treturn multi(eval(a), eval(b));\n}\n\nsigned main() {\n\twhile (true) {\n\t\tstring t;\n\t\tcin >> t;\n\n\t\tif (t == \".\") break;\n\n\t\tint ret = 0;\n\t\tfor (char p = '0'; p <= '2'; p++) {\n\t\t\tfor (char q = '0'; q <= '2'; q++) {\n\t\t\t\tfor (char r = '0'; r <= '2'; r++) {\n\t\t\t\t\tstring s = t;\n\t\t\t\t\trep(i, s.size()) {\n\t\t\t\t\t\tif (s[i] == 'P') s[i] = p;\n\t\t\t\t\t\telse if (s[i] == 'Q') s[i] = q;\n\t\t\t\t\t\telse if (s[i] == 'R') s[i] = r;\n\t\t\t\t\t}\n\t\t\t\t\tret += (eval(s) == '2');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<functional>\n#include<utility>\n#include<assert.h>\nusing namespace std;\nint sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2},\n};\n\nint prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2},\n};\n\nint neg[3] = {2,1,0};\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    string str;\n    getline(cin, str);\n    if(str[0] == '.') break;\n    int cnt = 0;\n    for(int p = 0; p < 3; p++) {\n      for(int q = 0; q < 3; q++) {\n        for(int r = 0; r < 3; r++) {\n          int sp = 0;\n          function<int()> parse = [&str, &sp, p, q, r, &parse](){\n            char c = str[sp++];\n            if(c=='(') {\n              int l = parse();\n              char op = str[sp++];\n              int r = parse();\n              sp++;  // ')'\n              if(op == '+') {\n                return sum[l][r];\n              } else if(op=='*'){\n                return prod[l][r];\n              } else {\n                assert(false);\n                return -1;\n              }\n            } else if(c == '-') {\n              return neg[parse()];\n            } else if(c == 'P') {\n              return p;\n            } else if(c == 'Q') {\n              return q;\n            } else if(c == 'R') {\n              return r;\n            } else if(c == '0') {\n              return 0;\n            } else if(c == '1') {\n              return 1;\n            } else if(c == '2') {\n              return 2;\n            } else {\n              assert(false);\n            }\n          };\n          if(parse()==2) cnt++;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint vari[3];\nstring s;\n\nstring regenerate(string t) {\n    int n = t.length();\n    string ret = \"\";\n    rep(i,0,n) {\n        if(i < n-1 && t[i] == '-' && t[i+1] == '-') i++;\n        else ret += t[i];\n    }\n    return ret;\n}\n\nint opnot(int m) {\n    return 2 - m;\n}\n\nvector< vector<int> > opmul{ {0, 0, 0}, {0, 1, 1}, {0, 1, 2} };\nvector< vector<int> > oppls{ {0, 1, 2}, {1, 1, 2}, {2, 2, 2} };\n\nint retvari(char c) {\n    string chk = \"PQR\";\n    if(chk.find(c) != string::npos) return vari[ chk.find(c) ];\n    else return c - '0';\n}\n\nint solve(int l, int r) {\n    if(r - l == 1) return retvari(s[l]);\n    else {\n        int cnt = 0, nl = -1, nr = -1;\n        int vl, vr;\n        rep(i,l,r) {\n            if(s[i] == '(') {\n                cnt++;\n            }\n            if(s[i] == ')') {\n                cnt--;\n            }\n            if(s[i] == '*' && cnt == 0) {\n                vl = solve(l, i);\n                vr = solve(i+1, r);\n                return opmul[vl][vr];\n            }\n            if(s[i] == '+' && cnt == 0) {\n                vl = solve(l, i);\n                vr = solve(i+1, r);\n                return oppls[vl][vr];\n            }\n        }\n    }\n\n    if(s[l] == '-') return opnot( solve(l+1, r) );\n    else return solve(l+1, r-1);\n}\n\nsigned main() {\n    while(cin >> s, s != \".\") {\n        s = regenerate(s);\n        int n = s.length(), cnt = 0;\n        rep(i,0,3) rep(j,0,3) rep(k,0,3) {\n            vari[0] = i, vari[1] = j, vari[2] = k;\n            if(solve(0, n) == 2) cnt++;\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nstring s;\nint p,q,r;\nconst int n[]={2,1,0};\nint i;\n\nint f(){\n    int ret;\n    if(s[i]=='P')ret=p;\n    else if(s[i]=='Q')ret=q;\n    else if(s[i]=='R')ret=r;\n    else if(isdigit(s[i]))ret=s[i]-'0';\n    else if(s[i]=='-'){\n        i++;\n        return n[f()];\n    }\n    else if(s[i]=='('){\n        i++;\n        ret=f();\n        if(s[i]=='*')i++,ret=min(ret,f());\n        else if(s[i]=='+')i++,ret=max(ret,f());\n    }\n    i++;\n    return ret;\n}\n\nvoid run(){\n    cin>>s;\n    if(s==\".\")return;\n    int ans=0;\n    for(p=0;p<3;p++)for(q=0;q<3;q++)for(r=0;r<3;r++){\n        i=0;\n        int ret=f();\n        if(ret==2)ans++;\n    }\n    cout<<ans<<endl;\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nint formula(string &s, int P, int Q, int R, int &i) {\n    if(s[i] == '-') {\n        i++;\n        return 2-formula(s, P, Q, R, i);\n    } else if(s[i] == '(') {\n        int X, Y;\n        i++;\n        X = formula(s, P, Q, R, i);\n        if(s[i] == '*') {\n            i++;\n            Y = formula(s, P, Q, R, i);\n            i++;\n            if(X == 0) return 0;\n            if(X == 1) {\n                if(Y == 0) return 0;\n                else return 1;\n            } else {\n                return Y;\n            }\n        } else {\n            i++;\n            Y = formula(s, P, Q, R, i);\n            i++;\n            if(X == 0) return Y;\n            if(X == 1) {\n                if(Y == 0) return 1;\n                else return Y;\n            } else {\n                return 2;\n            }\n        }\n    } else {\n        int ret;\n        if(s[i] >= '0' && s[i] <= '2') ret = s[i]-'0';\n        else if(s[i] == 'P') ret = P;\n        else if(s[i] == 'Q') ret = Q;\n        else if(s[i] == 'R') ret = R;\n        i++;\n        return ret;\n    }\n}\n\nint main(void){\n    string s;\n    while(cin >> s && s != \".\") {\n        int cnt = 0;\n        rep(i, 3) rep(j, 3) {\n            rep(k, 3) {\n                int index = 0;\n                if(formula(s, i, j, k, index) == 2) cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstring str;\nint idx;\n\n\nint getn() {\n    char c = str[idx];\n    idx++;\n    if (c == '-') {\n        return 2-getn();\n    } else {\n        return c-'0';\n    }\n}\n\nint calc() {\n    char c = str[idx];\n    if (c == '(') {\n        idx++;\n        int r1 = calc();\n        char cc = str[idx];\n        idx++;\n        int r2 = calc();\n        idx++;\n        if (cc == '*') {\n            return min(r1, r2);\n        } else {\n            return max(r1, r2);\n        }\n    } else {\n        return getn();\n    }\n}\n\nint main() {\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \".\") break;\n        int res = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    str = \"\";\n                    for (int i = 0; i < s.size(); i++) {\n                        switch (s[i]) {\n                        case 'P':\n                            str += to_string(p);\n                            break;\n                        case 'Q':\n                            str += to_string(q);\n                            break;\n                        case 'R':\n                            str += to_string(r);\n                            break;\n                        default:\n                            str += s[i];\n                            break;\n                        }\n                    }\n                    str += '=';\n                    idx = 0;\n                    //cerr << str << endl;\n                    if (calc() == 2) {\n                        //cerr << \"asdkfjf\" << endl;\n                        res++;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n\nstring input, ss;\nint a[3], it, cnt;\n\nint Not(int x) {\n    return 2-x;\n}\n\nint And(int x, int y) {\n    if (x*y == 0) return 0;\n    if (x == 2 && y == 2) return 2;\n    return 1;\n}\n\nint Or(int x, int y) {\n    if (x == 2 || y == 2) return 2;\n    if (x == 1 || y == 1) return 1;\n    return 0;\n}\n\nint parse() {\n    char c = ss[it++];\n    if ('0' <= c && c <= '2') return c-'0';\n    if (c == '-') return Not(parse());\n\n    int x = parse();\n    c = ss[it++];\n    int y = parse();\n    ++it;\n    return c == '*' ? And(x, y) : Or(x, y);\n}\n\nvoid dfs(int i) {\n    if (i == 3) {\n        ss = input;\n        for (char& c : ss) {\n            if (c == 'P') c = a[0]+'0';\n            if (c == 'Q') c = a[1]+'0';\n            if (c == 'R') c = a[2]+'0';\n        }\n        it = 0;\n        if (parse() == 2) cnt++;\n        return ;\n    }\n\n    rep (j,3) {\n        a[i] = j;\n        dfs(i+1);\n    }\n}\n\nint main() {\n    while (cin >> input && input != \".\") {\n        rep (i,3) a[i] = i;\n        cnt = 0;\n        dfs(0);\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str;\nint pos;\nint P, Q, R;\n\nint formula() {\n  pos ++;\n  if(str[pos] == '(') {\n    int f = formula();\n    pos ++;\n    if(str[pos] == '+') f = max(f, formula());\n    if(str[pos] == '*') f = min(f, formula());\n    pos ++;\n    return f;\n  }\n  \n  if(str[pos] == '-') return 2-formula();\n  if(str[pos] == '0') return 0;\n  if(str[pos] == '1') return 1;\n  if(str[pos] == '2') return 2;\n  if(str[pos] == 'P') return P;\n  if(str[pos] == 'Q') return Q;\n  if(str[pos] == 'R') return R;\n  \n}\n\nint main() {\n  \n  while(cin >> str) {\n    if(str == \".\") break;\n    int cnt = 0;\n    for(P = 0; P<=2; P++)\n      for(Q = 0; Q<=2; Q++)\n\tfor(R = 0; R<=2; R++) {\n\t  pos = -1;\n\t  cnt += formula() == 2;\n\t}\n    cout << cnt << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst string seeds[10] = {\n\t\"000\",\n\t\"001\",\n\t\"002\",\n\t\"011\",\n\t\"012\",\n\t\"022\",\n\t\"111\",\n\t\"112\",\n\t\"122\",\n\t\"222\"\n};\n\nchar evaluate( string ex )\n{\n\tint f;\n\tint s;\n\tfor ( int i = 0; i < ex.size(); i++ )\n\t{\n\t\tif ( ex[i] == '(' )\n\t\t\tf = i;\n\t\telse if ( ex[i] == ')' )\n\t\t{\n\t\t\ts = i;\n\t\t\tstring sub = ex.substr( f+1, s-f-1 );\n\t\t\tex.erase( ex.begin()+f, ex.begin()+s+1 );\n\t\t\tchar n = evaluate( sub );\n\t\t\tex.insert( ex.begin()+f, n );\n\t\t\ti = s = f = 0;\n\t\t}\n\t}\n\n\t// \"-ðµæ¤\"\n\tfor ( int i = 0; i < ex.size(); i++ )\n\t{\n\t\tif ( ex[i] == '-' )\n\t\t{\n\t\t\tif ( ex[i+1] == '0' )\n\t\t\t{\n\t\t\t\tex.erase( ex.begin()+i, ex.begin()+i+2 );\n\t\t\t\tex.insert( ex.begin()+i, '2' );\n\t\t\t}\n\t\t\telse if ( ex[i+1] == '1' )\n\t\t\t{\n\t\t\t\tex.erase( ex.begin()+i, ex.begin()+i+2 );\n\t\t\t\tex.insert( ex.begin()+i, '1' );\n\t\t\t}\n\t\t\telse if ( ex[i+1] == '2' )\n\t\t\t{\n\t\t\t\tex.erase( ex.begin()+i, ex.begin()+i+2 );\n\t\t\t\tex.insert( ex.begin()+i, '0' );\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t// ÁAæ\n\tfor ( int i = 0; i < ex.size(); i++ )\n\t{\n\t\tif ( ex[i] == '*' )\n\t\t{\n\t\t\tif ( ex[i-1] == '0' || ex[i+1] == '0' )\n\t\t\t\treturn '0';\n\t\t\telse if ( ex[i-1] == '1' || ex[i+1] == '1' )\n\t\t\t\treturn '1';\n\t\t\telse\n\t\t\t\treturn '2';\n\t\t}\n\t\telse if ( ex[i] == '+' )\n\t\t{\n\t\t\tif ( ex[i-1] == '2' || ex[i+1] == '2' )\n\t\t\t\treturn '2';\n\t\t\telse if ( ex[i-1] == '1' || ex[i+1] == '1' )\n\t\t\t\treturn '1';\n\t\t\telse\n\t\t\t\treturn '0';\n\t\t}\n\t}\n\n\treturn ex[0];\n}\n\nint main( void )\n{\n\tstring in;\n\twhile ( cin >> in && in != \".\" )\n\t{\n\t\t// \"--\"ÍÁ¹é\n\t\tint index = 0;\n\t\twhile ( ( index = in.find( \"--\" ) ) != string::npos )\n\t\t{\n\t\t\tin.replace( index, 2, \"\" );\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor ( int k = 0; k < 10; k++ )\n\t\t{\n\t\t\tstring seed;\n\t\t\tseed = seeds[k];\n\t\t\tdo {\n\t\t\t\tstring ex = in;\n\t\t\t\treplace( ex.begin(), ex.end(), 'P', seed[0] );\n\t\t\t\treplace( ex.begin(), ex.end(), 'Q', seed[1] );\n\t\t\t\treplace( ex.begin(), ex.end(), 'R', seed[2] );\n\n\t\t\t\t//==================================================\n\t\t\t\t// CÌ\n\t\t\t\t//==================================================\n\t\t\t\tchar result = evaluate( ex );\n\t\t\t\tif ( result == '2' ) cnt ++;\n\t\t\t} while ( next_permutation( seed.begin(), seed.end() ) );\n\t\t}\n\n\t\t//==================================================\n\t\t// oÍ\n\t\t//==================================================\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid replace_all(string& s,string from,string to){\n\tstring::size_type p = 0;\n\twhile(p=s.find(from,p), p!=string::npos){\n\t\ts.replace(p,from.length(),to);\n\t\tp+=to.length();\n\t}\n}\n\nint main(void){\n\tint i,j,k,l,count;\n\tstring s,ts,num[3]={\"0\",\"1\",\"2\"};\n\tstring to0[6]={\"(0*0)\",\"(0*1)\",\"(0*2)\",\"(1*0)\",\"(2*0)\",\"(0+0)\"};\n\tstring to1[6]={\"(1*1)\",\"(1*2)\",\"(2*1)\",\"(0+1)\",\"(1+0)\",\"(1+1)\"};\n\tstring to2[6]={\"(2*2)\",\"(0+2)\",\"(1+2)\",\"(2+0)\",\"(2+1)\",\"(2+2)\"};\n\n\twhile(cin>>ts && ts!=\".\"){\n\t\tcount = 0;\n\t\treplace_all(ts,\"--\",\"\");\n\n\t\tfor(i=0;i<=2;i++){\n\t\t\tfor(j=0;j<=2;j++){\n\t\t\t\tfor(k=0;k<=2;k++){\n\t\t\t\t\ts = ts;\n\t\t\t\t\treplace_all(s,\"P\",num[i]);\n\t\t\t\t\treplace_all(s,\"Q\",num[j]);\n\t\t\t\t\treplace_all(s,\"R\",num[k]);\n\n\t\t\t\t\twhile(s.length() != 1){\n\t\t\t\t\t\treplace_all(s,\"-1\",\"1\");\n\t\t\t\t\t\treplace_all(s,\"-2\",\"0\");\n\t\t\t\t\t\treplace_all(s,\"-0\",\"2\");\n\n\t\t\t\t\t\tfor(l=0;l<6;l++){\n\t\t\t\t\t\t\treplace_all(s,to0[l],\"0\");\n\t\t\t\t\t\t\treplace_all(s,to1[l],\"1\");\n\t\t\t\t\t\t\treplace_all(s,to2[l],\"2\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s==\"2\") count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<count<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring str;\nint p;\n\nint negate_(int f) { return 2 - f; }\n\nint add(int a, int b) {\n  if (a == 2 || b == 2) {\n    return 2;\n  } else if (a == 0 && b == 0) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint mult(int a, int b) {\n  if (a * b == 0) {\n    return 0;\n  } else if (a * b == 4) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nint P, Q, R;\n\nint term(char c) {\n  switch (c) {\n    case 'P':\n     return P;\n    case 'Q':\n      return Q;\n    case 'R':\n      return R;\n  }\n}\n\nint formula() {\n  if (str[p] == '-') {\n    p++; // read -\n    int f = formula();\n    return negate_(f);\n  } else if (isdigit(str[p])) {\n    int f = str[p] - '0';\n    p++; // read [0-2]\n    return f;\n  } else if (isalpha(str[p])) {\n    int f = term(str[p]);\n    p++; // read [P-R]\n    return f;\n  } else {\n    p++; // read (\n    int a = formula();\n    if (str[p] == '*') {\n      p++; // read *\n      int b = formula();\n      p++; // read )\n      return mult(a, b);\n    } else {\n      p++; // read +\n      int b = formula();\n      p++; // read )\n      return add(a, b);\n    }\n  }\n}\n\nint main() {\n  while (cin >> str and str != \".\") {\n    p = 0;\n    int ans = 0;\n    for (P = 0; P < 3; P++) \n      for (Q = 0; Q < 3; Q++)\n        for (R = 0; R < 3; R++)\n          if (p = 0, formula() == 2) \n            ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint P, Q, R;\nint pos;\nstring str;\n\nint formula(void){\n\n  pos++;\n  switch(str[pos]){\n  case '-': return 2 - formula();\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  case '0': return 0;\n  case '1': return 1;\n  case '2': return 2;\n\n  case '(':\n    int form1 = formula();\n    int form2;\n    pos++; // '*' or '+' のぶんを飛ばすため\n    switch(str[pos]){\n    case '*':\n      form2 = formula();\n      pos++; // ')' のぶんを飛ばすため\n      return min(form1, form2);\n    case '+':\n      form2 = formula();\n      pos++; // ')' のぶんを飛ばすため\n      return max(form1, form2);\n    }\n  }\n  return 0;\n}\n\n\nint main(void){\n\n  while(getline(cin, str )){\n    int cnt = 0;\n    if(str == \".\") break;\n\n    // 全パターン試す\n    for(int i = 0 ; i < 3 ; i++){\n      for(int j = 0 ; j < 3 ; j++){\n\tfor(int k = 0 ; k < 3 ; k++){\n\t  P = i, Q = j, R = k;\n\t  pos = -1;\n\t  if(formula() == 2) cnt++;\n\t}\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nconst int se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint num(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tif (isdigit(s[idx])||s[idx]=='-')return num(s, idx);\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\treturn val;\n}\nint num(string& s, int &idx) {\n\tint not= 0;\n\twhile (s[idx]=='-')\n\t{\n\t\tnot++;\n\t\tidx++;\n\t}\n\tint val = s[idx] - '0';\n\tidx++;\n\tif (not% 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint minus_rotate(int minus_n, int v) {\n\tif (v == 1)return 1;\n\tif (v == 0) {\n\t\tif (minus_n % 2 == 0)return 0;\n\t\telse return 2;\n\t}\n\tif (v == 2) {\n\t\tif (minus_n % 2 == 0)return 2;\n\t\telse return 0;\n\t}\n}\n\nint kakeru(int a, int b) {\n\tint list[3][3] = { {0,0,0},{0,1,1},{0,1,2} };\n\treturn list[a][b];\n}\n\nint tasu(int a, int b) {\n\tint list[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\treturn list[a][b];\n}\n\nint parser(vector<int> vlist) {\n\tint minus_continue = 0;\n\tint step = 0;\n\tint A, B;\n\tint calc_kind = 0;\n\tfor (int i = 0; i < vlist.size(); i++) {\n\t\tint now = vlist[i];\n\t\tif(step == 0){\n\t\t\tif (now == 100 && !minus_continue) {\n\t\t\t\tminus_continue = 1;\n\t\t\t}\n\t\t\telse if (minus_continue && now == 100) {\n\t\t\t\tminus_continue++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tA = minus_rotate(minus_continue, now);\n\t\t\t\tminus_continue = 0;\n\t\t\t\tstep = 1;\n\t\t\t}\n\t\t}\n\t\telse if (step == 1) {\n\t\t\tif (now == -1) {\n\t\t\t\tcalc_kind = 1;\n\t\t\t}\n\t\t\tif (now == -2) {\n\t\t\t\tcalc_kind = 2;\n\t\t\t}\n\t\t\tstep = 2;\n\t\t}\n\t\telse if (step == 2) {\n\t\t\tif (now == 100 && !minus_continue) {\n\t\t\t\tminus_continue = 1;\n\t\t\t}\n\t\t\telse if (minus_continue && now == 100) {\n\t\t\t\tminus_continue++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tB = minus_rotate(minus_continue, now);\n\t\t\t\tminus_continue = 0;\n\t\t\t\t//�v�Z�p�[�g�A�v�Z����A�Ɋi�[�����B\n\t\t\t\tif (calc_kind == 1) {\n\t\t\t\t\tA = kakeru(A, B);\n\t\t\t\t}\n\t\t\t\tif (calc_kind == 2) {\n\t\t\t\t\tA = tasu(A, B);\n\t\t\t\t}\n\n\t\t\t\tstep = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn A;\n}\n\nint calc(int a, int b, int c, string formula) {\n\tint ret = 0;\n\tbool isrem = false;//()�̒��g���L�����Ă邩\n\tstring next;\n\tint nest = 0;\n\tvector<int> value;\n\tfor (int i = 0; i < formula.size(); i++) {\n\t\tchar now = formula[i];\n\t\tif (now == '(') {\n\t\t\tnest++; \n\t\t\tif(nest == 1)isrem = true;\n\t\t\telse next += now;\n\t\t}\n\t\telse if (now == ')') {\n\t\t\tnest--;\n\t\t\tif (nest == 0) {\n\t\t\t\tisrem = false;\n\t\t\t\tvalue.push_back(calc(a, b, c, next));\n\t\t\t\tnext.clear();\n\t\t\t}\n\t\t\telse next += now;\n\t\t}\n\t\telse if (isrem) {\n\t\t\tnext += now;\n\t\t}\n\t\telse {\n\t\t\tif (now == '*')value.push_back(-1);\n\t\t\tif (now == '+')value.push_back(-2);\n\t\t\tif (now == '-') {\n\t\t\t\tvalue.push_back(100);\n\t\t\t}\n\t\t\tif (now == '0')value.push_back(0);\n\t\t\tif (now == '1')value.push_back(1);\n\t\t\tif (now == '2')value.push_back(2);\n\t\t\tif (now == 'P')value.push_back(a);\n\t\t\tif (now == 'Q')value.push_back(b);\n\t\t\tif (now == 'R')value.push_back(c);\n\t\t}\n\t}\n\n\treturn parser(value);\n}\n\nint main() {\n\tstring S;\n\n\twhile (cin >> S, S != \".\") {\n\n\t\tint cnt = 0;\n\t\t\n\t\tfor (int a = 0; a < 3; a++) {\n\t\t\tfor (int b = 0; b < 3; b++) {\n\t\t\t\tfor (int c = 0; c < 3; c++) {\n\t\t\t\t\tif (calc(a, b, c, S) == 2) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nchar stck[80];\nchar NOT(char a){return 98-a;}\nchar AND(char a,char b){\n  return min(a,b);\n}\nchar OR(char a,char b){\n  return max(a,b);\n}\nbool is012(char c){return '0'<=c&&c<='2';}\nint main(){ _;\n  string s;\n  while(cin>>s,s[0]!='.'){\n    int sum=0;\n    REP(p,3)REP(q,3)REP(r,3){\n      int ptr=0;\n      for(char c:s){\n\tstck[ptr]=(c=='P'?p+'0':c=='Q'?q+'0':c=='R'?r+'0':c);\n\tptr++;\n\twhile(true){\n\t  if(ptr>=2&&stck[ptr-2]=='-'&&is012(stck[ptr-1])){\n\t    stck[ptr-2]=NOT(stck[ptr-1]);\n\t    ptr--;\n\t  }else if(ptr>=3&&is012(stck[ptr-3])&&stck[ptr-2]=='*'&&is012(stck[ptr-1])){\n\t    stck[ptr-3]=AND(stck[ptr-3],stck[ptr-1]);\n\t    ptr-=2;\n\t  }else if(ptr>=3&&is012(stck[ptr-3])&&stck[ptr-2]=='+'&&is012(stck[ptr-1])){\n\t    stck[ptr-3]=OR(stck[ptr-3],stck[ptr-1]);\n\t    ptr-=2;\n\t  }else if(ptr>=3&&stck[ptr-3]=='('&&is012(stck[ptr-2])&&stck[ptr-1]==')'){\n\t    stck[ptr-3]=stck[ptr-2];\n\t    ptr-=2;\n\t  }else break;\n\t}\n\t//\tREP(i,ptr)cout<<stck[i];\n\t//\tcout<<endl;\n      }\n      if(stck[0]=='2')sum++;\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint pqr[3];\nint fom(string h);\nint main(){\n  string h;\n  while(getline(cin,h)){\n    if(h == \".\"){break;}\n    int ans = 0;\n    for(int i=0; i<27; i++){\n      pqr[0] = i%3;\n      pqr[1] = (i/3)%3;\n      pqr[2] = (i/9)%3;\n      if(fom(h) == 2){ans++;}\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}\nint fom(string h){\n  int ans,one,two,dow,an;\n  bool f = false;\n  ans = one = two = dow = an = -1;\n  for(int i=0; i<h.size(); i++){\n    if(h[i] == '0'){dow = 0;}\n    else if(h[i] == '1'){dow = 1;}\n    else if(h[i] == '2'){dow = 2;}\n    else if(h[i] == 'P'){dow = pqr[0];}\n    else if(h[i] == 'Q'){dow = pqr[1];}\n    else if(h[i] == 'R'){dow = pqr[2];}\n    else if(h[i] == '-'){f = (f+1)%2;}\n    else if(h[i] == '+'){an = 0;}\n    else if(h[i] == '*'){an = 1;}\n    else if(h[i] == '('){\n      int j;\n      for(j = 1; j+i<h.size(); j++){\n\tif(h[j+i] == ')'){break;}\n      }\n      dow = fom(h.substr(i+1,j-1));\n      i = i+j;\n    }\n    if(dow != -1){\n      if(f){dow = 2-dow;}\n      if(one == -1){one = dow;}\n      else{two = dow;}\n      dow = -1;\n      f = 0;\n    }\n    if(one != -1 && two != -1){\n      if(an == 0){one = max(one,two);}\n      if(an == 1){one = min(one,two);}\n      an = -1;\n      two = -1;\n    }\n  }\n  if(one != -1 && two == -1){ans = one;}\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nint p,q,r;\nint pos;\n\nint parse(string &s) {\n    if(s[pos] == '(') {\n        pos++;\n        int k = parse(s),res;\n        if(s[pos] == '+') {\n            pos++;\n            int l = parse(s);\n            if(k == 2 || l == 2) res = 2;\n            else if(k == 0 && l == 0) res = 0;\n            else res = 1;\n        }else if(s[pos] == '*') {\n            pos++;\n            int l = parse(s);\n            if(k == 0 || l == 0) res = 0;\n            else if(k == 2 && l == 2) res = 2;\n            else res = 1;\n        }\n        assert(s[pos] == ')');\n        pos++;\n        return res;\n    }\n    if(s[pos] == '-') {\n        pos++;\n        int k = parse(s);\n        if(k == 0) return 2;\n        else if(k == 1) return 1;\n        else return 0;\n    }\n\n    if(s[pos] == 'P') {\n        pos++;\n        return p;\n    }\n    if(s[pos] == 'Q') {\n        pos++;\n        return q;\n    }\n    if(s[pos] == 'R') {\n        pos++;\n        return r;\n    }\n    if(s[pos] == '0' || s[pos] == '1' || s[pos] == '2') {\n        int l = s[pos] - '0';\n        pos++;\n        return l;\n    }\n\n    assert(false);\n}\n\nint main() {\n    string s;\n    while(cin>>s) {\n        if(s == \".\") break;\n\n        int ans = 0;\n        for(int i=0; i<=2; ++i)\n            for(int j=0; j<=2; ++j)\n                for(int k=0; k<=2; ++k) {\n                    p=i,q=j,r=k;\n                    pos = 0;\n                    if(parse(s) == 2) ans++;\n                }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct RES {\n  int idx, val;\n  RES(int i, int v) : idx(i), val(v) {}\n};  \n\nRES parse(string& line, int idx, int p, int q, int r) \n{\n  char c = line[idx];\n  if (c == '0') return RES(idx+1, 0);\n  if (c == '1') return RES(idx+1, 1);\n  if (c == '2') return RES(idx+1, 2);\n  if (c == 'P') return RES(idx+1, p);\n  if (c == 'Q') return RES(idx+1, q);\n  if (c == 'R') return RES(idx+1, r);\n  if (c == '-') {\n    RES r1 = parse(line, idx+1, p, q, r);\n    return RES(r1.idx, 2 - r1.val);\n  }\n  if (c == '(') {\n    RES  r1 = parse(line, idx+1, p, q, r);\n    char op = line[r1.idx];\n    RES  r2 = parse(line, r1.idx+1, p, q, r);\n    if (op == '*') {\n      if (r1.val == 2 && r2.val == 2) return RES(r2.idx + 1, 2);\n      if (r1.val > 0 && r2.val > 0)   return RES(r2.idx + 1, 1);\n      return RES(r2.idx + 1, 0);\n    }\n    else if (op == '+') {\n      if (r1.val == 0 && r2.val == 0) return RES(r2.idx + 1, 0);\n      if (r1.val < 2 && r2.val < 2)   return RES(r2.idx + 1, 1);\n      return RES(r2.idx + 1, 2);\n    }\n    else\n      cout << \"error at \" << r1.idx << \" (\" << line[r1.idx] << \")\" << endl;\n  }\n  else\n    cout << \"error at \" << (idx+1) << \" (\" << c << \")\" << endl;\n}\n\nvoid compute(string& line) \n{\n  int models = 0;\n  for (int p=0; p <= 2; p++)\n    for (int q=0; q <= 2; q++)\n      for (int r=0; r <= 2; r++)\n        if (parse(line, 0, p, q, r).val == 2)\n          models++;\n  cout << models << endl;\n}\n\nint main(void) \n{\n  string line;\n  while (cin >> line) {\n    if (line[0] == '.') break;\n    compute(line);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint check(char op, int x, int y) {\n    switch (op) {\n    case '*':\n        if (x == 2 && y == 2) return 2;\n        return x & y;\n    case '+':\n        if (x == 2 || y == 2) return 2;\n        return x | y;\n    }\n    while (1);\n}\n\nint formula(string& form, int& idx) {\n    switch (form[idx]) {\n    case '0':\n    case '1':\n    case '2':\n        return form[idx] - '0';\n    case '-':\n        return 2 - formula(form, ++idx);\n    case '(':\n        int x = formula(form, ++idx);\n        char op = form[++idx];\n        int y = formula(form, ++idx);\n        ++idx;\n        return check(op, x, y);\n    }\n    while (1);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \".\") {\n            break;\n        }\n\n        int n = 0;\n        REP(p, 3) REP(q, 3) REP(r, 3) {\n            string tmp = line;\n            REP(i, tmp.length()) {\n                switch (tmp[i]) {\n                case 'P':\n                    tmp[i] = p + '0';\n                    break;\n                case 'Q':\n                    tmp[i] = q + '0';\n                    break;\n                case 'R':\n                    tmp[i] = r + '0';\n                    break;\n                }\n            }\n            int idx = 0;\n            if (formula(tmp, idx) == 2) {\n                n++;\n            }\n        }\n        cout << n << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstring st;\nint a;\nvector<int>nums;\nint calc(const int a, const char c, const int b) {\n\tif (c == '-') {\n\t\treturn 2 - a;\n\t}\n\telse if (c == '*') {\n\t\treturn min(a, b);\n\t}\n\telse if (c == '+') {\n\t\treturn max(a, b);\n\t}\n\telse {\n\t\tassert(false);\n\t}\n}\nint getnum() {\n\tif (isdigit(st[a])) {\n\t\tint num = st[a] - '0';\n\t\ta++;\n\t\treturn num;\n\t}\n\telse {\n\t\tint num = nums[st[a] - 'P'];\n\t\ta++;\n\t\treturn num;\n\t}\n}\n\nint getform() {\n\tif (st[a] == '-') {\n\t\ta++;\n\t\tint num = getform();\n\t\treturn calc(num, '-', num);\n\t}\n\telse if (st[a] == '(') {\n\t\ta++;\n\t\tint num = getform();\n\t\tchar c = st[a];\n\t\ta++;\n\t\tint anum = getform();\n\t\tassert(st[a] == ')');\n\t\ta++;\n\t\treturn calc(num, c, anum);\n\t}\n\telse {\n\t\treturn getnum();\n\t}\n}\nint solve() {\n\tint correct = 0;\n\tfor (int i = 0; i < 27; ++i) {\n\t\t{\n\t\t\tint n(i);\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tnums[j] = n % 3;\n\t\t\t\tn /= 3;\n\t\t\t}\n\t\t}\n\t\ta = 0;\n\t\tint ans = getform();\n\t\tif (ans == 2)correct++;\n\t}\n\treturn correct;\n}\nint main() {\n\tnums.resize(3);\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \".\")break;\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <string.h>\n\n#define MAX_N 100\n\nusing namespace std;\n\nchar form[MAX_N];\nchar str[MAX_N];\n\nint calc_form(int l, int r){ //l-r???????????????????¨????\n\tint former, latter;\n\tint count = 0;\n\tint i;\n\tif(str[l] == '0') return 0;\n\tif(str[l] == '1') return 1;\n\tif(str[l] == '2') return 2;\n\tif(str[l] == '-'){\n\t\ti = l;\n\t\twhile(str[i] == '-') i++;\n\t\tint res = calc_form(i, r);\n\t\tif((i-l)%2 == 0){\n\t\t\treturn res;\n\t\t}else{\n\t\t\tif(res == 2) return 0;\n\t\t\telse if(res == 1) return 1;\n\t\t\telse return 2;\n\t\t}\n\t}\n\tfor (i = l+1; i < r; i++)\n\t{\n\t\tif((str[i] == '+' || str[i] == '*') && count == 0) break;\n\t\tif(str[i] == '(') count++;\n\t\tif(str[i] == ')') count--;\n\t}\n\tformer = calc_form(l+1, i-1);\n\tlatter = calc_form(i+1, r-1);\n\tif(str[i] == '*'){\n\t\tif(former == 2 && latter == 2) return 2;\n\t\tif(former == 0 || latter == 0) return 0;\n\t\telse return 1;\n\t}else if(str[i] == '+'){\n\t\tif(former == 2 || latter == 2) return 2;\n\t\tif(former == 0 && latter == 0) return 0;\n\t\telse return 1;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> form;\n\t\tif(form[0] == '.') break;\n\t\tstrcpy(str, form);\n\t\tint ans = 0;\n\t\tfor (int p = 0; p <= 2; p++)\n\t\t{\n\t\t\tfor (int q = 0; q <= 2; q++)\n\t\t\t{\n\t\t\t\tfor (int r = 0; r <= 2 ; r++)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < strlen(str); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(str[i] == 'P') str[i] = p+'0';\n\t\t\t\t\t\tif(str[i] == 'Q') str[i] = q+'0';\n\t\t\t\t\t\tif(str[i] == 'R') str[i] = r+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif(calc_form(0, strlen(str)-1) == 2) ans++;\n\t\t\t\t\tstrcpy(str, form);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef int value;\n\nstring s;\nsize_t cur = 0;\nvalue P, Q, R;\nint ans = 0;\n\nvalue and(value a, value b){\n\treturn (a<b) ? a : b;\n}\nvalue or(value a, value b){\n\treturn (a<b) ? b : a;\n}\nvalue formula(){\n\tvalue a, b, f;\n\tchar op;\n\tswitch (s[cur]){\n\tcase ('0') :\n\tcase ('1') :\n\tcase ('2') :\n\t\t\t   f = s[cur] - '0';\n\t\tcur++;\n\t\tbreak;\n\tcase ('P') :\n\t\tf = P;\n\t\tcur++;\n\t\tbreak;\n\tcase ('Q') :\n\t\tf = Q;\n\t\tcur++;\n\t\tbreak;\n\tcase ('R') :\n\t\tf = R;\n\t\tcur++;\n\t\tbreak;\n\tcase ('-') :\n\t\tf = 2 - formula();\n\t\tbreak;\n\tcase ('(') :\n\t\tcur++;\n\t\ta = formula();\n\t\tassert(s[cur] == '*' || s[cur] == '+');\n\t\top = s[cur];\n\t\tcur++;\n\t\tb = formula();\n\t\tf = (op == '*') ? and(a, b) : or(a, b);\n\t\tassert(s[cur] == ')');\n\t\tcur++;\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t\tbreak;\n\t}\n\treturn f;\n}\nint main(){\n\tcin >> s;\n\twhile (s != \".\"){\n\t\tfor (P = 0; P <= 2; P++)\n\t\t\tfor (Q = 0; Q <= 2; Q++)\n\t\t\t\tfor (R = 0; R <= 2; R++){\n\t\t\t\t\tif (formula() == 2)ans++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tcin >> s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring s;\nvector<int> p,q,r;\nint x;\n\nint formula(){\n\tint ans;\n\tif(s[x] == '0' || s[x] == '1' || s[x] == '2'){\n\t\tstringstream ss;\n\t\tss << s[x];\n\t\tss >> ans;\n\t\treturn ans;\n\t}\n\telse if(s[x] == '-'){\n\t\tx++;\n\t\treturn 2 - formula();\n\t}\n\telse if(s[x] == '('){\n\t\tx++;\n\t\tint a = formula();\n\t\tx++;\n\t\tif(s[x] == '+'){\n\t\t\tx++;\n\t\t\tint b = formula();\n\t\t\tx++;\n\t\t\treturn max(a,b);\n\t\t}\n\t\telse if(s[x] == '*'){\n\t\t\tx++;\n\t\t\tint b = formula();\n\t\t\tx++;\n\t\t\treturn min(a,b);\n\t\t}\n\t}\n}\n\nint main(){\n\tint ans;\n\twhile(1){\n\t\tcin >> s;\n\t\tif(s[0] == '.')break;\n\t\tans = 0;\n\t\tp.clear();\n\t\tq.clear();\n\t\tr.clear();\n\t\tfor(int i = 0;i < s.size();i++){\n\t\t\tif(s[i] == 'P')p.push_back(i);\n\t\t\telse if(s[i] == 'Q')q.push_back(i);\n\t\t\telse if(s[i] == 'R')r.push_back(i);\n\t\t}\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 3;j++){\n\t\t\t\tfor(int k = 0;k < 3;k++){\n\t\t\t\t\tfor(int l = 0;l < p.size();l++)s[p[l]] = '0' + i;\n\t\t\t\t\tfor(int l = 0;l < q.size();l++)s[q[l]] = '0' + j;\n\t\t\t\t\tfor(int l = 0;l < r.size();l++)s[r[l]] = '0' + k;\n\t\t\t\t\tx = 0;\n\t\t\t\t\tif(formula() == 2)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstring str;\n\nint evaluate(int idx){\n  if(str[idx]=='('){\n    int depth=1;\n    int idx2=idx+1;\n    while(depth>0){\n      if(str[idx2]=='('){\n        depth++;\n      }else if(str[idx2]==')'){\n        depth--;\n      }else if(str[idx2]=='+' && depth==1){\n        return max(evaluate(idx+1), evaluate(idx2+1));\n      }else if(str[idx2]=='*' && depth==1){\n        return min(evaluate(idx+1), evaluate(idx2+1));\n      }\n      idx2++;\n    }\n  }else{\n    if(str[idx]=='-'){\n      return 2-evaluate(idx+1);\n    }else{\n      return str[idx]-'0';\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    string tmp;\n    cin >> tmp;\n    if(tmp[0] == '.') break;\n\n    str = tmp;\n    int count = 0;\n    for(int i=0; i<=2; i++){\n      for(int j=0; j<=2; j++){ \n        for(int k=0; k<=2; k++){\n          //substitute\n          for(int idx=0; idx<(int)tmp.length(); idx++){\n            if(tmp[idx]=='P') str[idx]='0'+i;\n            else if(tmp[idx]=='Q') str[idx]='0'+j;\n            else if(tmp[idx]=='R') str[idx]='0'+k;\n            else str[idx]=tmp[idx];\n          }\n          if(evaluate(0) == 2) count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tswitch (T[pos++]) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return 2 - solve();\n\t\tcase '(':\n\t\t\tint a = solve();\n\t\t\tswitch (T[pos]) {\n\t\t\t\tcase '+': return min(a, solve());\n\t\t\t\tcase '*': return max(a, solve());\n\t\t\t}\n\t\t\tpos++;\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <string>\n\nusing namespace std;\nusing P=tuple<int, int>;\n\nclass Solver {\n};\n\nint solve(int p, int q, int r, string s) {\n\tint val = 0;\n\tif (s[0] == '(') {\n\t\tint nest = 0;\n\t\tstring now = \"\";\n\t\tbool plus = false;\n\t\tint val1 = 0;\n\t\tfor (int i = 1; i < s.size()-1; i++) {\n\t\t\tif (nest == 0 && s[i] == '+') {\n\t\t\t\tplus = true;\n\t\t\t\tval1 = solve(p, q, r, now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\telse if (nest == 0 && s[i] == '*') {\n\t\t\t\tplus = false;\n\t\t\t\tval1 = solve(p, q, r, now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow += s[i];\n\t\t\t\tif (s[i] == '(')nest++;\n\t\t\t\tif (s[i] == ')')nest--;\n\t\t\t}\n\t\t}\n\t\tint val2 = solve(p, q, r, now);\n\t\tif (plus) {\n\t\t\tval = max(val1, val2);\n\t\t}\n\t\telse {\n\t\t\tval= min(val1, val2);\n\t\t}\n\t}\n\telse {\n\t\tif (s[0] == '-') {\n\t\t\tval= 2 - solve(p, q, r, s.substr(1));\n\t\t}\n\t\telse {\n\t\t\tif (s[0] == '0')val= 0;\n\t\t\tif (s[0] == '1')val = 1;\n\t\t\tif (s[0] == '2')val = 2;\n\t\t\tif (s[0] == 'P')val = p;\n\t\t\tif (s[0] == 'Q')val = q;\n\t\t\tif (s[0] == 'R')val = r;\n\t\t}\n\t}\n\treturn val;\n}\n\nstring replace_all(string s, string before, string after) {\n\tstring now = \"\";\n\tvector<bool> replacable(s.size(), false);\n\tfor (int i = 0; i < s.size() - before.size() + 1; i++) {\n\t\tbool valid = true;\n\t\tfor (int j = 0; j < before.size(); j++) {\n\t\t\tif (s[i + j] == before[j])continue;\n\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (valid) {\n\t\t\tfor (int j = 0; j < before.size(); j++) {\n\t\t\t\treplacable[i + j] = true;\n\t\t\t}\n\t\t\ti += before.size();\n\t\t}\n\t}\n\n\tstring ret = \"\";\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (replacable[i]) {\n\t\t\tret += after;\n\t\t\ti += before.size() - 1;\n\t\t}\n\t\telse {\n\t\t\tret += s[i];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (true) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s[0] == '.')break;\n\n\t\ts = replace_all(s, \"--\", \"\");\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tif (solve(i, j, k, s) == 2)res++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <stack>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nstring in;\n\nint dfs(int l, int r, int P, int Q, int R){\n  int N = in.length(),i,res=0;\n\n  if(l + 1 == r){\n    if(in[l] == '0' || in[l] == '1' || in[l] == '2') return in[l]-'0';\n    if(in[l] == 'P') return P;\n    if(in[l] == 'Q') return Q;\n    if(in[l] == 'R') return R;\n  }\n  if(in[l] == '-'){\n    return 2 - dfs(l+1,r,P,Q,R);\n  }\n  if(in[l] == '('){\n    int op = 0;\n    for(i = l+1; i < r-1; i++){\n      if(in[i] == '(') op++;\n      if(in[i] == ')') op--;\n      if(op == 0 && (in[i] == '*')) return min(dfs(l+1,i,P,Q,R),dfs(i+1,r-1,P,Q,R));\n      if(op == 0 && (in[i] == '+')) return max(dfs(l+1,i,P,Q,R),dfs(i+1,r-1,P,Q,R));\n    }\n  }\n}\n\nint main(){\n  int i;\n\n  while(1){\n    cin >> in;\n    if(in == \".\") break;\n\n    int j,k,ans=0;\n    rep(i,3) rep(j,3) rep(k,3){\n      if(dfs(0,in.length(),i,j,k) == 2) ans++;\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint id = 0;\nint memo[3] = {0};\n\nint recall();\nint solve();\n\nint main() {\n  while(1) {\n    cin >> s;\n    if(s == \".\") break;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 0; i < 3; ++i)\n    for(int j = 0; j < 3; ++j)\n      for(int k = 0; k < 3; ++k) {\n        id = -1;\n        memo[0] = i;\n        memo[1] = j;\n        memo[2] = k;\n        if(recall() == 2) ++ans;\n      }\n  return ans;\n}\n\nint recall() {\n  int now = 0, nextn = 0;\n  bool option = 0;\n  ++id;\n  if(s[id] >= '0' && s[id] <= '2') return s[id] - '0';\n  if(s[id] >= 'P' && s[id] <= 'R') return memo[s[id] - 'P'];\n  if(s[id] == '-') return 2 - recall();\n  now = recall();\n  if(s[++id] == '+') option = 1;\n  nextn = recall();\n  ++id;\n  if(option) {\n    if(now == 2 || nextn == 2) return 2;\n    return now + nextn > 0;\n  }\n  if(now == 0 || nextn == 0) return 0;\n  return 1 + (now * nextn == 4);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstruct node{\n    char type;\n    int value;\n    node *left, *right;\n    node(){\n        type='\\0';\n        value=-1;\n        left=right=NULL;\n    }\n    ~node(){\n        if(left!=NULL) delete left;\n        if(right!=NULL) delete right;\n    }\n};\n\nnode *root;\n\nint rec(node* p, int i, string str){\n    if(i==str.size())return -1;\n    if(str[i]=='0'||str[i]=='1'||str[i]=='2'){\n        p->type='C';\n        p->value=str[i]-'0';\n        return i;\n    }\n    if(str[i]=='-'){\n        p->type='-';\n        p->left=new node();\n        return rec(p->left,i+1,str);\n    }\n    if(str[i]=='P'||str[i]=='Q'||str[i]=='R'){\n        p->type=str[i];\n        return i;\n    }\n    if(str[i]=='('){\n        p->left=new node();\n        i=rec(p->left,i+1,str)+1;\n        p->type=str[i];\n        p->right=new node();\n        i=rec(p->right,i+1,str)+1;\n        return i;\n    }\n    return i;\n}\nint P,Q,R;\n\nint rec2(node*p){\n    if(p==NULL) return -1;\n    if(p->type=='C') return p->value;\n    if(p->type=='P') return P;\n    if(p->type=='Q') return Q;\n    if(p->type=='R') return R;\n    if(p->type=='-'){\n        switch(rec2(p->left)){\n            case 0: return 2;\n            case 1: return 1;\n            case 2: return 0;\n        }\n    }\n    if(p->type=='*'){\n        int l,r;\n        l=rec2(p->left);\n        r=rec2(p->right);\n        if(!l||!r)return 0;\n        if(l==2&&r==2) return 2;\n        return 1;\n    }\n    if(p->type=='+'){\n        int l,r;\n        l=rec2(p->left);\n        r=rec2(p->right);\n        if(l==2||r==2) return 2;\n        if(!l&&!r) return 0;\n        return 1;        \n    }\n    return -1;\n}\n\nint main(){\n    string str;\n    node *p;\n    while(cin>>str,str[0]!='.'){\n        root=new node();\n        rec(root,0,str);\n        int ans=0;\n        for(P=0;P<3;P++){\n            for(Q=0;Q<3;Q++){\n                for(R=0;R<3;R++){\n                    if(rec2(root)==2)ans++;\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=k+'0';\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint P, Q, R;\n\nint eval(string &S, int &cur) {\n    if (S[cur] == '(') {\n        int a = eval(S, ++cur);\n        char op = S[cur];\n        int b = eval(S, ++cur);\n        int res = 0;\n        if (op == '*') {\n            res = min(a, b);\n        } else {  // S[cur] == '+'\n            if (a == 2 || b == 2) {\n                res = 2;\n            } else if (a == 1 || b == 1) {\n                res = 1;\n            } else {\n                res = 0;\n            }\n        }\n\n        // curは閉じ括弧に位置する\n        ++cur;\n        return res;\n    } else if (S[cur] == '-') {  // S[cur] == '-'\n        int a = eval(S, ++cur);\n        return 2 - a;\n    } else if (S[cur] == 'P') {\n        ++cur;\n        return P;\n    } else if (S[cur] == 'Q') {\n        ++cur;\n        return Q;\n    } else if (S[cur] == 'R') {\n        ++cur;\n        return R;\n    } else {\n        int res = (int)(S[cur] - '0');\n        ++cur;\n        return res;\n    }\n}\n\nint main() {\n    string S;\n    while (cin >> S, S != \".\") {\n        int res = 0;\n        for (P = 0; P <= 2; ++P) {\n            for (Q = 0; Q <= 2; ++Q) {\n                for (R = 0; R <= 2; ++R) {\n                    int cur = 0;\n                    if (eval(S, cur) == 2) ++res;\n                    //cout << \"cur: \" << cur << endl;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\nusing namespace std;\n\nmap<char,int> nanm;\nint nanminus;\nint nani;\nint narec(string s){\n\tif(s[nani]=='P'||s[nani]=='Q'||s[nani]=='R'){\n\t\tnani++;\n\t\tint minus=nanminus;\n\t\tnanminus=0;\n\t\treturn pow(-1,minus)*nanm[s[nani-1]];\n\t}\n\tif(isdigit(s[nani])){\n\t\tnani++;\n\t\tint minus=nanminus;\n\t\tnanminus=0;\n\t\treturn pow(-1,minus)*(s[nani-1]-'0'-1);\n\t}\n\tif(s[nani]=='-'){\n\t\tnanminus++;\n\t\tnani++;\n\t\treturn narec(s);\n\t}\n\tif(s[nani]=='('){\n\t\tnani++;\n\t\tint left=narec(s);\n\t\tchar op=s[nani];\n\t\tnani++;\n\t\tint right=narec(s);\n\t\tnani++;\n\t\tif(op=='*')\treturn min(left,right);\n\t\tif(op=='+')\treturn max(left,right);\n\t}\n\treturn -2;\n}\n\n\nint main(){\n\tstring s;\n\tint P,Q,R;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint ans=0;\n\t\tfor(P=-1;P<=1;P++){\n\t\t\tfor(Q=-1;Q<=1;Q++){\n\t\t\t\tfor(R=-1;R<=1;R++){\n\t\t\t\t\tnanminus=0;\n\t\t\t\t\tnani=0;\n\t\t\t\t\tnanm['P']=P;nanm['Q']=Q;nanm['R']=R;\n\t\t\t\t\tif(narec(s)==1){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// 'P', 'Q', 'R' ツづー '1', '2', '3' ツづ可置ツつォツ環キツつヲツづゥ\nvoid PQR_change(string& s ,char p , char q , char r ){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == 'P' ) s[i] = p;\n\t\tif( s[i] == 'Q' ) s[i] = q;\n\t\tif( s[i] == 'R' ) s[i] = r;\n\t}\n}\n\n// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\" ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_erace(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '-' && s[i-1] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\n// \"-0\", \"-1\", \"-2\" ツづー \"2\", \"1\", \"0\" ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_calc(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' && ( s[i] == '0' || s[i] == '1' || s[i] == '2' ) ){\n\t\t\tif( s[i] == '0' ){\n\t\t\t\ts.replace( i-1 , 2 , \"2\" );\n\t\t\t}else if( s[i] == '1' ){\n\t\t\t\ts.replace( i-1 , 2 , \"1\" );\n\t\t\t}else if( s[i] == '2' ){\n\t\t\t\ts.replace( i-1 , 2 , \"0\" );\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\n// \"(0+0)\", ... , \"(2*2)\" ツづー \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ (18ツ津環づィ) \nvoid calc(string& s){\n\tstring ex[18] = {\n\t\t\"(0+0)\", \"(0+1)\", \"(0+2)\",\n\t\t\"(1+0)\", \"(1+1)\", \"(1+2)\",\n\t\t\"(2+0)\", \"(2+1)\", \"(2+2)\",\n\t\t\"(0*0)\", \"(0*1)\", \"(0*2)\",\n\t\t\"(1*0)\", \"(1*1)\", \"(1*2)\",\n\t\t\"(2*0)\", \"(2*1)\", \"(2*2)\"\n\t};\n\tstring result[18] = {\n\t\t\"0\", \"1\", \"2\",\n\t\t\"1\", \"1\", \"2\",\n\t\t\"2\", \"2\", \"2\",\n\t\t\"0\", \"0\", \"0\",\n\t\t\"0\", \"1\", \"1\",\n\t\t\"0\", \"1\", \"2\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 18 ; j++ ){\n\t\t\tif( s.substr(i,5) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile( cin >> s , s != \".\" ){\n\t\tint ans = 0;\n\t\tfor(char p = '0' ; p <= '2' ; p++ ){\n\t\t\tfor(char q = '0' ; q <= '2' ; q++ ){\n\t\t\t\tfor(char r = '0' ; r <= '2' ; r++ ){\n\t\t\t\t\tstring s_ = s;\n\t\t\t\t\t// 'P', 'Q', 'R' ツづー '1', '2', '3'ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tPQR_change( s_ , p , q , r );\n\t\t\t\t\t// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\"ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tminus_erace( s_ );\n\t\t\t\t\t\n\t\t\t\t\t// \"0\", \"1\", \"2\" ツづ個値ツづ可づ按づゥツづ慊づ繰ツづィツ陛板つオツ嘉算ツづ湘ヲツ算ツづーツ計ツ算ツつキツづゥ\n\t\t\t\t\twhile( s_.size() > 1 ){\n\t\t\t\t\t\t// \"-0\", \"-1\", \"-2\" ツづー \"2\", \"1\", \"0\" ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\t\tminus_calc( s_ );\n\t\t\t\t\t\t// \"(0+0)\", ... , \"(2*2)\" ツづー \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ (18ツ津環づィ) \n\t\t\t\t\t\tcalc( s_ );\n\t\t\t\t\t\t// cout << \"debug : \" << s_ << endl;\n\t\t\t\t\t}\n\t\t\t\t\tif( s_ == \"2\" ){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(i=0;i<n;i++)\n\nusing namespace std;\n\nint v[3],n,c;\nstring s;\n\nint f(){\n  n++;\n  int r;\n  if(s[n-1]=='(')r=f(),n++,r=s[n-1]=='+'?max(r,f()):min(r,f()),n++;\n  else if(s[n-1]=='-')r=2-f();\n  else if(isdigit(s[n-1]))r=s[n-1]-'0';\n  else r=v[s[n-1]-'P'];\n  return r;\n}\n\nint main(){ \n  cin >> s;\n  if(s!=\".\"){\n    c=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3)n=0,c+=f()/2;\n    cout << c << endl;\n    main();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define State string::const_iterator\nclass ParseError {};\n\n\nint expression(State &begin);\n//int term(State &begin);\nint number(State &begin);\nint factor(State &begin);\nint denial(State &begin);\nvoid consume(State &begin, char expected);\nint p,q,r;\nstring input;\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '+'){\n            consume(begin, '+');\n            int num = factor(begin);\n            //cout << num << \" + \" << ret;\n            if(ret == 0 && num == 0){\n                ret = 0;\n            }\n            else if(ret == 1 || num == 1){\n                if(ret != 2 && num != 2){\n                    ret = 1;\n                }\n                else{\n                    ret = 2;\n                }\n            }\n            else{\n                ret = 2;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else if(*begin == '*'){\n            consume(begin, '*');\n            int num = factor(begin);\n            //cout << num << \" * \" << ret;\n            if(num == 2 && ret == 2){\n                ret = 2;\n            }\n            else if(num == 0 || ret == 0){\n                ret = 0;\n            }\n            else{\n                ret = 1;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\nint denial(State &begin){\n    if(*begin == '-'){\n\n        consume(begin, '-');\n\n        int ret = factor(begin);\n\n        if(ret == 2){\n            ret = 0;\n        }\n        else if(ret == 0){\n            ret = 2;\n        }\n\n        return ret;\n    }\n    return number(begin);\n}\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\n    if(*begin == 'P'){\n        consume(begin, 'P');\n        return p;\n    }\n    else if(*begin == 'Q'){\n        consume(begin, 'Q');\n        return q;\n    }\n    else if(*begin == 'R'){\n        consume(begin, 'R');\n        return r;\n    }\n\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        int ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return denial(begin);\n    }\n}\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        cerr << input.end() - begin << endl;\n        throw ParseError();\n    }\n}\n\n\n\nint main() {\n\n\n\n    while(true){\n\n        cin >> input;\n\n        if(input[0] == '.'){\n            break;\n        }\n\n        int ans = 0;\n\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                for(int k=0; k<3; k++){\n                    p = i;\n                    q = j;\n                    r = k;\n                    State s = input.begin();\n                    if(factor(s) == 2){\n                        ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<algorithm>\n\nusing namespace std;\n\n\nbool check(string str,int P,int Q,int R){\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='P')str[i]=P+'0';\n\t\tif(str[i]=='Q')str[i]=Q+'0';\n\t\tif(str[i]=='R')str[i]=R+'0';\n\t}\n\tstack<int> sta[50];\n\tint rank=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='-')sta[rank].push(-1);\n\t\tif(str[i]=='+')sta[rank].push(-2);\n\t\tif(str[i]=='*')sta[rank].push(-3);\n\t\tif(str[i]=='(')rank++;\n\t\tif(str[i]==')'){\n\t\t\tint c=sta[rank].top(),flag2=0;\n\t\t\tsta[rank].pop();\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\trank--;\n\t\t\tsta[rank].push(c);\n\t\t}\n\t\tif(str[i]>='0' && str[i]<='2'){\n\t\t\tint c=str[i]-'0',flag2=0;\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsta[rank].push(c);\n\t\t}\n\t}\n\tif(sta[0].top()==2)return true;\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\".\")break;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(check(str,i,j,k))cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint p,q,r,i;\nint dfs(){\n  int t[2]={},c=0,m=0,w=0,k=0,a=0;\n  if(s[i]=='(')i++;\n  for(;i<s.size();i++){\n    if(s[i]=='(')t[c++]=dfs(),a++;\n    else if(s[i]>='0'&&s[i]<='2')t[c++]=s[i]-'0',a++;\n    else if(s[i]=='P')t[c++]=p,a++;\n    else if(s[i]=='Q')t[c++]=q,a++;\n    else if(s[i]=='R')t[c++]=r,a++;\n    else if(s[i]=='-')m++;\n    else if(s[i]=='+')w++,a=0;\n    else if(s[i]=='*')k++,a=0;\n    if(m%2&&a){\n     t[c-1]=abs(t[c-1]-2);\n     a=m=0;\n   }\n    if(s[i]==')'){\n      if(w)return max(t[0],t[1]);\n      if(k)return min(t[0],t[1]);\n    }\n  }\n  return t[0];\n}\nint main(){\n  while(cin>>s,s!=\".\"){\n      int res=0;\n      r(x,3)r(y,3)r(z,3){\n\tp=x;q=y;r=z;i=0;\n\tif(dfs()==2)res++;\n      }\n      cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\n\n\n\n\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\nstring s,tmp;\nchar aa[]={'P','Q','R'};\n\nstring schange(string st,char a,char b){\n\t// cout<<a<<\" \"<<b<<endl;\n\trep(i,st.size()){\n\t\tif(st[i]==a){\n\t\t\tst[i]=b;\n\t\t}\n\t}\n\treturn st;\n}\n\nstring NOT(string t){\n\tif(t[1]=='1') return \"1\";\n\telse if(t[1]=='2') return \"0\";\n\treturn \"2\";\n}\nstring AND(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==0||b==0) return \"0\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"2\";\n}\nstring OR(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==2||b==2) return \"2\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"0\";\n}\nbool isnum(char t){\n\tif(t>='0'&&t<='2') return true;\n\treturn false;\n}\n\nint calc(string tmp){\n\t// cout<<tmp<<endl;\n\tif(tmp.size()==1&&tmp[0]=='2') return 2;\n\telse if(tmp.size()==1) return 0;\n\tint tmps=tmp.size();\n\tbool f=false;\n\twhile(1){\n\t\trep(i,tmp.size()){\n\t\t\t\tif(tmp[i]=='('){\n\t\t\t\t\tif(tmp[i+2]==')'){\n\t\t\t\t\t\ttmp=tmp.substr(0,i)+tmp.substr(i+1,1)+tmp.substr(i+3);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(tmp[i]=='-'){\n\t\t\t\t\tif(isnum(tmp[i+1])){\n\t\t\t\t\t\ttmp=tmp.substr(0,i)+NOT(tmp.substr(i,2))+tmp.substr(i+2);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(tmp[i]=='*'&&f){\n\t\t\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\n\t\t\t\t\t\ttmp=tmp.substr(0,i-1)+AND(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(tmp[i]=='+'&&f){\n\t\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\t\t\n\t\t\t\t\ttmp=tmp.substr(0,i-1)+OR(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) break;\n\t\tif(tmps!=tmp.size()) break;\n\t\telse f=true;\n\t}\n\treturn calc(tmp);\n}\n\nint solve(string s){\n\tint ans=0;\n\tint c=0;\n\trep(i,3){\n\t\tif(s.find(aa[i])!=-1){\n\t\t\ts = schange(s,aa[i],'a'+c);\n\t\t\tc++;\n\t\t}\n\t}\n\trep(i,3){\n\t\trep(j,3){\n\t\t\trep(k,3){\n\t\t\t\ttmp=s;\n\t\t\t\ttmp = schange(tmp,'a',i+'0');\n\t\t\t\ttmp = schange(tmp,'b',j+'0');\n\t\t\t\ttmp = schange(tmp,'c',k+'0');\n\t\t\t\tif(calc(tmp)==2){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\n}\n\n\nint main(){\n\twhile(cin>>s,s[0]!='.'){\n\t\t\tcout<<solve(s)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nstruct Lex {\n  string S;\n  int P, Q, R;\n  Lex(){}\n  void load(string s){ S = s; }\n  void set(int p, int q, int r){ P = p, Q = q, R = r; }\n  int minus(int x){ return 2 - x; }\n  int mul(int x, int y){ return min(x, y); }\n  int add(int x, int y){ return max(x, y); }\n  int solve(){\n    char *p = (char*)S.c_str();\n    return formula(&p);\n  }\n  int formula(char** p){\n    if (isdigit(**p)){\n      int r = **p - '0';\n      consume(p, **p);\n      return r;\n    }\n    if (isalpha(**p)){\n      int r;\n      if (**p == 'P') r = P;\n      if (**p == 'Q') r = Q;\n      if (**p == 'R') r = R;\n      consume(p, **p);\n      return r;\n    }\n    if (**p == '-'){\n      consume(p, '-');\n      return minus(formula(p));\n    }\n    if (**p == '('){\n      consume(p, '(');\n      int x = formula(p);\n      if (**p == '*'){\n        consume(p, '*');\n        int y = formula(p);\n        consume(p, ')');\n        return mul(x, y);\n      }\n      if (**p == '+'){\n        consume(p, '+');\n        int y = formula(p);\n        consume(p, ')');\n        return add(x, y);\n      }\n    }\n  }\n  inline void consume(char** p, char expected){\n    assert(**p == expected);\n    (*p)++;\n  }\n};\n\nint main()\n{\n  string s;\n  while (cin >> s, s != \".\"){\n    Lex lex;\n    lex.load(s);\n    int ans = 0;\n    for (int p = 0; p < 3; p++){\n      for (int q = 0; q < 3; q++){\n        for (int r = 0; r < 3; r++){\n          lex.set(p, q, r);\n          if (lex.solve() == 2) ans++;\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\nassert(false);\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint solve2(string& s,int& i);\nint solve(string& s,int& i){\n    int ret=solve2(s,i);\n    while(s[i]=='*'||s[i]=='+'){\n        if(s[i]=='*'){\n            ret=min(ret,solve2(s,++i));\n        }\n        else {\n            ret=max(ret,solve2(s,++i));\n        }\n    }\n    return ret;\n}\n\nint solve2(string& s,int& i){\n    if('0'<=s[i]&&s[i]<='2'){\n        return s[i++]-'0';\n    }\n    if(s[i]=='-')return 2-solve2(s,++i);\n    ++i;\n    int ret=solve(s,i);\n    ++i;\n    return ret;\n}\n\n\nvoid solve3(string& s){\n    int ans=0;\n    rep(i1,3)rep(i2,3)rep(i3,3){\n        string t=s;\n        rep(j,s.size()){\n            if(t[j]=='P')t[j]=i1+'0';\n            if(t[j]=='Q')t[j]=i2+'0';\n            if(t[j]=='R')t[j]=i3+'0';\n        }\n        int k=0;\n        int ret=solve(t,k);\n        if(ret==2)++ans;\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    string s;\n    while(cin>>s,s!=\".\")solve3(s);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}\n#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(false);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    assert(fales);\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    string s;\n    cin >> s;\n    if (s == \".\") break;\n    vector<int> v(3);\n    function<int(int &)> dfs = [&](int &i) -> int {\n      if (s[i] == '(') {\n        i++;\n        int e = dfs(i);\n        if (s[i] == '+') {\n          i++;\n          cmax(e, dfs(i));\n        }\n        if (s[i] == '*') {\n          i++;\n          cmin(e, dfs(i));\n        }\n        i++; // ')'\n        return e;\n      }\n      if (s[i] == '-') {\n        i++;\n        return 2 - dfs(i);\n      }\n      if (isdigit(s[i])) return s[i++] - '0';\n      return v[s[i++] - 'P'];\n    };\n    int cnt = 0;\n    for (v[0] = 0; v[0] < 3; v[0]++) {\n      for (v[1] = 0; v[1] < 3; v[1]++) {\n        for (v[2] = 0; v[2] < 3; v[2]++) {\n          int i = 0;\n          cnt += dfs(i) == 2;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar sb[100];\nchar s[100];\nint stsy(int,int,int,int);\nint pr(int,int);\nint ka(int,int);\nint main(){\n  while(1){\n    cin >> sb;\n    if(sb[0]=='.')break;\n    int co=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  strcpy(s,sb);\n\t  int ans;\n\t  //   cout <<i<<j<<k <<\" \";\n\t  ans=stsy(0,i,j,k);\n\t  //\t  cout << ans << endl;\n\t  if(ans==2)\n\t    co++;\n\t}\n      }\n    }\n    cout << co << endl;\n  }\n  return 0;\n}\nint stsy(int I,int p,int q,int r){\n  int d=-1;\n  int d2=-1;\n  int mi=0;\n  int t=0;\n  int x=0;\n  while(1){\n    //cout << s[I] ;\n    if(s[I]==')'||s[I]=='\\0')return d2;\n    else if(s[I]=='('){\n      d=stsy(I+1,p,q,r);\n      for(;s[I]!=')';I++);\n      s[I]='x';\n      \n    }\n    else if(s[I]=='-'){\n      if(mi==0)mi=1;\n      else mi=0;\n    }\n    else if(s[I]=='P')d=p;\n    else if(s[I]=='Q')d=q;\n    else if(s[I]=='R')d=r;\n    else if(s[I]=='0')d=0;\n    else if(s[I]=='1')d=1;\n    else if(s[I]=='2')d=2;\n    else if(s[I]=='+')t=1;\n    else if(s[I]=='*')x=1;\n    if(d!=-1&&mi==1){\n      if(d==2)d=0;\n      else if(d==0)d=2;\n      mi=0;\n    }\n    if(t==1&&d!=-1){\n      d2=pr(d,d2);\n      //  cout << \" \"<<d2 <<'+'<< \" \";\n      d=-1;\n      t=0;\n    }\n    if(x==1&&d!=-1){\n      d2=ka(d,d2);\n      d=-1;\n      x=0;\n    }\n    if(d!=-1){\n      d2=d;\n    }\n    d=-1;\n    I++;\n  }    \n}\nint pr(int a,int b){\n  return max(a,b);\n}\nint ka(int a,int b){\n  return min(a,b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint p, q, r, pos, nn;\nstring in;\n\nint Formula();\nint Seki(int, int);\nint Wa(int, int);\nint Not(int);\nint Num();\nmain(){\n  while(1){\n   cin >> in;\n   if(in==\".\") break;\n   \n   int ans=0;\n   for(p=0;p<3;p++){\n     for(q=0;q<3;q++){\n       for(r=0;r<3;r++){\n\t pos=0;\n\t nn=0;\n\t if(Formula()==2) ans++;\n       }\n     }\n   }\n   cout << ans << endl;\n }\n return 0;\n}\n\nint Formula(){\n  int x;\n  if(in[pos]=='('){\n    pos++;\n    x=Formula();\n    pos++;\n  }else if(in[pos]=='-'){\n    nn=0;\n    while(in[pos]=='-'){\n      nn++;\n      pos++;\n    }\n    if(Num()==-1){\n      x=Formula();\n    }else x=Num();\n    for(int i=0;i<nn;i++){\n      x=Not(x);\n    }\n    nn=0;\n  }else{\n    x=Num();\n  }\n  if(pos<in.size()-1){\n    if(in[pos+1]=='*'){\n      pos+=2;\n      x=Seki(x, Formula());\n    }else if(in[pos+1]=='+'){\n      pos+=2;\n      x=Wa(x, Formula());\n    }\n  }\n  return x;\n}\n\nint Seki(int a, int b){\n  if(a==0){\n    return 0;\n  }else if(a==1){\n    if(b==0) return 0;\n    else return 1;\n  }else{\n    return b;\n  }\n}\n\nint Wa(int a, int b){\n  if(a==0){\n    return b;\n  }else if(a==1){\n    if(b==2) return 2;\n    else return 1;\n  }else{\n    return 2;\n  }\n}\n\nint Not(int a){\n  if(a==0) return 2;\n  if(a==2) return 0;\n  return 1;\n}\n\nint Num(){\n  int x;\n  if(in[pos]=='P'){\n    x=p;\n  }else if(in[pos]=='Q'){\n    x=q;\n  }else if(in[pos]=='R'){\n    x=r;\n  }else if(in[pos]=='0'){\n    x=0;\n  }else if(in[pos]=='1'){\n    x=1;\n  }else if(in[pos]=='2'){\n    x=2;\n  }else x=-1;\n  \n  return x;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tr = 2-r;\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tl = 2-l;\n\t\t\tst.pop();\n\t\t\t\n\t\t\tint tmp;\n\t\t\tif(o == '*')\n\t\t\t\ttmp = AND[r][l];\n\t\t\telse\n\t\t\t\ttmp = OR[r][l];\n\t\t\t\t\n\t\t\tif(!st.empty()){\n\t\t\t\tfor(m=0; !st.empty(); m++)\n\t\t\t\t\tst.pop();\n\t\t\t\tif(m%2)\n\t\t\t\t\ttmp = 2-tmp;\n\t\t\t}\n\t\t\t\n\t\t\tst.push((char)(tmp+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\n\tif(st.top() == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nint main()\n{\n\t//真理値表\n\tchar getminus[3], getmulti[3][3], getplus[3][3];\n\tgetminus[0] = '2';\n\tgetminus[1] = '1';\n\tgetminus[2] = '0';\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (i == 0 || j == 0){\n\t\t\t\tgetmulti[i][j] = '0';\n\t\t\t}\n\t\t\telse if (i == 2 && j == 2){\n\t\t\t\tgetmulti[i][j] = '2';\n\t\t\t}\n\t\t\telse\n\t\t\t\tgetmulti[i][j] = '1';\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (i == 2 || j == 2){\n\t\t\t\tgetplus[i][j] = '2';\n\t\t\t}\n\t\t\telse if (i == 0 && j == 0){\n\t\t\t\tgetplus[i][j] = '0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tgetplus[i][j] = '1';\n\t\t}\n\t}\n\n\tstring s,inits;\n\twhile (cin >> inits, inits[0] != '.'){\n\t\tint counter = 0;\n\t\tfor (char p = '0'; p < '3'; p++){\n\t\t\tfor (char q = '0'; q < '3'; q++){\n\t\t\t\tfor (char r = '0'; r < '3'; r++){\n\t\t\t\t\ts = inits;\n\t\t\t\t\twhile (s.length()>1){\n\t\t\t\t\t\t//代入\n\t\t\t\t\t\tfor (int i = 0; i < s.length(); i++){\n\t\t\t\t\t\t\tif (s[i] == 'P'){\n\t\t\t\t\t\t\t\ts[i] = p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (s[i] == 'Q'){\n\t\t\t\t\t\t\t\ts[i] = q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (s[i] == 'R'){\n\t\t\t\t\t\t\t\ts[i] = r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \"-\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < s.length() - 1; i++){\n\t\t\t\t\t\t\tif (s[i] == '-'&& s[i + 1] != '-' && s[i + 1] != '('){\n\t\t\t\t\t\t\t\ts[i] = getminus[(int)s[i + 1] - '0'];\n\t\t\t\t\t\t\t\ts.erase(s.begin() + i + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//\"*\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < s.length() - 4; i++){\n\t\t\t\t\t\t\tif (s[i] == '('&& s[i + 2] == '*' && s[i + 4] == ')'){\n\t\t\t\t\t\t\t\ts[i] = getmulti[(int)s[i + 1] - '0'][(int)s[i + 3] - '0'];\n\t\t\t\t\t\t\t\ts.erase(i + 1, 4);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//\"+\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < s.length() - 4; i++){\n\t\t\t\t\t\t\tif (s[i] == '('&& s[i + 2] == '+' && s[i + 4] == ')'){\n\t\t\t\t\t\t\t\ts[i] = getplus[(int)s[i + 1] - '0'][(int)s[i + 3] - '0'];\n\t\t\t\t\t\t\t\ts.erase(i + 1, 4);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (s[0] == '2'){\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter++ << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nint not_[3]={2,1,0};\nint and_[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint or_[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\nint i,p,q,r;\nint rec(string s)\n{\n  stack<char>key;\n  int ans=0,v;\n  key.push('+');\n  while(i<s.size())\n    {\n      if(s[i]==')')\n\t{return ans;}\n      else if(s[i]=='+'||s[i]=='-'||s[i]=='*')\n\t  key.push(s[i++]);\n      else\n\t{\n\t  if(s[i]=='(')\n\t    {i++;v=rec(s);}\n\t  else if(s[i]=='P')v=p;\n\t  else if(s[i]=='Q')v=q;\n\t  else if(s[i]=='R')v=r;\n\t  else\n\t      v=s[i]-'0';\n\t  while(!key.empty())\n\t    {\n\t      if(key.top()=='+')\n\t\tans=or_[ans][v];\n\t      else if(key.top()=='-')\n\t\t{\n\t\t  v=not_[v];\n\t\t  if(key.size()==1)ans=v;\n\t\t}\n\t      else if(key.top()=='*')\n\t\tans=and_[ans][v];\n\t      key.pop();\n\t    }\n\t  i++;\n\t}\n    }\n  return ans;\n}\n\nint main()\n{\n  string s;\n  while(cin>>s)\n    {\n      if(s[0]=='.')return 0;\n      int a,b,c;\n      int cnt=0;\n      rep(a,3)rep(b,3)rep(c,3)\n\t{\n\t  p=a;q=b;r=c;\n\t  i=0;\n\t  if(rec(s)==2)cnt++;\n\t}\n      cout<<cnt<<endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\n\nint Minus(int a) {\n  return 2 - a;\n}\n\nint Prod(int a, int b) {\n  if (a == 0) {\n    return 0;\n  }\n  if (b == 0) {\n    return 0;\n  }\n  if (a == 1) {\n    return 1;\n  }\n  if (b == 1) {\n    return 1;\n  }\n  if (a == 2) {\n    return 2;\n  }\n}\n\nint Sum(int a, int b) {\n  return 2 - Prod(2 - a, 2 - b);\n}\n/*\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\n\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n*/\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus(res.first), res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum(lhs.first, rhs.first), rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod(lhs.first, rhs.first), rhs.second + 1);\n    }\n    assert(false);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res = formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 24;\n\nint mns(int val){\n    if(val == 0) val = 2;\n    else if(val == 2) val = 0;\n\n    return val;\n}\n\nint mlt(int lhs, int rhs){\n    return min(lhs, rhs);\n}\n\nint pls(int lhs, int rhs){\n    return max(lhs, rhs);\n}\n\nint parse(string & str, int & pos){\n    int ret;\n\n    if(str.at(pos) == '('){\n        pos++;\n\n        int lhs = parse(str, pos);\n        char op = str.at(pos); pos++;\n        int rhs = parse(str, pos);\n\n        switch(op){\n            case '+': { ret = pls(lhs, rhs); break; }\n            case '*': { ret = mlt(lhs, rhs); break; }\n            default: break;\n        }\n\n        pos++;\n    }\n    else if(str.at(pos) == '-'){\n        int cnt = 0;\n        while(str.at(pos) == '-'){\n            cnt++;\n            pos++;\n        }\n\n        ret = parse(str, pos);\n        if(cnt % 2 == 1) ret = mns(ret);\n    }\n    else {\n        ret = str.at(pos) - '0';\n        pos++;\n    }\n\n    return ret;\n}\n\nint main(void){\n    for(string str_org; cin >> str_org, str_org != \".\";){\n        int res = 0;\n\n        rep(p, 3){\n            rep(q, 3){\n                rep(r, 3){\n                    string str = str_org;\n\n                    for(auto && c : str){\n                        switch(c){\n                            case 'P': { c = p + '0'; break; }\n                            case 'Q': { c = q + '0'; break; }\n                            case 'R': { c = r + '0'; break; }\n                            default: break;\n                        }\n                    }\n\n                    int pos = 0;\n                    if(parse(str, pos) == 2){\n                        res++;\n                    }\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <string>\n#include <functional>\n#include <array>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing A = array<int, 3>;\n\nfunction<int(A &)> f(string::iterator &i) {\n\tswitch (*i) {\n\tcase '0': case '1': case '2':\n\t\t{\n\t\t\tchar c = *i++ - '0';\n\t\t\treturn [c](...) { return c; };\n\t\t}\n\tcase 'P': case 'Q': case 'R':\n\t\t{\n\t\t\tint j = *i == 'P' ? 0 : *i == 'Q' ? 1 : 2;\n\t\t\ti++;\n\t\t\treturn [j](A &e) { return e[j]; };\n\t\t}\n\tcase '-':\n\t\t{\n\t\t\tauto a = f(++i);\n\t\t\treturn [a](A &e) { return 2 - a(e); };\n\t\t}\n\tdefault:\n\t\t{\n\t\t\tauto a = f(++i);\n\t\t\tchar op = *i;\n\t\t\tauto b = f(++i);\n\t\t\ti++;\n\t\t\tif (op == '*')\n\t\t\t\treturn [a, b](A &e) { return min(a(e), b(e)); };\n\t\t\telse\n\t\t\t\treturn [a, b](A &e) { return max(a(e), b(e)); };\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (string s; scan(s), s[0] != '.';) {\n\t\tauto i = s.begin();\n\t\tauto e = f(i);\n\t\tA t;\n\t\tfunction<int(int)> loop = [&](int i) {\n\t\t\tif (i--) {\n\t\t\t\tint a = 0;\n\t\t\t\tfor (t[i] = 0; t[i] < 3; t[i]++)\n\t\t\t\t\ta += loop(i);\n\t\t\t\treturn a;\n\t\t\t} else\n\t\t\t\treturn (int) (e(t) == 2);\n\t\t};\n\t\toutl(loop(3));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=10005,INF=1<<29;\nint P,Q,R;\nint expr(string &S,int &i);\nint term(string &S,int &i);\nint factor(string &S,int &i);\nint number(string &S,int &i);\nstring T=\"012PQR\";\n\nint expr(string &S,int &i){\n    int ret=term(S,i);\n    \n    while(i<S.size()&&(S[i]=='+'||S[i]=='*')){\n        char c=S[i];\n        i++;\n        int to=term(S,i);\n        \n        if(c=='+') ret=max(ret,to);\n        else if(c=='*') ret=min(ret,to);\n    }\n    \n    return ret;\n}\n\nint term(string &S,int &i){\n    int ret;\n    if(S[i]=='-'){\n        i++;\n        ret=2-term(S,i);\n    }else ret=factor(S,i);\n    \n    return ret;\n}\n\nint factor(string &S,int &i){\n    bool ok=false;\n    for(int j=0;j<6;j++) if(S[i]==T[j]) ok=true;\n    \n    if(ok) return number(S,i);\n    \n    i++;\n    \n    int ret=expr(S,i);\n    \n    i++;\n    \n    return ret;\n}\n\nint number(string &S,int &i){\n    int ret;\n    if(isdigit(S[i])) ret=int(S[i]-'0');\n    else{\n        if(S[i]=='P') ret=P;\n        else if(S[i]=='Q') ret=Q;\n        else ret=R;\n    }\n    \n    i++;\n    return ret;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        string S;cin>>S;\n        if(S[0]=='.') break;\n        \n        int cnt=0;\n        \n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                for(int k=0;k<3;k++){\n                    int ii=0;\n                    P=i;\n                    Q=j;\n                    R=k;\n                    \n                    if(expr(S,ii)==2) cnt++;\n                }\n            }\n        }\n        \n        cout<<cnt<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nstring s;\nvi alpha(3);\nint t;\nint formula(int a){\n\tint out=-1;\n\tif(s[t]=='(')++t,out=formula(0);\n\telse if(s[t]=='-')++t,out=2-formula(1);\n\telse if(isdigit(s[t]))out=s[t]-'0';\n\telse if(isalpha(s[t]))out=alpha[s[t]-'P'];\n\t\n\tif(a)return out;\n\tt++;\n\t\n\tif(s[t]=='*')\t\t++t,out=min(out,formula(0));\n\telse if(s[t]=='+')\t++t,out=max(out,formula(0));\n\treturn out;\n}\nvoid f(){\n\tint co=0;\n\trep(P,3)rep(Q,3)rep(R,3){\n\t\talpha[0]=P;\n\t\talpha[1]=Q;\n\t\talpha[2]=R;\n\t\tif(formula(t=0)==2)co++;\n\t}\n\tcout<<co<<endl;\n}\nint main(){while(cin>>s,s!=\".\")f();}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nint P, Q, R;\nconst char *p;\n\nint formula() {\n  \n  p++;\n\n  switch( *p ) {\n  case '-': return 2 - formula();\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  case '0': return 0;\n  case '1': return 1;\n  case '2': return 2;\n    \n  case '(':\n    int form1 = formula();\n    int form2;\n    p++;\n    switch( *p ) {\n    case '*':\n      form2 = formula();\n      p ++;\n      return min( form1, form2 );\n    case '+':\n      form2 = formula();\n      p++;\n      return max( form1, form2 );\n    }\n  }\n  \n  return 0;\n}\n\nint main() {\n  string str;\n  \n  while(getline(cin, str)) {\n    int cnt = 0;\n    if( str == \".\" ) break;\n    for(int i=0; i<3; i++) {\n      for(int j=0; j<3; j++) {\n\tfor(int k=0; k<3; k++) {\n\t  P = i, Q = j, R = k;\n\t  p = &str[0]-1;\n\t  if( formula() == 2 ) cnt ++;\n\t}\n      }\n    }\n    \n    cout << cnt << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<deque>\n#include<stack>\n#include<algorithm>\n#include<cstring>\n#include<cctype>\nusing namespace std;\nint T(char*s)\n{\n\tchar*p,a[2]=\"@\",c;\n\tstack<char> o;\n\tdeque<char> d;\n\tfor(p=s;*p;++p)\n\t{\n\t\ta[0]=*p;\n\t\tif(isdigit(*p))\n\t\t{\n\t\t\td.push_back(*p);\n\t\t\twhile(o.size()&&o.top()=='-')o.pop(),d.push_back('-');\n\t\t}\n\t\tif(strpbrk(a,\"(+*\"))o.push(*p);\n\t\tif(*p=='-')o.push(*p);\n\t\tif(*p==')')while(c=o.top(),o.pop(),c-'(')d.push_back(c);\n\t}\n\twhile(o.size())d.push_back(o.top()),o.pop();\n\tfor(int i=1;i<d.size();)\n\t{\n\t\tif(d[i]=='-')d[i-1]=-(d[i-1]-'1')+'1',d.erase(d.begin()+i);\n\t\telse if(d[i]=='*')d[i-2]=min(d[i-2],d[i-1]),d.erase(d.begin()+i-1,d.begin()+i+1),--i;\n\t\telse if(d[i]=='+')d[i-2]=max(d[i-2],d[i-1]),d.erase(d.begin()+i-1,d.begin()+i+1),--i;\n\t\telse ++i;\n\t}\n\treturn d[0]=='2';\n}\nint main()\n{\n\tchar s[84],t[84],*p,i[3];\n\twhile(scanf(\"%s\",s),s[0]-'.')\n\t{\n\t\tint r=0;\n\t\tfor(i[0]='0';i[0]<'3';++i[0])for(i[1]='0';i[1]<'3';++i[1])for(i[2]='0';i[2]<'3';++i[2])\n\t\t{\n\t\t\tstrcpy(t,s);\n\t\t\twhile(p=strpbrk(t,\"PQR\"))*p=i[*p-'P'];\n\t\t\tr+=T(t);\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct parsed {string str, val; };\n\n//calclate -X\nstring mi(string x)\n{\n    if(x == \"0\")\n        return \"2\";\n    else if(x == \"2\")\n        return \"0\";\n    else \n        return x;\n}\n\n//calclate X * Y\nstring mul(string left, string right)\n{\n    if(left == \"0\" || right == \"0\")\n        return \"0\";\n    else if(left == \"1\" || right == \"1\")\n        return \"1\";\n    else \n        return \"2\";\n}\n\n//calclate X + Y\nstring add(string left, string right)\n{\n    if(left == \"0\" && right == \"0\")\n        return \"0\";\n    else if(left == \"2\" || right == \"2\")\n        return \"2\";\n    else \n        return \"1\";\n}\n\n//parse expression\nparsed formula(string str)\n{\n    string s = str.substr(0, 1);\n    string t = str.substr(1);\n    if(s == \"0\" || s == \"1\" || s == \"2\") {\n        return (parsed){t, s};\n    } else if(s == \"-\") {\n        parsed p = formula(t);\n        return (parsed){p.str, mi(p.val)};\n    } else {\n        parsed lhs = formula(t);\n        string op  = lhs.str.substr(0, 1);\n        parsed rhs = formula(lhs.str.substr(1));\n\n\n        if(op == \"*\") {\n            return (parsed){rhs.str.substr(1), mul(lhs.val, rhs.val)};\n        } else {\n            return (parsed){rhs.str.substr(1), add(lhs.val, rhs.val)};\n        }\n    }\n}\n\nint main()\n{\n    string str;\n    while(cin >> str && str != \".\") {\n        int ans = 0;\n        for(int i = 0; i < 3; i++) {\n            for(int j = 0; j < 3; j++) {\n                for(int k = 0; k < 3; k++) {\n                    string ex = str;\n                    char P = '0' + i;\n                    char Q = '0' + j;\n                    char R = '0' + k;\n                    for(int l = 0; l < ex.size(); l++) {\n                        if(ex[l] == 'P')\n                            ex[l] = P;\n                        else if(ex[l] == 'Q')\n                            ex[l] = Q;\n                        else if(ex[l] == 'R')\n                            ex[l] = R;\n                    }\n                    //cout << ex << endl;\n                    parsed ret = formula(ex);\n                    if(ret.val == \"2\")\n                        ans++;\n\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<char, int> gensi;\nint formular(string&, int&);\nint factor(string&, int&);\n\nint NOT[3] = {2, 1, 0};\nint AND[3][3] = {{0, 0, 0},\n\t       {0, 1, 1},\n\t       {0, 1, 2},};\nint OR[3][3]  = {{0, 1, 2},\n\t       {1, 1, 2},\n\t       {2, 2, 2},};\n\nint formular(string& str, int& p){\n  int res = factor(str, p);\n  while(str[p] == '-' || str[p] == '*' || str[p] == '+'){\n    if(str[p] == '-'){\n      p++;\n      res = NOT[formular(str,  p)];\n    }else if(str[p] == '*'){\n      p++;\n      res = AND[res][formular(str, p)];\n    }else if(str[p] == '+'){\n      p++;\n      res = OR[res][formular(str, p)];\n    }\n  }\n  return res;\n}\n\nint factor(string& str, int& p){\n  int res;\n\n  if(str[p] == '('){\n    while(str[p] != ')'){\n      p++;\n      res = formular(str, p);\n    }\n  }\n\n\n\n  if(str[p] == '0' || str[p] == '1' || str[p] == '2'){\n    res = str[p] - '0';\n    p++;\n  }else if(str[p] == 'P' || str[p] == 'Q' || str[p] == 'R'){\n    res = gensi[str[p]];\n    p++;\n  }\n  return res;\n}\n\n\nint main(void){\n  string str;\n  while(cin >> str, str != \".\"){\n    int ans = 0;\n    for(gensi['P'] = 0; gensi['P'] < 3; gensi['P']++){\n      for(gensi['Q'] = 0; gensi['Q'] < 3; gensi['Q']++){\n        for(gensi['R'] = 0; gensi['R'] < 3; gensi['R']++){\n          int p = 0;\n          if(formular(str, p) == 2){\n            ans++;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint seki[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint wa[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\nint hoge[3] = {2,1,0};\n\nint p,q,r;\nint eval(string s) {\n//  cout << s << endl;\n  if (s[0]!='(') {\n    int i;\n    for (i=0;s[i]=='-';i++);\n    int foo;\n    if (isdigit(s[i])) foo = s[i]-'0';\n    if (s[i]=='P') foo = p;\n    if (s[i]=='Q') foo = q;\n    if (s[i]=='R') foo = r;\n    if (i%2) return hoge[foo];\n    else return foo;\n  }\n  int nest = 0;\n  REP(i,s.length()) {\n    if (s[i] == '(') nest++;\n    if (s[i] == ')') nest--;\n    if (nest!=1) continue;\n    if (s[i] == '+') return wa[eval(s.substr(1,i-1))][eval(s.substr(i+1))];\n    if (s[i] == '*') return seki[eval(s.substr(1,i-1))][eval(s.substr(i+1))];\n  }\n}\n\n\nint main() {\n  string s;\n  while(cin>>s,s!=\".\") {\n    int ans = 0;\n    for(p=0;p<3;p++) {\n      for(q=0;q<3;q++) {\n        for(r=0;r<3;r++) {\n          if (eval(s)==2)\n            ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nstruct Parser{\n    // <formula> ::= 0 | 1 | 2 | P | Q | R |\n    //               -<formula> |\n    //               (<formula>*<formula>) | (<formula>*<formula>)\n    typedef string::const_iterator itr;\n    itr now;\n    vector<int> pqr;\n    const vector<char> ex012 = {'0', '1', '2'};\n    const vector<char> exPQR = {'P', 'Q', 'R'};\n    int ans;\n    Parser(const string &s, vector<int> &pqr)\n        : pqr(pqr)\n        {\n            now = s.begin();\n            ans = formula(now);\n        }\n    int formula(itr &now) {\n        // <formula> ::= -<formula>\n        if(*now == '-') {\n            next(now, '-');\n            int x = formula(now);\n            return NOT(x);\n        } else if(*now == '(') {\n            next(now, '(');\n            int x = formula(now);\n            // <formula> ::= (<formula>*<formula>)\n            if(*now == '*') {\n                next(now, '*');\n                int y = formula(now);\n                next(now, ')');\n                return AND(x, y);\n            // <formula> ::= (<formula>+<formula>)\n            } else if(*now == '+') {\n                next(now, '+');\n                int y = formula(now);\n                next(now, ')');\n                return OR(x, y);\n            }\n        // <formula> ::= 0 | 1 | 2\n        } else if('0' <= *now and *now <= '2') {\n            int ret = *now - '0';\n            next(now, ex012);\n            return ret;\n        // <formula> ::= P | Q | R\n        } else if('P' <= *now and *now <= 'R') {\n            int ret = pqr[*now - 'P'];\n            next(now, exPQR);\n            return ret;\n        }\n        return 0;\n    }\n    int NOT(int x) {\n        if(x != 1) x = (x + 2) % 4;\n        return x;\n    }\n    int AND(int x, int y) {\n        if(x == 2 and y == 2) return 2;\n        if(x > 0 and y > 0) return 1;\n        return 0;\n    }\n    int OR(int x, int y) {\n        if(x == 0 and y == 0) return 0;\n        if(x < 2 and y < 2) return 1;\n        return 2;\n    }\n    void next(itr &now, const char expected) {\n        vector<char> req = {expected};\n        next(now, req);\n    }\n    void next(itr &now, const vector<char> &expected) {\n        for(char c: expected){\n            if(*now == c){\n                now++;\n                return;\n            }\n        }\n        // デバッグ用\n        fprintf(stderr, \"Expected: \");\n        for(char c: expected) fprintf(stderr, \"%c\", c);\n        fprintf(stderr, \"\\nGot: %c\\n\", *now);\n        fprintf(stderr, \"Rest: \");\n        while(*now) fprintf(stderr, \"%c\", *now++);\n    }\n};\n\nint main(){\n    string s;\n    while(cin>>s&&s!=\".\"){\n        int cnt=0;\n        for(int i=0;i<pow(3,3);i++){\n            vector<int> pqr(3);\n            int tmp=i;\n            for(int j=0;j<3;j++){\n                pqr[j]=tmp%3;\n                tmp/=3;\n            }\n            Parser parse(s,pqr);\n            if(parse.ans==2){\n                cnt++;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#define _USE_MATH_DEFINES\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nll inf = llmax / 2;\ndouble eps = 1e-11;\n\nstring S = \"12+1290\";\nstring SS = \"\";\nint cur = 0;\n\nint digit() {\n    assert(isdigit(S[cur]));\n    int n = S[cur] - '0';\n    cur++;\n    return n;\n}\n\nll number() {\n    ll n = digit();\n    while (cur < S.size() && isdigit(S[cur])) {\n        n = n * 10 + digit();\n    }\n    return n;\n}\n\nll formula() {\n    if (S[cur] == '-') {\n        cur++;\n        ll n = formula();\n        if (n == 0) {\n            return 2;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return 0;\n        }\n    } else if (S[cur] == '(') {\n        cur++;\n        ll a = formula();\n        char op = S[cur];\n        cur++;\n        if (cur < S.size()) {\n            ll b = formula();\n            if (op == '*') {\n                a = min(a, b);\n            } else {\n                a = max(a, b);\n            }\n        }\n        assert(S[cur] == ')');\n        cur++;\n        return a;\n    } else {\n        return number();\n    }\n}\n\nll parse(int p, int q, int r) {\n    int len = S.size();\n    for (int i = 0; i < len; i++) {\n        if (S[i] == 'P') {\n            S[i] = p + '0';\n        } else if (S[i] == 'Q') {\n            S[i] = q + '0';\n        } else if (S[i] == 'R') {\n            S[i] = r + '0';\n        }\n    }\n    return formula();\n}\n\nint solve() {\n    int count = 0;\n    for (int p:{0, 1, 2}) {\n        for (int q:{0, 1, 2}) {\n            for (int r:{0, 1, 2}) {\n                S = SS;\n                cur = 0;\n                if (parse(p, q, r) == 2) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    while (true) {\n        cin >> SS;\n        if (SS == \".\") {\n            break;\n        }\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint pqr[3];\nint fom(string h);\nint main(){\n  string h;\n  while(getline(cin,h)){\n    if(h == \".\"){break;}\n    int ans = 0;\n    for(int i=0; i<27; i++){\n      pqr[0] = i%3;\n      pqr[1] = (i/3)%3;\n      pqr[2] = (i/9)%3;\n      if(fom(h) == 2){ans++;}\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}\nint fom(string h){\n  int one,two,dow,an;\n  bool f = false;\n  one = two = dow = an = -1;\n  for(int i=0; i<h.size(); i++){\n    if(h[i] == '0'){dow = 0;}\n    else if(h[i] == '1'){dow = 1;}\n    else if(h[i] == '2'){dow = 2;}\n    else if(h[i] == 'P'){dow = pqr[0];}\n    else if(h[i] == 'Q'){dow = pqr[1];}\n    else if(h[i] == 'R'){dow = pqr[2];}\n    else if(h[i] == '-'){f = (f+1)%2;}\n    else if(h[i] == '+'){an = 0;}\n    else if(h[i] == '*'){an = 1;}\n    else if(h[i] == '('){\n      int j,dps = 0;\n      for(j = 1; j+i<h.size(); j++){\n\tif(h[j+i] == ')'){\n\t  if(dps != 0){dps--;}\n\t  else{break;}\n\t}\n\tif(h[j+i] == '('){dps++;}\n      }\n      dow = fom(h.substr(i+1,j-1));\n      i = i+j;\n    }\n    if(dow != -1){\n      if(f){dow = 2-dow;}\n      if(one == -1){one = dow;}\n      else{two = dow;}\n      dow = -1;\n      f = 0;\n    }\n    if(one != -1 && two != -1){\n      if(an == 0){one = max(one,two);}\n      if(an == 1){one = min(one,two);}\n      an = -1;\n      two = -1;\n    }\n  }\n  return one;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nchar str[100];\nint v[3];\nint eq(int a,int b);\nint ter(int a,int b){\n\tif(str[a]=='(')return eq(a+1,b-1);\n\tif(str[a]=='-')return 2-ter(a+1,b);\n\tif(str[a]>'A')return v[str[a]-'P'];\n\treturn str[a]-'0';\n}\nint fac(int a,int b){\n\tint now=0;\n\tint ret=2;\n\tint las=a;\n\tfor(int i=a;i<b;i++){\n\t\tif(str[i]=='(')now++;\n\t\tif(str[i]==')')now--;\n\t\tif(now==0&&str[i]=='*'){\n\t\t\tret=min(ret,ter(las,i));\n\t\t\tlas=i+1;\n\t\t}\n\t}\n\treturn min(ret,ter(las,b));\n}\nint eq(int a,int b){\n\tint now=0;\n\tint ret=0;\n\tint las=a;\n\tfor(int i=a;i<b;i++){\n\t\tif(str[i]=='(')now++;\n\t\tif(str[i]==')')now--;\n\t\tif(now==0&&str[i]=='+'){\n\t\t\tret=max(ret,fac(las,i));\n\t\t\tlas=i+1;\n\t\t}\n\t}\n\treturn max(ret,fac(las,b));\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='.')return 0;\n\t\tint n=strlen(str);\n\t\tint ret=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tv[0]=i;\n\t\t\t\t\tv[1]=j;\n\t\t\t\t\tv[2]=k;\n\t\t\t\t\tret+=eq(0,n)/2;\n\t\t\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define S str[ima]\n#define F formula(P,Q,R)\nusing namespace std;\nstring str;\nint ima;\nint formula(int P,int Q,int R) {\n  int res;\n  while(1){\n    if(('0'<= S && S<='2')||('P'<=S&& S<='R')){\n      res = S-'0';\n      if(S=='P') res = P;\n      if(S=='Q') res = Q;\n      if(S=='R') res = R;\n      ima++;\n    }\n    else if(S=='-') {\n      ima++;\n      res = F;\n      if(res == 0) res = 2;\n      else if(res == 2) res = 0;\n    }\n    else if(S=='(') {\n      ima++;\n      res = F;\n      if(S=='*')ima++, res = min(F,res);\n      if(S=='+')ima++, res = max(F,res);\n      ima++;\n    }\n    else break;\n  }\n  return res;\n}\n\nint main() {\n  while(1) {\n    cin >> str;\n    if(str==\".\") break;\n    int ans = 0;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tfor(int k=0;k<3;k++){\n\t  ima = 0;\n\t  if(formula(i,j,k) == 2) ans++;\n\t}\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint pqr,now;\nstring s;\n\nint formula(void){\n\t\n\tif(isdigit(s[now])){return s[now++]-'0';}\n\tif(isupper(s[now])){now++;return (pqr>>(s[now-1]-'P'))&1;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tres=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\tfor(pqr=0;pqr<(1<<3);pqr++){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INF = 1001001001;\n\nint formula(const string& str, int& cur)\n{\n//\tputs(str.substr(cur).c_str());\n\tif(isdigit(str[cur])){\n\t\t++cur;\n\t\treturn str[cur-1] - '0';\n\t}\n\tif(str[cur] == '-'){\n\t\t++cur;\n\t\treturn 2 - formula(str, cur);\n\t}\n\n\t++cur;\n\tint a = formula(str, cur);\n\tchar op = str[cur];\n\t++cur;\n\tint b = formula(str, cur);\n\t++cur;\n\tif(op == '+')\n\t\treturn max(a, b);\n\telse\n\t\treturn min(a, b);\n}\n\nint main()\n{\n\tchar str[128];\n\twhile(scanf(\"%s\", str), str[0]!='.'){\n\t\tint n = strlen(str);\n\t\tint cnt = 0;\n\t\trep(p, 3) rep(q, 3) rep(r, 3){\n\t\t\tstring tmp = str;\n\t\t\trep(i, n){\n\t\t\t\tif(tmp[i] == 'P') tmp[i] = p + '0';\n\t\t\t\tif(tmp[i] == 'Q') tmp[i] = q + '0';\n\t\t\t\tif(tmp[i] == 'R') tmp[i] = r + '0';\n\t\t\t}\n\t\t\tint cur = 0;\n\t\t\tcnt += formula(tmp, cur) == 2;\n\t\t}\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nstring s;\nint pos;\nint and2(int a, int b) {\n    if( a==2 and b == 2) return 2;\n    if(a == 0 or b == 0) return 0;\n    return 1;\n}\n\nint or2(int a, int b) {\n    if(a==2 or b==2) return 2;\n    if(a==0 and b==0) return 0;\n    return 1;\n}\n\nint form() {\n    if(s[pos] == '-') {\n        pos++;\n        return 2 - form();\n    } else if(s[pos] == '(') {\n        pos++;\n        int a = form();\n        char ope = s[pos];\n        pos++;\n        int b = form();\n        pos++;\n        if(ope == '*') return and2(a, b);\n        else return or2(a, b);\n    } else {\n        return s[pos++] - '0';\n    }\n}\n\nint main()\n{\n    string rs;\n    while(getline(cin, rs), rs != \".\") {\n        int ans = 0;\n        rep(p, 3) rep(q, 3) rep(r, 3) {\n            pos = 0;\n            s = rs;\n            rep(i, s.size()) {\n                if(rs[i] == 'P') s[i] = p + '0';\n                else if(rs[i] == 'Q') s[i] = q + '0';\n                else if(rs[i] == 'R') s[i] = r + '0';\n            }\n            if(form() == 2) ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nqueue<char> convert(string formula){\n  queue<char> qu;\n  stack<char> st;\n  \n  bool b_minus = false;\n  for(char c : formula){\n    switch(c){\n      case '(':\n        if(b_minus == true) {\n          st.push('-');\n          b_minus = false;\n        }\n        break;\n      case '0': case '1': case '2': case 'P': case 'Q': case 'R':\n        qu.push(c);\n        if(b_minus == true){\n          qu.push('-');\n          b_minus = false;\n        }\n        break;\n      case '*': case '+':\n        st.push(c);\n        break;\n      case '-':\n           b_minus = true;\n        break;\n      case ')':\n        qu.push(st.top());\n        st.pop();\n        if(!st.empty() && st.top() == '-'){\n          qu.push(st.top());\n          st.pop();\n        }\n        break;\n      }\n  }\n  return qu;\n}\n\nint lAnd(int a, int b){\n  if(a == 0 || b == 0) return 0;\n  else if(a == 2 && b == 2) return 2;\n  else return 1;\n}\n\nint lOr(int a, int b){\n  if(a == 2 || b == 2) return 2;\n  else if(a == 0 && b == 0) return 0;\n  else return 1;\n}\n\nint lNot(int a){\n  if(a == 0) return 2;\n  else if(a == 1) return 1;\n  else return 0;\n}\n\nint cal(queue<char> quc, int p, int q, int r){\n  stack<int> stc;\n  int a,b;\n  while(!quc.empty()){\n    char c = quc.front();\n    quc.pop();\n    switch(c){\n      case '0':\n      case '1':\n      case '2':\n        stc.push(c-'0');\n        break;\n      case 'P':\n        stc.push(p);\n        break;\n      case 'Q':\n        stc.push(q);\n        break;\n      case 'R':\n        stc.push(r);\n        break;\n      case '+':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lOr(a,b));\n        break;\n      case '*':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lAnd(a,b));\n        break;\n      case '-':\n        a = stc.top(); stc.pop();      \n        stc.push(lNot(a));\n        break;\n    }\n  }\n  return stc.top();\n}\n\nint main(void){\n  string d = \"\";\n  int ans;\n  while(true){\n    cin >> d;\n    if(d == \".\") break;\n    d = regex_replace(d, std::regex(\"(--)\"), \"\");\n    \n    queue<char> t = convert(d);\n    ans = 0;\n    for(int i=0;i<=2;i++){\n      for(int j=0;j<=2;j++){\n        for(int k=0;k<=2;k++){\n          if(cal(t,i,j,k) == 2) ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n\n    // queue<char> t = convert(d);\n    // while(!t.empty()){\n    //   cout << t.front();\n    //   t.pop();\n    // }\n    // cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State&);\nint factor(State&);\nint formula(State&);\n\nint number(State &begin) {\n  ll ret = *begin - '0';\n  begin++;\n  return ret;\n}\n\nint factor(State &begin) {\n  //DEBUG(*begin);\n  begin++; // '('を飛ばす。\n  ll ret = formula(begin);\n  if (*begin == '*') {\n    begin++;\n    ll ret2 = formula(begin);\n    begin++;\n    return min(ret, ret2);\n  }\n  else if (*begin == '+') {\n    begin++;\n    ll ret2 = formula(begin);\n    begin++;\n    return max(ret, ret2);\n  }\n}\n\n\nint formula(State &begin) {\n  //DEBUG(*begin);\n  for (;;) {\n    if (isdigit(*begin)) {\n      return number(begin);\n    }\n    else if (*begin == '-') {\n      begin++;\n      int ret = formula(begin);\n      return 2 - ret;\n    }\n    else if (*begin == '(') {\n      return factor(begin);\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    string s;\n    cin >> s;\n    if (s == \".\") return 0;\n    int ans = 0;\n    rep (p, 3) rep (q, 3) rep (r, 3) {\n      string t = s;\n      rep (i, t.size()) {\n        if (t[i] == 'P') t[i] = p + '0';\n        if (t[i] == 'Q') t[i] = q + '0';\n        if (t[i] == 'R') t[i] = r + '0';\n      }\n      //DEBUG(t);\n      State begin = t.begin();\n      int ret = formula(begin);\n      if (ret == 2) ans++;\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(')exit(1);\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r-0 == 0)res = '0';\n\t\telse res = 1;\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n\n//構文を実際に計算する\nbool play(string s) {\n\t//cout << s << endl;\n\n\tstack<char> info;\n\tfor (char c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(string formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\t//cout << \"pqr:: \" << p << q << r << endl;\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nint p, q, r;\n\nint single(int x) {\n    if(x == 0) return 2;\n    else if(x == 1) return 1;\n    else return 0;\n}\n\nint sekiXY(int x, int y) {\n    return min(x, y);\n}\n\nint waXY(int x, int y) {\n    return max(x, y);\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    // エラー検出\n    void consume(State &begin, char expected) {\n        if(*begin == expected) begin++;\n        else {\n            cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n            cerr << \"Rest string is '\";\n            while(*begin) {\n                cerr << *begin++;\n            }\n            cerr << \"'\" << endl;\n            throw ParseError();\n        }\n    }\n\n    // 数字の列をパースして、その数を返す\n    int number(State &begin) {\n        int ret = 0;\n        if(*begin == 'P') ret = p;\n        else if(*begin == 'Q') ret = q;\n        else if(*begin == 'R') ret = r;\n        else if(isdigit(*begin)) ret = *begin - '0';\n        else return 0;\n        \n        begin++;\n        return ret;\n    }\n\n    // 括弧か数をパースして、その評価結果を返す\n    int factor(State &begin) {\n        if(*begin == '(') {\n            consume(begin, '(');    // '('を飛ばす\n            int ret = expression(begin);\n            consume(begin, ')');    // ')'を飛ばす\n            return ret;\n        }else return number(begin);\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    int term(State &begin) {\n        if(*begin == '-') {\n            consume(begin, '-');\n            return single(term(begin));\n        }else return factor(begin);\n    }\n\n    // 四則演算の式をパースして、その評価結果を返す\n    int expression(State &begin) {\n        int ret = term(begin);\n        while(1) {\n            if(*begin == '+') {\n                consume(begin, '+');\n                ret = waXY(ret, term(begin));\n            }else if(*begin == '*') {\n                consume(begin, '*');\n                ret = sekiXY(ret, term(begin));\n            }else break;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    while(1) {\n        string s; getline(cin, s);\n        if(s.at(0) == '.') break;\n        int cnt = 0;\n        for(p = 0; p < 3; ++p) {\n            for(q = 0; q < 3; ++q) {\n                for(r = 0; r < 3; ++r) {\n                    Parser ps;\n                    State begin = s.begin();\n                    if(ps.expression(begin) == 2) cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint countMinus(State&);\nint negative(int,int);\nint number(State&);\nint factor(State&);\nint expression(State&);\n\nint p, q, r;\n\nint inverted(int ret){\n    if(ret == 0) return 2;\n    else if(ret == 2) return 0;\n    else return 1;\n}\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n    if(*begin == 'P') ret = p;\n    else if(*begin == 'Q') ret = q;\n    else if(*begin == 'R') ret = r;\n    else if(isdigit(*begin)) ret = *begin - '0';\n    else return 0;\n\n    begin++;\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    int ret;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    }else {\n        return number(begin);\n    }\n}\n\nint term(State &begin){\n    if (*begin == '-') {\n        begin++;\n        return inverted(term(begin));\n    } else {\n        return factor(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret = max(ret, term(begin));\n        } else if (*begin == '*') {\n            begin++;\n            ret = min(ret, term(begin));\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    string s;\n    while(cin >> s, s[0] != '.'){\n        int cnt = 0;\n        for(p = 0; p < 3; p++){\n            for(q = 0; q < 3; q++){\n                for(r = 0; r < 3; r++){\n                    State tmp = s.begin();\n                    if(expression(tmp) == 2){\n                        //cout << p << ' ' << q << ' ' << r << endl;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tif (T[pos] == '0') { pos++; return 0; }\n\tif (T[pos] == '1') { pos++; return 1; }\n\tif (T[pos] == '2') { pos++; return 2; }\n\tif (T[pos] == '-') { pos++; return 2 - solve(); }\n\tif (T[pos] == '(') {\n\t\tpos++; int a = solve(); char c = T[pos];\n\t\tpos++; int b = solve();\n\t\tif (c == '+') return max(a, b);\n\t\tif (c == '*') return min(a, b);\n\t}\n\treturn 0;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tint cnt=0,f;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tV.PB(mt);\n\t\t}\n\t}\n\tif(f==0)return (char)(_and[V[0]][V[1]]+'0');\n\telse return (char)(_or[V[0]][V[1]]+'0');\n}\nint rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\treturn (s[0]-'0');\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tint res=rec(s,i,j,k);\n\t\t\tif(res==2)cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long Int;\ntypedef string::const_iterator Itr;\n\nint P, Q, R;\n\nint expression(Itr &itr);\nint term(Itr &itr);\nint factor(Itr &itr);\nint letter(Itr &itr);\n\nint not(int n)\n{\n\tif (n == 0)return 2;\n\telse if (n == 1)return 1;\n\telse return 0;\n}\n\nint star(int x, int y)\n{\n\tif (x == 0 || y == 0)return 0;\n\telse if (x == 1 || y == 1)return 1;\n\telse return 2;\n}\n\nint _plus(int x, int y)\n{\n\tif (x == 0 && y == 0)return 0;\n\telse if (x == 2 || y == 2)return 2;\n\telse return 1;\n}\n\nint expression(Itr &itr) \n{\n\tint ret = term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '*')\n\t\t{\n\t\t\titr++;\n\t\t\tret = star(ret, term(itr));\n\n\t\t}\n\t\telse if (*itr == '+')\n\t\t{\n\t\t\titr++;\n\t\t\tret = _plus(ret, term(itr));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(Itr &itr)\n{\n\tint ret;\n\n\tif (*itr == '-')\n\t{\n\t\titr++;\n\t\tret = not(term(itr));\n\t}\n\telse\n\t{\n\t\tret = factor(itr);\n\t}\n\n\treturn ret;\n}\n\nint factor(Itr &itr)\n{\n\tint ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = letter(itr);\n\t}\n\n\treturn ret;\n}\n\nint letter(Itr &itr)\n{\n\tint ret = 0;\n\n\tif (*itr == 'P')\n\t{\n\t\tret = P;\n\t}\n\telse if (*itr == 'Q')\n\t{\n\t\tret = Q;\n\t}\n\telse if (*itr == 'R')\n\t{\n\t\tret = R;\n\t}\n\telse if(isdigit(*itr))\n\t{\n\t\tret = *itr - '0';\n\t}\n\titr++;\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tif (str[0] == '.')break;\n\t\tstr.append(\"_\");\n\t\tint count = 0;\n\t\tREP(i, 3)REP(j, 3)REP(k, 3)\n\t\t{\n\t\t\tP = i;\n\t\t\tQ = j;\n\t\t\tR = k;\n\t\t\tItr begin = str.begin();\n\t\t\tint ans = expression(begin);\n\t\t\tif (ans == 2)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tif(s.size()==1)return s[0];\n\tint cnt=0,f,now=-1;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tif(now==-1)now=mt;\n\t\t\telse{\n\t\t\t\tif(f==0)now=_and[now][mt];\n\t\t\t\telse now=_or[now][mt];\n\t\t\t}\n\t\t}\n\t}\n\treturn now+'0';\n}\nchar rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\tchar tt=pyon(s,p,q,r);\n\treturn tt;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tif(rec(s,i,j,k)=='2')cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tswitch (T[pos++]) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return 2 - solve();\n\t\tcase '(':\n\t\t\tint a = solve();\n\t\t\tswitch (T[pos++]) {\n\t\t\t\tcase '+': return min(a, solve());\n\t\t\t\tcase '*': return max(a, solve());\n\t\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint table[3];\n\nstring s;\nint p;\n\ninline int opnot(int x) {\n    return 2-x;\n}\n\ninline int opand(int x, int y) {\n    if (x == 0 || y == 0) return 0;\n    if (x == 1 || y == 1) return 1;\n    return 2;\n}\n\ninline int opor(int x, int y) {\n    if (x == 2 || y == 2) return 2;\n    if (x == 1 || y == 1) return 1;\n    return 0;\n}\n\nint formula() {\n    switch (s[p]) {\n        case '0': case '1': case '2':\n            return s[p++] - '0';\n            break;\n        case 'P': case 'Q': case 'R':\n            return table[s[p++] - 'P'];\n            break;\n        case '-':\n            p++;\n            return opnot(formula());\n            break;\n        case '(':\n            p++;\n            int a = formula();\n            if (s[p] == '*') {\n                p++; // for '*'\n                int res = opand(a, formula());\n                p++; // for ')'\n                return res;\n            } else {\n                p++; // for '+'\n                int res = opor(a, formula());\n                p++; // for ')'\n                return res;\n            }\n            break;\n    }\n}\n\nint main() {\n    while (getline(cin, s)) {\n        if (s == \".\") break;\n        int cnt = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    table[0] = i;\n                    table[1] = j;\n                    table[2] = k;\n                    p = 0;\n                    if (formula() == 2) cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nstring inv(string s) {\n\tif(s==\"2\") return \"0\";\n\tif(s==\"1\") return \"1\";\n\tif(s==\"0\") return \"2\";\n}\n\nstring mult(string a, string b) {\n\tif(a[0] < b[0]) {\n\t\treturn a;\n\t} else {\n\t\treturn b;\n\t}\n}\n\nstring add(string a, string b) {\n\tif(a[0] < b[0]) {\n\t\treturn b;\n\t} else {\n\t\treturn a;\n\t}\n}\n\nstring form(string s) {\n\tif(s.length()==1) {\n\t\treturn s;\n\t}\n\tif(s[0]=='-') {\n\t\treturn inv( form(s.substr(1)) );\n\t}\n\tif(s[0]=='(') {\n\t\tint enc = 0;\n\t\tfor(int i=1; i<s.length(); i++) {\n\t\t\tif(s[i] == '(') {\n\t\t\t\tenc++;\n\t\t\t}\n\t\t\telse if(s[i] == ')') {\n\t\t\t\tenc--;\n\t\t\t}\n\t\t\telse if(enc==0 && s[i] == '*') {\n\t\t\t\tstring a = form( s.substr(1,i-1) );\n\t\t\t\tstring b = form( s.substr(i+1, s.length()-1-i-1) );\n\t\t\t\treturn mult(a, b);\n\t\t\t}\n\t\t\telse if(enc==0 && s[i] == '+') {\n\t\t\t\tstring a = form( s.substr(1,i-1) );\n\t\t\t\tstring b = form( s.substr(i+1, s.length()-1-i-1) );\n\t\t\t\treturn add(a, b);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tstring in;\n\twhile(cin >> in, in!=\".\") {\n\t\tint cnt = 0;\n\t\trep(p,3) rep(q,3) rep(r,3) {\n\t\t\tstring s = in;\n\t\t\trep(i,s.length()) {\n\t\t\t\tif(s[i] == 'P') {\n\t\t\t\t\ts[i] = p+'0';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'Q') {\n\t\t\t\t\ts[i] = q+'0';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'R') {\n\t\t\t\t\ts[i] = r+'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring ss = form(s);\n\t\t\tif( ss == \"2\" ) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str;\nint pos;\nint P, Q, R;\n\nint formula() {\n\tint res = -1;\n\tif (str[pos] == '-') {\n\t\t++pos;\n\t\tint a = formula();\n\t\tres = 2 - a;\n\t}\n\telse if (str[pos] == '(') {\n\t\t++pos;\n\t\tint a = formula();\n\t\tchar c = str[pos];\n\t\t++pos;\n\t\tint b = formula();\n\t\t++pos;\n\n\t\tif (c == '*') {\n\t\t\tres = min(a, b);\n\t\t}\n\t\telse {\n\t\t\tres = max(a, b);\n\t\t}\n\t}\n\telse if (str[pos] == 'P') {\n\t\tres = P;\n\t\t++pos;\n\t}\n\telse if (str[pos] == 'Q') {\n\t\tres = Q;\n\t\t++pos;\n\t}\n\telse if (str[pos] == 'R') {\n\t\tres = R;\n\t\t++pos;\n\t}\n\telse if (isdigit(str[pos])) {\n\t\tres = str[pos] - '0';\n\t\t++pos;\n\t}\n\telse {\n\t\tassert(false);\n\t}\n\treturn res;\n}\n\nint parse(string s) {\n\tstr = s;\n\tpos = 0;\n\treturn formula();\n}\n\nint main() {\n\tstring s;\n\twhile ( cin >> s, s != \".\" ) {\n\t\tint ans = 0;\n\t\tfor (int p = 0; p < 3; ++p) for (int q = 0; q < 3; ++q) for (int r = 0; r < 3; ++r) {\n\t\t\tP = p, Q = q, R = r;\n\t\t\tif ( parse(s) == 2 ) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint idx = 0;\n\nint factor(const string &s)\n{\n    int ret = 0;\n    if ('0' <= s[idx] && s[idx] <= '2')\n    {\n        ret = s[idx] - '0';\n    }\n    else\n    {\n    }\n    idx++;\n    return ret;\n}\n\nint formula(const string &s)\n{\n    if (s[idx] == '-')\n    {\n        idx++;\n        return 2 - formula(s);\n    }\n    else if (s[idx] == '(')\n    {\n        idx++;\n        int ret = formula(s);\n        if (s[idx] == '*')\n        {\n            idx++;\n            ret = min(ret, formula(s));\n        }\n        else if (s[idx] == '+')\n        {\n            idx++;\n            ret = max(ret, formula(s));\n        }\n        idx++; // ')'\n        return ret;\n    }\n    else\n    {\n        return factor(s);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s;\n    vector<char> c = {'0', '1', '2'};\n    while (cin >> s, s != \".\")\n    {\n        int res = 0, n = s.length();\n        for (int p = 0; p < 3; p++)\n        {\n            for (int q = 0; q < 3; q++)\n            {\n                for (int r = 0; r < 3; r++)\n                {\n                    string t = s;\n                    for (int i = 0; i < n; i++)\n                    {\n                        if (t[i] == 'P')\n                            t[i] = c[p];\n                        if (t[i] == 'Q')\n                            t[i] = c[q];\n                        if (t[i] == 'R')\n                            t[i] = c[r];\n                    }\n                    idx = 0;\n                    if (formula(t) == 2)\n                        res++;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// 'P', 'Q', 'R' ツづー '1', '2', '3'ツづ可置ツつォツ環キツつヲツづゥ\nvoid PQR_change(string& s ,char p , char q , char r ){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == 'P' ) s[i] = p;\n\t\tif( s[i] == 'Q' ) s[i] = q;\n\t\tif( s[i] == 'R' ) s[i] = r;\n\t}\n}\n\n// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\"ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_erace(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '-' && s[i-1] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\n// \"-0\", \"-1\", \"-2\" ツづー \"2\", \"1\", \"0\" ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_calc(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' ){\n\t\t\tif( s[i] == '0' ){\n\t\t\t\ts.replace( i-1 , 2 , \"2\" );\n\t\t\t}else if( s[i] == '1' ){\n\t\t\t\ts.replace( i-1 , 2 , \"1\" );\n\t\t\t}else if( s[i] == '2' ){\n\t\t\t\ts.replace( i-1 , 2 , \"0\" );\n\t\t\t}\n\t\t\ti = 1;\n\t\t}\n\t}\n}\n\n// \"(0+0)\", \"(0+1)\", ... , \"(2+2)\" ツづー \"0\", \"1\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ) \nvoid plus_calc(string& s){\n\tstring ex[9] = {\n\t\t\"(0+0)\", \"(0+1)\", \"(0+2)\",\n\t\t\"(1+0)\", \"(1+1)\", \"(1+2)\",\n\t\t\"(2+0)\", \"(2+1)\", \"(2+2)\"\n\t};\n\tstring result[9] = {\n\t\t\"0\", \"1\", \"2\",\n\t\t\"1\", \"1\", \"2\",\n\t\t\"2\", \"2\", \"2\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 9 ; j++ ){\n\t\t\tif( s.substr( i , 5 ) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// \"(0*0)\", \"(0*1)\", ... , \"(2*2)\" ツづー \"0\", \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ) \nvoid mult_calc(string& s){\n\tstring ex[9] = {\n\t\t\"(0*0)\", \"(0*1)\", \"(0*2)\",\n\t\t\"(1*0)\", \"(1*1)\", \"(1*2)\",\n\t\t\"(2*0)\", \"(2*1)\", \"(2*2)\"\n\t};\n\tstring result[9] = {\n\t\t\"0\", \"0\", \"0\",\n\t\t\"0\", \"1\", \"1\",\n\t\t\"0\", \"1\", \"2\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 9 ; j++ ){\n\t\t\tif( s.substr( i , 5 ) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile( cin >> s , s != \".\" ){\n\t\tint ans = 0;\n\t\tfor(char p = '0' ; p <= '2' ; p++ ){\n\t\t\tfor(char q = '0' ; q <= '2' ; q++ ){\n\t\t\t\tfor(char r = '0' ; r <= '2' ; r++ ){\n\t\t\t\t\tstring s_ = s;\n\t\t\t\t\t// 'P', 'Q', 'R' ツづー '1', '2', '3'ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tPQR_change( s_ , p , q , r );\n\t\t\t\t\t// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\"ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tminus_erace( s_ );\n\t\t\t\t\t// \"-0\", \"-1\", \"-2\" ツづー \"2\", \"1\", \"0\" ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tminus_calc( s_ );\n\t\t\t\t\t\n\t\t\t\t\t// \"0\", \"1\", \"2\" ツづ個値ツづ可づ按づゥツづ慊づ繰ツづィツ陛板つオツ嘉算ツづ湘ヲツ算ツづーツ計ツ算ツつキツづゥ\n\t\t\t\t\twhile( s_.size() != 1 ){\n\t\t\t\t\t\t// \"(0+0)\", ... , \"(2+2)\" ツづー \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ)\n\t\t\t\t\t\tplus_calc( s_ );\n\t\t\t\t\t\t// \"(0*0)\", ... , \"(2*2)\" ツづー \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ) \n\t\t\t\t\t\tmult_calc( s_ );\n\t\t\t\t\t}\n\t\t\t\t\tif( s_ == \"2\" ){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nint pqr[3];\nchar *pt;\nint parse() {\n  int ret;\n  if('0' <= *pt && *pt <= '2') {\n    ret = *pt-'0';\n    pt++;\n  } else if('P' <= *pt && *pt <= 'R') {\n    ret = pqr[*pt-'P'];\n    pt++;\n  } else if('-' == *pt) {\n    pt++;\n    ret = 2-parse();\n  } else if('(') {\n    pt++;\n    int x = parse();\n    char op = *pt; pt++;\n    int y = parse();\n    if(op == '*') {\n      ret = min(x,y);\n    } else if(op == '+') {\n      ret = max(x,y);\n    } else assert(false);\n    assert(*pt==')');\n    pt++;\n  } else assert(false);\n  return ret;\n}\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    char pr[100]; scanf(\" %s\", pr);\n    if(*pr=='.') break;\n    int cnt=0;\n    for(pqr[0]=0;pqr[0]<3;pqr[0]++)\n      for(pqr[1]=0;pqr[1]<3;pqr[1]++)\n        for(pqr[2]=0;pqr[2]<3;pqr[2]++) {\n          pt=pr;\n          if(parse()==2)cnt++;\n        }\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring repr(string s,int p,int q,int r){\n  int tmp;\n  string s_tmp=s;\n  while ((tmp = s_tmp.find(\"P\")) >= 0){s_tmp.replace(s_tmp.find(\"P\"),1,to_string(p));}\n  while ((tmp = s_tmp.find(\"Q\")) >= 0){s_tmp.replace(s_tmp.find(\"Q\"),1,to_string(q));}\n  while ((tmp = s_tmp.find(\"R\")) >= 0){s_tmp.replace(s_tmp.find(\"R\"),1,to_string(r));}\n  return s_tmp;\n}\n\nstring op_plus(string left,string right){\n  int l,r;\n  if (left[0]=='-'){l=2-(left[1]-'0');}\n  else {l=left[0]-'0';}\n  if (right[0]=='-'){r=2-(right[1]-'0');}\n  else {r=right[0]-'0';}\n  return to_string(max(l,r));\n}\n\nstring times(string left,string right){\n  int l,r;\n  if (left[0]=='-'){l=2-(left[1]-'0');}\n  else {l=left[0]-'0';}\n  if (right[0]=='-'){r=2-(right[1]-'0');}\n  else {r=right[0]-'0';}\n  return to_string(min(l,r));\n}\n\nstring solve(string str){\n  while (str.substr(0,2) == \"--\"){str.erase(str.begin(),str.begin()+2);}\n  if (str.length() == 1||str.length() == 2){\n    if (str == \"0\"){\n      return \"0\";\n    } else if (str == \"1\"){\n      return \"1\";\n    } else if (str == \"2\"){\n      return \"2\";\n    } else if (str == \"-0\"){\n      return \"2\";\n    } else if (str == \"-1\"){\n      return \"1\";\n    } else if (str == \"-2\"){\n      return \"0\";\n    } else {\n      cout << str << \" :Error\" << endl;\n      return \"-1\";\n    }\n  }\n  if (str[0] == '(') {\n    str.erase(str.begin());\n    str.pop_back();\n  }\n  int brcount = 0;\n  int ind = 0;\n  while (ind < str.length()){\n    if (str[ind] == '('){++brcount;}\n    if (str[ind] == ')'){--brcount;}\n    if ((brcount == 0)&&(str[ind] == '+' || str[ind] == '*')) break;\n    ++ind;\n  }\n  if (ind == str.length()){\n    return to_string(2-(solve(str.substr(1,str.length()-1))[0]-'0'));\n  }\n  string left,right;\n  cout << str.substr(0,ind) << endl;\n  cout << str.substr(ind+1,str.length()-(ind+1)) << endl;\n  left = solve(str.substr(0,ind));\n  right = solve(str.substr(ind+1,str.length()-(ind+1)));\n  if (str[ind] == '+'){\n    return op_plus(left,right);\n  }\n  if (str[ind] == '*'){\n    return times(left,right);\n  }\n}\n\nint main(){\n  string s,s_tmp;\n  int sum;\n  while (1){\n    cin >> s;\n    if (s == \".\") {\n      break;\n    }\n    sum = 0;\n    for (int p=0;p<3;p++){\n      for (int q=0;q<3;q++){\n        for (int r=0;r<3;r++){\n          s_tmp = repr(s,p,q,r);\n          if (solve(s_tmp) == \"2\" ){++sum;}\n        }\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n#define RSORT(c) sort((c).rbegin(), (c).rend())\n#define CLR(a) memset((a), 0, sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstring expr;\nint idx;\nint p, q, r;\n\nint form();\n\nint paren() {\n    int left = form();\n    char op = expr[idx++];\n    int right = form();\n    idx++; // ')'\n\n    if (left == right) {\n        return left;\n    }\n    if (op == '+') {\n        return (left + right >= 2) ? 2 : 1;\n    } else {\n        return (left * right > 0) ? 1 : 0;\n    }\n}\n\nint form() {\n    char c = expr[idx++];\n    switch (c) {\n    case '0':\n    case '1':\n    case '2':\n        return c - '0';\n    case 'P': return p;\n    case 'Q': return q;\n    case 'R': return r;\n    case '-':\n        return 2 - form();\n    case '(':\n        return paren();\n    }\n}\n\nint main() {\n    while (cin >> expr, expr != \".\") {\n        int cnt = 0;\n        REP(i, 27) {\n            idx = 0;\n            int w = i;\n            p = w % 3; w /= 3;\n            q = w % 3; w /= 3;\n            r = w % 3; w /= 3;\n            int n = form();\n            if (n == 2) cnt++;\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\nint p,q,r;\n\nint minus_(int a){\n    if(a == 0) return 2;\n    else if(a == 2) return 0;\n    else return 1;\n}\n\nint multiply(int a, int b){ return a & b; }\nint plus_(int a, int b){\n    if((a == 1 && b == 2) || (a == 2 && b == 1)) return 2;\n    return a | b;\n}\n\nint solve(const string& f){\n    stack<char> c;\n    stack<int> si;\n\n    for(int i = 0; i < f.size(); ++i){\n        if('0' <= f[i] && f[i] <= '2') si.push(f[i] - '0');\n        else if(f[i] == 'P') si.push(p);\n        else if(f[i] == 'Q') si.push(q);\n        else if(f[i] == 'R') si.push(r);\n        else if(f[i] == '-'){\n            i++;\n            if('0' <= f[i] && f[i] <= '2') si.push(minus_(f[i] - '0'));\n            else if(f[i] == 'P') si.push(minus_(p));\n            else if(f[i] == 'Q') si.push(minus_(q));\n            else if(f[i] == 'R') si.push(minus_(r));\n        }else if(f[i] == ')'){\n            int a = si.top();\n            si.pop();\n            int b = si.top();\n            si.pop();\n            char ope = c.top();\n            c.pop();\n            c.pop();\n            if(ope == '*') si.push(multiply(a, b));\n            else si.push(plus_(a, b));\n        }else{ c.push(f[i]); }\n    }\n\n    return si.top();\n}\n\nint main(){\n    string f;\n    while(true){\n        cin >> f;\n        if(f == \".\") break;\n\n        int ans = 0;\n        for(p = 0; p <= 2; ++p){\n            for(q = 0; q <= 2; ++q){\n                for(r = 0; r <= 2; ++r){\n                    if(solve(f) == 2){\n                        ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nstring in;\nint pos;\nint p,q,r;\n\nint formula(){\n  if(isdigit(in[pos])){\n    return in[pos++]-'0';\n  }\n\n  switch(in[pos]){\n  case 'P':++pos; return p;\n  case 'Q':++pos; return q;\n  case 'R':++pos; return r;\n  }\n\n  if(in[pos]=='-'){\n    ++pos;\n    return 2-formula();\n  }\n  ++pos;\n  int a=formula();\n  char cc=in[pos++];\n  int b=formula();\n  pos++;\n  if(cc=='+'){\n    if(a==2 || b==2)return 2;\n    if(!a && !b)return 0;\n    return 1;\n  }\n  if(!a || !b)return 0;\n  if(a==2 && b==2)return 2;\n  return 1;\n}\n\n\nmain(){\n  while(cin>>in){\n    if(in==\".\")break;\n    int ans=0;\n    for(p=0;p<3;p++)for(q=0;q<3;q++)for(r=0;r<3;r++){\n      pos=0;\n      if(formula()==2)++ans;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint bit(int C1,bool C2);\nint minus(int C3);\nint kake(int C4,int C5);\nint plus(int C6,int C7);\nstring tstring(int C8);\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[MAX_N];\n\nint bit(int C1,bool C2){\n\tif(C2==true){return C1;}\n\treturn minus(C1);\n}\n\nint minus(int C3){\n\treturn 2-C3;\n}\nint plus(int C4,int C5){\n\treturn max(C4,C5);\n}\nint kake(int C6,int C7){\n\treturn max(C6,C7);\n}\n\nstring tstring(int C8)\n{\n\tif(C8==0)\n\t{\n\t\treturn \"0\";\n\t}\n\tif(C8==1)\n\t{\n\t\treturn \"1\";\n\t}\n\treturn \"2\";\n}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\tif(ok==false){ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return plus(ans,ans2);}\n\treturn kake(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=tstring((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tsum=0;\n\t\tif(S==\".\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nchar not_k(char a) {\n\tif (a == '0') {\n\t\treturn '2';\n\t} else if(a == '2') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar seki(char a, char b) {\n\tif (a == b) {\n\t\treturn a;\n\t} else if (a == '0' || b == '0') {\n\t\treturn '0';\n\t} else if (a == '1' || b == '1') {\n\t\treturn '1';\n\t} else {\n\t\treturn '2';\n\t}\n}\n\nchar wa(char a, char b) {\n\tif (a == b) {\n\t\treturn a;\n\t} else if (a == '2' || b == '2') {\n\t\treturn '2';\n\t} else if (a == '1' || b == '1') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nbool kaiseki(string a) {\n\tstack<char> stk1, stk2;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == '0' || a[i] == '1' || a[i] == '2') {\n\t\t\tchar b = a[i];\n\t\t\tif (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\tstk1.pop();\n\t\t\t\tb = not_k(b);\n\t\t\t}\n\t\t\tstk2.push(b);\n\t\t} else if (a[i] == '-') {\n\t\t\tif (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\tstk1.pop();\n\t\t\t} else {\n\t\t\t\tstk1.push(a[i]);\n\t\t\t}\n\t\t} else if (a[i] == ')') {\n\t\t\tchar p = stk2.top();\n\t\t\tstk2.pop();\n\t\t\tchar q = stk2.top();\n\t\t\tstk2.pop();\n\t\t\tchar r = stk1.top();\n\t\t\tstk1.pop();\n\t\t\tif (r == '+') {\n\t\t\t\tp = wa(p, q);\n\t\t\t} else {\n\t\t\t\tp = seki(p, q);\n\t\t\t}\n\t\t\tstk1.pop();\n\t\t\tif (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\tstk1.pop();\n\t\t\t\tp = not_k(p);\n\t\t\t}\n\t\t\tstk2.push(p);\n\t\t} else {\n\t\t\tstk1.push(a[i]);\n\t\t}\n\t}\n\tchar k = stk2.top();\n\tstk2.pop();\n\tif (!stk1.empty() && stk1.top() == '-') {\n\t\tstk1.pop();\n\t\tk = not_k(k);\n\t}\n\treturn k == '2';\n}\n\nint main() {\n\tstring a;\n\tstring abc = \"012\";\n\twhile (cin >> a) {\n\t\tif (a == \".\") {\n\t\t\tbreak;\n\t\t}\n\t\tint counter = 0;\n\t\tstring b;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tb = a;\n\t\t\twhile (b.find('P') != string::npos) {\n\t\t\t\tb[b.find('P')] = abc[i];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\twhile (b.find('Q') != string::npos) {\n\t\t\t\t\tb[b.find('Q')] = abc[j];\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\twhile (b.find('R') != string::npos) {\n\t\t\t\t\t\tb[b.find('R')] = abc[k];\n\t\t\t\t\t}\n\t\t\t\t\tif (kaiseki(b)) {\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tb = a;\n\t\t\t\t\twhile (b.find('P') != string::npos) {\n\t\t\t\t\t\tb[b.find('P')] = abc[i];\n\t\t\t\t\t}\n\t\t\t\t\twhile (b.find('Q') != string::npos) {\n\t\t\t\t\t\tb[b.find('Q')] = abc[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = a;\n\t\t\t\twhile (b.find('P') != string::npos) {\n\t\t\t\t\tb[b.find('P')] = abc[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint mul(int X,int Y){\n  if(X == 0 || Y == 0)return 0;\n  if(X == 1 || Y == 1)return 1;\n  if(X == 2 && Y == 2)return Y;\n  assert(false);\n}\n\nint add(int X,int Y){\n  if(X == 0)return Y;\n  if(X == 1 && (Y == 0 || Y == 1))return 1;\n  if(X == 1 && Y == 2)return 2; \n  if(X == 2)return 2;\n  assert(false);\n}\n\nint sub(int X){\n  //cout << \"X = \"<< X << endl;\n  if(X == 0)return 2;\n  if(X == 1)return 1;\n  if(X == 2)return 0;\n  assert(false);\n}\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }\n    else if(parse[pos] == '-'){\n      int p = 0;     \n      int cnt=0;\n      while(parse[pos] == '-'){      \n\tcnt++,pos++;\n      }\n      //cout << \"now parse = \" << parse[pos] << endl;\n      //p = parse[pos]-'0';\n      //pos++;\n      p = fact();\n      //cout << \"exp = \" << p << endl;\n      //pos++;\n      rep(i,cnt){\n\tp = sub(p);\t\n      }    \n      //cout << \" - IN!!! p = \" << p << endl;  \n      return p;\n      \n    }else{\n     \n      int p = 0;\n     \n      while('0' <= parse[pos] && parse[pos] <= '2'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n  int term(){\n    int p = fact();\n    return p;\n  }\n\n\n  int expression(){\n    int p = term();\n    //cout << \"X = \"<< p << endl;\n    while(parse[pos] == '+' || parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \" <<q << endl;\n\tp = mul(p,q);\n      }\n      else if(parse[pos] == '+'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \"<< q << endl;\n\tp = add(p,q);\n      }\n    }\n    return p;\n  }\n\n\n};\n\nint ans,last;\nstring s;\n\nvoid draw(char P,char Q,char R){\n  string pre = s;\n  rep(i,s.length()){\n    if(s[i] == 'P')s[i] = P;\n    else if(s[i] == 'Q')s[i] = Q;\n    else if(s[i] == 'R')s[i] = R;\n  }\n  Parsing par = Parsing(s);\n  int res = par.expression();\n  assert(res == 0 || res == 1 || res == 2);\n  if(res == 2)ans++;  \n  s = pre;\n}\n\nvoid test(){\n\n  for(char i='0';i<='2';i++){// P\n    for(char j='0';j<='2';j++){// Q\n      for(char k='0';k<='2';k++){// R\n\tdraw(i,j,k);\n      }\n    }\n  }\n\n\n}\n\n\nint main(){\n  while(true){\n    cin >> s;\n    //Parsing par = Parsing(s);\n    //cout <<par.expression() << endl;\n    //return 0;\n    if(s == \".\")break;\n    ans = 0;  \n    test();\n    cout << ans << endl;\n  }\nreturn 0;\n}\n\n\n\n\n\n\n\n\n// ika gomi bako"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[10000];\n\nint bit(int c,bool d){\n\tif(d==true){return c;}\n\treturn minus(c);\n}\nint minus(int c){return 2-c;}\nint plus(int c,int d){return max(c,d);}\nint kake(int c,int d){return max(c,d);}\n\nstring tstring(int c)\n{\n\tif(c==0)\n\t{\n\t\treturn \"0\";\n\t}\n\tif(c==1)\n\t{\n\t\treturn \"1\";\n\t}\n\treturn \"2\";\n}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\tif(ok==false){ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return plus(ans,ans2);}\n\treturn kake(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=tstring((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tsum=0;\n\t\tif(S==\".\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring str, s;\nint pos;\n\nvoid a() {\n  for(int i = 0; i < str.length(); ++i) {\n    if(str[i] != '-') continue;\n    int j;\n    for(j = i+1; j < str.length() && str[j] == '-'; ++j);\n    if(j == i+1) continue;\n    if((j-i) % 2 == 0)\n      str = str.substr(0, i) + str.substr(j);\n    else\n      str = str.substr(0, i+1) + str.substr(j);\n  }\n}\n\nint exp();\n\nint factor2() {\n  int x;\n  if(s[pos] == '(') {\n    ++pos;\n    x = exp();\n    ++pos;\n  } else {\n    x = s[pos++] - '0';\n  }\n  return x;\n}\n\nint factor() {\n  int x;\n  if(s[pos] == '-') {\n    ++pos;\n    x = 2-factor();\n  } else {\n    x = factor2();\n  }\n  return x;\n}\n\nint term() {\n  int x = factor();\n  while(s[pos] == '*') {\n    ++pos;\n    x = min(x, factor());\n  }\n  return x;\n}\n\nint exp() {\n  int x = term();\n  while(s[pos] == '+') {\n    ++pos;\n    x = max(x, term());\n  }\n  return x;\n}\n\nint solve() {\n  int ans = 0;\n  //a();\n  for(char p = '0'; p <= '2'; ++p) {\n    for(char q = '0'; q <= '2'; ++q) {\n      for(char r = '0'; r <= '2'; ++r) {\n\ts = str;\n\tfor(int i = 0; i < s.length(); ++i) {\n\t  if(s[i] == 'P') s[i] = p;\n\t  if(s[i] == 'Q') s[i] = q;\n\t  if(s[i] == 'R') s[i] = r;\n\t}\n\tpos = 0;\n\tif(exp() == 2) ++ans;\n      }\n    }\n  }\n  return ans;\n}\n\nmain() {\n  while((cin >> str) && str != \".\") {\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-9;\n\nlong long int N, M, K, H, W, L, R;\n\nint Search(string &s, vector<int>& n, int p) {\n\tint ret = -1;\n\tbool minus = false;\n\tbool wa = false;\n\tbool seki = false;\n\tint depth = 1;\n\tfor (int i = p; i < s.size(); i++) {\n\t\tif (depth == 1) {\n\t\t\tif (s[i] == '-')minus ^= true;\n\t\t\telse if (s[i] == '*') seki ^= true;\n\t\t\telse if (s[i] == '+')wa ^= true;\n\t\t\telse if (s[i] == '(') {\n\t\t\t\tint box = Search(s, n, i + 1);\n\t\t\t\tif (ret == -1) {\n\t\t\t\t\tif (minus) {\n\t\t\t\t\t\tbox = 2 - box;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tret = box;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (minus) {\n\t\t\t\t\t\tbox = 2 - box;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (wa) {\n\t\t\t\t\t\tret = max(ret, box);\n\t\t\t\t\t\twa = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (seki) {\n\t\t\t\t\t\tret = min(ret, box);\n\t\t\t\t\t\tseki = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint box = n[s[i]];\n\t\t\t\tif (ret == -1) {\n\t\t\t\t\tif (minus) {\n\t\t\t\t\t\tbox = 2 - box;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tret = box;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (minus) {\n\t\t\t\t\t\tbox = 2 - box;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (wa) {\n\t\t\t\t\t\tret = max(ret, box);\n\t\t\t\t\t\twa = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (seki) {\n\t\t\t\t\t\tret = min(ret, box);\n\t\t\t\t\t\tseki = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (s[i] == ')')depth--;\n\t\tif (s[i] == '(')depth++;\n\t\tif (!depth)return ret;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tvector<int>ans;\n\tstring s;\n\tcin >> s;\n\tvector<int>num(256);\n\tnum['1'] = 1;\n\tnum['2'] = 2;\n\tnum['0'] = 0;\n\twhile (s!=\".\") {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tnum['P'] = i;\n\t\t\t\t\tnum['Q'] = j;\n\t\t\t\t\tnum['R'] = k;\n\t\t\t//\t\tcout << Search(s, num, 0);\n\t\t\t\t\tret += Search(s, num, 0) == 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(ret);\n\t\t//cout << endl;\n\t\tcin >> s;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    assert(true);\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp\nusing namespace std;\ntypedef long long ll;\n\nint to_digit(int& at, string& S, int P, int Q, int R) {\n\tint ret;\n\tif (S[at] == 'P') ret = P;\n\telse if (S[at] == 'Q') ret = Q;\n\telse if (S[at] == 'R') ret = R;\n\telse ret = S[at] - '0';\n\tat++;\n\treturn ret;\n}\nint dfs(int& at,string& S, int P, int Q, int R) {\n\tint ret;\n\tif (S[at] == '(') {\n\t\tat++;\n\t\tret = dfs(at, S, P, Q, R);\n\t\tif (S[at] == '*') {\n\t\t\tat++;\n\t\t\tret = min(ret, dfs(at, S, P, Q, R));\n\t\t}\n\t\telse if(S[at] == '+'){\n\t\t\tat++;\n\t\t\tret = max(ret, dfs(at, S, P, Q, R));\n\t\t}\n\n\t\t//')'?????????\n\t\tat++;\n\t\treturn ret;\n\t}\n\telse if (S[at] == '-') {\n\t\tat++;\n\t\tret = dfs(at, S, P, Q, R);\n\t\tif (ret == 0) ret = 2;\n\t\telse if (ret == 1) ret = 1;\n\t\telse if (ret == 2) ret = 0;\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn to_digit(at,S, P, Q, R);\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring S;\n\twhile (cin >> S) {\n\t\tif (S == \".\")break;\n\t\tint ans = 0;\n\t\tfor (int P = 0; P < 3; P++) {\n\t\t\tfor (int Q = 0; Q < 3;Q++) {\n\t\t\t\tfor (int R = 0; R < 3;R++) {\n\t\t\t\t\tint at = 0;\n\t\t\t\t\tif (dfs(at, S, P, Q, R) == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint mynot(int i){\n  return 2 - i;\n}\n\nint myand(int i, int j){\n  if(i == 2 && j == 2){return 2;}\n  if(i == 0 || j == 0){return 0;}\n  return 1;\n}\n\nint myor(int i, int j){\n  if(i == 0 && j == 0){return 0;}\n  if(i == 2 || j == 2){return 2;}\n  return 1;\n}\n\nint interp(int P, int Q, int R, char* formula){\n  char* snd;\n  int   lcnt = 0;\n  int   ptr  = 0;\n\n  switch(formula[0]){\n    case '0':\n      return 0;\n      break;\n    case '1':\n      return 1;\n      break;\n    case '2':\n      return 2;\n      break;\n    case 'P':\n      return P;\n      break;\n    case 'Q':\n      return Q;\n      break;\n    case 'R':\n      return R;\n      break;\n    case '-':\n      return mynot(interp(P, Q, R, formula + 1));\n      break;\n    case '(':\n      int left, right;\n      ptr++;\n\n        if(formula[ptr] == '('){\n          int cnt = 1; ptr++;\n          while(cnt != 0){\n            if( formula[ptr] == '(' ){cnt++;}\n            if( formula[ptr] == ')' ){cnt--;}\n            ptr++;\n          }\n        }else if(formula[ptr] == '-'){\n          while(formula[ptr] == '-'){ptr++;}\n          if(formula[ptr] == '('){\n            int cnt = 1; ptr++;\n            while(cnt != 0){\n              if( formula[ptr] == '(' ){cnt++;}\n              if( formula[ptr] == ')' ){cnt--;}\n              ptr++;\n            }\n          }\n        }else{\n          ptr++;\n        }\n\n      if(formula[ptr] == '*'){\n        left  = interp(P, Q, R, formula + 1);\n        right = interp(P, Q, R, formula + ptr + 1);\n        return myand(left, right);\n      }\n      if(formula[ptr] == '+'){\n        left  = interp(P,Q,R, formula + 1);\n        right = interp(P,Q,R, formula + ptr + 1);\n        return myor(left, right);\n      }\n    }\n}\n\n\nint main(void){\n  while(1){\n    char formula[80];\n    cin >> formula;\n    if(formula[0] == '.') return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < 3 ; i++){\n      for(int j = 0; j < 3 ; j++){\n        for(int k = 0; k < 3 ; k++){\n          if(interp(i,j,k,formula) == 2) cnt++;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint formula(char *);\nint min(int,int);\nint max(int,int);\n\nint p,q,r;\nint position;\n\nmain(){\n    int count=0;\n    char str[10000];\n    \n    while(1){\n        \n        scanf(\"%s\",str);\n        if(str[0] == '.') break;\n        count = 0;\n        \n    for(p=0; p<3; p++){\n        for(q=0; q<3; q++){\n            for(r=0; r<3; r++){\n                position = 0;\n               if(formula(str) == 2)\n               count++;\n            }\n        }\n    }\n    printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}\n\nint formula(char *str){\n    int result;\n    \n    if(str[position] == '-'){\n        result = 2-formula(str);\n        position++;\n    }   \n    \n    else if(str[position] == '('){\n    position++;\n    result = formula(str);\n    if(str[position] == '*'){\n        position++;\n        result = min(result,formula(str));\n    }\n    else if(str[position] == '+'){\n        position++;\n        result = max(result,formula(str));\n    }\n}\n\nelse{\n    if(str[position] >= '0' && str[position] <= '2')\n    return str[position] - '0';\n    \n    if(str[position] == 'P')\n    return p;\n    else if(str[position] == 'Q')\n    return q;\n    else if(str[position] == 'R')\n    return r;\n    }\n}\n\nint min(int x,int y){\n    if(x > y)\n    return y;\n    else return x;\n}\n\nint max(int x,int y){\n    if(x > y)\n    return x;\n    else return y;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nvoid consume(State& begin,int c);\nint digit(State& begin);\nint formula(State& begin);\nvoid consume(State& begin,int c){\n  if(*begin != c){\n    cout << \"expected:\"<< (char)c<< \":input:\" << *begin << endl;\n  }\n  begin++;\n}\nint P,Q,R;\nint digit(State& begin){\n  int ret = *begin;\n  begin++;\n  return ret - '0';\n}\n\nint exp(State& begin){\n  int ret = 0;\n  consume(begin,'(');\n  int f = formula(begin);\n  char op = *begin;\n  begin++;\n  int n = formula(begin);\n  consume(begin,')');\n\n  if(op == '*'){\n    ret = f*n;\n    if(ret == 2)return 1;\n    if(ret == 4)return 2;\n    return ret; \n  }\n  if(op == '+'){\n    ret = f+n;\n    //   cout << \"in plus ret = \"  <<  ret << endl;\n    if(ret == 3 || ret == 4)return 2;\n    if(f == 1 && n == 1)return 1;\n    return ret;\n  }\n}\n\nint formula(State& begin){\n  char c = *begin;\n  if(isdigit(c)){\n    return digit(begin);\n  }else if(c == '('){\n    return exp(begin);\n  }else if(c == '-'){\n    begin++;\n    return 2 - formula(begin);\n  }else if(c == 'P'){\n    begin++;\n    return P;\n  }else if(c == 'Q'){\n    begin++;\n    return Q;\n  }else if(c == 'R'){\n    begin++;\n    return R;\n  }\n}\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  string str;\n  while(true){\n    int count = 0;\n    getline(cin,str);\n    if(str == \".\")break;\n    for(P = 0;P < 3;P++)\n      for(Q = 0;Q < 3;Q++)\n\tfor(R = 0;R < 3;R++){\n\t  State begin = str.begin();\n\t  if(formula(begin) == 2){\n\t    //cout << '(' << P << ','<<Q<<','<<R<<')' << endl;\n\t    count++;\n\t  }\n\t}\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar buf[100];\nchar mot[100];\nint cnt;\nint N;\n\nint calc_n(int a){\n  if( a == 0 ) return 2;\n  else if( a == 1 ) return 1;\n  else return 0;\n}\n\nint calc_x(int a,int b){\n  if( a==0 || b==0 ) return 0;\n  if( a==1 || b==1 ) return 1;\n  return 2;\n}\n\nint calc_p(int a,int b){\n  if( a==2 || b==2 ) return 2;\n  if( a==1 || b==1 ) return 1;\n  return 0;\n}\n\nint formula(){\n  // cout << cnt << \" \" << buf[cnt] << endl;\n  if( buf[cnt] == '-' ){\n    cnt++;\n    return calc_n(formula());\n  } else if( buf[cnt] == '(' ){\n    cnt++;\n    int a = formula();\n    if( buf[cnt] == '*' ) {\n      cnt++;\n      int b = formula();\n      cnt++;\n      // cout << \"calc_x(\" << a << \" , \" << b << \") = \" << calc_x(a,b) << endl;\n      return calc_x(a,b);\n    } else {\n      cnt++;\n      int b = formula();\n      cnt++;\n      //cout << \"calc_p(\" << a << \" , \" << b << \") = \" << calc_p(a,b) << endl;\n      return calc_p(a,b);\n    }\n  } else {\n    return buf[cnt++]-'0';\n  }\n}\n\nint main(){\n  while( cin >> buf ){\n    if( buf[0] == '.' ) break;\n    N = strlen(buf);\n    for(int i=0;i<N;i++) mot[i] = buf[i];\n    int res = 0;\n\n    for(int p=0;p<3;p++){\n      for(int q=0;q<3;q++){\n\tfor(int r=0;r<3;r++){\n\t  for(int i=0;i<=N;i++){\n\t    if( mot[i] == 'P' ) buf[i] = p+'0';\n\t    else if (mot[i] == 'Q' ) buf[i] = q+'0';\n\t    else if (mot[i] == 'R' ) buf[i] = r+'0';\n\t    else buf[i] = mot[i];\n\t  }\n\t  cnt = 0;\n\t  if( formula() == 2 ){\n\t    res++;\n\t    //\t    cout << buf << endl;\n\t    //cout << cnt << \" \" << N <<endl;\n\t  }\n\t}\n      }\n    }\n    cout << res << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define State string::const_iterator\nclass ParseError {};\n\n\nint expression(State &begin);\n//int term(State &begin);\nint number(State &begin);\nint factor(State &begin);\nint denial(State &begin);\nvoid consume(State &begin, char expected);\nint p,q,r;\nstring input;\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '+'){\n            consume(begin, '+');\n            int num = factor(begin);\n            //cout << num << \" + \" << ret;\n            if(ret == 0 && num == 0){\n                ret = 0;\n            }\n            else if(ret == 1 || num == 1){\n                if(ret != 2 && num != 2){\n                    ret = 1;\n                }\n                else{\n                    ret = 2;\n                }\n            }\n            else{\n                ret = 2;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else if(*begin == '*'){\n            consume(begin, '*');\n            int num = factor(begin);\n            //cout << num << \" * \" << ret;\n            if(num == 2 && ret == 2){\n                ret = 2;\n            }\n            else if(num == 0 || ret == 0){\n                ret = 0;\n            }\n            else{\n                ret = 1;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\nint denial(State &begin){\n    if(*begin == '-'){\n\n        consume(begin, '-');\n\n        int ret = denial(begin);\n\n        if(ret == 2){\n            ret = 0;\n        }\n        else if(ret == 0){\n            ret = 2;\n        }\n\n        return ret;\n    }\n    return number(begin);\n}\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\n    if(*begin == 'P'){\n        consume(begin, 'P');\n        return p;\n    }\n    else if(*begin == 'Q'){\n        consume(begin, 'Q');\n        return q;\n    }\n    else if(*begin == 'R'){\n        consume(begin, 'R');\n        return r;\n    }\n\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        int ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return denial(begin);\n    }\n}\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        cerr << input.end() - begin << endl;\n        throw ParseError();\n    }\n}\n\n\n\nint main() {\n\n\n\n    while(true){\n\n        cin >> input;\n\n        if(input[0] == '.'){\n            break;\n        }\n\n        int ans = 0;\n\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                for(int k=0; k<3; k++){\n                    p = i;\n                    q = j;\n                    r = k;\n                    State s = input.begin();\n                    if(factor(s) == 2){\n                        ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n//#include <stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n#include<fstream>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\ntypedef string::const_iterator State;\n\nint dy[5] = { 0,0,1,-1,0 };\nint dx[5] = { 1,-1,0,0 ,0 };\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint count = 0;\n\t\tint calc, first, second;\n\t\tint tmp;\n\t\tbool flag = false;\n\t\tstring s;\n\t\t\n\n\t\tcin >> s;\n\t\tif (s == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(p, 0, 2) {\n\t\t\tFOR(q, 0, 2) {\n\t\t\t\tFOR(r, 0, 2) {\n\t\t\t\t\tflag = false;//true 反転\n\t\t\t\t\tstack<int>sta;\n\t\t\t\t\tsta.push(-4);\n\n\t\t\t\t\tFOR(i, 0, s.size() - 1) {\n\t\t\t\t\t\tswitch (s[i]) {\n\t\t\t\t\t\tcase 'P':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(p);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(q);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '0':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '2':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tsta.push(-3);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsta.push(3);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tsta.push(-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tsta.push(-2);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ')':\n\t\t\t\t\t\t\tfirst = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\ttmp = sta.top();\n\n\t\t\t\t\t\t\tif (tmp == -3) {\n\t\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\t\tswitch (first) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tfirst = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcalc = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\tsecond = sta.top();\n\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\ttmp = sta.top();\n\n\t\t\t\t\t\t\tif (tmp == -3) {\n\t\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\t\tswitch (second) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsecond = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsecond = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (tmp == 3) {\n\t\t\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch (calc) {\n\t\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\t\tif (first == 2 || second == 2) {\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (first == 0 && second == 0) {\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase -2:\n\t\t\t\t\t\t\t\tif (first == 2 && second == 2) {\n\t\t\t\t\t\t\t\t\tsta.push(2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (first == 0 || second == 0) {\n\t\t\t\t\t\t\t\t\tsta.push(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsta.push(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfirst = sta.top();\n\t\t\t\t\tsta.pop();\n\t\t\t\t\ttmp = sta.top();\n\t\t\t\t\tif (tmp == -3) {\n\t\t\t\t\t\tswitch (first) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tfirst = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (first == 2) {\n\t\t\t\t\t\t//cout << p << \" \" << q << \" \" << r << endl;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<functional>\n#include<cassert>\nusing namespace std;\n\ntypedef function<int(int[3])> node_t;\nint sub[3]={2,1,0};\nint mul[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint add[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\nstring s;\nint cur=0;\n\nchar readchar()\n{\n    assert(cur<s.size());\n    char ret=s[cur];\n    cur+=1;\n    return ret;\n}\n\nnode_t parse()\n{\n    char c=readchar();\n    if(isdigit(c))\n      return [=](int[3]) { return c-'0'; };\n    if(isalpha(c))\n      return [=](int a[3]) { return a[c-'P']; };\n    node_t left=parse();\n    if(c=='-')  \n      return [=](int a[3]) { return sub[left(a)]; };\n    assert(c=='(');\n    char op=readchar();\n    node_t right=parse();\n    cur++;\n    if(op=='*')\n      return [=](int a[3]) { return mul[left(a)][right(a)]; };\n    return [=](int a[3]) { return add[left(a)][right(a)]; };\n}\n\nint solve()\n{\n    cur=0;\n    auto tree=parse();\n    int count=0;\n    for(int p:{0,1,2})\n       for(int q:{0,1,2})\n          for(int r:{0,1,2})\n          {\n              int a[]={p,q,r};\n              if(tree(a)==2)\n                count++;\n          }\n    return count;\n}\n\nint main()\n{\n    while(cin >> s && s !=\".\")\n        cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint c_not[3]    = {2,1,0};\nint c_and[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint c_or[3][3]  = {{0,1,2},{1,1,2},{2,2,2}};\n\nint calc(string s, int p, int q, int r){\n\n  for(int i=0;i<s.size();i++){\n\n    if(s[i] == 'P'){\n      s[i] = '0' + p;\n    }\n    if(s[i] == 'Q'){\n      s[i] = '0' + q;\n    }\n    if(s[i] == 'R'){\n      s[i] = '0' + r;\n    }\n    \n  }\n  \n  while(s.size() > 1){\n    string s_old = s;\n    \n    //debug(s);\n    \n    for(int i=0;i<s.size();i++){\n\n      //not\n      if(i+1 < s.size()){\n        if(s[i] == '-' && ('0' <= s[i+1] && s[i+1] <= '2')){\n          int p = c_not[s[i+1]-'0'];\n          s = s.substr(0,i) + \"0\" + s.substr(i+2, s.size() - (i+2));\n          s[i] += p;\n          break;\n        }\n      }\n\n      \n      if(0 < i && i+1 < s.size()){\n        //and\n        if(('0' <= s[i-1] && s[i-1] <= '2') &&\n           s[i] == '*' &&\n           ('0' <= s[i+1] && s[i+1] <= '2')){\n          int p = c_and[s[i-1]-'0'][s[i+1]-'0'];\n          s = s.substr(0,i-1) + \"0\" + s.substr(i+2, s.size() - (i+2));\n          s[i-1] += p;\n          break;\n        }\n\n        //or\n        if(('0' <= s[i-1] && s[i-1] <= '2') &&\n           s[i] == '+' &&\n           ('0' <= s[i+1] && s[i+1] <= '2')){\n          int p = c_or[s[i-1]-'0'][s[i+1]-'0'];\n          s = s.substr(0,i-1) + \"0\" + s.substr(i+2, s.size() - (i+2));\n          s[i-1] += p;\n          break;\n        }\n\n        //(*)\n        if(s[i-1] == '(' &&\n           ('0' <= s[i] && s[i] <= '2') &&\n           s[i+1] == ')'){\n          int p = s[i]-'0';\n          s = s.substr(0,i-1) + \"0\" + s.substr(i+2, s.size() - (i+2));\n          s[i-1] += p;\n          break;\n        }\n      }\n    }\n\n    if(s == s_old){\n      assert(false);\n      break;\n    }\n  }\n\n  return s[0]-'0';\n}\n\nbool solve(){\n  string s;\n\n  cin >> s;\n\n  if(s == \".\") return false;\n\n  int ans = 0;\n  \n  for(int i=0;i<=2;i++){\n    for(int j=0;j<=2;j++){\n      for(int k=0;k<=2;k++){\n        ans += calc(s,i,j,k) == 2;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n\n  return true;\n}\n  \n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <utility>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nusing namespace std;\ntypedef int tribool;\nstring s;\nint p, q, r;\ntribool tri_negate(tribool x) {\n    static const tribool table[3] = { 2, 1, 0 };\n    return table[x];\n}\ntribool tri_mult(tribool x, tribool y) {\n    static const tribool table[3][3] =\n        { { 0, 0, 0 }\n        , { 0, 1, 1 }\n        , { 0, 1, 2 }\n        };\n    return table[x][y];\n}\ntribool tri_plus(tribool x, tribool y) {\n    static const tribool table[3][3] =\n        { { 0, 1, 2 }\n        , { 1, 1, 2 }\n        , { 2, 2, 2 }\n        };\n    return table[x][y];\n}\nstd::pair<tribool,int> eval(int i) {\n    switch (s[i]) {\n        case '0':\n        case '1':\n        case '2':\n            return make_pair(s[i]-'0',i+1);\n        case 'P':\n            return make_pair(p,i+1);\n        case 'Q':\n            return make_pair(q,i+1);\n        case 'R':\n            return make_pair(r,i+1);\n        case '-': {\n            std::pair<tribool,int> p = eval(i+1);\n            return make_pair(tri_negate(p.first),p.second);\n        }\n        case '(': {\n            std::pair<tribool,int> a = eval(i+1);\n            char op = s[a.second];\n            std::pair<tribool,int> b = eval(a.second+1);\n            // consume ')'\n            switch (op) {\n                case '*':\n                    return make_pair(tri_mult(a.first,b.first),b.second+1);\n                case '+':\n                    return make_pair(tri_plus(a.first,b.first),b.second+1);\n                default:\n                    assert(false);\n            }\n        }\n        default:\n            assert(false);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    while (true) {\n        cin >> s;\n        if (s == \".\") break;\n        int cnt = 0;\n        repeat (i,27) {\n            p = i/9;\n            q = (i/3)%3;\n            r = i%3;\n            if (eval(0).first == 2) {\n                cnt += 1;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n \nusing namespace std;\n \nstring str;\nint p, q, r;\n \nint negation( int &pt);\nint prod( int x, int y );\nint disj( int x, int y );\nint calc( int &pt );\nint getv( char ch);\nint getlhs( int &pt );\nint getrhs( int &pt );\n \nint solve(){\n \n\tint cnt = 0;\n\tcin >> str;\n\tif( str == \".\" ) { return 0; }\n \n\tfor( p = 0; p < 3; p++ )\n\t\tfor( q = 0; q < 3; q++ )\n\t\t\tfor( r = 0; r < 3; r++ ) {\n\t\t\t\tint ptr = 0;\n\t\t\t\tif( calc( ptr ) == 2 )\n\t\t\t\t\tcnt ++;\n\t\t\t}\n \n\tcout << cnt << endl;\n \n\treturn 1;\n \n}\n \nint main( void ) {\n \n\twhile( solve() ) {}\n \n\treturn 0;\n}\n \nint getvalue( int &pt ) {\n\tswitch( str[pt] ) {\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tbreak;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tbreak;\n\t\tcase '2':\n\t\t\treturn 2;\n\t\tbreak;\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tbreak;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tbreak;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tbreak;\n\t}\n\treturn 0;\n}\nint negation( int &pt ) {\n\tif( str[pt] == '-' ) {\n\t\tpt ++;\n\t\treturn negation(pt);\n\t}\n\tif( str[pt] == '(' ) {\n\t\tpt ++;\n\t\treturn 2-calc(pt);\n\t}\n\tint ret = 2-getvalue(pt);\n\tpt ++;\n\treturn ret;\n}\nint disj( int x, int y ) {\n\t//?????????\n\tif( x == y ) { return x; }\n\tif( x + y > 2 ) { return 2; }\n\treturn x + y;\n}\nint prod( int x, int y ) {\n\t//?????????\n\tif( x == 0 || y == 0 ) { return 0; }\n\tif( x == 2 && y == 2 ) { return 2; }\n\treturn 1;\n}\n \nint calc( int &pt ) {\n \n\t//?????????????????????\n\tint lhs;\n\tif( str[pt] == '-' ) {\n\t\tlhs = negation(++pt);\n\t} else if( str[pt] == '(' ) {\n\t\tlhs = calc(++pt);\n\t} else {\n\t\tlhs = getvalue(pt);\n\t\t++pt;\n\t}\n \n\t//????????????lhs?????????\n\tif( ( pt >= str.length() - 1 ) || ( str[pt] == ')' ) ) {\n\t\t++pt;\n\t\treturn lhs;\n\t}\n \n\t//?????????????????????\n\tchar op = str[pt];\n\t++pt;\n \n\t//?????????????????????\n\tint rhs;\n\tif( str[pt] == '-' ) {\n\t\trhs = negation(++pt);\n\t} else if( str[pt] == '(' ) {\n\t\trhs = calc(++pt);\n\t} else {\n\t\trhs = getvalue(pt);\n\t\t++pt;\n\t}\n \n\tswitch( op ) {\n\t\tcase '+':\n\t\t\treturn disj( lhs, rhs );\n\t\tbreak;\n\t\tcase '*':\n\t\t\treturn prod( lhs, rhs );\n\t\tbreak;\n\t}\n \n\treturn -1;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint p, q, r, res = 0, pt;\nstring str;\n\nint solve_rec()\n{\n\tif( str[pt] == '0' )\n\t\treturn 0;\n\telse if( str[pt] == '1' )\n\t\treturn 1;\n\telse if( str[pt] == '2' )\n\t\treturn 2;\n\telse if( str[pt] == 'P' )\n\t\treturn p;\n\telse if( str[pt] == 'Q' )\n\t\treturn q;\n\telse if( str[pt] == 'R' )\n\t\treturn r;\n\telse if( str[pt] == '-')\n\t{\n\t\tpt++;\n\t\tint a = solve_rec();\n\t\treturn 2-a;\n\t}\n\telse if( str[pt] == '(')\n\t{\n\t\tpt++;\n\t\tint a = solve_rec();\n\t\tpt++;\n\t\tchar op = str[pt];\n\t\tpt++;\n\t\tint b = solve_rec();\n\t\tpt++;\n\n\t\tif( op == '*' )\n\t\t{\n\t\t\tint c = a*b;\n\t\t\t\n\t\t\tif( c == 2 )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn c/2;\n\t\t}\n\t\telse if( op == '+' )\n\t\t\treturn max(a, b);\n\t}\n\telse\n\t{\n\t\tpt++;\n\t}\n}\n\n\nvoid solve()\n{\n\tfor( p = 0; p <= 2; p++ )\n\t\tfor( q = 0; q <= 2; q++ )\n\t\t\tfor( r = 0; r <= 2; r++ )\n\t\t\t{\n\t\t\t\tpt = 0;\n\t\t\t\t\n\t\t\t\tif( solve_rec() == 2 )\n\t\t\t\t\tres++;\n\t\t\t}\n\n\treturn;\n}\n\nint main()\n{\n\n\twhile(cin >> str, str[0] != '.')\n\t{\n\t\tres = 0;\n\t\tsolve();\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring formula;\nint not_[3] = {2,1,0};\nint and_[3][3] = { {0,0,0},{0,1,1},{0,1,2}};\nint or_[3][3] = { {0,1,2},{1,1,2},{2,2,2}};\nint R,Q,P;\n\nint parse(int &pos) {\n    int ret;\n    if(formula[pos] == 'R') ret = R;\n    else if(formula[pos] == 'Q') ret = Q;\n    else if(formula[pos] == 'P') ret = P;\n    else if('0'<=formula[pos] && formula[pos] <= '9') ret = formula[pos] - '0'; \n    else if(formula[pos] == '(') {\n        ret = parse(++pos);\n        if(formula[pos] == '+') ret = or_[ret][parse(++pos)];\n        else if(formula[pos] == '*') ret = and_[ret][parse(++pos)];\n    }\n    else if(formula[pos] == '-') return not_[parse(++pos)];\n\n    pos++;\n\n    return ret;\n\n} \n\nvoid solve() {\n    int pos = 0;\n    int ans = 0;\n    for(P=0;P<=2;P++) {\n        for(Q=0;Q<=2;Q++) {\n            for(R=0;R<=2;R++) {\n                pos = 0;\n                if(parse(pos) == 2) ans++;\n            }\n        }\n    }\n\n    cout<<ans<<endl;\n\n}\nint main() {\n    while(cin>>formula) {\n        if(formula==\".\") return 0;\n\n        solve();\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n\nusing namespace std;\n\n\nint t;\nstring s;\n\nint tbk[3][3] = {\n\t{ 0, 0, 0 },\n\t{ 0, 1, 1 },\n\t{ 0, 1, 2 }\n};\nint tbp[3][3] = {\n\t{ 0, 1, 2 },\n\t{ 1, 1, 2 },\n\t{ 2, 2, 2 }\n};\n\nint d[3];\n\nint form(){\n\n\tif (s[t] >= '0' && s[t] <= '2'){\n\t\tint p = s[t] - '0';\n\t\tt++;\n\t\treturn p;\n\t}\n\n\tif (s[t] >= 'P' && s[t] <= 'R'){\n\t\tint p = s[t] - 'P';\n\t\tt++;\n\t\treturn d[p];\n\t}\n\n\tif (s[t] == '-'){\n\t\tt++;\n\t\tint q = form();\n\t\treturn (q == 0 ? (2) : ((q == 2) ? 0 : 1));\n\t}\n\n\tif (s[t] == '('){\n\t\tt++;\n\t\tint p = form();\n\t\tif (s[t] == '*'){\n\t\t\tt++; int q = form(); t++; return tbk[p][q];\n\t\t}\n\t\telse\n\t\t\tif (s[t] == '+'){\n\t\t\t\tt++; int q = form(); t++; return tbp[p][q];\n\t\t\t}\n\t}\n}\n\nint ans = 0;\n\nvoid dfs(int i){\n\n\tif (i == 3){\n\t\tt = 0;\n\t\tif (form() == 2)ans++;\n\t\treturn;\n\t}\n\n\tfor (int j = 0; j < 3; j++){\n\t\td[i] = j;\n\t\tdfs(i + 1);\n\t}\n}\n\n\nint main()\n{\n\twhile (cin >> s && s != \".\"){\n\t\tt = 0;\n\t\tans = 0;\n\t\ts += \" \";\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint p,q,r,i;\nint dfs(){\n  int t[2]={},c=0,m=0,w=0,k=0,a=0,pp=0;\n  t[0]=t[1]=-100;\n  if(s[i]=='(')i++;\n  for(;i<s.size();i++){pp=0;\n    if(s[i]=='(')t[c++]=dfs(),a++,pp++;\n    else if(s[i]>='0'&&s[i]<='2')t[c++]=s[i]-'0',a++;\n    else if(s[i]=='P')t[c++]=p,a++;\n    else if(s[i]=='Q')t[c++]=q,a++;\n    else if(s[i]=='R')t[c++]=r,a++;\n    else if(s[i]=='-')m++;\n    else if(s[i]=='+')w++,a=0;\n    else if(s[i]=='*')k++,a=0;\n    if(m%2&&a&&!pp){\n     t[c-1]=abs(t[c-1]-2);\n     a=m=0;\n   }\n    if(s[i]==')'&&!pp){\n      if(c==1)return t[0];\n      if(w)return max(t[0],t[1]);\n      if(k)return min(t[0],t[1]);\n    }\n  }\n  return t[0];\n}\nint main(){\n  while(cin>>s,s!=\".\"){\n      int res=0;\n      r(x,3)r(y,3)r(z,3){\n\tp=x;q=y;r=z;i=0;\n\tif(dfs()==2)res++;\n      }\n      cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\n\n\ntypedef string::const_iterator Cursol;\nint P, Q, R;\nint tmp1[3] = { 2, 1, 0}, tmp2[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint tmp3[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n \nint formula(Cursol &c){\n  int ret ;\n  if(*c == 'P') ret = P;\n  else if(*c == 'Q') ret = Q;\n  else if(*c == 'R') ret = R;\n  else if(isdigit(*c)) ret = *c - '0';\n  else if(*c == '-') return tmp1[formula(++c)];\n  else if(*c == '('){\n    ret = formula(++c);\n    if(*c == '*') ret = tmp2[ret][formula(++c)];\n    else if(*c == '+') ret = tmp3[ret][formula(++c)];\n  }\n  c++;\n  return ret;\n}\nint solve2(string s){\n  Cursol c;\n \n  // while( cin >> s, s != \".\"){\n    int ret = 0;\n    for(P = 0 ; P < 3 ; P++ ){\n      for(Q = 0 ; Q < 3 ; Q++ ){\n        for(R = 0 ; R < 3 ; R++ ){\n          c = s.begin();\n          if( 2 == formula(c)) ret++;\n        }\n      }\n    }\n    return ret;\n    // cout << ret << endl;\n  // }\n}\n\n\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\nstring s,tmp;\nchar aa[]={'P','Q','R'};\n\nstring schange(string st,char a,char b){\n\t// cout<<a<<\" \"<<b<<endl;\n\trep(i,st.size()){\n\t\tif(st[i]==a){\n\t\t\tst[i]=b;\n\t\t}\n\t}\n\treturn st;\n}\n\nstring NOT(string t){\n\tif(t[1]=='1') return \"1\";\n\telse if(t[1]=='2') return \"0\";\n\treturn \"2\";\n}\nstring AND(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==0||b==0) return \"0\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"2\";\n}\nstring OR(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==2||b==2) return \"2\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"0\";\n}\nbool isnum(char t){\n\tif(t>='0'&&t<='2') return true;\n\treturn false;\n}\n\nint calc(string tmp){\n\t// cout<<tmp<<endl;\n\tif(tmp.size()==1&&tmp[0]=='2') return 2;\n\telse if(tmp.size()==1) return 0;\n\tint tmps=tmp.size();\n\tbool f=false;\n\twhile(1){\n\t\trep(i,tmp.size()){\n\t\t\t\tif(tmp[i]=='('){\n\t\t\t\t\tif(tmp[i+2]==')'){\n\t\t\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\t\t\t\t\ttmp=tmp.substr(0,i)+tmp.substr(i+1,1)+tmp.substr(i+3);\n\t\t\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(tmp[i]=='-'){\n\t\t\t\t\tif(isnum(tmp[i+1])){\n\t\t\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\t\t\t\t\ttmp=tmp.substr(0,i)+NOT(tmp.substr(i,2))+tmp.substr(i+2);\n\t\t\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(tmp[i]=='*'&&f){\n\t\t\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\n\t\t\t\t\t\ttmp=tmp.substr(0,i-1)+AND(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(tmp[i]=='+'&&f){\n\t\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\t\t\t\t\n\t\t\t\t\ttmp=tmp.substr(0,i-1)+OR(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) break;\n\t\tif(tmps!=tmp.size()) break;\n\t\telse f=true;\n\t}\n\t// cout<<tmp<<endl;\n\treturn calc(tmp);\n}\n\nint solve(string s){\n\tint ans=0;\n\tint c=0;\n\trep(i,3){\n\t\tif(s.find(aa[i])!=-1){\n\t\t\t// cout<<\"before \"<<s<<endl;\n\t\t\ts = schange(s,aa[i],'a'+c);\n\t\t\tc++;\n\t\t\t// cout<<\"after \"<<s<<endl;\n\t\t}\n\t}\n\t// cout<<aa[0]<<endl;\n\t// cout<<s<<endl;\n\trep(i,3){\n\t\trep(j,3){\n\t\t\trep(k,3){\n\t\t\t\ttmp=s;\n\t\t\t\t// cout<<tmp<<endl;\n\t\t\t\ttmp = schange(tmp,'a',i+'0');\n\t\t\t\ttmp = schange(tmp,'b',j+'0');\n\t\t\t\ttmp = schange(tmp,'c',k+'0');\n\t\t\t\t// cout<<tmp<<endl;\n\t\t\t\tif(calc(tmp)==2){\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout<<\"ans \"<<ans<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\n}\n\n\nint main(){\n\twhile(cin>>s,s[0]!='.'){\n\t\t// cout<<s<<endl;\n\t\t// cout<<solve2(s)<<endl;\n\t\t// if(solve(s)!=solve2(s)){\n\t\t\t// cout<<s<<endl;\n\t\t\tcout<<solve(s)<<endl;//\" \"<<solve2(s)<<endl;\n\t\t// }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct node{\n  string exp;\n  int left=-1;\n  int right=-1;\n};\n\nint num;\n\nint prior(char c){\n  if(c=='+') return 0;\n  else if(c=='*') return 1;\n  else if(c=='-') return 2;\n  else return 3;\n}\n\nvoid divide(int self,string exp,node nodes[]){\n  int cnt=0,min=3,min_index=-1;\n  bool inter=false;\n  for(int i=0;i<exp.size();i++){\n    if(exp[i]=='('){\n      cnt++;\n      if(i==0) inter=true;\n    } else if(exp[i]==')'){\n      cnt--;\n      if(cnt==0&&i!=exp.size()-1) inter=false;\n    } else if(cnt==0){\n      int p=prior(exp[i]);\n      if(p<min){\n\tmin=p; min_index=i;\n      }\n    }\n  }\n  if(inter){\n    divide(self,exp.substr(1,exp.size()-2),nodes); return;\n  }\n  if(min_index>=0){\n    if(min<2) divide(nodes[self].left=++num,exp.substr(0,min_index),nodes);\n    divide(nodes[self].right=++num,exp.substr(min_index+1),nodes);\n    nodes[self].exp=exp[min_index];\n  } else nodes[self].exp=exp;\n}\n\nint AND[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint OR[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nint NOT[3]={2,1,0};\n\nint solve(int n,node nodes[],int p,int q,int r){\n  if(nodes[n].exp==\"0\") return 0;\n  else if(nodes[n].exp==\"1\") return 1;\n  else if(nodes[n].exp==\"2\") return 2;\n  else if(nodes[n].exp==\"P\") return p;\n  else if(nodes[n].exp==\"Q\") return q;\n  else if(nodes[n].exp==\"R\") return r;\n  else{\n    if(nodes[n].exp==\"+\")\n      return OR[solve(nodes[n].left,nodes,p,q,r)][solve(nodes[n].right,nodes,p,q,r)];\n    else if(nodes[n].exp==\"*\")\n      return AND[solve(nodes[n].left,nodes,p,q,r)][solve(nodes[n].right,nodes,p,q,r)];\n    else\n      return NOT[solve(nodes[n].right,nodes,p,q,r)];\n  }\n  //cout<<nodes[n].exp<<endl;\n}\n\nint main(){\n  string exp;\n\n  for(;;){\n    cin>>exp;\n    if(exp==\".\") break;\n    num=0;\n    struct node nodes[100];\n    divide(0,exp,nodes);\n    int sum=0;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tfor(int k=0;k<3;k++)\n\t  if(solve(0,nodes,i,j,k)==2) sum++;\n    cout<<sum<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tint cnt=0,f;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tV.PB(mt);\n\t\t}\n\t}\n\tif(f==0)return (char)(_and[V[0]][V[1]]+'0');\n\telse return (char)(_or[V[0]][V[1]]+'0');\n}\nint rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\treturn (s[0]-'0');\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tint res=rec(s,i,j,k);\n\t\t\tif(res==2)cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<stack>\n#include<queue>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint NOT(int x){ return 2-x; }\nint AND(int x, int y){ return min(x,y); }\nint OR(int x, int y){ return max(x,y); }\nbool is_operator(char op){\n\treturn (op == '-' || op == '*' || op == '+');\n}\n\nstring postfix(string fml)\n{\n\tstring res=\"\";\n\tstack<char> st;\n\tqueue<char> que;\n\trep(i, fml.size())\n\t{\n\t\tif(is_operator(fml[i])){\n\t\t\twhile(!st.empty()){\n\t\t\t\tif(!is_operator(st.top())) break;\n\t\t\t\tif(fml[i] == '-') break;\n\t\t\t\tque.push(st.top());\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.push(fml[i]);\n\t\t}\n\t\telse if(fml[i] == '('){\n\t\t\tst.push(fml[i]);\n\t\t}\n\t\telse if(fml[i] == ')'){\n\t\t\twhile(!(st.top() == '(')){\n\t\t\t\tque.push(st.top());\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t\telse{\n\t\t\tque.push(fml[i]);\n\t\t}\n\t}\n\n\twhile(!que.empty()){\n\t\tres += que.front();\n\t\tque.pop();\n\t}\n\treturn res;\n}\n\nint solve(int p, int q, int r, string fml)\n{\n\tint res=0;\n\tstack<int> st;\n\trep(i,fml.size())\n\t{\n\t\tif(fml[i] == 'P'){\n\t\t\tst.push(p);\n\t\t}\n\t\telse if(fml[i] == 'Q'){\n\t\t\tst.push(q);\n\t\t}\n\t\telse if(fml[i] == 'R'){\n\t\t\tst.push(r);\n\t\t}\n\t\telse if(isdigit(fml[i])){\n\t\t\tst.push(fml[i]-'0');\n\t\t}\n\t\telse if(fml[i] == '-'){\n\t\t\tint x = st.top();\n\t\t\tst.pop();\n\t\t\tst.push(NOT(x));\n\t\t}\n\t\telse if(fml[i] == '*'){\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tst.push(AND(x,y));\n\t\t}\n\t\telse if(fml[i] == '+'){\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tst.push(OR(x,y));\n\t\t\t\n\t\t}\n\t}\n\n\treturn (st.top() == 2) ? 1 : 0;\n}\n\nint main()\n{\n\tstring formula;\n\twhile(cin >> formula)\n\t{\n\t\tif(formula == \".\") break;\n\n\t\tformula = postfix(formula);\n\n\t\tint ans=0;\n\t\trep(p,3){\n\t\t\trep(q,3){\n\t\t\t\trep(r,3){\n\t\t\t\t\tans += solve(p,q,r,formula);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tswitch (T[pos++]) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return 2 - solve();\n\t\tcase '(':\n\t\t\tint a = solve();\n\t\t\tswitch (T[++pos]) {\n\t\t\t\tcase '+': return min(a, solve());\n\t\t\t\tcase '*': return max(a, solve());\n\t\t\t}\n\t\t\tpos++;\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n//typedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring s;\nint p;\nint P, Q, R;\nint term();\n\nint elem()\n{\n\tint tmp;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\ttmp = term();\n\t\tp++;\n\t\treturn tmp;\n\t}\n\tint cnt = 0;\n\twhile (s[p] == '-')\n\t{\n\t\tcnt++;\n\t\tp++;\n\t}\n\tif (isdigit(s[p])) tmp = s[p] - '0';\n\telse if (s[p] == 'P') tmp = P;\n\telse if (s[p] == 'Q') tmp = Q;\n\telse if (s[p] == 'R') tmp = R;\n\tp++;\n\treturn (cnt % 2 ? 2 - tmp : tmp);\n}\n\nint term()\n{\n\tint tmp = elem();\n\twhile (s[p] == '+' || s[p] == '*')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tint a = elem();\n\t\tif (c == '+')\n\t\t{\n\t\t\ttmp = max(tmp, a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp = min(tmp, a);\n\t\t}\n\t}\n\treturn tmp;\n}\n\n\nint main()\n{\n\twhile (getline(cin, s))\n\t{\n\t\tif (s == \".\") break;\n\t\tp = 0;\n\t\tint cnt = 0;\n\t\tREP(i, 3)REP(j, 3)REP(k, 3)\n\t\t{\n\t\t\tp = 0;\n\t\t\tP = i, Q = j, R = k;\n\t\t\tif (term() == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint formula(string& s, int& i) {\n\tif(s[i] == '(') {\n\t\ti++;\n\t\tint val = formula(s, i);\n\n\t\tchar op = s[i];\n\n\t\ti++;\n\t\tint val2 = formula(s, i);\n\n\t\tint ret = 0;\n\t\tif(op == '+') {\n\t\t\tif(val == 2 || val2 == 2) ret = 2;\n\t\t\telse if(val == 1 || val2 == 1) ret = 1;\n\t\t\telse ret = 0;\n\t\t}\n\t\tif(op == '*') {\n\t\t\tif(val == 2 && val2 == 2) ret = 2;\n\t\t\telse if((val == 1 || val == 2) && (val2 == 1 || val2 == 2)) ret = 1;\n\t\t\telse ret = 0;\n\t\t}\n\n\t\ti++;\n\t\treturn ret;\n\t} else if(isdigit(s[i])) {\n\t\tint ret = (s[i] - '0');\n\t\ti++;\n\t\treturn ret;\n\t} else if(s[i] == '-') {\n\t\ti++;\n\t\tint val = formula(s, i);\n\n\t\tint ret = 0;\n\t\tif(val == 0) ret = 2;\n\t\tif(val == 1) ret = 1;\n\t\tif(val == 2) ret = 0;\n\n\t\treturn ret;\n\t}\n}\n\n\nint main() {\n\tstring s;\n\twhile(cin >> s) {\n\t\tif(s == \".\") break;\n\n\t\tint ans = 0;\n\t\trep(i, 3) {\n\t\t\trep(j, 3) {\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\trep(l, s.size()) {\n\t\t\t\t\t\tif(t[l] == 'P') t[l] = ('0' + i);\n\t\t\t\t\t\telse if(t[l] == 'Q') t[l] = ('0' + j);\n\t\t\t\t\t\telse if(t[l] == 'R') t[l] = ('0' + k);\n\t\t\t\t\t}\n\n\t\t\t\t\tint p = 0;\n\t\t\t\t\tif(formula(t, p) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint v[3],n,c;\nstring s;\n\nint f(){\n  n++;\n  int r;\n  if(s[n-1]=='(')r=f(),n++,r=s[n-1]=='+'?max(r,f()):min(r,f()),n++;\n  if(s[n-1]=='-')r=2-f();\n  if(isdigit(s[n-1]))r=s[n-1]-'0';\n  else r=v[s[n-1]-'P'];\n  return r;\n}\n\nint main(){ \n  cin >> s;\n  if(s!=\".\"){\n    c=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3)n=0,c+=f()/2;\n    cout << c << endl;\n    main();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint expr(auto& itr) {\n  if (isdigit(*itr)) return *itr++ - '0';\n  if (*itr == '-') return 2 - expr(++itr);\n  int l = expr(++itr);\n  if (*itr++ == '*') {\n    int r = expr(itr);\n    ++itr;\n    return min(l, r);\n  } else {\n    int r = expr(itr);\n    ++itr;\n    return max(l, r);\n  }\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    string s; cin >> s;\n    if (s == \".\") break;\n    int res = 0;\n    for (int p = 0; p < 3; ++p) for (int q = 0; q < 3; ++q) for (int r = 0; r < 3; ++r) {\n      auto t = s;\n      for (auto&& e : t) {\n        if (e == 'P') e = '0' + p;\n        if (e == 'Q') e = '0' + q;\n        if (e == 'R') e = '0' + r;\n      }\n      auto itr = begin(t);\n      res += expr(itr) == 2;\n    }\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=k+'0';\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ndouble EPS=1e-10;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\nmap<char,int> m;\nint idx;\nint nums[10];\n\nint analysis(string s){\n\tif(s.size()==1){\n\t\tif(s[0]>='0'&&s[0]<='9')\n\t\t\treturn s[0]-'0';\n\t\treturn nums[m[s[0]]];\n\t}\n\tif(s[0]=='('&&s[s.size()-1]==')'){\n\t\tint cnt=1;\n\t\tbool ok=false;\n\t\tfor(int i=1;i<s.size()-1;i++){\n\t\t\tif(s[i]=='(')cnt++;\n\t\t\telse if(s[i]==')')cnt--;\n\t\t\tif(cnt==0){\n\t\t\t\tbool ok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok&&cnt==1){\n\t\t\treturn analysis(s.substr(1,s.size()-2));\n\t\t}\n\t}\n\tint cnt=0;\n\tfor(int i=s.size()-1;i>=0;i--){\n\t\tif(s[i]=='(')cnt++;\n\t\telse if(s[i]==')')cnt--;\n\t\tif(cnt==0&&s[i]=='+'){\n\t\t\tint a=analysis(s.substr(0,i));\n\t\t\tint b=analysis(s.substr(i+1));\n\t\t\tif(a==0)return b;\n\t\t\telse if(a==1){\n\t\t\t\tif(b<=1)return 1;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tfor(int i=s.size()-1;i>=0;i--){\n\t\tif(s[i]=='(')cnt++;\n\t\telse if(s[i]==')')cnt--;\n\t\tif(cnt==0&&s[i]=='*'){\n\t\t\tint a=analysis(s.substr(0,i));\n\t\t\tint b=analysis(s.substr(i+1));\n\t\t\tif(a==0)return 0;\n\t\t\telse if(a==1){\n\t\t\t\tif(b==0)return 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tif(s[0]=='-'){\n\t\tint a=analysis(s.substr(1));\n\t\tif(a==0)return 2;\n\t\telse if(a==1)return 1;\n\t\treturn 0;\n\t}\n\t//for(int i=s.size()-1;i>=0;i--){\n\t//\tif(s[i]=='(')cnt++;\n\t//\telse if(s[i]==')')cnt--;\n\t//\tif(cnt==0&&s[i]=='-'){\n\t//\t\tint a=analysis(s.substr(i+1));\n\t//\t\tif(a==0)return 2;\n\t//\t\telse if(a==1)return 1;\n\t//\t\telse return 0;\n\t//\t}\n\t//}\n}\n\nstring ins;\nint res;\nvoid rec(int depth){\n\tif(depth==m.size()){\n\t\tif(analysis(ins)==2){\n\t\t\tres++;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<3;i++){\n\t\t\tnums[depth]=i;\n\t\t\trec(depth+1);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tres=0;\n\t\tins=s;\n\t\tidx=0;\n\t\tm.clear();\n\t\t//for(int i=0;i<s.size();i++){\n\t\t//\tif(m.count(s[i])==0&&(s[i]=='P'||s[i]=='Q'||s[i]=='R')){\n\t\t//\t\tm[s[i]]=idx++;\n\t\t//\t}\n\t\t//}\n\t\tm['P']=0;\n\t\tm['Q']=1;\n\t\tm['R']=2;\n\n\t\trec(0);\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <cctype>\nusing namespace std;\nusing node_t = function<int(int[3])>;\nstring S;\nsize_t cur = 0;\n\nnode_t parse() {\n    char c = S[cur++];\n    if (isdigit(c)) return [=](int[3]) { return c - '0'; };     // 定数関数\n    if (isalpha(c)) return [=](int a[3]) { return a[c - 'P']; };\n    node_t left = parse();\n    if (c == '-') return [=](int a[3]) { return 2 - left(a); };             // NOT\n    assert(c == '(');\n    char op = S[cur++];\n    node_t right = parse();\n    ++cur;  // skip ')'\n    if (op == '*') return [=](int a[3]) { return min(left(a), right(a)); }; // AND\n    return [=](int a[3]) { return max(left(a), right(a)); };                // OR\n}\n\nint main() {\n    while (cin >> S, S != \".\") {\n        int cnt = 0;\n        cur = 0;\n        auto tree = parse();\n        for (int p : {0, 1, 2}) {\n            for (int q : {0, 1, 2}) {\n                for (int r : {0, 1, 2}) {\n                    int a[] = {p, q, r};\n                    if (tree(a) == 2) cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing state = string::const_iterator;\n\n\nint formula(state &cur);\n\nint factor(state &cur){\n    if(*cur == '-'){\n        cur++;\n        return 2-factor(cur);\n    }\n    if(isdigit(*cur)) {\n        return *(cur++)-'0';\n    }\n    cur++;\n    int ans = formula(cur);\n    cur++;\n    return ans;\n}\n\n\n\nint formula(state &cur) {\n    int ans = factor(cur);\n    while(true){\n        if(*cur == '*'){\n            cur++;\n            ans = min(ans, factor(cur));\n        }else if(*cur == '+'){\n            cur++;\n            ans = max(ans, factor(cur));\n        }else break;\n    }\n    return ans;\n}\n\n\nint main() {\n    string s;\n    while(cin >> s, s != \".\"){\n        int ans = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                for (int k = 0; k < 3; ++k) {\n                    string t = s;\n                    for (auto &&l : t) {\n                        if(l == 'P') l = '0'+i;\n                        if(l == 'Q') l = '0'+j;\n                        if(l == 'R') l = '0'+k;\n                    }\n                    state cur = t.begin();\n                    if(formula(cur) == 2) ans++;\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str; int pos, P, Q, R;\n\nint formula() {\n  pos ++;\n  if(str[pos] == '(') {\n    int f = formula(); pos++;\n    if(str[pos] == '*') f = min(f, formula());\n    if(str[pos] == '+') f = max(f, formula());\n    pos ++;\n    return f;\n  }\n  if(str[pos] == '-') return 2-formula();\n  if(str[pos] == 'P') return P;\n  if(str[pos] == 'Q') return Q;\n  if(str[pos] == 'R') return R;\n  if(isdigit(str[pos])) return str[pos]-'0';\n}\n\nint main() {\n  while(cin >> str) {\n    if(str == \".\") return 0;\n    int cnt = 0;\n    for(P=0; P<=2; P++)\n      for(Q=0; Q<=2; Q++)\n\tfor(R=0; R<=2; R++) {\n\t  pos = -1;\n\t  cnt += formula() == 2;\n\t}\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <string.h>\n\n#define MAX_N 100\n\nusing namespace std;\n\nchar form[MAX_N];\nchar str[MAX_N];\n\nint calc_form(int l, int r){ //l-r???????????????????¨????\n\tint former, latter;\n\tint count = 0;\n\tint i;\n\tif(str[l] == '0') return 0;\n\tif(str[l] == '1') return 1;\n\tif(str[l] == '2') return 2;\n\tif(str[l] == '-'){\n\t\tif((l-r)%2==0){\n\t\t\treturn str[r]-'0';\n\t\t}else{\n\t\t\tint a = str[r]-'0';\n\t\t\tif(a == 0) return 2;\n\t\t\telse if(a == 2) return 0;\n\t\t\telse return 1;\n\t\t}\n\t}\n\tfor (i = l+1; i < r; i++)\n\t{\n\t\tif((str[i] == '+' || str[i] == '*') && count == 0) break;\n\t\tif(str[i] == '(') count++;\n\t\tif(str[i] == ')') count--;\n\t}\n\tformer = calc_form(l+1, i-1);\n\tlatter = calc_form(i+1, r-1);\n\tif(str[i] == '*'){\n\t\tif(former == 2 && latter == 2) return 2;\n\t\tif(former == 0 || latter == 0) return 0;\n\t\telse return 1;\n\t}else if(str[i] == '+'){\n\t\tif(former == 2 || latter == 2) return 2;\n\t\tif(former == 0 && latter == 0) return 0;\n\t\telse return 1;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> form;\n\t\tif(form[0] == '.') break;\n\t\tstrcpy(str, form);\n\t\tint ans = 0;\n\t\tfor (int p = 0; p <= 2; p++)\n\t\t{\n\t\t\tfor (int q = 0; q <= 2; q++)\n\t\t\t{\n\t\t\t\tfor (int r = 0; r <= 2 ; r++)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < strlen(str); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(str[i] == 'P') str[i] = p+'0';\n\t\t\t\t\t\tif(str[i] == 'Q') str[i] = q+'0';\n\t\t\t\t\t\tif(str[i] == 'R') str[i] = r+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif(calc_form(0, strlen(str)-1) == 2) ans++;\n\t\t\t\t\tstrcpy(str, form);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nchar NOT[3] = {'2', '1', '0'};\nchar AND[3][3] = {{'0', '0', '0'}, {'0', '1', '1'}, {'0', '1', '2'}};\nchar OR[3][3] = {{'0', '1', '2'}, {'1', '1', '2'}, {'2', '2', '2'}};\n\nchar s[100];\nchar s1[100];\n\nchar getNumber() {\n  char k[100], kLeft[100], kN[100], notCounter[100], kNumber = 0;\n  for (char i = 0; i < 100; i++) notCounter[i] = 0;\n  char ans;\n  for (char i = 0; s1[i] != 0; i++) {\n    if (s1[i] == '*' || s1[i] == '+') kLeft[kNumber] = s1[i-1] - '0';\n    if (s1[i] == '-') notCounter[kNumber]++;\n    else if (s1[i] == '(') kNumber++;\n    else if (s1[i] == '*') kN[kNumber] = 0;\n    else if (s1[i] == '+') kN[kNumber] = 1;\n    else if (s1[i] == ')') {\n      if (kN[kNumber] == 0) {\n        s1[i] = AND[kLeft[kNumber]][s1[i-1] - '0'];\n      } else {\n        s1[i] = OR[kLeft[kNumber]][s1[i-1] - '0'];\n      }\n      kNumber--;\n      if (notCounter[kNumber] % 2 == 1) s1[i] = NOT[s1[i] - '0'];\n      ans = s1[i];\n      notCounter[kNumber] = 0;\n    } else {\n      if (notCounter[kNumber] % 2 == 1) s1[i] = NOT[s1[i] - '0'];\n      ans = s1[i];\n      notCounter[kNumber] = 0;\n    }\n  }\n  return ans - '0';\n}\n\nchar check(char p, char q, char r) {\n  for (char i = 0; s[i] != 0; i++) {\n    s1[i] = s[i];\n    if (s1[i] == 'P') s1[i] = p + '0';\n    if (s1[i] == 'Q') s1[i] = q + '0';\n    if (s1[i] == 'R') s1[i] = r + '0';\n    s1[i+1] = 0;\n  }\n  if (getNumber() == 2) return 1;\n  return 0;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%s\", s);\n    if (s[0] == '.') break;\n    char ans = 0;\n    for (char p = 0; p < 3; p++)\n      for (char q = 0; q < 3; q++)\n        for (char r = 0; r < 3; r++)\n          ans += check(p, q, r);\n    printf(\"%d\\n\", (int)ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint term(string&, int&);\nint dfs(string&s, int&i) {\n\tint ret = term(s, i);\n\twhile (s[i] == '+' || s[i] == '*') {\n\t\tif (s[i] == '+') {\n\t\t\ti++; int b = dfs(s, i);\n\t\t\tret = max(ret, b);\n\t\t}\n\t\telse {\n\t\t\ti++; int b = dfs(s, i);\n\t\t\tret = min(ret, b);\n\t\t}\n\t}\n\treturn ret;\n}\nint term(string&s, int&i) {\n\tif (isdigit(s[i]))return s[i++] - '0';\n\tif (s[i] == '-') {\n\t\ti++; int a = term(s, i);\n\t\tif (a == 0)return 2;\n\t\tif (a == 2)return 0;\n\t\treturn 1;\n\t}\n\tif (s[i] == '(') {\n\t\ti++; int a = dfs(s, i); i++;\n\t\treturn a;\n\t}\n}\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \".\") {\n\t\tint cnt = 0;\n\t\trep(i, 3)rep(j, 3)rep(k, 3) {\n\t\t\tstring t = s;\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (c == 'P')c = '0' + i;\n\t\t\t\tif (c == 'Q')c = '0' + j;\n\t\t\t\tif (c == 'R')c = '0' + k;\n\t\t\t}\n\t\t\tint I = 0;\n\t\t\tif (dfs(t, I) == 2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tswitch (T[pos++]) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return 2 - solve();\n\t\tcase '(':\n\t\t\tint a = solve();\n\t\t\tswitch (T[pos++]) {\n\t\t\t\tcase '+': a = max(a, solve());\n\t\t\t\tcase '*': a = min(a, solve());\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn a;\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<deque>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef string::const_iterator state;\nclass parse_error {};\n\nvoid cmpinc(state &it, char expected) {\n\tif (*it == expected) {\n\t\tit++;\n\t}\n\telse {\n\t\tcerr << \"Expected '\" << expected << \"',\";\n\t\tcerr << \"got '\" << *it << \"'\";\n\n\t\tcout << endl;\n\t\tthrow parse_error();\n\t}\n}\n\n/*\n\nBNF\n\n<formula> ::= 0 | 1 | 2 | P | Q | R |\n-<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n\n*/\n\nint i; //?????°??¨\nint NOT[3] = { 2,1,0 },\nAND[3][3] = { {0,0,0},{0,1,1},{0,1,2} },\nOR[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\nint formula(state &it) {\n\tint ret, L, R;\n\n\t//while (true) {\n\tswitch (*it) {\n\n\tcase '(':\n\t\tit++;\n\t\tL = formula(it);\n\n\t\tswitch (*it) {\n\t\tcase '*':\n\t\t\tit++;\n\t\t\tR = formula(it);\n\t\t\tret = AND[L][R];\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tit++;\n\t\t\tR = formula(it);\n\t\t\tret = OR[L][R];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcmpinc(it, ')'); //)\n\t\tbreak;\n\tcase '-':\n\t\tit++;\n\t\tret = NOT[formula(it)];\n\t\tbreak;\n\n\n\tcase 'P':\n\t\tret = i % 3;\n\t\tit++;\n\t\tbreak;\n\tcase 'Q':\n\t\tret = (i / 3) % 3;\n\t\tit++;\n\t\tbreak;\n\tcase 'R':\n\t\tret = (i / 9) % 3;\n\t\tit++;\n\t\tbreak;\n\n\tdefault:\n\t\tif (*it >= '0'&&*it <= '2') {\n\t\t\tret = *it - '0';\n\t\t\tit++;\n\t\t}\n\t\tbreak;\n\t}\n\t//}\n\n\treturn ret;\n}\n\nint main() {\n\tfor (string s; getline(cin, s), s != \".\"; ) {\n\n\t\tint cnt = 0;\n\n\t\tfor (i = 0; i < 27; i++) {\n\t\t\tstate it = s.begin();\n\n\t\t\tint L, R;\n\t\t\tL = formula(it);\n\n\t\t\t//cerr << L << endl;\n\n\t\t\tif (L == 2)\n\t\t\t\tcnt++;\n\n\t\t}\n\n\t\tcout << cnt << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\nusing State = string::const_iterator;\n\nint formula(State& begin);\n\nvoid consume(State &begin, char expected){\n\tif(*begin==expected)begin++;\n\telse{\n\t\tcerr << \"expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is'\";\n\t\twhile(*begin)cerr << *begin++;\n\t\tcerr << \"'\" << endl;\n\t\texit(0);\n\t}\n}\n\n\nint reverse(int a){\n\tif(a==2)return 0;\n\telse if(a==0)return 2;\n\telse return 1;\n}\n\nint number(State& begin){\n\tint ret = (int)(*begin - '0');\n\tbegin++;\n\treturn ret;\n}\n\nint factor(State& begin){\n\tint ret = formula(begin);\n\tif(*begin == '+'){\n\t\tbegin++;\n\t\tint ret2 = formula(begin);\n\t\tret = max(ret,ret2);\n\t}else if(*begin == '*'){\n\t\tbegin++;\n\t\tint ret2 = formula(begin);\n\t\tret = min(ret,ret2);\n\t}\n\treturn ret;\n}\n\nint formula(State& begin){\n\tif(*begin == '-'){\n\t\tbegin++;\n\t\treturn reverse(formula(begin));\n\t}else if(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tint ret = factor(begin);\n\t\tconsume(begin,')');\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tstring s;\n\twhile(cin>>s,s[0]!='.'){\n\t\tint ct = 0;\n\t\tREP(P,3){\n\t\t\tREP(Q,3){\n\t\t\t\tREP(R,3){\n\t\t\t\t\tstring tmps = s;\n\t\t\t\t\treplace(tmps.begin(),tmps.end(),'P',(char)('0' + P));\n\t\t\t\t\treplace(tmps.begin(),tmps.end(),'Q',(char)('0' + Q));\n\t\t\t\t\treplace(tmps.begin(),tmps.end(),'R',(char)('0' + R));\n\t\t\t\t\tState start = tmps.begin();\n\t\t\t\t\tif(formula(start) == 2)ct++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ct << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint v[3],n,c;\nstring s;\n\nint f(){\n  n++;\n  int r;\n  if(s[n-1]=='(')r=f(),n++,r=s[n-1]=='+'?max(r,f()):min(r,f()),n++;\n  else if(s[n-1]=='-')r=2-f();\n  else if(isdigit(s[n-1]))r=s[n-1]-'0';\n  else r=v[s[n-1]-'P'];\n  return r;\n}\n\nint main(){ \n  cin >> s;\n  if(s!=\".\"){\n    c=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3)n=0,c+=f()/2;\n    cout << c << endl;\n    main();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nstring s;\nmap<char,int> m;\n\n// int minus(int &i);\nint number(int &i);\nint facter(int &i);\nint expr(int &i);\n\nint number(int &i){\n    int res;\n    if(s[i] >= '0' && s[i] <= '2'){\n        res = s[i] - '0';\n        i++;\n    }\n    else if(s[i] >= 'P' && s[i] <= 'R'){\n        res = m[s[i]];\n        i++;\n    }\n    return res;\n}\n\nint facter(int &i){\n    int res = 0;\n    if(s[i] == '('){\n        i++;\n        res = expr(i);\n        i++;\n    }\n    else if(s[i] == '-'){\n        i++;\n        res = 2 - facter(i);\n    }\n    else res = number(i);\n    return res;\n}\n\nint expr(int &i){\n    int res = facter(i);\n    while(1){\n        if(s[i] == '*'){\n            i++;\n            res = min(res,facter(i));\n        }\n        else if(s[i] == '+'){\n            i++;\n            res = max(res,facter(i));\n        }\n        else break;\n    }\n    return res;\n}\n\n\nint main(){\n    while(cin >> s && s != \".\"){\n        ll ans = 0;\n        rep(i,3){\n            rep(j,3){\n                rep(k,3){\n                    m['P'] = i;\n                    m['Q'] = j;\n                    m['R'] = k;\n                    int pos = 0;\n                    int num = expr(pos);\n                    // if(num == 2){\n                    //     cout << i << \" \" << j << \" \" << k << endl;\n                    // }\n                    ans += (num == 2);\n\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing State = string::const_iterator;\n\n//-------------------------------------\n\nint add(int a, int b) {\n    if(a == 0 && b == 0) {\n        return 0;\n    }\n    if(a == 2 || b == 2) {\n        return 2;\n    }\n    return 1;\n}\n\nint mul(int a, int b) {\n    if(a == 0 || b == 0) {\n        return 0;\n    }\n    if(a == 1 || b == 1) {\n        return 1;\n    }\n    return 2;\n}\n\nint Not(int a) {\n    if(a == 0) {\n        return 2;\n    } else if(a == 1) {\n        return 1;\n    }\n    return 0;\n}\n\nint p, q, r;\nint formula(State &now) {\n    if(*now == '0') {\n        now++;\n        return 0;\n    } else if(*now == '1') {\n        now++;\n        return 1;\n    } else if(*now == '2') {\n        now++;\n        return 2;\n    } else if(*now == 'P') {\n        now++;\n        return p;\n    } else if(*now == 'Q') {\n        now++;\n        return q;\n    } else if(*now == 'R') {\n        now++;\n        return r;\n    } else if(*now == '-') {\n        now++;\n        return Not(formula(now));\n    } else {\n        now++;\n        int res = formula(now);\n        // cout << *now << endl;\n        if(*now == '*') {\n            now++;\n            res = mul(res, formula(now));\n        } else if(*now == '+') {\n            now++;\n            res = add(res, formula(now));\n        }\n        now++;\n        return res;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    while(1) {\n        cin >> s;\n        if(s == \".\") {\n            break;\n        }\n        int ans = 0;\n        for(int i = 0; i <= 2; i++) {\n            for(int j = 0; j <= 2; j++) {\n                for(int k = 0; k <= 2; k++) {\n                    p = i, q = j, r = k;\n                    State now = s.begin();\n                    int res = formula(now);\n                    if(res == 2) {\n                        // cout << p << ' ' << q << ' ' << r << endl;\n                        ans++;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n\nusing namespace std;\n\nint Minus(int a)\n{\n\treturn 2 - a;\n}\n\nint Mul(int a,int b)\n{\n\tif(a == 0 || b == 0)\n\t\treturn 0;\n\tif(a == 1 || b == 1)\n\t\treturn 1;\n\treturn 2;\n}\n\nint Add(int a,int b)\n{\n\tif(a == 2 || b == 2)\n\t\treturn 2;\n\tif(a == 1 || b == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nint p,q,r;\n\nint GetNum(char c)\n{\n\tif(c == 'P') return p;\n\telse if(c == 'Q') return q;\n\telse return r;\n}\n\nint calc(vector<char>& num);\n\nint GetArg(vector<char>& num){\n\tchar c = num.back(); num.pop_back();\n\tif(c == '-' || c == '+' || c == '*'){\n\t\tnum.push_back(c);\n\t\treturn calc(num);\n\t} else if(c == 'P' || c == 'Q' || c == 'R')\n\t\treturn GetNum(c);\n\telse return c - '0';\n}\n\nint calc(vector<char>& num)\n{\n\tchar c = num.back(); num.pop_back();\n\tswitch(c){\n\t\tcase '-':\n\t\t\treturn Minus(GetArg(num));\n\t\tcase '*':\n\t\t\treturn Mul(GetArg(num),GetArg(num));\n\t\tcase '+':\n\t\t\treturn Add(GetArg(num),GetArg(num));\n\t\tdefault:\n\t\t\tnum.push_back(c);\n\t\t\treturn GetArg(num);\n\t}\n}\n\nvoid solve(string& str)\n{\n\tvector<char>ope,num; //ZqAlpX^bN\n\tfor(unsigned int i = 0; i < str.size(); i++){\n\t\tchar c = str[i];\n\t\tswitch(c){\n\t\t\tcase '(':\n\t\t\t\tope.push_back(c);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(ope.back() != '('){\n\t\t\t\t\tnum.push_back(ope.back()); ope.pop_back();\n\t\t\t\t}\n\t\t\t\tope.pop_back(); //')'àí\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tope.push_back(c);\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\tcase '+':\n\t\t\t\twhile(!ope.empty() && ope.back() != '('){\n\t\t\t\t\tnum.push_back(ope.back()); ope.pop_back();\n\t\t\t\t}\n\t\t\t\tope.push_back(c);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnum.push_back(c);\n\t\t}\n\t}\n\n\twhile(!ope.empty()){\n\t\tnum.push_back(ope.back()); ope.pop_back();\n\t}\n\t\n\tstring po(num.begin(),num.end());\n\tcout << po << endl;\n\n\tint count = 0;\n\tfor(p = 0; p < 3; p++)\n\t\tfor(q = 0; q < 3; q++)\n\t\t\tfor(r = 0; r < 3; r++){\n\t\t\t\tvector<char> tmp(num.begin(),num.end()); //Rs[\n\t\t\t\tif(calc(tmp) == 2)\n\t\t\t\t\tcount++;\n\t\t\t}\n\n\tcout << count << endl;\n}\n\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str,str[0] != '.'){\n\t\tsolve(str);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstring s;\nmap<char, int> hm;\nint mn[3] = {2, 1, 0};\nint ml[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint pl[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntemplate<typename T> class Parsing\n{\npublic:\n  static void consume(State& begin, char expected) {\n    if (*begin == expected) {\n      begin++;\n    } else {\n      cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n           << endl;\n      cerr << \"Rest string is '\";\n      while (*begin) {\n        cerr << *begin++;\n      }\n      cerr << \"'\" << endl;\n      throw ParseError();\n    }\n  }\n\n  static T formula(State& begin){\n    T ret;\n    if(*begin == '-'){\n      consume(begin, '-');\n      ret = mn[formula(begin)];\n    }\n    else if(isalpha(*begin) || isdigit(*begin)){\n      ret = hm[*(begin++)];\n    }\n    else if(*begin == '('){\n      consume(begin, '(');\n      ret = formula(begin);\n      if(*begin == '*'){\n        consume(begin, '*');\n        ret = ml[ret][formula(begin)];\n      }\n      else if(*begin == '+'){\n        consume(begin, '+');\n        ret = pl[ret][formula(begin)];\n      }\n      consume(begin, ')');\n    }\n    return ret;\n  }\n};\n\nint main()\n{\n  rep(i, 3) hm['0' + i] = i;\n  while(cin >> s, s != \".\"){\n    int res = 0;\n    rep(P, 3) rep(Q, 3) rep(R, 3){\n      hm['P'] = P;\n      hm['Q'] = Q;\n      hm['R'] = R;\n      State begin = s.begin();\n      if(Parsing<int>::formula(begin) == 2) res += 1;\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<algorithm>\n\nusing namespace std;\n\n\nbool check(string str,int P,int Q,int R){\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='P')str[i]=P+'0';\n\t\tif(str[i]=='Q')str[i]=Q+'0';\n\t\tif(str[i]=='R')str[i]=R+'0';\n\t}\n\tstack<int> sta[500];\n\tint rank=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='-')sta[rank].push(-1);\n\t\tif(str[i]=='+')sta[rank].push(-2);\n\t\tif(str[i]=='*')sta[rank].push(-3);\n\t\tif(str[i]=='(')rank++;\n\t\tif(str[i]==')'){\n\t\t\tint c=sta[rank].top(),flag2=0;\n\t\t\tsta[rank].pop();\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\trank--;\n\t\t\tsta[rank].push(c);\n\t\t}\n\t\tif(str[i]>='0' && str[i]<='2'){\n\t\t\tint c=str[i]-'0',flag2=0;\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsta[rank].push(c);\n\t\t}\n\t}\n\tif(sta[0].top()==2)return true;\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\".\")break;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(check(str,i,j,k))cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint bar[3] = { 2, 1, 0 };\n\nint mul[3][3] = {\n\t{ 0, 0, 0 },\n\t{ 0, 1, 1 },\n\t{ 0, 1, 2 }\n};\n\nint add[3][3] = {\n\t{ 0, 1, 2 },\n\t{ 1, 1, 2 },\n\t{ 2, 2, 2 }\n};\n\nstring str;\nint var[3];\n\nint expr(int&);\nint fomula(int&);\n\nint expr(int& i) {\n\tint val = fomula(i);\n\t\n\twhile (str[i] == '*' || str[i] == '+') {\n\t\tchar op = str[i];\n\t\t++i;\n\t\tint f = fomula(i);\n\t\tif (op == '*') val = mul[val][f];\n\t\telse val = add[val][f];\n\t}\n\t\n\treturn val;\n}\n\nint fomula(int& i) {\n\tif (str[i] == '-') {\n\t\t++i;\n\t\treturn bar[fomula(i)];\n\t}\n\t\n\tif (isdigit(str[i])) { return str[i++] - '0'; }\n\tif (str[i] == 'P') { ++i; return var[0]; }\n\tif (str[i] == 'Q') { ++i; return var[1]; }\n\tif (str[i] == 'R') { ++i; return var[2]; }\n\t\n\t++i;\n\tint res = expr(i);\n\t++i;\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> str) {\n\t\tif (str == \".\") break;\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor_(p,0,3) for_(q,0,3) for_(r,0,3) {\n\t\t\tvar[0] = p; var[1] = q; var[2] = r;\n\t\t\tint i = 0;\n\t\t\tif (expr(i) == 2) ++ans;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint BIT(int C1,bool C2);\nint MINUS(int C3);\nint KAKE(int C4,int C5);\nint PLUS(int C6,int C7);\nstring TSTRING(int C8);\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[MAX_N];\n\nint BIT(int C1,bool C2){\n\tif(C2==true){return C1;}\n\treturn MINUS(C1);\n}\n\nint MINUS(int C3){\n\treturn 2-C3;\n}\nint PLUS(int C4,int C5){\n\treturn max(C4,C5);\n}\nint KAKE(int C6,int C7){\n\treturn max(C6,C7);\n}\n\nstring TSTRING(int C8)\n{\n\tif(C8==0)\n\t{\n\t\treturn \"0\";\n\t}\n\tif(C8==1)\n\t{\n\t\treturn \"1\";\n\t}\n\treturn \"2\";\n}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\tif(ok==false){ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=BIT(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=BIT(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=BIT(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=BIT(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=BIT(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=BIT(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return PLUS(ans,ans2);}\n\treturn KAKE(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=TSTRING((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tsum=0;\n\t\tif(S==\".\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=S[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntypedef string::const_iterator ParseState;\n\nclass ParseError {\n};\n\nint expression(ParseState &begin);\n\nint term(ParseState &begin);\n\nint factor(ParseState &begin);\n\nint num(ParseState &begin);\n\nint NOT(int a) {\n    return 2 - a;\n}\n\nint AND(int x, int y) {\n    if (x == 0 || y == 0) return 0;\n    if (x == 2 && y == 2) return 2;\n    return 1;\n}\n\nint OR(int x, int y) {\n    if (x == 2 || y == 2) return 2;\n    if (x == 0 && y == 0) return 0;\n    return 1;\n}\n\nint expression(ParseState &begin) {\n    int res = 0;\n    if (*begin == '(') {\n        begin++;\n        int d1 = expression(begin);\n        int d2;\n        if (*begin == '+') {\n            begin++;\n            d2 = expression(begin);\n            res = OR(d1, d2);\n        } else if (*begin == '*') {\n            begin++;\n            d2 = expression(begin);\n            res = AND(d1, d2);\n        }\n        begin++;\n    } else {\n        res += term(begin);\n    }\n    return res;\n}\n\nint term(ParseState &begin) {\n    int res;\n    if (*begin == '-') {\n        begin++;\n        res = NOT(expression(begin));\n    } else if (isdigit(*begin)) {\n        res = *begin - '0';\n        begin++;\n    }\n    return res;\n}\n\nint main() {\n\n    while (true) {\n\n        string s;\n        cin >> s;\n\n        if (s.size() == 1 && s[0] == '.') break;\n\n        int ans = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string t = s;\n                    for (int l = 0; l < t.size(); l++) {\n                        if (t[l] == 'P') t[l] = (char) ('0' + i);\n                        if (t[l] == 'Q') t[l] = (char) ('0' + j);\n                        if (t[l] == 'R') t[l] = (char) ('0' + k);\n                    }\n                    auto begin = t.cbegin();\n                    //cout << expression(begin);\n                    if (expression(begin) == 2) {\n                        ans++;\n                      //  cout << t << endl;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nint parse(int P, int Q, int R, std::string &str) \n{\n\tswitch(str[0]) {\n\t\tcase '0':\n\t\t\tstr.erase(0, 1);\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tstr.erase(0, 1);\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tstr.erase(0, 1);\n\t\t\treturn 2;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tstr.erase(0, 1);\n\t\t\treturn P;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tstr.erase(0, 1);\n\t\t\treturn Q;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tstr.erase(0, 1);\n\t\t\treturn R;\n\t\t\tbreak;\n\t\tcase '-': \n\t\t\t{\n\t\t\t\tstr.erase(0, 1);\n\t\t\t\tint a = parse(P, Q, R, str);\n\t\t\t\treturn 2 - a;\n\t\t\t\tbreak;\n\t\t\t};\n\t\tcase '(':\n\t\t\t{\n\t\t\t\tstr.erase(0, 1);\n\t\t\t\tint a = parse(P, Q, R, str);\n\t\t\t\tif ( str[0] == '*' ) {\n\t\t\t\t\tstr.erase(0, 1);\n\t\t\t\t\tint b = parse(P, Q, R, str);\n\t\t\t\t\tstr.erase(0, 1);\n\t\t\t\t\tif ( a == 0 || b == 0 ) return 0;\n\t\t\t\t\telse if ( a == 2 && b == 2 ) return 2;\n\t\t\t\t\telse return 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr.erase(0, 1);\n\t\t\t\t\tint b = parse(P, Q, R, str);\n\t\t\t\t\tstr.erase(0, 1);\n\t\t\t\t\tif ( a == 2 || b == 2 ) return 2;\n\t\t\t\t\telse if ( a == 0 && b == 0 ) return 0;\n\t\t\t\t\telse return 1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\t\tif ( str == \".\" ) break;\n\n\t\tstd::string buf;\n\t\tint count = 0;\n\t\tfor ( int i = 0; i < 3; ++i ) {\n\t\t\tfor ( int j = 0; j < 3; ++j ) {\n\t\t\t\tfor ( int k = 0; k < 3; ++k ) {\n\t\t\t\t\tbuf = str;\n\t\t\t\t\tif ( parse(i, j, k , buf) == 2 ) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << count << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint neg(int v) {\n\tint ret = v;\n\tif (v == 0) {\n\t\tret = 2;\n\t} else if (v == 2) {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nint conj(int lhs, int rhs) {\n\tif (lhs == 0 || rhs == 0) {\n\t\treturn 0;\n\t}\n\tif (lhs == 2 && rhs == 2) {\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nint disj(int lhs, int rhs) {\n\tif (lhs == 2 || rhs == 2) {\n\t\treturn 2;\n\t}\n\tif (lhs == 0 && rhs == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nclass Parser {\n\tprivate:\n\t\tstring line;\n\t\tint pos;\n\tpublic:\n\t\tParser(string _line) {\n\t\t\tline = _line;\n\t\t\tpos = 0;\n\t\t}\n\n\t\tvoid assign(char var, int val) {\n\t\t\tREP (i, line.length()) {\n\t\t\t\tif (line[i] == var) {\n\t\t\t\t\tline[i] = val + '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint formula() {\n\t\t\tif (line[pos] == '0' || line[pos] == '1' || line[pos] == '2') {\n\t\t\t\treturn constant();\n\t\t\t}\n\t\t\tif (line[pos] == '-') {\n\t\t\t\tpos++;\n\t\t\t\treturn neg(formula());\n\t\t\t}\n\t\t\tif (line[pos] == '(') {\n\t\t\t\tpos++;\n\t\t\t\tint lhs = formula();\n\t\t\t\tchar op = line[pos];\n\t\t\t\tpos++;\n\t\t\t\tint rhs = formula();\n\t\t\t\tassert(line[pos] == ')');\n\t\t\t\tpos++;\n\t\t\t\tif (op == '*') {\n\t\t\t\t\treturn conj(lhs, rhs);\n\t\t\t\t} else {\n\t\t\t\t\treturn disj(lhs, rhs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\n\t\tint constant() {\n\t\t\tchar c = line[pos];\n\t\t\tpos++;\n\t\t\treturn c - '0';\n\t\t}\n};\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\topt_debug = true;\n\tinput(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tstring s;\n\twhile (cin >> s, s != \".\") {\n\t\tint ans = 0;\n\t\tREP (p, 3) {\n\t\t\tREP (q, 3) {\n\t\t\t\tREP (r, 3) {\n\t\t\t\t\tParser parser(s);\n\t\t\t\t\tparser.assign('P', p);\n\t\t\t\t\tparser.assign('Q', q);\n\t\t\t\t\tparser.assign('R', r);\n\t\t\t\t\tif (parser.formula() == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint NOT(int x)\n{\n    if(x==0) return 2;\n    else if(x==1) return 1;\n    else return 0;\n}\n\nint AND(int x, int y)\n{\n    if(x==0 || y==0) return 0;\n    else if(x==1 || y==1) return 1;\n    else return 2;\n}\n\nint OR(int x, int y)\n{\n    if(x==2 || y==2) return 2;\n    else if(x==1 || y==1) return 1;\n    else return 0;\n}\n\nint formula(string s)\n{\n    if(s.size()==1) return s[0]-'0';\n    else\n    {\n        if(s[0]=='(' && s[s.size()-1]==')')\n        {\n            string t=s.substr(1,s.size()-2);\n            //cout << \"er : \"<<t<<endl;\n            int b=0;\n            int op=-1;\n            int now=0;\n            while(now<t.size())\n            {\n                if(t[now]=='(') ++b;\n                else if(t[now]==')') --b;\n                else if(b==0)\n                {\n                    if(t[now]=='+')\n                    {\n                        op=0;\n                        break;\n                    }\n                    if(t[now]=='*')\n                    {\n                        op=1;\n                        break;\n                    }\n                }\n\n                ++now;\n            }\n\n            string x=t.substr(0,now), y=t.substr(now+1);\n\n            if(op==0) return OR(formula(x),formula(y));\n            if(op==1) return AND(formula(x),formula(y));\n        }\n        else if(s[0]=='-') return NOT(formula(s.substr(1)));\n    }\n\n    return 0;\n}\n\nint main()\n{\n    string s;\n    while(cin >>s)\n    {\n        if(s==\".\") break;\n\n        int ans=0;\n        rep(i,3)rep(j,3)rep(k,3)\n        {\n            string t=s;\n            rep(x,s.size())\n            {\n                if(t[x]=='P') t[x]=i+'0';\n                if(t[x]=='Q') t[x]=j+'0';\n                if(t[x]=='R') t[x]=k+'0';\n            }\n\n            if(formula(t)==2) ++ans;\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint conv[256];\nint v[3];\n\nint calc(char *s, char *e)\n{\n\t/*for (char *p = s; p != e; p++){\n\t\tprintf(\"%c\", *p);\n\t}\n\tputs(\"\");*/\n\t\n\tvector<char> op;\n\tvector<int> val;\n\tfor (char *p = s; p != e; p++){\n\t\tbool f = false;\n\t\tif (*p == '('){\n\t\t\tchar *a = p + 1;\n\t\t\tchar *b = p + 1;\n\t\t\tint cnt = 1;\n\t\t\twhile (true){\n\t\t\t\tif (*b == '(') cnt++;\n\t\t\t\tif (*b == ')') cnt--;\n\t\t\t\tif (cnt == 0) break;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tval.push_back(calc(a, b));\n\t\t\tp = b;\n\t\t\tf = true;\n\t\t}\n\t\telse if (*p == '-') op.push_back('-');\n\t\telse if (*p == '+') op.push_back('+');\n\t\telse if (*p == '*') op.push_back('*');\n\t\telse if (*p >= '0' && *p <= '2'){\n\t\t\tval.push_back(*p - '0');\n\t\t\tf = true;\n\t\t}\n\t\telse {\n\t\t\tval.push_back(v[conv[*p]]);\n\t\t\tf = true;\n\t\t}\n\t\tif (f){\n\t\t\twhile (op.size() && op.back() == '-'){\n\t\t\t\tval.back() = 2 - val.back();\n\t\t\t\top.pop_back();\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for (int i = 0; i < val.size(); i++){\n\t\t\tprintf(\"%d \", val[i]);\n\t\t}\n\t\tputs(\"\");\n\t\tfor (int i = 0; i < op.size(); i++){\n\t\t\tprintf(\"%c \", op[i]);\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\t\n\tif (op.size() == 0) return val[0];\n\tif (op.back() == '+') return max(val[0], val[1]);\n\tif (op.back() == '*') return min(val[0], val[1]);\n}\n\nint main()\n{\n\tconv['P'] = 0;\n\tconv['Q'] = 1;\n\tconv['R'] = 2;\n\t\n\tchar str[256];\n\twhile (scanf(\"%s\", str), str[0] != '.'){\n\t\tint res = 0;\n\t\tchar *e = str + strlen(str);\n\t\tfor (v[0] = 0; v[0] < 3; v[0]++){\n\t\t\tfor (v[1] = 0; v[1] < 3; v[1]++){\n\t\t\t\tfor (v[2] = 0; v[2] < 3; v[2]++){\n\t\t\t\t\t//printf(\"%d\\n\", calc(str, e));\n\t\t\t\t\tres += (calc(str, e) == 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nclass Solver {\n    public:\n        string line;\n        int solve() {\n            int count = 0;\n            for (int p = 0; p < 3; ++p) {\n                for (int q = 0; q < 3; ++q) {\n                    for (int r = 0; r < 3; ++r) {\n                        if (eval(p, q, r) == 2) {\n                            ++count;\n                        }\n                    }\n                }\n            }\n            return count;\n        }\n        void process(stack<char> &operators, stack<int> &values) {\n            int x, y;\n            while (!operators.empty()) {\n                if (operators.top() == '-') {\n                    x = 2 - values.top();\n                    values.pop();\n                    values.push(x);\n                } else if (operators.top() == '+') {\n                    y = values.top();\n                    values.pop();\n                    x = values.top();\n                    values.pop();\n                    values.push(max(x, y));\n                } else if (operators.top() == '*') {\n                    y = values.top();\n                    values.pop();\n                    x = values.top();\n                    values.pop();\n                    values.push(min(x, y));\n                }\n                operators.pop();\n            }\n        }\n        int eval(int p, int q, int r, int begin=0, int end=-1) {\n            int nest = 0;\n            int bracket_begin = -1;\n            stack<char> operators;\n            stack<int> values;\n            if (end < 0) {\n                end = line.length();\n            }\n            for (int i = begin; i < end; ++i) {\n                if (line[i] == '(') {\n                    if (nest == 0) {\n                        bracket_begin = i;\n                    }\n                    ++nest;\n                } else if(line[i] == ')') {\n                    --nest;\n                    if (nest == 0) {\n                        int x = eval(p, q, r, bracket_begin + 1, i);\n                        values.push(x);\n                        process(operators, values);\n                    }\n                }\n                if (line[i] == '(' || line[i] == ')' || nest > 0) {\n                    continue;\n                }\n                if ('0' <= line[i] && line[i] <= '2') {\n                    values.push(line[i] - '0');\n                    process(operators, values);\n                } else if (line[i] == 'P') {\n                    values.push(p);\n                    process(operators, values);\n                } else if (line[i] == 'Q') {\n                    values.push(q);\n                    process(operators, values);\n                } else if (line[i] == 'R') {\n                    values.push(r);\n                    process(operators, values);\n                } else if (line[i] == '-') {\n                    operators.push('-');\n                } else if (line[i] == '+') {\n                    operators.push('+');\n                } else if (line[i] == '*') {\n                    operators.push('*');\n                }\n            }\n            return values.top();\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.line;\n        if (s.line == \".\") {\n            return 0;\n        }\n        cout << s.solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#ifdef DEBUG\n#define line() cout << \"[\" << __LINE__ << \"] \";\n#define dump(i) cout << #i \": \" << i << \" \";\n#define dumpl(i) cout << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\n\nmap<int, int> mins;\nmap<pair<int, int>, int> mul;\nmap<pair<int, int>, int> add;\n\ntypedef string::const_iterator State;\nclass ParseError\n{\n};\n\nmap<char, int> val;\n\nint formula(State &begin)\n{\n    if (isdigit(*begin))\n    {\n        int ret = (*begin) - '0';\n        begin++;\n        return ret;\n    }\n    if ((*begin == 'R') || (*begin == 'Q') || (*begin == 'P'))\n    {\n        int ret = val[*begin];\n        begin++;\n\n        return ret;\n    }\n    if (*begin == '-')\n    {\n        begin++;\n        int ret = formula(begin);\n        return mins[ret];\n    }\n    if (*begin == '(')\n    {\n        begin++;\n        int ret1 = formula(begin);\n        char op = *begin;\n        begin++;\n        int ret2 = formula(begin);\n        begin++;\n        if (op == '*')\n        {\n            return mul[{ret1, ret2}];\n        }\n        else\n        {\n            return add[{ret1, ret2}];\n        }\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    mins[0] = 2;\n    mins[1] = 1;\n    mins[2] = 0;\n\n    mul[{0, 0}] = 0;\n    mul[{0, 1}] = 0;\n    mul[{0, 2}] = 0;\n\n    mul[{1, 0}] = 0;\n    mul[{1, 1}] = 1;\n    mul[{1, 2}] = 1;\n\n    mul[{2, 0}] = 0;\n    mul[{2, 1}] = 1;\n    mul[{2, 2}] = 2;\n\n    add[{0, 0}] = 0;\n    add[{0, 1}] = 1;\n    add[{0, 2}] = 2;\n\n    add[{1, 0}] = 1;\n    add[{1, 1}] = 1;\n    add[{1, 2}] = 2;\n\n    add[{2, 0}] = 2;\n    add[{2, 1}] = 2;\n    add[{2, 2}] = 2;\n\n    while (true)\n    {\n        string s;\n        cin >> s;\n        if (s == \".\")\n            break;\n        int ans = 0;\n        rep(i, 3) rep(j, 3) rep(k, 3)\n        {\n            val['R'] = i;\n            val['Q'] = j;\n            val['P'] = k;\n            State begin = s.begin();\n            if (formula(begin) == 2)\n            {\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define N_MAX 80\nstring s,s_copy;\nint ans=0;\nint point=0;\n\nchar ch(int i){\n\tif(i==0)\n\t\treturn '0';\n\telse if(i==1)\n\t\treturn '1';\n\telse return '2';\n}\n\nvoid set(int i,int j,int z){\n\ts_copy=s;\n\tint c=s.size();\n\tfor(int k=0;k<c;k++){\n\t\tif(s_copy[k]=='P') s_copy[k]=ch(i);\n\t\tif(s_copy[k]=='Q') s_copy[k]=ch(j);\n\t\tif(s_copy[k]=='R') s_copy[k]=ch(z);\n\t}\n}\n\nint mainus(int i){\n\tswitch (i){\n\tcase 0: return 2;\n\tcase 1: return 1;\n\tcase 2: return 0;\n\t}\n}\n\nint kakeru(int x,int y){\n\treturn x>y ? y:x;\n}\n\nint tasu(int x,int y){\n\treturn x>y ? x:y;\n}\n\nint calc(){ \n\tswitch(s_copy[point++]){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return mainus(calc());\n\t\tcase '(': \n\t\t\tint left=calc();\n\t\t\tchar temp=s_copy[point++];\n\t\t\tint right=calc();\n\t\t\tpoint++;\n\t\t\tif(temp=='+')return tasu(left,right);\n\t\t\telse return kakeru(left,right);\n\t}\n}\n\n\n\nint main()\n{\n\t\twhile(true){\n\t\t\tcin>>s;\n\t\t\tif(s==\".\") break;\n\t\t\tfor(int i=0;i<=2;i++)\n\t\t\t\tfor(int j=0;j<=2;j++)\n\t\t\t\t\tfor(int z=0;z<=2;z++){\n\t\t\t\t\t\tset(i,j,z);\n\t\t\t\t\t\tpoint=0;\n\t\t\t\t\t\tif(calc()==2)\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\tcout<<ans<<\"\\n\";\n\t\t\t\tans=0;\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-6;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconst int64 mod = 1e9+7;\n\nint32 add(int32 a, int32 b){\n\tif(a == 1 && b == 1) return 1;\n\treturn min(2, a+b);\n}\n\nint32 mul(int32 a, int32 b){\n\tif(a*b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint32 nnot(int32 a){\n\treturn 2-a;\n}\n\nint32 val[3];\n\nint32 eval(string s){\n\tif(s.size() == 1 && '0' <= s[0] && s[0] <= '3') return s[0]-'0';\n\tif(s.size() == 1) return val[s[0]-'P'];\n\tif(s[0] == '-') return nnot(eval(s.substr(1, s.size()-1)));\n\tint32 now = 0;\n\tREP(i, s.size()){\n\t\tif(s[i] == '(') now++;\n\t\tif(s[i] == ')') now--;\n\t\tif(now == 1 && s[i] == '+') return add(eval(s.substr(1, i-1)), eval(s.substr(i+1, s.size()-i-2)));\n\t\tif(now == 1 && s[i] == '*') return mul(eval(s.substr(1, i-1)), eval(s.substr(i+1, s.size()-i-2)));\n\t}\n}\n\nint main(void){\n\tstring s;\n\twhile(cin >> s && s != \".\"){\n\t\tint32 res = 0;\n\t\tREP(i, 3){\n\t\t\tREP(j, 3){\n\t\t\t\tREP(k, 3){\n\t\t\t\t\tval[0] = i; val[1] = j; val[2] = k;\n\t\t\t\t\tif(eval(s) == 2) res++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<deque>\n#include<stack>\n#include<algorithm>\n#include<cstring>\n#include<cctype>\nusing namespace std;\nint T(char*s)\n{\n\tchar*p,a[2]=\"@\",c;\n\tstack<char> o;\n\tdeque<char> d;\n\tfor(p=s;*p;++p)\n\t{\n\t\ta[0]=*p;\n\t\tif(isdigit(*p))\n\t\t{\n\t\t\td.push_back(*p);\n\t\t\twhile(o.size()&&o.top()=='-')o.pop(),d.push_back('-');\n\t\t}\n\t\tif(strpbrk(a,\"(+*-\"))o.push(*p);\n\t\tif(*p==')')\n\t\t{\n\t\t\twhile(c=o.top(),o.pop(),c-'(')d.push_back(c);\n\t\t\twhile(o.size()&&o.top()=='-')o.pop(),d.push_back('-');\n\t\t}\n\t}\n\twhile(o.size())d.push_back(o.top()),o.pop();\n\tfor(int i=1;i<d.size();)\n\t{\n\t\tif(d[i]=='-')d[i-1]=-(d[i-1]-'1')+'1',d.erase(d.begin()+i);\n\t\telse if(d[i]=='*')d[i-2]=min(d[i-2],d[i-1]),d.erase(d.begin()+i-1,d.begin()+i+1),--i;\n\t\telse if(d[i]=='+')d[i-2]=max(d[i-2],d[i-1]),d.erase(d.begin()+i-1,d.begin()+i+1),--i;\n\t\telse ++i;\n\t}\n\treturn d[0]=='2';\n}\nint main()\n{\n\tchar s[84],t[84],*p,i[3];\n\twhile(scanf(\"%s\",s),s[0]-'.')\n\t{\n\t\tint r=0;\n\t\tfor(i[0]='0';i[0]<'3';++i[0])for(i[1]='0';i[1]<'3';++i[1])for(i[2]='0';i[2]<'3';++i[2])\n\t\t{\n\t\t\tstrcpy(t,s);\n\t\t\twhile(p=strpbrk(t,\"PQR\"))*p=i[*p-'P'];\n\t\t\tr+=T(t);\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\nint formula(State& begin, int s);\nint factor(State& begin, int s);\n\nvoid consume(State& begin, char expected) {\n    if (*begin == expected) begin++;\n    else {\n        cout << \"expected: \" << expected << endl;\n        cout << \"but *begin is \" << *begin << endl;\n        cout << \"rest string is\" << endl;\n        while (*begin) {\n            cout << *begin++ ;\n        }\n        cout << endl;\n        exit(1);\n    }\n}\n\nint formula(State& begin, int s) {\n    if (*begin == '-') {\n        consume(begin, '-');\n        return 2-formula(begin, s);\n    } else if (*begin == '(') {\n        consume(begin, '(');\n        int ret = formula(begin, s);\n        if (*begin == '*') {\n            consume(begin, '*');\n            ret = min(ret, formula(begin, s));\n        } else if (*begin == '+') {\n            consume(begin, '+');\n            ret = max(ret, formula(begin, s));\n        }\n        consume(begin, ')');\n        return ret;\n    } else {\n        return factor(begin, s);\n    }\n}\n\nint factor(State& begin, int s) {\n    int ret = 0;\n    if (isdigit(*begin)) ret = *begin - '0';\n    else {\n        if (*begin == 'P') ret = ((s%3));\n        else if (*begin == 'Q') ret = ((s/3)%3);\n        else ret = ((s/9));\n    }\n    begin++;\n    return ret;\n}\n\nvoid solve(const string& s) {\n    int ans = 0;\n    for (int S = 0; S < 27; S++) {\n        State begin = s.begin();\n        if (formula(begin, S) == 2) ans++;\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    while (cin >> s) {\n        if (s == \".\") break;\n        solve(s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint P,Q,R;\nchar *p;\n\nint formula(){\n  int l,r;\n  char c = *p++;\n  if(isdigit(c)) return c-'0';\n  if(isupper(c)) return (c == 'P' ? P : c == 'Q' ? Q : R);\n  if(c == '-') return 2-formula();\n  if(c == '('){\n    l = formula();\n    if(*p++ == '*'){\n      r = formula();\n      *p++;\n      return (l < r ? l : r);\n    }else{\n      r = formula();\n      *p++;\n      return (l > r ? l : r);\n    }  \n  }\n  return 0;\n}\n\nint main(){\n  int ans;\n  char s[100];\n  while(scanf(\"%s\",s), s[0] != '.'){\n    ans = 0; \n    for(P = 0 ; P < 3 ; P++){\n      for(Q = 0 ; Q < 3 ; Q++){\n        for(R = 0 ; R < 3 ; R++){\n          p = s;\n          if(formula() == 2) ans++;\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint nottable[3] = { 2,1,0 };\nint andtable[3][3] = { {0,0,0},{0,1,1},{0,1,2} };\nint ortable[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\nchar tochar(int num) {\n\tif (num == 0) {\n\t\treturn '0';\n\t}\n\telse if (num == 1) {\n\t\treturn '1';\n\t}\n\telse {\n\t\treturn '2';\n\t}\n}\n\nint solve(string::iterator& iter)\n{\n\tint ret;\n\n\tif (*iter == '0') {\n\t\tret = 0;\n\t}\n\telse if (*iter == '1') {\n\t\tret = 1;\n\t}\n\telse if (*iter == '2') {\n\t\tret = 2;\n\t}\n\telse if (*iter == '-') {\n\t\titer++;\n\t\treturn nottable[solve(iter)];\n\t}\n\telse if (*iter == '(') {\n\t\titer++;\n\t\tret = solve(iter);\n\t\t\n\t\tif (*iter == '+') {\n\t\t\titer++;\n\t\t\tret = ortable[ret][solve(iter)];\n\t\t}\n\t\telse if (*iter == '*') {\n\t\t\titer++;\n\t\t\tret = andtable[ret][solve(iter)];\n\t\t}\n\t}\n\n\titer++;\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (str == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\tstring temp = str;\n\n\t\t\t\t\tfor (int l = 0; l < temp.size(); l++) {\n\t\t\t\t\t\tif (temp[l] == 'P') {\n\t\t\t\t\t\t\ttemp[l] = tochar(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'Q') {\n\t\t\t\t\t\t\ttemp[l] = tochar(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'R') {\n\t\t\t\t\t\t\ttemp[l] = tochar(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (solve(temp.begin()) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nchar tmp[100];\nint place;\n\nint m_minus(int num){\n\treturn 2 - num;\n}\n\nint m_op(int a,int b,char c){\n\tif(c == '*')return a & b;\n\telse return a | b;\n}\n\nint dfs(){\n\tif(tmp[place] == '-'){\n\t\tplace++;\n\t\treturn m_minus(dfs());\n\t}\n\telse if(tmp[place] == '('){\n\t\tplace++;\n\t\tint a = dfs();\n\t\tchar c = tmp[place];\n\t\tplace++;\n\t\tint b = dfs();\n\t\tplace++;\n\t\treturn m_op(a,b,c);\n\t}\n\telse{\n\t\tint ret = tmp[place] - '0';\n\t\tplace++;\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\t\n\tstring str;\n\twhile(cin >> str,str[0] != '.'){\t\t\t\n\t\tint ans = 0;\n\t\t\n\t\tREP(i,3){\n\t\t\tREP(j,3){\n\t\t\t\tREP(k,3){\n\t\t\t\t\tREP(l,str.size()){\n\t\t\t\t\t\tif(str[l] == 'P'){\n\t\t\t\t\t\t\ttmp[l] = '0' + i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(str[l] == 'Q'){\n\t\t\t\t\t\t\ttmp[l] = '0' + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(str[l] == 'R'){\n\t\t\t\t\t\t\ttmp[l] = '0' + k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse tmp[l] = str[l];\n\t\t\t\t\t}\n\t\t\t\t\tplace = 0;\n\t\t\t\t\tif(dfs() == 2){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_VAL 26\n\nstd::string ReplaceString(std::string& subject, const std::string& search,\n                          const std::string& replace) {\n    size_t pos = 0;\n    while ((pos = subject.find(search, pos)) != std::string::npos) {\n         subject.replace(pos, search.length(), replace);\n         pos += replace.length();\n    }\n    return subject;\n}\n\nint main() {\n    string expr;\n    while (getline(cin, expr), expr != \".\") {\n        ReplaceString(expr, \"--\", \"\");\n\n        string expr_copy = expr;\n        int count = 0;\n        for (int v = 0; v <= 26; v++) {\n            expr = expr_copy;\n            int w = v;\n            int p = w % 3; w /= 3;\n            int q = w % 3; w /= 3;\n            int r = w % 3; w /= 3;\n\n            REP(i, expr.size()) {\n                switch (expr[i]) {\n                case 'P':\n                    expr[i] = '0' + p;\n                    break;\n                case 'Q':\n                    expr[i] = '0' + q;\n                    break;\n                case 'R':\n                    expr[i] = '0' + r;\n                    break;\n                }\n            }\n\n            while (expr.size() > 1) {\n                stack<int> parens;\n                REP(i, expr.size()) {\n                    // NOT\n                    ReplaceString(expr, \"-0\", \"2\");\n                    ReplaceString(expr, \"-1\", \"1\");\n                    ReplaceString(expr, \"-2\", \"0\");\n                    if (expr[i] == '(') {\n                        parens.push(i);\n                        continue;\n                    } else if (expr[i] == ')') {\n                        int j = parens.top(); parens.pop();\n                        int a = expr[j+1] - '0';\n                        int b = expr[j+3] - '0';\n                        string ret;\n                        if (expr[j+2] == '+') {\n                            // OR\n                            if (a == b) ret = a + '0';\n                            else ret = a + b >= 2 ? \"2\" : \"1\";\n                        } else {\n                            // AND\n                            if (a == 2 && b == 2) ret = \"2\";\n                            else ret = a * b > 0 ? \"1\" : \"0\";\n                        }\n                        string e = string(expr.begin() + j, expr.begin() + i + 1);\n                        ReplaceString(expr, e, ret);\n                        break;\n                    }\n                }\n            }\n\n            if (expr == \"2\") {\n                count++;\n            }\n        }\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//たぶんO(NlogN)の構文解析\n#include <iostream>\n#include <string>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint NOT[3] = {2, 1, 0};\nint AND[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint OR[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\nstring s;\nint P, Q, R;\n\nint dfs(int l, int r) {\n\tif (s[l] == '0') return 0;\n\tif (s[l] == '1') return 1;\n\tif (s[l] == '2') return 2;\n\tif (s[l] == 'P') return P;\n\tif (s[l] == 'Q') return Q;\n\tif (s[l] == 'R') return R;\n\tif (s[l] == '-') return NOT[dfs(l + 1, r)];\n\t\n\tint lc = l, cntl = 0;\n\tint rc = r - 1, cntr = 0;\n\tint it = -1;\n\twhile (lc <= rc) {\n\t\tif (s[lc] == '(') cntl++;\n\t\tif (s[lc] == ')') cntl--;\n\t\tif (s[lc] == '+' && cntl == 1) { it = lc; break; }\n\t\tif (s[lc] == '*' && cntl == 1) { it = lc; break; }\n\t\tlc++;\n\t\t\n\t\tif (s[rc] == '(') cntr--;\n\t\tif (s[rc] == ')') cntr++;\n\t\tif (s[rc] == '+' && cntr == 1) { it = rc; break; }\n\t\tif (s[rc] == '*' && cntr == 1) { it = rc; break; }\n\t\trc--;\n\t}\n\t\n\tint res1 = dfs(l + 1, it);\n\tint res2 = dfs(it + 1, r - 1);\n\tif (s[it] == '*') return AND[res1][res2];\n\treturn OR[res1][res2];\n}\n\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \".\") break;\n\t\tint ans = 0;\n\t\tP = Q = R = 0;\n\t\trep(P, 3) rep(Q, 3) rep(R, 3) if (dfs(0, s.length()) == 2) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\nusing State = string::const_iterator;\n\nint factor(State& begin);\n\nvoid consume(State &begin, char expected){\n\tif(*begin==expected)begin++;\n\telse{\n\t\tcerr << \"expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is'\";\n\t\twhile(*begin)cerr << *begin++;\n\t\tcerr << \"'\" << endl;\n\t\texit(0);\n\t}\n}\n\n\nint reverse(int a){\n\tif(a==2)return 0;\n\telse if(a==0)return 2;\n\telse return 1;\n}\n\nint number(State& begin){\n\tint ret = (int)(*begin - '0');\n\tbegin++;\n\treturn ret;\n}\n\nint expression(State& begin){\n\tint ret = factor(begin);\n\treturn ret;\n}\n\nint term(State& begin){\n\tint ret = factor(begin);\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tint ret2 = factor(begin);\n\t\t\tret = max(ret,ret2);\n\t\t}else if(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tint ret2 = factor(begin);\n\t\t\tret = min(ret,ret2);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint factor(State& begin){\n\tint ret;\n\tif(*begin == '-'){\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\treturn reverse(ret);\n\t}else if(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tret = term(begin);\n\t\tconsume(begin,')');\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tstring s;\n\twhile(cin>>s,s[0]!='.'){\n\t\tint ct = 0;\n\t\tREP(P,3){\n\t\t\tREP(Q,3){\n\t\t\t\tREP(R,3){\n\t\t\t\t\tstring tmps = s;\n\t\t\t\t\treplace(tmps.begin(),tmps.end(),'P',(char)('0' + P));\n\t\t\t\t\treplace(tmps.begin(),tmps.end(),'Q',(char)('0' + Q));\n\t\t\t\t\treplace(tmps.begin(),tmps.end(),'R',(char)('0' + R));\n\t\t\t\t\tState start = tmps.begin();\n\t\t\t\t\tif(expression(start) == 2)ct++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ct << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::iterator State;\ntypedef map<char, int> Env;\n\nint formula(State& state, Env env) {\n    if ('0' <= *state && *state <= '2') {\n        return *state++ - '0';\n    }\n\n    if ('P' <= *state && *state <= 'R') {\n        return env[*state++];\n    }\n\n    if (*state == '-') {\n        ++state;\n        return 2 - formula(state, env);\n    }\n\n    ++state; // '('\n    int lhs = formula(state, env);\n    char op = *state++;\n    int rhs = formula(state, env);\n    ++state; // ')'\n\n    if (op == '+') {\n        return max(lhs, rhs);\n    } else if (op == '*') {\n        return min(lhs, rhs);\n    }\n\n    assert(false);\n}\n\n\nint main() {\n    string expr;\n    Env env;\n    while (true) {\n        cin >> expr;\n\n        if (expr == \".\") {\n            break;\n        }\n\n        int count = 0;\n\n        for (int j = 0; j < 27; ++j) {\n            env['P'] = j % 3;\n            env['Q'] = (j / 3) % 3;\n            env['R'] = j / 9;\n\n            State state = expr.begin();\n            if (formula(state, env) == 2) {\n                ++count;\n            }\n        }\n        \n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstring in;\nint pos;\nint p,q,r;\n\nint formula(){\n  if(isdigit(in[pos])){\n    return in[pos++]-'0';\n  }\n\n  switch(in[pos]){\n  case 'P':++pos; return p;\n  case 'Q':++pos; return q;\n  case 'R':++pos; return r;\n  }\n\n  if(in[pos]=='-'){\n    ++pos;\n    return 2-formula();\n  }\n  ++pos;\n  int a=formula();\n  char cc=in[pos++];\n  int b=formula();\n  pos++;\n  if(cc=='+'){\n    if(a==2 || b==2)return 2;\n    if(!a && !b)return 0;\n    return 1;\n  }\n  if(!a || !b)return 0;\n  if(a==2 && b==2)return 2;\n  return 1;\n}\n\n\nmain(){\n  while(cin>>in){\n    if(in==\".\")break;\n    int ans=0;\n    for(p=0;p<3;p++)for(q=0;q<3;q++)for(r=0;r<3;r++){\n      pos=0;\n      if(formula()==2)++ans;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring str;\n\nvoid a() {\n  for(int i = 0; i < str.length(); ++i) {\n    if(str[i] != '-') continue;\n    int j;\n    for(j = i+1; j < str.length() && str[j] == '-'; ++j);\n    if(j == i+1) continue;\n    if((j-i) % 2 == 0)\n      str = str.substr(0, i) + str.substr(j, str.length()-j);\n    else\n      str = str.substr(0, i+1) + str.substr(j, str.length()-j);\n  }\n}\n\nvoid b(string &s) {\n  for(int i = 0; i < s.length(); ++i) {\n    if(s[i] == '-') {\n      s = s.substr(0, i) + s.substr(i+1, s.length()-(i+1));\n      s[i] = '2'-(s[i]-'0');\n    }\n  }\n}\n\nint rec(string &, int);\nint rec2(string &, int);\nint rec3(string &, int);\nint pos;\n\nint rec2(string &s, int ans) {\n  int tmp = pos++;\n  if(tmp < s.length()) {\n    if(s[tmp] == '*') {\n      int aaa;\n      if(s[tmp+1] == '(') aaa = rec(s, 0);\n      else                aaa = s[tmp+1] - '0';\n      pos += 1;\n      return min(ans, aaa);\n    } else if(s[tmp] == '+') {\n      int aaa;\n      if(s[tmp+1] == '(') aaa = rec(s, 0);\n      else                aaa = s[tmp+1] - '0';\n      pos += 1;\n      return max(ans, aaa);\n    }\n  }\n  return ans;\n}\n\nint rec(string &s,  int ans) {\n  int tmp = pos++;\n  if(tmp < s.length() && s[tmp] == '(') {\n    int aaa = rec(s, ans);\n    return rec2(s, aaa);\n  }\n  return rec2(s, s[tmp]-'0');\n}\n\nint solve() {\n  int cnt = 0;\n  a();\n  for(char p = '0'; p <= '2'; ++p) {\n    for(char q = '0'; q <= '2'; ++q) {\n      for(char r = '0'; r <= '2'; ++r) {\n\tstring tmp = str;\n\tfor(int i = 0; i < tmp.length(); ++i) {\n\t  if(tmp[i] == 'P') tmp[i] = p;\n\t  if(tmp[i] == 'Q') tmp[i] = q;\n\t  if(tmp[i] == 'R') tmp[i] = r;\n\t}\n\tpos = 0;\n\tb(tmp);\n\tif(rec(tmp, 0) == 2) {\n\t  //cout << tmp << endl;\n\t  cnt++;\n\t}\n      }\n    }\n  }\n  return cnt;\n}\n\nmain() {\n  while((cin >> str) && str != \".\") {\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nstring str;\n\nint deny[3] = {2,1,0};\nint mult[3][3] = {{0,0,0},\n\t\t  {0,1,1},\n\t\t  {0,1,2}};\n\nint add[3][3] = {{0,1,2},\n\t\t {1,1,2},\n\t\t {2,2,2}};\n\nstring make(string s, int p, int q, int r){\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == 'P') s[i] = p+'0';\n    if(s[i] == 'Q') s[i] = q+'0';\n    if(s[i] == 'R') s[i] = r+'0';\n  }\n\n  return s;\n}\n\nint solve(string s){\n  if(s.length() == 1) return s[0]-'0';\n\n  //cout << s << endl;\n\n  if(s[0] == '-'){\n    string next = \"\";\n    for(int i = 1; i < s.length(); i++)\n      next+=s[i];\n    return deny[solve(next)];\n  }\n\n  if(s[0] == '('){\n    string a = \"\", b = \"\";\n    int pos = 1;\n\n    int par = 0;\n\n    while(s[pos] != '*' && s[pos] != '+' || par){\n      a += s[pos];\n      if(s[pos] == '(') par++;\n      if(s[pos] == ')') par--;\n      pos++;\n    }\n\n    int ismul = false;\n    if(s[pos++] == '*') ismul = true;\n\n    while(pos < s.length()-1){\n      b += s[pos++];\n    }\n   \n    if(ismul) return mult[solve(a)][solve(b)];\n    else return add[solve(a)][solve(b)];\n  }\n}\n\nint main(){\n  while(cin >> str && str != \".\"){\n    int ans = 0;\n   \n    for(int P = 0; P <= 2; P++)\n      for(int Q = 0; Q <= 2; Q++)\n\tfor(int R = 0; R <= 2; R++){\n\t  string s = make(str,P,Q,R);\n\t  if(solve(s) == 2) ans++;\n\t}\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#define or(a,b) a > b ? a : b\n#define and(a,b) a > b ? b : a\n#define not(n) 1 - (n - 1)\n\nint p[3];\nchar str[81];\n\nint formula(int i){\n\tif(isupper(str[i]))\n\t\treturn p[str[i] - 'P'];\n\telse if(isdigit(str[i]))\n\t\treturn str[i] - '0';\n\telse if(str[i] == '-')\n\t\treturn not(formula(i + 1));\n\telse if(str[i] == '('){\n\t\tint j = i;\n\t\tint cen = 0;\n\t\twhile(1){\n\t\t\tif(str[++j] == '(')\n\t\t\t\tcen++;\n\t\t\telse if(str[j] == ')')\n\t\t\t\tcen--;\n\t\t\tif(cen == 0 && (str[j] == '*' || str[j] == '+')){\n\t\t\t\tif(str[j] == '*')\n\t\t\t\t\treturn and(formula(i + 1),formula(j + 1));\n\t\t\t\telse\n\t\t\t\t\treturn or(formula(i + 1),formula(j + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint count,locate;\n\tgets(str);\n\twhile(str[0] != '.'){\n\t\tstr[strlen(str)] = '\\0';\n\t\tcount = 0;\n\t\tfor(p[0] = 0;p[0] <= 2;p[0]++){\n\t\t\tfor(p[1] = 0;p[1] <= 2;p[1]++){\n\t\t\t\tfor(p[2] = 0;p[2] <= 2;p[2]++){\n\t\t\t\t\tif(formula(0) == 2)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t\tgets(str);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstring s;\nint i,j,k,p,ans;\n\nint calc(){\n  char c=s[p++];\n  if('0'<=c&&c<='9')return (c-'0');\n  else if(c=='P')return i;\n  else if(c=='Q')return j;\n  else if(c=='R')return k;\n  else if(c=='-'){\n    return 2-calc();\n  }else if(c=='('){\n    int a=calc();\n    char ch=s[p++];\n    int b=calc();\n    p++;\n    if(ch=='*')return min(a,b);\n    else if(ch=='+')return max(a,b);\n  }\n  return 0;\n}\n\n\nvoid solve(){\n  p=0;\n  if(calc()==2)ans++;\n}\nint main(){\n  while(1){\n    cin>>s;\n    if(s==\".\")break;\n    ans=0;\n    for(i=0;i<3;i++)\n      for(j=0;j<3;j++)\n\tfor(k=0;k<3;k++)\n\t  solve();\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct node_t\n{\n\tvirtual int eval(int p, int q, int r) = 0;\n};\n\nstruct lit : public node_t\n{\n\tconst int val;\n\n\tlit(int v) : val(v) { }\n\tint eval(int p, int q, int r) { return val; }\n};\n\nstruct var : public node_t\n{\n\tconst char name;\n\n\tvar(char name) : name(name) { }\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn name == 'P' ? p : (name == 'Q' ? q : r);\n\t}\n};\n\nstruct not : public node_t\n{\n\tnode_t *x;\n\n\tnot(node_t *x) : x(x) { }\n\t~not()\n\t{\n\t\tdelete x;\n\t}\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn 2 - x->eval(p, q, r);\n\t}\n};\n\nstruct or : public node_t\n{\n\tnode_t *x, *y;\n\n\tor(node_t *x, node_t *y) : x(x), y(y) { }\n\t~or()\n\t{\n\t\tdelete x;\n\t\tdelete y;\n\t}\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn max(x->eval(p, q, r), y->eval(p, q, r));\n\t}\n};\n\nstruct and : public node_t\n{\n\tnode_t *x, *y;\n\n\tand(node_t *x, node_t *y) : x(x), y(y) { }\n\t~and()\n\t{\n\t\tdelete x;\n\t\tdelete y;\n\t}\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn min(x->eval(p, q, r), y->eval(p, q, r));\n\t}\n};\n\nstatic string s;\nstatic int p;\n\nbool end() { return p >= s.length(); }\nchar peek() { return s[p]; }\nvoid succ() { if (!end()) p++; }\n\nnode_t *fomula()\n{\n\tchar c = peek();\n\tif ('0' <= c && c <= '2')\n\t{\n\t\tsucc();\n\t\treturn new lit(c - '0');\n\t}\n\telse if ('P' <= c && c <= 'R')\n\t{\n\t\tsucc();\n\t\treturn new var(c);\n\t}\n\telse if (c == '-')\n\t{\n\t\tsucc();\n\t\treturn new not(fomula());\n\t}\n\telse if (c == '(')\n\t{\n\t\tsucc();\n\t\tnode_t *x = fomula();\n\t\tchar op = peek(); succ();\n\t\tnode_t *y = fomula();\n\t\tsucc(); // ')'\n\t\tif (op == '+') return new or(x, y);\n\t\telse return new and(x, y);\n\t}\n}\n\nnode_t *parse_fomula()\n{\n\tp = 0;\n\treturn fomula();\n}\n\nint main()\n{\n\twhile(cin>>s, s != \".\")\n\t{\n\t\tnode_t *e = parse_fomula();\n\n\t\tint c = 0;\n\t\tfor (int p = 0; p <= 2; p++)\n\t\t{\n\t\t\tfor (int q = 0; q <= 2; q++)\n\t\t\t{\n\t\t\t\tfor (int r = 0; r <= 2; r++)\n\t\t\t\t{\n\t\t\t\t\tif (e->eval(p, q, r) == 2) c++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\n\t\tdelete e;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint nottable[3] = { 2,1,0 };\nint andtable[3][3] = { {0,0,0},{0,1,1},{0,1,2} };\nint ortable[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\nchar tochar(int num) {\n\tif (num == 0) {\n\t\treturn '0';\n\t}\n\telse if (num == 1) {\n\t\treturn '1';\n\t}\n\telse {\n\t\treturn '2';\n\t}\n}\n\nint solve(string::iterator& iter)\n{\n\tint ret;\n\n\tif (*iter == '0') {\n\t\tret = 0;\n\t}\n\telse if (*iter == '1') {\n\t\tret = 1;\n\t}\n\telse if (*iter == '2') {\n\t\tret = 2;\n\t}\n\telse if (*iter == '-') {\n\t\titer++;\n\t\treturn nottable[solve(iter)];\n\t}\n\telse if (*iter == '(') {\n\t\titer++;\n\t\tret = solve(iter);\n\t\t\n\t\tif (*iter == '+') {\n\t\t\titer++;\n\t\t\tret = ortable[ret][solve(iter)];\n\t\t}\n\t\telse if (*iter == '*') {\n\t\t\titer++;\n\t\t\tret = andtable[ret][solve(iter)];\n\t\t}\n\t}\n\n\titer++;\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (str == \".\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\tstring temp = str;\n\n\t\t\t\t\tfor (int l = 0; l < temp.size(); l++) {\n\t\t\t\t\t\tif (temp[l] == 'P') {\n\t\t\t\t\t\t\ttemp[l] = tochar(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'Q') {\n\t\t\t\t\t\t\ttemp[l] = tochar(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp[l] == 'R') {\n\t\t\t\t\t\t\ttemp[l] = tochar(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tstring::iterator iter = temp.begin();\n\n\t\t\t\t\tif (solve(iter) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint mul(int X,int Y){\n  if(X == 0 || Y == 0)return 0;\n  if(X == 1 || Y == 1)return 1;\n  if(X == 2)return Y;\n  assert(false);\n}\n\nint add(int X,int Y){\n  if(X == 0)return Y;\n  if(X == 1 && (Y == 0 || Y == 1))return 1;\n  if(X == 1)return 2; \n  if(X == 2)return 2;\n  assert(false);\n}\n\nint sub(int X){\n  if(X == 0)return 2;\n  if(X == 2)return 0;\n  return 1;\n}\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }\n    else if(parse[pos] == '-'){\n      int p = 0;     \n      int cnt=0;\n      while(parse[pos] == '-'){      \n\tcnt++,pos++;\n      }\n\t//cout << \"cnt = \" << cnt << \" parse = \" << parse[pos]<< endl;\n      p = parse[pos]-'0';\n      pos++;\n      rep(i,cnt){\n\tp = sub(p);\n\t//cout << \"p = \" << p << endl;\n\t}\n      //cout <<\"p = \" << p << endl;\n      return p;\n      \n    }else{\n      int p = 0;\n     \n      while('0' <= parse[pos] && parse[pos] <= '2'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n\n  int term(){\n    int p = fact();\n    return p;\n  }\n \n\n  int expression(){\n    int p = term();\n    //cout << \"X = \"<< p << endl;\n    while(parse[pos] == '+' || parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \" <<q << endl;\n\tp = mul(p,q);\n      }\n      else if(parse[pos] == '+'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \"<< q << endl;\n\tp = add(p,q);\n      }\n    }\n    return p;\n  }\n\n\n};\n\nint ans,last;\nstring s;\n/*\nvoid rec(int now){\n  \n  bool ok = true;\n  for(int i=now;i<s.length();i++){\n    if(s[i] == 'P' || s[i] == 'Q' || s[i] == 'R'){\n      ok = false;\n      break;\n    }\n  }\n  if(ok){\n    Parsing par = Parsing(s);\n    int res = par.expression();\n    cout << s  << \" = \" << res << endl;\n    if(res == 2)ans++;\n    return;\n  }\n  \n  //if(now == last){\n  //cout << \"ok\"<< endl;\n  //}\n\n  for(int i=now;i<s.length();i++){\n    if(s[i] == 'P' || s[i] == 'Q' || s[i] == 'R'){\n      char pre = s[i];\n      s[i] = '0';\n      rec(now);\n      s[i] = '1';\n      rec(now);\n      s[i] = '2';\n      rec(now);\n      s[i] = pre;\n    }\n  }\n\n}\n*/\n\nvoid draw(char P,char Q,char R){\n  string pre = s;\n  rep(i,s.length()){\n    if(s[i] == 'P')s[i] = P;\n    else if(s[i] == 'Q')s[i] = Q;\n    else if(s[i] == 'R')s[i] = R;\n  }\n  Parsing par = Parsing(s);\n  if(par.expression() == 2)ans++;\n  s = pre;\n}\n\nvoid test(){\n\n  for(char i='0';i<='2';i++){\n    for(char j='0';j<='2';j++){\n      for(char k='0';k<='2';k++){\n\tdraw(i,j,k);\n      }\n    }\n  }\n\n\n}\n\n\nint main(){\n \n  \n  while(true){\n    cin >> s;\n    if(s == \".\")break;\n    ans = 0;\n    bool nise = true;\n    for(int i=0;i<s.length();i++)\n      if(s[i] == 'P' || s[i] == 'Q' || s[i] == 'R'){\n\tnise = false;\n\tlast = i;\n      }\n    if(nise){\n      Parsing par = Parsing(s);      \n      if(par.expression() == 2)cout << 27 << endl;\n      else cout << 0 << endl;\n      continue;\n    }\n    //rec(0);\n    test();\n    cout << ans << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nstring s;\nint state[3], ind;\n\nint parse(){\n  while(s[ind]==')') ind++;\n  if(s[ind]=='0'||s[ind]=='1'||s[ind]=='2'){\n    return (int)(s[ind]-'0');\n  }\n  if(s[ind]=='P'||s[ind]=='Q'||s[ind]=='R'){\n    return state[s[ind]-'P'];\n  }\n  if(s[ind]=='*') return 1;\n  if(s[ind]=='+') return 2;\n\n  if(s[ind]=='-'){\n    pair< int, pair<int,int> > p;\n    ind++;\n    p.second.first = parse();\n    p.first = 0;\n    if(p.second.first == 0) return 2;\n    if(p.second.first == 1) return 1;\n    if(p.second.first == 2) return 0;\n  }\n  if(s[ind]=='('){\n    pair< int, pair<int,int> > p;\n    ind++;\n    p.second.first = parse();\n    ind++;\n    p.first = parse();\n    ind++;\n    p.second.second = parse();\n    if(p.first == 1){\n      if(p.second.first==0 || p.second.second==0) return 0;\n      else if(p.second.first==2 && p.second.second==2) return 2;\n      else return 1;\n    }else if(p.first == 2){\n      if(p.second.first==2 || p.second.second==2) return 2;\n      else if(p.second.first==0 && p.second.second==0) return 0;\n      else return 1;\n    }\n  }\n  return -999999;\n}\n\nint main() {\n  while(1){\n    cin>>s;\n    if(s==\".\") break;\n    int cnt = 0;\n    /*(0,0,0)~(1,1,1)*/\n    REP(pi,0,3){\n      REP(qi,0,3){\n        REP(ri,0,3){\n          state[0]=pi; state[1]=qi; state[2]=ri;\n          ind = 0;\n          if(parse() == 2) cnt++;\n        }\n      }\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define pb  push_back \n#define rep(i,n) for(int i=0; i<(n);i++)\nusing namespace std;\n\nint mapper[256] = {};\n\nint formula(const string& s, int& i) {\n  char c = s[i++];\n  int v,v2;\n  switch(c) {\n  case '0':\n  case '1':\n  case '2': return c -'0';\n  case 'P':\n  case 'Q':\n  case 'R': return mapper[c];\n  case '-':\n    v = formula(s,i);\n    return (-v+2)%3;\n  case '(':\n    v = formula(s,i);\n    char op = s[i++];\n    v2 = formula(s,i);\n    i++;\n    if (op=='*') {\n      return min(v, v2);\n    } else {\n      return max(v, v2);\n    }\n  }\n  return 0;\n}\n\nint main(){\n  string s;\n  while(cin>>s,s!=\".\") {\n\n    int count = 0;\n    rep(p,3) rep(q,3) rep(r,3) {\n      int i = 0;\n      mapper['P'] = p;\n      mapper['Q'] = q;\n      mapper['R'] = r;\n      if (formula(s,i) == 2) {\n\t//cout << \"ok \" << p << q << r << endl;\n\tcount++;\n      }\n    }\n    cout << count << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tr = 2-r;\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tl = 2-l;\n\t\t\tst.pop();\n\t\t\t\n\t\t\tint tmp;\n\t\t\tif(o == '*')\n\t\t\t\tst.push((char)(AND[r][l]+'0'));\n\t\t\telse\n\t\t\t\tst.push((char)(OR[r][l]+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\n\tchar ans = st.top();\n\tst.pop();\n\n\tif(!st.empty()){\n\t\tint m;\n\t\tfor(m=0; !st.empty(); m++)\n\t\t\tst.pop();\n\t\tif(m%2)\n\t\t\tans = (char)((2-(ans-'0'))+'0');\n\t}\n\n\tif(ans == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nconst int not_res[3] = { 2,1,0 };\nconst int and_res[3][3] = {\n    { 0,0,0 },\n    { 0,1,1 },\n    { 0,1,2 }\n};\nconst int or_res[3][3] = {\n    { 0,1,2 },\n    { 1,1,2 },\n    { 2,2,2 }\n};\n\n\nvoid solve(string s) {\n    const int n = s.size();\n    dump(s,n);\n    int ans = 0;\n    rep (P,3) rep (Q,3) rep (R,3) {\n        def (eval, int &i) -> int {\n            char cur = s[i++];\n            if (cur == '0') return 0;\n            if (cur == '1') return 1;\n            if (cur == '2') return 2;\n            if (cur == 'P') return P;\n            if (cur == 'Q') return Q;\n            if (cur == 'R') return R;\n            if (cur == '-') return not_res[eval(i)];\n            assert(cur == '(');\n            int x = eval(i);\n            char op = s[i++];\n            assert(op == '*' || op == '+');\n            int y = eval(i);\n            char close = s[i++];\n            assert(close == ')');\n            if (op == '*') {\n                return and_res[x][y];\n            } else {\n                return or_res[x][y];\n            }\n        };\n\n        int i = 0;\n        if (eval(i) == 2) {\n            dump(P,Q,R);\n            ans++;\n        }\n        assert(i == n);\n    }\n\n    cout << ans << \"\\n\";\n\n}\n\nint32_t main() {\n    while (true) {\n        string s; cin >> s;\n        if (s == \".\") break;\n        solve(s);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint inv(int a) {\n\treturn 2 - a;\n}\nint mul(int a, int b) {\n\tif (a == 0 || b == 0)return 0;\n\tif (a == 1 || b == 1)return 1;\n\treturn 2;\n}\nint add(int a, int b) {\n\tif (a == 2 || b == 2)return 2;\n\tif (a == 1 || b == 1)return 1;\n\treturn 0;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s) {\n\t\tif (s == \".\")break;\n\t\tint len = s.length();\n\t\tint out = 0; int cnt;\n\t\trep(i, 3) {\n\t\t\trep(j, 3) {\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tint sum[100] = {}; vector<char> ope[100];\n\t\t\t\t\trep(l, len) {\n\t\t\t\t\t\tif (s[l] == '(')cnt++;\n\t\t\t\t\t\telse if (s[l] == ')') {\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\tint res = sum[cnt + 1];\n\t\t\t\t\t\t\tint r = ope[cnt].size();\n\t\t\t\t\t\t\tper(x, r) {\n\t\t\t\t\t\t\t\tif (ope[cnt][x] == '-') {\n\t\t\t\t\t\t\t\t\tres = inv(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ope[cnt][x] == '+') {\n\t\t\t\t\t\t\t\t\tres = add(res, sum[cnt]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tres = mul(res, sum[cnt]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum[cnt] = res;\n\t\t\t\t\t\t\tope[cnt].clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ('0' <= s[l] && s[l] <= '2') {\n\t\t\t\t\t\t\tint r = ope[cnt].size();\n\t\t\t\t\t\t\tint res=s[l]-'0';\n\t\t\t\t\t\t\tper(x, r) {\n\t\t\t\t\t\t\t\tif (ope[cnt][x] == '-') {\n\t\t\t\t\t\t\t\t\tres = inv(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ope[cnt][x] == '+') {\n\t\t\t\t\t\t\t\t\tres = add(res, sum[cnt]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tres = mul(res, sum[cnt]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum[cnt] = res;\n\t\t\t\t\t\t\tope[cnt].clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[l] == 'P' || s[l] == 'Q' || s[l] == 'R') {\n\t\t\t\t\t\t\tint r = ope[cnt].size();\n\t\t\t\t\t\t\tint res;\n\t\t\t\t\t\t\tif (s[l] == 'P')res = i;\n\t\t\t\t\t\t\telse if (s[l] == 'Q')res = j;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tres = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tper(x, r) {\n\t\t\t\t\t\t\t\tif (ope[cnt][x] == '-') {\n\t\t\t\t\t\t\t\t\tres = inv(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ope[cnt][x] == '+') {\n\t\t\t\t\t\t\t\t\tres = add(res, sum[cnt]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tres = mul(res, sum[cnt]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum[cnt] = res;\n\t\t\t\t\t\t\tope[cnt].clear();\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tope[cnt].push_back(s[l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sum[0] == 2)out++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n\nint lminus(int f){\n\treturn -(f-2);\n}\n\nint lprod(int f1, int f2){\n\tif(f1 == 0 || f2 == 0) return 0;\n\tif(f1 == 1 || f2 == 1) return 1;\n\treturn 2;\n}\n\nint lplus(int f1, int f2){\n\tif(f1 == 2 || f2 == 2) return 2;\n\tif(f1 == 1 || f2 == 1) return 1;\n\treturn 0;\n}\n\n\nint evaluate(string s){\n\tif(s.size() == 0) return 0;\n\n\tif(s.size() == 1){\n\t\treturn s[0] - '0';\n\t}\n\n\tif(s[0] == '-'){\n\t\treturn lminus(evaluate(s.substr(1)));\n\t}\n\n\tif(s[0] == '('){\n\t\tint f1begin = 1, f1len;\n\t\tint f2begin, f2len;\n\n\t\tint i = 1;\n\t\tint nest = 1;\n\t\tchar c = ' ';\n\t\tfor(i = 1; ; i++){\n\t\t\tif(nest == 1){\n\t\t\t\tif( s[i] == '*' ){\n\t\t\t\t\tc = '*';\n\t\t\t\t\tf1len = i-1;\n\t\t\t\t\tf2begin = i+1;\n\t\t\t\t}\n\t\t\t\tif( s[i] == '+' ){\n\t\t\t\t\tc = '+';\n\t\t\t\t\tf1len = i-1;\n\t\t\t\t\tf2begin = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s[i] == ')') nest--;\n\t\t\tif(s[i] == '(') nest++;\n\t\t\tif(nest == 0)break;\n\t\t}\n\t\tf2len = i - f2begin;\n\n\t\tif(c == '*') return lprod(evaluate(s.substr(f1begin, f1len)), evaluate(s.substr(f2begin, f2len)));\n\t\tif(c == '+') return lplus(evaluate(s.substr(f1begin, f1len)), evaluate(s.substr(f2begin, f2len)));\n\t\treturn -1;\n\t}\n\n}\n\nstring repl(const string &s, char from, char to){\n\tstring t = s;\n\trep(i, t.size()){\n\t\tif(t[i] == from) t[i] = to;\n\t}\n\treturn t;\n}\n\nint main(){\n\tstring s;\n\n\twhile(cin >> s, !(s.size() == 1 && s[0] == '.')){\n\t\tint cnt = 0;\n\n\t\tfor(char i = '0'; i <= '2'; i++){\n\t\t\tfor(char j = '0'; j <= '2'; j++){\n\t\t\t\tfor(char k = '0'; k <= '2'; k++){\n\t\t\t\t\tcnt += (evaluate(repl(repl(repl(s, 'P', i), 'Q', j), 'R', k)) == 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<int,P>Q;\n#define fi first\ntypedef long long ll;\n#define sc second\n\nstring s;\nint n;\nint rec(int L,int R,int a,int b,int c){\n\tint xx[3]={a,b,c};\n\tif('0'<=s[L] && s[L] <= '2') return s[L]-'0';\n\tif('P'<=s[L] && s[L] <= 'R') return xx[s[L]-'P'];\n\tif(s[L] == '-') return 2 - rec(L+1,R,a,b,c);\n\tint dep = 0;\n\tfor(int i=L+1;i<R;i++){\n\t\tif(s[i] == '(') dep++;\n\t\telse if(s[i] == ')') dep--;\n\t\telse if(dep == 0 && s[i] == '*'){\n\t\t\tint ll = rec(L+1,i-1,a,b,c);\n\t\t\tint rr = rec(i+1,R-1,a,b,c);\n\t\t\tif(ll == 0  || rr == 0) return 0;\n\t\t\telse if(ll==2&&rr==2) return 2;\n\t\t\telse return 1;\n\t\t}\n\t\telse if(dep == 0 && s[i] == '+'){\n\t\t\tint ll = rec(L+1,i-1,a,b,c);\n\t\t\tint rr = rec(i+1,R-1,a,b,c);\n\t\t\tif(ll==0&&rr==0) return 0;\n\t\t\telse if(ll<=1&&rr<=1) return 1;\n\t\t\telse return 2;\n\t\t}\n\t}\n\tassert(0);\n}\nint main(){\n\twhile(1){\n\t\tcin>>s;n=s.size();if(s==\".\")return 0;\n\t\tint ans =0;\n\t\trep(i,3)rep(j,3)rep(k,3) ans += rec(0,n-1,i,j,k) == 2;\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint mul(int X,int Y){\n  if(X == 0 || Y == 0)return 0;\n  if(X == 1 || Y == 1)return 1;\n  if(X == 2)return Y;\n  assert(false);\n}\n\nint add(int X,int Y){\n  if(X == 0)return Y;\n  if(X == 1 && (Y == 0 || Y == 1))return 1;\n  if(X == 1)return 2; \n  if(X == 2)return 2;\n  assert(false);\n}\n\nint sub(int X){\n  if(X == 0)return 2;\n  if(X == 2)return 0;\n  return 1;\n}\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }\n    else if(parse[pos] == '-'){\n      int p = 0;     \n      int cnt=0;\n      while(parse[pos] == '-'){      \n\tcnt++,pos++;\n      }\n\t//cout << \"cnt = \" << cnt << \" parse = \" << parse[pos]<< endl;\n      p = parse[pos]-'0';\n      pos++;\n      rep(i,cnt){\n\tp = sub(p);\n\t//cout << \"p = \" << p << endl;\n\t}\n      //cout <<\"p = \" << p << endl;\n      return p;\n      \n    }else{\n      int p = 0;\n     \n      while('0' <= parse[pos] && parse[pos] <= '2'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n\n  int term(){\n    int p = fact();\n    return p;\n  }\n \n\n  int expression(){\n    int p = term();\n    //cout << \"X = \"<< p << endl;\n    while(parse[pos] == '+' || parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \" <<q << endl;\n\tp = mul(p,q);\n      }\n      else if(parse[pos] == '+'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \"<< q << endl;\n\tp = add(p,q);\n      }\n    }\n    return p;\n  }\n\n\n};\n\nint ans,last;\nstring s;\n/*\nvoid rec(int now){\n  \n  bool ok = true;\n  for(int i=now;i<s.length();i++){\n    if(s[i] == 'P' || s[i] == 'Q' || s[i] == 'R'){\n      ok = false;\n      break;\n    }\n  }\n  if(ok){\n    Parsing par = Parsing(s);\n    int res = par.expression();\n    cout << s  << \" = \" << res << endl;\n    if(res == 2)ans++;\n    return;\n  }\n  \n  //if(now == last){\n  //cout << \"ok\"<< endl;\n  //}\n\n  for(int i=now;i<s.length();i++){\n    if(s[i] == 'P' || s[i] == 'Q' || s[i] == 'R'){\n      char pre = s[i];\n      s[i] = '0';\n      rec(now);\n      s[i] = '1';\n      rec(now);\n      s[i] = '2';\n      rec(now);\n      s[i] = pre;\n    }\n  }\n\n}\n*/\n\nvoid draw(char P,char Q,char R){\n  string pre = s;\n  rep(i,s.length()){\n    if(s[i] == 'P')s[i] = P;\n    else if(s[i] == 'Q')s[i] = Q;\n    else if(s[i] == 'R')s[i] = R;\n  }\n  Parsing par = Parsing(s);\n  if(par.expression() == 2)ans++;\n  s = pre;\n}\n\nvoid test(){\n\n  for(char i='0';i<='2';i++){\n    for(char j='0';j<='2';j++){\n      for(char k='0';k<='2';k++){\n\tdraw(i,j,k);\n      }\n    }\n  }\n\n\n}\n\n\nint main(){\n \n  \n  while(true){\n    cin >> s;\n    if(s == \".\")break;\n    ans = 0;\n    /*\n    bool nise = true;\n    for(int i=0;i<s.length();i++)\n      if(s[i] == 'P' || s[i] == 'Q' || s[i] == 'R'){\n\tnise = false;\n\tlast = i;\n      }\n    if(nise){\n      Parsing par = Parsing(s);      \n      if(par.expression() == 2)cout << 27 << endl;\n      else cout << 0 << endl;\n      continue;\n    }\n    */\n    //rec(0);\n    test();\n    cout << ans << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p, q, r, cursor;\nstring s;\n\nint not(int a) {\n\treturn 2 - a;\n}\n\nint and(int a, int b) {\n\tif(a == 0 || b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint or(int a, int b) {\n\tif(a == 2 || b == 2) return 2;\n\tif(a == 1 || b == 1) return 1;\n\treturn 0;\n}\n\nint f() {\n\tchar c = s[cursor];\n\tcursor++;\n\tif(c == '0') return 0;\n\tif(c == '1') return 1;\n\tif(c == '2') return 2;\n\tif(c == 'P') return p;\n\tif(c == 'Q') return q;\n\tif(c == 'R') return r;\n\tif(c == '-') return not(f());\n\tif(c == '(') {\n\t\tint a = f();\n\t\tchar op = s[cursor];\n\t\tcursor++;\n\t\tint b = f();\n\t\tcursor++;\n\t\tif(op == '*') {\n\t\t\treturn and(a, b);\n\t\t}\n\t\telse {\n\t\t\treturn or(a, b);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> s, s[0] != '.') {\n\t\tint ans = 0;\n\t\tfor(p = 0; p <= 2; p++) {\n\t\t\tfor(q = 0; q <= 2; q++) {\n\t\t\t\tfor(r = 0; r <= 2; r++) {\n\t\t\t\t\tcursor = 0;\n\t\t\t\t\tif(f() == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\ntypedef long long i64;\n\nint hitei(int a){\n  return (2-a);\n}\n\nint whereis(string s){\n  int i=0;\n  bool kakko = false;\n  int continuing = 0;\n  while(true){\n    if((s[i]=='*' || s[i]=='+') && (!kakko)){\n      return i;\n    }else if(s[i]=='('){\n      kakko=true;\n      continuing++;\n    }else if(s[i]==')'){\n      continuing--;\n      kakko=(continuing!=0);\n    }\n    i++;\n  }\n}\n\nint calc(string s){\n  switch(s[0]){\n  case '(':\n    {\n      string kakkohazushi = s.substr(1,s.length()-2);\n      int enzanshi = whereis(kakkohazushi);\n      if(kakkohazushi[enzanshi]=='*'){\n\treturn min(calc(kakkohazushi.substr(0,enzanshi)),calc(kakkohazushi.substr(enzanshi+1,kakkohazushi.length()-enzanshi-1)));\n      }else{\n\treturn max(calc(kakkohazushi.substr(0,enzanshi)),calc(kakkohazushi.substr(enzanshi+1,kakkohazushi.length()-enzanshi-1)));\n      }\n    }\n    break;\n  case '-':\n    return hitei(calc(s.substr(1,s.length()-1)));\n    break;\n  default:\n    return (int)(s[0]-'0');\n  }\n}\n\nint main(){\n  while(true){\n    string s;\n    cin >> s;\n    if(s==\".\") break;\n    int count = 0;\n    rep(p,3){\n      rep(q,3){\n        rep(r,3){\n\t  string a = s;\n\t  replace(a.begin(),a.end(),'P',to_string(p)[0]);\n\t  replace(a.begin(),a.end(),'Q',to_string(q)[0]);\n\t  replace(a.begin(),a.end(),'R',to_string(r)[0]);\n\t  if(calc(a)==2) count++;\n\t}\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nconst int se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint num(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tif (isdigit(s[idx])||s[idx]=='-')return number(s, idx);\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\treturn val;\n}\nint number(string& s, int &idx) {\n\tint not= 0;\n\twhile (s[idx]=='-')\n\t{\n\t\tnot++;\n\t\tidx++;\n\t}\n\tint val = s[idx] - '0';\n\tidx++;\n\tif (not% 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint p, q, r, pos;\nstring in;\n\nint Formula();\nint Seki(int, int);\nint Wa(int, int);\nint Not(int);\nint Num();\nmain(){\n\n  while(1){\n    cin >> in;\n    if(in==\".\") break;\n\n    int ans=0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  pos=0;\n\t  int tmp=Formula();\n\t  if(tmp==2) ans++;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint Formula(){\n  int x;\n  if(in[pos]=='('){\n    pos++;\n    x=Formula();\n    pos++;\n  }else if(in[pos]=='-'){\n    int count=0;\n    while(in[pos]=='-'){\n      count++;\n      pos++;\n    }\n    x=Num();\n    for(int i=0;i<count;i++){\n      x=(Not(x));\n    }\n  }else{\n    x=Num();\n  }\n  if(pos<in.size()-1){\n    if(in[pos+1]=='*'){\n      pos+=2;\n      x=Seki(x, Formula());\n    }else if(in[pos+1]=='+'){\n      pos+=2;\n      x=Wa(x, Formula());\n    }\n  }\n  return x;\n}\n\nint Seki(int a, int b){\n  if(a==0){\n    return 0;\n  }else if(a==1){\n    if(b==0) return 0;\n    else return 1;\n  }else{\n    return b;\n  }\n}\n\nint Wa(int a, int b){\n  if(a==0){\n    return b;\n  }else if(a==1){\n    if(b==2) return 2;\n    else return 1;\n  }else{\n    return 2;\n  }\n}\n\nint Not(int a){\n  if(a==0) return 2;\n  if(a==2) return 0;\n  return 1;\n}\n\nint Num(){\n  int x;\n  if(in[pos]=='P'){\n    x=p;\n  }else if(in[pos]=='Q'){\n    x=q;\n  }else if(in[pos]=='R'){\n    x=r;\n  }else if(in[pos]=='0'){\n    x=0;\n  }else if(in[pos]=='1'){\n    x=1;\n  }else if(in[pos]=='2'){\n    x=2;\n  }\n  return x;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str;\nint pos;\nint P, Q, R;\n\nint formula() {\n  pos ++;\n  if(str[pos] == '(') {\n    int f = formula();\n    pos ++;\n    if(str[pos] == '+') f = max(f, formula());\n    if(str[pos] == '*') f = min(f, formula());\n    pos ++;\n    return f;\n  }\n  \n  if(str[pos] == '-') return 2-formula();\n  if(str[pos] == '0') return 0;\n  if(str[pos] == '1') return 1;\n  if(str[pos] == '2') return 2;\n  if(str[pos] == 'P') return P;\n  if(str[pos] == 'Q') return Q;\n  if(str[pos] == 'R') return R;\n  \n}\n\nint main() {\n  \n  while(cin >> str) {\n    if(str == \".\") break;\n    int cnt = 0;\n    for(P = 0; P<=2; P++)\n      for(Q = 0; Q<=2; Q++)\n\tfor(R = 0; R<=2; R++)\n\t  cnt += formula() == 2;\n    cout << cnt << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tif(s.size()==1)return s[0]=='P'?p+'0':s[0]=='Q'?q+'0':s[0]=='R'?r+'0':s[0];\n\tint cnt=0,f,now=-1;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tif(now==-1)now=mt;\n\t\t\telse{\n\t\t\t\tif(f==0)now=_and[now][mt];\n\t\t\t\telse now=_or[now][mt];\n\t\t\t}\n\t\t}\n\t}\n\treturn now+'0';\n}\nchar rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\tchar tt=pyon(s,p,q,r);\n\treturn tt;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tchar t=rec(s,i,j,k);\n\t\t\tif(t=='2')cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint P,Q,R;\n\nint formula(string& f, int& i) {\n  switch(f[i++]) {\n  case '-' : return 2 - formula(f, i);\n  case 'P' : return P;\n  case 'Q' : return Q;\n  case 'R' : return R;\n  case '0' : return 0;\n  case '1' : return 1;\n  case '2' : return 2;\n  case '(' :\n    int f1 = formula(f, i);\n    int f2;\n    switch(f[i++]) {\n    case '*' :\n      f2 = formula(f, i);\n      i++;\n      return min(f1, f2);\n    case '+' :\n      f2 = formula(f, i);\n      i++;\n      return max(f1, f2);\n    }\n  }\n  \n  return 0;\n} \n\nint main() {\n  string f;\n  while(cin >> f, f[0] != '.') {\n    int cnt = 0;\n    for (P = 0; P <= 2; P++) {\n      for (Q = 0; Q <= 2; Q++) {\n\tfor (R = 0; R <= 2; R++) {\n\t  int i = 0;\n\t  if(formula(f, i) == 2) cnt++;\n\t}\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n;\nchar s[111],sav[111];\n\nint f(int l,int r){\n  if(l+1==r){\n    return s[l]-'0';\n  }\n  if(s[l]=='-'){\n    return 2-f(l+1,r);\n  }\n  if(s[l]=='('){\n    int level=-1;\n    repl(i,l,r){\n      if(s[i]=='(')level++;\n      else if(s[i]==')')level--;\n      if(level==0&&s[i]=='+'){\n        return max(f(l+1,i),f(i+1,r-1));\n      }\n      if(level==0&&s[i]=='*'){\n        return min(f(l+1,i),f(i+1,r-1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>s;\n    if(s[0]=='.')break;\n    int res=0;\n    n=strlen(s);\n    rep(p,3)rep(q,3)rep(r,3){\n      memcpy(sav,s,sizeof(s));\n      rep(i,n){\n        if(s[i]=='P')s[i]=p+'0';\n        if(s[i]=='Q')s[i]=q+'0';\n        if(s[i]=='R')s[i]=r+'0';\n      }\n      if(f(0,n)==2)res++;\n      memcpy(s,sav,sizeof(sav));\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n\nint formula(char *);\nint min(int,int);\nint max(int,int);\n\nint p,q,r;\nint position;\n\nmain(){\n    int count=0;\n    char str[100000];\n    \n    while( scanf(\"%s\",str) !=EOF){\n        if(str[0] == '.') break;\n        count = 0;\n        \n    for(p=0; p<3; p++){\n        for(q=0; q<3; q++){\n            for(r=0; r<3; r++){\n                position = 0;\n               if(formula(str) == 2)\n               count++;\n            }\n        }\n    }\n    printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}\n\nint formula(char *str){\n    int result;\n    \n    if(str[position] == '-'){\n        result = 2-formula(str);\n        position++;\n    }   \n    \n    else if(str[position] == '('){\n    position++;\n    result = formula(str);\n    if(str[position] == '*'){\n        position++;\n        result = min(result,formula(str));\n    }\n    else if(str[position] == '+'){\n        position++;\n        result = max(result,formula(str));\n    }\n}\n\nelse{\n    if(str[position] >= '0' && str[position] <= '2')\n    return str[position] - '0';\n    \n    if(str[position] == 'P')\n    return p;\n    else if(str[position] == 'Q')\n    return q;\n    else if(str[position] == 'R')\n    return r;\n    }\n}\n\nint min(int x,int y){\n    if(x > y)\n    return y;\n    else return x;\n}\n\nint max(int x,int y){\n    if(x > y)\n    return x;\n    else return y;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint check(char op, int x, int y) {\n    switch (op) {\n    case '*':\n        if (x == 2 && y == 2) return 2;\n        return x & y;\n    case '+':\n        if (x == 2 || y == 2) return 2;\n        return x | y;\n    }\n    assert(0);\n}\n\nint formula(string& form, int& idx) {\n    switch (form[idx]) {\n    case '0':\n    case '1':\n    case '2':\n        return form[idx++] - '0';\n    case '-':\n        return 2 - formula(form, ++idx);\n    case '(':\n        int x = formula(form, ++idx);\n        char op = form[idx];\n        int y = formula(form, ++idx);\n        ++idx;\n        return check(op, x, y);\n    }\n    assert(0);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \".\") {\n            break;\n        }\n\n        int n = 0;\n        REP(p, 3) REP(q, 3) REP(r, 3) {\n            string tmp = line;\n            REP(i, tmp.length()) {\n                switch (tmp[i]) {\n                case 'P':\n                    tmp[i] = p + '0';\n                    break;\n                case 'Q':\n                    tmp[i] = q + '0';\n                    break;\n                case 'R':\n                    tmp[i] = r + '0';\n                    break;\n                }\n            }\n            int idx = 0;\n            if (formula(tmp, idx) == 2) {\n                n++;\n            }\n        }\n        cout << n << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator itr;\n\nint P = 0, Q = 0, R = 0;\n\nint factor(itr &begin);\nint num(itr &begin);\nint expression(itr &begin);\n\nint factor(itr &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else if(*begin == '-'){\n            begin++;\n            return 2 - factor(begin);\n        }\n    else {\n        return num(begin);\n    }\n}\n\nint num(itr &begin){\n    int ret = 0;\n    if(*begin == 'R') ret = R;\n    else if(*begin == 'P') ret = P;\n    else if(*begin == 'Q') ret = Q;\n    else ret = *begin - '0';\n    begin++;\n    return ret;\n}\n\nint expression(itr &begin){\n    int ret = factor(begin);\n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret = min(ret, factor(begin));\n        }\n        else if(*begin == '+'){\n            begin++;\n            ret = max(ret, factor(begin));\n        }\n        else break;\n    }\n    return ret;\n}\n\nint main(){\n    string s; \n    while(true){\n        cin >> s;\n        if(s == \".\") return 0;\n        int ans = 0;\n        for(R=0; R<=2; R++){\n            for(P=0; P<=2; P++){\n                for(Q=0; Q<=2; Q++){\n                    itr begin = s.begin();\n                    int res = expression(begin);\n                    if(res == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint countMinus(State&);\nint negative(int,int);\nint number(State&);\nint factor(State&);\nint expression(State&);\n\nint p, q, r;\n\nint countMinus(State &begin){\n    int ng = 0;\n    while(*begin == '-'){\n        ng++;\n        begin++;\n    }\n    return ng;\n}\n\nint negative(int ret, int ng){\n    if(ng % 2){\n        if(ret == 0) ret = 2;\n        else if(ret == 2) ret = 0;\n    }\n    return ret;\n}\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n    if(*begin == 'P') ret = p;\n    else if(*begin == 'Q') ret = q;\n    else if(*begin == 'R') ret = r;\n    else if(isdigit(*begin)) ret = *begin - '0';\n    else return 0;\n\n    begin++;\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    int ng = countMinus(begin);\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return negative(ret, ng);\n    } else {\n        return negative(number(begin), ng);\n    }\n    return -1;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret = max(ret, factor(begin));\n        } else if (*begin == '*') {\n            begin++;\n            ret = min(ret, factor(begin));\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n\nint main(){\n    string s;\n    while(cin >> s, s[0] != '.'){\n        int cnt = 0;\n        rep(i,3){\n            rep(j,3){\n                rep(k,3){\n                    State tmp = s.begin();\n                    p = i; q = j; r = k;\n                    if(expression(tmp) == 2){\n                        //cout << p << ' ' << q << ' ' << r << endl;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct Node{\n    virtual int eval(map<char,int> vMap) {};\n    Node(){};\n};\n\nstruct ConstNode : Node{\n    int value;\n    int eval(map<char,int> vMap){\n        return value;\n    };\n    ConstNode(int val) : value(val) {};\n};\n\nstruct VarNode : Node{\n    char var;\n    int eval(map<char,int> vMap){\n        return vMap[var];\n    }\n    VarNode(char va) : var(va) {};\n};\n\nstruct MinusNode : Node{\n    Node* child;\n    int eval(map<char,int> vMap){\n        int e = (*child).eval(vMap);\n        if(e == 0) return 2;\n        if(e == 1) return 1;\n        if(e == 2) return 0;\n    }\n    MinusNode(Node* chi) : child(chi) {};\n};\n\nstruct PlusNode : Node{\n    Node *left,*right;\n    int eval(map<char,int> vMap){\n        int le = (*left).eval(vMap);\n        int re = (*right).eval(vMap);\n        return max(le,re);\n    }\n    PlusNode(Node* le,Node* ri) : left(le),right(ri) {};\n};\n\nstruct MulNode : Node{\n    Node *left,*right;\n    int eval(map<char,int> vMap){\n        int le = (*left).eval(vMap);\n        int re = (*right).eval(vMap);\n        return min(le,re);\n    }\n    MulNode(Node *le,Node *ri) : left(le),right(ri) {};\n};\n\nstruct Result{\n    Node *node;\n    int index;\n    Result(Node *no,int ind) : node(no),index(ind) {};\n};\n\n\n// parsestring,next_index.\nResult formula(string,int);\nResult mterm(string,int);\nResult term(string,int);\n\n\nResult formula(string s,int ind){\n    Result r = mterm(s,ind);\n    if(s[r.index] == '+'){\n        Result r2 = mterm(s,r.index+1);\n        return Result(new PlusNode(r.node,r2.node),r2.index);\n    }else if(s[r.index] == '*'){\n        Result r2 = mterm(s,r.index+1);\n        return Result(new MulNode(r.node,r2.node),r2.index);\n    }\n    return r;\n}\n\nResult mterm(string s,int ind){\n    if(s[ind] == '-'){\n        Result r = mterm(s,ind+1);\n        return Result(new MinusNode(r.node),r.index);\n    }else{\n        return term(s,ind);\n    }\n}\n\nResult term(string s,int ind){\n    if(s[ind] == '('){\n        Result r = formula(s,ind+1);\n        // ')'\n        r.index++;\n        return r;\n    }else{\n        switch(s[ind]){\n        case '0':\n        case '1':\n        case '2':\n            return Result(new ConstNode(s[ind]-'0'),ind+1);\n        case 'P':\n        case 'Q':\n        case 'R':\n            return Result(new VarNode(s[ind]),ind+1);\n        }\n    }\n}\n\nint main(){\n    while(true){\n        string s;\n        cin >> s;\n\n        if(s==\".\") break;\n        int cnt = 0;\n        Result r = formula(s,0);\n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                for(int k=0;k<3;k++){\n                    map<char,int> m;\n                    m['P'] = i;\n                    m['Q'] = j;\n                    m['R'] = k;\n                    //cerr << i << \" \" << j << \" \" << k << \" \" << r.node->eval(m) << endl;\n                    if(r.node->eval(m) == 2){\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    cnt++;\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return (int)(tmp[cnt]-'0');\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=(char)(i+'0');\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=(char)(j+'0');\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=(char)(k+'0');\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nmap<char, int> gensi;\nint NOT[3] = {2, 1, 0};\nint AND[3][3] = {{0, 0, 0},\n\t       {0, 1, 1},\n\t       {0, 1, 2},};\nint OR[3][3]  = {{0, 1, 2},\n\t       {1, 1, 2},\n\t       {2, 2, 2},};\nint formular(string&, int&);\nint factor(string&, int&);\nint term(string&, int&);\n\nint formular(string& str, int& p){\n  int res = term(str, p);\n  while(str[p] == '*' || str[p] == '+'){\n    if(str[p] == '*'){\n      p++;\n      return(AND[res][term(str, p)]);\n    }else{\n      p++;\n      return(OR[res][term(str, p)]);\n    }\n  }\n  return res;\n}\n\nint term(string& str, int& p){\n  int res;\n  while(str[p] == '('){\n    while(str[p] != ')'){\n      p++;\n      res = formular(str, p);\n      p++;\n      return res;\n    }\n  }\n  while(str[p] == '-'){\n    p++;\n    return(NOT[term(str, p)]);\n  }\n  while(isdigit(str[p])){\n    res = str[p] - '0';\n    p++;\n    return res;\n  }\n  while(str[p] == 'P' || str[p] == 'Q' || str[p] == 'R'){\n    res = gensi[str[p]];\n    p++;\n    return res;\n  }\n}\n\nint main(void){\n  string str;\n  while(cin >> str, str != \".\"){\n    int ans = 0;\n    for(gensi['P'] = 0; gensi['P'] < 3; gensi['P']++){\n      for(gensi['Q'] = 0; gensi['Q'] < 3; gensi['Q']++){\n        for(gensi['R'] = 0; gensi['R'] < 3; gensi['R']++){\n          int p = 0;\n          if(formular(str, p) == 2){\n            ans++;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nchar mns(char c) {\n\tif (c == '0') return '2';\n\tif (c == '1') return '1';\n\treturn '0';\n}\n\nchar multi(char c1, char c2) {\n\tif (c1 == '0' || c2 == '0') return '0';\n\tif (c1 == '2' && c2 == '2') return '2';\n\treturn '1';\n}\n\nchar pls(char c1, char c2) {\n\tif (c1 == '2' || c2 == '2') return '2';\n\tif (c1 == '0' && c2 == '0') return '0';\n\treturn '1';\n}\n\nchar eval(string s) {\n\tif (s.size() == 1) return s[0];\n\n\tif (s[0] != '(') {\n\t\tint i = 0;\n\t\twhile (s[i] == '-') i++;\n\t\tstring t = s.substr(i);\n\t\tif (i % 2) return mns(eval(t));\n\t\treturn eval(t);\n\t}\n\n\n\ts = s.substr(1, (int)s.size() - 2);\n\t\n\tint cnt = 0;\n\tint pt = 0;\n\twhile (!(cnt == 0 && (s[pt] == '+' || s[pt] == '*'))) {\n\t\tif (s[pt] == '(') cnt++;\n\t\telse if (s[pt] == ')') cnt--;\n\t\tpt++;\n\t}\n\n\tstring a = s.substr(0, pt);\n\tstring b = s.substr(pt + 1);\n\n\tif (s[pt] == '+') return pls(eval(a), eval(b));\n\treturn multi(eval(a), eval(b));\n}\n\nsigned main() {\n\twhile (true) {\n\t\tstring t;\n\t\tcin >> t;\n\n\t\tif (t == \".\") break;\n\n\t\tint ret = 0;\n\t\tfor (char p = '0'; p <= '2'; p++) {\n\t\t\tfor (char q = '0'; q <= '2'; q++) {\n\t\t\t\tfor (char r = '0'; r <= '2'; r++) {\n\t\t\t\t\tstring s = t;\n\t\t\t\t\trep(i, s.size()) {\n\t\t\t\t\t\tif (s[i] == 'P') s[i] = p;\n\t\t\t\t\t\telse if (s[i] == 'Q') s[i] = q;\n\t\t\t\t\t\telse if (s[i] == 'R') s[i] = r;\n\t\t\t\t\t}\n\t\t\t\t\tret += (eval(s) == '2');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 200005\nint N, M;\nint dp[MAX];\nbool taked[MAX];\n// expr +\n// term *\nint P, Q, R;\nint number(string& s, int& i);\nint factor(string& s, int& i);\nint not_calc(string& s, int& i);\nint term(string& s, int& i);\nint expr(string& s, int& i);\n\nint number(string& s, int& i) {\n\tint res;\n\tswitch (s[i]) {\n\tcase 'P': res = P; break;\n\tcase 'Q': res = Q; break;\n\tcase 'R': res = R; break;\n\tdefault: res = s[i] - '0';\n\t}\n\ti++;\n\tif (test) {\n\t\tdump(i);\n\t\tfprintf(stderr, \"number \");\n\t\tdump(res);\n\t}\n\treturn res;\n}\nint factor(string& s, int& i) {\n\tif (s[i] != '(') return number(s, i);\n\ti++;\n\tint ret = expr(s, i);\n\ti++;\n\tif (test) {\n\t\tfprintf(stderr, \"factor : \");\n\t\tdump(ret);\n\t}\n\treturn ret;\n}\n\nint not_calc(string& s, int& i) {\n\tint val;\n\tint cnt = 0;\n\twhile (s[i] == '-') {\n\t\tcnt++;\n\t\ti++;\n\t}\n\tval = factor(s, i);\n\tif (cnt % 2) {\n\t\tval = 2 - val;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"not_calc \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint term(string& s, int& i) {\n\tint val = not_calc(s, i);\n\twhile (s[i] == '*') {\n\t\ti++;\n\t\tint val2 = not_calc(s, i);\n\t\tif (val2 == 0) val = 0;\n\t\telse if (val2 == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"term \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint expr(string& s, int& i) {\n\tint val = term(s, i);\n\twhile (s[i] == '+') {\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (val == 2 || val2 == 2) val = 2;\n\t\telse if (val == 1 || val == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"sum \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\n\nsigned main(void)\n{\n\tint i, j, k;\n\n\twhile (1) {\n\t\tstring s;\n\t\tint cnt = 0;\n\t\tcin >> s;\n\t\tif (s == \".\") return 0;\n\t\t//i = 0;\n\t\t//P = 0; Q = 0; R = 0;\n\t\t//expr(s, i);\n\t\trep(P, 3) rep(Q, 3) rep(R, 3) {\n\t\t\t//dump(P);\n\t\t\t//dump(Q);\n\t\t\t//dump(R);\n\t\t\ti = 0;\n\t\t\tif (expr(s, i) == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stack>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define NUM 0\n#define NOT 1\n#define AND 2\n#define OR  3\n#define PAREN 4\n\nint cheak(string t){//cout<<t<<endl;\n\tstack<pair<int,int> > sta;\n\t\n\tfor(int i = 0; i < t.size(); i++){\n\t\tif('0' <= t[i] && t[i] <= '2'){\n\t\t\tint num = t[i]-'0';\n\t\t\tfor(; !sta.empty();){\n\t\t\t\tif(sta.top().first == NOT){\n\t\t\t\t\tsta.pop();\n\t\t\t\t\tnum = 2-num;\n\t\t\t\t\t\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tsta.push(make_pair(NUM,num));\n\t\t\t\t\n\t\t} else if(t[i] == ')'){\n\t\t\tpair<int,int> a = sta.top(); sta.pop();\n\t\t\tpair<int,int> b = sta.top(); sta.pop();\n\t\t\tpair<int,int> c = sta.top(); sta.pop();sta.pop();\n\t\t\tif(b.first == AND){\n\t\t\t\ta.second = min(a.second,c.second);\n\t\t\t} else if(b.first == OR){\n\t\t\t\ta.second = max(a.second,c.second);\n\t\t\t}\n\t\t\tint num = a.second;\n\t\t\t//cout<<\"num = \"<<num<<\" \"<<sta.top().first<<endl;\n\t\t\tfor(; !sta.empty();){\n\t\t\t\tif(sta.top().first == NOT){\n\t\t\t\t\tsta.pop();\n\t\t\t\t\tnum = 2-num;\n\t\t\t\t\t\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tsta.push(make_pair(NUM,num));\t\n\t\t} else if(t[i] == '-'){\n\t\t\tsta.push(make_pair(NOT,0));\n\t\t} else if(t[i] == '*'){\n\t\t\tsta.push(make_pair(AND,0));\n\t\t} else if(t[i] == '+'){\n\t\t\tsta.push(make_pair(OR,0));\n\t\t} else if(t[i] == '('){\n\t\t  \tsta.push(make_pair(PAREN,0));\n\t\t}\n\t\t//cout<<i<<endl;if(!sta.empty())cout<<i<<\" \"<<sta.top().first<<\" \"<<sta.top().second<<endl;\n\t}\n\treturn sta.top().second;\n}\nbool solve(){\n  string s;\n  cin>>s;//cout<<cheak(s)<<endl;return false;\n\n\tif(s == \".\") return false;\n\t\n\tint count = 0;\n\tstring temp = s;\n\tfor(int i = 0; i < 27; i++){\n\t\tint p = i%3, q = (i/3)%3, r = (i/9)%3;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'P'){\n\t\t\t\ttemp[j] = '0' + p;\n\t\t\t} else if(s[j] == 'Q'){\n\t\t\t\ttemp[j] = '0' + q;\n\t\t\t} else if(s[j] == 'R'){\n\t\t\t\ttemp[j] = '0' + r;\n\t\t\t}\n\t\t}\n\t\tif(cheak(temp) == 2)count++;\n\t}\n\t\n\tcout<<count<<endl;\n\treturn true;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\twhile(solve());\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint bar[3] = {2,1,0};\n\nint mul[3][3] = {\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint add[3][3] = {\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\n\nstring s;\nint PQR[3];\n\nbool isvar(char c) { return (c - '0' >= 0 && c - '0' <= 2) || (c - 'P' >= 0 && c - 'P' <= 2); }\nint getvar(char c) {\n\tif (0 <= c - '0' && c - '0' <= 2) return c - '0';\n\treturn PQR[c - 'P'];\n}\n\nint rec(int lft, int rgt) {\n\t//cerr << s.substr(lft, rgt-lft) << endl;\n\tint open_cnt = 0, close_cnt = 0, bar_cnt = 0;\n\tint nxt_lft = -1;\n\t\n\tstack< int > st;\n\tstack< char > op;\n\tfor_(i,lft,rgt) {\n\t\tif (open_cnt == close_cnt && s[i] == '-') {\n\t\t\t++bar_cnt;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && isvar(s[i])) {\n\t\t\tint x = getvar(s[i]);\n\t\t\tfor_(rep,0,bar_cnt) x = bar[x];\n\t\t\tst.push(x);\n\t\t\tbar_cnt = 0;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '*') op.push('*');\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '+') op.push('+');\n\t\t\n\t\tif (s[i] == '(') {\n\t\t\tif (open_cnt == close_cnt) nxt_lft = i+1;\n\t\t\t++open_cnt;\n\t\t}\n\t\t\n\t\tif (s[i] == ')') {\n\t\t\t++close_cnt;\n\t\t\tif (open_cnt == close_cnt) {\n\t\t\t\tint x = rec(nxt_lft, i);\n\t\t\t\tfor_(rep,0,bar_cnt) x = bar[x];\n\t\t\t\tst.push(x);\n\t\t\t\tbar_cnt = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (st.size() >= 2 && !op.empty()) {\n\t\t\tchar opr = op.top(); op.pop();\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tif (opr == '*') st.push(mul[x][y]);\n\t\t\tif (opr == '+') st.push(add[x][y]);\n\t\t}\n\t}\n\t\n\treturn st.top();\n}\n\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \".\") break;\n\t\tint ans = 0;\n\t\tfor_(p,0,3) for_(q,0,3) for_(r,0,3) {\n\t\t\tPQR[0] = p; PQR[1] = q; PQR[2] = r;\n\t\t\tif (rec(0, s.size()) == 2) ++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nchar buf[100];\n\nint calc_not(int value){\n\tswitch(value){\n\tcase 0:return 2;\n\tcase 1:return 1;\n\tcase 2:return 0;\n\t}\n\treturn -1; //must not reach here\n}\n\nint calc_and(int left,int right){\n\tif(left == 0 || right == 0)return 0;\n\telse{\n\t\tif(left == 1 || right == 1)return 1;\n\t\telse{\n\t\t\treturn 2;\n\t\t}\n\t}\n}\n\nint calc_or(int left,int right){\n\treturn max(left,right);\n}\n\nint recursive(int P,int Q,int R,int left,int right){\n\tint depth = 0,op_pos = -1;\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(buf[i] == '(')depth++;\n\t\telse if(buf[i] == ')')depth--;\n\t\telse if((buf[i] == '+' || buf[i] == '*') && depth == 0){\n\t\t\top_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint FLG = 1,index,num;\n\n\tif(op_pos == -1){\n\n\t\tfor(index = left; buf[index] == '-'; index++){\n\t\t\tFLG *= -1;\n\t\t}\n\t\tif(buf[index] >= '0' && buf[index] <= '2'){\n\t\t\tnum = buf[index] - '0';\n\t\t\tif(FLG == -1){\n\t\t\t\treturn calc_not(num);\n\t\t\t}else{\n\t\t\t\treturn num;\n\t\t\t}\n\t\t}else if(buf[index] == 'P' || buf[index] == 'Q' || buf[index] == 'R'){\n\t\t\tswitch(buf[index]){\n\t\t\tcase 'P':\n\t\t\t\tnum = P;\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\t\tnum = Q;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tnum = R;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(FLG == -1){\n\t\t\t\treturn calc_not(num);\n\t\t\t}else{\n\t\t\t\treturn num;\n\t\t\t}\n\t\t}else{ //buf[index] == '('\n\t\t\tif(FLG == -1){\n\t\t\t\treturn calc_not(recursive(P,Q,R,index+1,right-1));\n\t\t\t}else{\n\t\t\t\treturn recursive(P,Q,R,index+1,right-1);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tint calc_left,calc_right;\n\n\t\tif(buf[op_pos-1] == ')'){\n\t\t\tif(buf[left] == '-'){\n\n\t\t\t\tFLG =1;\n\t\t\t\tfor(index = left; buf[index] == '-';index++){\n\t\t\t\t\tFLG *= -1;\n\t\t\t\t}\n\t\t\t\tif(FLG == -1){\n\t\t\t\t\tcalc_left = calc_not(recursive(P,Q,R,index+1,op_pos-2));\n\t\t\t\t}else{\n\t\t\t\t\tcalc_left = recursive(P,Q,R,index+1,op_pos-2);\n\t\t\t\t}\n\n\t\t\t}else{ //buf[left] == '('\n\t\t\t\tcalc_left = recursive(P,Q,R,left+1,op_pos-2);\n\t\t\t}\n\t\t}else{\n\t\t\tcalc_left = recursive(P,Q,R,left,op_pos-1);\n\t\t}\n\n\t\tif(buf[op_pos+1] == '('){\n\t\t\tcalc_right = recursive(P,Q,R,op_pos+2,right-1);\n\t\t}else{\n\t\t\tif(buf[right] == ')'){\n\t\t\t\tif(buf[op_pos+1] == '-'){\n\n\t\t\t\t\tFLG =1;\n\t\t\t\t\tfor(index = op_pos+1; buf[index] == '-';index++){\n\t\t\t\t\t\tFLG *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG == -1){\n\t\t\t\t\t\tcalc_right = calc_not(recursive(P,Q,R,index+1,right-1));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_right = recursive(P,Q,R,index+1,right-1);\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tcalc_right = recursive(P,Q,R,op_pos+1,right);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcalc_right = recursive(P,Q,R,op_pos+1,right);\n\t\t\t}\n\t\t}\n\n\t\tif(buf[op_pos] == '+'){\n\t\t\treturn calc_or(calc_left,calc_right);\n\t\t}else{ //buf[op_pos] == '*'\n\t\t\treturn calc_and(calc_left,calc_right);\n\t\t}\n\t}\n}\n\nbool purse(int P,int Q,int R){\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\n\tint left = -1,right = -1;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(buf[i] == '('){\n\t\t\tleft = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(int i = length-1; i >= 0; i--){\n\t\tif(buf[i] == ')'){\n\t\t\tright = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint FLG = 1,index,num;\n\tif(left == -1){\n\t\tfor(index = 0; buf[index] == '-'; index++){\n\t\t\tFLG *= -1;\n\t\t}\n\t\tif(buf[index] >= '0' && buf[index] <= '2'){\n\t\t\tnum = buf[index] - '0';\n\t\t\tif(FLG == -1){\n\t\t\t\treturn calc_not(num) == 2;\n\t\t\t}else{\n\t\t\t\treturn num == 2;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(buf[index]){\n\t\t\tcase 'P':\n\t\t\t\tnum = P;\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\t\tnum = Q;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tnum = R;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(FLG == -1){\n\t\t\t\treturn calc_not(num) == 2;\n\t\t\t}else{\n\t\t\t\treturn num == 2;\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tif(left == 0){\n\t\t\treturn recursive(P,Q,R,left+1,right-1) == 2;\n\t\t}else{\n\t\t\tfor(index = 0; buf[index] == '-'; index++){\n\t\t\t\tFLG *= -1;\n\t\t\t}\n\t\t\tif(FLG == -1){\n\t\t\t\treturn calc_not(recursive(P,Q,R,index+1,right-1)) == 2;\n\t\t\t}else{\n\t\t\t\treturn recursive(P,Q,R,index+1,right-1) == 2;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tint count = 0;\n\n\tfor(int P = 0; P <= 2; P++){\n\t\tfor(int Q = 0; Q <= 2; Q++){\n\t\t\tfor(int R = 0; R <=2; R++){\n\t\t\t\tif(purse(P,Q,R))count++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",count);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0] == '.')break;\n\n\t\tfunc();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\nusing namespace std;\nint pos, p, q, r;\nstring str;\n\nint term();\nint factor();\nint number();\n\nint formula(){\n    if (isdigit(str[pos])) {\n        return str[pos++] - '0';\n    }\n    if (str[pos] == 'P') {\n        pos++;\n        return p;\n    }\n    if (str[pos] == 'Q') {\n        pos++;\n        return q;\n    }\n    if (str[pos] == 'R') {\n        pos++;\n        return r;\n    }\n    int res = 0;\n    if (str[pos] == '-') {\n        pos++;\n        return 2 - formula();\n    }\n    if (str[pos] == '(') {\n        pos++;\n        res = formula();\n        if (str[pos] == '*') {\n            pos++;\n            res = min(res, formula());\n        }\n        else if (str[pos] == '+') {\n            pos++;\n            res = max(res, formula());\n        }\n        pos++;\n    }\n\n    return res;\n}\n\nint main()\n{\n    while (true) {\n        cin >> str;\n        if (str == \".\") {\n            break;\n        }\n        int count = 0;\n        for (p = 0; p <= 2; p++) {\n            for (q = 0; q <= 2; q++) {\n                for (r = 0; r <= 2; r++) {\n                    pos = 0;\n                    if (formula() == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint pos;\nstring t;\n\nint calc(){\n\tchar c = t[pos++];\n\tif('0'<=c&&c<'3') return c - '0';\n\tif(c == '-')   return 2 - calc();\n\tint a = calc();\n\tchar op = t[pos++];\n\tint b = calc();\n\tpos++;\n\treturn op == '+' ? max(a,b) : min(a,b);\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tfor(int P=0;P<3;P++){\n\t\t\tfor(int Q=0;Q<3;Q++){\n\t\t\t\tfor(int R=0;R<3;R++){\n\t\t\t\t\tt = \"\";\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tfor(int i=0;i<s.size();i++){\n\t\t\t\t\t\tif(s[i]=='P') t += P + '0';\n\t\t\t\t\t\telse if(s[i]=='Q') t += Q + '0';\n\t\t\t\t\t\telse if(s[i]=='R') t += R + '0';\n\t\t\t\t\t\telse t += s[i];\n\t\t\t\t\t}\n\t\t\t\t\tans += calc() == 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * <formula> ::= 0 | 1 | 2 | P | Q | R |\n *    -<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\nint table_seki[3][3];\nint table_wa[3][3];\nint P,Q,R;\n\nint formula(string& s, int& i);\nint main();\n\nint formula(string& s, int& i)\n{\n\tint left=0, right=0;\t\n\tchar ope=0;\n\n\tswitch(s[i])\n\t{\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase 'P': return P;\n\t\tcase 'Q': return Q;\n\t\tcase 'R': return R;\n\t\tcase '-':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\tif (left == 0) { return 2; }\n\t\t\telse if (left == 2) { return 0; }\n\t\t\telse { return 1; }\n\t\tcase '(':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\ti++;\n\t\t\tope = s[i];\n\t\t\ti++;\n\t\t\tright = formula(s,i);\n\t\t\ti++; //)\n\t\t\tif (ope == '*') {\n\t\t\t\treturn table_seki[left][right];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn table_wa[left][right];\n\t\t\t}\n\t\tdefalt:\n\t\t\treturn 0; //起こることは本来ない．扱う字句または構文のミス\n\t}\n\treturn 0; //起こることはないはず\n}\n\nint main() {\n\t//積集合\n\ttable_seki[0][0] = 0; //y,x\n\ttable_seki[1][0] = 0; //y,x\n\ttable_seki[2][0] = 0; //y,x\n\ttable_seki[0][1] = 0; //y,x\n\ttable_seki[1][1] = 1; //y,x\n\ttable_seki[2][1] = 1; //y,x\n\ttable_seki[0][2] = 0; //y,x\n\ttable_seki[1][2] = 1; //y,x\n\ttable_seki[2][2] = 2; //y,x\n\n\t//和集合\n\ttable_wa[0][0] = 0; //y,x\n\ttable_wa[1][0] = 1; //y,x\n\ttable_wa[2][0] = 2; //y,x\n\ttable_wa[0][1] = 1; //y,x\n\ttable_wa[1][1] = 1; //y,x\n\ttable_wa[2][1] = 2; //y,x\n\ttable_wa[0][2] = 2; //y,x\n\ttable_wa[1][2] = 2; //y,x\n\ttable_wa[2][2] = 2; //y,x\n\n\tstring line;\n\tvector<int> binary;\n\tbinary.push_back(0);\n\tbinary.push_back(1);\n\tbinary.push_back(2);\n\tint pattern_cnt = 0;\n\n\twhile(true) {\n\t\tcin >> line;\n\t\tpattern_cnt = 0;\n\t\tif (line[0] == '.') { break; }\n\n\t\trep(p,3) {\n\t\t\trep(q,3) {\n\t\t\t\trep(r,3) {\n\t\t\t\t\tP=p; Q=q; R=r;\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint result = formula(line,i);\n\n\t\t\t\t\tif (result == 2) { pattern_cnt++; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << pattern_cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tr = 2-r;\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tl = 2-l;\n\t\t\tst.pop();\n\t\t\t\n\t\t\tint tmp;\n\t\t\tif(o == '*')\n\t\t\t\ttmp = AND[r][l];\n\t\t\telse\n\t\t\t\ttmp = OR[r][l];\n\t\t\t\t\n\t\t\tif(!st.empty() && st.top()=='-'){\n\t\t\t\tfor(m=0; !st.empty() && st.top()=='-'; m++)\n\t\t\t\t\tst.pop();\n\t\t\t\tif(m%2)\n\t\t\t\t\ttmp = 2-tmp;\n\t\t\t}\n\t\t\t\n\t\t\tst.push((char)(tmp+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\n\tif(st.top() == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstring s;\nint p = 0;\nint P, Q, R;\n\nint dfs() {\n  char c = s[p++];\n  if ( isdigit(c) ) return c-'0';\n  if ( c == 'P' ) return P;\n  if ( c == 'Q' ) return Q;\n  if ( c == 'R' ) return R;\n  if ( c == '-' ) return 2-dfs();\n  if ( c == '(' ) {\n    int l = dfs();\n    char c_ = s[p++];\n    int r = dfs();\n    p++;    \n    if ( c_ == '*' ) return min(l, r);\n    if ( c_ == '+' ) return max(l, r);\n  }\n  return 0;  \n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  \n  while ( cin >> s, s != \".\" ) {\n    int cnt = 0;\n    for ( P = 0; P <= 2; P++ ) {\n      for ( Q = 0; Q <= 2; Q++ ) {\n\tfor ( R = 0; R <= 2; R++ ) {\n\t  p = 0;\n\t  if ( dfs() == 2 ) cnt++;\n\t}\n      }\n    }\n    cout << cnt << endl;  \n  }  \n       \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint pqr,now;\nstring s;\n\nint formula(void){\n\t\n\tif(isdigit(s[now])){return s[now++]-'0';}\n\tif(isupper(s[now])){now++;return (pqr>>(s[now]-'P'))&1;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tres=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\tfor(pqr=0;pqr<(1<<3);pqr++){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nint expr(string&, int&);\nint term(string&, int&);\nint number(string&, int&);\n\nint number(string& s, int& i){\n    int c = s[i] - '0';\n    i++;\n    return c;\n}\n\nint term(string& s,int& i){\n    if(isdigit(s[i]))return number(s,i);\n    if(s[i] == '-'){\n        while(s[i] == '-'){\n            int val;\n            i++;\n            val = term(s,i);\n            if(val == 2){\n                val = 0;\n            }\n            else if(val == 0){\n                val = 2;\n            }\n            return val;\n        }\n    }\n    i++;\n    int res = expr(s,i);\n    i++;\n    return res;\n}\n\nint expr(string& s, int& i){\n    int val = term(s,i);\n    while(s[i] == '*' || s[i] == '+'){\n        char op = s[i];\n        i++;\n        int val2 = term(s,i);\n        if(op == '*'){\n            if(val == 0 || val2 == 0){\n                val = 0;\n            }\n            else if(val == 1 || val2 == 1){\n                val =  1;\n            }\n            else{\n                val = 2;\n            }\n        }\n        else if(op == '+'){\n            if(val == 2 || val2 == 2){\n                val = 2;\n            }\n            else if(val == 1 || val2 == 1){\n                val = 1;\n            }\n            else{\n                val = 0;\n            }\n        }\n    }\n    //cout << \"# \" << val << \"\\n\";\n    return val;\n}\nint solve(string str,int depth){\n    if(depth == 3){\n        int idx = 0;\n        return expr(str,idx) == 2;\n    }\n    string a,b,c;\n    rep(i,str.size()){\n        if(str[i] == 'P'+depth){\n            a += \"0\";\n            b += \"1\";\n            c += \"2\";\n        }\n        else{\n            a += str[i];\n            b += str[i];\n            c += str[i];\n        }\n    }\n    return solve(a,depth+1) + solve(b,depth+1) + solve(c,depth+1);\n}\nint main(){\n    string str;\n    while(true){\n        cin >> str;\n        if(str == \".\"){\n            break;\n        }\n        printf(\"%d\\n\",solve(str,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// type {{{\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvll = vector<vector<ll>>;\n// }}}\n\n\n// macro {{{\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define RREP(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i,a,n) for (int i=(a); i<(n); ++i)\n#define RFOR(i,a,n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n// }}}\n\n\n// debug {{{\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    REP (i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n// }}}\n\n\n// chmax, chmin {{{\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// }}}\n\n\n// constants {{{\n#define inf(T) (numeric_limits<T>::max() / 2)\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n// }}}\n\n\nusing State = string::const_iterator;\nclass ParseError {};\n\nvector<int> val;\n\nint formula(State& begin) {\n    if (*begin == '-') {\n        ++begin;\n        int ret = formula(begin);\n        if (ret == 0) return 2;\n        if (ret == 1) return 1;\n        if (ret == 2) return 0;\n        throw ParseError();\n    }\n    if (*begin == '(') {\n        ++begin;\n        int lhs = formula(begin);\n        char op = *begin;\n        ++begin;\n        int rhs = formula(begin);\n        if (*begin != ')') throw ParseError();\n        ++begin;\n        if (op == '*') return min(lhs, rhs);\n        if (op == '+') return max(lhs, rhs);\n        throw ParseError();\n    }\n    if ('0' <= *begin and *begin <= '2') {\n        int ret = *begin - '0';\n        ++begin;\n        return ret;\n    }\n    if ('P' <= *begin and *begin <= 'R') {\n        int ret = val[*begin - 'P'];\n        ++begin;\n        return ret;\n    }\n    throw ParseError();\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        string s; cin >> s;\n        if (s == \".\") break;\n\n        int ans = 0;\n\n        val.assign(4, 0);\n\n        while (!val[3]) {\n            State begin = s.begin();\n\n            int ret = formula(begin);\n            if (ret == 2) ++ans;\n\n            for (int i = 0; ++val[i] == 3; ++i) val[i] = 0;\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\nstring s,tmp;\nchar aa[]={'P','Q','R'};\n\nstring schange(string s,char a,char b){\n\trep(i,s.size()){\n\t\tif(s[i]==a){\n\t\t\ts[i]=b;\n\t\t}\n\t}\n\treturn s;\n}\n\nstring NOT(string t){\n\tif(t[1]=='1') return \"1\";\n\telse if(t[1]=='2') return \"0\";\n\treturn \"2\";\n}\nstring AND(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==0||b==0) return \"0\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"2\";\n}\nstring OR(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==2||b==2) return \"2\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"0\";\n}\nbool isnum(char t){\n\tif(t>='0'&&t<='2') return true;\n\treturn false;\n}\n\nint calc(string tmp){\n\t// cout<<tmp<<endl;\n\tif(tmp.size()==1&&tmp[0]=='2') return 2;\n\telse if(tmp.size()==1) return 0;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='('){\n\t\t\tif(tmp[i+2]==')'){\n\t\t\t\ttmp=tmp.substr(0,i)+tmp.substr(i+1,1)+tmp.substr(i+3);\n\t\t\t}\n\t\t}\n\t\telse if(tmp[i]=='-'){\n\t\t\tif(isnum(tmp[i+1])){\n\t\t\t\ttmp=tmp.substr(0,i)+NOT(tmp.substr(i,2))+tmp.substr(i+2);\n\t\t\t}\n\t\t}\n\t\telse if(tmp[i]=='*'){\n\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\ttmp=tmp.substr(0,i-1)+AND(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t}\n\t\t}\n\t\telse if(tmp[i]=='+'){\n\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\ttmp=tmp.substr(0,i-1)+OR(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn calc(tmp);\n}\n\nint solve(){\n\tint ans=0;\n\tint c=0;\n\trep(i,3){\n\t\tif(s.find(aa[i])){\n\t\t\ts = schange(s,aa[i],'a'+c);\n\t\t\tc++;\n\t\t}\n\t}\n\t// cout<<s<<endl;\n\trep(i,3){\n\t\trep(j,3){\n\t\t\trep(k,3){\n\t\t\t\ttmp=s;\n\t\t\t\t// cout<<tmp<<endl;\n\t\t\t\ttmp = schange(tmp,'a',i+'0');\n\t\t\t\ttmp = schange(tmp,'b',j+'0');\n\t\t\t\ttmp = schange(tmp,'c',k+'0');\n\t\t\t\t// cout<<tmp<<endl;\n\t\t\t\tif(calc(tmp)==2){\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout<<\"ans \"<<ans<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\n}\n\n\nint main(){\n\twhile(cin>>s,s!=\".\"){\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#define OR(a,b) a > b ? a : b\n#define AND(a,b) a > b ? b : a\n#define NOT(n) 1 - (n - 1)\n\nint p[3];\nchar str[81];\n\nint formula(int i){\n\tif(isupper(str[i]))\n\t\treturn p[str[i] - 'P'];\n\telse if(isdigit(str[i]))\n\t\treturn str[i] - '0';\n\telse if(str[i] == '-')\n\t\treturn NOT(formula(i + 1));\n\telse if(str[i] == '('){\n\t\tint j = i;\n\t\tint cen = 0;\n\t\twhile(1){\n\t\t\tif(str[++j] == '(')\n\t\t\t\tcen++;\n\t\t\telse if(str[j] == ')')\n\t\t\t\tcen--;\n\t\t\tif(cen == 0 && (str[j] == '*' || str[j] == '+')){\n\t\t\t\tif(str[j] == '*')\n\t\t\t\t\treturn AND(formula(i + 1),formula(j + 1));\n\t\t\t\telse\n\t\t\t\t\treturn OR(formula(i + 1),formula(j + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint count;\n\tgets(str);\n\twhile(str[0] != '.'){\n\t\tstr[strlen(str)] = '\\0';\n\t\tcount = 0;\n\t\tfor(p[0] = 0;p[0] <= 2;p[0]++){\n\t\t\tfor(p[1] = 0;p[1] <= 2;p[1]++){\n\t\t\t\tfor(p[2] = 0;p[2] <= 2;p[2]++){\n\t\t\t\t\tif(formula(0) == 2)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t\tgets(str);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <numeric>\n#include <queue>\n#include <climits>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <cstring>\n#include <map>\nusing namespace std;\nusing ll = long long;\n#define MOD 1000000007\n#define INF 1LL << 59\nusing ld = long double;\nconst int MAX = 510000;\n\nint t[3] = {2, 1, 0};\n\nint seki[3][3] = {{0, 0, 0},\n                  {0, 1, 1},\n                  {0, 1, 2}};\n\nint wa[3][3] = {\n    {0, 1, 2},\n    {1, 1, 2},\n    {2, 2, 2}};\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    //cout << fixed << setprecision(5);\n\n    string s;\n    while (cin >> s)\n    {\n        if (s == \".\")\n            break;\n\n        int n = s.size();\n        int ans = 0;\n        for (int i = 0; i < 3; ++i)\n        { // P\n            for (int j = 0; j < 3; ++j)\n            { // Q\n                for (int k = 0; k < 3; ++k)\n                { // R\n                    stack<int> c;\n                    stack<char> ope;\n                    for (int len = 0; len < n; ++len)\n                    {\n                        if (s[len] == '-' || s[len] == '(' || s[len] == '*' || s[len] == '+')\n                        {\n                            ope.push(s[len]);\n                        }\n                        else if (s[len] != ')')\n                        {\n                            bool jud = true;\n                            while (ope.size() > 0 && ope.top() == '-')\n                            {\n                                if (jud == true)\n                                    jud = false;\n                                else\n                                    jud = true;\n                                ope.pop();\n                            }\n                            if (s[len] == 'P')\n                            {\n                                if (!jud)\n                                    c.push(t[i]);\n                                else\n                                    c.push(i);\n                            }\n                            else if (s[len] == 'Q')\n                            {\n                                if (!jud)\n                                    c.push(t[j]);\n                                else\n                                    c.push(j);\n                            }\n                            else if (s[len] == 'R')\n                            {\n                                if (!jud)\n                                    c.push(t[k]);\n                                else\n                                    c.push(k);\n                            }\n                            else\n                            {\n                                if (!jud)\n                                    c.push(t[(int)s[len] - '0']);\n                                else\n                                    c.push((int)s[len] - '0');\n                            }\n                        }\n                        else if (s[len] == ')')\n                        {\n                            char opt = ope.top();\n                            ope.pop();\n                            int a = c.top();\n                            c.pop();\n                            int b = c.top();\n                            c.pop();\n                            int num = 0;\n                            if (opt == '+')\n                            {\n                                num = wa[b][a];\n                            }\n                            else if (opt == '*')\n                            {\n                                num = seki[b][a];\n                            }\n                            bool jud = true;\n                            ope.pop();\n                            while (ope.size() > 0 && ope.top() == '-')\n                            {\n                                jud = jud ? false : true;\n                                ope.pop();\n                            }\n\n                            num = jud ? num : t[num];\n                            c.push(num);\n                        }\n                        //cout << ope.size() << \" \" << ope.top() << endl;\n                    }\n\n                    if (c.top() == 2)\n                        ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nbool is_operator(char ch){\n\treturn (ch == '-' || ch == '*' || ch == '+');\n}\n\nstring toRPN(string str){\n\tstring res=\"\";\n\tstack<char> st;\n\tqueue<char> que;\n\tfor(int i=0; i<str.size(); i++){\n\t\tif(is_operator(str[i])){\n\t\t\twhile(1){\n\t\t\t\tif(st.empty() || !is_operator(st.top()) || str[i] == '-') break;\n\t\t\t\tque.push(st.top());\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.push(str[i]);\n\t\t} else if(str[i] == '('){\n\t\t\tst.push(str[i]);\n\t\t} else if(str[i] == ')'){\n\t\t\twhile(!(st.top() == '(')){\n\t\t\t\tque.push(st.top());\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.pop();\n\t\t} else{\n\t\t\tque.push(str[i]);\n\t\t}\n\t}\n\n\twhile(!st.empty()){\n\t\tque.push(st.top());\n\t\tst.pop();\n\t}\n\twhile(!que.empty()){\n\t\tres += que.front();\n\t\tque.pop();\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tstring str; cin >> str;\n\t\tif(str == \".\") break;\n\t\tstr = toRPN(str);\n\n\t\tint ans=0;\n\t\tfor(int p=0; p<3; p++){\n\t\t\tfor(int q=0; q<3; q++){\n\t\t\t\tfor(int r=0; r<3; r++){\n\t\t\t\t\tstack<int> st;\n\t\t\t\t\tfor(int i=0; i<str.size(); i++){\n\t\t\t\t\t\tif(str[i] == 'P') st.push(p);\n\t\t\t\t\t\telse if(str[i] == 'Q') st.push(q);\n\t\t\t\t\t\telse if(str[i] == 'R') st.push(r);\n\t\t\t\t\t\telse if(isdigit(str[i])) st.push(str[i]-'0');\n\t\t\t\t\t\telse if(str[i] == '-'){\n\t\t\t\t\t\t\tint x = st.top();\n\t\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\t\tst.push(2-x);\n\t\t\t\t\t\t} else if(str[i] == '*'){\n\t\t\t\t\t\t\tint x = st.top(); st.pop();\n\t\t\t\t\t\t\tint y = st.top(); st.pop();\n\t\t\t\t\t\t\tst.push(min(x, y));\n\t\t\t\t\t\t} else if(str[i] == '+'){\n\t\t\t\t\t\t\tint x = st.top(); st.pop();\n\t\t\t\t\t\t\tint y = st.top(); st.pop();\n\t\t\t\t\t\t\tst.push(max(x, y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(st.top() == 2) ans++;\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint p,q,r;\nvoid invert(stack<int> &st){\n    int x;\n    x=st.top();\n    st.pop();\n    while(!st.empty()){\n        if(st.top()!=-1)break;\n\t\tst.pop();\n        x=(x-1)*(-1)+1;\n\t//\tcout << st.size();\n    }\n\tst.push(x);\n    return;\n}\n\nvoid calc(stack<int> &st){\n\tint x,y;\n\twhile(true){\n\t\tinvert(st);\n\t\tx=st.top();\n\t\tst.pop();\n\t\tif(st.top()==-4){\n\t\t\tst.pop();\n\t\t\tst.push(x);\n\t\t\tinvert(st);\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tint t=st.top();\n\t\t\tst.pop();\n\t\t\tinvert(st);\n\t\t\tif(t==-2){\n\t\t\t\ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(max(x,y));\n\t\t\t}\n\t\t\telse if(t==-3){\n\t\t\t\ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(min(x,y));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(true){\n\t\tstring str;\n\t\tcin >> str;\n\t\tint ans=0;\n\t\tstack<int> st;\n\t\tif(str[0]=='.')break;\n\t\tfor(p=0;p<3;p++){\n\t\tfor(q=0;q<3;q++){\n\t\tfor(r=0;r<3;r++){\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(str[i]=='(')st.push(-4);\n\t\t\t\telse if(str[i]=='-')st.push(-1);\n\t\t\t\telse if(str[i]=='+')st.push(-2);\n\t\t\t\telse if(str[i]=='*')st.push(-3);\n\t\t\t\telse if(str[i]=='P')st.push(p);\n\t\t\t\telse if(str[i]=='Q')st.push(q);\n\t\t\t\telse if(str[i]=='R')st.push(r);\n\t\t\t\telse if(str[i]==')')calc(st);\n\t\t\t\telse st.push((int)(str[i]-'0'));\n\t\t\t}\t\n\t\t\tif(st.top()==2)ans++;\n\t\t}\n\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring in;\nint index;\n\nint formula(int p,int q,int r);\nint formula2(int p,int q,int r);\n\nint formula(int p,int q,int r){\n\tint num;\n\tif(in[index]=='0'){\n\t\tindex++;\n\t\treturn 0;\n\t}\n\tif(in[index]=='1'){\n\t\tindex++;\n\t\treturn 1;\n\t}\n\tif(in[index]=='2'){\n\t\tindex++;\n\t\treturn 2;\n\t}\n\tif(in[index]=='P'){\n\t\tindex++;\n\t\treturn p;\n\t}\n\tif(in[index]=='Q'){\n\t\tindex++;\n\t\treturn q;\n\t}\n\tif(in[index]=='R'){\n\t\tindex++;\n\t\treturn r;\n\t}\n\tif(in[index]=='-'){\n\t\tindex++;\n\t\tnum=formula(p,q,r);\n\t\tif(num==0) num=2;\n\t\telse if(num==2) num=0;\n\t\telse num=1;\n\t\treturn num;\n\t}\n\tif(in[index]=='('){\n\t\tindex++;\n\t\tnum=formula2(p,q,r);\n\t\treturn num;\n\t}\n}\nint formula2(int p,int q, int r){\n\tint num1;\n\tif(in[index]=='('){\n\t\tindex++;\n\t\tnum1=formula2(p,q,r);\n\t}\n\telse num1=formula(p,q,r);\n\n\tchar c=in[index];\n\tindex++;\n\n\tint num2;\n\tif(in[index]=='('){\n\t\tindex++;\n\t\tnum2=formula2(p,q,r);\n\t}\n\telse num2=formula(p,q,r);\n\n\tindex++;\n\tif(c=='*'){\n\t\tif(num1==0||num2==0) return 0;\n\t\tif(num1==1||num2==1) return 1;\n\t\treturn 2;\n\t}\n\telse{\n\t\tif(num1==2||num2==2) return 2;\n\t\telse if(num1==1||num2==1) return 1;\n\t\treturn 0;\n\t}\n}\n\n\nint main(){\n\n\tint pdata[]={0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2};\n\tint qdata[]={0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2};\n\tint rdata[]={0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2};\n\tint cnt;\n\n\twhile(1){\n\n\t\tcin>>in;\n\t\tif(in==\".\") break;\n\n\t\tcnt=0;\n\t\tfor(int i=0;i<27;i++){\n\t\t\tindex=0;\n\t\t\tif(formula(pdata[i],qdata[i],rdata[i])==2) cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\nint not[3]={2,1,0};\nint and[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint or[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nint p,q,r;\nchar s[128],*pos;\nint formula(){\n\tchar c=*pos++;\n\tswitch(c){\n\tcase '0':return 0;\n\tcase '1':return 1;\n\tcase '2':return 2;\n\tcase 'P':return p;\n\tcase 'Q':return q;\n\tcase 'R':return r;\n\tcase '-':return not[formula()];\n\tcase '(':\n\t\tint a,b;\n\t\ta=formula();\n\t\tc=*pos++;\n\t\tb=formula();\n\t\tpos++;\n\t\tif(c=='*')return and[a][b];\n\t\treturn or[a][b];\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(cin>>s,s[0]!='.'){\n\t\tint ans=0;\n\t\tfor(p=0;p<=2;p++){\n\t\t\tfor(q=0;q<=2;q++){\n\t\t\t\tfor(r=0;r<=2;r++){\n\t\t\t\t\tpos=s;\n\t\t\t\t\tif(formula()==2)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstring str;\nint idx;\n\n\nint getn() {\n    char c = str[idx];\n    idx++;\n    if (c == '-') {\n        return 2-getn();\n    } else {\n        return c-'0';\n    }\n}\n\nint calc() {\n    char c = str[idx];\n    if (c == '(') {\n        idx++;\n        int r1 = calc();\n        char cc = str[idx];\n        idx++;\n        int r2 = calc();\n        idx++;\n        if (cc == '*') {\n            return min(r1, r2);\n        } else {\n            return max(r1, r2);\n        }\n    } else {\n        return getn();\n    }\n}\n\nint main() {\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \".\") break;\n        int res = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    str = \"\";\n                    for (int i = 0; i < s.size(); i++) {\n                        switch (s[i]) {\n                        case 'P':\n                            str += to_string(p);\n                            break;\n                        case 'Q':\n                            str += to_string(q);\n                            break;\n                        case 'R':\n                            str += to_string(r);\n                            break;\n                        default:\n                            str += s[i];\n                            break;\n                        }\n                    }\n                    str += '=';\n                    idx = 0;\n                    cerr << str << endl;\n                    if (calc() == 2) {\n                        cerr << \"asdkfjf\" << endl;\n                        res++;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cctype>\n#include <string>\n#include <cassert>\nusing namespace std;\nstring S;\nint PQR[3];\nint cur = 0;\nint formula();\nint kakko();\nint formula(){\n  char c = S[cur];\n  cur++;\n  if(isdigit(c)){\n    return c -'0';\n  }else if(isupper(c)){\n    return PQR[c-'P'];\n  }else if(c == '-'){\n    int tmp = formula();\n    if(tmp == 2)return 0;\n    else if(tmp == 1)return 1;\n    else return 2;\n  }else{\n    int tmp = kakko();\n    return tmp;\n  }\n  return -1;\n}\nint kakko(){\n  int f = formula();\n  char op = S[cur];\n  cur++;\n  int s = formula();\n  assert(S[cur] == ')');\n  cur++;\n  if(op == '*'){\n    //cout << f << \" \" << s << endl;\n    return min(f,s);\n  }else if(op == '+'){\n    return max(f,s);\n  }\n  return -1;\n}\nint main(){\n  while(cin >> S,S != \".\"){\n    int cnt = 0;\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n\tfor(int k = 0;k < 3;k++){\n\t  cur = 0;\n\t  PQR[0] = i;\n\t  PQR[1] = j;\n\t  PQR[2] = k;\n\t  if(formula() == 2)cnt++;\n\t}\n      }\n    }\n      \n    \n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<iostream>\nusing namespace std;\nstring mon;\nint P,Q,R,it;\nint solve(void){//?????°???????????????????????????\n\tit++;\n\tif(mon[it]=='0'){return 0;}\n\tif(mon[it]=='1'){return 1;}\n\tif(mon[it]=='2'){return 2;}\n\tif(mon[it]=='P'){return P;}\n\tif(mon[it]=='Q'){return Q;}\n\tif(mon[it]=='R'){return R;}\n\tif(mon[it]=='-'){return 2-solve();}\n\tif(mon[it]=='('){\n\t\tint sk,at;\n\t\tchar en;\n\t\tsk=solve();\n\t\tit++;\n\t\ten=mon[it];\n\t\tat=solve();\n\t\tit++;\n\t\tif(en=='+'){return max(sk,at);}\n\t\telse{return min(sk,at);}\n\t}\n\treturn 9999;\n\tcout<<\"BUG!!!\"<<endl;\n}\nint main(void){//solve????§£????????????\n\tint ans;\n\twhile(-1){\n\t\tmon.clear();cin>>mon;ans=0;\n\t\tif(mon==\".\"){return 0;}\n\t\tfor(P=0;P<3;P++){for(Q=0;Q<3;Q++){for(R=0;R<3;R++){\n\t\t\tit=-1;//?????????+1????????????????????§????????????\n\t\t\tif(solve()==2){ans++;}\n\t\t}}}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\nclass Parser_ {\npublic:\n  int operator() (std::string str_) {\n    str = str_;\n    i = 0;\n    return calc().first;\n  }\n  std::pair<int, int> calc() {\n    return formula(0);\n  }\n  std::pair<int, int> formula(int i) {\n    auto v = value(i);\n    if( v.second != i ) return v;\n    i = v.second;\n    char c1 = str[i]; i += 1;\n    if( c1 == '-' ) {\n      auto f1 = formula(i);\n      return std::pair<int, int>(2 - f1.first, f1.second);\n    }\n    assert( c1 == '(' );\n    auto f1 = formula(i);\n    i = f1.second;\n    char c2 = str[i]; i += 1;\n    auto f2 = formula(i);\n    i = f2.second;\n    int res = 0;\n    assert( c2 == '+' or c2 == '*' );\n    if( c2 == '+' ) {\n      res = std::max(f1.first, f2.first);\n    }\n    else {\n      res = std::min(f1.first, f2.first);\n    }\n    if( str[i] != ')' ) {\n      std::cerr << str[i] << std::endl;\n      assert(0);\n    }\n    i += 1; // pass ')'\n    return std::pair<int, int>(res, i);    \n  }\n  std::pair<int, int> value(int i) {\n    if( '0' <= str[i] and str[i] <= '2' ) {\n      return std::pair<int, int>(str[i]-'0', i + 1);\n    }\n    return std::pair<int, int>(0, i);\n  }    \nprivate:\n  std::string str;\n  int i;\n};\nParser_ Parser;\n\nstd::string Assign(std::string str, int P, int Q, int R) {\n  for(int i = 0; i < (int)str.size(); ++i) {\n    if( str[i] == 'P' ) str[i] = P + '0';\n    if( str[i] == 'Q' ) str[i] = Q + '0';\n    if( str[i] == 'R' ) str[i] = R + '0';\n  }\n  return str;\n}\n\nint main() {\n  for(;;) {\n    std::string str;\n    std::cin >> str;\n    if( str == \".\" ) break;\n\n    int count = 0;\n    for(int i = 0; i < 3; ++i) {\n      for(int j = 0; j < 3; ++j) {\n        for(int k = 0; k < 3; ++k) {\n          if( Parser(Assign(str, i, j, k)) == 2 ) count += 1;\n        }\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nint expr(string&, int&);\nint term(string&, int&);\nint number(string&, int&);\n\nint number(string& s, int& i){\n    int c = s[i] - '0';\n    i++;\n    return c;\n}\n\nint term(string& s,int& i){\n    if(isdigit(s[i]))return number(s,i);\n    if(s[i] == '-'){\n        while(s[i] == '-'){\n            int val;\n            i++;\n            val = term(s,i);\n            if(val == 2){\n                val = 0;\n            }\n            else if(val == 0){\n                val = 2;\n            }\n            return val;\n        }\n    }\n    i++;\n    int res = expr(s,i);\n    i++;\n    return res;\n}\n\nint expr(string& s, int& i){\n    int val = term(s,i);\n    while(s[i] == '*' || s[i] == '+'){\n        char op = s[i];\n        i++;\n        int val2 = term(s,i);\n        if(op == '*'){\n            if(val == 0 || val2 == 0){\n                val = 0;\n            }\n            else if(val == 1 || val2 == 1){\n                val =  1;\n            }\n            else{\n                val = 2;\n            }\n        }\n        else if(op == '+'){\n            if(val == 2 || val2 == 2){\n                val = 2;\n            }\n            else if(val == 1 || val2 == 1){\n                val = 1;\n            }\n            else{\n                val = 0;\n            }\n        }\n    }\n    //cout << \"# \" << val << \"\\n\";\n    return val;\n}\n\nmap <string,int> memo;\nmap <string,int> used;\nint solve(string str,int depth){\n    if(memo[str])return memo[str];\n    if(depth == 3){\n        used[str] = 1;\n        int idx = 0;\n        //cout << str << \"\\n\";\n        int res = expr(str,idx);\n        //cout << res << \"\\n\";\n        if(res == 2){\n            memo[str] = 1;\n        }\n        return memo[str];\n    }\n    string a,b,c;\n    rep(i,str.size()){\n        if(str[i] == 'P'+depth){\n            a += \"0\";\n            b += \"1\";\n            c += \"2\";\n        }\n        else{\n            a += str[i];\n            b += str[i];\n            c += str[i];\n        }\n    }\n    memo[str] = solve(a,depth+1) + solve(b,depth+1) + solve(c,depth+1);\n    return memo[str];\n}\nint main(){\n    string str;\n    while(true){\n        cin >> str;\n        if(str == \".\"){\n            break;\n        }\n        printf(\"%d\\n\",solve(str,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef int value;\n\nstring s;\nsize_t cur = 0;\nvalue P, Q, R;\nint ans = 0;\n\nvalue Formula();\n\nvalue Not(){\n\tassert(s[cur] == '-');\n\tcur++;\n\treturn 2 - Formula();\n}\nvalue And(value a, value b){\n\treturn (a<b) ? a : b;\n}\nvalue Or(value a, value b){\n\treturn (a<b) ? b : a;\n}\nvalue Formula(){\n\tvalue a, b, f;\n\tchar op;\n\tswitch (s[cur]){\n\tcase ('0') :\n\tcase ('1') :\n\tcase ('2') :\n\t\t\t   f = s[cur] - '0';\n\t\tcur++;\n\t\tbreak;\n\tcase ('P') :\n\t\tf = P;\n\t\tcur++;\n\t\tbreak;\n\tcase ('Q') :\n\t\tf = Q;\n\t\tcur++;\n\t\tbreak;\n\tcase ('R') :\n\t\tf = R;\n\t\tcur++;\n\t\tbreak;\n\tcase ('-') :\n\t\tf = Not();\n\t\tbreak;\n\tcase ('(') :\n\t\tcur++;\n\t\ta = Formula();\n\t\tassert(s[cur] == '*' || s[cur] == '+');\n\t\top = s[cur];\n\t\tcur++;\n\t\tb = Formula();\n\t\tf = (op == '*') ? And(a, b) : Or(a, b);\n\t\tassert(s[cur] == ')');\n\t\tcur++;\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t\tbreak;\n\t}\n\treturn f;\n}\nint main(){\n\tcin >> s;\n\twhile (s != \".\"){\n\t\tfor (P = 0; P <= 2; P++)\n\t\t\tfor (Q = 0; Q <= 2; Q++)\n\t\t\t\tfor (R = 0; R <= 2; R++){\n\t\t\t\t\tif (Formula() == 2)ans++;\n\t\t\t\t\tcur = 0;\n\t\t\t\t}\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tcin >> s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint p, q, r;\n\nint calf(string s) {\n\tif(s.size() == 1) {\n\t\tif(s[0] == '0') return 0;\n\t\tif(s[0] == '1') return 1;\n\t\tif(s[0] == '2') return 2;\n\t\tif(s[0] == 'P') return p;\n\t\tif(s[0] == 'Q') return q;\n\t\tif(s[0] == 'R') return r;\n\t} else {\n\t\tif(s[0] == '-') {\n\t\t\tint n = calf(s.substr(1, s.size() - 1));\n\t\t\tswitch(n) {\n\t\t\t\tcase 0: return 2;\n\t\t\t\tcase 1: return 1;\n\t\t\t\tcase 2: return 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint r = 0;\n\t\t\tREP(i, s.size()) {\n\t\t\t\tif(s[i] == '(') ++r;\n\t\t\t\tif(s[i] == ')') --r;\n\t\t\t\tif(r == 1 && s[i] == '*') {\n\t\t\t\t\tint x = calf(s.substr(1, i - 1));\n\t\t\t\t\tint y = calf(s.substr(i + 1, s.size() - 3 - (i - 1)));\n\t\t\t\t\tif(x == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if(x == 1) {\n\t\t\t\t\t\tswitch(y) {\n\t\t\t\t\t\t\tcase 0: return 0;\n\t\t\t\t\t\t\tcase 1: return 1;\n\t\t\t\t\t\t\tcase 2: return 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(x == 2) {\n\t\t\t\t\t\tswitch(y) {\n\t\t\t\t\t\t\tcase 0: return 0;\n\t\t\t\t\t\t\tcase 1: return 1;\n\t\t\t\t\t\t\tcase 2: return 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(r == 1 && s[i] == '+') {\n\t\t\t\t\tint x = calf(s.substr(1, i - 1));\n\t\t\t\t\tint y = calf(s.substr(i + 1, s.size() - 3 - (i - 1)));\n\t\t\t\t\tif(x == 0) {\n\t\t\t\t\t\tswitch(y) {\n\t\t\t\t\t\t\tcase 0: return 0;\n\t\t\t\t\t\t\tcase 1: return 1;\n\t\t\t\t\t\t\tcase 2: return 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(x == 1) {\n\t\t\t\t\t\tswitch(y) {\n\t\t\t\t\t\t\tcase 0: return 1;\n\t\t\t\t\t\t\tcase 1: return 1;\n\t\t\t\t\t\t\tcase 2: return 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(x == 2) {\n\t\t\t\t\t\tswitch(y) {\n\t\t\t\t\t\t\tcase 0: return 2;\n\t\t\t\t\t\t\tcase 1: return 2;\n\t\t\t\t\t\t\tcase 2: return 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 114514;\n}\n\nint main(void) {\n\twhile(true) {\n\t\tstring s;\n\t\tcin>>s;\n\t\tll ans = 0;\n\t\tif(s == \".\") break;\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tp = i;\n\t\t\t\t\tq = j;\n\t\t\t\t\tr = k;\n\t\t\t\t\tif(calf(s) == 2) ++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nchar NOT(char a)\n{\n  if(a=='0')return '2';\n  if(a=='1')return '1';\n  return '0';\n}\n\nchar OR(char a,char b)\n{\n  if(a=='0' && b=='0')return '0';\n  if(a=='2' || b=='2')return '2';\n  return '1';\n}\n\nchar AND(char a,char b)\n{\n  if(a=='2' && b=='2')return '2';\n  if(a=='0' || b=='0')return '0';\n  return '1';\n}\n\nchar Check(int x,int y,int z,string s)\n{\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='P')s[i]='0'+x;\n    if(s[i]=='Q')s[i]='0'+y;\n    if(s[i]=='R')s[i]='0'+z;\n  }\n  char a,b,c;\n  stack<char> S;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='0' || s[i]=='1' || s[i]=='2'){\n      S.push(s[i]);\n      while(1){\n\tif(S.size()==1)break;\n\ta = S.top();S.pop();\n\tc = S.top();\n\tif(c=='('){\n\t  S.push(a);\n\t  break;\n\t}\n\tS.pop();\n        if(c=='+'){\n\t  b=S.top();S.pop();\n\t  S.push(OR(b,a));\n\t}\n\telse if(c=='*'){\n\t  b=S.top();S.pop();\n\t  S.push(AND(b,a));\n\t}\n\telse{\n\t  S.push(NOT(a));\n\t}\n      }\n    }\n    else if(s[i]==')'){\n      while(1){\n\ta = S.top();S.pop();\n        c = S.top();S.pop();\n\tif(c=='('){\n          S.push(a);\n\t  while(1){\n\t    if(S.size()==1)break;\n\t    a = S.top();S.pop();\n\t    c = S.top();\n\t    if(c=='('){\n\t      S.push(a);\n\t      break;\n\t    }\n\t    S.pop();\n\t    if(c=='+'){\n\t      b=S.top();S.pop();\n\t      S.push(OR(b,a));\n\t    }\n\t    else if(c=='*'){\n\t      b=S.top();S.pop();\n\t      S.push(AND(b,a));\n\t    }\n\t    else{\n\t      S.push(NOT(a));\n\t    }\n\t  }\n\t  break;\n\t}\n        else if(c=='+'){\n\t  b=S.top();S.pop();\n\t  S.push(OR(b,a));\n\t}\n\telse if(c=='*'){\n\t  b=S.top();S.pop();\n\t  S.push(AND(b,a));\n\t}\n\telse{\n\t  S.push(NOT(a));\n\t}\n      }\n    }\n    else S.push(s[i]);\n  }\n  return S.top();\n}\n\nint main()\n{\n  string s;\n  int ans;\n  while(1){\n    cin>>s;\n    if(s[0]=='.')break;\n    ans=0;\n    s='('+s+')';\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  if(Check(i,j,k,s)=='2')ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstring S;\n\nint calc(int p, int q, int r) {\n  stack<int> s;\n  REP(i, 0, S.length()) {\n    int n = -1;\n    char c = S[i];\n    if(c == '(') s.push('(');\n    if(c == '*') s.push('*');\n    if(c == '+') s.push('+');\n    if(c == 'P') n = p;\n    if(c == 'Q') n = q;\n    if(c == 'R') n = r;\n    if('0' <= c && c <= '2') n = c - '0';\n    if(c == '-') s.push('-');\n    if(c == ')') {\n      int v1 = s.top(); s.pop();\n      int op = s.top(); s.pop();\n      int v2 = s.top(); s.pop();\n      s.pop();\n      if(op == '*') {\n        if(v1 == 2 && v2 == 2) n = 2;\n        else if(v1 == 0 || v2 == 0) n = 0;\n        else n = 1;\n      }\n      if(op == '+') {\n        if(v1 == 0 && v2 == 0) n = 0;\n        else if(v1 == 2 || v2 == 2) n = 2;\n        else n = 1;\n      }\n    }\n    if(n != -1) {\n      while(!s.empty() && s.top() == '-') {\n        s.pop();\n        n = 2 - n;\n      }\n      s.push(n);\n    }\n  }\n\n  return s.top();\n}\n\nint main(void) {\n  while(cin >> S, S != \".\") {\n    int ans = 0;\n    REP(p, 0, 3) REP(q, 0, 3) REP(r, 0, 3) {\n      if(calc(p, q, r) == 2) ans++;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint NOT(int x){\n  if(x==0) return 2;\n  else if(x==1) return 1;\n  else return 0;\n}\n\nint AND(int x,int y){\n  if(x==2&&y==2) return 2;\n  else if(x==0||y==0) return 0;\n  else return 1;\n}\n\nint OR(int x,int y){\n  if(x==2||y==2) return 2;\n  else if(x==0&&y==0) return 0;\n  else return 1;\n}\n\nstruct State{\n  int value;\n  int backpos;\n  State(int a,int b) {\n    value   = a;\n    backpos = b;\n  }\n  State(){\n    value=0;\n    backpos=0;\n  }\n};\n\nState formula(const std::string& s,const int frontpos){\n  char c=s[frontpos];\n  if(c=='0'){\n    return State(0,frontpos);\n  }else if(c=='1'){\n    return State(1,frontpos);\n  }else if(c=='2'){\n    return State(2,frontpos);\n  }else if(c=='-'){\n    State result=formula(s,frontpos+1);\n    result.value=NOT(result.value);\n    return result;\n  }else if(c=='('){\n    int right_front=frontpos+1;\n    int bracket=0;\n    for(;right_front<s.size();right_front++){\n      if(s[right_front]=='('){\n        bracket++;\n      }else if(s[right_front]==')'){\n        bracket--;\n      }\n      if(bracket==0&&s[right_front]=='*'){\n        right_front++;\n        State left=formula(s,frontpos+1);\n        State right=formula(s,right_front);\n        State result(AND(left.value,right.value),right.backpos+1);\n        return result;\n      }else if(bracket==0&&s[right_front]=='+'){\n        right_front++;\n        State left=formula(s,frontpos+1);\n        State right=formula(s,right_front);\n        State result(OR(left.value,right.value),right.backpos+1);\n        return result;\n      }\n    }\n  }\n}\n\nint Solve(const std::string& s){\n  int result=0;\n  for(int p=0;p<=2;p++){\n    for(int q=0;q<=2;q++){\n      for(int r=0;r<=2;r++){\n        std::string replaced=s;\n        for(int i=0;i<replaced.size();i++){\n          if(replaced[i]=='P'){\n            replaced[i]=p+'0';\n          }else if(replaced[i]=='Q'){\n            replaced[i]=q+'0';\n          }else if(replaced[i]=='R'){\n            replaced[i]=r+'0';\n          }\n        }\n        // cerr<<replaced<<endl;\n        // cerr<<Perse(replaced,0)<<endl;\n\n        if(formula(replaced,0).value==2){\n          result++;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  while(1){\n    std::string s;\n    cin>>s;\n    if(s==\".\") break;\n    cout<<Solve(s)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nt_T string out_m2(v_<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)r_ ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            int v = a[h][W[wi]];            str s = tos(v);            if (abs(v) == inf || abs(v) == INF<T>())s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            str s = tos(a[h][w]);            if (abs(a[h][w]) == inf || abs(a[h][w]) == INF<T>())s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    r_ out_m2(a, hs, ws, key);}\nt_T string out_m2(v_<v_<v_<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    r_ ss.str();}\nstring out_m2(int a) {    stringstream ss;    ss << a;    r_ ss.str();}\nt_T string out_m2(T &a) {    stringstream ss;    ss << a;    r_ ss.str();}\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<out_m2(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<out_m2(x)<<\", \"<< debugName(y)<<\" = \"<<out_m2(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<out_m2(x)  << \", \" <<  debugName(y)<<\" = \"<<out_m2(y) <<\", \" debugName(z)<<\" = \"<<out_m2(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<\", \" <<  debugName(b)<<\" = \"<<out_m2(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.pb(v);\n    r_ a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    for (auto &&v:m) os << v << \" \";    r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nt_T void out(const vector<T>& A) {    rep(i, sz(A)-1){        cout<<A[i]<<\" \";    }    cout<<A[sz(A)-1]<< endl;}\nvoid out() { cout << \"\" << endl; }\n\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n\nvoid solve() {\n    auto fa = [&](int a) {\n        if (a == 0)return 2;\n        if (a == 1)return 1;\n        if (a == 2)return 0;\n    };\n    str S;\n    while (1) {\n        cin >> S;\n        if (S == \".\")break;\n        int N = sz(S);\n        vi rp(N);\n        {\n            vi last;\n            rer(i, N) {\n                if (S[i] == ')')last += i + 1;\n                if (S[i] == '(')rp[i] = last.back(), last.pop_back();\n            }\n        }\n        int cou = 0;\n        rep(P, 3)rep(Q, 3)\n                rep(R, 3) {\n                    auto ds = fix([&](auto ds, int l, int r) -> int {\n                        auto getv = [&]() {\n                            int minus = 0;\n                            while (S[l] == '-') {\n                                l++;\n                                minus++;\n                            }\n                            auto mi = [&](int v, int cou) {\n                                while (cou--) {\n                                    v = fa(v);\n                                }\n                                return v;\n                            };\n                            if (S[l] == '(') {\n                                int v = mi(ds(l, rp[l]), minus);\n                                l = rp[l];\n                                return v;\n                            }\n                            l++;\n                            if (S[l - 1] == 'P')return mi(P, minus);\n                            if (S[l - 1] == 'Q')return mi(Q, minus);\n                            if (S[l - 1] == 'R')return mi(R, minus);\n                            if (S[l - 1] == '0')return mi(0, minus);\n                            if (S[l - 1] == '1')return mi(1, minus);\n                            if (S[l - 1] == '2')return mi(2, minus);\n                            return 0ll;\n                        };\n                        //(じゃなければgetv\n                        int v;\n                        if (S[l] == '('){\n                            v = ds(l + 1, rp[l] - 1);\n                            l = rp[l];\n                        }\n                        else {\n                            v = getv();\n                        }\n                        auto ope = [&](int i, int lv, int rv) {\n                            if (S[i] == '*')return min(lv, rv);\n                            if (S[i] == '+')return max(lv, rv);\n                            return lv;\n                        };\n                        if (l == r)return v;\n                        else return ope(l, v, ds(l + 1, r));\n                    });\n                    if (ds(0, N) == 2) {\n                        cou++;\n                    }\n                }\n        out(cou);\n    }\n\n}\n\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define N_MAX 80\nstring s,s_copy;\nint ans=0;\nint point=0;\n\nchar ch(int i){\n\tif(i==0)\n\t\treturn '0';\n\telse if(i==1)\n\t\treturn '1';\n\telse return '2';\n}\n\nvoid set(int i,int j,int z){\n\ts_copy=s;\n\tint c=s.size();\n\tfor(int k=0;k<c;k++){\n\t\tif(s_copy[k]=='P') s_copy[k]=ch(i);\n\t\tif(s_copy[k]=='Q') s_copy[k]=ch(j);\n\t\tif(s_copy[k]=='R') s_copy[k]=ch(z);\n\t}\n}\n\nint mainus(int i){\n\tswitch (i){\n\tcase 0: return 2;\n\tcase 1: return 1;\n\tcase 2: return 0;\n\t}\n}\n\nint kakeru(int x,int y){\n\treturn x>y ? y:x;\n}\n\nint tasu(int x,int y){\n\treturn x>y ? x:y;\n}\n\nint calc(){ \n\tswitch(s_copy[point++]){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return mainus(calc());\n\t\tcase '(': \n\t\t\tint left=calc();\n\t\t\tchar temp=s_copy[point++];\n\t\t\tint right=calc();\n\t\t\tif(temp=='+')return tasu(left,right);\n\t\t\telse return kakeru(left,right);\n\t}\n}\n\n\n\nint main()\n{\n\t\twhile(true){\n\t\t\tcin>>s;\n\t\t\tif(s==\".\") break;\n\t\t\tfor(int i=0;i<=2;i++)\n\t\t\t\tfor(int j=0;j<=2;j++)\n\t\t\t\t\tfor(int z=0;z<=2;z++){\n\t\t\t\t\t\tset(i,j,z);\n\t\t\t\t\t\tpoint=0;\n\t\t\t\t\t\tif(calc()==2)\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\tcout<<ans<<\"\\n\";\n\t\t\t\tans=0;\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n#include <cctype>\n#include <cassert>\nusing namespace std;\ntypedef function<int(int[3])> node_t;\nint sub[3]={2,1,0};\nint mul[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint add[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nstring S;\nint cur=0;\nchar readchar()\n{\n    assert(cur < S.size());\n    char ret = S[cur];\n    cur += 1;\n    return ret;\n}\nnode_t parse()\n{\n    char c=readchar();\n    if(isdigit(c))\n        return [ =](int[3]){return c-'0'; };\n    if(isalpha(c))\n        return [ =](int a[3]){return a[c-'P']; };\n    node_t left=parse();\n    if(c=='-')\n        return [ =](int a[3]){return sub[left(a)]; };\n    assert(c=='(');\n    char op = readchar();\n    node_t right = parse();\n    ++cur;\n    if(op=='*')\n        return [ =](int a[3]){return mul[left(a)][right(a)]; };\n    return [ =](int a[3]){return add[left(a)][right(a)]; };\n}\nint solve()\n{\n    cur = 0;\n    auto tree = parse();\n    int count = 0;\n    for(int p:{0,1,2})\n        for(int q:{0,1,2})\n            for(int r:{0,1,2})\n            {\n                int a[] = {p, q, r};\n                if(tree(a) == 2)\n                    count++;\n            }\n    return count;\n}\n\nint main()\n{\n    cin >> S;\n    while(S!=\".\")\n    {\n        cout << solve() << endl;\n        cin >> S;\n    } \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\nint _not[3]={2,1,0};\nint _and[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint _or[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nint p,q,r;\nchar s[128],*pos;\nint formula(){\n\tchar c=*pos++;\n\tswitch(c){\n\tcase '0':return 0;\n\tcase '1':return 1;\n\tcase '2':return 2;\n\tcase 'P':return p;\n\tcase 'Q':return q;\n\tcase 'R':return r;\n\tcase '-':return _not[formula()];\n\tcase '(':\n\t\tint a,b;\n\t\ta=formula();\n\t\tc=*pos++;\n\t\tb=formula();\n\t\tpos++;\n\t\tif(c=='*')return _and[a][b];\n\t\treturn _or[a][b];\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(cin>>s,s[0]!='.'){\n\t\tint ans=0;\n\t\tfor(p=0;p<=2;p++){\n\t\t\tfor(q=0;q<=2;q++){\n\t\t\t\tfor(r=0;r<=2;r++){\n\t\t\t\t\tpos=s;\n\t\t\t\t\tif(formula()==2)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<stack>\nusing namespace std;\nint I;\nint dfs(string s,int ad){\n\tint ret = 0;\n\tfor(I = ad;I < s.size();I++){\n\t\t//cout<<I<<\"~\";\n\t\tif(s[I]=='('){\n\t\t\t//cout<<\"( \";\n\t\t\tret = dfs(s,I+1);\n\t\t\t//I--;\n\t\t}\n\t\telse if(s[I]==')'){\n\t\t\t//cout<<\") \";\n\t\t\t\n\t\t//cout<<\"[\"<<ret<<\"]\";\n\t\t\t//I++;\n\t\t\treturn ret;\n\t\t}\n\t\telse if(s[I]=='0'){\n\t\t\tret = 0;\n\t\t\t//cout<<\"0 \";\n\t\t}\n\t\telse if(s[I]=='1'){\n\t\t\tret = 1;\n\t\t\t//cout<<\"1 \";\n\t\t}\n\t\telse if(s[I]=='2'){\n\t\t\tret = 2;\n\t\t\t//cout<<\"2 \";\n\t\t}\n\t\telse if(s[I]=='-'){\n\t\t\t//cout<<\"- \";\n\t\t\tif(s[I+1]=='(')\n\t\t\t\tret = 2 - dfs(s,I+2);\n\t\t\telse\n\t\t\t\tret = 2 - dfs(s,I+1);\n\t\t\t//cout<<\"/ \";\n\t\t\t//I--;\n\t\t\t//cout<<ret<<\"~\";\n\t\t\t//return ret;\n\t\t}\n\t\telse if(s[I]=='*'){\n\t\t\t//cout<<\"* \";\n\t\t\tret = min(ret,dfs(s,I+1));\n\t\t\t//I--;\n\t\t}\n\t\telse if(s[I]=='+'){\n\t\t\t//cout<<\"+ \";\n\t\t\tret = max(ret,dfs(s,I+1));\n\t\t\t//I--;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tstring str;\n\twhile(cin>>str,str!=\".\"){\n\t\tfor(int i = 1;i < str.size();i++){\n\t\t\tif(str[i-1]=='-'&&str[i]=='-'){\n\t\t\t\tfor(int j = i+1;j < str.size();j++){\n\t\t\t\t\tstr[j-2] = str[j];\n\t\t\t\t}\n\t\t\t\tstring tmp=\"\";\n\t\t\t\tfor(int i = 0;i < str.size()-2;i++)\n\t\t\t\t\ttmp+=str[i];\n\t\t\t\tstr = tmp;\n\t\t\t}\n\t\t}\n\t\tstring t = \"(\";\n\t\tfor(int i = 0;i < str.size();i++){\n\t\t\tif(isdigit(str[i]))t+=\"(\",t+=str[i],t+=\")\";\n\t\t\telse if(str[i]=='P')t+=\"(\",t+=str[i],t+=\")\";\n\t\t\telse if(str[i]=='Q')t+=\"(\",t+=str[i],t+=\")\";\n\t\t\telse if(str[i]=='R')t+=\"(\",t+=str[i],t+=\")\";\n\t\t\telse t += str[i];\n\t\t}\n\t\tt+=\")\";\n\t\tstr = t;\n\t\t//cout<<str<<endl;\n\t\tint ans = 0;\n\t\tfor(int p = 0;p < 3;p++){\n\t\t\tfor(int q = 0;q < 3;q++){\n\t\t\t\tfor(int r = 0;r < 3;r++){\n\t\t\t\t\tstring s = str;\n\t\t\t\t\tfor(int i = 0;i < s.size();i++){\n\t\t\t\t\t\tif(s[i] == 'P')s[i] = p +'0';\n\t\t\t\t\t\tif(s[i] == 'Q')s[i] = q +'0';\n\t\t\t\t\t\tif(s[i] == 'R')s[i] = r +'0';\n\t\t\t\t\t}\n\n\t\t\t\t\t//cout<<s<<endl;\n\t\t\t\t\tint d = dfs(s,0);\n\t\t\t\t\tif(d==2)ans++;\n\t\t\t\t\t//cout<<d<<\" \"<<p<<\" \"<<q<<\" \"<<r<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring replacePQR(int p,int q,int r,string input){\n  p += '0';\n  q += '0';\n  r += '0';\n  for(int i=0;i<(int)input.size();i++){\n    switch(input[i]){\n    case 'P':\n      input[i]=p;\n      break;\n    case 'Q':\n      input[i]=q;\n      break;\n    case 'R':\n      input[i]=r;\n      break;\n    }\n  }\n  return input;\n}\n\nstring solve(string input){\n  //  cout<<input<<endl;  \n  if((int)input.size()==1) return input;\n  if(input[0]=='('){\n    int paren=0;\n    int i;\n    char op;\n    for(i=1;i<(int)input.size();i++){\n      if(input[i]=='(') paren++;\n      else if(input[i]==')') paren--;\n      else if((input[i]=='+' || input[i]=='*' )&& paren == 0){\n\top=input[i];\n\tbreak;\n      }\n    }\n    string s1,s2;\n    s1=solve(input.substr(1,i-1));\n    s2=solve(input.substr(i+1,(int)input.size()-2-i));\n    if(op=='+'){\n      if(s1[0]=='2' || s2[0]=='2') return string(1,'2');\n      else if(s1[0]=='1' || s2[0]=='1') return string(1,'1');\n      else return string(1,'0');\n    }else{\n      if(s1[0]=='0' || s2[0]=='0') return string(1,'0');\n      else if(s1[0]=='1' || s2[0]=='1') return string(1,'1');\n      else return string(1,'2');\n    }\n  }\n  else{\n    string s=solve(input.substr(1));\n    if(s[0]=='0') s[0]+=2;\n    else if(s[0]=='2') s[0]-=2;\n    //cout<<\" (--\"<<s<<\"--)\"<<endl;\n    return s;\n  }\n\n}\n\nint main(){\n  string input;\n  while(cin>>input,input!=\".\"){\n    int cnt=0;\n    for(int p=0;p<3;p++){\n      for(int q=0;q<3;q++){\n\tfor(int r=0;r<3;r++){\n\t  string s;\n\t  if((s=solve(replacePQR(p,q,r,input)))==\"2\") cnt++;\n\t  //cout<<s<<endl;\n\t}\n      }\n    }\n    cout<<cnt<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long int a[3][3] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };\n\nlong long int b[3][3] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\npair< long long int, long long int > kansu( string s, long long int n, long long int p, long long int q, long long int r ) {\n\n  long long int k = 1;\n  bool f = false;\n  bool c = 0;\n\n  while( true ) {\n\n    //    cout << \"n = \" << n << \" : k = \" << k << \" : c = \" << c << endl;\n\n    if ( s[n] == ')' ) break;\n    if ( s[n] == '0' ) {\n      k = 0;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == '1' ) {\n      k = 1;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == '2' ) {\n      k = 2;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == 'P' ) {\n      k = p;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == 'Q' ) {\n      k = q;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == 'R' ) {\n      k = r;\n      if ( f == true ) {\n\tk = 2 - k;\n\tf = false;\n      }\n    }else if ( s[n] == '-' ) {\n      if ( f == true ) {\n\tf = false;\n      }else {\n\tf = true;\n      }\n    }else if ( s[n] == '*' ) {\n      pair< long long int, long long int > w = kansu( s, n + 1, p, q, r );\n      k = a[k][ w.first ];\n      n = w.second;\n      break;\n    }else if ( s[n] == '+' ) {\n      pair< long long int, long long int > w = kansu( s, n + 1, p, q, r );\n      k = b[k][ w.first ];\n      n = w.second;\n      break;\n    }else if ( s[n] == '(' ) {\n      pair< long long int, long long int > w = kansu( s, n + 1, p, q, r );\n      k = w.first;\n      n = w.second;\n    }\n    n++;\n\n  }\n\n  return make_pair( k, n );\n\n}\n\nint main() {\n\n  while( true ) {\n\n    string s;\n    cin >> s;\n\n    if ( s == \".\" ) break;\n\n    s = s + \")\";\n\n    long long int ans = 0;\n\n    for ( long long int p = 0; p < 3; p++ ) {\n      for ( long long int q = 0; q < 3; q++ ) {\n\tfor ( long long int r = 0; r < 3; r++ ) {\n\n\t  if ( kansu( s, 0, p, q, r ).first == 2 ) ans++;\n\n\t}\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nchar c[128];\nstring l;\nint p;\n\nint no[3]={2,1,0};\nint mu[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint ad[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nint G();\n\nint F(){\n\tint le = G();\n\twhile(l[p] == '*' || l[p] == '+'){\n\t\tif( l[p] == '*' ){\n\t\t\tp++;\n\t\t\tint ri = G();\n\t\t\tle = mu[le][ri];\n\t\t}else{\n\t\t\tp++;\n\t\t\tint ri = G();\n\t\t\tle = ad[le][ri];\n\t\t}\n\t}\n\treturn le;\n}\nint G(){\n\tif( l[p] == '-' ){\n\t\tp++;\n\t\treturn no[G()];\n\t}else if( l[p] == '(' ){\n\t\tp++;\n\t\tint ri = F();\n\t\tp++;\n\t\treturn ri;\n\t}else{\n\t\tif( '0' <= l[p] && l[p] <= '9' ){\n\t\t\tint ri = l[p]-'0';\n\t\t\tp++;\n\t\t\treturn ri;\n\t\t}else{\n\t\t\tint ri = c[l[p]];\n\t\t\tp++;\n\t\t\treturn ri;\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(cin >> l && l != \".\" ){\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\tfor(int k = 0 ; k < 3 ; k++){\n\t\t\t\t\tc['P'] = i;\n\t\t\t\t\tc['Q'] = j;\n\t\t\t\t\tc['R'] = k;\n\t\t\t\t\tp = 0;\n\t\t\t\t\tif( F() == 2 ){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nint p,q,r;\n\n\nclass ParceError {};\n\nint number(State &begin){\n  int ret = 0;\n  if(isdigit(*begin)){\n    ret += *begin - '0';\n    begin++;\n  }\n  else if(*begin == 'P'){\n    ret = p;\n    begin++;\n  }\n  else if(*begin == 'Q'){\n    ret = q;\n    begin++;\n  }\n  else if(*begin == 'R'){\n    ret = r;\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin);\n\nint term(State &begin){\n  int ret;\n  if(*begin == '-'){\n    int count = 0;\n    while(*begin == '-'){\n      count++;\n      begin++;\n    }\n    ret = factor(begin);\n    for(int i = 0; i < count ; i++){\n      ret = -1 * (ret - 1) + 1;\n    }\n  }\n  else ret = factor(begin);\n  return ret;\n}\n\nint expression(State &begin){\n  int ret = term(begin);\n  if(*begin == '*'){\n//    cout << *begin;\n    begin++;\n    int a = term(begin);\n    if(ret == 2 && a == 2) ret = 2;\n    else if(ret == 0 || a == 0) ret = 0;\n    else ret = 1;\n  }\n  else if(*begin == '+'){\n//    cout << *begin;\n    begin++;\n    int a = term(begin);\n    if(ret == 2 || a == 2) ret = 2;\n    else if(ret == 0 && a == 0) ret = 0;\n    else ret = 1;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin == '('){\n//    cout << *begin;\n    begin++;\n    int ret = expression(begin);\n//    cout  << *begin;\n    begin++;\n    return ret;\n  }\n  else{\n    return number(begin);\n  }\n}\n\n\nint main(){\n  string s;\n  while(cin >> s && s[0] != '.'){\n    int count = 0;\n    for(p = 0; p < 3; p++){\n      for(q = 0; q < 3; q++){\n        for(r = 0; r < 3; r++){\n          State begin = s.begin();\n          int ans = expression(begin);\n//          cout << endl;\n          if(ans == 2) count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef string::const_iterator State;\nint expression(State &begin);\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nint _or[3][3] = {{0,1,2},\n                {1,1,2},\n                {2,2,2}};\n\nint _and[3][3] ={ {0,0,0},\n                 {0,1,1},\n                 {0,1,2}};\n\nint _not[3] = {2,1,0};\n\n\nint formula(State &begin){\n  while(true){\n    if(isdigit(*begin)){\n      int ret = *begin - '0';\n      begin++;\n      return ret;\n    } else if(*begin == '-'){\n      begin++;\n      return _not[formula(begin)];\n    } else if (*begin == '(') {\n      begin++;\n      int ret = formula(begin);\n      if(*begin == '*'){ //and\n        begin++;\n        ret = _and[ret][formula(begin)];\n      } else if (*begin == '+') { // or\n        begin++;\n        ret = _or[ret][formula(begin)];\n      }\n      begin++;\n      return ret;\n    } else {\n      break;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  int n;\n  while(true){\n    cin >> s;\n    if(s==\".\") break;\n    n = s.size();\n    VI P;\n    VI Q;\n    VI R;\n\n    rep(i,n){\n      if(s[i] == 'P') P.push_back(i);\n      if(s[i] == 'Q') Q.push_back(i);\n      if(s[i] == 'R') R.push_back(i);\n    }\n    int ans = 0;\n    rep(p,3){\n      rep(q,3){\n        rep(r,3){\n          rep(i,P.size()) s[P[i]] = (char)(p + '0');\n          rep(i,Q.size()) s[Q[i]] = (char)(q + '0');\n          rep(i,R.size()) s[R[i]] = (char)(r + '0');\n          State begin = s.begin();\n          int tmp = formula(begin);\n          //cout << ans << endl;\n          if(tmp == 2) ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint formula(const string& s, int& p)\n{\n  if (s[p] == '(') {\n    ++p;\n    int lhs = formula(s, p);\n    char op = s[p++];\n    int rhs = formula(s, p);\n    ++p;\n    if (op == '*') {\n      if (lhs == 0 || rhs == 0)\n\treturn 0;\n      else if (lhs == 2 && rhs == 2)\n\treturn 2;\n      else\n\treturn 1;\n    } else {\n      if (lhs == 2 || rhs == 2)\n\treturn 2;\n      else if (lhs == 0 && rhs == 0)\n\treturn 0;\n      else\n\treturn 1;\n    }\n  } else if (s[p] == '-') {\n    ++p;\n    return 2 - formula(s, p);\n  } else {\n    return s[p++] - '0';\n  }\n}\n\nint main()\n{\n  string s;\n  while (cin >> s) {\n    if (s == \".\")\n      break;\n\n    int ans = 0;\n    for (int P = 0; P <= 2; ++P) {\n      string exp1 = s;\n      while (exp1.find_first_of(\"P\") != string::npos)\n\texp1[exp1.find_first_of(\"P\")] = ('0' + P);\n      for (int Q = 0; Q <= 2; ++Q) {\n\tstring exp2 = exp1;\n\twhile (exp2.find_first_of(\"Q\") != string::npos)\n\t  exp2[exp2.find_first_of(\"Q\")] = ('0' + Q);\n\tfor (int R = 0; R <= 2; ++R) {\n\t  string exp3 = exp2;\n\t  while (exp3.find_first_of(\"R\") != string::npos)\n\t    exp3[exp3.find_first_of(\"R\")] = ('0' + R);\n\t  int p = 0;\n\t  if (formula(exp3, p) == 2)\n\t    ++ans;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<int,int> calc(const string &s, int i) {\n  if (s[i] == '-') {\n    auto p = calc(s, i+1);\n    p.first = 2 - p.first;\n    return p;\n  } else if (s[i] == '(') {\n    auto lhs = calc(s, i+1);\n    auto rhs = calc(s, lhs.second + 1);\n    if (s[lhs.second] == '*') {\n      return make_pair(min(lhs.first, rhs.first), rhs.second+1);\n    } else {\n      return make_pair(max(lhs.first, rhs.first), rhs.second+1);\n    }\n  } else {\n    return make_pair(s[i] - '0', i+1);\n  }\n}\n\nint main() {\n  while(1){\n    string s;\n    cin>>s;\n    if (s == \".\") break;\n    int cnt = 0;\n    REP(i,27) {\n      int v[3];\n      int p = i;\n      REP(j,3) {\n        v[j] = p % 3;\n        p /= 3;\n      }\n      string cp = s;\n      for (char &c : cp) {\n        if ('P' <= c && c <= 'R') {\n          c = v[c - 'P'] + '0';\n        }\n      }\n      if (calc(cp, 0).first == 2) ++cnt;\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p, q, r, cursor;\nstring s;\n\nint NOT(int a) {\n\treturn 2 - a;\n}\n\nint AND(int a, int b) {\n\tif(a == 0 || b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint OR(int a, int b) {\n\tif(a == 2 || b == 2) return 2;\n\tif(a == 1 || b == 1) return 1;\n\treturn 0;\n}\n\nint f() {\n\tchar c = s[cursor];\n\tcursor++;\n\tif(c == '0') return 0;\n\tif(c == '1') return 1;\n\tif(c == '2') return 2;\n\tif(c == 'P') return p;\n\tif(c == 'Q') return q;\n\tif(c == 'R') return r;\n\tif(c == '-') return NOT(f());\n\tif(c == '(') {\n\t\tint a = f();\n\t\tchar op = s[cursor];\n\t\tcursor++;\n\t\tint b = f();\n\t\tcursor++;\n\t\tif(op == '*') {\n\t\t\treturn AND(a, b);\n\t\t}\n\t\telse {\n\t\t\treturn OR(a, b);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> s, s[0] != '.') {\n\t\tint ans = 0;\n\t\tfor(p = 0; p <= 2; p++) {\n\t\t\tfor(q = 0; q <= 2; q++) {\n\t\t\t\tfor(r = 0; r <= 2; r++) {\n\t\t\t\t\tcursor = 0;\n\t\t\t\t\tif(f() == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint check(char op, int x, int y) {\n    switch (op) {\n    case '*':\n        if (x == 2 && y == 2) return 2;\n        return x & y;\n    case '+':\n        if (x == 2 || y == 2) return 2;\n        return x | y;\n    }\n    assert(0);\n}\n\nint formula(string& form, int& idx) {\n    for (; idx < (int)form.length(); idx++) {\n        switch (form[idx]) {\n        case '0':\n        case '1':\n        case '2':\n            return form[idx] - '0';\n        case '-':\n            ++idx;\n            return 2 - formula(form, idx);\n        case '(':\n            int x = formula(form, ++idx);\n            char op = form[++idx];\n            int y = formula(form, ++idx);\n            ++idx;\n            return check(op, x, y);\n        }\n    }\n    assert(0);\n}\n\nint solve(string line, int p, int q, int r) {\n    REP(i, line.length()) {\n        switch (line[i]) {\n        case 'P':\n            line[i] = p + '0';\n            break;\n        case 'Q':\n            line[i] = q + '0';\n            break;\n        case 'R':\n            line[i] = r + '0';\n            break;\n        }\n    }\n    int idx = 0;\n    return formula(line, idx);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \".\") {\n            break;\n        }\n\n        int n = 0;\n        REP(p, 3) REP(q, 3) REP(r, 3) {\n            if (solve(line, p, q, r) == 2) {\n                n++;\n            }\n        }\n        cout << n << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[10000];\n\nint bit(int c,bool d){\n\tif(d==true){return c;}\n\treturn minus(c);\n}\nint minus(int c){return 2-c;}\nint plus(int c,int d){return max(c,d);}\nint kake(int c,int d){return max(c,d);}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\tif(ok==false){ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return plus(ans,ans2);}\n\treturn kake(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=to_string((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tsum=0;\n\t\tif(S==\".\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint calc(string& s, int& i) {\n\tif (s[i] == '-') {\n\t\ti++;\n\t\treturn 2 - calc(s, i);\n\t}\n\tif (s[i] != '(') return s[i++] - '0';\n\ti++;\n\tint X = calc(s, i);\n\tchar c = s[i];\n\ti++;\n\tint Y = calc(s, i);\n\ti++;\n\tif (c == '*') return min(X, Y);\n\tif (c == '+') return max(X, Y);\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s; cin >> s;\n\t\tif (s == \".\") break;\n\t\tint cnt = 0;\n\t\tfor (int P = 0; P <= 2; P++)\n\t\t\tfor (int Q = 0; Q <= 2; Q++)\n\t\t\t\tfor (int R = 0; R <= 2; R++) {\n\t\t\t\t\tstring _s = s;\n\t\t\t\t\tfor (int i = 0; i < _s.length(); i++)\n\t\t\t\t\t\tif (_s[i] == 'P') _s[i] = '0' + P;\n\t\t\t\t\t\telse if (_s[i] == 'Q') _s[i] = '0' + Q;\n\t\t\t\t\t\telse if (_s[i] == 'R') _s[i] = '0' + R;\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tif (calc(_s, i) == 2) cnt++;\n\t\t\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//49\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint eval(const char **s){\n  if(**s=='('){\n    (*s)++;\n    int a=eval(s);\n    char o=**s;\n    (*s)++;\n    int b=eval(s);\n    (*s)++;\n    if(o=='*'){\n      return min(a,b);\n    }else{\n      return max(a,b);\n    }\n  }else if(**s=='-'){\n    (*s)++;\n    return -eval(s)+2;\n  }else{\n    char c=**s;\n    (*s)++;\n    return c-'0';\n  }\n}\n\nint dfs(const char *os,char q){\n  if(q>'R'){\n    return eval(&os)==2;\n  }else{\n    int r=0;\n    for(int i=0;i<3;i++){\n      char s[80];\n      strcpy(s,os);\n      replace(s,s+80,q,char('0'+i));\n      r+=dfs(s,q+1);\n    }\n    return r;\n  }\n}\n\nint main(){\n  for(char s[80];cin>>s,s[0]!='.';){\n    cout<<dfs(s,'P')<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define MyDebug\n#include <bits/stdc++.h>\n\n#define rep(i, from, to) for (int i = from; i < to; ++i)\n#define REP(i, from, to) for (int i = from; i <= to; ++i)\n\n#ifdef MyDebug\n#define debug(x) cerr << #x << \" : \" << x << endl;\n#define debug3(x, y, z) cerr << #x << \" : \" << x << \", \"<<#y << \" : \" << y <<  \", \" << #z << \" : \" << z << endl;\n#else\n#define debug(x)\n#define debug3(x, y, z)\n#endif\n\nusing namespace std;\n\nint cnt = 0;\nstring s;\nchar now;\nstring ans;\nchar op1 = '*', op2 = '+', op3 = '-';\nbool isSymbol(char c) {\n\treturn c == '0' || c == '1' || c == '2' || c == 'P' || c == 'Q' || c == 'R';\n}\nvoid replaceAll(string &s, char c, int num) {\n\trep (i, 0, (int)s.size()) {\n\t\tif (s[i] == c) s[i] = (char)(num + '0');\n\t}\n}\nvoid formula() {\n\tif (s[cnt] == '(') {\n\t\t++cnt;\n\t\tformula();\n\t\tif (s[cnt] == op1) {\n\t\t\t++cnt;\n\t\t\tformula();\n\t\t\tans += op1;\n\t\t\tdebug(ans);\n\t\t\t++cnt;\n\t\t}else if (s[cnt] == op2) {\n\t\t\t++cnt;\n\t\t\tformula();\n\t\t\tans += op2;\n\t\t\tdebug(ans);\n\t\t\t++cnt;\n\t\t}\n\t} else if (isSymbol(s[cnt])) {\n\t\tans += s[cnt];\n\t\t++cnt;\n\t} else if (s[cnt] == op3) {\n\t\t++cnt;\n\t\tformula();\n\t\tans += op3;\n\t}\n}\n\nint my_or[][3] = {{0, 1, 2},\n\t\t\t\t   {1, 1, 2},\n\t\t\t\t   {2, 2, 2}};\nint my_and[][3] = {{0, 0, 0},\n\t              {0, 1, 1},\n\t\t\t\t  {0, 1, 2}};\nint my_not[] = {2, 1, 0};\n\nint eval(int x1, int x2, char op) {\n\tdebug3(x1, x2, op);\n\tif (op == op1) {\n\tdebug(my_and[x1][x2]);\n\t\treturn my_and[x1][x2];\n\t}\n\tif (op == op2) {\n\tdebug(my_or[x1][x2]);\n\t\treturn my_or[x1][x2];\n\t}\n\tif (op == op3) {\n\tdebug(my_not[x1]);\n\t\treturn my_not[x1];\n\t}\n\tcerr << \"error\" << endl;\n\treturn -1;\n}\n\nstack<int> st;\n\nbool isNum(char c) {\n\treturn c == '0' || c == '1' || c == '2';\n}\nint evalAll(string &s) {\n\trep(i, 0, (int)s.size()) {\n\t\t//debug(s[i]);\n\t\tif (isNum(s[i])) {\n\t\t\tst.push(s[i] - '0');\n\t\t} else if (s[i] == op3) {\n\t\t\tint v = eval(st.top(), -1, op3);\n\t\t\tst.pop();\n\t\t\tst.push(v);\n\t\t} else if (s[i] == op1 || s[i] == op2){\n\t\t\tint x1 = st.top();st.pop();\n\t\t\tint x2 = st.top();st.pop();\n\t\t\tint v = eval(x1, x2, s[i]);\n\t\t\tst.push(v);\n\t\t} else cerr << \"error\" << endl;\n\t}\n\tint top = st.top();\n\tst.pop();\n\treturn top;\n}\nint ansN = 0;\nvoid init() {\n\tansN = 0;\n\tans =\"\";\n\tst = stack<int>();\n\tcnt = 0;\n\ts = \"\";\n}\n\nvoid solve() {\n\twhile(cin >> s, s != \".\") {\n\t\tformula();\n\t\trep(i, 0, 3) {\n\t\t\trep(j, 0, 3) {\n\t\t\t\trep(k, 0, 3) {\n\t\t\t\t\tstring ans1 = ans;\n\t\t\t\t\treplaceAll(ans1, 'P', i);\n\t\t\t\t\treplaceAll(ans1, 'Q', j);\n\t\t\t\t\treplaceAll(ans1, 'R', k);\n\t\t\t\t\tif (evalAll(ans1) == 2) {\n\t\t\t\t\t\t++ansN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ansN << endl;\n\t\tinit();\n\t}\n}\nvoid test() {\n\tstring s = \"aaaaaa\";\n\ts.insert(2, \"b\");\n\ts.erase(2, 1);\n\tdebug(s);\n}\nvoid test2() {\n\tstring a = \"01+\";\n\tdebug(evalAll(a));\n}\nvoid test3() {\n\tstring a = \"PQ+Q*-\";\n\treplaceAll(a, 'P', 2);\n\treplaceAll(a, 'Q', 1);\n\tcerr << a << endl;\n\tcerr << evalAll(a) << endl;\n}\nvoid test4() {\n\tstring s = \"2\";\n\tcerr << evalAll(s) << endl;\n}\nvoid test5() {\n\ts = \"(((P+(---Q*Q))*(-(---2*(--0*Q))+(--R+--1)))+(((1*Q)+-1)*-(--0*---P)))\";\n\t//s = \"(-(P+(P*Q))*Q)\";\n\tformula();\n\tcerr << ans << endl;\n}\n\nint main() {\n\tsolve();\n\t//test5();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#ifdef DEBUG\n#define dump(x) cout << \"[*] \" #x \": \" << x << endl\n#define debug(x) x\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nstring form;\n\nconstexpr int val_0 = 100;\nconstexpr int val_1 = 200;\nconstexpr int val_2 = 300;\nconstexpr int val_p = 400;\nconstexpr int val_q = 500;\nconstexpr int val_r = 600;\nconstexpr int val_minus = 700;\n\nint mns(int x) {\n    switch (x) {\n        case 0:\n            return 2;\n        case 1:\n            return 1;\n        case 2:\n            return 0;\n    }\n}\n\nint mul(int x, int y) {\n    if (!x || !y) {\n        return 0;\n    } else if (x == 1 || y == 1) {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nint add(int x, int y) {\n    if (x == 2 || y == 2) {\n        return 2;\n    } else if (x == 1 || y == 1) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction<int(int, int, int)> eval(string s, const vector<int>& t, const int t_off) {\n    dump(s);\n    dump(t_off);\n    if (s[0] == '(') {\n        int num = t[t_off];\n        int index;\n        for (index = 1; index < s.size(); index++) {\n            if (t[t_off + index] == num) {\n                break;\n            }\n        }\n        dump(num);\n        dump(index);\n        const auto func = s[index] == '*' ? mul : add;\n        const auto left = eval(s.substr(1, index-1), t, t_off+1);\n        const auto right = eval(s.substr(index+1, s.size()-index-2), t, t_off+index+1);\n        return [func, left, right](int p, int q, int r) { return func(left(p, q, r), right(p, q, r)); };\n    } else if (s[0] == '-') {\n        const auto func = eval(s.substr(1, s.size()), t, t_off+1);\n        return [func](int p, int q, int r) { return mns(func(p, q, r)); };\n    } else {\n        switch (s[0]) {\n            case '0':\n                return [](int p, int q, int r) {return 0;};\n            case '1':\n                return [](int p, int q, int r) {return 1;};\n            case '2':\n                return [](int p, int q, int r) {return 2;};\n            case 'P':\n                return [](int p, int q, int r) {return p;};\n            case 'Q':\n                return [](int p, int q, int r) {return q;};\n            case 'R':\n                return [](int p, int q, int r) {return r;};\n        }\n    }\n}\n\nint main() {\n    while (true) {\n        cin >> form;\n        if (form[0] == '.') {\n            break;\n        }\n        vector<int> token(form.size());\n        int cnt = 0;\n        for (int i = 0; i < form.size(); ++i) {\n            switch (form[i]) {\n                case '(':\n                    token[i] = ++cnt;\n                    break;\n                case ')':\n                    token[i] = cnt--;\n                    break;\n                case '0':\n                    token[i] = val_0;\n                    break;\n                case '1':\n                    token[i] = val_1;\n                    break;\n                case '2':\n                    token[i] = val_2;\n                    break;\n                case 'P':\n                    token[i] = val_p;\n                    break;\n                case 'Q':\n                    token[i] = val_q;\n                    break;\n                case 'R':\n                    token[i] = val_r;\n                    break;\n                case '-':\n                    token[i] = val_minus;\n                    break;\n                case '*':\n                    token[i] = cnt;\n                    break;\n                case '+':\n                    token[i] = cnt;\n                    break;\n            }\n        }\n        dump(\"tokenaized\");\n\n        cnt = 0;\n        auto func = eval(form, token, 0);\n        dump(\"evaled\");\n        for (int q = 0; q <= 2; ++q) {\n            for (int p = 0; p <= 2; ++p) {\n                for (int r = 0; r <= 2; ++r) {\n                    const int res = func(p, q, r);\n                    if (res == 2) {\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\nvoid de(stack<char> s) {\n\tstring tmp;\n\twhile (!s.empty()) {\n\t\ttmp += s.top();\n\t\ts.pop();\n\t}\n\treverse(tmp.begin(), tmp.end());\n\t//cout << tmp << endl;\n}\n\n//構文を実際に計算する\nbool play(string s) {\n\t//cout << s << endl;\n\n\tstack<char> info;\n\tfor (char c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t\t//de(info);\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(string formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\t//cout << \"pqr:: \" << p << q << r << endl;\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tif (T[pos] == '0') return 0;\n\tif (T[pos] == '1') return 1;\n\tif (T[pos] == '2') return 2;\n\tif (T[pos] == '-') return 2 - solve();\n\tif (T[pos] == '(') {\n\t\tpos++; int a = solve();\n\t\tpos++; int b = solve();\n\t\tif (T[pos] == '+') return max(a, b);\n\t\tif (T[pos] == '*') return min(a, b);\n\t}\n\treturn 0;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n \nint mul(int X,int Y){\n  if(X == 0 || Y == 0)return 0;\n  if(X == 1 || Y == 1)return 1;\n  if(X == 2 && Y == 2)return Y;\n  assert(false);\n}\n \nint add(int X,int Y){\n  if(X == 0)return Y;\n  if(X == 1 && (Y == 0 || Y == 1))return 1;\n  if(X == 1 && Y == 2)return 2; \n  if(X == 2)return 2;\n  assert(false);\n}\n \nint sub(int X){\n  //cout << \"X = \"<< X << endl;\n  if(X == 0)return 2;\n  if(X == 1)return 1;\n  if(X == 2)return 0;\n  assert(false);\n}\n \nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n \n \n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }\n    else if(parse[pos] == '-'){\n      int p = 0;     \n      int cnt=0;\n      while(parse[pos] == '-'){      \n    cnt++,pos++;\n      }\n      //cout << \"now parse = \" << parse[pos] << endl;\n      //p = parse[pos]-'0';\n      //pos++;\n      p = fact();\n      //cout << \"exp = \" << p << endl;\n      //pos++;\n      rep(i,cnt){\n    p = sub(p); \n      }    \n      //cout << \" - IN!!! p = \" << p << endl;  \n      return p;\n       \n    }else{\n      \n      int p = 0;\n      \n      while('0' <= parse[pos] && parse[pos] <= '2'){\n    p *= 10;\n    p += parse[pos]-'0';\n    pos++;\n      }\n      return p;\n    }\n  }\n \n  int term(){\n    int p = fact();\n    return p;\n  }\n \n \n  int expression(){\n    int p = term();\n    //cout << \"X = \"<< p << endl;\n    while(parse[pos] == '+' || parse[pos] == '*'){\n      if(parse[pos] == '*'){\n    pos++;\n    int q = term();\n    //cout << \"Y = \" <<q << endl;\n    p = mul(p,q);\n      }\n      else if(parse[pos] == '+'){\n    pos++;\n    int q = term();\n    //cout << \"Y = \"<< q << endl;\n    p = add(p,q);\n      }\n    }\n    return p;\n  }\n \n \n};\n \nint ans,last;\nstring s;\n \nvoid draw(char P,char Q,char R){\n  string pre = s;\n  rep(i,s.length()){\n    if(s[i] == 'P')s[i] = P;\n    else if(s[i] == 'Q')s[i] = Q;\n    else if(s[i] == 'R')s[i] = R;\n  }\n  Parsing par = Parsing(s);\n  int res = par.expression();\n  assert(res == 0 || res == 1 || res == 2);\n  if(res == 2)ans++;  \n  s = pre;\n}\n \nvoid test(){\n \n  for(char i='0';i<='2';i++){// P\n    for(char j='0';j<='2';j++){// Q\n      for(char k='0';k<='2';k++){// R\n    draw(i,j,k);\n      }\n    }\n  }\n \n \n}\n \n \nint main(){\n  while(true){\n    cin >> s;\n    //Parsing par = Parsing(s);\n    //cout <<par.expression() << endl;\n    //return 0;\n    if(s == \".\")break;\n    ans = 0;  \n    test();\n    cout << ans << endl;\n  }\nreturn 0;\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint solve(string s, int p, int q, int r){\n    s=regex_replace(s,regex(\"-0\"),\"2\");\n    s=regex_replace(s,regex(\"-1\"),\"1\");\n    s=regex_replace(s,regex(\"-2\"),\"0\");\n    s=regex_replace(s,regex(\"-P\"),to_string(2-p));\n    s=regex_replace(s,regex(\"-Q\"),to_string(2-q));\n    s=regex_replace(s,regex(\"-R\"),to_string(2-r));\n    s=regex_replace(s,regex(\"P\"),to_string(p));\n    s=regex_replace(s,regex(\"Q\"),to_string(q));\n    s=regex_replace(s,regex(\"R\"),to_string(r));\n    string a=\"\";\n    for(auto c:s){\n        a+=c;\n        if(c==')'){\n            auto p=a.substr(a.size()-5);\n            if(p[2]=='+'){\n                a=a.substr(0,a.size()-5)+max(p[1],p[3]);\n            }else{\n                a=a.substr(0,a.size()-5)+min(p[1],p[3]);\n            }\n        }\n    }\n    return a==\"2\"?1:0;\n}\n\nint main(void){\n    string s;\n    while(cin>>s,s!=\".\"){\n        auto cp=regex_replace(s,regex(\"--\"),\"\");\n        int ans=0;\n        rep(p,3)rep(q,3)rep(r,3){\n            ans+=solve(cp,p,q,r);\n        }\n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define S str[ima]\nusing namespace std;\nstring str;\nint ima;\n\nint formula(int P,int Q,int R) {\n  int res;\n  while(S=='0' || S=='1' || S=='2' || S=='P'||S=='Q'||S=='R'||S=='-'||S=='('){\n    if(S=='0' || S=='1' || S=='2' || S=='P'||S=='Q'||S=='R'){\n      res = S-'0';\n      if(S=='P') res = P;\n      if(S=='Q') res = Q;\n      if(S=='R') res = R;\n      ima++;\n    }\n    else if(S=='-') {\n      ima++;\n      res = formula(P,Q,R);\n      if(res == 0) res = 2;\n      else if(res == 2) res = 0;\n    }\n    else if(S=='(') {\n      ima++;\n      res = formula(P,Q,R);\n      if(S=='*')ima++, res = min(formula(P,Q,R),res);\n      if(S=='+')ima++, res = max(formula(P,Q,R),res);\n      ima++;\n    }\n  }\n  return res;\n}\n\nint main() {\n\n  while(1) {\n    cin >> str;\n    if(str==\".\") break;\n    int ans = 0;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tfor(int k=0;k<3;k++){\n\t  ima = 0;\n\t  if(formula(i,j,k) == 2) ans++;\n\t}\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring formula;\nint parse(int P, int Q, int R, int &i){\n  int a, b;\n  switch(formula[i]){\n  case '0':\n    a = 0;\n    i++;\n    break;\n  case '1':\n    a = 1;\n    i++;\n    break;\n  case '2':\n    a = 2;\n    i++;\n    break;\n  case 'P':\n    a = P;\n    i++;\n    break;\n  case 'Q':\n    a = Q;\n    i++;\n    break;\n  case 'R':\n    a = R;\n    i++;\n    break;\n  case '-':\n    i++;\n    a = parse(P, Q, R, i);\n    a = 2 - a;\n    break;\n  case '(':\n    i++;\n    a = parse(P, Q, R, i);\n    if(formula[i] == '*'){\n      i++;\n      b = parse(P, Q, R, i);\n      i++;\n      a = (a * b) / 2;\n    }\n    else{\n      i++;\n      b = parse(P, Q, R, i);\n      i++;\n      if(a == 1 && b == 1) a = 1;\n      else a = 2 - (((2-a) * (2-b)) / 2);\n    }\n\n  }\n\n  return a;\n}\n\nint main(){\n  while(1){\n    cin >> formula;\n    if(formula == \".\") break;\n    int count = 0;\n    for(int i = 0; i <=2; i++){\n      for(int j = 0; j <= 2; j++){\n        for(int k = 0; k <= 2; k++){\n          int index = 0;\n          if(parse(i, j, k, index) == 2) count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring target;\nint pos;\n\nstruct Node{\n\tstring num;\n\tNode *left;\n\tNode *right;\n\tNode(){\n\t\tnum = \"\";\n\t\tleft = NULL;\n\t\tright = NULL;\n\t}\n\tNode(string n, Node *l, Node *r){\n\t\tnum = n;\n\t\tleft = l;\n\t\tright = r;\n\t}\n};\n\n//Node *rule_Element();\n//Node *rule_Tree();\n//string rule_Num();\nNode *rule_formula();\n\nNode *rule_formula(){\n\tNode * buff = new Node;\n\tswitch (target[pos]){\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase 'P':\n\tcase 'Q':\n\tcase 'R':\n\t\tbuff->num = target[pos];\n\t\tpos++;\n\t\tbreak;\n\tcase '-':\n\t\tbuff->num = target[pos];\n\t\tpos++;\n\t\tbuff->left = rule_formula();\n\t\tbreak;\n\tcase '(':\n\t\tpos++;\n\t\tbuff->left = rule_formula();\n\t\tbuff->num = target[pos];\n\t\tpos++;\n\t\tbuff->right = rule_formula();\n\t\tassert(target[pos] == ')'); pos++;\n\t\tbreak;\n\t}\n\n\treturn buff;\n}\n\n/*\nNode *rule_Tree(){\n\tNode *buff = new Node;\n\n\tbuff->left = rule_Element();//to Elem\n\tassert(target[pos] == '['); pos++;\n\tbuff->num = rule_Num();//to Num\n\tassert(target[pos] == ']'); pos++;\n\tbuff->right = rule_Element();//to Elem\n\n\treturn buff;\n}\n\nNode *rule_Element(){\n\tNode *buff = new Node;\n\t//cout << \"pos:\" << pos << endl;\n\tassert(target[pos] == '('); pos++;\n\tif (target[pos] == ')'){\n\t\tpos++;\n\t\treturn NULL;\n\t}\n\telse {\n\t\tbuff = rule_Tree();//to Tree\n\t\tassert(target[pos] == ')'); pos++;\n\t\treturn buff;\n\t}\n}\n\nstring rule_Num(){\n\tstring ret;\n\twhile (target[pos] != ']'){\n\t\tret += target[pos]; pos++;\n\t}\n\treturn ret;\n}\n*/\n\nNode *makeTree(string str){\n\n\ttarget = str;\n\tpos = 0;\n\tNode *ret;\n\n\tret = rule_formula();\n\n\treturn ret;\n}\n\nstring itos(int i) {\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}\n\nNode *merge(Node *a, Node *b){\n\t//cout << \"a.num:\" << (a->num) << \"\\tb.num\" << (b->num) << endl;\n\tNode *buff = new Node;\n\tint v1 = (atoi)(a->num.c_str());\n\tint v2 = (atoi)(b->num.c_str());\n\tbuff->num = itos(v1 + v2);\n\tif (a->left != NULL && b->left != NULL) buff->left = merge(a->left, b->left);\n\tif (a->right != NULL && b->right != NULL) buff->right = merge(a->right, b->right);\n\n\treturn buff;\n}\n\nvoid out(Node *c){\n\tcout << \"(\";\n\tif (c->left != NULL) out(c->left);\n\tcout << \")[\" << c->num << \"](\";\n\tif (c->right != NULL) out(c->right);\n\tcout << \")\";\n\treturn;\n}\nint eval(Node *n, int p, int q, int r){\n\tint l_eval, r_eval;\n\tswitch (n->num[0]){\n\tcase '0':\n\t\treturn 0;\n\t\tbreak;\n\tcase '1':\n\t\treturn 1;\n\t\tbreak;\n\tcase '2':\n\t\treturn 2;\n\t\tbreak;\n\tcase 'P':\n\t\treturn p;\n\t\tbreak;\n\tcase 'Q':\n\t\treturn q;\n\t\tbreak;\n\tcase 'R':\n\t\treturn r;\n\t\tbreak;\n\tcase '-':\n\t\tl_eval = eval(n->left, p, q, r);\n\t\tif (l_eval == 0) return 2;\n\t\telse if (l_eval == 1) return 1;\n\t\telse return 0;\n\t\tbreak;\n\tcase '*':\n\t\tl_eval = eval(n->left, p, q, r);\n\t\tr_eval = eval(n->right, p, q, r);\n\t\tif (l_eval == 0) return 0;\n\t\telse if (r_eval == 0) return 0;\n\t\telse if (l_eval == 1) return 1;\n\t\telse if (r_eval == 1) return 1;\n\t\telse return 2;\n\t\tbreak;\n\tcase '+':\n\t\tl_eval = eval(n->left, p, q, r);\n\t\tr_eval = eval(n->right, p, q, r);\n\t\tif (l_eval == 2) return 2;\n\t\telse if (r_eval == 2) return 2;\n\t\telse if (l_eval == 1) return 1;\n\t\telse if (r_eval == 1) return 1;\n\t\telse return 0;\n\t}\n}\n\nint main(void){\n\n\tstring A;\n\twhile (cin >> A, A[0] != '.'){\n\t\tNode *a;\n\n\t\ta = makeTree(A);\n\n\t\tint result = 0;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tfor (int k = 0; k < 3; k++){\n\t\t\t\t\tif (eval(a, i, j, k) == 2) result++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep0(i,n) for(i=0;i<(n);i++)\n#define repp(i,m,n) for(int i=(m);i<(n);i++)\n\n#define PUTLINE cout<<__LINE__<<endl;\n\nint p,q,r;\n\nint formula(string str){\n\tif(str==\"0\")return 0;\n\tif(str==\"1\")return 1;\n\tif(str==\"2\")return 2;\n\tif(str==\"P\")return p;\n\tif(str==\"Q\")return q;\n\tif(str==\"R\")return r;\n\tif(str[0]=='-')return 2-formula(str.substr(1,str.size()-1));\n\tint i,k=0;\n\tfor(i=0;i<str.size();++i){\n\t\tif(str[i]=='(')++k;\n\t\tif(str[i]==')')--k;\n\t\tif(k==1&&str[i]=='*')return min(formula(str.substr(1,i-1)),formula(str.substr(i+1,str.size()-i-2)));\n\t\tif(k==1&&str[i]=='+')return max(formula(str.substr(1,i-1)),formula(str.substr(i+1,str.size()-i-2)));\n\t}\n\treturn 0;\n}\n\nint main() {\n\tstring str;\n\tfor(;;){\n\t\tcin>>str;\n\t\tif(str==\".\")break;\n\t\tint res=0;\n\t\tfor(p=0;p<3;++p)for(q=0;q<3;++q)for(r=0;r<3;++r){\n\t\t\tif(formula(str)==2)++res;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint pqr,now;\nstring s;\n\nint formula(void){\n\t\n\tif(isdigit(s[now])){return s[now++]-'0';}\n\tif(isupper(s[now])){return (pqr>>(s[now++]-'P'))&1;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tres=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\tfor(pqr=0;pqr<(1<<3);pqr++){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstring str;\nint idx;\n\n\nint getn() {\n    char c = str[idx];\n    idx++;\n    return c-'0';\n}\n\nint calc() {\n    char c = str[idx];\n    if (c == '-') {\n        idx++;\n        return 2-calc(); \n    }\n    if (c == '(') {\n        idx++;\n        int r1 = calc();\n        char cc = str[idx];\n        idx++;\n        int r2 = calc();\n        idx++;\n        if (cc == '*') {\n            return min(r1, r2);\n        } else {\n            return max(r1, r2);\n        }\n    } else {\n        return getn();\n    }\n}\n\nint main() {\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \".\") break;\n        int res = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    str = \"\";\n                    for (int i = 0; i < s.size(); i++) {\n                        switch (s[i]) {\n                        case 'P':\n                            str += to_string(p);\n                            break;\n                        case 'Q':\n                            str += to_string(q);\n                            break;\n                        case 'R':\n                            str += to_string(r);\n                            break;\n                        default:\n                            str += s[i];\n                            break;\n                        }\n                    }\n                    str += '=';\n                    idx = 0;\n                    //cerr << str << endl;\n                    if (calc() == 2) {\n                        //cerr << \"asdkfjf\" << endl;\n                        res++;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i;\n  int p,q,r;\n  int ln,ct;\n  string s,t;\n  while(cin>>s&&s[0]!='.'){\n    ct=0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  t=s;\n\t  ln=t.length();\n\t  for(i=0;i<ln;i++){\n\t    if(0){\n\t    }else if(t[i]=='P'){\n\t      t[i]='0'+p;\n\t    }else if(t[i]=='Q'){\n\t      t[i]='0'+q;\n\t    }else if(t[i]=='R'){\n\t      t[i]='0'+r;\n\t    }\n\t  }\n\t  while(t.length()!=1){\n\t    do{\n\t      h=0;\n\t      for(i=0;i<ln-1;i++){\n\t\tif(t[i]=='-'&&'0'<=t[i+1]&&t[i+1]<='3'){\n\t\t  t.erase(i,1);\n\t\t  t[i]=2-t[i]+'0'+'0';\n\t\t  h=1;\n\t\t}\n\t      }\n\t    }while(h);\n\t    do{\n\t      h=0;\n\t      for(i=0;i<ln-2;i++){\n\t\tif(t[i]=='('&&t[i+4]==')'){\n\t\t  if(0){\n\t\t  }else if(t[i+2]=='*'){\n\t\t    if(0){\n\t\t    }else if(t[i+1]=='0'||t[i+3]=='0'){\n\t\t      t[i+4]='0';\n\t\t    }else if(t[i+1]=='2'&&t[i+3]=='2'){\n\t\t      t[i+4]='2';\n\t\t    }else{\n\t\t      t[i+4]='1';\n\t\t    }\n\t\t    t.erase(i,4);\n\t\t    h=1;\n\t\t  }else if(t[i+2]=='+'){\n\t\t    if(0){\n\t\t    }else if(t[i+1]=='2'||t[i+3]=='2'){\n\t\t      t[i+4]='2';\n\t\t    }else if(t[i+1]=='0'&&t[i+3]=='0'){\n\t\t      t[i+4]='0';\n\t\t    }else{\n\t\t      t[i+4]='1';\n\t\t    }\n\t\t    t.erase(i,4);\n\t\t    h=1;\n\t\t  }\n\t\t}\n\t      }\n\t    }while(h);\n\t  }\n\t  if(t[0]=='2')\n\t    ct++;\n\t}\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint cur,p,q,r;\nstring s;\n\nint form(){\n\tif(isdigit(s[cur]))return s[cur++]-'0';\n\tif(s[cur]=='P'){cur++;return p;}\n\tif(s[cur]=='Q'){cur++;return q;}\n\tif(s[cur]=='R'){cur++;return r;}\n\tif(s[cur]=='-'){cur++;return 2-form();}\n\tif(s[cur]=='('){\n\t\tcur++;\n\t\tint a=form();\n\t\tchar op=s[cur++];\n\t\tint b=form();\n\t\tif(op=='+')a=max(a,b);\n\t\telse a=min(a,b);\n\t\tassert(s[cur]==')');\n\t\tcur++;\n\t\treturn a;\n\t}\n} \n\nint main() {\n\twhile(cin>>s){\n\t\tif(s==\".\")return 0;\n\t\tint ans=0;\n\t\tfor(int i=0;i<27;i++){\n\t\t\tp=i/9;q=(i/3)%3;r=i%3;\n\t\t\tcur=0;\n\t\t\tif(form()==2)ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint o=0;\nvoid rec(string str){\n  //cout << str << endl;\n  string next,buf;\n  if('0'<=str[0]&&str[0]<='2'){\n    //cout << str << endl;\n    if(str[0]=='2') o++;\n    return;\n  }\n  for(int i=1;i<str.size();i++){\n    if('0'<=str[i]&&str[i]<='2') {\n      if(str[i-1]=='-') {\n\tif(str[i]=='0')  str[i]='2';\n\telse if(str[i]=='2')  str[i]='0';\n\tstr[i-1]=' ';\n      }else if(str[i-1]=='*') {\n\tif(str[i-3]=='('){\n\tif(str[i]=='0'||str[i-2]=='0') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='0';\n\t  str[i+1]=' ';\n\t}else if(str[i]=='2'&&str[i-2]=='2') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='2';\n\t  str[i+1]=' ';\n\t}else if('0'<=str[i-2]&&str[i-2]<='2'){\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='1';\n\t  str[i+1]=' ';\n\t}\n\t}\n      }else if(str[i-1]=='+') {\n\tif(str[i-3]=='('){\n\tif(str[i]=='2'||str[i-2]=='2') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='2';\n\t  str[i+1]=' ';\n\t}else if(str[i]=='0'&&str[i-2]=='0') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='0';\n\t  str[i+1]=' ';\n\t}else if('0'<=str[i-2]&&str[i-2]<='2'){\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='1';\n\t  str[i+1]=' ';\n\t}\n\t}\n      }\n    }\n  }\n  for(int i=0;i<str.size();i++){\n    if(str[i]!=' ') next+=str[i];\n  }\n  rec(next);\n}\nint main(){\n  string str,buf;\n  cin >> str;\n  while(str!=\".\"){\n    int p[]={0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2};\n    int q[]={0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2};\n    int r[]={0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2};\n    o=0;\n    for(int i=0;i<27;i++){\n      buf=str;\n      for(int j=0;j<str.size();j++){\n\tif(buf[j]=='P') buf[j]=p[i]+'0';\n\tif(buf[j]=='Q') buf[j]=q[i]+'0';\n\tif(buf[j]=='R') buf[j]=r[i]+'0';\n      }\n      rec(buf);\n    }\n    cout << o << endl;\n    cin >> str;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint pos;\nconst string kVars = \"abcdefghijk\";\nstring formula1, formula2, res;\n\nint mlt(int lhs, int rhs){\n    return lhs && rhs;\n}\n\nint pls(int lhs, int rhs){\n    return lhs || rhs;\n}\n\nint mns(int val){\n    return !val;\n}\n\nint imp(int lhs, int rhs){\n    return !(lhs && !rhs);\n}\n\nint operate(const string& formula, int& pos){\n    int ret;\n\n    if(formula.at(pos) == '('){\n        pos++;\n\n        int lhs = operate(formula, pos);\n        char op = formula.at(pos++); if(op == '-') pos++;\n        int rhs = operate(formula, pos);\n\n        switch(op){\n        case '*': { ret = mlt(lhs, rhs); break; }\n        case '+': { ret = pls(lhs, rhs); break; }\n        case '-': { ret = imp(lhs, rhs); break; }\n        default : break; \n        }\n\n        pos++;\n    }\n\n    else if(formula.at(pos) == '-'){\n        bool isMns = true;\n        while(formula.at(++pos) == '-') isMns = !isMns;\n\n        ret = operate(formula, pos);\n        if(isMns) ret = mns(ret);\n    }\n\n    else {\n        ret = formula.at(pos) - '0';\n\n        pos++;\n    }\n\n    return ret;\n}\n\nvoid dfs(int p){\n    if(p == kVars.size()){\n        if(operate(formula1, pos = 0) != operate(formula2, pos = 0)){\n            res = \"NO\";\n        }\n\n        return;\n    }\n\n    rep(i, 2){\n        string tmp1 = formula1, tmp2 = formula2;\n\n        replace(all(formula1), kVars.at(p), (char)(i + '0'));\n        replace(all(formula2), kVars.at(p), (char)(i + '0'));\n\n        dfs(p + 1);\n\n        formula1 = tmp1, formula2 = tmp2;\n    }\n}\n\nint main(void){\n    for(string in; cin >> in, in != \"#\"; cout << res << endl){\n        res = \"YES\";\n\n        replace(all(in), 'T', '1');\n        replace(all(in), 'F', '0');\n        replace(all(in), '=', ' ');\n\n        stringstream ss(in);\n        ss >> formula1;\n        ss >> formula2;\n\n        dfs(0);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::string::const_iterator State;\n\nint Expr(State&);\n\n// Num: '0', '1', '2'\nint Num(State &begin){\n    return *(begin++) - '0';\n}\n\n// Not: '-' Not / Num\nint Not(State &begin){\n    if(*begin == '-'){\n        begin++;\n        int n = Not(begin);\n        return 2-n;\n    }\n    return Num(begin);\n}\n\n// Fact: '(' Expr ')' / Not\nint Fact(State &begin){\n    if(*begin == '('){\n        begin++;\n        int n = Expr(begin);\n        begin++;\n        return n;\n    }\n    return Not(begin);\n}\n\n// Term: Fact '*' Fact '*' Fact ...\nint Term(State &begin){\n    int res = Fact(begin);\n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            res = std::min(res, Fact(begin));\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\n// Expr: Term '+' Term '+' Term ...\nint Expr(State &begin){\n    int res = Term(begin);\n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            res = std::max(res, Term(begin));\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nvoid position(std::string &s, char c, std::vector<int> &v){\n    int pos = 0;\n    while(pos = s.find(c, pos), pos != std::string::npos){\n        v.push_back(pos);\n        pos += 1;\n    }\n}\n\nint main(){\n    std::string s;\n    while(std::cin >> s, s != \".\"){\n        std::vector<int> p_pos, q_pos, r_pos;\n        position(s, 'P', p_pos);\n        position(s, 'Q', q_pos);\n        position(s, 'R', r_pos);\n        \n        int res = 0;\n        REP(p, 3){\n            REP(q, 3){\n                REP(r, 3){\n                    std::string t = s;\n                    REP(i, p_pos.size()){\n                        t[p_pos[i]] = p+'0';\n                    }\n                    REP(i, q_pos.size()){\n                        t[q_pos[i]] = q+'0';\n                    }\n                    REP(i, r_pos.size()){\n                        t[r_pos[i]] = r+'0';\n                    }\n                    // std::cout << t << std::endl;\n                    State state = t.begin();\n                    if(Expr(state) == 2){res++;}\n                }\n            }\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint p,q,r,now;\nstring s;\n\nint formula(){\n\t\n\tif(isdigit(s[now]))return s[now]-'0';\n\telse if(s[now]=='P'){now++;return p;}\n\telse if(s[now]=='Q'){now++;return q;}\n\telse if(s[now]=='R'){now++;return r;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\telse if(s[now]=='('){\n\t\tnow++;\n\t\tint res=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\trep(p,3)rep(q,3)rep(r,3){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint pos;\n\nint parse(string s) {\n\tchar c = s[pos];\n\tswitch(c) {\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\t\t++pos;\n\t\treturn c - '0';\n\tcase '-':\n\t\t++pos;\n\t\treturn 2 - parse(s);\n\tcase '(':\n\t\t++pos;\n\t\tint a = parse(s);\n\t\tchar op = s[pos];\n\t\t++pos;\n\t\tint b = parse(s);\n\t\t++pos;\n\t\tif(op == '+') {\n\t\t\treturn max(a, b);\n\t\t} else if(op == '*') {\n\t\t\treturn min(a, b);\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s;\n\n\twhile(cin >> s, s != \".\") {\n\t\tint ans = 0;\n\t\tREP(p, 3) {\n\t\t\tREP(q, 3) {\n\t\t\t\tREP(r, 3) {\n\t\t\t\t\tstring tmp = s;\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tREP(i, s.size()) {\n\t\t\t\t\t\tif(tmp[i] == 'P') {\n\t\t\t\t\t\t\ttmp[i] = p + '0';\n\t\t\t\t\t\t} else if(tmp[i] == 'Q') {\n\t\t\t\t\t\t\ttmp[i] = q + '0';\n\t\t\t\t\t\t} else if(tmp[i] == 'R') {\n\t\t\t\t\t\t\ttmp[i] = r + '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(parse(tmp) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nclass Solver {\n    public:\n        string line;\n        int solve() {\n            int count = 0;\n            for (int p = 0; p < 3; ++p) {\n                for (int q = 0; q < 3; ++q) {\n                    for (int r = 0; r < 3; ++r) {\n                        if (eval(p, q, r, 0, line.length()) == 2) {\n                            ++count;\n                        }\n                    }\n                }\n            }\n            return count;\n        }\n        int eval(int p, int q, int r, int begin, int end) {\n            int nest = 0;\n            int bracket_begin;\n            stack<int> values;\n            stack<char> operators;\n            for (int i = begin; i < end; ++i) {\n                int x = -1;\n                if (nest == 0) {\n                    if ('0' <= line[i] && line[i] <= '2') {\n                        x = line[i] - '0';\n                    } else if (line[i] == 'P') {\n                        x = p;\n                    } else if (line[i] == 'Q') {\n                        x = q;\n                    } else if (line[i] == 'R') {\n                        x = r;\n                    } else if (line[i] != '(' && line[i] != ')') {\n                        operators.push(line[i]);\n                    }\n                }\n                if (line[i] == '(') {\n                    if (nest == 0) {\n                        bracket_begin = i;\n                    }\n                    ++nest;\n                } else if (line[i] == ')') {\n                    --nest;\n                    if (nest == 0) {\n                        x = eval(p, q, r, bracket_begin + 1, i);\n                    }\n                }\n                if (x < 0) {\n                    continue;\n                }\n                while (!operators.empty()) {\n                    char op = operators.top();\n                    if (op == '-') {\n                        x = 2 - x;\n                    } else if (op == '+') {\n                        x = max(x, values.top());\n                        values.pop();\n                    } else if (op == '*') {\n                        x = min(x, values.top());\n                        values.pop();\n                    }\n                    operators.pop();\n                }\n                values.push(x);\n            }\n            return values.top();\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.line;\n        if (s.line == \".\") {\n            return 0;\n        }\n        cout << s.solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\nint p,q,r;\nchar str[100];\nchar *sp;\n\nint formula(){\n\tchar c;\n\tc=*sp++;\n\tif('0'<=c&&c<'9') return c-'0';\n\tif(c=='P') return p;\n\tif(c=='Q') return q;\n\tif(c=='R') return r;\n\tif(c=='-') return -(formula()-1)+1;\n\tif(c=='('){\n\t\tint left, right;\n\t\tchar ope;\n\t\tleft = formula();\n\t\tope = *sp++;\n\t\tright = formula();\n\t\tsp++;\n\t\tif(ope=='*') return min(left, right);\n\t\tif(ope=='+') return max(left, right);\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>str, *str!='.'){\n\t\tint sum=0;\n\t\tfor(p=0;p<3;p++)\n\t\tfor(q=0;q<3;q++)\n\t\tfor(r=0;r<3;r++){\n\t\t\tsp = str;\n\t\t\tsum += formula()==2;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring in;\nint index;\nint f;\n\nint siki(int p,int q,int r){\n\tint num=-1;\n\tif(in[index]=='0'||in[index]=='1'||in[index]=='2'){\n\t\tnum=in[index]-'0';\n\t\tindex++;\n\t\tif(index==in.size()) return num;\n\t}\n\telse if(in[index]=='('){\n\t\tindex++;\n\t\tnum=siki(p,q,r);\n\t}\n\telse if(in[index]=='-'){\n\t\tindex++;\n\t\tf++;\n\t\tnum=siki(p,q,r);\n\t\tf--;\n\t\tif(num==0) num=2;\n\t\telse if(num==2) num=0;\n\t}\n\telse if(in[index]=='P') num=p,index++;\n\telse if(in[index]=='Q') num=q,index++;\n\telse if(in[index]=='R') num=r,index++;\n\tif(f!=0) return num;\n\tif(in[index]=='*'){\n\t\tint num2;\n\t\tindex++;\n\t\tnum2=siki(p,q,r);\n\t\tif(num==0&&num2==0) num=0;\n\t\telse if(num==0&&num2==1) num=0;\n\t\telse if(num==0&&num2==2) num=0;\n\t\telse if(num==1&&num2==0) num=0;\n\t\telse if(num==1&&num2==1) num=1;\n\t\telse if(num==1&&num2==2) num=1;\n\t\telse if(num==2&&num2==0) num=0;\n\t\telse if(num==2&&num2==1) num=1;\n\t\telse if(num==2&&num2==2) num=2;\n\t}\n\telse if(in[index]=='+'){\n\t\tint num2;\n\t\tindex++;\n\t\tnum2=siki(p,q,r);\n\t\tif(num==0&&num2==0) num=0;\n\t\telse if(num==0&&num2==1) num=1;\n\t\telse if(num==0&&num2==2) num=2;\n\t\telse if(num==1&&num2==0) num=1;\n\t\telse if(num==1&&num2==1) num=1;\n\t\telse if(num==1&&num2==2) num=2;\n\t\telse if(num==2&&num2==0) num=2;\n\t\telse if(num==2&&num2==1) num=2;\n\t\telse if(num==2&&num2==2) num=2;\n\t}\n\tif(in[index]==')'){\n\t\tindex++;\n\t\treturn num;\n\t}\n\treturn num;\n}\n\nint main(){\n\n\tint pdata[]={0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2};\n\tint qdata[]={0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2};\n\tint rdata[]={0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2};\n\tint cnt;\n\n\twhile(1){\n\n\t\tcin>>in;\n\t\tif(in==\".\") break;\n\n\t\tcnt=0;\n\t\tfor(int i=0;i<27;i++){\n\t\t\tindex=0;\n\t\t\tf=0;\n\t\t\tif(siki(pdata[i],qdata[i],rdata[i])==2) cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tswitch (T[pos++]) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return 2 - solve();\n\t\tcase '(':\n\t\t\tint a = solve();\n\t\t\tswitch (T[pos++]) {\n\t\t\t\tcase '+': a = min(a, solve());\n\t\t\t\tcase '*': a =  max(a, solve());\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn a;\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\n#define DEBUG false\n\nstring on[3] = { \"2\",\"1\",\"0\" };\nstring om[3][3] = { {\"0\",\"0\",\"0\"}, {\"0\",\"1\",\"1\"}, {\"0\",\"1\",\"2\"} };\nstring os[3][3] = { {\"0\",\"1\",\"2\"}, {\"1\",\"1\",\"2\"}, {\"2\",\"2\",\"2\"} };\n\nstring tab=\"\";\n\n/* \\¶ðÍ */\nstring cal( string s ){\n  stack<string> st;\n  string r, op1,op2;\n  unsigned int i,n, kind;\n\n  if( DEBUG ){\n    tab+=\"  \";\n    cout << tab << \"cal : \" << s << endl;\n  }\n  if( s[0]=='-' ){       // Ûè\n    r=\"\";\n    for( i=1,n=0; i<s.length();i++ ){\n      r += s[i];\n      if( s[i]=='(' )      n++;\n      else if( s[i]==')' ) n--;\n      if( s[i]=='-' ) continue;\n      if( n==0 ) break;\n    }\n    r = cal( r );\n    s = on[ r[0]-'0' ];\n  }else if( s[0]=='(' ){ // _aE_Ï\n    // op1ðßé\n    for( i=1,n=0,op1=\"\";i<s.length();i++ ){\n      op1 += s[i];\n      if( s[i]=='(' )      n++;\n      else if( s[i]==')' ) n--;\n      if( s[i]=='-' ) continue;\n      if( n==0 ){ ++i; break; }\n    }\n    if( s[i]=='+' ) kind=1;\n    else            kind=2;\n    // op2ðßé\n    for( ++i,n=0,op2=\"\";i<s.length();i++ ){\n      op2 += s[i];\n      if( s[i]=='(' )      n++;\n      else if( s[i]==')' ) n--;\n      if( s[i]=='-' ) continue;\n      if( n==0 ) break;\n    }\n    op1 = cal( op1 );\n    op2 = cal( op2 );\n    int i1=op1[0]-'0', i2=op2[0]-'0';\n    if( kind==1 ) s = os[ i1 ][ i2 ];\n    else          s = om[ i1 ][ i2 ];\n  }\n  if( DEBUG ){\n    cout << tab << \" return : \" << s << endl;\n    if( tab.length()>=2 )\n      tab = tab.substr( 2 );\n  }\n  return s;\n}\n\nint parse( string s, int p, int q, int r ){   // u·\n  for( unsigned int i=0;i<s.length();i++ ){\n    if( s[i]=='P' )      s[i] = p+'0';\n    else if( s[i]=='Q' ) s[i] = q+'0';\n    else if( s[i]=='R' ) s[i] = r+'0';\n  }\n  return cal( s )[0]-'0';\n}\n\n\nint main(){\n  string s;\n  while( cin>>s && s!=\".\" ){\n    if( DEBUG ){\n      cout << \"input : \" << s << endl;\n    }\n    int ans=0;\n    for( int p=0;p<3;p++ )\n      for( int q=0;q<3;q++ )\n\tfor( int r=0;r<3;r++ ){\n\t  if( parse( s,p,q,r )==2 )\n\t    ans++;\n\t  if( DEBUG ){\n\t    p=3;q=3;r=3; // fobOp\n\t  }\n\t}\n    cout << ans << endl;\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\n#define MAX_N 100\n\nusing namespace std;\n\nchar form[MAX_N];\nchar str[MAX_N];\n\nint calc_form(int l, int r){ //l-r???????????????????¨????\n\tint former, latter;\n\tint count = 0;\n\tint i;\n\tif(str[l] == '0') return 0;\n\tif(str[l] == '1') return 1;\n\tif(str[l] == '2') return 2;\n\tif(str[l] == '-'){\n\t\tif((l-r)%2==0){\n\t\t\treturn str[r]-'0';\n\t\t}else{\n\t\t\tint a = str[r]-'0';\n\t\t\tif(a == 0) return 2;\n\t\t\telse if(a == 2) return 0;\n\t\t\telse return 1;\n\t\t}\n\t}\n\tfor (i = l+1; i < r; i++)\n\t{\n\t\tif((str[i] == '+' || str[i] == '*') && count == 0) break;\n\t\tif(str[i] == '(') count++;\n\t\tif(str[i] == ')') count--;\n\t}\n\tformer = calc_form(l+1, i-1);\n\tlatter = calc_form(i+1, r-1);\n\tif(str[i] == '*'){\n\t\tif(former == 2 && latter == 2) return 2;\n\t\tif(former == 0 || latter == 0) return 0;\n\t\telse return 1;\n\t}else if(str[i] == '+'){\n\t\tif(former == 2 || latter == 2) return 2;\n\t\tif(former == 0 && latter == 0) return 0;\n\t\telse return 1;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> form;\n\t\tif(form[0] == '.') break;\n\t\tstrcpy(str, form);\n\t\tint ans = 0;\n\t\tfor (int p = 0; p <= 2; p++)\n\t\t{\n\t\t\tfor (int q = 0; q <= 2; q++)\n\t\t\t{\n\t\t\t\tfor (int r = 0; r <= 2 ; r++)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < strlen(str); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(str[i] == 'P') str[i] = p+'0';\n\t\t\t\t\t\tif(str[i] == 'Q') str[i] = q+'0';\n\t\t\t\t\t\tif(str[i] == 'R') str[i] = r+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif(calc_form(0, strlen(str)-1) == 2) ans++;\n\t\t\t\t\tstrcpy(str, form);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc_neg(int a) { return 2 - a; }\nint calc_plus(int a, int b) { return max(a, b); }\nint calc_mult(int a, int b) { return min(a, b); }\n\nint calc_op(int l, int r, char op) {\n\tif(op == '+') return calc_plus(l, r);\n\tif(op == '*') return calc_mult(l, r);\n\tassert(false);\n}\n\nint parse(const string &s, int &idx, map<char, int> mp) {\n\tif(s[idx] == '-') {\n\t\tidx++;\n\t\treturn calc_neg(parse(s, idx, mp));\n\t} else if(s[idx] == '(') {\n\t\tidx++;\n\t\tint left = parse(s, idx, mp);\n\t\tchar op = s[idx];\n\t\tidx++;\n\t\tint right = parse(s, idx, mp);\n\t\tassert(s[idx] == ')');\n\t\tidx++;\n\t\treturn calc_op(left, right, op);\n\t} else if('0' <= s[idx] && s[idx] <= '2') {\n\t\tint n = s[idx] - '0';\n\t\tidx++;\n\t\treturn n;\n\t} else {\n\t\tint n = mp[s[idx]];\n\t\tidx++;\n\t\treturn n;\n\t}\n}\n\nbool solve() {\n\tstring s;\n\tcin >> s;\n\tif(s == \".\") return false;\n\tmap<char, int> mp;\n\tint ans = 0;\n\tfor(int i = 0; i < 3 * 3 * 3; i++) {\n\t\tint cpy = i;\n\t\tfor(int j = 0; j < 3; j++) {\n\t\t\tmp['P' + j] = cpy % 3;\n\t\t\tcpy /= 3;\n\t\t}\n\t\tint idx = 0;\n\t\tint res = parse(s, idx, mp);\n\t\tans += res == 2;\n\t}\n\tcout << ans << endl;\n\treturn true;\n}\n\nint main() {\n\twhile(solve());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n#include<string>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n//構文を実際に計算する\nbool play(const string& s) {\n\tstack<char> info;\n\tfor (const char& c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(const string& formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n\nsize_t cur=0;\nint mul[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint add[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\n\nint term(string S);\nint expression(string S);\n\nint logic(string S){\n\tint n = S[cur] - '0'; \n\tcur++; \n\treturn n;\n}\n\n\nint factor(string S) {\n\tif (S[cur] == '('){\n\t\tcur++;\n\t\tint n = expression(S);\n\t\tassert(S[cur] == ')');\n\t\tcur++;\n\t\treturn n;\n\t}else if(S[cur] == '-'){\n\t\tcur++;\n\t\tint n;\n\t\t/*if( S[cur] == '0' ||S[cur] == '1' ||S[cur] == '2')\n\t\t\t n = logic(S);\n\t\telse */\n\t\t\t n = factor(S);\n\t\tif(n==1)\n\t\t\treturn n;\n\t\telse\n\t\t\treturn abs(n-2);\n\t}else\n\t\treturn logic(S);\n}\n\nint expression(string S){\n\tint sum = factor(S);\n\twhile(S[cur] == '*' || S[cur] == '+'){\n\t\tchar op = S[cur];\n\t\tcur += 1;\n\t\tint b = factor(S);\n\t\tif( op == '*')\n\t\t\tsum=mul[sum][b];\n\t\telse \n\t\t\tsum=add[sum][b];\n\t}\n\treturn sum;\n}\n\nvoid ReplaceStr(string& str, const string& from, const string& to)\n{\n  string::size_type pos = 0;\n\n  while(pos = str.find(from, pos), pos != string::npos) {\n    str.replace(pos, from.length( ), to);\n    pos += to.length();\n  }\n}\n\nint main(void){\n\tstring S;\n\twhile(cin >> S, S !=\".\"){\n\tint num=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tcur=0;\n\t\t\t\t\tstring I,J,K,T;\n\t\t\t\t\tI=i+'0';\n\t\t\t\t\tJ=j+'0';\n\t\t\t\t\tK=k+'0';\n\t\t\t\t\tT=S;\n\t\t\t\t\tReplaceStr( T,\"P\", I );\n\t\t\t\t\tReplaceStr( T,\"Q\", J );\n\t\t\t\t\tReplaceStr( T,\"R\", K );\n\t\t\t\t\tint r;\n\t\t\t\t\tr=expression(T);\n\t\t\t\t\tif(r==2)\n\t\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << num << endl;\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int AND[3][3]={{0,0,0},\n                    {0,1,1},\n                    {0,1,2}};\n\nconst int OR[3][3]={{0,1,2},\n                    {1,1,2},\n                    {2,2,2}};\n\nconst int NOT[3]={2,1,0};\n\n\nstring str;\nint wp=-1;\nint p,q,r;\n\nint parse(){ \n  wp++;\n  if(str[wp]=='0') return 0;\n  else if(str[wp]=='1') return 1;\n  else if(str[wp]=='2') return 2;\n  else if(str[wp]=='-') return NOT[parse()];\n  else if(str[wp]=='P') return p;\n  else if(str[wp]=='Q') return q;\n  else if(str[wp]=='R') return r;\n  else if(str[wp]=='('){\n    int ans,tmp = parse();     \n    wp++;\n    if(str[wp]=='+'){\n      ans = OR[tmp][parse()]; \n    }else if(str[wp]=='*'){\n      ans = AND[tmp][parse()];\n    }\n  \n    wp++;\n    return ans;\n  }\n  return 0;\n}\n\nint main(){\n\n  while(1){\n    cin >> str;\n    if(str==\".\"){\n      break;\n    }\n\n    int count=0;\n    rep(i,3) rep(j,3) rep(k,3){\n      p=i;q=j;r=k;\n      //cout << i << j << k << endl;\n      if(parse()==2) count++;\n      wp=-1;\n    }\n    cout << count << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n//typedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring s;\nint p;\nint P, Q, R;\nint term();\n\nint elem()\n{\n\tint tmp;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\ttmp = term();\n\t\tp++;\n\t\treturn tmp;\n\t}\n\tint cnt = 0;\n\tif (s[p] == '-')\n\t{\n\t\twhile (s[p] == '-')\n\t\t{\n\t\t\tcnt++;\n\t\t\tp++;\n\t\t}\n\t\treturn (cnt % 2 ? 2 - elem() : elem());\n\t}\n\tif (isdigit(s[p])) tmp = s[p] - '0';\n\telse if (s[p] == 'P') tmp = P;\n\telse if (s[p] == 'Q') tmp = Q;\n\telse if (s[p] == 'R') tmp = R;\n\tp++;\n\treturn tmp;\n}\n\nint term()\n{\n\tint tmp = elem();\n\twhile (s[p] == '+' || s[p] == '*')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tint a = elem();\n\t\tif (c == '+')\n\t\t{\n\t\t\ttmp = max(tmp, a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp = min(tmp, a);\n\t\t}\n\t}\n\treturn tmp;\n}\n\n\nint main()\n{\n\twhile (getline(cin, s))\n\t{\n\t\tif (s == \".\") break;\n\t\tp = 0;\n\t\tint cnt = 0;\n\t\tREP(i, 3)REP(j, 3)REP(k, 3)\n\t\t{\n\t\t\tp = 0;\n\t\t\tP = i, Q = j, R = k;\n\t\t\tif (term() == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\n\nint p,q,r;\nint it;\nstring s;\nint formula()\n{\n  // cout<<\"formula :\"<<s[it]<<endl;\n  if(s[it]=='-')\n    {\n      it++;\n      int tmp = formula();\n      return (-tmp)+2;\n    }\n  else if(s[it]=='(')\n    {\n      it++;\n      int a = formula();\n      it++;\n      if(s[it]=='*')\n\t{\n\t  it++;\n\t  int b = formula();\n\t  it++;\n\t  //\t  cout<<a<<\" \"<<b<<endl;\n\t  return min(a,b);\n\t}\n      else\n\t{\n\t  it++;\n\t  int b = formula();\n\t  it++;\n\t  return max(a,b);\n\t}\n    }\n  else\n    {\n      char tmp=s[it];\n      // it++;\n      if(tmp=='0')\n\treturn 0;\n      if(tmp=='1')\n\treturn 1;\n      if(tmp=='2')\n\treturn 2;\n      if(tmp=='P')\n\treturn p;\n      if(tmp=='Q')\n\treturn q;\n      if(tmp=='R')\n\treturn r;\n\n    }\n}\n\nint parse(string s)\n{\n  //  string::iterator it=s.begin();\n  it=0;\n  return formula();\n}\n\n\n\nint main()\n{\n  for(;cin>>s,s!=\".\";)\n    {\n      int cnt=0;\n      for(p=0;p<3;p++)\n\tfor(q=0;q<3;q++)\n\t  for(r=0;r<3;r++)\n\t    {\n\t         int ans=parse(s);\n\t      if(ans==2)\n\t\tcnt++;\n\t      //cout<<p<<\" \"<<q<<\" \"<<r<<\" \"<<ans<<endl;\n\t    }\n      cout<<cnt<<endl;\n\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nchar NOT[3] = {'2', '1', '0'};\nchar AND[3][3] = {{'0', '0', '0'}, {'0', '1', '1'}, {'0', '1', '2'}};\nchar OR[3][3] = {{'0', '1', '2'}, {'1', '1', '2'}, {'2', '2', '2'}};\n\nchar s[100];\nchar s1[100];\n\nchar getNumber() {\n  char k[100], kLeft[100], kN[100], kNumber = 0, notCounter = 0;\n  char ans;\n  for (char i = 0; s1[i] != 0; i++) {\n    if (s1[i] == '*' || s1[i] == '+') kLeft[kNumber] = s1[i-1] - '0';\n    if (s1[i] == '-') notCounter++;\n    else if (s1[i] == '(') kNumber++;\n    else if (s1[i] == '*') kN[kNumber] = 0;\n    else if (s1[i] == '+') kN[kNumber] = 1;\n    else if (s1[i] == ')') {\n      if (kN[kNumber] == 0) {\n        s1[i] = AND[kLeft[kNumber]][s1[i-1] - '0'];\n      } else {\n        s1[i] = OR[kLeft[kNumber]][s1[i-1] - '0'];\n      }\n      kNumber--;\n      if (notCounter % 2 == 1) s1[i] = NOT[s1[i] - '0'];\n      ans = s1[i];\n      notCounter = 0;\n    } else {\n      if (notCounter % 2 == 1) s1[i] = NOT[s1[i] - '0'];\n      ans = s1[i];\n      notCounter = 0;\n    }\n  }\n  return ans - '0';\n}\n\nchar check(char p, char q, char r) {\n  for (char i = 0; s[i] != 0; i++) {\n    s1[i] = s[i];\n    if (s1[i] == 'P') s1[i] = p + '0';\n    if (s1[i] == 'Q') s1[i] = q + '0';\n    if (s1[i] == 'R') s1[i] = r + '0';\n    s1[i+1] = 0;\n  }\n  if (getNumber() == 2) return 1;\n  return 0;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%s\", s);\n    if (s[0] == '.') break;\n    char ans = 0;\n    for (char p = 0; p < 3; p++)\n      for (char q = 0; q < 3; q++)\n        for (char r = 0; r < 3; r++)\n          ans += check(p, q, r);\n    printf(\"%d\\n\", (int)ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring formula;\nint idx;\n\nint notop[3]    = {2, 1, 0};\nint andop[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint orop[3][3]  = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\nint solve()\n{\n  int ret; char x = formula[idx];\n  if(x == '(') {\n    idx++, ret = solve();\n    char op = formula[idx];\n    if(op == '*') idx++, ret = andop[ret][solve()];\n    else if(op == '+') idx++, ret = orop[ret][solve()];\n    idx++;\n  }\n  else if(x == ')') idx++;\n  else if(x == '-') idx++, ret = notop[solve()];  \n  else if(isdigit(x)) ret = x - '0', idx++;\n  return ret;\n}\n\nint main()\n{\n  while(cin >> formula, formula != \".\") {\n    int ans = 0;\n    for(int P = '0'; P < '3'; P++) {\n      for(int Q = '0'; Q < '3'; Q++) {\n\tfor(int R = '0'; R < '3'; R++) {\n\t  string temp = formula;\n\t  replace(formula.begin(), formula.end(), 'P', (char)P);\n\t  replace(formula.begin(), formula.end(), 'Q', (char)Q);\n\t  replace(formula.begin(), formula.end(), 'R', (char)R);\n\t  idx = 0; if(solve() == 2) ans++;\n\t  formula = temp;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint p,q,r,now;\nstring s;\n\nint formula(){\n\t\n\tif(isdigit(s[now])){return s[now++]-'0';}\n\telse if(s[now]=='P'){now++;return p;}\n\telse if(s[now]=='Q'){now++;return q;}\n\telse if(s[now]=='R'){now++;return r;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\telse if(s[now]=='('){\n\t\tnow++;\n\t\tres=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\trep(p,3)rep(q,3)rep(r,3){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nusing namespace std;\n\nstring S;\nsize_t cur=0;\n\nint val[3];\n\nint mul[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint add[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\n\nint formula(){\n\tif(isdigit(S[cur]))\n\t\treturn S[cur++]-'0';\n\tif(isupper(S[cur]))\n\t\treturn val[S[cur++]-'P'];\n\n\tint res=0;\n\tif(S[cur]=='-'){\n\t\tcur++;\n\t\tres=2-formula();\n\t}else{\n\t\tif(S[cur]=='(') cur++;\n\t\tint a=formula();\n\t\tchar op=S[cur++];\n\t\tint b=formula();\n\t\tif(S[cur]==')') cur++;\n\t\tif(op=='*')\n\t\tres=mul[a][b];\n\t\tif(op=='+')\n\t\tres=add[a][b];\n\t}\n\treturn res;\n}\n\nint calc(){\n\tint res=0;\n\trep(i,3)rep(j,3)rep(k,3){\n\t\tcur=0;\n\t\tval[0]=i,val[1]=j,val[2]=k;\n\t\tres+=(2==formula());\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> S){\n\t\tif(S==\".\") break;\n\t\tcout << calc() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint rev(int x){\n    if (x == 0) return 2;\n    else if (x == 1) return 1;\n    else return 0;\n}\n\nint add(int x, int y){\n    return max(x, y);\n}\n\nint fac(int x, int y){\n    return min(x, y);\n}\n\nint main(){\n    while (1){\n        string s;\n        cin >> s;\n        if (s == \".\") break;\n        int ans = 0;\n        for (int p = 0; p < 3; p++){\n            for (int q = 0; q < 3; q++){\n                for (int r = 0; r < 3; r++){\n                    string t = s;\n                    while (t.size() != 1){\n                        int left = 0;\n                        int right = 0;\n                        int k = t.size();\n                        for (int i = 0; i < k; i++){\n                            if (t[i] == '(') left = i;\n                            if (t[i] == ')'){\n                                right = i;\n                                int dec = 0;\n                                char ope;\n                                int one;\n                                int two;\n                                for (int j = left + 1; j < right - 1; j++){\n                                    if (t[j] == '-') dec++;\n                                    else if (t[j] == '+' || t[j] == '*') ope = t[j];\n                                    else {\n                                        if (t[j] == 'P') one = p;\n                                        else if (t[j] == 'Q') one = q;\n                                        else if (t[j] == 'R') one = r;\n                                        else one = t[j] - '0';\n                                        if (dec % 2 == 1) one = rev(one);\n                                        dec = 0;\n                                    }\n                                }\n                                if (t[right - 1] == 'P') two = p;\n                                else if (t[right - 1] == 'Q') two = q;\n                                else if (t[right - 1] == 'R') two = r;\n                                else two = t[right - 1] - '0';\n                                if (dec % 2 == 1) two = rev(two);\n                                string next = \"\";\n                                if (ope == '+') next += add(one, two) + '0';\n                                else next += fac(one, two) + '0';\n                                t = t.substr(0, left) + next + t.substr(right+1);\n                                break;\n                            }\n                        }\n                        if (left == 0 && right == 0){\n                            int dec = 0;\n                            int one;\n                            for (int i = 0; i < k; i++){\n                                if (t[i] == '-') dec++;\n                                else {\n                                    if (t[i] == 'P') one = p;\n                                    else if (t[i] == 'Q') one = q;\n                                    else if (t[i] == 'R') one = r;\n                                    else one = t[i] - '0';\n                                    if (dec % 2 == 1) one = rev(one);\n                                    dec = 0;\n                                }\n                            }\n                            t = \"\";\n                            t += one + '0';\n                        }\n                    }\n                    if (t == \"P\"){\n                        t = \"\";\n                        t += p + '0';\n                    }\n                    if (t == \"Q\"){\n                        t = \"\";\n                        t += q + '0';\n                    }\n                    if (t == \"R\"){\n                        t = \"\";\n                        t += r + '0';\n                    }\n                    if (t == \"2\") ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint formula();\n\nint p, P, Q, R;\nstring s;\n\nint AND(int a, int b){\n  if( a == 0 || b == 0 ) return 0;\n  if( a == 2 && b == 2 ) return 2;\n  return 1;\n}\n\nint OR(int a, int b){\n  if( a == 2 || b == 2 ) return 2;\n  if( a == 0 && b == 0 ) return 0;\n  return 1;\n}\n\nint get(){\n  \n  int flg = 0;\n  \n  if( s[p] == '-' ){\n    p++;\n    flg = 1;\n  }\n  \n  int res;\n  \n  if( s[p] == 'P' ){\n    p++;\n    res = P;\n  }\n  else if( s[p] == 'Q' ){\n    p++;\n    res = Q;\n  }\n  else if( s[p] == 'R' ){\n    p++;\n    res = R;\n  }\n  else if( s[p] == '(' ){\n    p++;\n    res = formula();\n    p++;\n  }\n  else res = s[p++] - '0';\n  \n  if( flg ){\n    if( res == 0 ) res = 2;\n    else if( res == 2 ) res = 0;\n  }\n    \n  return res;\n}\n\nint formula(){\n  \n  int res = get();\n  \n  if( p == (int)s.size() ) return res;\n  \n  if( s[p] == '*' ){\n    p++;\n    res = AND( res, get() );\n  }\n  else if( s[p] == '+' ){\n    p++;\n    res = OR( res, get() );\n  }\n  \n  return res;\n}\n\nint solve(){\n  \n  int res = 0;\n  \n  for(P=0;P<=2;P++){\n    \n    for(Q=0;Q<=2;Q++){\n      \n      for(R=0;R<=2;R++){\n\t\n\tp = 0;\n\t\n\tif( formula() == 2 ) res++;\n\t\n      }\n      \n    }\n    \n  }\n\n  return res;\n}\n\nsigned main(){\n\n  while(1){\n  \n    cin >> s;\n    \n    if( s == \".\" ) break;\n    \n    int cnt = 100;\n    \n    while(cnt--){\n      \n      for(int i=0;i<(int)s.size()-1;i++){\n\n\tif( s[i] == '-' && s[i+1] == '-' ){\n\t  s = s.substr(0,i) + s.substr(i+2);\n\t  break;\n\t}\n\t\n      }\n      \n    }\n\n    cout << solve() << endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);++(i))\n\nconst int mul[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nconst int add[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\nconst int neg[3] = {2, 1, 0};\n\nint eval(string::iterator& c) {\n\tif(*c == '-') {\n\t\treturn neg[eval(++c)];\n\t}\n\tif(*c == '(') {\n\t\tint left = eval(++c);\n\t\tc++;\n\t\tif(*c == '*') {\n\t\t\tint right = eval(++c);\n\t\t\tc++;\n\t\t\treturn mul[left][right];\n\t\t}\n\t\tif(*c == '+') {\n\t\t\tint right = eval(++c);\n\t\t\tc++;\n\t\t\treturn add[left][right];\n\t\t}\n\t}\n\treturn *c-'0';\n}\n\nint main() {\n\tstring S;\n\twhile(cin >> S && S != \".\") {\n\t\tint res = 0;\n\t\trep(P,3) rep(Q,3) rep(R,3) {\n\t\t\tstring s = S;\n\t\t\tint pos;\n\t\t\tpos = s.find(\"P\");\n\t\t\twhile(pos != string::npos) {\n\t\t\t\ts.replace(pos, 1, to_string(P));\n\t\t\t\tpos = s.find(\"P\");\n\t\t\t}\n\t\t\tpos = s.find(\"Q\");\n\t\t\twhile(pos != string::npos) {\n\t\t\t\ts.replace(pos, 1, to_string(Q));\n\t\t\t\tpos = s.find(\"Q\");\n\t\t\t}\n\t\t\tpos = s.find(\"R\");\n\t\t\twhile(pos != string::npos) {\n\t\t\t\ts.replace(pos, 1, to_string(R));\n\t\t\t\tpos = s.find(\"R\");\n\t\t\t}\n\t\t\tstring::iterator c = s.begin();\n\t\t\tif(eval(c) == 2) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\n#define FOR(i,a,n) for(int i=a;i<n;i++)\n#define REP(i,n) FOR(i,0,n)\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\n#define ALL(a) a.begin(),a.end()\n\nint not(int n){\n\tswitch(n){\n\tcase 0:return 2;\n\tcase 1:return 1;\n\tcase 2:return 0;\n\t}\n}\nint and(int x,int y){\n\tswitch(x){\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn (y==0?0:1);\n\tcase 2:\n\t\treturn y;\n\t}\n}\nint or(int x,int y){\n\tswitch(x){\n\tcase 0:\n\t\treturn y;\n\tcase 1:\n\t\treturn (y==2?2:1);\n\tcase 2:\n\t\treturn 2;\n\t}\n}\nint n;\nint go(string s,int p,int q,int r){\n\tint a,b,sign,v;\n\tswitch(s[n]){\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\t\tv=s[n];\n\t\tn++;\n\t\treturn v-'0';\n\tcase 'P':\n\t\tn++;\n\t\treturn p;\n\tcase 'Q':\n\t\tn++;\n\t\treturn q;\n\tcase 'R':\n\t\tn++;\n\t\treturn r;\n\tcase '-':\n\t\tn++;\n\t\treturn not(go(s,p,q,r));\n\tcase '(':\n\t\tn++;\n\t\ta=go(s,p,q,r);\n\t\tsign=s[n];\n\t\tn++;\n\t\tb=go(s,p,q,r);\n\t\tn++;\n\t\tswitch(sign){\n\t\tcase '*':\n\t\t\treturn and(a,b);\n\t\tcase '+':\n\t\t\treturn or(a,b);\n\t\t}\n\tcase ')':\n\t\tassert(\")\");\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\".\"){\n\t\tint ans=0;\n\t\tREP(p,3)REP(q,3)REP(r,3){\n\t\t\tn=0;\n\t\t\tif(go(s,p,q,r)==2){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nconst int se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint number(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tif (isdigit(s[idx]) || s[idx]=='-')\n\t\treturn number(s, idx);\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\treturn val;\n}\nint number(string& s, int &idx) {\n\tint re = 0;\n\twhile (s[idx]=='-'){\n\t\tre++;\n\t\tidx++;\n\t}\n\tint val = s[idx] - '0';\n\tidx++;\n\tif (re% 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint bar[3] = { 2, 1, 0 };\n\nint mul[3][3] = {\n\t{ 0, 0, 0 },\n\t{ 0, 1, 1 },\n\t{ 0, 1, 2 }\n};\n\nint add[3][3] = {\n\t{ 0, 1, 2 },\n\t{ 1, 1, 2 },\n\t{ 2, 2, 2 }\n};\n\nstring str;\nint var[3];\n\nint parse(int l, int r) {\n\tint arc = 0, nl = -1;\n\tstack< char > op;\n\tstack< int > val;\n\t\n\tfor_(i,l,r) {\n\t\tif (arc == 0 && str[i] == '(') {\n\t\t\t++arc;\n\t\t\tnl = i + 1;\n\t\t} else if (arc > 0) {\n\t\t\tif (str[i] == ')') {\n\t\t\t\t--arc;\n\t\t\t\tif (arc == 0) val.push(parse(nl, i));\n\t\t\t} else if (str[i] == '(') {\n\t\t\t\t++arc;\n\t\t\t}\n\t\t} else if (arc == 0) {\n\t\t\tif (isdigit(str[i])) val.push(str[i] - '0');\n\t\t\telse if (str[i] == 'P') val.push(var[0]);\n\t\t\telse if (str[i] == 'Q') val.push(var[1]);\n\t\t\telse if (str[i] == 'R') val.push(var[2]);\n\t\t\telse op.push(str[i]);\n\t\t}\n\t}\n\t\n\tif (val.size() == 1) {\n\t\tint res = val.top(); val.pop();\n\t\t\n\t\twhile (!op.empty() && op.top() == '-') {\n\t\t\top.pop();\n\t\t\tres = bar[res];\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tint x2 = val.top(); val.pop();\n\twhile (op.top() == '-') {\n\t\top.pop();\n\t\tx2 = bar[x2];\n\t}\n\t\n\tchar opp = op.top(); op.pop();\n\t\n\tint x1 = val.top(); val.pop();\n\twhile (!op.empty() && op.top() == '-') {\n\t\top.pop();\n\t\tx1 = bar[x1];\n\t}\n\t\n\treturn (opp == '*' ? mul[x1][x2] : add[x1][x2]);\n}\n\nint main() {\n\twhile (cin >> str) {\n\t\tif (str == \".\") break;\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor_(p,0,3) for_(q,0,3) for_(r,0,3) {\n\t\t\tvar[0] = p; var[1] = q; var[2] = r;\n\t\t\tif (parse(0, (int)str.size()) == 2) ++ans;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nstring s;\nint c1[3]={2,1,0};\nint c2[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint c3[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nint t=0;\nint ret=0;\nint p,q,r;\nint form(){\n\tif(s[t]=='P')return p;\n\tif(s[t]=='Q')return q;\n\tif(s[t]=='R')return r;\n\tif(s[t]=='-'){\n\t\tt++;\n\t\treturn c1[form()];\n\t}\n\tif(s[t]=='('){\n\t\tt++;\n\t\tint t1=form();\n\t\tt++;\n\t\tchar t2=s[t];\n\t\tt++;\n\t\tint t3=form();\n\t\tt++;\n\t\tif(t2=='*'){\n\t\t\treturn c2[t1][t3];\n\t\t}else if(t2=='+'){\n\t\t\treturn c3[t1][t3];\n\t\t}\n\t}\n\tif(s[t]==')');\n\tif(s[t]=='0')return 0;\n\tif(s[t]=='1')return 1;\n\tif(s[t]=='2')return 2;\n}\nint main(){\n\twhile(1){\n\t\tret=0;\n\t\tcin>>s;\n\t\tif(s==\".\")break;\n\t\tfor(p=0;p<3;p++){\n\t\t\tfor(q=0;q<3;q++){\n\t\t\t\tfor(r=0;r<3;r++){\n\t\t\t\t\tt=0;\n\t\t\t\t\tif(form()==2)ret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint mynot(int i){\n  return 2 - i;\n}\n\nint myand(int i, int j){\n  if(i == 2 && j == 2){return 2;}\n  if(i == 0 || j == 0){return 0;}\n  return 1;\n}\n\nint myor(int i, int j){\n  if(i == 0 && j == 0){return 0;}\n  if(i == 2 || j == 2){return 2;}\n  return 1;\n}\n\nint interp(int P, int Q, int R, char* formula){\n  char* snd;\n  int   lcnt = 0;\n  int   ptr  = 0;\n\n  switch(formula[0]){\n    case '0':\n      return 0;\n      break;\n    case '1':\n      return 1;\n      break;\n    case '2':\n      return 2;\n      break;\n    case 'P':\n      return P;\n      break;\n    case 'Q':\n      return Q;\n      break;\n    case 'R':\n      return R;\n      break;\n    case '-':\n      return mynot(interp(P, Q, R, formula + 1));\n      break;\n    case '(':\n      int left, right;\n      ptr++;\n\n      if(formula[ptr] == '('){\n        int cnt = 1; ptr++;\n        while(cnt != 0){\n          if( formula[ptr] == '(' ){cnt++;}\n          if( formula[ptr] == ')' ){cnt--;}\n          ptr++;\n        }\n      }else if(formula[ptr] == '-'){\n        while(formula[ptr] == '-'){ptr++;}\n        ptr++;\n      }else{\n        ptr++;\n      }\n      if(formula[ptr] == '*'){\n        left  = interp(P, Q, R, formula + 1);\n        right = interp(P, Q, R, formula + ptr + 1);\n        return myand(left, right);\n      }\n      if(formula[ptr] == '+'){\n        left  = interp(P,Q,R, formula + 1);\n        right = interp(P,Q,R, formula + ptr + 1);\n        return myor(left, right);\n      }\n    }\n}\n\n\nint main(void){\n  while(1){\n    char formula[80];\n    cin >> formula;\n    if(formula[0] == '.') return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < 3 ; i++){\n      for(int j = 0; j < 3 ; j++){\n        for(int k = 0; k < 3 ; k++){\n          if(interp(i,j,k,formula) == 2) cnt++;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\n#include<stack>\n#define INF 1000000\nusing namespace std;\n\nstring str;\nint table[3];\nstack<int> Stack;\nint pos;\n\nint opnot(int a){\n  return 2 - a;\n}\n\nint opand(int a,int b){\n  if(a>b)return b;\n  else return a;\n}\n\nint opor(int a,int b){\n  if(a>b)return a;\n  else return b;\n}\n\nint formula(){\n  if(str[pos]=='0' || str[pos]=='1' || str[pos]=='2'){\n    return str[pos++]-'0';\n  }else if(str[pos]=='P' || str[pos]=='Q' || str[pos]=='R'){\n    return table[str[pos++]-'P'];\n  }else if(str[pos]=='-'){\n    pos++;\n    return opnot(formula());\n  }else if(str[pos]=='('){\n    pos++;\n    int ans=formula();\n    if(str[pos] == '*'){\n      pos++;\n      int res = opand(ans,formula());\n      pos++;\n      return res;\n    }else{\n      pos++;\n      int res = opor(ans,formula());\n      pos++;\n      return res;\n    }\n  }\n}\nint main(){\n  int count;\n  Stack.push(INF);\n  while(cin>>str){\n    if(str==\".\")break;\n    count=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  pos=0;\n\t  table[0]=i;\n\t  table[1]=j;\n\t  table[2]=k;\n\t  if(formula()==2) count++;\n\t}\n      }\n    }\n    cout<<count<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      //      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      //      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  } \n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint id, PQR[3];\nstring s;\n\nint NOT(int a) { return 2 - a; }\nint AND(int a, int b) { return min(a, b); }\nint OR(int a, int b) { return max(a, b); }\n\nint formula() {\n\tif (isdigit(s[id]))\treturn s[id++] - '0';\n\tif (isalpha(s[id])) return PQR[s[id++] - 'P'];\n\tif (s[id] == '-') {\n\t\tid++;\n\t\treturn NOT(formula());\n\t}\n\tif (s[id] == '(') {\n\t\tid++;\n\t\tint res, tmp = formula();\n\t\tif (s[id++] == '*') res = AND(tmp, formula());\n\t\telse res = OR(tmp, formula());\n\t\tid++;\n\t\treturn res;\n\t}\n}\n\nint main() {\n\twhile (cin >> s, s != \".\") {\n\t\tint ans = 0;\n\t\tfor (PQR[0] = 0; PQR[0] < 3; ++PQR[0])\n\t\t\tfor (PQR[1] = 0; PQR[1] < 3; ++PQR[1])\n\t\t\t\tfor (PQR[2] = 0; PQR[2] < 3; ++PQR[2], id = 0)\n\t\t\t\t\tif (formula() == 2) ans++;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define vec vector\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n\nint cal(char a, int d1, int d2)\n{\n\tif (a == '*') {\n\t\treturn min(d1, d2);\n\t} else {\n\t\treturn max(d1, d2);\n\t}\n}\n\nint ret(int a, int minus)\n{\n\tif (minus % 2) return 2 - a;\n\telse return a;\n}\n\nint solve(vec<char> formula, int p, int q, int r)\n{\n\tstack<int> ans;\n\tint minus = 0;\n\trep(i, formula.size()) {\n\t\tchar get = formula[i];\n\t\tif (get == '0' || get == '1' || get == '2'){\n\t\t   \tans.push(ret((int)get - '0', minus));\n\t\t}\n\t\telse if (get == 'P') ans.push(ret(p, minus));\n\t\telse if (get == 'Q') ans.push(ret(q, minus));\n\t\telse if (get == 'R') ans.push(ret(r, minus));\n\t\telse if (get == '-') minus++;\n\t\telse {\n\t\t\tint d1, d2;\n\t\t\td1 = ans.top();\n\t\t\tans.pop();\n\t\t\td2 = ans.top();\n\t\t\tans.pop();\n\t\t\tans.push(ret(cal(get, d1, d2), minus));\n\t\t}\n\t\tif (get != '-') minus = 0;\n\t}\n\tif (ans.top() == 2) return 1;\n\telse return 0;\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s == \".\") break;\n\n\t\tstack<char> keep;\n\t\tvec<char> formula;\n\t\trep(i, s.length()) {\n\t\t\tif (s[i] == '+' || s[i] == '(' || s[i] == '*') keep.push(s[i]);\n\t\t\telse if (s[i] == ')') {\n\t\t\t\twhile(1) {\n\t\t\t\t\tchar get = keep.top();\n\t\t\t\t\tkeep.pop();\n\t\t\t\t\tif (get == '(') break;\n\t\t\t\t\tformula.push_back(get);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tformula.push_back(s[i]);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\trep(p, 3) rep(q, 3) rep(r, 3) num += solve(formula, p, q, r); \n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring exp;\nint now,ans,p,q,r;\n\nint multi(int x,int y){\n\treturn min(x,y);\n}\n\nint myplus(int x,int y){\n\treturn max(x,y);\n}\n\nint myminus(int x){\n\tif(x==2)\n\t\treturn 0;\n\tif(x==1)\n\t\treturn 1;\n\tif(x==0)\n\t\treturn 2;\n\treturn false;\n}\nint calc(){\n\tif(exp[now]=='0' || exp[now]=='1' || exp[now]=='2'){\n\t\tchar temp=exp[now];\n\t\tnow++;\n\t\treturn temp-'0';\n\t}\n\tif(exp[now]=='P'){\n\t\tnow++;\n\t\treturn p;\n\t}else if(exp[now]=='Q'){\n\t\tnow++;\n\t\treturn q;\n\t}else if(exp[now]=='R'){\n\t\tnow++;\n\t\treturn r;\n\t}else if(exp[now]=='-'){\n\t\tnow++;\n\t\treturn myminus(calc());\n\t}else if(exp[now]=='('){\n\t\tnow++;\n\t\tint left=calc(),right;\n\t\tif(exp[now]=='*'){\n\t\t\tnow++;\n\t\t\tright=calc();\n\t\t\tnow++;\n\t\t\treturn multi(left,right);\n\t\t}\n\t\telse if(exp[now]=='+'){\n\t\t\tnow++;\n\t\t\tright=calc();\n\t\t\tnow++;\n\t\t\treturn myplus(left,right);\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tnow=0;\n\tans=0;\n\tint k;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int z=0;z<3;z++){\n\t\t\t\tp=i;\n\t\t\t\tq=j;\n\t\t\t\tr=z;\t\n\t\t\t\tk=calc();\n\t\t\t\tif(k==2){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tnow=0;\n\t\t\t}\n\tcout<<ans<<\"\\n\";\n}\n\n\nint main()\n{\n\tcin>>exp;\n\twhile(exp!=\".\"){\n\t\tsolve();\n\t\tcin>>exp;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint P, Q, R;\n\nint eval(string S, int &cur)\n{\n    // cerr << cur << endl;\n    if (S[cur] == '(')\n    {\n        cur++;\n        int val1 = eval(S, cur);\n        char op = S[cur];\n        cur++;\n        int val2 = eval(S, cur);\n        int val = 0;\n        if (op == '+')\n        {\n            val = max(val1, val2);\n        }\n        else if (op == '*')\n        {\n            val = min(val1, val2);\n        }\n        // cerr << val1 << ' ' << val2 << ' ' << cur << endl;\n        cur++;\n        return val;\n    }\n    else if (S[cur] == '-')\n    {\n        cur++;\n        int val = eval(S, cur);\n        if (val == 0)\n            return 2;\n        else if (val == 1)\n            return 1;\n        else if (val == 2)\n            return 0;\n    }\n    else\n    {\n        int val = 0;\n        if (S[cur] == 'P')\n        {\n            val = P;\n        }\n        else if (S[cur] == 'Q')\n            val = Q;\n        else if (S[cur] == 'R')\n            val = R;\n        else\n            val = (int)(S[cur] - '0');\n        cur++;\n        return val;\n    }\n}\n\nint main()\n{\n    string S;\n    while (cin >> S, S != \".\")\n    {\n        int res = 0;\n        for (P = 0; P <= 2; P++)\n        {\n            for (Q = 0; Q <= 2; Q++)\n            {\n                for (R = 0; R <= 2; R++)\n                {\n                    int c = 0;\n                    // cerr << P << ' ' << Q << ' ' << R << ':' << eval(S, c) << endl;\n                    // cerr << c << endl;\n                    c = 0;\n                    if (eval(S, c) == 2)\n                        res++;\n                }\n            }\n        }\n        // int c = 0;\n        // cerr << eval(S, c) << endl;\n        // cerr << c << endl;\n\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nvoid consume(State& begin,int c);\nint digit(State& begin);\nint formula(State& begin);\nvoid consume(State& begin,int c){\n  if(*begin != c){\n    cout << \"expected:\"<< (char)c<< \":input:\" << *begin << endl;\n  }\n  begin++;\n}\nint P,Q,R;\nint digit(State& begin){\n  int ret = *begin;\n  begin++;\n  return ret - '0';\n}\n\nint exp(State& begin){\n  int ret = 0;\n  consume(begin,'(');\n  int f = formula(begin);\n  char op = *begin;\n  begin++;\n  int n = formula(begin);\n  consume(begin,')');\n\n  if(op == '*'){\n    ret = f*n;\n    if(ret == 2)return 1;\n    if(ret == 4)return 2;\n    return ret; \n  }\n  if(op == '+'){\n    ret = f+n;\n    cout << \"in plus ret = \"  <<  ret << endl;\n    if(ret == 3 || ret == 4)return 2;\n    if(f == 1 && n == 1)return 1;\n    return ret;\n  }\n}\n\nint formula(State& begin){\n  char c = *begin;\n  if(isdigit(c)){\n    return digit(begin);\n  }else if(c == '('){\n    return exp(begin);\n  }else if(c == '-'){\n    begin++;\n    return 2 - formula(begin);\n  }else if(c == 'P'){\n    begin++;\n    return P;\n  }else if(c == 'Q'){\n    begin++;\n    return Q;\n  }else if(c == 'R'){\n    begin++;\n    return R;\n  }\n}\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  string str;\n  while(true){\n    int count = 0;\n    getline(cin,str);\n    if(str == \".\")break;\n    for(P = 0;P < 3;P++)\n      for(Q = 0;Q < 3;Q++)\n\tfor(R = 0;R < 3;R++){\n\t  State begin = str.begin();\n\t  if(formula(begin) == 2){\n\t    //cout << '(' << P << ','<<Q<<','<<R<<')' << endl;\n\t    count++;\n\t  }\n\t}\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint solve(string ss, int p, int q, int r) {\n  if (ss[0] == '-') {\n    int j = 0;\n    while(ss[j] == '-') j++;\n    int tmp = solve(ss.substr(j, ss.length() - j), p, q, r);\n    if (j % 2 == 1 && tmp != 1) {\n      if (tmp == 2) tmp = 0;\n      else tmp = 2;\n    }\n    return tmp;\n  } else if (ss[0] == '(') {\n    int j = 1, f = 0, op = 0, k = 0;\n\n    while(j < ss.length() - 1) {\n      if (ss[j] == '(') f++;\n      else if (ss[j] == ')') f--;\n      else if (f == 0 && ss[j] == '*') op = 1, k = j;\n      else if (f == 0 && ss[j] == '+') op = 0, k = j;\n      j++;\n    }\n    int a = solve(ss.substr(1, k - 1), p, q, r);\n    int b = solve(ss.substr(k + 1, ss.length() - 2 - k), p, q, r);\n\n    if (op) {\n      return min(a, b);\n    } else {\n      return max(a, b);\n    }\n  } else if (ss[0] == 'P') {\n    return p;\n  } else if (ss[0] == 'Q') {\n    return q;\n  } else if (ss[0] == 'R') {\n    return r;\n  } else {\n    return ss[0] - '0';\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  string s;\n  while(cin >> s, s[0]!='.') {\n    int ans = 0;\n    rep(i, 27) {\n      int p = i % 3, q = (i / 3) % 3, r = (i / 9) % 3;\n      int tmp = solve(s, p, q, r);\n      if (tmp == 2) ans++;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[100];\nint cnt=0;\nint Minus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    Minus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  int tm=0;\n    cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[tm++]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[tm++]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[tm++]=k+'0';\n\t    }else{\n\t      tmp[tm++]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint mul(int x, int y){\n  if(x == 0 || y == 0) return 0;\n  if(x == 2 && y == 2) return 2;\n  return 1;\n}\n\nint add(int x, int y){\n  if(x == 0 && y == 0) return 0;\n  if(x == 2 || y == 2) return 2;\n  return 1;\n}\n\nint neg(int x){\n  return 2 - x;\n}\n\nint parse(string& str, int a, int b){\n  int left = -1, right = -1;\n  int s, cnt = 0, op = 0, n = 1;\n  for(int i=a;i<b;++i){\n\tswitch(str[i]){\n\tcase '(':\n\t  if(cnt++ == 0) s = i+1;\n\t  break;\n\tcase ')':\n\t  --cnt;\n\t  if(cnt == 0){\n\t\tif(left == -1)\n\t\t  left = (n < 0? neg(parse(str, s, i)): parse(str, s, i));\n\t\telse\n\t\t  right = (n < 0? neg(parse(str, s,i)): parse(str, s,i));\n\t  }\n\t  break;\n\tcase '0': case '1': case '2':\n\t  if(cnt == 0){\n\t\tint d = str[i] - '0';\n\t\tif(left == -1)\n\t\t  left = (n < 0? neg(d): d);\n\t\telse\n\t\t  right = (n < 0? neg(d): d);\n\t  }\n\t  break;\n\tcase '-':\n\t  if(cnt == 0) n *= -1;\n\t  break;\n\tcase '+':\n\t  if(cnt == 0) n = 1, op = 1;\n\t  break;\n\tcase '*':\n\t  if(cnt == 0) n = 1, op = 2;\n\t  break;\n\t}\n  }\n  if(right == -1)\n\treturn left;\n  else{\n\tif(op == 1)\n\t  return add(left, right);\n\treturn mul(left, right);\n  }\n}\n\nstring rep(string& s, int p, int q, int r){\n  string ret = s;\n  for(int i=0;i<SZ(ret);++i){\n\tif(ret[i] == 'P') ret[i] = p+'0';\n\tif(ret[i] == 'Q') ret[i] = q+'0';\n\tif(ret[i] == 'R') ret[i] = r+'0';\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string line;\n  while(getline(cin,line)){\n\tif(line == \".\") break;\n\tint ans = 0;\n\tfor(int P=0;P<=2;++P)\n\t  for(int Q=0;Q<=2;++Q)\n\t\tfor(int R=0;R<=2;++R){\n\t\t  string s = rep(line, P, Q, R);\n\t\t  if(parse(s, 0, SZ(s)) == 2)\n\t\t\t++ans;\n\t\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nmap<char, int> num;\n\nint formula(string &s, int &i){\n    if(num.find(s[i]) != num.end()){\n        ++i;\n        return num[s[i-1]];\n    }\n    else if(s[i] == '-'){\n        ++i;\n        int ret = 2 - formula(s, i);\n        return ret;\n    }\n    else{\n        ++i;\n        int lhs = formula(s, i);\n        int ret;\n        if(s[i] == '*'){\n            ++i;\n            int rhs = formula(s, i);\n            ret = min(lhs, rhs);\n        }\n        else{\n            ++i;\n            int rhs = formula(s, i);\n            ret = max(lhs, rhs);\n        }\n        ++i;\n        return ret;\n    }\n}\n\nvoid solve(string &s){\n    rep(i, 3) num['0'+i] = i;\n    int ans = 0;\n    rep(S, 27){\n        int t = S;\n        rep(i, 3){\n            num['P'+i] = t % 3;\n            t /= 3;\n        }\n        int idx = 0;\n        ans += (formula(s, idx) == 2);\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main(){\n    string s;\n    while(cin >> s && s != \".\"){\n        solve(s);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint formula();\nvoid input();  // 終了処理有り\nvoid chkRPar();\nint expression();\nint calcPlus(int, int);\nint calcMul(int, int);\n\nchar ch;\nint pos;\nstring str;\nint P, Q, R;\nint nFlg = 1;  // 1 or -1 をformulaに掛ける。VARIABLEが来て初期化 1\n\nint main(void) {\n  int cnt;\n\n  while(1) {\n    cnt = 0;\n    getline(cin, str);\n    cout << str << endl;\n    for(P = 0; P < 3; P++) {\n      for(Q = 0; Q < 3; Q++) {\n\tfor(R = 0; R < 3; R++) {\n\t  pos = 0;\n\t  if(expression() == 2) cnt++;\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}\n\nvoid chkRPar() {\n  input();\n}\nvoid input() {\n  ch = str[pos++];\n  // cout << \"---\" << ch << endl;\n  if (ch == '.') exit(0);\n}\n\nint expression() {\n  int res = 0;\n  \n  input();\n\n  switch (ch) {\n  case '(':\n    res = expression();\n    input();\n    switch(ch) {\n    case '+':\n      res = calcPlus(res, expression());\n      break;\n    case '*':\n      res = calcMul(res, expression());\n      break;\n    default:\n      cout << \"Error!\" << endl;\n      exit(1);\n    }\n    chkRPar();\n    break;\n\n  default:\n    switch(ch) {\n    case '-':\n      res = 2 - expression();\n      break;\n    default:\n      res = formula();\n    }\n    break;\n  }\n\n  return res;\n}\n\nint formula() {\n\n  if(isdigit(ch)) return ch - '0';\n\n  switch(ch) {\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  }\n}\n\nint calcPlus(int d1, int d2) {\n  switch(d1) {\n  case 0:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 2;\n    }\n\n  case 1:\n    switch(d2) {\n    case 0: return 1;\n    case 1: return 1;\n    case 2: return 2;\n    }\n\n  case 2:\n    switch(d2) {\n    case 0: return 2;\n    case 1: return 2;\n    case 2: return 2;\n    }\n  }\n}\n\nint calcMul(int d1, int d2) {\n  switch(d1) {\n  case 0:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 0;\n    case 2: return 0;\n    }\n\n  case 1:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 1;\n    }\n\n  case 2:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 2;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint mul(int X,int Y){\n  if(X == 0 || Y == 0)return 0;\n  if(X == 1 || Y == 1)return 1;\n  if(X == 2 && Y == 2)return Y;\n  assert(false);\n}\n\nint add(int X,int Y){\n  if(X == 0)return Y;\n  if(X == 1 && (Y == 0 || Y == 1))return 1;\n  if(X == 1 && Y == 2)return 2; \n  if(X == 2)return 2;\n  assert(false);\n}\n\nint sub(int X){\n  if(X == 0)return 2;\n  if(X == 1)return 1;\n  if(X == 2)return 0;\n  assert(false);\n}\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }\n    else if(parse[pos] == '-'){\n      int p = 0;     \n      int cnt=0;\n      while(parse[pos] == '-'){      \n\tcnt++,pos++;\n      }\n      p = parse[pos]-'0';\n      pos++;\n      rep(i,cnt){\n\tp = sub(p);\t\n      }      \n      return p;\n      \n    }else{\n     \n      int p = 0;\n     \n      while('0' <= parse[pos] && parse[pos] <= '2'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n  int term(){\n    int p = fact();\n    return p;\n  }\n\n\n  int expression(){\n    int p = term();\n    //cout << \"X = \"<< p << endl;\n    while(parse[pos] == '+' || parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \" <<q << endl;\n\tp = mul(p,q);\n      }\n      else if(parse[pos] == '+'){\n\tpos++;\n\tint q = term();\n\t//cout << \"Y = \"<< q << endl;\n\tp = add(p,q);\n      }\n    }\n    return p;\n  }\n\n\n};\n\nint ans,last;\nstring s;\n\nvoid draw(char P,char Q,char R){\n  string pre = s;\n  rep(i,s.length()){\n    if(s[i] == 'P')s[i] = P;\n    else if(s[i] == 'Q')s[i] = Q;\n    else if(s[i] == 'R')s[i] = R;\n  }\n  Parsing par = Parsing(s);\n  int res = par.expression();\n  assert(res == 0 || res == 1 || res == 2);\n  if(res == 2)ans++;  \n  s = pre;\n}\n\nvoid test(){\n\n  for(char i='0';i<='2';i++){// P\n    for(char j='0';j<='2';j++){// Q\n      for(char k='0';k<='2';k++){// R\n\tdraw(i,j,k);\n      }\n    }\n  }\n\n\n}\n\n\nint main(){\n  while(true){\n    cin >> s;\n    if(s == \".\")break;\n    ans = 0;  \n    test();\n    cout << ans << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstring S;\n\nint and3(int s1, int s2) {\n  if(s1 == 2 && s2 == 2) return 2;\n  if(s1 == 0 || s2 == 0) return 0;\n  return 1;\n}\n\nint or3(int s1, int s2) {\n  if(s1 == 0 && s2 == 0) return 0;\n  if(s1 == 2 || s2 == 2) return 2;\n  return 1;\n}\n\nint calc(int p, int q, int r) {\n  stack<char> stk;\n\n  REP(i, 0, S.length()) {\n    if(S[i] == '-' || S[i] == '*' || S[i] == '+') stk.push(S[i]);\n    if(('0' <= S[i] && S[i] <= '2') || ('P' <= S[i] && S[i] <= 'R')) {\n      int d;\n      if('0' <= S[i] && S[i] <= '2') d = S[i] - '0';\n      if(S[i] == 'P') d = p;\n      if(S[i] == 'Q') d = q;\n      if(S[i] == 'R') d = r;\n      while(!stk.empty() && stk.top() == '-') {\n        stk.pop();\n        d = 2 - d;\n      }\n      stk.push(d);\n    }\n    if(S[i] == ')') {\n      int s2 = stk.top(); stk.pop();\n      int op = stk.top(); stk.pop();\n      int s1 = stk.top(); stk.pop();\n      int d;\n      if(op == '*') d = and3(s1, s2);\n      if(op == '+') d = or3(s1, s2);\n      stk.push(d);\n    }\n  }\n\n  return stk.top();\n}\n\nint main(void) {\n  while(cin >> S, S != \".\") {\n    int cnt = 0;\n    REP(p, 0, 3) REP(q, 0, 3) REP(r, 0, 3) if(calc(p, q, r) == 2) cnt++;\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nstring s;\nvector<int> eval(3);\nmap<char,function<int(int,int)>> op;\n\nint solve(int &i){\n  if(isdigit(s[i])){\n    return s[i++] - '0';\n    \n  }else if('P' <= s[i] and s[i] <= 'R'){\n    return eval[s[i++] - 'P'];\n    \n  }else if(s[i] == '-'){\n    i++; // '-'\n    return  2 - solve(i);\n\n  }else if(s[i] == '('){\n    i++; // '('\n    int l = solve(i);\n    \n    // '+' or '*'\n    char m = s[i];\n    assert(op.count(m));\n    i++;\n\n    int r = solve(i);\n    i++; // ')'\n    \n    return op[m](l,r);\n  }\n  assert(false);\n}\n\nint rec(int depth){\n  if(depth == 3){\n    int index = 0;\n    return solve(index) == 2;\n  }\n  int res = 0;\n  rep(i,3){\n    eval[depth] = i;\n    res += rec(depth+1);\n  }\n  return res;\n}\n\nint main(void){\n  op['+'] = [](int x,int y){\n    if(x == 2 or y == 2) return 2;\n    else if(x == 1 or y == 1) return 1;\n    else return 0;\n  };\n  op['*'] = [](int x,int y){\n    if(x == 0 or y == 0) return 0;\n    else if(x == 1 or y == 1) return 1;\n    else return 2;\n  };\n  \n  while(cin >> s, s != \".\"){\n    int res = rec(0);\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring R(string s,string t,string u){\n\tint p=s.find(t);\n\twhile(p!=string::npos){\n\t\ts.replace(p,t.size(),u);\n\t\tp=s.find(t,p+u.size());\n\t}\n\treturn s;\n}\nstring from[21]={\"-0\",\"-1\",\"-2\",\"(0*0)\",\"(0*1)\",\"(0*2)\",\"(1*0)\",\"(1*1)\",\"(1*2)\",\"(2*0)\",\"(2*1)\",\"(2*2)\",\"(0+0)\",\"(0+1)\",\"(0+2)\",\"(1+0)\",\"(1+1)\",\"(1+2)\",\"(2+0)\",\"(2+1)\",\"(2+2)\"};\nstring to[21]={\"2\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"2\",\"0\",\"1\",\"2\",\"1\",\"1\",\"2\",\"2\",\"2\",\"2\"};\nstring kaga3(string s){\n\twhile(1<s.size()){\n\t\tfor(int i=0;i<21;i++)s=R(s,from[i],to[i]);\n\t}\n\treturn s;\n}\n\nint main(){\n\t\n\tfor(string S,s;cin>>S,S!=\".\";){\n\t\tint ans=0;\n\t\tfor(char P='0';P<'3';P++){\n\t\t\tfor(char Q='0';Q<'3';Q++){\n\t\t\t\tfor(char R='0';R<'3';R++){\n\t\t\t\t\ts=S;\n\t\t\t\t\treplace(s.begin(),s.end(),'P',P);\n\t\t\t\t\treplace(s.begin(),s.end(),'Q',Q);\n\t\t\t\t\treplace(s.begin(),s.end(),'R',R);\n\t\t\t\t\tif(kaga3(s)==\"2\")ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tif(s.size()==1)return s[0];\n\tint cnt=0,f;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tV.PB(mt);\n\t\t}\n\t}\n\tif(f==0)return (char)(_and[V[0]][V[1]]+'0');\n\telse return (char)(_or[V[0]][V[1]]+'0');\n}\nint rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\tchar tt=pyon(s,p,q,r);\n\treturn tt-'0';\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tint res=rec(s,i,j,k);\n\t\t\tif(res==2)cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring exp;\nint now,ans,p,q,r;\n\nint multi(int x,int y){\n\treturn min(x,y);\n}\n\nint plus(int x,int y){\n\treturn max(x,y);\n}\n\nint minus(int x){\n\tif(x==2)\n\t\treturn 0;\n\tif(x==1)\n\t\treturn 1;\n\tif(x==0)\n\t\treturn 2;\n}\n\nint calc(){\n\tif(exp[now]=='0' || exp[now]=='1' || exp[now]=='2'){\n\t\tnow++;\n\t\treturn exp[now]-'0';\n\t}\n\tif(exp[now]=='P'){\n\t\tnow++;\n\t\treturn p;\n\t}else if(exp[now]=='Q'){\n\t\tnow++;\n\t\treturn q;\n\t}else if(exp[now]=='R'){\n\t\tnow++;\n\t\treturn r;\n\t}else if(exp[now]=='-'){\n\t\tnow++;\n\t\treturn minus(calc());\n\t}else if(exp[now]=='('){\n\t\tnow++;\n\t\tint left=calc(),right;\n\t\tif(exp[now]=='*'){\n\t\t\tnow++;\n\t\t\tright=calc();\n\t\t\tnow++;\n\t\t\treturn multi(left,right);\n\t\t}\n\t\telse if(exp[now]=='+'){\n\t\t\tnow++;\n\t\t\tright=calc();\n\t\t\tnow++;\n\t\t\treturn plus(left,right);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tnow=0;\n\tans=0;\n\tint k;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int z=0;z<3;z++){\n\t\t\t\tp=i;\n\t\t\t\tq=j;\n\t\t\t\tr=z;\t\n\t\t\t\tk=calc();\n\t\t\t\tif(k==2){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tnow=0;\n\t\t\t}\n\tcout<<ans<<\"\\n\";\n}\n\n\nint main()\n{\n\tcin>>exp;\n\twhile(exp!=\".\"){\n\t\tsolve();\n\t\tcin>>exp;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nint _not[3] = {2, 1, 0};\nint _and[3][3] = {\n    {0, 0, 0},\n    {0, 1, 1},\n    {0, 1, 2}\n};\nint _or[3][3] = {\n    {0, 1, 2},\n    {1, 1, 2},\n    {2, 2, 2}\n};\n\nint formula(string s, int &i, const int P, const int Q, const int R){\n    if      (s[i] == 'P')\n        return s[i++] = P;\n    else if (s[i] == 'Q')\n        return s[i++] = Q;\n    else if (s[i] == 'R')\n        return s[i++] = R;\n    else if (s[i] == '-')\n        return _not[formula(s, ++i, P, Q, R)];\n    else if (s[i] == '('){\n        int a = formula(s, ++i, P, Q, R);\n        if      (s[i] == '*'){\n            int ret = _and[a][formula(s, ++i, P, Q, R)];\n            i++;\n            return ret;\n        }else if(s[i] == '+'){\n            int ret = _or[a][formula(s, ++i, P, Q, R)];\n            i++;\n            return ret;\n        }\n    }else{\n        return s[i++]-'0';\n    }\n    return -1;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    while(cin>>s, s!=\".\"){\n        int count = 0;\n        for(int P=0; P<3; P++)\n            for(int Q=0; Q<3; Q++)\n                for(int R=0; R<3; R++){\n                    int i = 0;\n                    count += 2 == formula(s, i, P, Q, R);\n                }\n        cout << count << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 200005\nint N, M;\nint dp[MAX];\nbool taked[MAX];\n// expr +\n// term *\nint P, Q, R;\nint number(string& s, int& i);\nint factor(string& s, int& i);\nint not_calc(string& s, int& i);\nint term(string& s, int& i);\nint expr(string& s, int& i);\n\nint number(string& s, int& i) {\n\tint res;\n\tswitch (s[i]) {\n\tcase 'P': res = P; break;\n\tcase 'Q': res = Q; break;\n\tcase 'R': res = R; break;\n\tdefault: res = s[i] - '0';\n\t}\n\ti++;\n\tif (test) {\n\t\tdump(i);\n\t\tfprintf(stderr, \"number \");\n\t\tdump(res);\n\t}\n\treturn res;\n}\nint factor(string& s, int& i) {\n\tif (s[i] != '(') return number(s, i);\n\ti++;\n\tint ret = expr(s, i);\n\ti++;\n\tif (test) {\n\t\tfprintf(stderr, \"factor : \");\n\t\tdump(ret);\n\t}\n\treturn ret;\n}\n\nint not_calc(string& s, int& i) {\n\tint val;\n\tint cnt = 0;\n\twhile (s[i] == '-') {\n\t\tcnt++;\n\t\ti++;\n\t}\n\tval = factor(s, i);\n\tif (cnt % 2) {\n\t\tval = 2 - val;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"not_calc \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint term(string& s, int& i) {\n\tint val = not_calc(s, i);\n\twhile (s[i] == '*') {\n\t\ti++;\n\t\tint val2 = not_calc(s, i);\n\t\tif (val == 0 || val2 == 0) val = 0;\n\t\telse if (val == 1 || val2 == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"term \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint expr(string& s, int& i) {\n\tint val = term(s, i);\n\twhile (s[i] == '+') {\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (val == 2 || val2 == 2) val = 2;\n\t\telse if (val == 1 || val2 == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"sum \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\n\nsigned main(void)\n{\n\tint i, j, k;\n\n\twhile (1) {\n\t\tstring s;\n\t\tint cnt = 0;\n\t\tcin >> s;\n\t\tif (s == \".\") return 0;\n\t\t//i = 0;\n\t\t//P = 0; Q = 0; R = 0;\n\t\t//expr(s, i);\n\t\trep(P, 3) rep(Q, 3) rep(R, 3) {\n\t\t\t//dump(P);\n\t\t\t//dump(Q);\n\t\t\t//dump(R);\n\t\t\ti = 0;\n\t\t\tif (expr(s, i) == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint PQR[3],now;\nstring exp;\n\nint fomula(){\n\n  now++;\n  if(exp[now-1]=='('){\n    int res=fomula();\n    now++;\n    if(exp[now-1]=='+')res=max(res,fomula());\n    if(exp[now-1]=='*')res=min(res,fomula());\n    now++;\n    return res;\n  }\n  if(isdigit(exp[now-1]))return exp[now-1]-'0';\n  if(isupper(exp[now-1]))return PQR[exp[now-1]-'P'];\n  if(exp[now-1]=='-')return 2-fomula();\n}\n\nint main(void){\n\n  while(cin >> exp,exp!=\".\"){\n    int cnt=0;\n    rep(PQR[0],3)rep(PQR[1],3)rep(PQR[2],3){\n      now=0;\n      cnt+=(2==fomula());\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nconst int se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint num(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tif (isdigit(s[idx])||s[idx]=='-')return num(s, idx);\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\treturn val;\n}\nint num(string& s, int &idx) {\n\tint not= 0;\n\twhile (s[idx]=='-')\n\t{\n\t\tnot++;\n\t\tidx++;\n\t}\n\tint val = s[idx] - '0';\n\tidx++;\n\tif (not% 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nmap<char, int> table;\n\nint formula(const string &f, int &pos) {\n  if (isdigit(f[pos])) return f[pos++] - '0';\n  if (f[pos] == 'P' || f[pos] == 'Q' || f[pos] == 'R') return table[f[pos++]];\n\n  if (f[pos] == '-') {\n    int ret = formula(f, ++pos);\n    return ret == 0 ? 2 : (ret + 2) % 2;\n  }\n\n  if (f[pos] == '(') {\n    int lhs = formula(f, ++pos);\n    char op = f[pos];\n    int rhs = formula(f, ++pos);\n    int ret;\n    if (op == '+') {\n      if (lhs == 2 || rhs == 2) ret = 2;\n      else if (lhs == 1 || rhs == 1) ret = 1;\n      else ret = 0;\n    } else if(op == '*') {\n      if (lhs == 0 || rhs == 0) ret = 0;\n      else if (lhs == 1 || rhs == 1) ret = 1;\n      else ret = 2;\n    }\n    pos++;\n    return ret;\n  }\n}\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  string f;\n  while (cin >> f, f != \".\") {\n    int ans = 0;\n    int pos = 0;\n    rep(p, 3) rep(q, 3) rep(r, 3) {\n      table['P'] = p;\n      table['Q'] = q;\n      table['R'] = r;\n\n      pos = 0;\n      int ret = formula(f, pos);\n      if (ret == 2) ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "//#define MyDebug\n#include <bits/stdc++.h>\n\n#define rep(i, from, to) for (int i = from; i < to; ++i)\n#define REP(i, from, to) for (int i = from; i <= to; ++i)\n\n#ifdef MyDebug\n#define debug(x) cerr << #x << \" : \" << x << endl;\n#define debug3(x, y, z) cerr << #x << \" : \" << x << \", \"<<#y << \" : \" << y <<  \", \" << #z << \" : \" << z << endl;\n#else\n#define debug(x)\n#define debug3(x, y, z)\n#endif\n\nusing namespace std;\n\nint cnt = 0;\nstring s;\nchar now;\nstring ans;\nchar op1 = '*', op2 = '+', op3 = '-';\nbool isSymbol(char c) {\n\treturn c == '0' || c == '1' || c == '2' || c == 'P' || c == 'Q' || c == 'R';\n}\nvoid replaceAll(string &s, char c, int num) {\n\trep (i, 0, (int)s.size()) {\n\t\tif (s[i] == c) s[i] = (char)(num + '0');\n\t}\n}\nvoid formula() {\n\tnow = s[cnt];\n\tif (now == '(') {\n\t\t++cnt;\n\t\tformula();\n\t\tif (s[cnt] == op1) {\n\t\t\tcnt++;\n\t\t\tformula();\n\t\t\t++cnt;\n\t\t\tans += op1;\n\t\t}if (s[cnt] == op2) {\n\t\t\tcnt++;\n\t\t\tformula();\n\t\t\t++cnt;\n\t\t\tans += op2;\n\t\t}\n\t} else if (isSymbol(now)) {\n\t\tans += now;\n\t\t++cnt;\n\t} else if (now == op3) {\n\t\t++cnt;\n\t\tformula();\n\t\tans += op3;\n\t}\n}\n\nint my_and[][3] = {{0, 1, 2},{1, 1, 2}, {2, 2, 2}};\nint my_or[][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint my_not[] = {2, 1, 0};\n\nint eval(int x1, int x2, char op) {\n\tdebug3(x1, x2, op);\n\tif (op == op2) return my_and[x1][x2];\n\tif (op == op1) return my_or[x1][x2];\n\tif (op == op3) return my_not[x1];\n\treturn -1;\n}\n\nstack<int> st;\n\nbool isNum(char c) {\n\treturn c == '0' || c == '1' || c == '2';\n}\nint evalAll(string &s) {\n\trep(i, 0, (int)s.size()) {\n\t\tdebug(s[i]);\n\t\tif (isNum(s[i])) {\n\t\t\tst.push(s[i] - '0');\n\t\t} else if (s[i] == op3) {\n\t\t\tint v = eval(st.top(), -1, op3);\n\t\t\tst.pop();\n\t\t\tst.push(v);\n\t\t} else {\n\t\t\tint x1 = st.top();st.pop();\n\t\t\tint x2 = st.top();st.pop();\n\t\t\tint v = eval(x1, x2, s[i]);\n\t\t\tst.push(v);\n\t\t}\n\t}\n\tint top = st.top();\n\tst.pop();\n\treturn top;\n}\nint ansN = 0;\nvoid init() {\n\tansN = 0;\n\tans =\"\";\n\tst = stack<int>();\n\tcnt = 0;\n\ts = \"\";\n}\n\nvoid solve() {\n\twhile(cin >> s, s != \".\") {\n\t\tformula();\n\t\trep(i, 0, 3) {\n\t\t\trep(j, 0, 3) {\n\t\t\t\trep(k, 0, 3) {\n\t\t\t\t\tstring ans1 = ans;\n\t\t\t\t\treplaceAll(ans1, 'P', i);\n\t\t\t\t\treplaceAll(ans1, 'Q', j);\n\t\t\t\t\treplaceAll(ans1, 'R', k);\n\t\t\t\t\tif (evalAll(ans1) == 2) {\n\t\t\t\t\t\t++ansN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ansN << endl;\n\t\tinit();\n\t}\n}\nvoid test() {\n\tstring s = \"aaaaaa\";\n\ts.insert(2, \"b\");\n\ts.erase(2, 1);\n\tdebug(s);\n}\nvoid test2() {\n\tstring a = \"01+\";\n\tdebug(evalAll(a));\n}\nvoid test3() {\n\tstring a = \"PQ+\";\n\treplaceAll(a, 'P', 2);\n\treplaceAll(a, 'Q', 1);\n\tcerr << evalAll(a) << endl;\n}\nvoid test4() {\n\tstring s = \"2\";\n\tcerr << evalAll(s) << endl;\n}\nvoid test5() {\n\ts = \"(P*-P)\";\n\tformula();\n\tcerr << ans << endl;\n}\n\nint main() {\n\tsolve();\n\t//test5();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nint apply(int lhs, char op, int rhs) {\n  if (op == '*') return std::min(lhs, rhs);\n  if (op == '+') return std::max(lhs, rhs);\n  assert(false);\n}\n\nint parse(\n    const std::string &s, size_t &i, const std::vector<int> &vars, \n    const std::vector<std::string> &ops={\"+*\"}, size_t preced=0) {\n\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      int res=parse(s, ++i, vars, ops, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if (s[i] == '-') {\n      ++i;\n      return 2-parse(s, i, vars, ops, preced);\n    }\n    if (isalpha(s[i])) {\n      return vars[s[i++]-'P'];\n    }\n    if (isdigit(s[i])) {\n      return s[i++]-'0';\n    }\n  }\n  int res=parse(s, i, vars, ops, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    int tmp=parse(s, ++i, vars, ops, preced+1);\n    res = apply(res, op, tmp);\n  }\n  return res;\n}\n\nint testcase_ends() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  if (s == \".\") return 1;\n  int res=0;\n  std::vector<int> vars(3);\n  for (int p=0; p<3; ++p) {\n    vars[0] = p;\n    for (int q=0; q<3; ++q) {\n      vars[1] = q;\n      for (int r=0; r<3; ++r) {\n        vars[2] = r;\n        size_t i=0;\n        if (parse(s, i, vars) == 2)\n          ++res;\n      }\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nclass Exp {\npublic:\n  char op, val;\n  Exp *lch, *rch;\n  Exp() {}\n};\nExp *pl(const string &s, int l, int r);\nExp *mult(const string &s, int l, int r);\nExp *mi(const string &s, int l, int r);\nExp *term(const string &s, int l, int r);\nExp *pl(const string &s, int l, int r) {\n  if(l >= r) return nullptr;\n  int cnt = 0;\n  for(int i=l;i<r;++i) {\n    if(s[i] == '(') {\n      cnt++;\n    } else if(s[i] == ')') {\n      cnt--;\n    } else if(s[i] == '+' && cnt == 0) {\n      Exp *res = new Exp();\n      res->op = '+';\n      res->lch = pl(s, l, i);\n      res->rch = pl(s, i+1, r);\n      return res;\n    }\n  }\n  return mult(s, l, r);\n}\nExp *mult(const string &s, int l, int r) {\n  if(l >= r) return nullptr;\n  int cnt = 0;\n  for(int i=l;i<r;++i) {\n    if(s[i] == '(') {\n      cnt++;\n    } else if(s[i] == ')') {\n      cnt--;\n    } else if(s[i] == '*' && cnt == 0) {\n      Exp *res = new Exp();\n      res->op = '*';\n      res->lch = mult(s, l, i);\n      res->rch = mult(s, i+1, r);\n      return res;\n    }\n  }\n  return mi(s, l, r);\n}\nExp *mi(const string &s, int l, int r) {\n  if(l >= r) return nullptr;\n  if(s[l] == '-') {\n    Exp *res = new Exp();\n    res->op = '-';\n    res->rch = mi(s, l+1, r);\n    return res;\n  } else {\n    return term(s, l, r);\n  }\n}\nExp *term(const string &s, int l, int r) {\n  if(s[l] == '(' && s[r-1] == ')') {\n    return pl(s, l+1, r-1);\n  }\n  Exp *res = new Exp();\n  res->val = s[l];\n  return res;\n}\nint solve(Exp *now, int p, int q, int r) {\n  if(now->op == '*') {\n    int lch = solve(now->lch, p, q, r);\n    int rch = solve(now->rch, p, q, r);\n    if(lch == 0) {\n      return 0;\n    } else if(lch == 1) {\n      if(rch == 0) return 0;\n      else return 1;\n    } else {\n      return rch;\n    }\n  } else if(now->op == '+') {\n    int lch = solve(now->lch, p, q, r);\n    int rch = solve(now->rch, p, q, r);\n    if(lch == 0) {\n      return rch;\n    } else if(lch == 1) {\n      if(rch == 2) return 2;\n      else return 1;\n    } else {\n      return 2;\n    }\n  } else if(now->op == '-') {\n    int rch = solve(now->rch, p, q, r);\n    if(rch == 0) {\n      return 2;\n    } else if(rch == 1) {\n      return 1;\n    } else if(rch == 2) {\n      return 0;\n    }\n  } else if(now->val == '0') {\n    return 0;\n  } else if(now->val == '1') {\n    return 1;\n  } else if(now->val == '2') {\n    return 2;\n  } else if(now->val == 'P') {\n    return p;\n  } else if(now->val == 'Q') {\n    return q;\n  } else if(now->val == 'R') {\n    return r;\n  }\n  return 0;\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    string s; cin >> s;\n    if(s == \".\") break;\n    Exp *res = pl(s, 0, (int)(s.size()));\n    int cnt = 0;\n    for(int i=0;i<=2;++i) {\n      for(int j=0;j<=2;++j) {\n        for(int k=0;k<=2;++k) {\n          cnt += solve(res, i, j, k) == 2;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint mynot(int i){\n  return 2 - i;\n}\n\nint myand(int i, int j){\n  if(i == 2 && j == 2){return 2;}\n  if(i == 0 || j == 0){return 0;}\n  return 1;\n}\n\nint myor(int i, int j){\n  if(i == 0 && j == 0){return 0;}\n  if(i == 2 || j == 2){return 2;}\n  return 1;\n}\n\nint interp(int P, int Q, int R, char* formula){\n  char* snd;\n  int   lcnt = 0;\n  int   ptr  = 0;\n\n  switch(formula[0]){\n    case '0':\n      return 0;\n      break;\n    case '1':\n      return 1;\n      break;\n    case '2':\n      return 2;\n      break;\n    case 'P':\n      return P;\n      break;\n    case 'Q':\n      return Q;\n      break;\n    case 'R':\n      return R;\n      break;\n    case '-':\n      return mynot(interp(P, Q, R, formula + 1));\n      break;\n    case '(':\n      int left, right;\n      ptr++;\n\n        if(formula[ptr] == '('){\n          int cnt = 1; ptr++;\n          while(cnt != 0){\n            if( formula[ptr] == '(' ){cnt++;}\n            if( formula[ptr] == ')' ){cnt--;}\n            ptr++;\n          }\n        }else if(formula[ptr] == '-'){\n          while(formula[ptr] == '-'){ptr++;}\n          if(formula[ptr] == '('){\n            int cnt = 1; ptr++;\n            while(cnt != 0){\n              if( formula[ptr] == '(' ){cnt++;}\n              if( formula[ptr] == ')' ){cnt--;}\n              ptr++;\n            }\n          }\n          ptr++;\n        }else{\n          ptr++;\n        }\n\n      if(formula[ptr] == '*'){\n        left  = interp(P, Q, R, formula + 1);\n        right = interp(P, Q, R, formula + ptr + 1);\n        return myand(left, right);\n      }\n      if(formula[ptr] == '+'){\n        left  = interp(P,Q,R, formula + 1);\n        right = interp(P,Q,R, formula + ptr + 1);\n        return myor(left, right);\n      }\n    }\n}\n\n\nint main(void){\n  while(1){\n    char formula[80];\n    cin >> formula;\n    if(formula[0] == '.') return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < 3 ; i++){\n      for(int j = 0; j < 3 ; j++){\n        for(int k = 0; k < 3 ; k++){\n          if(interp(i,j,k,formula) == 2) cnt++;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V=1e3+5;\nconst int INF=1e9;\nvector< vector<int> > board(25,vector<int>(25,0) );\nint w,h;\nint sy,sx,gy,gx;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint goal=100;\n//Prototype\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint number(string &s,int &i)\n{\n  int n=s[i++]-'0';\n  while(isdigit(s[i])) n=n*10+s[i++]-'0';\n  return n;\n}\n\nint factor(string &s,int &i)\n{\n  if(isdigit(s[i])) return number(s,i);\n  assert(s[i]=='(');\n  i++;\n  int ret=expr(s,i);\n  i++;\n  return ret;\n}\nint term(string &s, int &i)\n{\n  int val;\n  if(s[i]!='-')\n    {\n      val=factor(s,i);\n    }\n  while(s[i]=='-')\n    {\n      i++;\n      int val2=term(s,i);\n      if(val2==0) val=2;\n      if(val2==1) val=1;\n      if(val2==2) val=0;\n    }\n  return val;\n}\nint expr(string &s, int &i)\n{\n  int val=term(s,i);\n  while(s[i]=='*' || s[i]=='+')\n    {\n      char op=s[i];\n      i++;\n      int val2=term(s,i);\n      if(op=='*') val=min(val,val2);\n      else if(op=='+') val=max(val,val2); \n    }\n  return val;\n}\nint main(void)\n{\n  string s;\n  while(cin >> s && s!=\".\")\n    {\n      int ans=0;\n      string origin=s;\n      for(int r=0;r<=2;r++)\n\t{\n\t  for(int p=0;p<=2;p++)\n\t    {\n\t      for(int q=0;q<=2;q++)\n\t\t{\n\t\t  s=origin;\n\t\t  for(int i=0;i<int(s.size());i++)\n\t\t    {\n\t\t      if(s[i]=='P') s[i]='0'+p;\n\t\t      if(s[i]=='Q') s[i]='0'+q;\n\t\t      if(s[i]=='R') s[i]='0'+r;\n\t\t    }\n\t\t  //cout << s << endl;\n\t\t  int i=0;\n\t\t  if(expr(s,i)==2) ans++;\n\t\t}\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstring replace(string S, char a, char b){\n  string ret = S;\n  for(int i = 0; i < S.length(); ++i){\n    if(S[i] == a) ret[i] = b;\n  }\n  return ret;\n}\n\nclass Parser{\npublic:\n  string s;\n  size_t i;\n  int parse(){\n    i = 0;\n    return formula();\n  }\n  int formula(){\n    if(i >= s.length()) return 0;\n    if(s[i] >= '0' && s[i] <= '2'){\n      ++i;\n      return s[i-1] - '0';\n    }\n    if(s[i] == '-'){\n      ++i;\n      return 2 - formula();\n    }\n    if(s[i] == '('){\n      ++i;\n      int x = formula();\n      char o = s[i];\n      ++i;\n      int y = formula();\n      ++i;\n      if(o == '*') return min(x,y);\n      if(o == '+') return max(x,y);\n    }\n    return -1;\n  }\n};\n\n\nint solve(string S){\n  int ret = 0;\n  for(int i = 0; i < 3; ++i){\n    for(int j = 0; j < 3; ++j){\n      for(int k = 0; k < 3; ++k){\n        string S_ = S;\n        S_ = replace(S_,'P','0'+i);\n        S_ = replace(S_,'Q','0'+j);\n        S_ = replace(S_,'R','0'+k);\n        Parser P;\n        P.s = S_;\n        if(P.parse() == 2) ++ret;\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  string S;\n  while(cin >> S, S != \".\"){\n    cout << solve(S) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint bar[3] = {2,1,0};\n\nint mul[3][3] = {\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint add[3][3] = {\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\n\nstring s;\nint PQR[3];\n\nbool isvar(char c) { return (c - '0' >= 0 && c - '0' <= 2) || (c - 'P' >= 0 && c - 'P' <= 2); }\nint getvar(char c) {\n\tif (0 <= c - '0' && c - '0' <= 2) return c - '0';\n\treturn PQR[c - 'P'];\n}\n\nint rec(int lft, int rgt) {\n\t//cerr << s.substr(lft, rgt-lft) << endl;\n\tint open_cnt = 0, close_cnt = 0, bar_cnt = 0;\n\tint nxt_lft = -1;\n\t\n\tstack< int > st;\n\tstack< char > op;\n\tfor_(i,lft,rgt) {\n\t\tif (open_cnt == close_cnt && s[i] == '-') {\n\t\t\t++bar_cnt;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && isvar(s[i])) {\n\t\t\tint x = getvar(s[i]);\n\t\t\tfor_(rep,0,bar_cnt) x = bar[x];\n\t\t\tst.push(x);\n\t\t\tbar_cnt = 0;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '*') op.push('*');\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '+') op.push('+');\n\t\t\n\t\tif (s[i] == '(') {\n\t\t\tif (open_cnt == close_cnt) nxt_lft = i+1;\n\t\t\t++open_cnt;\n\t\t}\n\t\t\n\t\tif (s[i] == ')') {\n\t\t\t++close_cnt;\n\t\t\tif (open_cnt == close_cnt) st.push(rec(nxt_lft, i));\n\t\t}\n\t\t\n\t\tif (st.size() >= 2 && !op.empty()) {\n\t\t\tchar opr = op.top(); op.pop();\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tif (opr == '*') st.push(mul[x][y]);\n\t\t\tif (opr == '+') st.push(add[x][y]);\n\t\t}\n\t}\n\t\n\treturn st.top();\n}\n\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \".\") break;\n\t\tint ans = 0;\n\t\tfor_(p,0,3) for_(q,0,3) for_(r,0,3) {\n\t\t\tPQR[0] = p; PQR[1] = q; PQR[2] = r;\n\t\t\tif (rec(0, s.size()) == 2) ++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=k+'0';\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 200005\nint N, M;\nint dp[MAX];\nbool taked[MAX];\n// expr +\n// term *\nint P, Q, R;\nint number(string& s, int& i);\nint factor(string& s, int& i);\nint not_calc(string& s, int& i);\nint term(string& s, int& i);\nint expr(string& s, int& i);\n\nint number(string& s, int& i) {\n\tint res;\n\tswitch (s[i]) {\n\tcase 'P': res = P; break;\n\tcase 'Q': res = Q; break;\n\tcase 'R': res = R; break;\n\tdefault: res = s[i] - '0';\n\t}\n\ti++;\n\tif (test) {\n\t\tdump(i);\n\t\tfprintf(stderr, \"number \");\n\t\tdump(res);\n\t}\n\treturn res;\n}\nint factor(string& s, int& i) {\n\tif (s[i] != '(') return number(s, i);\n\ti++;\n\tint ret = expr(s, i);\n\ti++;\n\tif (test) {\n\t\tfprintf(stderr, \"factor : \");\n\t\tdump(ret);\n\t}\n\treturn ret;\n}\n\nint not_calc(string& s, int& i) {\n\tint val;\n\tint cnt = 0;\n\twhile (s[i] == '-') {\n\t\tcnt++;\n\t\ti++;\n\t}\n\tval = factor(s, i);\n\tif (cnt % 2) {\n\t\tval = 2 - val;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"not_calc \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint term(string& s, int& i) {\n\tint val = not_calc(s, i);\n\twhile (s[i] == '*') {\n\t\ti++;\n\t\tint val2 = not_calc(s, i);\n\t\tif (val == 0 || val2 == 0) val = 0;\n\t\telse if (val == 1 || val2 == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"term \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint expr(string& s, int& i) {\n\tint val = term(s, i);\n\twhile (s[i] == '+') {\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (val == 2 || val2 == 2) val = 2;\n\t\telse if (val == 1 || val == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"sum \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\n\nsigned main(void)\n{\n\tint i, j, k;\n\n\twhile (1) {\n\t\tstring s;\n\t\tint cnt = 0;\n\t\tcin >> s;\n\t\tif (s == \".\") return 0;\n\t\t//i = 0;\n\t\t//P = 0; Q = 0; R = 0;\n\t\t//expr(s, i);\n\t\trep(P, 3) rep(Q, 3) rep(R, 3) {\n\t\t\t//dump(P);\n\t\t\t//dump(Q);\n\t\t\t//dump(R);\n\t\t\ti = 0;\n\t\t\tif (expr(s, i) == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint p, q, r;\nstring expr;\nint i;\n\nint calc(){\n\tswitch( expr[i++] ){\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t\tcase '-':\n\t\t\treturn 2 - calc();\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '(':\n\t\t\tint a = calc();\n\t\t\t\n\t\t\tif( expr[i++] == '+' ){\n\t\t\t\ta = max( a, calc() );\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta = min( a, calc() );\n\t\t\t}\n\t\t\t++i;\n\t\t\treturn a;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tfor(; cin >> expr, expr[0] != '.'; ){\n\t\tint cnt = 0;\n\t\tfor( p = 0; p <= 2; ++p ){\n\t\t\tfor( q = 0; q <= 2; ++q ){\n\t\t\t\tfor( r = 0; r <= 2; ++r ){\n\t\t\t\t\ti = 0;\n\t\t\t\t\tif( calc() == 2 ){\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nmap<char, int> val;\nstring in;\nint p;\n\nint formula(){\n    int res = -1;\n    if(isdigit(in[p]))res = in[p++] - '0';\n    else if(isalpha(in[p]))res = val[in[p++]];\n    else if(in[p] == '-'){\n        p++;\n        res = 2 - formula();\n    }\n    else if(in[p] == '('){\n        p++;\n        int x = formula();\n        bool plus = in[p++] == '+';\n        int y = formula();\n        p++;\n        res = plus? max(x, y): min(x, y);\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> in, in != \".\"){\n        int ans = 0;\n        rep(i, 3){\n            val['P'] = i;\n            rep(j, 3){\n                val['Q'] = j;\n                rep(k, 3){\n                    val['R'] = k;\n                    p = 0;\n                    ans += 2 == formula();\n                }\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INF = 1001001001;\n\nint formula(const string& str, int& cur)\n{\n//\tputs(str.substr(cur).c_str());\n\tif(isdigit(str[cur])){\n\t\t++cur;\n\t\treturn str[cur-1] - '0';\n\t}\n\tif(str[cur] == '-'){\n\t\t++cur;\n\t\treturn 2 - formula(str, cur);\n\t}\n\n\t++cur;\n\tint a = formula(str, cur);\n\tchar op = str[cur];\n\t++cur;\n\tint b = formula(str, cur);\n\t++cur;\n\tif(op == '+')\n\t\treturn max(a, b);\n\telse\n\t\treturn min(a, b);\n}\n\nint main()\n{\n\tchar str[128];\n\twhile(scanf(\"%s\", str), str[0]!='.'){\n\t\tint n = strlen(str);\n\t\tint cnt = 0;\n\t\trep(p, 3) rep(q, 3) rep(r, 3){\n\t\t\tstring tmp = str;\n\t\t\trep(i, n){\n\t\t\t\tif(tmp[i] == 'P') tmp[i] = p + '0';\n\t\t\t\tif(tmp[i] == 'Q') tmp[i] = q + '0';\n\t\t\t\tif(tmp[i] == 'R') tmp[i] = r + '0';\n\t\t\t}\n\t\t\tint cur = 0;\n\t\t\tcnt += formula(tmp, cur) == 2;\n\t\t}\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nstring s;\nint table1[] = { 2,1,0 };\nint table2[3][3] = { { 0,1,2 },\n\t\t\t\t\t { 1,1,2 },\n\t\t\t\t\t { 2,2,2 } };\nint table3[3][3] = { { 0,0,0 },\n\t\t\t\t\t { 0,1,1 },\n\t\t\t\t\t { 0,1,2 } };\nint p, q, r;\n\nint number(int &pos) {\n\tif (s[pos] == '0') {\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif (s[pos] == '1') {\n\t\tpos++;\n\t\treturn 1;\n\t}\n\tif (s[pos] == '2') {\n\t\tpos++;\n\t\treturn 2;\n\t}\n\tif (s[pos] == 'P') {\n\t\tpos++;\n\t\treturn p;\n\t}\n\tif (s[pos] == 'Q') {\n\t\tpos++;\n\t\treturn q;\n\t}\n\tif (s[pos] == 'R') {\n\t\tpos++;\n\t\treturn r;\n\t}\n}\n\nint formula(int &pos) {\n\tif (s[pos] == '-') {\n\t\tpos++;\n\t\treturn table1[formula(pos)];\n\t}\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tint res = formula(pos);\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tres = table2[res][formula(pos)];\n\t\t}\n\t\telse if (s[pos] == '*') {\n\t\t\tpos++;\n\t\t\tres = table3[res][formula(pos)];\n\t\t}\n\t\tpos++;\n\t\treturn res;\n\t}\n\treturn number(pos);\n}\n\nint main() {\n\twhile (cin >> s&&s != \".\") {\n\t\tint ans = 0;\n\t\trep(i, 3) {\n\t\t\trep(j, 3) {\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tp = i;\n\t\t\t\t\tq = j;\n\t\t\t\t\tr = k;\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tif (formula(pos) == 2) {\n\t\t\t\t\t\t//cout << \"!\" << p << \" \" << q << \" \" << r << endl;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nusing P   = pair<ll, ll>;\nusing mat = vector<vector<ll>>;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nvoid IOS() { ios::sync_with_stdio(false), cin.tie(0); }\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-12;\n\ntemplate <typename T>\nvoid dump(T x) { cout << x << endl; }\nvoid dumpf(ld x, int t) { cout << setprecision(t) << fixed << x << endl; }\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\ninline ll mod(ll a, ll b) {\n\tif (a > 0) return a % b;\n\tif (a % b == 0) return 0;\n\tll x = -a / b + 1;\n\ta += x * b;\n\treturn a % b;\n}\nll powm(ll a, ll b, ll c) {\n\tif (b == 0)\n\t\treturn 1;\n\telse if (b % 2 == 0) {\n\t\tll d = powm(a, b / 2, c);\n\t\treturn (d * d) % c;\n\t} else\n\t\treturn (a * powm(a, b - 1, c)) % c;\n}\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n//ll dx[4] = {1, 0, -1, 0};\n//ll dy[4] = {0, 1, 0, -1};\n\nint number(State &);\nint factor(State &);\nint expr(State &);\nint p[3];\n\nint number(State &begin) {\n\tint ret;\n\tif (*begin == '-') {\n\t\tbegin++;\n\t\treturn -factor(begin) + 2;\n\t}\n\tif (isdigit(*begin)) {\n\t\tret = *begin - '0';\n\t\tbegin++;\n\t} else {\n\t\tint x = *begin - 'P';\n\t\tret   = p[x];\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tll ret = expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint expr(State &begin) {\n\tint ret = factor(begin);\n\twhile (1) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret = max(ret, factor(begin));\n\t\t} else if (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret = min(ret, factor(begin));\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tstring s;\n\twhile (1) {\n\t\tcin >> s;\n\t\tif (s == \".\") break;\n\t\tll ans = 0;\n\t\tfor (int i = 0; i <= 2; i++)\n\t\t\tfor (int j = 0; j <= 2; j++)\n\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\t\tState begin = s.begin();\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << expr(begin) << endl;\n\t\t\t\t\tif (expr(begin) == 2) ans++;\n\t\t\t\t}\n\t\tdump(ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint P,Q,R;\nchar* c;\n\nint NOT(int);\nint test(void);\nint Calc(void);\nbool Solve(void);\n\nint main(){\n\tchar st[100];\n\twhile(scanf(\"%s\",st), st[0]!='.'){\n\t\tint ans=0;\n\t\tfor(P=0;P<3;P++){\n\t\t\tfor(Q=0;Q<3;Q++){\n\t\t\t\tfor(R=0;R<3;R++){\n\t\t\t\t\tc=st;\n\t\t\t\t\tans+=Solve();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}\nint NOT(int x){\n\tif(x==2)return 0;\n\telse if(x==1)return 1;\n\telse if(x==0)return 2;\n\telse{\n\t\tcout<<\"??\"<<endl;\n\t\treturn 0;\n\t}\n}\nint Calc(){\n\tif(*c=='0'||*c=='1'||*c=='2')return *c-'0';\n\telse if(*c=='P')return P;\n\telse if(*c=='Q')return Q;\n\telse if(*c=='R')return R;\n\telse if(*c=='-'){\n\t\t++c;\n\t\treturn NOT(Calc());\n\t}else if(*c=='(')return test();\n}\n\n//{{{\nint test(){\n\tc++;\n\tint A=Calc();\tc++;\n\tchar op=*c;\tc++;\n\tint B=Calc();\tc++;\n\n\tif(op=='+')return max(A,B);\n\telse if(op=='*')return min(A,B);\n}\n//}}}\nbool Solve(){\n\tstack<int> s;\n\twhile(*c!='\\0'){\n\t\ts.push(Calc());\n\n\t\tc++;\n\t}\n\t//printf(\"SIZE : %d\\n\",s.size());\n\tint ans=s.top();\ts.pop();\n\tif(ans==2){\n\t\t//printf(\"(P,Q,R) : %d,%d,%d\\n\",P,Q,R);\n\t\treturn true;\n\t}\n\telse return false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nPII expression( const string &, int );\nPII factor( const string &, int );\nPII number( const string &, int );\n\nPII expression( const string &s, int p = 0 )\n{\n\tif ( s[p] == '-' )\n\t{\n\t\tPII r = expression( s, p + 1 );\n\t\tr.fst = 2 - r.fst;\n\t\treturn r;\n\t}\n\telse if ( s[p] == '(' )\n\t{\n\t\tPII r = factor( s, p + 1 );\n\t\tr.snd ++;\n\t\treturn r;\n\t}\n\telse\n\t{\n\t\tPII r = number( s, p );\n\t\treturn r;\n\t}\n}\n\nconst int mult[][3] = {\n\t0, 0, 0, \n\t0, 1, 1,\n\t0, 1, 2\n};\nconst int plu[][3] = {\n\t0, 1, 2,\n\t1, 1, 2,\n\t2, 2, 2\n};\n\nPII factor( const string &s, int p )\n{\n\tPII r1 = expression( s, p );\n\tchar op = s[ r1.snd + 1 ];\n\tPII r2 = expression( s, r1.snd + 2 );\n\n\tswitch ( op )\n\t{\n\t\tcase '*':\n\t\t\treturn MP( mult[ r1.fst ][ r2.fst ], r2.snd );\n\t\tcase '+':\n\t\t\treturn MP( plu[ r1.fst ][ r2.fst ], r2.snd );\n\t}\n};\n\nPII number( const string &s, int p )\n{\n\treturn MP( s[p] - '0', p );\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( string str; cin >> str, str != \".\"; )\n\t{\n\t\tint res = 0;\n\t\tREP( i, 0, 3 )\n\t\t{\n\t\t\tREP( j, 0, 3 )\n\t\t\t{\n\t\t\t\tREP( k, 0, 3 )\n\t\t\t\t{\n\t\t\t\t\tstring tmp = str;\n\t\t\t\t\treplace( ALL( tmp ), 'P', (char)( '0' + i ) );\n\t\t\t\t\treplace( ALL( tmp ), 'Q', (char)( '0' + j ) );\n\t\t\t\t\treplace( ALL( tmp ), 'R', (char)( '0' + k ) );\n\t\t\t\t\tres += expression( tmp ).fst == 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n \nint P,Q,R;\nchar *p;\n \nint formula(){\n    int l,r;\n    char c = *p++;\n    if(isdigit(c)) return c-'0';\n    if(isupper(c)) return (c == 'P' ? P : c == 'Q' ? Q : R);\n    if(c == '-') return 2-formula();\n    if(c == '('){\n\tl = formula();\n\tif(*p++ == '*'){\n\t    r = formula();\n\t    *p++;\n\t    return (l < r ? l : r);\n\t}else{\n\t    r = formula();\n\t    *p++;\n\t    return (l > r ? l : r);\n\t}  \n    }\n    return 0;\n}\n \nint main(){\n    int ans;\n    char s[100];\n    while(scanf(\"%s\",s), s[0] != '.'){\n\tans = 0; \n\tfor(P = 0 ; P < 3 ; P++){\n\t    for(Q = 0 ; Q < 3 ; Q++){\n\t\tfor(R = 0 ; R < 3 ; R++){\n\t\t    p = s;\n\t\t    if(formula() == 2) ans++;\n\t\t}\n\t    }\n\t}\n\tprintf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define N 3\nusing namespace std;\nint formula();\nint p,P,Q,R;\nstring str;\nint main(){\n  int r,cnt;\n  while(1){\n    cin >> str;\n    if(str==\".\") break;\n    cnt=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tfor(int k=0;k<N;k++){\n\t  p=0,P=i,Q=j,R=k;\n\t  r=formula();\n\t  if(r==2) cnt++;\n\t}\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nint formula(){\n  int val,val1;\n  while(1){\n    if(str[p]=='0'||str[p]=='1'||str[p]=='2'){\n      p++;\n      return str[p-1]-'0';\n    }\n    else if(str[p]=='P'){\n      p++;\n      return P;\n    }\n    else if(str[p]=='Q'){\n      p++;\n      return Q;\n    }\n    else if(str[p]=='R'){\n      p++;\n      return R;\n    }\n    else if(str[p]=='-'){\n      p++;\n      val=formula();\n      return 2-val;\n    }\n    else if(str[p]=='('){\n      p++;\n      val=formula();\n    }\n    else if(str[p]=='*'){\n      p++;\n      val1=formula();\n      return min(val,val1);\n    }\n    else if(str[p]=='+'){\n      p++;\n      val1=formula();\n      return max(val,val1);\n    }\n    else if(str[p]==')') p++;\n  }\n  return val;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nqueue<char> convert(string formula){\n  queue<char> qu;\n  stack<char> st;\n  \n  bool b_minus = false;\n  for(char c : formula){\n    switch(c){\n      case '(':\n        if(b_minus == true) {\n          st.push('-');\n          b_minus = false;\n        }\n        break;\n      case '0': case '1': case '2': case 'P': case 'Q': case 'R':\n        qu.push(c);\n        if(b_minus == true){\n          qu.push('-');\n          b_minus = false;\n        }\n        break;\n      case '*': case '+':\n        st.push(c);\n        break;\n      case '-':\n           b_minus = true;\n        break;\n      case ')':\n        qu.push(st.top());\n        st.pop();\n        if(!st.empty() && st.top() == '-'){\n          qu.push(st.top());\n          st.pop();\n        }\n        break;\n      }\n  }\n  return qu;\n}\n\nint lAnd(int a, int b){\n  if(a == 0 || b == 0) return 0;\n  else if(a == 2 && b == 2) return 2;\n  else return 1;\n}\n\nint lOr(int a, int b){\n  if(a == 2 || b == 2) return 2;\n  else if(a == 0 && b == 0) return 0;\n  else return 1;\n}\n\nint lNot(int a){\n  if(a == 0) return 2;\n  else if(a == 1) return 1;\n  else return 0;\n}\n\nint cal(queue<char> quc, int p, int q, int r){\n  stack<int> stc;\n  int a,b;\n  while(!quc.empty()){\n    char c = quc.front();\n    quc.pop();\n    switch(c){\n      case '0':\n      case '1':\n      case '2':\n        stc.push(c-'0');\n        break;\n      case 'P':\n        stc.push(p);\n        break;\n      case 'Q':\n        stc.push(q);\n        break;\n      case 'R':\n        stc.push(r);\n        break;\n      case '+':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lOr(a,b));\n        break;\n      case '*':\n        b = stc.top(); stc.pop();\n        a = stc.top(); stc.pop();\n        stc.push(lAnd(a,b));\n        break;\n      case '-':\n        a = stc.top(); stc.pop();      \n        stc.push(lNot(a));\n        break;\n    }\n  }\n  return stc.top();\n}\n\nint main(void){\n  string d = \"\";\n  int ans;\n  while(true){\n    cin >> d;\n    if(d == \".\") break;\n    d = regex_replace(d, std::regex(\"(--)\"), \"\");\n    \n    queue<char> t = convert(d);\n    ans = 0;\n    for(int i=0;i<=2;i++){\n      for(int j=0;j<=2;j++){\n        for(int k=0;k<=2;k++){\n          if(cal(t,i,j,k) == 2) ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n\n    // queue<char> t = convert(d);\n    // while(!t.empty()){\n    //   cout << t.front();\n    //   t.pop();\n    // }\n    // cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// 'P', 'Q', 'R' ツづー '1', '2', '3'ツづ可置ツつォツ環キツつヲツづゥ\nvoid PQR_change(string& s ,char p , char q , char r ){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == 'P' ) s[i] = p;\n\t\tif( s[i] == 'Q' ) s[i] = q;\n\t\tif( s[i] == 'R' ) s[i] = r;\n\t}\n}\n\n// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\"ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_erace(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '-' && s[i-1] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 1;\n\t\t}\n\t}\n}\n\n// \"-0\", \"-1\", \"-2\" ツづー \"2\", \"1\", \"0\" ツづ可置ツつォツ環キツつヲツづゥ\nvoid minus_calc(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' ){\n\t\t\tif( s[i] == '0' ){\n\t\t\t\ts.replace( i-1 , 2 , \"2\" );\n\t\t\t}else if( s[i] == '1' ){\n\t\t\t\ts.replace( i-1 , 2 , \"1\" );\n\t\t\t}else if( s[i] == '2' ){\n\t\t\t\ts.replace( i-1 , 2 , \"0\" );\n\t\t\t}\n\t\t\ti = 1;\n\t\t}\n\t}\n}\n\n// \"(0+0)\", \"(0+1)\", ... , \"(2+2)\" ツづー \"0\", \"1\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ) \nvoid plus_calc(string& s){\n\tstring ex[9] = {\n\t\t\"(0+0)\", \"(0+1)\", \"(0+2)\",\n\t\t\"(1+0)\", \"(1+1)\", \"(1+2)\",\n\t\t\"(2+0)\", \"(2+1)\", \"(2+2)\"\n\t};\n\tstring result[9] = {\n\t\t\"0\", \"1\", \"2\",\n\t\t\"1\", \"1\", \"2\",\n\t\t\"2\", \"2\", \"2\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 9 ; j++ ){\n\t\t\tif( s.substr( i , 5 ) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// \"(0*0)\", \"(0*1)\", ... , \"(2*2)\" ツづー \"0\", \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ) \nvoid mult_calc(string& s){\n\tstring ex[9] = {\n\t\t\"(0*0)\", \"(0*1)\", \"(0*2)\",\n\t\t\"(1*0)\", \"(1*1)\", \"(1*2)\",\n\t\t\"(2*0)\", \"(2*1)\", \"(2*2)\"\n\t};\n\tstring result[9] = {\n\t\t\"0\", \"0\", \"0\",\n\t\t\"0\", \"1\", \"1\",\n\t\t\"0\", \"1\", \"2\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 9 ; j++ ){\n\t\t\tif( s.substr( i , 5 ) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile( cin >> s , s != \".\" ){\n\t\tint ans = 0;\n\t\tfor(char p = '0' ; p <= '2' ; p++ ){\n\t\t\tfor(char q = '0' ; q <= '2' ; q++ ){\n\t\t\t\tfor(char r = '0' ; r <= '2' ; r++ ){\n\t\t\t\t\tstring s_ = s;\n\t\t\t\t\t// 'P', 'Q', 'R' ツづー '1', '2', '3'ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tPQR_change( s_ , p , q , r );\n\t\t\t\t\t// \"--\"(ツ連ツ堕アツつキツづゥ2ツづつづ個マツイツナツス) ツづー \"\"ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tminus_erace( s_ );\n\t\t\t\t\t// \"-0\", \"-1\", \"-2\" ツづー \"2\", \"1\", \"0\" ツづ可置ツつォツ環キツつヲツづゥ\n\t\t\t\t\tminus_calc( s_ );\n\t\t\t\t\t\n\t\t\t\t\t// \"0\", \"1\", \"2\" ツづ個値ツづ可づ按づゥツづ慊づ繰ツづィツ陛板つオツ嘉算ツづ湘ヲツ算ツづーツ計ツ算ツつキツづゥ\n\t\t\t\t\twhile( s_.size() != 1 ){\n\t\t\t\t\t\t// \"(0+0)\", ... , \"(2+2)\" ツづー \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ)\n\t\t\t\t\t\tplus_calc( s_ );\n\t\t\t\t\t\t// \"(0*0)\", ... , \"(2*2)\" ツづー \"0\", ... , \"2\" ツづ可置ツつォツ環キツつヲツづゥ(9ツ津環づィ) \n\t\t\t\t\t\tmult_calc( s_ );\n\t\t\t\t\t}\n\t\t\t\t\tif( s_ == \"2\" ){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nchar* s;\nint p,q,r;\n\nint formula()\n{\n\tif(isdigit(*s) || isupper(*s)){\n\t\tchar c=*s++;\n\t\tif(isdigit(c)) return c-'0';\n\t\tif(c=='P') return p;\n\t\tif(c=='Q') return q;\n\t\tif(c=='R') return r;\n\t}\n\tif(*s=='-'){\n\t\ts++;\n\t\tint v=formula();\n\t\treturn 2-v;\n\t}\n\tif(*s=='('){\n\t\ts++;\n\t\tint a=formula();\n\t\tchar op=*s++;\n\t\tint b=formula();\n\t\ts++;\n\t\tif(op=='*') return min(a,b);\n\t\tif(op=='+') return max(a,b);\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(char s[81];cin>>s,s[0]!='.';){\n\t\tint res=0;\n\t\tfor(p=0;p<3;p++)\n\t\t\tfor(q=0;q<3;q++)\n\t\t\t\tfor(r=0;r<3;r++){\n\t\t\t\t\t::s=s;\n\t\t\t\t\tif(formula()==2)\n\t\t\t\t\t\tres++;\n\t\t\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <functional>\n#include<vector>\n#include<math.h>\n#include<bitset>\n#include<string>\n#include <deque>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include <random>\n#include<type_traits>\n#include<stack>\n#include <sstream> \nusing namespace std;\n#define ll long long int\n#define all(v) begin(v), end(v)\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n//typedef vector<int> V;\n//typedef vector<VV> VVV;\n\ntemplate<typename T>\nvoid remove(std::vector<T>& vector, unsigned int index)\n{\n\tvector.erase(vector.begin() + index);\n}\n\nint sum_estemater(string s, int p, int q, int r) {\n\twhile (s[0] == '('){\n\t\tstring new_s = \"\", if_s = \"\";\n\t\tchar enzan_falg = '0';\n\t\tint num_flag = 0, mina_flag = 0, s_flag = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s[i] == '(') {\n\t\t\t\ts_flag = 1;\n\t\t\t\tnew_s += if_s;\n\t\t\t\tif_s = \"\";\n\t\t\t\tif_s += s[i];\n\t\t\t\tmina_flag = 0;\n\t\t\t\tenzan_falg = '0';\n\t\t\t}\n\t\t\telse if (s[i] == '-') {\n\t\t\t\tmina_flag = 1 - mina_flag;\n\t\t\t\tif_s += s[i];\n\t\t\t}\n\t\t\telse if((s[i]=='P')|| (s[i] == 'Q')|| (s[i] == 'R')|| ((s[i]-'0'<=9)&& (s[i]-'0' >=0 ))){\n\t\t\t\tif_s += s[i];\n\t\t\t\tif (s[i] == 'P')s[i] = p+'0';\n\t\t\t\tif (s[i] == 'Q')s[i] = q + '0';\n\t\t\t\tif (s[i] == 'R')s[i] = r + '0';\n\t\t\t\tif (enzan_falg == '0') {\n\t\t\t\t\tif (mina_flag == 0) {\n\t\t\t\t\t\tnum_flag=s[i]-'0';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum_flag = 2 - (s[i] - '0');\n\t\t\t\t\t\tmina_flag = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (mina_flag != 0) {\n\t\t\t\t\t\ts[i] =(2 - (s[i] - '0'))+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif (enzan_falg == '*') {\n\t\t\t\t\t\tnum_flag = min(s[i]-'0', num_flag);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum_flag = max(s[i] - '0', num_flag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (s[i] == ')') {\n\t\t\t\tif (s_flag == 0) {\n\t\t\t\t\tif_s += s[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts_flag = 0;\n\t\t\t\t\tnew_s += to_string(num_flag);\n\t\t\t\t\tnum_flag = 0;\n\t\t\t\t\tif_s = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif_s += s[i];\n\t\t\t\tenzan_falg = s[i];\n\t\t\t}\n\t\t}\n\t\tnew_s += if_s;\n\t\ts = new_s;\n\t\t//cout << \"s :\" << s <<\" p :\"<<p<<\" q :\"<<q<<\" r :\"<<r<< endl;\n\t}\n\treturn atoi(s.c_str());\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\twhile(s != \".\") {\n\t\tif (s[0] != '(')s = '(' + s + ')';\n\t\tint max1 = 0, sum;\n\t\tfor (int p = 0; p < 3; p++) {\n\t\t\tfor (int q = 0; q < 3; q++) {\n\t\t\t\tfor (int r = 0; r < 3; r++) {\n\t\t\t\t\tsum = sum_estemater(s, p, q, r);\n\t\t\t\t\tif (sum == 2)max1++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max1 << endl;\n\t\tcin >> s;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main() {\n\tstd::cout << \"tsu_ra_i\" << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing i64 = long long;\nconst i64 MOD = 1e9+7;\nconst i64 INF = 1e18+7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nvoid solve(string s){\n    struct Data{\n        Data(int a, int v) : r(a), v(v){}\n        int r, v;\n    };\n    function<Data(int)> f;\n\n    array<int, 3> res{0, 0, 0};\n\n    f = [&](int l){\n        if(s[l] == '0')\n            return Data(l + 1, 0);\n        if(s[l] == '1')\n            return Data(l + 1, 1);\n        if(s[l] == '2')\n            return Data(l + 1, 2);\n        if(s[l] == 'P')\n            return Data(l + 1, res[0]);\n        if(s[l] == 'Q')\n            return Data(l + 1, res[1]);\n        if(s[l] == 'R')\n            return Data(l + 1, res[2]);\n        if(s[l] == '-'){\n            auto a = f(l + 1);\n            return Data(a.r, 2 - a.v);\n        }\n        if(s[l] == '('){\n            auto a = f(l + 1);\n            auto b = f(a.r + 1);\n            int v = 0;\n            if(s[a.r] == '*'){\n                v = min(a.v, b.v);\n            }\n            if(s[a.r] == '+'){\n                v = max(a.v, b.v);\n            }\n            // cout << a.v << \" \" << b.v << \" \" << s.substr(l, b.r + 1 - l) << endl;\n            return Data(b.r + 1, v);\n        }\n    };\n    int ans = 0;\n    for(int i = 0; i < 27; ++i){\n        res[0] = i % 3;\n        res[1] = (i / 3) % 3;\n        res[2] = (i / 9) % 3;\n        ans += (f(0).v == 2);\n    }\n    cout << ans << endl;\n}\n\n\nsigned main(){\n    string s;\n    cin >> s;\n    while(s != \".\"){\n        solve(s);\n        cin >> s;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint p, q, r;\n\nint not_[3] = {2, 1, 0};\nint and_[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint or_[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\nint f(int &i) {\n    int t, x, y;\n    char op;\n    switch (s[i++]) {\n        case '0':\n            return 0;\n        case '1':\n            return 1;\n        case '2':\n            return 2;\n        case 'P':\n            return p;\n        case 'Q':\n            return q;\n        case 'R':\n            return r;\n        case '-':\n            return not_[f(i)];\n        case '(':\n            x = f(i);\n            op = s[i++];\n            y = f(i);\n            i ++;\n            return (op == '*') ? and_[x][y] : or_[x][y];\n    }\n}\n\nint main() {\n    while (cin >> s) {\n        if (s == \".\") break;\n        int cnt = 0;\n        for (p=0; p<3; ++p)\n            for (q=0; q<3; ++q)\n                for (r=0; r<3; ++r) {\n                    int i = 0;\n                    if (f(i) == 2) cnt ++;\n                }\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint pos;\nstring str;\n\nint operate(void);\nint mins(int val);\nint pls(int val1, int val2);\nint multi(int val1, int val2);\n\nint main(void){\n    string in;\n    for(int res; cin >> in, in != \".\"; cout << res << endl){\n        res = 0;\n        rep(P, 3){\n            rep(Q, 3){\n                rep(R, 3){\n                    str = in;\n                    replace(all(str), 'P', (char)(P + '0'));\n                    replace(all(str), 'Q', (char)(Q + '0'));\n                    replace(all(str), 'R', (char)(R + '0'));\n\n                    pos = 0;\n                    if(operate() == 2) res++;\n                }\n            }\n        }\n    }\n\n\treturn 0;\n}\n\nint operate(void){\n    int ret;\n\n    if(str[pos] == '('){\n        pos++;\n        int a = operate();\n   \n        char op = str[pos];\n\n        pos++;\n        if(op == '+'){\n            ret = pls(a, operate());\n        }\n        else ret = multi(a, operate());\n\n        pos++;\n    }\n    else if(str[pos] == '-'){\n        int cnt = 0;\n        while(str[pos] == '-') (++cnt) %= 2, pos++;\n\n        if(cnt) ret = mins(operate());\n        else ret = operate();\n    }\n    else{\n        ret = str[pos] - '0';\n        pos++;\n    }\n\n    return ret;\n}\n\nint mins(int val){\n    int ret;\n\n    if(val == 0) ret = 2;\n    else if(val == 2) ret = 0;\n    else ret = val;\n\n    return ret;\n}\n\nint pls(int val1, int val2){\n    return max(val1, val2);\n}\n\nint multi(int val1, int val2){\n    return min(val1, val2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <functional>\n\nusing namespace std;\n\ntypedef function<int(int[3])> node_t;\n\nstring S;\nsize_t cur;\n\nint andtable[3][3] = { {0,0,0},{0,1,1},{0,1,2} };\nint ortable[3][3] = { {0,1,2},{1,1,2},{2,2,2} };\n\nnode_t parse(){\n  char c = S[cur++];\n  if(isdigit(c))\n    return [=](int[3]){ return c-'0'; };\n  if(isalpha(c))\n    return [=](int a[3]){ return a[c-'P']; };\n\n  node_t left = parse();\n  if(c == '-')\n    return [=](int a[3]){ return 2-left(a);};\n\n  assert(c == '(');\n  char op = S[cur++];\n  node_t right = parse();\n  ++cur;\n\n  if(op == '*'){\n    return [=](int a[3]){\n      return andtable[right(a)][left(a)];\n    };\n  }else{\n    return [=](int a[3]){\n      return ortable[right(a)][left(a)];\n    };\n  }\n}\n\nint solve(){\n  cur = 0;\n  auto tree = parse();\n  int count = 0;\n  for(int p:{0,1,2}){\n    for(int q:{0,1,2}){\n      for(int r:{0,1,2}){\n        int a[] = {p,q,r};\n        if(tree(a)==2) ++ count;\n      }\n    }\n  }\n  return count;\n}\nint main(){\n\n  while(cin>>S&&S[0]!='.')\n    cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-6;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconst int64 mod = 1e9+7;\n\nint32 add(int32 a, int32 b){\n\tif(a == 1 && b == 1) return 1;\n\treturn min((int32)2, a+b);\n}\n\nint32 mul(int32 a, int32 b){\n\tif(a*b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint32 nnot(int32 a){\n\treturn 2-a;\n}\n\nint32 val[3];\n\nint32 eval(string s){\n\tif(s.size() == 1 && '0' <= s[0] && s[0] <= '3') return s[0]-'0';\n\tif(s.size() == 1) return val[s[0]-'P'];\n\tif(s[0] == '-') return nnot(eval(s.substr(1, s.size()-1)));\n\tint32 now = 0;\n\tREP(i, s.size()){\n\t\tif(s[i] == '(') now++;\n\t\tif(s[i] == ')') now--;\n\t\tif(now == 1 && s[i] == '+') return add(eval(s.substr(1, i-1)), eval(s.substr(i+1, s.size()-i-2)));\n\t\tif(now == 1 && s[i] == '*') return mul(eval(s.substr(1, i-1)), eval(s.substr(i+1, s.size()-i-2)));\n\t}\n}\n\nint main(void){\n\tstring s;\n\twhile(cin >> s && s != \".\"){\n\t\tint32 res = 0;\n\t\tREP(i, 3){\n\t\t\tREP(j, 3){\n\t\t\t\tREP(k, 3){\n\t\t\t\t\tval[0] = i; val[1] = j; val[2] = k;\n\t\t\t\t\tif(eval(s) == 2) res++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstring s;\nint p,q,r;\n\nint number(int& pos);\nint term(int& pos);\nint expr(int& pos);\n\nint number(int& pos){\n    if(isdigit(s[pos])){\n        return s[pos++] - '0';\n    }else{\n        if(s[pos] == 'P'){\n            pos++;\n            return p;\n        }else if(s[pos] == 'Q'){\n            pos++;\n            return q;\n        }else{\n            pos++;\n            return r;\n        }\n    }\n}\n\nint term(int& pos){\n    if(isalpha(s[pos]) || isdigit(s[pos])){\n        return number(pos);\n    }else if(s[pos] == '-'){\n        pos++;\n        return 2-term(pos);\n    }else{\n        pos++;\n        int res = expr(pos);\n        pos++;\n        return res;\n    }\n}\n\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '*'){\n        if(s[pos] == '+'){\n            res = max(res,term(++pos));\n        }else{\n            res = min(res,term(++pos));\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> s;\n        if(s == \".\"){\n            break;\n        }\n        int num = 0;\n        rep(i,3){\n            rep(j,3){\n                rep(k,3){\n                    int pos = 0;\n                    p = i,q = j,r = k;\n                    if(expr(pos) == 2){\n                        num++;\n                    }\n                }\n            }\n        }\n        cout << num << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp\n\n \n\tsorce: ICPC Domestic 2008\t\n\n\t構文解析の問題。\n\n\t<formula> ::= 0 | 1 | 2 | P | Q | R |\n              -<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n\n\t下のように書き換え\n\n\t<expr>::=<term1><op><term1>|<term1>\n\t<term1>::='-'<term1>|<term2>\n\t<term2>::='('<expr>')'|0|1|2\n\n\t文字の部分は数字に置き換え、全探索。\n*/\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int _and[3][3] = { \n\t\t\t\t{ 0, 0, 0 },\n\t\t\t\t{ 0, 1, 1 },\n\t\t\t\t{ 0, 1, 2 } };\nconst int _or[3][3] = {\n\t\t\t\t{ 0, 1, 2 },\n\t\t\t\t{ 0, 1, 2 },\n\t\t\t\t{ 2, 2, 2 } };\n\nconst int _not[3] = { 2, 1, 0 };\nstring s;\nint idx;\n\nint term1 (void );\nint term2 (void );\nint expr (void );\n\nint term1 (void ){\n\tif (s[idx] == '-' ){\n\t\tidx++;\n\t\treturn _not[term1()];\n\t}else return term2();\n}\n\nint term2 (void ){\n\tint res = 0;\n\tif (s[idx] == '(' ){\n\t\tidx++;\n\t\tres = expr ();\n\t\tidx++;\n\t}else{\n\t\treturn (s[idx] - '0' );\n\t} // end if\n\n\treturn res;\n}\n\nint expr (void ){\n\tint a = term1 ();\n\twhile (idx < s.size() && s[idx] != ')' ){\n\t\tchar op = s[idx++];\n\t\tint b = term1 ();\n\t\tswitch (op ){\n\t\t\tcase '*': a = _and[a][b]; break;\n\t\t\tcase '+': a = _or[a][b]; break;\n\t\t} // end switch\n\t} // end if\n\n\treturn a;\n}\n\nint parse (void ){\n\t\n\tidx = 0;\n\tint res = expr ();\n\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\n\tstring str = \"\";\n\twhile (cin >> str, str != \".\" ){\n\t\tint res = 0;\n\t\tint n = str.length();\n\t\trep (p, 3 ){\n\t\t\tstring s1 = str;\n\t\t\trep (i, n ) if (s1[i] == 'P' ) s1[i] = (char)('0'+p);\n\t\t\trep (q, 3 ){\n\t\t\t\tstring t1 = s1;\n\t\t\t\trep (i, n ) if (t1[i] == 'Q' ) t1[i] = (char)('0'+q);\n\t\t\t\trep (r, 3 ){\n\t\t\t\t\ts = t1;\n\t\t\t\t\trep (i, n ) if (s[i] == 'R' ) s[i] = (char )('0'+r);\n\t\t\t\t\tint ans = parse ();\n//\t\t\t\t\tcerr << s << '=' << ans << endl;\n\t\t\t\t\tif (ans == 2 ) res++;\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tcout << res << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint pqr[3];\n\nint getOperator(int l, int r){\n    int c = 0;\n    for(int i=l;i<r;i++){\n        if(c == 0 && (S[i] == '*' || S[i] == '+')){\n            return i;\n        }else if(S[i] == '('){\n            c++;\n        }else if(S[i] == ')'){\n            c--;\n        }\n    }\n    assert(false);\n    return -1;\n}\n\nint parseFomula(int l, int r){\n    int ret = -1;\n    if(S[l] == '('){\n        assert(S[r-1] == ')');\n        int opPos = getOperator(l+1, r-1);\n        int lv = parseFomula(l+1, opPos), rv = parseFomula(opPos+1, r-1);\n        if(S[opPos] == '+'){\n            ret = max(lv, rv);\n        }else{\n            ret = min(lv, rv);\n        }\n    }else if(S[l] == '-'){\n        ret = 2 - parseFomula(l+1, r);\n    }else if('P' <= S[l] && S[l] <= 'R'){\n        ret = pqr[S[l]-'P'];\n    }else if('0' <= S[l] && S[l] <= '2'){\n        ret = S[l] - '0';\n    }\n    assert(ret != -1);\n    return ret;\n}\n\nint main(){\n    while(1){\n        cin >> S;\n        if(S == \".\") break;\n\n        int ans = 0;\n        for(int i=0;i<=2;i++){\n            for(int j=0;j<=2;j++){\n                for(int k=0;k<=2;k++){\n                    pqr[0] = i;\n                    pqr[1] = j;\n                    pqr[2] = k;\n                    if(parseFomula(0, S.size()) == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nstring ts;\nstring s;\nint idx;\n\nint NOT[] = {2,1,0};\nint AND[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint OR[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nint getDigit(){\n  int cnt = 0;\n  while(s[idx] == '-'){\n    cnt++;\n    idx++;\n  }\n  int digit = s[idx] - '0';\n  idx++;\n\n  if(cnt % 2 == 1){\n    return NOT[digit];\n  }\n  return digit;\n}\n\nint solve(){\n  int res = 0;\n\n  //cout<<\":\"<<idx<<endl;\n\n  int left = -1;\n  int right = -1;\n\n  if(s[idx] == '('){\n    idx++;\n    left = solve();\n  }\n  else{\n    left = getDigit();\n  }\n\n  if(idx < s.length()){\n    if(s[idx] == '*'){\n      idx++;\n      if(s[idx] == '('){\n        idx++;\n        right = solve();\n      }\n      else{\n        right = getDigit();\n      }\n\n      res = AND[left][right];\n    }\n    else if(s[idx] == '+'){\n      idx++;\n      if(s[idx] == '('){\n        idx++;\n        right = solve();\n      }\n      else{\n        right = getDigit();\n      }\n\n      res = OR[left][right];\n    }\n  }\n  idx++;\n\n  if(right == -1){\n    return left;\n  }\n  else{\n    return res;\n  }\n}\n\nvoid replace(int R,int P,int Q){\n  s = \"\";\n  rep(i,ts.size()){\n    if(ts[i] == 'R') s += (char)('0' + R);\n    else if(ts[i] == 'P') s += (char)('0' + P);\n    else if(ts[i] == 'Q') s += (char)('0' + Q);\n    else{\n      s += ts[i];\n    }\n  }\n}\n\nint main(){\n  while(cin>>ts,ts!=\".\"){\n    int ans = 0;\n    rep(R,3) rep(P,3) rep(Q,3){\n      replace(R,P,Q);\n      idx = 0;\n      if(solve() == 2) ans++;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nint eval(const string& s, int& pos){\n  if(s[pos]=='0'){\n    ++pos;\n    return 0;\n  }\n  if(s[pos]=='1'){\n    ++pos;\n    return 1;\n  }\n  if(s[pos]=='2'){\n    ++pos;\n    return 2;\n  }\n  if(s[pos]=='-'){\n    ++pos;\n    int v = eval(s,pos);\n    return 2-v;\n  }\n  if(s[pos]=='('){\n    ++pos;\n    int a = eval(s,pos);\n    char c = s[pos++];\n    int b = eval(s,pos);\n    ++pos;\n    if(c == '*'){\n      return (a*b+1)/2;\n    }\n    if(c == '+'){\n      return max(a,b);\n    }\n    abort();\n  }\n}\nint main(){\n  string input;\n  while(cin>>input){\n    int ans = 0;\n    if(input==\".\") break;\n    REP(p,3)REP(q,3)REP(r,3){\n      int s[3];\n      s[0] = p;\n      s[1] = q;\n      s[2] = r;\n      string calcstr = input;\n      REP(i,calcstr.size()){\n        if('P'<=calcstr[i]&&calcstr[i]<='R'){\n          calcstr[i] = s[calcstr[i]-'P'] + '0';\n        }\n      }\n      int pos = 0;\n      if(eval(calcstr,pos)==2){\n        ans++;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Parser \n{\n  string str, val;\n  Parser(string str, string val): str(str), val(val) {;};\n};\n\nstring minus_(string x)\n{\n  if (x == \"0\") return \"2\";\n  if (x == \"1\") return \"1\";\n  if (x == \"2\") return \"0\";\n}\n\nstring mul(string x, string y)\n{\n  if (x == \"0\" || y == \"0\") return \"0\";\n  if (x == \"1\" || y == \"1\") return \"1\";\n  return \"2\";\n}\n\nstring add(string x, string y)\n{\n  if (x == \"2\" || y == \"2\") return \"2\";\n  if (x == \"1\" || y == \"1\") return \"1\";\n  return \"0\";\n}\n\nParser formula(string str)\n{\n  if (str.size() == 0) {\n    return Parser(\"\", \"\");\n  }\n\n  string l = str.substr(0, 1);\n  string r = str.substr(1);\n  // -<formula>\n  if (l == \"-\") {\n    Parser ps = formula(r);\n    return Parser(ps.str, minus_(ps.val));\n  } else if (l == \"(\"){\n\n    Parser lhs = formula(r);\n    string op = lhs.str.substr(0, 1);\n    Parser rhs = formula(lhs.str.substr(1));\n\n    if (op == \"+\") {\n      // (<formula>+<formula>)\n      return Parser(rhs.str.substr(1), add(lhs.val, rhs.val));\n    } else {\n      // (<formula>*<formula>)\n      return Parser(rhs.str.substr(1), mul(lhs.val, rhs.val));\n    }\n  }\n\n  // 0 | 1 | 2\n  return Parser(str.substr(1), str.substr(0, 1));\n}\n\n\nint main()\n{\n  string str;\n  while (cin >> str && (str != \".\")) {\n    int res = 0;\n    for (int i = 0; i < 3; i++) { // P\n      for (int j = 0; j < 3; j++) { // Q\n        for (int k = 0; k < 3; k++) { // R\n          char P = '0' + i, Q = '0' + j, R = '0' + k;\n          string expr = str;\n          for (int s = 0; s < expr.size(); s++) {\n            if (expr[s] == 'P') expr[s] = P;\n            if (expr[s] == 'Q') expr[s] = Q;\n            if (expr[s] == 'R') expr[s] = R;\n          }\n\n          Parser ps = formula(expr);\n          if (ps.val == \"2\") res++;\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/04 14:52:47\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint Not(const int i) { return 2 - i; }\nint Plus(const int i, const int j) { return max(i, j); }\nint Prod(const int i, const int j) { return min(i, j); }\nint v[3] = {0, 0, 0};\nstring S;\nint pos;\nint number()\n{\n    if (isdigit(S[pos])) {\n        return pos++, S[pos - 1] - '0';\n    } else {\n        return pos++, v[S[pos - 1] - 'P'];\n    }\n}\nint formula()\n{\n    if (isalpha(S[pos]) or isdigit(S[pos])) { return number(); }\n    if (S[pos] == '-') {\n        pos++;\n        const int sub = formula();\n        return Not(sub);\n    } else {\n        pos++;\n        const int a = formula();\n        const char op = S[pos];\n        pos++;\n        const int b = formula();\n        pos++;\n        return (op == '*' ? Prod(a, b) : Plus(a, b));\n    }\n}\n\nint main()\n{\n    for (;;) {\n        cin >> S;\n        if (S == \".\") { break; }\n        int ans = 0;\n        for (v[0] = 0; v[0] < 3; v[0]++) {\n            for (v[1] = 0; v[1] < 3; v[1]++) {\n                for (v[2] = 0; v[2] < 3; v[2]++) {\n                    pos = 0;\n                    const int c = formula();\n                    if (c == 2) { ans++; }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nint P, Q, R;\nconst char *p;\n \nint formula() {\n   \n  p++;\n \n  switch( *p ) {\n  case '-': return 2 - formula();\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  case '0': return 0;\n  case '1': return 1;\n  case '2': return 2;\n     \n  case '(':\n    int form1 = formula();\n    int form2;\n    p++;\n    switch( *p ) {\n    case '*':\n      form2 = formula();\n      p ++;\n      return min( form1, form2 );\n    case '+':\n      form2 = formula();\n      p++;\n      return max( form1, form2 );\n    }\n  }\n   \n  return 0;\n}\n \nint main() {\n  string str;\n   \n  while(getline(cin, str)) {\n    int cnt = 0;\n    if( str == \".\" ) break;\n    for(int i=0; i<3; i++) {\n      for(int j=0; j<3; j++) {\n        for(int k=0; k<3; k++) {\n          P = i, Q = j, R = k;\n          p = str.c_str()-1;\n          if( formula() == 2 ) cnt ++;\n        }\n      }\n    }\n     \n    cout << cnt << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nstring s;\n\nstring func(string s) {\n    stack<char> st;\n    string t = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i]) || isdigit(s[i])) {\n            t += s[i];\n            while (st.size() && st.top() == '-') t += st.top(), st.pop();\n        }\n        else if (s[i] != ')') st.push(s[i]);\n        else {\n            while (st.top() != '(') t += st.top(), st.pop();\n            st.pop();\n        }\n    }\n    return t;\n}\n\nstring func2(string s, int p, int q, int r) {\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'P') s[i] = '0'+p;\n        if (s[i] == 'Q') s[i] = '0'+q;\n        if (s[i] == 'R') s[i] = '0'+r;\n    }\n    return s;\n}\n\nint solve(string s) {\n    stack<int> st;\n    for (int i = 0; i < s.size(); i++) {\n        if (isdigit(s[i])) st.push(s[i]-'0');\n        if (s[i] == '-') {\n            int a = st.top(); st.pop();\n            a = 2 - a;\n            st.push(a);\n        }\n        if (s[i] == '+') {\n            int a = st.top(); st.pop();\n            int b = st.top(); st.pop();\n            a = max(a, b);\n            st.push(a);\n        }\n        if (s[i] == '*') {\n            int a = st.top(); st.pop();\n            int b = st.top(); st.pop();\n            a = min(a, b);\n            st.push(a);\n        }\n    }\n    if (st.top() == 2) return 1;\n    else return 0;\n}\n\nint main(void){\n    while (cin>>s && s != \".\") {\n        s = func(s);\n        int ans = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string t = s;\n                    t = func2(t, i, j, k);\n                    ans += solve(t);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n\nusing namespace std;\n\nint Minus(int a)\n{\n\treturn 2 - a;\n}\n\nint Mul(int a,int b)\n{\n\tif(a == 0 || b == 0)\n\t\treturn 0;\n\tif(a == 1 || b == 1)\n\t\treturn 1;\n\treturn 2;\n}\n\nint Add(int a,int b)\n{\n\tif(a == 2 || b == 2)\n\t\treturn 2;\n\tif(a == 1 || b == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nint p,q,r;\n\nint GetNum(char c)\n{\n\tif(c == 'P') return p;\n\telse if(c == 'Q') return q;\n\telse return r;\n}\n\nint calc(vector<char>& num);\n\nint GetArg(vector<char>& num){\n\tchar c = num.back(); num.pop_back();\n\tif(c == '-' || c == '+' || c == '*'){\n\t\tnum.push_back(c);\n\t\treturn calc(num);\n\t} else if(c == 'P' || c == 'Q' || c == 'R')\n\t\treturn GetNum(c);\n\telse return c - '0';\n}\n\nint calc(vector<char>& num)\n{\n\tchar c = num.back(); num.pop_back();\n\tswitch(c){\n\t\tcase '-':\n\t\t\treturn Minus(GetArg(num));\n\t\tcase '*':\n\t\t\treturn Mul(GetArg(num),GetArg(num));\n\t\tcase '+':\n\t\t\treturn Add(GetArg(num),GetArg(num));\n\t\tdefault:\n\t\t\tnum.push_back(c);\n\t\t\treturn GetArg(num);\n\t}\n}\n\nvoid solve(string& str)\n{\n\tvector<char>ope,num; //ZqAlpX^bN\n\tfor(unsigned int i = 0; i < str.size(); i++){\n\t\tchar c = str[i];\n\t\tswitch(c){\n\t\t\tcase '(':\n\t\t\t\tope.push_back(c);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(ope.back() != '('){\n\t\t\t\t\tnum.push_back(ope.back()); ope.pop_back();\n\t\t\t\t}\n\t\t\t\tope.pop_back(); //')'àí\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tope.push_back(c);\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\tcase '+':\n\t\t\t\twhile(!ope.empty() && ope.back() != '('){\n\t\t\t\t\tnum.push_back(ope.back()); ope.pop_back();\n\t\t\t\t}\n\t\t\t\tope.push_back(c);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnum.push_back(c);\n\t\t}\n\t}\n\n\twhile(!ope.empty()){\n\t\tnum.push_back(ope.back()); ope.pop_back();\n\t}\n\t\n\tint count = 0;\n\tfor(p = 0; p < 3; p++)\n\t\tfor(q = 0; q < 3; q++)\n\t\t\tfor(r = 0; r < 3; r++){\n\t\t\t\tvector<char> tmp(num.begin(),num.end()); //Rs[\n\t\t\t\tif(calc(tmp) == 2)\n\t\t\t\t\tcount++;\n\t\t\t}\n\n\tcout << count << endl;\n}\n\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str,str[0] != '.'){\n\t\tsolve(str);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint rec(int& i,const string& s){\n    int ret = 0;\n    if(s[i] >= '0' && s[i] <= '3'){\n        ret = s[i] - '0';\n        i++;\n    }else if(s[i] == '-'){\n        i++;\n        int tmp = rec(i,s);\n        if(tmp == 0) ret = 2;\n        if(tmp == 1) ret = 1;\n        if(tmp == 2) ret = 0;\n    }else if(s[i] == '('){\n        i++;\n        int l = rec(i,s);\n        char c = s[i];\n        i++;\n        int r = rec(i,s);\n        i++;\n        if(c == '+') ret = max(l,r);\n        if(c == '*') ret = min(l,r);\n    }\n    return ret;\n}\nint solve(const string& s){\n    int res = 0;\n    string tmp;\n    for(int P = 0; P < 3; P++){\n        for(int Q = 0; Q < 3; Q++){\n            for(int R = 0; R < 3; R++){\n                tmp = s;\n                char p = '0'+P;\n                char q = '0'+Q;\n                char r = '0'+R;\n                replace(tmp.begin(),tmp.end(),'P',p);\n                replace(tmp.begin(),tmp.end(),'Q',q);\n                replace(tmp.begin(),tmp.end(),'R',r);\n                int i = 0;\n                if(rec(i,tmp) == 2) res++;\n            }\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    string s;\n    while(cin >> s){\n        if(s == \".\") break;\n        cout << solve(s) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint parse(string &T, int &pos){\n  if (T[pos] == '0'){\n    pos++;\n    return 0;\n  } else if (T[pos] == '1'){\n    pos++;\n    return 1;\n  } else if (T[pos] == '2'){\n    pos++;\n    return 2;\n  } else if (T[pos] == '-'){\n    pos++;\n    int A = parse(T, pos);\n    return 2 - A;\n  } else {\n    pos++;\n    int A = parse(T, pos);\n    char c = T[pos];\n    pos++;\n    int B = parse(T, pos);\n    pos++;\n    if (c == '*'){\n      return min(A, B);\n    }\n    if (c == '+'){\n      return max(A, B);\n    }\n  }\n}\nint main(){\n  while (1){\n    string S;\n    cin >> S;\n    if (S == \".\"){\n      break;\n    }\n    int N = S.size();\n    int ans = 0;\n    for (int i = 0; i < 3; i++){\n      for (int j = 0; j < 3; j++){\n        for (int k = 0; k < 3; k++){\n          string T = S;\n          for (int l = 0; l < N; l++){\n            if (T[l] == 'P'){\n              T[l] = '0' + i;\n            }\n            if (T[l] == 'Q'){\n              T[l] = '0' + j;\n            }\n            if (T[l] == 'R'){\n              T[l] = '0'+ k;\n            }\n          }\n          int pos = 0;\n          if (parse(T, pos) == 2){\n            ans++;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tif (T[pos] == '0') { pos++; return 0; }\n\tif (T[pos] == '1') { pos++; return 1; }\n\tif (T[pos] == '2') { pos++; return 2; }\n\tif (T[pos] == '-') { pos++; return 2 - solve(); }\n\tif (T[pos] == '(') {\n\t\tpos++; int a = solve();\n\t\tpos++; int b = solve();\n\t\tif (T[pos] == '+') return max(a, b);\n\t\tif (T[pos] == '*') return min(a, b);\n\t}\n\treturn 0;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tint product[3][3]{\n\t\t{0, 0, 0},\n\t\t{0, 1, 1},\n\t\t{0, 1, 2}\n\t};\n\tint sum[3][3]{\n\t\t{0, 1, 2},\n\t\t{1, 1, 2},\n\t\t{2, 2, 2}\n\t};\n\tint denial[3]{2, 1, 0};\n\n\tstd::string formula;\n\tint variant[3]{};\n\tint f_i{};\n\n\tint calcVal()\n\t{\n\t\tif (formula[f_i] == '(')\n\t\t\treturn interpretBinaryOperation();\n\t\telse if (formula[f_i] == '-')\n\t\t{\n\t\t\tf_i++;\n\t\t\treturn denial[calcVal()];\n\t\t}\n\t\telse if ('P' <= formula[f_i] && formula[f_i] <= 'R')\n\t\t{\n\t\t\tf_i++;\n\t\t\treturn variant[formula[f_i - 1] - 'P'];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf_i++;\n\t\t\treturn formula[f_i - 1] - '0';\n\t\t}\n\t}\n\n\tint interpretBinaryOperation()\n\t{\n\t\tf_i++;\n\t\tint left{calcVal()};\n\t\tint ope{};\n\t\tif (formula[f_i] == '*') ope = 1;\n\t\tf_i++;\n\t\tint right{calcVal()};\n\t\tf_i++;\n\n\t\tif (ope) return product[left][right];\n\t\telse return sum[left][right];\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tstd::cin >> formula;\n\t\tif (formula[0] == '.')\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint count{};\n\t\tfor (variant[0] = 0; variant[0] < 3; variant[0]++)\n\t\t\tfor (variant[1] = 0; variant[1] < 3; variant[1]++)\n\t\t\t\tfor (variant[2] = 0; variant[2] < 3; variant[2]++)\n\t\t\t\t{\n\t\t\t\t\tf_i = 0;\n\t\t\t\t\tif (calcVal() == 2)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\tprintf(\"%d\\n\", count);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nint parse(string x, int &i)\n{\n\tswitch (x[i])\n\t{\n\tcase '0': i++; return 0;\n\tcase '1': i++; return 1;\n\tcase '2': i++; return 2;\n\tcase '-': i++; return (2 - parse(x, i));\n\t}\n\n\ti++;\n\tint l = parse(x, i);\n\tint flag = -1;\n\tif (x[i] == '*')\n\t\tflag = 0;\n\telse\n\t\tflag = 1;\n\ti++;\n\tint r = parse(x, i);\n\ti++;\n\n\tif (flag == 0)\n\t{\n\t\tif (l == 2 && r == 2) return 2;\n\t\tif (l == 0 || r == 0) return 0;\n\t\treturn 1;\n\t}\n\n\tif (l == 0 && r == 0) return 0;\n\tif (l == 2 || r == 2) return 2;\n\treturn 1;\n}\n\nstring replace(string src, string from, string to)\n{\n\tstring::size_type Pos(src.find(from));\n\twhile (Pos != string::npos)\n\t{\n\t\tsrc.replace(Pos, from.length(), to);\n\t\tPos = src.find(from, Pos + to.length());\n\t}\n\treturn src;\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (s[0] == '.') return 0;\n\n\t\tint ans = 0;\n\t\trep(p, 0, 3) rep(q, 0, 3) rep(r, 0, 3)\n\t\t{\n\t\t\tstring ss = s;\n\t\t\tss = replace(ss, \"P\", to_string(p));\n\t\t\tss = replace(ss, \"Q\", to_string(q));\n\t\t\tss = replace(ss, \"R\", to_string(r));\n\n\t\t\tint i = 0;\n\t\t\tif (parse(ss, i) == 2) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(')exit(1);\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r-0 == 0)res = '0';\n\t\telse res = 1;\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n\n//構文を実際に計算する\nbool play(string s) {\n\t//cout << s << endl;\n\n\tstack<char> info;\n\tfor (char c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(string formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\t//cout << \"pqr:: \" << p << q << r << endl;\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<algorithm>\n\nusing namespace std;\n\n\nbool check(string str,int P,int Q,int R){\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='P')str[i]=P+'0';\n\t\tif(str[i]=='Q')str[i]=Q+'0';\n\t\tif(str[i]=='R')str[i]=R+'0';\n\t}\n\tstack<int> sta[500];\n\tint rank=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='-')sta[rank].push(-1);\n\t\tif(str[i]=='+')sta[rank].push(-2);\n\t\tif(str[i]=='*')sta[rank].push(-3);\n\t\tif(str[i]=='(')rank++;\n\t\tif(str[i]==')'){\n\t\t\tint c=sta[rank].top(),flag2=0;\n\t\t\tif(c>2 || c<0)while(1);\n\t\t\tsta[rank].pop();\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\trank--;\n\t\t\tsta[rank].push(c);\n\t\t}\n\t\tif(str[i]>='0' && str[i]<='2'){\n\t\t\tint c=str[i]-'0',flag2=0;\n\t\t\twhile(sta[rank].size()){\n\t\t\t\tint qd=sta[rank].top();\n\t\t\t\tsta[rank].pop();\n\t\t\t\tif(qd==-1)c=2-c;\n\t\t\t\tif(qd==-2)flag2=1;\n\t\t\t\tif(qd==-3)flag2=2;\n\t\t\t\tif(qd>=0){\n\t\t\t\t\tif(flag2==1)c=max(c,qd);\n\t\t\t\t\tif(flag2==2)c=min(c,qd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsta[rank].push(c);\n\t\t}\n\t}\n\tif(sta[0].top()==2)return true;\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\".\")break;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(check(str,i,j,k))cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint p, q, r;\n\nint formula(string str){\n  if(str == \"0\") return 0;\n  if(str == \"1\") return 1;\n  if(str == \"2\") return 2;\n  if(str == \"P\") return p;\n  if(str == \"Q\") return q;\n  if(str == \"R\") return r;\n  if(str[0] == '-') return 2 - formula(str.substr(1));\n  int size = str.size();\n  int cnt = 0;\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '(') cnt++;\n    if(str[i] == ')') cnt--;\n    if(str[i] == '*' && cnt == 1) return min(formula(str.substr(1, i-1)), formula(str.substr(i+1, size-i-2)));\n    if(str[i] == '+' && cnt == 1) return max(formula(str.substr(1, i-1)), formula(str.substr(i+1, size-i-2)));\n  }\n}\n\nint solve(string str){\n  int res = 0;\n  for(p=0;p<=2;p++){\n    for(q=0;q<=2;q++){\n      for(r=0;r<=2;r++){\n        if(formula(str) == 2) res++;\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  string in;\n  while(cin >> in){\n    if(in == \".\") break;\n    cout << solve(in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint o=0;\nvoid rec(string str){\n  //cout << str << endl;\n  string next,buf;\n  if(str[0]!='('){\n    //cout << str << endl;\n    if(str[0]=='2') o++;\n    return;\n  }\n  for(int i=1;i<str.size();i++){\n    if('0'<=str[i]&&str[i]<='2') {\n      if(str[i-1]=='-') {\n\tif(str[i]=='0')  str[i]='2';\n\telse if(str[i]=='2')  str[i]='0';\n\tstr[i-1]=' ';\n      }else if(str[i-1]=='*') {\n\tif(str[i-3]=='('){\n\tif(str[i]=='0'||str[i-2]=='0') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='0';\n\t  str[i+1]=' ';\n\t}else if(str[i]=='2'&&str[i-2]=='2') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='2';\n\t  str[i+1]=' ';\n\t}else if('0'<=str[i-2]&&str[i-2]<='2'){\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='1';\n\t  str[i+1]=' ';\n\t}\n\t}\n      }else if(str[i-1]=='+') {\n\tif(str[i-3]=='('){\n\tif(str[i]=='2'||str[i-2]=='2') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='2';\n\t  str[i+1]=' ';\n\t}else if(str[i]=='0'&&str[i-2]=='0') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='0';\n\t  str[i+1]=' ';\n\t}else if('0'<=str[i-2]&&str[i-2]<='2'){\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='1';\n\t  str[i+1]=' ';\n\t}\n\t}\n      }\n    }\n  }\n  for(int i=0;i<str.size();i++){\n    if(str[i]!=' ') next+=str[i];\n  }\n  rec(next);\n}\nint main(){\n  string str,buf;\n  cin >> str;\n  while(str!=\".\"){\n    int p[]={0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2};\n    int q[]={0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2};\n    int r[]={0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2};\n    o=0;\n    for(int i=0;i<27;i++){\n      buf=str;\n      for(int j=0;j<str.size();j++){\n\tif(buf[j]=='P') buf[j]=p[i]+'0';\n\tif(buf[j]=='Q') buf[j]=q[i]+'0';\n\tif(buf[j]=='R') buf[j]=r[i]+'0';\n      }\n      rec(buf);\n    }\n    cout << o << endl;\n    cin >> str;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint check(char op, int x, int y) {\n    switch (op) {\n    case '*':\n        if (x == 2 && y == 2) return 2;\n        return x & y;\n    case '+':\n        if (x == 2 || y == 2) return 2;\n        return x | y;\n    }\n    assert(0);\n}\n\nint formula(string& form, int& idx) {\n    switch (form[idx]) {\n    case '0':\n    case '1':\n    case '2':\n        ++idx;\n        return form[idx-1] - '0';\n    case '-':\n        ++idx;\n        return 2 - formula(form, idx);\n    case '(':\n        ++idx;\n        int x = formula(form, idx);\n        char op = form[idx];\n        ++idx;\n        int y = formula(form, idx);\n        ++idx;\n        return check(op, x, y);\n    }\n    assert(0);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \".\") {\n            break;\n        }\n\n        int n = 0;\n        REP(p, 3) REP(q, 3) REP(r, 3) {\n            string tmp = line;\n            REP(i, tmp.length()) {\n                switch (tmp[i]) {\n                case 'P':\n                    tmp[i] = p + '0';\n                    break;\n                case 'Q':\n                    tmp[i] = q + '0';\n                    break;\n                case 'R':\n                    tmp[i] = r + '0';\n                    break;\n                }\n            }\n            int idx = 0;\n            if (formula(tmp, idx) == 2) {\n                n++;\n            }\n        }\n        cout << n << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring input;\nint p, q, r;\n\nint i;\nint fomula();\nint inpar();\n\nint add(int left, int right) {\n\treturn max(left, right);\n}\n\nint mul(int left, int right) {\n\treturn min(left, right);\n}\n\nint no(int value) {\n\treturn 2 - value;\n}\n\nint fomula() {\n\tswitch(input[i++]) {\t\n\tcase 'P':\n\t\treturn p;\n\tcase 'Q':\n\t\treturn q;\n\tcase 'R':\n\t\treturn r;\n\tcase '0':\n\t\treturn 0;\n\tcase '1':\n\t\treturn 1;\n\tcase '2':\n\t\treturn 2;\n\tcase '-':\n\t\treturn no(fomula());\n\t}\n\n\treturn inpar();\n}\n\nint inpar() {\n\tint left = fomula();\n\tchar ope = input[i++];\n\tint right = fomula();\n\t++i;\n\n\tswitch(ope) {\n\tcase '+':\n\t\treturn add(left, right);\n\tcase '*':\n\t\treturn mul(left, right);\n\t}\t\n}\n\nint main() {\n\twhile(cin >> input, input[0] != '.') {\n\t\tint count = 0;\n\t\tfor(p=0; p<3; p++)\n\t\t\tfor(q=0; q<3; q++)\n\t\t\t\tfor(r=0; r<3; r++)\n\t\t\t\t\tif(i=0, fomula() == 2)\n\t\t\t\t\t\tcount++;\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint val[3];\n\nstring line;\nint pos;\nchar get() { return pos<line.size()?line[pos++]:'$'; }\nvoid unget() { pos--; }\n\nint bnot(int x) { return 2-x; }\nint band(int x, int y) { return min(x, y); }\nint bor(int x, int y) { return max(x, y); }\n\nint formula()\n{\n\tchar c = get();\n\tswitch (c) {\n\tcase '0': case '1': case '2':\n\t\treturn c-'0';\n\tcase 'P': return val[0];\n\tcase 'Q': return val[1];\n\tcase 'R': return val[2];\n\tcase '-': return bnot(formula());\n\tcase '(': {\n\t\t\t\t  int a = formula();\n\t\t\t\t  char op = get();\n\t\t\t\t  int b = formula();\n\t\t\t\t  int ans = op=='*'?band(a, b):bor(a, b);\n\t\t\t\t  get();\n\t\t\t\t  return ans;\n\t\t\t  }\n\t}\n}\n\nint main()\n{\n\tfor (;;) {\n\t\tcin >> line;\n\t\tif (line[0] == '.') break;\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 3*3*3; i++) {\n\t\t\tpos = 0;\n\t\t\tfor (int j = 0, t = i; j < 3; j++, t /= 3)\n\t\t\t\tval[j] = t%3;\n\t\t\tif (formula() == 2)\n\t\t\t\tcnt++;\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCà\\I2008 C. jyjfö\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint pos;\nstring t;\n\nint calc(){\n\tchar c = t[pos++];\n\tif(isdigit(c)) return c - '0';\n\tif(c == '-')   return 2 - calc();\n\tint a = calc();\n\tchar op = t[pos++];\n\tint b = calc();\n\tpos++;\n\treturn op == '+' ? max(a,b) : min(a,b);\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tfor(int P=0;P<3;P++){\n\t\t\tfor(int Q=0;Q<3;Q++){\n\t\t\t\tfor(int R=0;R<3;R++){\n\t\t\t\t\tt = \"\";\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tfor(int i=0;i<s.size();i++){\n\t\t\t\t\t\tif(s[i]=='P') t += P + '0';\n\t\t\t\t\t\telse if(s[i]=='Q') t += Q + '0';\n\t\t\t\t\t\telse if(s[i]=='R') t += R + '0';\n\t\t\t\t\t\telse t += s[i];\n\t\t\t\t\t}\n\t\t\t\t\tans += calc() == 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\n#ifndef HELLO_HPP_\n#define HELLO_HPP_\n\n// This file was automatically generated by Caper.\n// (http://jonigata.github.io/caper/caper.html)\n\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n\nnamespace calc {\n\nenum Token {\n    token_eof,\n    token_Add,\n    token_Cons,\n    token_LBranket,\n    token_Mul,\n    token_Not,\n    token_RBranket,\n    token_Var,\n};\n\ninline const char* token_label(Token t) {\n    static const char* labels[] = {\n        \"token_eof\",\n        \"token_Add\",\n        \"token_Cons\",\n        \"token_LBranket\",\n        \"token_Mul\",\n        \"token_Not\",\n        \"token_RBranket\",\n        \"token_Var\",\n    };\n    return labels[t];\n}\n\ntemplate <class T, unsigned int StackSize>\nclass Stack {\npublic:\n    Stack() { gap_ = 0; }\n\n    void rollback_tmp() {\n        gap_ = stack_.size();\n        tmp_.clear();\n    }\n\n    void commit_tmp() {\n        // may throw\n        stack_.reserve(gap_ + tmp_.size());\n       \n        // expect not to throw\n        stack_.erase(stack_.begin()+ gap_, stack_.end());\n        stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());\n        tmp_.clear();\n    }\n    bool push(const T& f) {\n        if (StackSize != 0 &&\n            int(StackSize) <= int(stack_.size() + tmp_.size())) {\n            return false;\n        }\n        tmp_.push_back(f);\n        return true;\n    }\n       \n    void pop(size_t n) {\n        if (tmp_.size() < n) {\n            n -= tmp_.size();\n            tmp_.clear();\n            gap_ -= n;\n        } else {\n            tmp_.erase(tmp_.end() - n, tmp_.end());\n        }\n    }\n\n    T& top() {\n        assert(0 < depth());\n        if (!tmp_.empty()) {\n            return tmp_.back();\n        } else {\n            return stack_[gap_ - 1];\n        }\n    }\n       \n    const T& get_arg(size_t base, size_t index) {\n        size_t n = tmp_.size();\n        if (base - index <= n) {\n            return tmp_[n - (base - index)];\n        } else {\n            return stack_[gap_ - (base - n) + index];\n        }\n    }\n       \n    void clear() {\n        stack_.clear();\n        tmp_.clear();\n        gap_ = 0; \n    }\n       \n    bool empty() const {\n        if (!tmp_.empty()) {\n            return false;\n        } else {\n            return gap_ == 0;\n        }\n    }\n       \n    size_t depth() const {\n        return gap_ + tmp_.size();\n    }\n       \n    T& nth(size_t index) {\n        if (gap_ <= index) {\n            return tmp_[index - gap_];\n        } else {\n            return stack_[index];\n        }\n    }\n\n    void swap_top_and_second() {\n        int d = depth();\n        assert(2 <= d);\n        T x = nth(d - 1);\n        nth(d - 1) = nth(d - 2);\n        nth(d - 2) = x;\n    }\n\nprivate:\n    std::vector<T> stack_;\n    std::vector<T> tmp_;\n    size_t gap_;\n       \n};\n\ntemplate <class _Value, class _SemanticAction,\n          unsigned int _StackSize = 0>\nclass Parser {\npublic:\n    typedef Token token_type;\n    typedef _Value value_type;\n\n    enum Nonterminal {\n        Nonterminal_Expr,\n    };\n\npublic:\n    Parser(_SemanticAction& sa) : sa_(sa) { reset(); }\n\n    void reset() {\n        error_ = false;\n        accepted_ = false;\n        clear_stack();\n        rollback_tmp_stack();\n        if (push_stack(0, value_type())) {\n            commit_tmp_stack();\n        } else {\n            sa_.stack_overflow();\n            error_ = true;\n        }\n    }\n\n    bool post(token_type token, const value_type& value) {\n        rollback_tmp_stack();\n        error_ = false;\n        while ((this->*(stack_top()->entry->state))(token, value))\n            ; // may throw\n        if (!error_) {\n            commit_tmp_stack();\n        } else {\n            recover(token, value);\n        }\n        return accepted_ || error_;\n    }\n\n    bool accept(value_type& v) {\n        assert(accepted_);\n        if (error_) { return false; }\n        v = accepted_value_;\n        return true;\n    }\n\n    bool error() { return error_; }\n\nprivate:\n    typedef Parser<_Value, _SemanticAction, _StackSize> self_type;\n\n    typedef bool (self_type::*state_type)(token_type, const value_type&);\n    typedef int (self_type::*gotof_type)(Nonterminal);\n\n    bool            accepted_;\n    bool            error_;\n    value_type      accepted_value_;\n    _SemanticAction& sa_;\n\n    struct table_entry {\n        state_type  state;\n        gotof_type  gotof;\n        bool        handle_error;\n    };\n\n    struct stack_frame {\n        const table_entry*  entry;\n        value_type          value;\n        int                 sequence_length;\n\n        stack_frame(const table_entry* e, const value_type& v, int sl)\n            : entry(e), value(v), sequence_length(sl) {}\n    };\n\n    Stack<stack_frame, _StackSize> stack_;\n\n    bool push_stack(int state_index, const value_type& v, int sl = 0) {\n        bool f = stack_.push(stack_frame(entry(state_index), v, sl));\n        assert(!error_);\n        if (!f) { \n            error_ = true;\n            sa_.stack_overflow();\n        }\n        return f;\n    }\n\n    void pop_stack(size_t n) {\n        stack_.pop(n);\n    }\n\n    stack_frame* stack_top() {\n        return &stack_.top();\n    }\n\n    const value_type& get_arg(size_t base, size_t index) {\n        return stack_.get_arg(base, index).value;\n    }\n\n    void clear_stack() {\n        stack_.clear();\n    }\n\n    void rollback_tmp_stack() {\n        stack_.rollback_tmp();\n    }\n\n    void commit_tmp_stack() {\n        stack_.commit_tmp();\n    }\n\n    void recover(token_type, const value_type&) {\n    }\n\n    bool call_nothing(Nonterminal nonterminal, int base) {\n        pop_stack(base);\n        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n        return push_stack(dest_index, value_type());\n    }\n\n    bool call_0_Identity(Nonterminal nonterminal, int base, int arg_index0) {\n        int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n        int r = sa_.Identity(arg0);\n        value_type v; sa_.upcast(v, r);\n        pop_stack(base);\n        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n        return push_stack(dest_index, v);\n    }\n\n    bool call_0_MakeAdd(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n        int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n        int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n        int r = sa_.MakeAdd(arg0, arg1);\n        value_type v; sa_.upcast(v, r);\n        pop_stack(base);\n        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n        return push_stack(dest_index, v);\n    }\n\n    bool call_0_MakeMul(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n        int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n        int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n        int r = sa_.MakeMul(arg0, arg1);\n        value_type v; sa_.upcast(v, r);\n        pop_stack(base);\n        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n        return push_stack(dest_index, v);\n    }\n\n    bool call_0_MakeNot(Nonterminal nonterminal, int base, int arg_index0) {\n        int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n        int r = sa_.MakeNot(arg0);\n        value_type v; sa_.upcast(v, r);\n        pop_stack(base);\n        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n        return push_stack(dest_index, v);\n    }\n\n    bool state_0(token_type token, const value_type& value) {\n        switch(token) {\n        case token_Cons:\n            // shift\n            push_stack(/*state*/ 6, value);\n            return false;\n        case token_LBranket:\n            // shift\n            push_stack(/*state*/ 3, value);\n            return false;\n        case token_Not:\n            // shift\n            push_stack(/*state*/ 2, value);\n            return false;\n        case token_Var:\n            // shift\n            push_stack(/*state*/ 7, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_0(Nonterminal nonterminal) {\n        switch(nonterminal) {\n        case Nonterminal_Expr: return 1;\n        default: assert(0); return false;\n        }\n    }\n\n    bool state_1(token_type token, const value_type& value) {\n        switch(token) {\n        case token_eof:\n            // accept\n            accepted_ = true;\n            accepted_value_ = get_arg(1, 0);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_1(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_2(token_type token, const value_type& value) {\n        switch(token) {\n        case token_Cons:\n            // shift\n            push_stack(/*state*/ 6, value);\n            return false;\n        case token_LBranket:\n            // shift\n            push_stack(/*state*/ 3, value);\n            return false;\n        case token_Not:\n            // shift\n            push_stack(/*state*/ 2, value);\n            return false;\n        case token_Var:\n            // shift\n            push_stack(/*state*/ 7, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_2(Nonterminal nonterminal) {\n        switch(nonterminal) {\n        case Nonterminal_Expr: return 8;\n        default: assert(0); return false;\n        }\n    }\n\n    bool state_3(token_type token, const value_type& value) {\n        switch(token) {\n        case token_Cons:\n            // shift\n            push_stack(/*state*/ 6, value);\n            return false;\n        case token_LBranket:\n            // shift\n            push_stack(/*state*/ 3, value);\n            return false;\n        case token_Not:\n            // shift\n            push_stack(/*state*/ 2, value);\n            return false;\n        case token_Var:\n            // shift\n            push_stack(/*state*/ 7, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_3(Nonterminal nonterminal) {\n        switch(nonterminal) {\n        case Nonterminal_Expr: return 9;\n        default: assert(0); return false;\n        }\n    }\n\n    bool state_4(token_type token, const value_type& value) {\n        switch(token) {\n        case token_Cons:\n            // shift\n            push_stack(/*state*/ 6, value);\n            return false;\n        case token_LBranket:\n            // shift\n            push_stack(/*state*/ 3, value);\n            return false;\n        case token_Not:\n            // shift\n            push_stack(/*state*/ 2, value);\n            return false;\n        case token_Var:\n            // shift\n            push_stack(/*state*/ 7, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_4(Nonterminal nonterminal) {\n        switch(nonterminal) {\n        case Nonterminal_Expr: return 10;\n        default: assert(0); return false;\n        }\n    }\n\n    bool state_5(token_type token, const value_type& value) {\n        switch(token) {\n        case token_Cons:\n            // shift\n            push_stack(/*state*/ 6, value);\n            return false;\n        case token_LBranket:\n            // shift\n            push_stack(/*state*/ 3, value);\n            return false;\n        case token_Not:\n            // shift\n            push_stack(/*state*/ 2, value);\n            return false;\n        case token_Var:\n            // shift\n            push_stack(/*state*/ 7, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_5(Nonterminal nonterminal) {\n        switch(nonterminal) {\n        case Nonterminal_Expr: return 12;\n        default: assert(0); return false;\n        }\n    }\n\n    bool state_6(token_type token, const value_type& value) {\n        switch(token) {\n        case token_eof:\n        case token_Add:\n        case token_Mul:\n        case token_RBranket:\n            // reduce\n            return call_0_Identity(Nonterminal_Expr, /*pop*/ 1, 0);\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_6(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_7(token_type token, const value_type& value) {\n        switch(token) {\n        case token_eof:\n        case token_Add:\n        case token_Mul:\n        case token_RBranket:\n            // reduce\n            return call_0_Identity(Nonterminal_Expr, /*pop*/ 1, 0);\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_7(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_8(token_type token, const value_type& value) {\n        switch(token) {\n        case token_eof:\n        case token_Add:\n        case token_Mul:\n        case token_RBranket:\n            // reduce\n            return call_0_MakeNot(Nonterminal_Expr, /*pop*/ 2, 1);\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_8(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_9(token_type token, const value_type& value) {\n        switch(token) {\n        case token_Add:\n            // shift\n            push_stack(/*state*/ 4, value);\n            return false;\n        case token_Mul:\n            // shift\n            push_stack(/*state*/ 5, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_9(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_10(token_type token, const value_type& value) {\n        switch(token) {\n        case token_RBranket:\n            // shift\n            push_stack(/*state*/ 11, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_10(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_11(token_type token, const value_type& value) {\n        switch(token) {\n        case token_eof:\n        case token_Add:\n        case token_Mul:\n        case token_RBranket:\n            // reduce\n            return call_0_MakeAdd(Nonterminal_Expr, /*pop*/ 5, 1, 3);\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_11(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_12(token_type token, const value_type& value) {\n        switch(token) {\n        case token_RBranket:\n            // shift\n            push_stack(/*state*/ 13, value);\n            return false;\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_12(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    bool state_13(token_type token, const value_type& value) {\n        switch(token) {\n        case token_eof:\n        case token_Add:\n        case token_Mul:\n        case token_RBranket:\n            // reduce\n            return call_0_MakeMul(Nonterminal_Expr, /*pop*/ 5, 1, 3);\n        default:\n            sa_.syntax_error();\n            error_ = true;\n            return false;\n        }\n    }\n\n    int gotof_13(Nonterminal nonterminal) {\n        assert(0);\n        return true;\n    }\n\n    const table_entry* entry(int n) const {\n        static const table_entry entries[] = {\n            { &Parser::state_0, &Parser::gotof_0, false },\n            { &Parser::state_1, &Parser::gotof_1, false },\n            { &Parser::state_2, &Parser::gotof_2, false },\n            { &Parser::state_3, &Parser::gotof_3, false },\n            { &Parser::state_4, &Parser::gotof_4, false },\n            { &Parser::state_5, &Parser::gotof_5, false },\n            { &Parser::state_6, &Parser::gotof_6, false },\n            { &Parser::state_7, &Parser::gotof_7, false },\n            { &Parser::state_8, &Parser::gotof_8, false },\n            { &Parser::state_9, &Parser::gotof_9, false },\n            { &Parser::state_10, &Parser::gotof_10, false },\n            { &Parser::state_11, &Parser::gotof_11, false },\n            { &Parser::state_12, &Parser::gotof_12, false },\n            { &Parser::state_13, &Parser::gotof_13, false },\n        };\n        return &entries[n];\n    }\n\n};\n\n} // namespace calc\n\n#endif // #ifndef HELLO_HPP_\n\n\n\nclass unexpected_char : public std::exception {};\n\nint var[3];\n\nclass scanner {\npublic:\n    using char_type = char;\n\nprivate:\n    string s;\n    int pos;\npublic:\n    scanner(string s) : s(s), pos(0) {}\n\n    calc::Token get(int& v) {\n        char c;\n        do {\n            c = getc();\n        } while (isspace(c));\n\n        if ('0' <= c and c <= '2') {\n            v = c - '0';\n            return calc::token_Cons;\n        }\n        if ('P' <= c and c <= 'R') {\n            v = var[c - 'P'];\n            return calc::token_Var;\n        }\n        switch (c) {\n        case '+': return calc::token_Add;\n//        case '-': return calc::token_Sub;\n        case '*': return calc::token_Mul;\n//        case '/': return calc::token_Div;\n        case '(': return calc::token_LBranket;\n        case ')': return calc::token_RBranket;\n        case '-': return calc::token_Not;\n        case EOF: return calc::token_eof;\n        }\n\n        // ??´??°\n        // if(isdigit(c)) {\n        //     v = c - '0';\n        //     return calc::token_Digit;\n        // }\n        cerr << c << endl;\n        throw unexpected_char();\n    }\n\nprivate:\n    char_type getc() {\n        if (pos == s.size()) return EOF;\n        return s[pos++];\n    }\n};\n\nstruct SemanticAction {\n    void syntax_error(){}\n    void stack_overflow(){}\n    void downcast( int& x, int y ) { x = y; }\n    void upcast( int& x, int y ) { x = y; }\n\n    int Identity( int n ) { return n; }\n    int MakeMul(int x, int y) {\n        return min(x, y);\n    }\n    int MakeAdd(int x, int y) {\n        return max(x, y);\n    }\n    int MakeNot(int x) {\n        return 2-x;\n    }\n};\n\nint main() {\n    while (true) {\n        string s;\n        getline(cin, s);\n        if (s == \".\") break;\n        int ans = 0;\n        for (int x = 0; x < 3; x++) {\n            for (int y = 0; y < 3; y++) {\n                for (int z = 0; z < 3; z++) {\n                    var[0] = x; var[1] = y; var[2] = z;\n                    scanner scn(s);\n                    SemanticAction sa;\n                    calc::Parser<int, SemanticAction> parser(sa);\n                    calc::Token token;\n                    while (true) {\n                        int v;\n                        token = scn.get(v);\n                        if (parser.post(token, v)) { break; }\n                    }\n                    int v;\n                    if (parser.accept(v)) {\n                        if (v == 2) ans++;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nint p,q,r;\n\nvoid invert(stack<int> &st){\n    int x;\n    x=st.top();\n    st.pop();\n    while(st.top()==-1){\n        x=(x-1)*(-1)+1;\n        st.pop();\n    }\n    st.push(x);\n    return;\n}\n\nvoid calc(stack<int> &st){\n    int x,y;\n    while(true){\n        invert(st);\n        x=st.top();\n        st.pop();\n        int t=st.top();\n        if(t==-4){\n            st.pop();\n            st.push(x);\n            return;\n        }\n        else{\n            st.pop();\n            invert(st);\n            y=st.top();\n            st.pop();\n            if(t==-2){\n                st.push(max(x,y));\n            }\n            else if(t==-3){\n                st.push(min(x,y));\n            }\n        }\n       // cout << st.top() << endl;\n    }\n}\n            \n\nint main(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str[0]=='.')break;\n        stack<int> st;\n        int ans=0;\n        for(p=0;p<3;p++){\n        for(q=0;q<3;q++){\n        for(r=0;r<3;r++){\n            for(int i=0;i<str.length();i++){\n                if(str[i]=='-')st.push(-1);\n                else if(str[i]=='+')st.push(-2);\n                else if(str[i]=='*')st.push(-3);\n                else if(str[i]=='(')st.push(-4);\n                else if(str[i]=='P')st.push(p);\n                else if(str[i]=='Q')st.push(q);\n                else if(str[i]=='R')st.push(r);\n                else if(str[i]==')') calc(st);\n                else st.push((int)str[i]-48);\n            }\n            //cout << st.top();\n            if(st.top()==2)ans++;\n        }\n        }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n                "
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i,a,n) for(ll i=a;i<(ll)(n);i++)\n\nint nott(int X){\n   if(X == 0) return 2;\n   if(X == 1) return 1;\n   return 0;\n}\n\nint andd(int X, int Y){\n   if(X == 0) return 0;\n   if(X == 1){\n      if(Y == 0) return 0;\n      return 1;\n   }\n   return Y;\n}\n\nint orr(int X, int Y){\n   if(X == 0) return Y;\n   if(X == 1){\n      if(Y == 0) return 1;\n      return Y;\n   }\n   return 2;\n}\n\nbool isNum(char c){\n   if(c == '0' || c == '1' || c == '2' || c == 'P' || c == 'Q' || c == 'R') return true;\n   return false;\n}\n\nint charToInt(char c){\n   if(c == '0') return 0;\n   if(c == '1') return 1;\n   return 2;\n}\n\n//逆ポーランド記法に変換\nstring fix(string str){\n   string result = \"\";\n   stack<int> st;\n   for(char c : str){\n      if(isNum(c)){\n         result += c;\n      }else{\n         if(c == ')'){\n            while(st.top() != '('){\n               result += st.top();\n               st.pop();\n            }\n            st.pop();\n         }else{\n            if(c == '('){\n               st.push(c);\n            }else{\n               while(!st.empty()){\n                  if(st.top() == '-' && c != '-'){\n                     result += st.top();\n                     st.pop();\n                  }else{\n                     break;\n                  }\n               }\n               st.push(c);\n            }\n         }\n      }\n   }\n   while(!st.empty()){\n      result += st.top();\n      st.pop();\n   }\n\n   return result;\n}\n\nint main(){\n   string str;\n   while(cin>>str, str != \".\"){\n      //逆ポーランド記法に変換\n      str = fix(str);\n      int count = 0;\n      for(int p=0; p<3; p++){\n         for(int q=0; q<3; q++){\n            for(int r=0; r<3; r++){\n               stack<int> st;\n               for(char c : str){\n                  if(c == 'P'){\n                     st.push(p);\n                  }else if(c == 'Q'){\n                     st.push(q);\n                  }else if(c == 'R'){\n                     st.push(r);\n                  }else if(c == '-'){\n                     int a = st.top();\n                     st.pop();\n                     st.push(nott(a));\n                  }else if(c == '+'){\n                     int a = st.top();\n                     st.pop();\n                     int b = st.top();\n                     st.pop();\n                     st.push(orr(a, b));\n                  }else if(c == '*'){\n                     int a = st.top();\n                     st.pop();\n                     int b = st.top();\n                     st.pop();\n                     st.push(andd(a, b));\n                  }else{\n                     st.push(charToInt(c));\n                  }\n               }\n               if(st.top() == 2) count++;\n            }\n         }\n      }\n      cout << count << endl;\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define S str[ima]\nusing namespace std;\nstring str;\nint ima;\n\nint formula(int p,int q,int r) {\n  int val;\n  int val2;\n    while(S=='0'||S=='1'||S=='2'||S=='P'||S=='Q'||S=='R'||S=='('||S=='-') {\n    if(S=='('){\n      ima++;\n      val = formula(p,q,r);\n\n      if(S == '+'){\n\tima++;\n\tval2 = formula(p,q,r);\n\tif(val==2 || val2==2) val = 2;\n\telse if(val==1 || val2==1) val = 1;\n\telse val = 0;\n      }\n      else if(S == '*') {\n\tima++;\n\tval2 = formula(p,q,r);\n\tif(val==0 || val2==0) val = 0;\n\telse if(val==1 || val2==1) val = 1;\n\telse val = 2;\n      }\n      ima++;\n    }\n    \n    else if(S=='0'||S=='1'||S=='2'||S=='P'||S=='Q'||S=='R'){\n      val = S-'0';\n      if(S=='P')val = p;\n      else if(S=='Q') val = q;\n      else if(S=='R') val = r;\n      ima++;\n    }\n    else if(S == '-'){\n      ima++;\n      val2 = formula(p,q,r);\n      //cout <<\"-\"<<val2<<endl;\n      if(val2 == 0) val = 2;\n      else if(val2==2)val = 0;\n      else val = 1;\n    }\n     \n    }\n\n  return val;    \n    \n}\n  \nint main(){\n\n  while(1) {\n    cin >> str;\n    if(str == \".\") break;\n    \n    int ans = 0;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tfor(int k=0;k<3;k++){\n\t  ima =0;\n\t  int res = formula(i,j,k);\n\t  //  cout<<i<<\" \"<<j<<\" \"<<k<<\" \" << res <<endl;\n\t  //cout << str.size()<<\" \"<<ima<<endl;\n\t  if(res == 2) ans++;\n\t}\n    cout << ans <<endl;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nstring s;\nint P, Q, R;\n\nint neg(int a) { return (a==0? 2:(a==1?1:0)); }\nint mul(int a, int b) { return min(a, b); }\nint add(int a, int b) { return max(a, b); }\n\nint dfs(int l, int r) {\n    if(s[l]=='-') return neg(dfs(l+1, r));\n    if(s[l]=='(' && s[r-1]==')') {\n        int m, cnt = 0;\n        for(m=l+1; m<r-1; m++) {\n            if(cnt == 0 && (s[m]=='*' ||  s[m]=='+')) break;\n            if(s[m]=='(') cnt++;\n            if(s[m]==')') cnt--;\n        };\n        if(s[m]=='*') return mul(dfs(l+1, m), dfs(m+1, r-1));\n        if(s[m]=='+') return add(dfs(l+1, m), dfs(m+1, r-1));\n    }\n    \n    if(isdigit(s[l])) return s[l]-'0';\n    return (s[l]=='P'? P:(s[l]=='Q'? Q:R));\n}\n\nint main() {\n    while(cin>>s, s!=\".\") {\n        int ans = 0;\n        for(P=0; P<3; P++) for(Q=0; Q<3; Q++) for(R=0; R<3; R++)\n            if(dfs(0, s.size()) == 2) ans++;\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nconst int se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint num(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tif (isdigit(s[idx]) || s[idx]=='-')\n\t\treturn number(s, idx);\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\treturn val;\n}\nint number(string& s, int &idx) {\n\tint not= 0;\n\twhile (s[idx]=='-')\n\t{\n\t\tnot++;\n\t\tidx++;\n\t}\n\tint val = s[idx] - '0';\n\tidx++;\n\tif (not% 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nint p,q,r;\n\nvoid invert(stack<int> &st){\n    int x;\n    x=st.top();\n    st.pop();\n    while(st.top()==-1){\n        x=(x-1)*(-1)+1;\n        st.pop();\n    }\n    st.push(x);\n    return;\n}\n\nvoid calc(stack<int> &st){\n    int x,y;\n    while(true){\n        invert(st);\n        x=st.top();\n        st.pop();\n        int t=st.top();\n        if(t==-4){\n            st.pop();\n            st.push(x);\n            return;\n        }\n        else{\n            st.pop();\n            invert(st);\n            y=st.top();\n            st.pop();\n            if(t==-2){\n                st.push(max(x,y));\n            }\n            else if(t==-3){\n                st.push(min(x,y));\n            }\n        }\n       // cout << st.top() << endl;\n    }\n}\n            \n\nint main(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str[0]=='.')break;\n        stack<int> st;\n        int ans=0;\n        for(p=0;p<3;p++){\n        for(q=0;q<3;q++){\n        for(r=0;r<3;r++){\n            for(int i=0;i<str.length();i++){\n                if(str[i]=='-')st.push(-1);\n                else if(str[i]=='+')st.push(-2);\n                else if(str[i]=='*')st.push(-3);\n                else if(str[i]=='(')st.push(-4);\n                else if(str[i]=='P')st.push(p);\n                else if(str[i]=='Q')st.push(q);\n                else if(str[i]=='R')st.push(r);\n                else if(str[i]==')') calc(st);\n                else st.push((int)str[i]-48);\n            }\n            //cout << st.top();\n            if(st.top()==2)ans++;\n        }\n        }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n                "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nstring s;\nint p, q, r;\n \nint expression(State&);\nint term(State&);\nint factor(State&);\nint number(State&);\n \nint expression(State &begin){\n    int ret = term(begin);\n    while (1){\n        if (*begin == '+'){\n            begin++;\n            ret = max(ret, term(begin));\n        }else if (*begin == '*'){\n            begin++;\n            ret = min(ret, term(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n \nint term(State &begin){\n    int ret = factor(begin);\n    while (1){\n        if (*begin == '-'){\n            begin++;\n            ret = 2 - term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n \nint factor(State &begin){\n    if (*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n \nint number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin) || (*begin >= 'P' && *begin <= 'R')){\n        if (*begin == 'P') ret = p;\n        else if (*begin == 'Q') ret = q;\n        else if (*begin == 'R') ret = r;\n        else{\n            ret *= 10;\n            ret += *begin - '0';\n        }\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> s && s != \".\"){\n        int ans = 0;\n        REP(_p,3) REP(_q,3) REP(_r,3){\n            p = _p;\n            q = _q;\n            r = _r;            \n            State begin = s.begin();\n            if (expression(begin) == 2) ans++;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring repr(string s,int p,int q,int r){\n  int tmp;\n  string s_tmp=s;\n  while ((tmp = s_tmp.find(\"P\")) >= 0){s_tmp.replace(s_tmp.find(\"P\"),1,to_string(p));}\n  while ((tmp = s_tmp.find(\"Q\")) >= 0){s_tmp.replace(s_tmp.find(\"Q\"),1,to_string(q));}\n  while ((tmp = s_tmp.find(\"R\")) >= 0){s_tmp.replace(s_tmp.find(\"R\"),1,to_string(r));}\n  return s_tmp;\n}\n\nstring op_plus(string left,string right){\n  int l,r;\n  if (left[0]=='-'){l=2-(left[1]-'0');}\n  else {l=left[0]-'0';}\n  if (right[0]=='-'){r=2-(right[1]-'0');}\n  else {r=right[0]-'0';}\n  return to_string(max(l,r));\n}\n\nstring times(string left,string right){\n  int l,r;\n  if (left[0]=='-'){l=2-(left[1]-'0');}\n  else {l=left[0]-'0';}\n  if (right[0]=='-'){r=2-(right[1]-'0');}\n  else {r=right[0]-'0';}\n  return to_string(min(l,r));\n}\n\nstring solve(string str){\n  while (str.substr(0,2) == \"--\"){str.erase(str.begin(),str.begin()+2);}\n  if (str.length() == 1||str.length() == 2){\n    if (str == \"0\"){\n      return \"0\";\n    } else if (str == \"1\"){\n      return \"1\";\n    } else if (str == \"2\"){\n      return \"2\";\n    } else if (str == \"-0\"){\n      return \"2\";\n    } else if (str == \"-1\"){\n      return \"1\";\n    } else if (str == \"-2\"){\n      return \"0\";\n    } else {\n      cout << str << \" :Error\" << endl;\n      return \"-1\";\n    }\n  }\n  if (str[0] == '(') {\n    str.erase(str.begin());\n    str.pop_back();\n  }\n  int brcount = 0;\n  int ind = 0;\n  while (ind < str.length()){\n    if (str[ind] == '('){++brcount;}\n    if (str[ind] == ')'){--brcount;}\n    if ((brcount == 0)&&(str[ind] == '+' || str[ind] == '*')) break;\n    ++ind;\n  }\n  if (ind == str.length()){\n    return to_string(2-(solve(str.substr(1,str.length()-1))[0]-'0'));\n  }\n  string left,right;\n  left = solve(str.substr(0,ind));\n  right = solve(str.substr(ind+1,str.length()-(ind+1)));\n  if (str[ind] == '+'){\n    return op_plus(left,right);\n  }\n  if (str[ind] == '*'){\n    return times(left,right);\n  }\n}\n\nint main(){\n  string s,s_tmp;\n  int sum;\n  while (1){\n    cin >> s;\n    if (s == \".\") {\n      break;\n    }\n    sum = 0;\n    for (int p=0;p<3;p++){\n      for (int q=0;q<3;q++){\n        for (int r=0;r<3;r++){\n          s_tmp = repr(s,p,q,r);\n          if (solve(s_tmp) == \"2\" ){++sum;}\n        }\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * <formula> ::= 0 | 1 | 2 | P | Q | R |\n *    -<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\nint table_seki[3][3];\nint table_wa[3][3];\nint P,Q,R;\n\nint formula(string& s, int& i);\nint main();\n\nint formula(string& s, int& i)\n{\n\tint left=false, right=false;\t\n\tchar ope=0;\n\tbool ans = false;\n\n\tswitch(s[i])\n\t{\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase 'P': return P;\n\t\tcase 'Q': return Q;\n\t\tcase 'R': return R;\n\t\tcase '-':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\tif (left == 0) { return 2; }\n\t\t\telse if (left == 2) { return 0; }\n\t\t\telse { return 1; }\n\t\tcase '(':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\ti++;\n\t\t\tope = s[i];\n\t\t\ti++;\n\t\t\tright = formula(s,i);\n\t\t\t/*\n\t\t\tdump(left);\n\t\t\tdump(ope);\n\t\t\tdump(right);\n\t\t\t*/\n\t\t\ti++; //)\n\t\t\tif (ope == '*') {\n\t\t\t\treturn table_seki[left][right];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn table_wa[left][right];\n\t\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t//積集合\n\ttable_seki[0][0] = 0; //y,x\n\ttable_seki[1][0] = 0; //y,x\n\ttable_seki[2][0] = 0; //y,x\n\ttable_seki[0][1] = 0; //y,x\n\ttable_seki[1][1] = 1; //y,x\n\ttable_seki[2][1] = 1; //y,x\n\ttable_seki[0][2] = 0; //y,x\n\ttable_seki[1][2] = 1; //y,x\n\ttable_seki[2][2] = 2; //y,x\n\n\t//和集合\n\ttable_wa[0][0] = 0; //y,x\n\ttable_wa[1][0] = 1; //y,x\n\ttable_wa[2][0] = 2; //y,x\n\ttable_wa[0][1] = 1; //y,x\n\ttable_wa[1][1] = 1; //y,x\n\ttable_wa[2][1] = 2; //y,x\n\ttable_wa[0][2] = 2; //y,x\n\ttable_wa[1][2] = 2; //y,x\n\ttable_wa[2][2] = 2; //y,x\n\n\tstring line;\n\tvector<int> binary;\n\tbinary.push_back(0);\n\tbinary.push_back(1);\n\tbinary.push_back(2);\n\tint pattern_cnt = 0;\n\n\twhile(true) {\n\t\tcin >> line;\n\t\tpattern_cnt = 0;\n\t\tif (line[0] == '.') { break; }\n\n\t\t/*\n\t\t//単一パターン\n\t\tP = 0; Q = 0; R = 1;\n\t\tint i = 0;\n\t\tint result = formula(line,i);\n\t\tcout << \"P=\" << P << \" Q=\" << Q << \" R=\" << R << \" res=\" << result << endl;\n\t\t*/\n\n\t\trep(p,3) {\n\t\t\trep(q,3) {\n\t\t\t\trep(r,3) {\n\t\t\t\t\tP=p; Q=q; R=r;\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint result = formula(line,i);\n\n\t\t\t\t\t//cout << \"P=\" << P << \" Q=\" << Q << \" R=\" << R << \" res=\" << result << endl;\n\n\t\t\t\t\tif (result == 2) {\n\t\t\t\t\t\tpattern_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << pattern_cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n \nusing namespace std;\n \nstring str;\nint p, q, r;\n \nint negation( int &pt);\nint prod( int x, int y );\nint disj( int x, int y );\nint calc( int &pt );\nint getvalue( int &pt );\n \nint solve(){\n \n\tint cnt = 0;\n\tcin >> str;\n\tif( str == \".\" ) { return 0; }\n \n \n\tfor( p = 0; p < 3; p++ )\n\t\tfor( q = 0; q < 3; q++ )\n\t\t\tfor( r = 0; r < 3; r++ ) {\n\t\t\t\tint ptr = 0;\n\t\t\t\tif( calc( ptr ) == 2 )\n\t\t\t\t\tcnt ++;\n\t\t\t}\n \n\tcout << cnt << endl;\n \n\treturn 1;\n \n}\n \nint main( void ) {\n \n\twhile( solve() ) {}\n \n\treturn 0;\n}\n \nint getvalue( int &pt ) {\n\tswitch( str[pt] ) {\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tbreak;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tbreak;\n\t\tcase '2':\n\t\t\treturn 2;\n\t\tbreak;\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tbreak;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tbreak;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n \nint negation( int &pt ) {\n\tif( str[pt] == '-' ) {\n\t\tpt ++;\n\t\treturn 2 - negation(pt);\n\t}\n\tif( str[pt] == '(' ) {\n\t\tpt ++;\n\t\treturn 2-calc(pt);\n\t}\n\tint ret = 2-getvalue(pt);\n\tpt ++;\n\treturn ret;\n}\n \nint disj( int x, int y ) {\n\t//?????????\n\tif( x == y ) { return x; }\n\tif( x + y > 2 ) { return 2; }\n\treturn x + y;\n}\n \nint prod( int x, int y ) {\n\t//?????????\n\tif( x == 0 || y == 0 ) { return 0; }\n\tif( x == 2 && y == 2 ) { return 2; }\n\treturn 1;\n}\n \nint calc( int &pt ) {\n \n\t//?????????????????????\n\tint lhs;\n\tif( str[pt] == '-' ) {\n\t\tlhs = negation(++pt);\n\t} else if( str[pt] == '(' ) {\n\t\tlhs = calc(++pt);\n\t} else {\n\t\tlhs = getvalue(pt);\n\t\t++pt;\n\t}\n \n \n\t//????????????lhs?????????\n\tif( ( pt >= str.length() - 1 ) || ( str[pt] == ')' ) ) {\n\t\t++pt;\n\t\treturn lhs;\n\t}\n \n\t//?????????????????????\n\tchar op = str[pt];\n\t++pt;\n \n\t//?????????????????????\n\tint rhs;\n\tif( str[pt] == '-' ) {\n\t\trhs = negation(++pt);\n\t} else if( str[pt] == '(' ) {\n\t\trhs = calc(++pt);\n\t} else {\n\t\trhs = getvalue(pt);\n\t\t++pt;\n\t}\n \n\tif( pt < str.length() && str[pt] == ')' ) {\n\t\tpt ++;\n\t}\n \n \n\tswitch( op ) {\n\t\tcase '+':\n\t\t\treturn disj( lhs, rhs );\n\t\tbreak;\n\t\tcase '*':\n\t\t\treturn prod( lhs, rhs );\n\t\tbreak;\n\t}\n \n\treturn -1;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p, q, r, cursor;\nstring s;\n\nint not(int a) {\n\treturn 2 - a;\n}\n\nint and(int a, int b) {\n\tif(a == 0 || b == 0) return 0;\n\tif(a == 1 || b == 1) return 1;\n\treturn 2;\n}\n\nint or(int a, int b) {\n\tif(a == 2 || b == 2) return 2;\n\tif(a == 1 || b == 1) return 1;\n\treturn 0;\n}\n\nint f() {\n\tchar c = s[cursor];\n\tcursor++;\n\tif(c == '0') return 0;\n\tif(c == '1') return 1;\n\tif(c == '2') return 2;\n\tif(c == 'P') return p;\n\tif(c == 'Q') return q;\n\tif(c == 'R') return r;\n\tif(c == '-') return not(f());\n\tif(c == '(') {\n\t\tint a = f();\n\t\tchar op = s[cursor];\n\t\tcursor++;\n\t\tint b = f();\n\t\tcursor++;\n\t\tif(op == '*') {\n\t\t\treturn and(a, b);\n\t\t}\n\t\telse {\n\t\t\treturn or(a, b);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> s, s[0] != '.') {\n\t\tint ans = 0;\n\t\tfor(p = 0; p <= 2; p++) {\n\t\t\tfor(q = 0; q <= 2; q++) {\n\t\t\t\tfor(r = 0; r <= 2; r++) {\n\t\t\t\t\tcursor = 0;\n\t\t\t\t\tif(f() == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint _not(int val){return 2-val;}\nint _or(int lhs,int rhs){return max(lhs,rhs);}\nint _and(int lhs,int rhs){return min(lhs,rhs);}\nint val(int& i,const string& s,const vector<int> &pqr);\nint section(int &i,const string& s,const vector<int>& pqr);\nint formula(int& i,const string& s,const vector<int>& pqr);\n\nbool is_nega(int& i,const string& s){\n  bool res=0;\n  for(;i<s.size() && s[i]=='-';i++){\n    res=!res;\n  }\n  return res;\n}\n\nint val(int &i,const string &s,const vector<int> &pqr){\n  int res=-1;\n  if(isalpha(s[i])){\n    res=pqr[s[i]-'P'];\n    i++;\n  }\n  else{\n    assert(isdigit(s[i]));\n    res=s[i]-'0';\n    i++;\n  }\n  return res;\n\n}\n\nint section(int &i,const string& s,const vector<int>& pqr){\n  int res=-1;\n  if(s[i]=='('){\n    i++;\n    res=formula(i,s,pqr);\n    i++;\n  }\n  else{\n    res=val(i,s,pqr);\n  }\n  return res;\n\n}\n\nint formula(int& i,const string& s,const vector<int>& pqr){\n  bool is_n=is_nega(i,s);\n  int lhs=section(i,s,pqr);\n  if(is_n) lhs=_not(lhs);\n  if(i>=s.size()) return lhs;\n  char op=s[i];\n  i++;\n  if(op==')'){\n    i++;\n    return lhs;\n  }\n  is_n=is_nega(i,s);\n  int rhs=section(i,s,pqr);\n  if(is_n) rhs=_not(rhs);\n  if(op=='+') return _or(lhs,rhs);\n  if(op=='*') return _and(lhs,rhs);\n  return -1;\n  \n}\n\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    int cnt=0;\n    for(int p=0;p<=2;p++){\n      for(int q=0;q<=2;q++){\n\tfor(int r=0;r<=2;r++){\n\t  vector<int> pqr={p,q,r};\n\t  int i=0;\n\t  int ret=formula(i,s,pqr);\n\t  cnt+=(ret==2);\n\t}\n      }\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstring str;\n\nint calc(int idx){\n    if(str[idx]=='('){\n        int depth=1;\n        int idx2=idx+1;\n        while(depth>0){\n            if(str[idx2]=='(') depth++;\n            if(str[idx2]==')') depth--;\n            if(str[idx2]=='*' && depth==1){\n                return min(calc(idx+1),calc(idx2+1));\n            }\n            if(str[idx2]=='+' && depth==1){\n                return max(calc(idx+1),calc(idx2+1));\n            }\n            idx2++;\n        }\n    }else{\n        if(str[idx]=='-'){\n            return 2-calc(idx+1);\n        }else{\n            return str[idx]-'0';\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(1){\n        string tmp;\n        cin >> tmp;\n        if(tmp[0] == '.') break;\n        \n        str=tmp;\n        int count=0;\n        for(int i=0; i<=2; i++){\n            for(int j=0; j<=2; j++){\n                for(int k=0; k<=2; k++){\n                    for(int idx=0; idx<(int)tmp.length(); idx++){\n                        str[idx] = tmp[idx];\n                        if(tmp[idx]=='P') str[idx] ='0'+i;\n                        if(tmp[idx]=='Q') str[idx] ='0'+j;\n                        if(tmp[idx]=='R') str[idx] ='0'+k;\n                    }\n                    if(calc(0)==2) count++;\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define rep(i,n) rep2(i,0,n-1)\n#define ll long long\nll INF = 1e9;\nconst int N = 1e6+100;\nint i,ans;\nchar s[N];\nmap<char,int> mp;\nll expr();\nll number(){\n    if(mp.count(s[i])) return mp[s[i++]];\n    else return (s[i++]-'0');\n}\nll factor(){\n    if(s[i]=='('){\n        i++;\n        ll res = expr();\n        i++;\n        return res;\n    }\n    else return number();\n}\nll term(){\n    if(s[i]=='-'){\n        i++;\n        return 2-term();\n    }\n    else return factor();\n}\nll expr(){\n    ll res = term();\n    for(;;){\n        if(s[i]=='+') i++,res = max(res,term());\n        else if(s[i]=='*') i++,res = min(res,term());\n        else break;\n    }\n    return res;\n}\n\nmain(){\n    while(1){\n        scanf(\"%s\",s);\n        if(s[0]=='.')return 0;\n        i=0,ans=0;\n        rep(ii,3)rep(j,3)rep(k,3){\n            i=0;\n            mp['P']=ii;\n            mp['Q']=j;\n            mp['R']=k;\n            if(expr()==2)ans++;\n        }\n        cout<<ans<<endl;\n        for(;i>=0;i--)s[i]=' ';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define CEIL(a,b) ((a) / (b) + ((a) % (b) == 0 ? 0 : 1))\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconstexpr int MOD = 1'000'000'007;\nconstexpr int INF = 1'000'000'001;\nconstexpr ll LLINF = 4'000'000'000'000'000'001;\n// constexpr int INF = 2147483647; // 2 * 1e9\n// constexpr ll LLINF = 9223372036854775807; // 9 * 1e18\n\nconst int dx[] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconst int dy[] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n\nint N[3] = {2, 1, 0};\nint A[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint O[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\n// [b, e)について、論理式を評価する\nint calc(int p, int q, int r, string &s, int b, int e){\n    if(e - b == 1){\n        switch(s[b]){\n            case '0': return 0;\n            case '1': return 1;\n            case '2': return 2;\n            case 'P': return p;\n            case 'Q': return q;\n            case 'R': return r;\n            default: cout << \"FUCK\\n\";\n        }\n    }\n    if(s[b] == '-') return N[calc(p, q, r, s, b+1, e)];\n    int lv = 0, lhs_e = -1, rhs_b = -1;\n    for(int i = b; i < e; ++i){\n        if(s[i] == '(')++lv;\n        else if(s[i] == ')') --lv;\n        else if(lv == 1 && s[i] == '*') return A[calc(p, q, r, s, b+1, i)][calc(p, q, r, s, i+1, e-1)];\n        else if(lv == 1 && s[i] == '+') return O[calc(p, q, r, s, b+1, i)][calc(p, q, r, s, i+1, e-1)];\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    while(true){\n        string s;\n        cin >> s;\n        if(s == \".\") break;\n        int ans = 0;\n        for(int p = 0; p < 3; ++p){\n            for(int q = 0; q < 3; ++q){\n                for(int r = 0; r < 3; ++r){\n                    ans += calc(p, q, r, s, 0, s.size()) == 2;\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return (int)tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=(char)(i+'0');\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=(char)(j+'0');\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=(char)(k+'0');\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef string::const_iterator Iter;\n\n// -X == 2 - X\n// X * Y == min(X, Y)\n// X + Y == max(X, Y)\n\nint express(Iter &p);\n\nint express(Iter &p) {\n\tif(*p == '-') {\n\t\tp++;\n\t\tint r = express(p);\n\t\treturn 2 - r;\n\t}\n\telse if(*p == '(') {\n\t\tp++; // skip '('\n\t\tint r = express(p);\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tint rs = express(p);\n\t\t\tr = min(r, rs);\n\t\t}\n\t\telse if(*p == '+') {\n\t\t\tp++;\n\t\t\tint rs = express(p);\n\t\t\tr = max(r, rs);\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\n\t\tp++; // skip ')'\n\t\treturn r;\n\t}\n\telse if(isdigit(*p)) {\n\t\tint r = (*p) - '0';\n\t\tp++;\n\t\treturn r;\n\t}\n\telse\n\t\tassert(false);\n}\n\nint main() {\n\tfor(;;) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\n\t\tif(line == \".\") break;\n\n\t\tint ans = 0;\n\t\tint var[3];\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\tvar[0] = i;\n\t\t\t\t\tvar[1] = j;\n\t\t\t\t\tvar[2] = k;\n\n\t\t\t\t\tstring s = line;\n\t\t\t\t\tfor(string::iterator it = s.begin(); it != s.end(); ++it) {\n\t\t\t\t\t\tif(isalpha(*it)) {\n\t\t\t\t\t\t\t*it = var[(*it) - 'P'] + '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tIter begin = s.begin();\n\t\t\t\t\tint r = express(begin);\n\t\t\t\t\tif(r == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint solve(string expr, int p, int q, int r) {\n    int k = 0;\n    function<int(void)> calc = [&]() {\n        if (isdigit(expr[k])) return expr[k++] - '0';\n        if (expr[k] == '-') { k++; return 2 - calc(); }\n        if (expr[k] == '(') {\n            k++;\n            int x = calc();\n            bool plus = expr[k++] == '+';\n            int y = calc();\n            k++;\n            return plus ? max(x, y) : min(x, y);\n        }\n        return -1;\n    };\n    for (auto& e : expr) {\n        switch (e) {\n            case 'P': e = p + '0'; break;\n            case 'Q': e = q + '0'; break;\n            case 'R': e = r + '0'; break;\n        }\n    }\n    return calc() == 2;\n}\n\nint main() {\n    for (string expr; cin >> expr, expr != \".\";) {\n        int cnt = 0;\n        rep(p, 3) rep(q, 3) rep(r, 3) if (solve(expr, p, q, r)) cnt++;\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring str, s;\nint pos;\n\nvoid a() {\n  for(int i = 0; i < str.length(); ++i) {\n    if(str[i] != '-') continue;\n    int j;\n    for(j = i+1; j < str.length() && str[j] == '-'; ++j);\n    if(j == i+1) continue;\n    if((j-i) % 2 == 0)\n      str = str.substr(0, i) + str.substr(j);\n    else\n      str = str.substr(0, i+1) + str.substr(j);\n  }\n}\n\nvoid b(string &s) {\n  for(int i = 0; i < s.length(); ++i) {\n    if(s[i] == '-') {\n      s = s.substr(0, i) + s.substr(i+1);\n      s[i] = '2'-(s[i]-'0');\n    }\n  }\n}\n\nint exp();\n\nint factor() {\n  int x;\n  if(s[pos] == '(') {\n    ++pos;\n    x = exp();\n    ++pos;\n  } else {\n    x = s[pos++] - '0';\n  }\n  return x;\n}\n\nint term() {\n  int x = factor();\n  while(s[pos] == '*') {\n    ++pos;\n    x = min(x, factor());\n  }\n  return x;\n}\n\nint exp() {\n  int x = term();\n  while(s[pos] == '+') {\n    ++pos;\n    x = max(x, term());\n  }\n  return x;\n}\n\nint solve() {\n  int ans = 0;\n  a();\n  for(char p = '0'; p <= '2'; ++p) {\n    for(char q = '0'; q <= '2'; ++q) {\n      for(char r = '0'; r <= '2'; ++r) {\n\ts = str;\n\tfor(int i = 0; i < s.length(); ++i) {\n\t  if(s[i] == 'P') s[i] = p;\n\t  if(s[i] == 'Q') s[i] = q;\n\t  if(s[i] == 'R') s[i] = r;\n\t}\n\tb(s);\n\tpos = 0;\n\tif(exp() == 2) ++ans;\n      }\n    }\n  }\n  return ans;\n}\n\nmain() {\n  while((cin >> str) && str != \".\") {\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include\"bits/stdc++.h\"\n#define INF          1e9\n#define INFLL        1e18\n#define EPS          1e-9\n#define MOD          1000000007\n#define REP(i,n)     for(ll i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)    for(ll i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)    for(ll i=(n)-1;i>=0;--i)\n#define REPR1(i,n)   for(ll i=(n);i>0;--i)\n#define REPC(i,obj)  for(auto i:obj)\n#define ALL(obj)     (obj).begin(),(obj).end()\n#define SETP(n)      cout<<fixed<<setprecision(n)\n#define VV(T,h,w)    vector<vector<T>>(h,vector<T>(w))\n#define VVI(T,h,w,i) vector<vector<T>>(h,vector<T>(w,i))\nusing namespace std;\nusing ll = long long;\ntemplate<typename T = ll>inline T in() { T ret; cin >> ret; return ret; }\n\nusing state=string::const_iterator;\nll expr(state &);\nll term(state &);\nll fuct(state &);\nll expr(state &s)\n{\n    ll ret = term(s);\n    while (true) {\n        char opr = *(s++);\n        ll arg = term(s);\n        if (opr == '+') {\n            if (ret == 2 || arg == 2)ret = 2;\n            else if (ret == 1 || arg == 1)ret = 1;\n            else ret = 0;\n        } else if (opr == '*') {\n            if (ret == 0 || arg == 0)ret = 0;\n            else if (ret == 1 || arg == 1)ret = 1;\n            else ret = 2;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\nll term(state & s)\n{\n    if (*s == '-') {\n        ++s;\n        return 2 - term(s);\n    } else {\n        return fuct(s);\n    }\n}\nll fuct(state & s)\n{\n    if (*s == '(') {\n        ++s;\n        ll ret = expr(s);\n        return ret;\n    } else if (isdigit(*s)) {\n        ll ret = *s - '0';\n        ++s;\n        return ret;\n    }\n}\nint main()\n{\n    while (true) {\n        string inp = in<string>();\n        if (inp[0] != '.') {\n            ll ans = 0;\n            for (char p = '0'; p <= '2'; ++p) {\n                for (char q = '0'; q <= '2'; ++q) {\n                    for (char r = '0'; r <= '2'; ++r) {\n                        string exstr = inp;\n                        replace(ALL(exstr), 'P', p);\n                        replace(ALL(exstr), 'Q', q);\n                        replace(ALL(exstr), 'R', r);\n                        auto s = exstr.cbegin();\n                        ans += expr(s) == 2;\n                    }\n                }\n            }\n            cout << ans << endl;\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nint PQR[3],NOT[3]={2,1,0},now;\nstring exp;\n\nint fomula(){\n  if(exp[now]=='('){\n    now++;\n    int res=fomula();\n    if(exp[now]=='+'){\n      now++;\n      res=max(res,fomula());\n    }\n    if(exp[now]=='*'){\n      now++;\n      res=min(res,fomula());\n    }\n    now++;\n    return res;\n  }\n  else if(isdigit(exp[now])){\n    return exp[now++]-'0';\n  }\n  else if(isupper(exp[now])){\n    return PQR[exp[now++]-'P'];\n  }\n  else if(exp[now]=='-'){\n    now++;\n    return NOT[fomula()];\n  }\n}\n\nint main(void){\n\n  while(cin >> exp){\n    if(exp==\".\")break;\n    int cnt=0;\n    for(PQR[0]=0;PQR[0]<3;PQR[0]++){\n      for(PQR[1]=0;PQR[1]<3;PQR[1]++){\n\tfor(PQR[2]=0;PQR[2]<3;PQR[2]++){\n\t  now=0;\n\t  cnt+=(2==fomula());\n\t}\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\n\nint p,q,r;\n\nint solve(string::const_iterator& s){\n    switch (*s) {\n        case '-':{\n            s++;\n            int res=solve(s);\n            return 1+(1-res);\n        }\n        case '(':{\n            s++;\n            int res1=solve(s);\n            int op=*s;\n            s++;\n            int res2=solve(s);\n            int ans=0;\n            if(op=='*'){\n                if(res1==0||res2==0){\n                    ans=0;\n                } else if(res1 == 2 && res2 == 2){\n                    ans=2;\n                } else {\n                    ans = 1;\n                }\n            } else {\n                if(res1 == 2 || res2 == 2){\n                    ans = 2;\n                } else if(res1 ==1 || res2 == 1){\n                    ans=1;\n                } else {\n                    ans = 0;\n                }\n            }\n            s++;\n            return ans;\n        }\n        default:\n            if(*s>='0'&&*s<='2'){\n                int ret = *s-'0';\n                s++;\n                return ret;\n            }\n            switch (*s) {\n                case 'P':\n                    s++;\n                    return p;\n                case 'Q':\n                    s++;\n                    return q;\n                case 'R':\n                    s++;\n                    return r;\n                default:\n                    break;\n            }\n            break;\n    }\n    return 0;\n}\nint main()\n{\n//    freopen(\"/Users/shitian/Desktop/programmingcCntest/GCJ/gcj/gcj/B-small-practice.in\", \"r\", stdin);\n//    freopen(\"/Users/shitian/Desktop/programmingcCntest/GCJ/gcj/gcj/out.txt\", \"w\", stdout);\n//    int tcase;\n//    cin>>tcase;\n//    for(int tca=1;tca<=tcase;tca++){\n//        cout<<\"Case #\"<<tca<<\": \";\n//        \n//    }\n    string str;\n    while(cin>>str){\n        if(str==\".\"){\n            break;\n        }\n        int ans=0;\n        for(p=0;p<3;p++){\n            for(q=0;q<3;q++){\n                for(r=0;r<3;r++){\n                    string::const_iterator it=str.begin();\n                    if(solve(it)==2){\n                        ans++;\n                    }\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {-1,0,1,0};\nint ty[] = {0,1,0,-1};\n\nP formula(const string &str, int pos=0);\nP factor(const string &str, int pos = 0);\nP term(const string &str, int pos = 0);\n\nP formula(const string &str, int pos){\n\tif(str[pos] == '('){\n\t\tP res1_ = formula(str,pos+1);\n\t\tpos = res1_.second;\n\t\tchar ch = str[pos];\n\t\tP res2_ = formula(str,pos+1);\n\n\t\tif(ch=='*') return P(min(res1_.first,res2_.first),res2_.second+1);\n\t\tif(ch=='+') return P(max(res1_.first,res2_.first),res2_.second+1);\n\t}\n\telse if(isdigit(str[pos])){\n\t\treturn P(str[pos]-'0',pos+1);\n\t}\n\n\telse if(str[pos] == '-'){\n\t\tP res_ = formula(str,pos+1);\n\t\tif(res_.first==0) res_.first=2;\n\t\telse if(res_.first==2) res_.first=0;\n\n\t\treturn res_;\n\t}\n}\n\n\nint main()\n{\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tif(str == \".\") break;\n\t\tint res = 0;\n\t\tfor(int p=0;p<=2;p++){\n\t\t\tfor(int q=0;q<=2;q++){\n\t\t\t\tfor(int r=0;r<=2;r++){\n\t\t\t\t\tstring tmp = str;\n\t\t\t\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\t\t\t\tif(tmp[i]=='P') tmp[i] = '0' + p;\n\t\t\t\t\t\telse if(tmp[i]=='Q') tmp[i] = '0' + q;\n\t\t\t\t\t\telse if(tmp[i]=='R') tmp[i] = '0' + r;\n\t\t\t\t\t}\n\t\t\t\t\t//P result;\n\t\t\t\t\t//result = formula(tmp,0);\n\t\t\t\t\t//printf(\"%s = %d\\n\",tmp.c_str(),result.first);\n\t\t\t\t\tif(formula(tmp,0).first == 2) res++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint minu[3]={2,1,0};\nint an[3][3]={\n  {0,0,0},{0,1,1},{0,1,2}\n};\nint o[3][3]={\n  {0,1,2},{1,1,2},{2,2,2}\n};\nint p,q,r;\n\nint solve(string s){\n  if(s==\"0\"||s==\"1\"||s==\"2\") return stoi(s);\n  if(s==\"P\") return p;\n  if(s==\"Q\") return q;\n  if(s==\"R\") return r;\n  if(s[0]=='-'){\n    return minu[solve(s.substr(1))];\n  }else{\n    int count=0;\n    for(int i=0;i<s.length();i++){\n      if(s[i]=='('){\n        count++;\n      }else if(s[i]==')'){\n        count--;\n      }\n      if(count==1&&s[i]=='*'){\n        return an[solve(s.substr(1,i-1))][solve(s.substr(i+1,s.length()-i-2))];\n      }\n      if(count==1&&s[i]=='+'){\n        return o[solve(s.substr(1,i-1))][solve(s.substr(i+1,s.length()-i-2))];\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    string s;\n    cin >> s;\n    if(s==\".\") return 0;\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          p=i,q=j,r=k;\n          if(solve(s)==2) ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nstring::iterator it;\nint P,Q,R;\n\nint formula(){\n  ++it;\n  switch(*it){\n  case '-':\n    return 2-formula();\n  case 'P':\n    return P;\n  case 'Q':\n    return Q;\n  case 'R':\n    return R;\n  case '0':\n    return 0;\n  case '1':\n    return 1;\n  case '2':\n    return 2;\n\n  case '(':\n    int form1 = formula();\n    int form2;\n\n    ++it;\n    switch(*it){\n    case '*':\n      form2 = formula();\n      ++it;\n      return min(form1,form2);\n    case '+':\n      form2 = formula();\n      ++it;\n      return max(form1,form2);\n    }\n  }\n\n  return 0;\n}\n\nint main(){\n  string str;\n\n  while(cin >> str,str != \".\"){\n    int cnt = 0;\n\n    for(int i = 0 ; i < 3 ; i++){\n      for(int j = 0 ; j < 3 ; j++){\n\tfor(int k = 0 ; k < 3 ; k++){\n\t  it = str.begin()-1;\n\t  P = i, Q = j , R = k;\n\t  if(formula() == 2) cnt++;\n\t}\n      }\n    }\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "package icpc2008_java;\n\nimport java.util.Scanner;\n\npublic class C {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\tsb.delete(i, i + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegRemove(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegate(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tcalc(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tremoveNest(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.printf(\"p,q,r = %d %d %d -> %s\\n\", p, q,\n\t\t\t\t\t\t// r,\n\t\t\t\t\t\t// f.toString());\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\n\ntypedef vector<char> P;\n\nint calc(string &a)\n{\n\tauto isNum = [](char c) {return c == '0' || c == '1' || c == '2'; };\n\tauto isOpe = [](char c) {return c == '*' || c == '+'; };\n\twhile (a.size() != 1)\n\t{\n\t\tFOR(i, a.size())\n\t\t{\n\t\t\tif (i + 1 >= a.size())continue;\n\t\t\tif (a[i] == '-'&&isNum(a[i + 1]))\n\t\t\t{\n\t\t\t\tchar c = a[i + 1];\n\t\t\t\tswitch (c)\n\t\t\t\t{\n\t\t\t\tcase '0':c = '2'; break;\n\t\t\t\tcase '2':c = '0'; break;\n\t\t\t\t}\n\t\t\t\ta[i + 1] = c;\n\t\t\t\ta.erase(a.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i + 4 >= a.size())continue;\n\t\t\tif (\n\t\t\t\ta[i] == '('\n\t\t\t\t&&isNum(a[i + 1]) \n\t\t\t\t&& isOpe(a[i + 2]) \n\t\t\t\t&& isNum(a[i + 3]) \n\t\t\t\t&& a[i + 4] == ')'\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tchar x = a[i + 1];\n\t\t\t\tchar y = a[i + 3];\n\t\t\t\tchar c;\n\t\t\t\tif (a[i + 2] == '+')\n\t\t\t\t{\n\t\t\t\t\tstring cc[3] = { \"012\",\"112\",\"222\" };\n\t\t\t\t\tc = cc[x - '0'][y - '0'];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstring cc[3] = { \"000\",\"011\",\"012\" };\n\t\t\t\t\tc = cc[x - '0'][y - '0'];\n\t\t\t\t}\n\t\t\t\ta[i + 4] = c;\n\t\t\t\tFOR(k, 4)a.erase(a.begin() + i);\n\t\t\t}\n\t\t}\n\t}\n\treturn a.front()-'0';\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tstring a;\n\t\tcin >> a;\n\t\tif (a == \".\")break;\n\t\tint ans = 0;\n\t\tFOR(p, 3)\n\t\t{\n\t\t\tFOR(q, 3)\n\t\t\t{\n\t\t\t\tFOR(r, 3)\n\t\t\t\t{\n\t\t\t\t\tstring s;\n\t\t\t\t\tFOR(i, a.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (a[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 'P':\n\t\t\t\t\t\t\ts.push_back(p + '0');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\ts.push_back(q + '0');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts.push_back(r + '0');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ts.push_back(a[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (calc(s) == 2)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nint main()\n{\n\t//真理値表\n\tchar getminus[3], getmulti[3][3], getplus[3][3];\n\tgetminus[0] = '2';\n\tgetminus[1] = '1';\n\tgetminus[2] = '0';\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (i == 0 || j == 0){\n\t\t\t\tgetmulti[i][j] = '0';\n\t\t\t}\n\t\t\telse if (i == 2 && j == 2){\n\t\t\t\tgetmulti[i][j] = '2';\n\t\t\t}\n\t\t\telse\n\t\t\t\tgetmulti[i][j] = '1';\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (i == 2 || j == 2){\n\t\t\t\tgetplus[i][j] = '2';\n\t\t\t}\n\t\t\telse if (i == 0 && j == 0){\n\t\t\t\tgetplus[i][j] = '0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tgetplus[i][j] = '1';\n\t\t}\n\t}\n\n\tstring s, inits;\n\twhile (cin >> inits, inits[0] != '.'){\n\t\tint counter = 0;\n\t\tfor (char p = '0'; p < '3'; p++){\n\t\t\tfor (char q = '0'; q < '3'; q++){\n\t\t\t\tfor (char r = '0'; r < '3'; r++){\n\t\t\t\t\ts = inits;\n\t\t\t\t\t//代入\n\t\t\t\t\tfor (int i = 0; i < (signed)s.length(); i++){\n\t\t\t\t\t\tif (s[i] == 'P'){\n\t\t\t\t\t\t\ts[i] = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[i] == 'Q'){\n\t\t\t\t\t\t\ts[i] = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[i] == 'R'){\n\t\t\t\t\t\t\ts[i] = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (s.length()>1){\n\n\t\t\t\t\t\t// \"-\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length() - 1; i++){\n\t\t\t\t\t\t\tif (s[i] == '-'&& s[i + 1] != '-' && s[i + 1] != '('){\n\t\t\t\t\t\t\t\ts[i] = getminus[(int)s[i + 1] - '0'];\n\t\t\t\t\t\t\t\ts.erase(s.begin() + i + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\"*\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length() - 4; i++){\n\t\t\t\t\t\t\tif (s[i] == '('&& s[i + 2] == '*' && s[i + 4] == ')'){\n\t\t\t\t\t\t\t\ts[i] = getmulti[(int)s[i + 1] - '0'][(int)s[i + 3] - '0'];\n\t\t\t\t\t\t\t\ts.erase(i + 1, 4);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\"+\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length() - 4; i++){\n\t\t\t\t\t\t\tif (s[i] == '('&& s[i + 2] == '+' && s[i + 4] == ')'){\n\t\t\t\t\t\t\t\ts[i] = getplus[(int)s[i + 1] - '0'][(int)s[i + 3] - '0'];\n\t\t\t\t\t\t\t\ts.erase(i + 1, 4);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (s[0] == '2'){\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter++ << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint formula(istringstream& iss)\n{\n\tchar c;\n\tiss >> c;\n\tif('0' <= c && c <= '2')\n\t\treturn c - '0';\n\tif(c == '-')\n\t\treturn 2 - formula(iss);\n\n\tint tmp1 = formula(iss);\n\tiss >> c;\n\tint tmp2 = formula(iss);\n\tif(c == '*'){\n\t\tif(tmp1 != 2 || tmp2 != 2){\n\t\t\tif(tmp1 == 0 || tmp2 == 0)\n\t\t\t\ttmp1 = 0;\n\t\t\telse\n\t\t\t\ttmp1 = 1;\n\t\t}\n\t}else{\n\t\tif(tmp1 != 0 || tmp2 != 0){\n\t\t\tif(tmp1 == 2 || tmp2 == 2)\n\t\t\t\ttmp1 = 2;\n\t\t\telse\n\t\t\t\ttmp1 = 1;\n\t\t}\n\t}\n\tiss >> c;\n\n\treturn tmp1;\n}\n\nvoid solve(string s)\n{\n\tint answer = 0;\n\tfor(int p=0; p<=2; ++p){\n\t\tfor(int q=0; q<=2; ++q){\n\t\t\tfor(int r=0; r<=2; ++r){\n\t\t\t\tstring tmp = s;\n\t\t\t\tfor(unsigned i=0; i<s.size(); ++i){\n\t\t\t\t\tif(tmp[i] == 'P')\n\t\t\t\t\t\ttmp[i] = p + '0';\n\t\t\t\t\telse if(tmp[i] == 'Q')\n\t\t\t\t\t\ttmp[i] = q + '0';\n\t\t\t\t\telse if(tmp[i] == 'R')\n\t\t\t\t\t\ttmp[i] = r + '0';\n\t\t\t\t}\n\t\t\t\tistringstream iss(tmp);\n\t\t\t\tif(formula(iss) == 2)\n\t\t\t\t\t++ answer;\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s == \".\")\n\t\t\tbreak;\n\n\t\tsolve(s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\nusing namespace std;\n\nchar CtoN[3];\nstring in;\nstring cp;\n\nbool input(){\n  cin>>in;\n  if(in==\".\")return false;\n  return true;\n}\n\nchar Not(char c){\n  switch(c){\n    case '0':\n      return '2';\n    case '1':\n      return '1';\n    case '2':\n      return '0';\n  }\n}\nchar Lpro(char a,char b){\n  return min(a,b);\n}\n\nchar Lsum(char a,char b){\n  return max(a,b);\n}\n\nchar Clac(string str){\n  if(str[0]=='('){\n    int count=1;\n    for(int i=1;i<str.size();i++){\n      if(str[i]=='('){\n        count++;\n      }else if(str[i]==')'){\n        count--;\n      }else if(count==1&&(str[i]=='+' || str[i]=='*')){\n        string str1 = str.substr(1,i-1);\n        string str2 = str.substr(i+1,str.size()-(i+1)-1);\n        if(str[i]=='+'){\n          return Lsum(Clac(str1),Clac(str2));\n        }else{\n          return Lpro(Clac(str1),Clac(str2));\n        }\n      }\n    }\n  }else if(str[0]=='-'){\n    return Not(Clac(str.substr(1)));\n  }else{\n    return str[0];\n  }\n}\n\nchar conv(char c){\n  switch(c){\n    case 'P':\n      return CtoN[0];\n    case 'Q':\n      return CtoN[1];\n    case 'R':\n      return CtoN[2];\n    default:\n      return c;\n  }\n}\n\nvoid mkcp(){\n  cp=\"\";\n  for(int i=0;i<in.size();i++){\n    cp+=conv(in[i]);\n  }\n}\n\n\nint solve(){\n  int ans=0;\n\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      for(int k=0;k<3;k++){\n        CtoN[0]=CtoN[1]=CtoN[2]='0';\n        CtoN[0]+=i;\n        CtoN[1]+=j;\n        CtoN[2]+=k;\n        mkcp();\n        if(Clac(cp)=='2'){\n          ans++;\n        }\n      }\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n  while(input()){\n    cout<<solve()<<endl;\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nint p,q,r;\n\nvoid invert(stack<int> &st){\n    int x;\n    x=st.top();\n    st.pop();\n    if(st.empty()){\n        st.push(x);\n        return;\n    }\n    while(st.top()==-1){\n        x=(x-1)*(-1)+1;\n        st.pop();\n    }\n    st.push(x);\n    return;\n}\n\nvoid calc(stack<int> &st){\n    int x,y;\n    while(true){\n        invert(st);\n        x=st.top();\n        st.pop();\n        int t=st.top();\n        if(t==-4){\n            st.pop();\n            st.push(x);\n            invert(st);\n            return;\n        }\n        else{\n            st.pop();\n            invert(st);\n            y=st.top();\n            st.pop();\n            if(t==-2){\n                st.push(max(x,y));\n            }\n            else if(t==-3){\n                st.push(min(x,y));\n            }\n        }\n       // cout << st.top() << endl;\n    }\n}\n            \n\nint main(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str[0]=='.')break;\n        stack<int> st;\n        int ans=0;\n        for(p=0;p<3;p++){\n        for(q=0;q<3;q++){\n        for(r=0;r<3;r++){\n            for(int i=0;i<str.length();i++){\n                if(str[i]=='-')st.push(-1);\n                else if(str[i]=='+')st.push(-2);\n                else if(str[i]=='*')st.push(-3);\n                else if(str[i]=='(')st.push(-4);\n                else if(str[i]=='P')st.push(p);\n                else if(str[i]=='Q')st.push(q);\n                else if(str[i]=='R')st.push(r);\n                else if(str[i]==')') calc(st);\n                else st.push((int)str[i]-48);\n            }\n            //cout << st.top();\n            if(st.top()==2)ans++;\n        }\n        }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n                "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tif(s.size()==1)return s[0];\n\tint cnt=0,f;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tV.PB(mt);\n\t\t}\n\t}\n\tif(f==0)return (char)(_and[V[0]][V[1]]+'0');\n\telse return (char)(_or[V[0]][V[1]]+'0');\n}\nchar rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\tREP(i,s.size()){\n\t\tif(s[i]=='(')pr.push(i);\n\t\tif(s[i]==')'){\n\t\t\tint top=pr.top();pr.pop();\n\t\t\tstring t;\n\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\ts.erase(top,i-top+1);\n\t\t\ts.insert(s.begin()+top,tt);\n\t\t\ti=top-1;\n\t\t}\n\t}\n\tchar tt=pyon(s,p,q,r);\n\treturn tt;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tif(rec(s,i,j,k)=='2')cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\nusing ll = long long;\nusing State = string::const_iterator;\nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\nint flip[3] = {2, 1, 0};\nint mul[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint add[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\nint expression(State &begin) {\n    int ret = term(begin);\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret = add[ret][term(begin)];\n        } else if (*begin == '*') {\n            begin++;\n            ret = mul[ret][term(begin)];\n        } else\n            break;\n    }\n    return ret;\n}\nint term(State &begin) {\n    if (*begin == '-') {\n        begin++;\n        return flip[term(begin)];\n    } else\n        return factor(begin);\n}\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else\n        return number(begin);\n}\nint number(State &begin) {\n    int ret = *begin - '0';\n    begin++;\n    return ret;\n}\n\nbool solve() {\n    string S;\n    cin >> S;\n    if (S == \".\") return false;\n    int ans = 0;\n    REP(p, 3) REP(q, 3) REP(r, 3) {\n        string tmp = S;\n        REP(i, tmp.size()) {\n            if (tmp[i] == 'P')\n                tmp[i] = '0' + p;\n            else if (tmp[i] == 'Q')\n                tmp[i] = '0' + q;\n            else if (tmp[i] == 'R')\n                tmp[i] = '0' + r;\n        }\n        State begin = tmp.begin();\n        if (expression(begin) == 2) ans++;\n    }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint add(int a, int b){\n\treturn max(a,b);\n}\n\nint mul(int a, int b){\n\treturn min(a,b);\n}\n\nint sub(int a){\n\treturn 2-a;\n}\n\nbool is_digit(char c){\n\treturn c >= '0' && c <= '9';\n}\n\nstring calc(string s, int p, int q, int r){\n\tstring ret;\n\treplace(s.begin(),s.end(),'P',char(p + '0'));\n\treplace(s.begin(),s.end(),'Q',char(q + '0'));\n\treplace(s.begin(),s.end(),'R',char(r + '0'));\n\t//cout << s << endl;\n\tfor(int i=0;i < s.size();i++){\n\t\tif(i < s.size()-2){\n\t\t\tif(s[i] == '(' && s[i+2] == ')'){\n\t\t\t\tret += s[i+1];\n\t\t\t\ti+=2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[i+1] == '+' && is_digit(s[i]) && is_digit(s[i+2])){\n\t\t\t\tret += to_string(add(int(s[i] - '0'),int(s[i+2] - '0')));\n\t\t\t\ti+=2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[i+1] == '*' && is_digit(s[i]) && is_digit(s[i+2])){\n\t\t\t\tret += to_string(mul(int(s[i] - '0'),int(s[i+2] - '0')));\n\t\t\t\ti+=2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(i < s.size()-1){\n\t\t\tif(s[i] == '-' && s[i+1] == '-'){\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[i] == '-' && is_digit(s[i+1])){\n\t\t\t\tret += to_string(sub(int(s[i+1] - '0')));\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tret += s[i];\n\t}\n\t//cout << ret << endl;\n\tif(ret.size() > 1){\n\t\treturn calc(ret, p, q, r);\n\t} else {\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s, s != \".\"){\n\t\tint ans = 0;\n\t\tfor(int p=0;p<3;p++){\n\t\t\tfor(int q=0;q<3;q++){\n\t\t\t\tfor(int r=0;r<3;r++){\n\t\t\t\t\tint x = stoi(calc(s, p, q, r));\n\t\t\t\t\tif(x == 2){\n\t\t\t\t\t\tans ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<set>\n#include<queue>\n#include<stack>\n\nusing namespace std;\n\nint add[3][3] = {\n\t\t\t{0, 1, 2},\n\t\t\t{1, 1, 2},\n\t\t\t{2, 2, 2}\n\t\t};\n\nint prod[3][3] = {\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 1, 2}\n\t\t};\n\nint minu[3] = {2, 1, 0};\n\nint P, Q, R;\n\nstring str;\n\nint eval(int &pos){\n\tif(str[pos]=='0'){ pos++; return 0; }\n\tif(str[pos]=='1'){ pos++; return 1; }\n\tif(str[pos]=='2'){ pos++; return 2; }\n\tif(str[pos]=='P'){ pos++; return P; }\n\tif(str[pos]=='Q'){ pos++; return Q; }\n\tif(str[pos]=='R'){ pos++; return R; }\n\tif(str[pos]=='-'){ pos++; return minu[eval(pos)]; }\n\tif(str[pos++]=='('){\n\t\tint a = eval(pos);\n\t\tchar op = str[pos++];\n\t\tint b = eval(pos);\n\t\tpos++;\n\t\tif(op=='+') return add[a][b];\n\t\tif(op=='*') return prod[a][b];\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> str;\n\t\tif(str==\".\") break;\n\t\tint ans=0;\n\t\tint pos=0;\n\t\tfor(P=0; P<3; P++){\n\t\t\tfor(Q=0; Q<3; Q++){\n\t\t\t\tfor(R=0; R<3; R++){\n\t\t\t\t\tint pos=0;\n\t\t\t\t\tint result = eval(pos);\n\t\t\t\t\tif(result==2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint p, q, r, pos, nn;\nstring in;\n\nint Formula();\nint Seki(int, int);\nint Wa(int, int);\nint Not(int);\nint Num();\nmain(){\n  while(1){\n   cin >> in;\n   if(in==\".\") break;\n   \n   int ans=0;\n   for(p=0;p<3;p++){\n     for(q=0;q<3;q++){\n       for(r=0;r<3;r++){\n\t pos=0;\n\t nn=0;\n\t if(Formula()==2) ans++;\n\t //\t cout << endl;\n       }\n     }\n   }\n   cout << ans << endl;\n }\n return 0;\n}\n\nint Formula(){\n  int x;\n  if(in[pos]=='('){\n    pos++;\n    x=Formula();\n    pos++;\n  }else if(in[pos]=='-'){\n    nn=0;\n    while(in[pos]=='-'){\n      nn++;\n      pos++;\n    }\n    x=Formula();\n    // printf(\"%d \", x);\n  }else{\n    x=Num();\n  }\n  if(pos<in.size()-1){\n    if(in[pos+1]=='*'){\n      pos+=2;\n      x=Seki(x, Formula());\n    }else if(in[pos+1]=='+'){\n      pos+=2;\n      x=Wa(x, Formula());\n    }\n  }\n  return x;\n}\n\nint Seki(int a, int b){\n  if(a==0){\n    return 0;\n  }else if(a==1){\n    if(b==0) return 0;\n    else return 1;\n  }else{\n    return b;\n  }\n}\n\nint Wa(int a, int b){\n  if(a==0){\n    return b;\n  }else if(a==1){\n    if(b==2) return 2;\n    else return 1;\n  }else{\n    return 2;\n  }\n}\n\nint Not(int a){\n  if(a==0) return 2;\n  if(a==2) return 0;\n  return 1;\n}\n\nint Num(){\n  int x;\n  if(in[pos]=='P'){\n    x=p;\n  }else if(in[pos]=='Q'){\n    x=q;\n  }else if(in[pos]=='R'){\n    x=r;\n  }else if(in[pos]=='0'){\n    x=0;\n  }else if(in[pos]=='1'){\n    x=1;\n  }else if(in[pos]=='2'){\n    x=2;\n  }\n  for(int i=0;i<nn;i++){\n    x=Not(x);\n  }\n  nn=0;\n  return x;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring formula;\nint parse(int P, int Q, int R, int &i){\n  int a, b;\n  switch(formula[i]){\n  case '0':\n    a = 0;\n    i++;\n    break;\n  case '1':\n    a = 1;\n    i++;\n    break;\n  case '2':\n    a = 2;\n    i++;\n    break;\n  case 'P':\n    a = P;\n    i++;\n    break;\n  case 'Q':\n    a = Q;\n    i++;\n    break;\n  case 'R':\n    a = R;\n    i++;\n    break;\n  case '-':\n    i++;\n    a = parse(P, Q, R, i);\n    a = 2 - a;\n    break;\n  case '(':\n    i++;\n    a = parse(P, Q, R, i);\n    if(formula[i] == '*'){\n      i++;\n      b = parse(P, Q, R, i);\n      i++;\n      if(a == 1 && b == 1) a = 1;\n      else a = (a * b) / 2;\n    }\n    else{\n      i++;\n      b = parse(P, Q, R, i);\n      i++;\n      if(a == 1 && b == 1) a = 1;\n      else a = 2 - (((2-a) * (2-b)) / 2);\n    }\n\n  }\n\n  return a;\n}\n\nint main(){\n  while(1){\n    cin >> formula;\n    if(formula == \".\") break;\n    int count = 0;\n    for(int i = 0; i <=2; i++){\n      for(int j = 0; j <= 2; j++){\n        for(int k = 0; k <= 2; k++){\n          int index = 0;\n          if(parse(i, j, k, index) == 2) count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint v[3],n,c;\nstring s;\n\nint f(){\n  n++;\n  int r;\n  if(s[n-1]=='(')r=f(),n++,r=s[n-1]=='+'?max(r,f()):min(r,f()),n++;\n  if(isdigit(s[n-1]))r=s[n-1]-'0';\n  if(isupper(s[n-1]))r=v[s[n-1]-'P'];\n  if(s[n-1]=='-')r=2-f();\n  return r;\n}\n\nint main(){\n  while(cin >> s,s!=\".\"){\n    c=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3)n=0,c+=f()/2;\n    cout << c << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct logical\n{\n\tvirtual int eval(int p, int q, int r) = 0;\n};\n\nstruct l_lit : public logical\n{\n\tconst int val;\n\n\tl_lit(int v) : val(v) { }\n\tint eval(int p, int q, int r) { return val; }\n};\n\nstruct l_var : public logical\n{\n\tconst char name;\n\n\tl_var(char name) : name(name) { }\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn name == 'P' ? p : (name == 'Q' ? q : r);\n\t}\n};\n\nstruct l_not : public logical\n{\n\tlogical *x;\n\n\tl_not(logical *x) : x(x) { }\n\t~l_not() { delete x; }\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn 2 - x->eval(p, q, r);\n\t}\n};\n\nstruct l_or : public logical\n{\n\tlogical *x, *y;\n\n\tl_or(logical *x, logical *y) : x(x), y(y) { }\n\t~l_or() { delete x; delete y; }\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn max(x->eval(p, q, r), y->eval(p, q, r));\n\t}\n};\n\nstruct l_and : public logical\n{\n\tlogical *x, *y;\n\n\tl_and(logical *x, logical *y) : x(x), y(y) { }\n\t~l_and() { delete x; delete y; }\n\tint eval(int p, int q, int r)\n\t{\n\t\treturn min(x->eval(p, q, r), y->eval(p, q, r));\n\t}\n};\n\nstatic string s;\nstatic int p;\n\nbool end() { return p >= (int)s.length(); }\nchar peek() { return s[p]; }\nvoid succ() { if (!end()) p++; }\n\nlogical *fomula()\n{\n\tchar c = peek();\n\tif ('0' <= c && c <= '2')\n\t{\n\t\tsucc();\n\t\treturn new l_lit(c - '0');\n\t}\n\telse if ('P' <= c && c <= 'R')\n\t{\n\t\tsucc();\n\t\treturn new l_var(c);\n\t}\n\telse if (c == '-')\n\t{\n\t\tsucc();\n\t\treturn new l_not(fomula());\n\t}\n\telse if (c == '(')\n\t{\n\t\tsucc();\n\t\tlogical *x = fomula();\n\t\tchar op = peek(); succ();\n\t\tlogical *y = fomula();\n\t\tsucc(); // ')'\n\t\tif (op == '+') return new l_or(x, y);\n\t\telse return new l_and(x, y);\n\t}\n\treturn NULL;\n}\n\nlogical *parse_fomula()\n{\n\tp = 0;\n\treturn fomula();\n}\n\nint main()\n{\n\twhile(cin>>s, s != \".\")\n\t{\n\t\tlogical *e = parse_fomula();\n\n\t\tint c = 0;\n\t\tfor (int p = 0; p <= 2; p++)\n\t\t{\n\t\t\tfor (int q = 0; q <= 2; q++)\n\t\t\t{\n\t\t\t\tfor (int r = 0; r <= 2; r++)\n\t\t\t\t{\n\t\t\t\t\tif (e->eval(p, q, r) == 2) c++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\n\t\tdelete e;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring s;\n\nint func(int P, int Q, int R) {\n    bool f = true;\n    while (f) {\n        f = false;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '(' && (s[i+2] == '+' || s[i+2] == '*')&& s[i+4] == ')') {\n                f = true;\n                int a,b,c;\n                a = s[i+1]-'0';\n                b = s[i+3]-'0';\n                c = (s[i+2]=='+'? max(a,b) : min(a,b));\n                s[i+4] = '0'+c;\n                s = s.substr(0,i) + s.substr(i+4);\n            }\n        }\n    }\n    if (s.size() == 3) return s[1]-'0';\n    else return s[0]-'0';\n}\n\nint main(void){\n    while (cin>>s && s != \".\") {\n        for (int i = 0; i < s.size()-1; i++) {\n            if (s[i] == '-' && s[i+1] == '-') s = s.substr(0,i) + s.substr(i+2);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string _s = s;\n                    for (int l = 0; l < s.size(); l++) {\n                        if (s[l] == '-') {\n                            if (s[l+1] == 'P') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'+abs(i-2); \n                            else if (s[l+1] == 'Q') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'+abs(j-2); \n                            else if (s[l+1] == 'R') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'+abs(k-2); \n                            else if (s[l+1] == '0') s = s.substr(0,l) + s.substr(l+1), s[l] = '2'; \n                            else if (s[l+1] == '1') s = s.substr(0,l) + s.substr(l+1); \n                            else if (s[l+1] == '2') s = s.substr(0,l) + s.substr(l+1), s[l] = '0'; \n                        }\n                        else if (s[l] == 'P') s[l] = '0'+i;\n                        else if (s[l] == 'Q') s[l] = '0'+j;\n                        else if (s[l] == 'R') s[l] = '0'+k;\n                    }\n                    \n                    if (func(i,j,k) == 2) ans++;\n                    s = _s;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n\n/** Problem1155 : How can I satisfy thee? Let me count the ways... **/\nstring s;\nint P, Q, R, pos;\n\nint formula()\n{\n\tchar c = s[pos++];\n\t\n\tif (c=='0'||c=='1'||c=='2') return c-'0';\n\telse if (c=='P') return P;\n\telse if (c=='Q') return Q;\n\telse if (c=='R') return R;\n\telse if (c=='-') return 2-formula();\n\telse if (c=='(') {\n\t\tchar a = formula();\n\t\tbool multi = (s[pos++]=='*');\n\t\tchar b = formula();\n\t\tpos++;\n\t\t\n\t\tif (multi) {\n\t\t\tif (a==0 || b==0)\n\t\t\t\treturn 0;\n\t\t\telse if (a==2 && b==2)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (a==0 && b==0)\n\t\t\t\treturn 0;\n\t\t\telse if (a==2 || b==2)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\twhile (cin>>s, s!=\".\") {\n\t\tint ans=0;\n\t\tfor(P=0;P<3;P++) {\n\t\t\tfor(Q=0;Q<3;Q++) {\n\t\t\t\tfor(R=0;R<3;R++) {\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (formula()==2) {\n\t\t\t\t\t\t//cerr<<\"(\"<<P<<\",\"<<Q<<\",\"<<R<<\")\"<<endl;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i,s,t ) for(int i = s; i< t ; i++)\nusing VL = vector<LL>;\n#define SZ(a) (int)a.size()\n\nvoid change(string&s, int a, int b, int c) {\n\tFOR(i, 0, SZ(s)) {\n\t\tif (s[i] == 'P') {\n\t\t\ts[i] = a + '0';\n\t\t}\n\t\tif (s[i] == 'Q') {\n\t\t\ts[i] = b + '0';\n\t\t}\n\t\tif (s[i] == 'R') {\n\t\t\ts[i] = c + '0';\n\t\t}\n\t}\n}\nstring expr1(string&, int&);\nstring expr2(string&, int&);\n\n// (だったらFを再度評価\n// -だったらFを再度評価\n// numだったらおちまい\n// ()内でしか*,+をやらない\n\nstring expr2(string &s, int &i) { // とるとこ,(だったらexpr1へ\n\tif (isdigit(s[i])) {\n\t\tstring num = string(1, s[i]);\n\t\ti++;\n\t\treturn num;\n\t}\n\tif (s[i] == '-') {\n\t\ti++;\n\t\tstring num = expr2(s, i);\n\t\tif (\"2\" == num)return \"0\";\n\t\tif (\"0\" == num)return \"2\";\n\t\tassert(num == \"1\");\n\t\treturn num;\n\t}\n\tif (s[i] == '(') {\n\t\ti++;\n\t\tstring num = expr1(s, i);\n\t\t// とってきたので、今見てるのは)\n\t\tassert(s[i] == ')');\n\t\ti++;\n\t\treturn num;\n\t}\n\t// -\n\n\treturn \"\";\n}\n\n\nstring expr1(string &s,int &i) { \n\tstring A = expr2(s, i);\n\tstring B = \"\";\n\t// いっことった\n\tint mode = 0;\n\twhile(i < SZ(s) &&(s[i] == '+' || s[i] =='*')) {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tif (op == '+') {\n\t\t\tB = expr1(s, i);\n\t\t\tmode = 1;\n\t\t}\n\t\telse if (op == '*') {\n\t\t\tB = expr1(s, i);\n\t\t\tmode = 2;\n\t\t}\n\t}\n\tstring OP = \" +*\";\n\n\t//cout << \"A:\" << A << \", \"<<OP[mode] <<\" B:\" << B << endl;\n\tif (mode == 1) {\n\t\tif (A == \"2\" || B == \"2\")return \"2\";\n\t\tif (A == \"1\" || B == \"1\")return \"1\";\n\t\treturn \"0\";\n\t}\n\telse if (mode == 2) {\n\t\tif (A == \"0\" || B == \"0\")return \"0\";\n\t\tif (A == \"1\" || B == \"1\")return \"1\";\n\t\treturn \"2\";\n\t}\n\n\treturn A;\n}\n\n\nvoid solve() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\t// p,q,r:0,1,2\n\t\tint ans = 0;\n\t\tFOR(a, 0, 2 + 1) {\n\t\t\tFOR(b, 0, 2 + 1) {\n\t\t\t\tFOR(c, 0, 2 + 1) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tchange(t, a, b, c);\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tstring res = expr1(t, i);\n\t\t\t\t\t//ut << \"res:\" << res << endl;\n\t\t\t\t\tif (\"2\" == res) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cassert>\nusing namespace std;\nstring S;\nint cur;\nint pqr[3];\nint deny[3]={2,1,0};\nint multi[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint sum[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nint formula();\nint Deny(int );\nint main(){\n  while(cin>>S&&S!=\".\"){\n    int cnt=0;\n    for(int p=0;p<=2;p++){\n      for(int q=0;q<=2;q++){\n        for(int r=0;r<=2;r++){\n          cur=0;\n          pqr[0]=p;pqr[1]=q;pqr[2]=r;\n          if(formula()==2)cnt++;\n        }\n      }\n    }\n    cout<<cnt<<endl;\n  }\n}\nint formula(){\n  if('0'<=S[cur]&&S[cur]<='2'){\n    return (int)(S[cur++]-'0');\n  }else if('P'<=S[cur]&&S[cur]<='R'){\n    return pqr[(int)(S[cur++]-'P')];\n  }else if(S[cur]=='-'){\n    cur++;\n    return Deny(formula());\n  }else{\n    assert(S[cur++]=='(');\n    int left=formula();\n    char op=S[cur++];\n    // cout<<\"op==\"<<op<<endl;\n    assert(op=='+'||op=='*');\n    \n    int right=formula();\n    assert(S[cur]==')');\n    cur++;\n    return (op=='+')?sum[left][right]:multi[left][right];\n  }\n}\nint Deny(int a){\n  assert(0<=a&&a<=2);\n  return deny[a];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring str;\nint p;\n\nint negate_(int f) { return 2 - f; }\n\nint add(int a, int b) {\n  if (a == 2 || b == 2) {\n    return 2;\n  } else if (a == 0 && b == 0) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint mult(int a, int b) {\n  if (a * b == 0) {\n    return 0;\n  } else if (a * b == 4) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nint P, Q, R;\n\nint term(char c) {\n  switch (c) {\n    case 'P':\n     return P;\n    case 'Q':\n      return Q;\n    case 'R':\n      return R;\n  }\n}\n\nint formula() {\n  if (str[p] == '-') {\n    p++; // read -\n    int f = formula();\n    return negate_(f);\n  } else if (isdigit(str[p])) {\n    int f = str[p] - '0';\n    p++; // read [0-2]\n    return f;\n  } else if (isalpha(str[p])) {\n    int f = term(str[p]);\n    p++; // read [P-R]\n    return f;\n  } else {\n    p++; // read (\n    int a = formula();\n    if (str[p] == '*') {\n      p++; // read *\n      int b = formula();\n      p++; // read )\n      return mult(a, b);\n    } else {\n      p++; // read +\n      int b = formula();\n      p++; // read )\n      return add(a, b);\n    }\n  }\n}\n\nint main() {\n  while (cin >> str and str != \".\") {\n    p = 0;\n    int ans = 0;\n    for (P = 0; P < 3; P++) \n      for (Q = 0; Q < 3; Q++)\n        for (R = 0; R < 3; R++)\n          if (p = 0, formula() == 2) \n            ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 200005\nint N, M;\nint dp[MAX];\nbool taked[MAX];\n// expr +\n// term *\nint P, Q, R;\nint number(string& s, int& i);\nint factor(string& s, int& i);\nint not_calc(string& s, int& i);\nint term(string& s, int& i);\nint expr(string& s, int& i);\n\nint number(string& s, int& i) {\n\tint res;\n\tswitch (s[i]) {\n\tcase 'P': res = P; break;\n\tcase 'Q': res = Q; break;\n\tcase 'R': res = R; break;\n\tdefault: res = s[i] - '0';\n\t}\n\ti++;\n\tif (test) {\n\t\tdump(i);\n\t\tfprintf(stderr, \"number \");\n\t\tdump(res);\n\t}\n\treturn res;\n}\nint factor(string& s, int& i) {\n\tif (s[i] != '(') return number(s, i);\n\ti++;\n\tint ret = expr(s, i);\n\ti++;\n\tif (test) {\n\t\tfprintf(stderr, \"factor : \");\n\t\tdump(ret);\n\t}\n\treturn ret;\n}\n\nint not_calc(string& s, int& i) {\n\tint val;\n\tint cnt = 0;\n\twhile (s[i] == '-') {\n\t\tcnt++;\n\t\ti++;\n\t}\n\tval = factor(s, i);\n\tif (cnt % 2) {\n\t\tval = 2 - val;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"not_calc \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint term(string& s, int& i) {\n\tint val = not_calc(s, i);\n\twhile (s[i] == '*') {\n\t\ti++;\n\t\tint val2 = not_calc(s, i);\n\t\tif (val == 0 || val2 == 0) val = 0;\n\t\telse if (val == 0 || val2 == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"term \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\nint expr(string& s, int& i) {\n\tint val = term(s, i);\n\twhile (s[i] == '+') {\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (val == 2 || val2 == 2) val = 2;\n\t\telse if (val == 1 || val == 1) val = 1;\n\t}\n\tif (test) {\n\t\tfprintf(stderr, \"sum \");\n\t\tdump(val);\n\t}\n\treturn val;\n}\n\n\nsigned main(void)\n{\n\tint i, j, k;\n\n\twhile (1) {\n\t\tstring s;\n\t\tint cnt = 0;\n\t\tcin >> s;\n\t\tif (s == \".\") return 0;\n\t\t//i = 0;\n\t\t//P = 0; Q = 0; R = 0;\n\t\t//expr(s, i);\n\t\trep(P, 3) rep(Q, 3) rep(R, 3) {\n\t\t\t//dump(P);\n\t\t\t//dump(Q);\n\t\t\t//dump(R);\n\t\t\ti = 0;\n\t\t\tif (expr(s, i) == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2},\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2},\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tr = 2-r;\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tl = 2-l;\n\t\t\tst.pop();\n\t\t\t\n\t\t\tint tmp;\n\t\t\tif(o == '*')\n\t\t\t\ttmp = AND[r][l];\n\t\t\telse\n\t\t\t\ttmp = OR[r][l];\n\t\t\t\t\n\t\t\tfor(m=0; !st.empty() && st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\ttmp = 2-tmp;\n\n\t\t\tst.push((char)(tmp+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\n\tint tmp = conv(st.top(), P, Q, R);\n\tst.pop();\n\tint m;\n\tfor(m=0; !st.empty() && st.top()=='-'; m++)\n\t\tst.pop();\n\tif(m%2)\n\t\ttmp = 2-tmp;\n\n\tif(tmp == 2)\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint formula();\nvoid input();  // 終了処理有り\nvoid chkRPar();\nint expression();\nint calcPlus(int, int);\nint calcMul(int, int);\n\nchar ch;\nint pos;\nstring str;\nint P, Q, R;\nint nFlg = 1;  // 1 or -1 をformulaに掛ける。VARIABLEが来て初期化 1\n\nint main(void) {\n  int cnt, res;\n\n  while(1) {\n    cnt = 0;\n    getline(cin, str);\n    cout << str << endl;\n    for(P = 0; P < 3; P++) {\n      for(Q = 0; Q < 3; Q++) {\n\tfor(R = 0; R < 3; R++) {\n\t  pos = 0;\n\t  res = expression();\n\t  if(res == -1) return 0;\n\t  if(res == 2) cnt++;\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}\n\nvoid chkRPar() {\n  input();\n}\nvoid input() {\n  ch = str[pos++];\n  // cout << \"---\" << ch << endl;\n}\n\nint expression() {\n  int res = 0;\n  \n  input();\n  if (ch == '.') return -1;\n\n  switch (ch) {\n  case '(':\n    res = expression();\n    input();\n    switch(ch) {\n    case '+':\n      res = calcPlus(res, expression());\n      break;\n    case '*':\n      res = calcMul(res, expression());\n      break;\n    }\n    chkRPar();\n    break;\n\n  default:\n    switch(ch) {\n    case '-':\n      res = 2 - expression();\n      break;\n    default:\n      res = formula();\n    }\n    break;\n  }\n\n  return res;\n}\n\nint formula() {\n\n  if(isdigit(ch)) return ch - '0';\n\n  switch(ch) {\n  case 'P': return P;\n  case 'Q': return Q;\n  case 'R': return R;\n  }\n}\n\nint calcPlus(int d1, int d2) {\n  switch(d1) {\n  case 0:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 2;\n    }\n\n  case 1:\n    switch(d2) {\n    case 0: return 1;\n    case 1: return 1;\n    case 2: return 2;\n    }\n\n  case 2:\n    switch(d2) {\n    case 0: return 2;\n    case 1: return 2;\n    case 2: return 2;\n    }\n  }\n}\n\nint calcMul(int d1, int d2) {\n  switch(d1) {\n  case 0:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 0;\n    case 2: return 0;\n    }\n\n  case 1:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 1;\n    }\n\n  case 2:\n    switch(d2) {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 2;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define fr first\n#define sc second\n\nusing namespace std;\n\ntypedef pair<const char*,int> parsed;\n\nconst int retmns[]     = {2,1,0};\nconst int retmul3[][3] = {{0,0,0},{0,1,1},{0,1,2}}; \nconst int retadd3[][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nparsed fomula(parsed p){\n  if(isdigit(*(p.fr))){\n    return parsed(p.fr+1, *(p.fr)-'0');\n  }\n  if(*(p.fr) == '('){\n    parsed a = fomula(make_pair(p.fr+1,0));\n    parsed b = fomula(make_pair(a.fr+1,0));\n    if( *(a.fr) == '*' ) return parsed( b.fr+1, retmul3[a.sc][b.sc] );\n    else return parsed(b.fr+1, retadd3[a.sc][b.sc]);\n  }\n  if(*(p.fr) == '-'){\n    parsed a = fomula(make_pair(p.fr+1,0));\n    return parsed(a.fr, retmns[a.sc] );\n  }\n}\n\nint main(){\n  while(true){\n    int ans = 0;\n    string s;\n    cin >> s;\n    if(s==\".\")break;\n    for(int p = 0; p < 3; ++p){\n      for(int q = 0; q < 3; ++q){\n\tfor(int r = 0; r < 3; ++r){\n\t  string t=s;\n\t  for(int l = 0; l < t.length(); ++l){\n\t    if(t[l]=='P')t[l]='0'+p;\n\t    if(t[l]=='Q')t[l]='0'+q;\n\t    if(t[l]=='R')t[l]='0'+r;\n\t  }\n\t  int ret = fomula( parsed(t.c_str(),0) ).sc;\n\t  //cout << \"EXPRESSION : \" <<  t << \" = \" << ret << endl;\n\t  if( ret == 2 ) ++ans;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n//構文を実際に計算する\nbool play(string s) {\n\tstack<char> info;\n\tfor (const char& c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(const string& formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstring pre,s;\nint now;\nint func(){\n\tif(s[now]=='0'){\n\t\tnow++;\n\t\treturn 0;\n\t}else if(s[now]=='1'){\n\t\tnow++;\n\t\treturn 1;\n\n\t}else if(s[now]=='2'){\n\t\tnow++;\n\t\treturn 2;\n\t}else if(s[now]=='-'){\n\t\tnow++;\n\t\treturn 2-func();\n\t}else if(s[now]=='('){\n\t\tnow++;\n\t\tint a=func();\n\t\tif(s[now]=='+'){\n\t\t\tnow++;\n\t\t\tint b=func();\n\t\t\tnow++;\n\t\t\treturn max(a,b);\n\t\t}else if(s[now]=='*'){\n\t\t\tnow++;\n\t\t\tint b=func();\n\t\t\tnow++;\n\t\t\treturn (a*b+1)/2;\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>pre,pre!=\".\"){\n\t\tint ans=0;\n\t\tfor(int x=0;x<=2;x++)\n\t\tfor(int y=0;y<=2;y++)\n\t\tfor(int z=0;z<=2;z++){\n\t\t\ts=pre;\n\t\t\tnow=0;\n\t\t\tfor(int i=0;i<(int)s.size();i++){\n\t\t\t\tif(s[i]=='P')\n\t\t\t\t\ts[i]='0'+x;\n\t\t\t\telse if(s[i]=='Q')\n\t\t\t\t\ts[i]='0'+y;\n\t\t\t\telse if(s[i]=='R')\n\t\t\t\t\ts[i]='0'+z;\n\t\t\t}\n\t\t\tif(func()==2)\n\t\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint p,q,r;\n\nchar perse(string x){\n  string tmp;\n  int n,c;\n  char op,a,b;\n  if(x[0] == '-'){\n    x.erase(x.begin());\n    return '0' + '2' - perse(x);\n  }\n  if(x[0] == '('){\n    tmp.clear();\n    n = 1;\n    c = 0;\n    while( c || (x[n] != '+' && x[n] != '*') ){\n      if(x[n] == '(')c++;\n      if(x[n] == ')')c--;\n      tmp.push_back(x[n]);\n      n++;\n    }\n    a = perse(tmp);\n    op = x[n];\n\n    tmp.clear();\n    n++;\n    while( c || x[n] != ')' ){\n      if(x[n] == '(')c++;\n      if(x[n] == ')')c--;\n      tmp.push_back(x[n]);\n      n++;\n    }\n    b = perse(tmp);\n\n    if(op == '+'){\n      if(a=='2' || b=='2')return '2';\n      else if(a=='1' || b=='1')return '1';\n      else return '0';\n    }else if(op == '*'){\n      if(a=='0' || b=='0')return '0';\n      else if(a=='1' || b=='1')return '1';\n      else return '2';\n    }\n  }\n\n  if(x[0] == 'P')return '0' + p;\n  if(x[0] == 'Q')return '0' + q;\n  if(x[0] == 'R')return '0' + r;\n\n  return x[0];\n}\n \nint main(){\n\n  int c;\n  string s;\n\n  while(1){\n    cin >> s;\n    if(s==\".\")break;\n\n    c = 0;\n    for(p=0;p<3;p++){\n      for(q=0;q<3;q++){\n\tfor(r=0;r<3;r++){\n\t  if(perse(s) == '2')c++;\n\t}\n      }\n    }\n\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define State string::const_iterator\nclass ParseError {};\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\nint not_operator(State &begin);\nvoid consume(State &begin, char expected);\n\nint R,P,Q;\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n    int ret = term(begin);\n\n    /*\n    while(true){\n        \n        if(*begin == '-'){\n            consume(begin, '-');\n            ret -= term(begin);\n        }\n        else{\n            break;\n        }\n    }\n    */\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State &begin) {\n    int ret = factor(begin);\n    \n    while(true){\n        if(*begin == '*'){\n            consume(begin, '*');\n            ret = min(ret, factor(begin));\n        }\n        else if(*begin == '+'){\n            consume(begin, '+');\n            ret = max(ret, factor(begin));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n    int ret = 0;\n\n    if(*begin=='R'){\n        consume(begin, 'R');\n        return R;\n    }\n    else if(*begin=='P'){\n        consume(begin, 'P');\n        return P;\n    }\n    else if(*begin=='Q'){\n        consume(begin, 'Q');\n        return Q;\n    }\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        int ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    }\n    else {\n        return not_operator(begin);\n    }\n}\n\nint not_operator(State &begin){\n    if(*begin == '-'){\n        consume(begin, '-');\n        int ret = factor(begin);\n        if(ret == 2){\n            ret = 0;\n        }\n        else if(ret == 0){\n            ret = 2;\n        }\n        //cout << *begin << \" \" << ret << endl;\n        return ret;\n    }\n    return number(begin);\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true){\n\n        string input;\n\n        cin >> input;\n\n        if(input[0] == '.'){\n            break;\n        }\n\n        int count = 0;\n\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                for(int k=0; k<3; k++){\n                    R = i;\n                    P = j;\n                    Q = k;\n                    // cout << R << \" \" << P << \" \" << Q << endl;\n                    State s = input.begin();\n                    int culc = expression(s);\n                    // cout << culc << endl;\n                    if(culc == 2){\n                        count++;\n                    }\n                }\n            }\n        }\n        cout << count << endl;\n       \n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n \n#define INF 100000000\n#define EPS 1e-9\n \nusing namespace std;\n \ntypedef long long ll;  \n\nint P, Q, R;\nstring str, tmpStr;\n\nint myNot[] = {2,1,0};\nint myAnd[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint myOr[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nvector<int> ans_list;\n\n//左から何番目を基準にしているか\nbool solve(int num){\n\n  for(int i = num + 1; i < tmpStr.length(); i++){\n    if(tmpStr[i] == '('){\n      solve(i);\n      break;\n    }\n    else if(tmpStr[i] == ')'){\n      int mai = 0; //マイナスが何回現れたか\n      int left = -1;\n      int right = -1; //左と右の数字\n      int ope = -1; //1:ans 2:or\n      for(int k = num+1; k < i; k++){\n\tif(tmpStr[k] == '-')\n\t  mai++;\n\telse if(tmpStr[k] == '*')\n\t  ope = 1;\n\telse if(tmpStr[k] == '+')\n\t  ope = 2;\n\telse{\n\t  mai %= 2;\n\t  int tmp = tmpStr[k] - '0';\n\t  if(mai == 1)\n\t    tmp = myNot[tmp];\n\t  if(left == -1)\n\t    left = tmp;\n\t  else\n\t    right = tmp;\n\t  mai = 0;\n\t}\n      }\n      int tmp = -1;\n      if(ope == 1)\n\ttmp = myAnd[left][right];\n      else\n\ttmp = myOr[left][right];\n      tmpStr.erase(num,i - num + 1);\n      tmpStr.insert(tmpStr.begin() + num, tmp + '0'); \n      break;\n    }\n  }\n\n  //文字の長さが1なら、それが2になっているかの判定\n  if(tmpStr.length() == 1){\n    if(tmpStr == \"2\")\n      return true;\n    else\n      return false;\n  }\n  \n  return false;\n\n}\n\nint main(){\n\n  while(true){\n    \n    cin >> str;\n    if(str == \".\")\n      break;\n\n    int ans = 0;\n    for(int i = 0; i < 27; i++){\n      P = i%3;\n      Q = (i/3)%3;\n      R = (i/9)%3;\n      tmpStr.clear();\n      tmpStr = str;\n      \n      for(int i = 0; i < tmpStr.length(); i++){\n\tif(tmpStr[i] == 'P')\n\t  tmpStr[i] = P + '0';\n\telse if(tmpStr[i] == 'Q')\n\t  tmpStr[i] = Q + '0';\n\telse if(tmpStr[i] == 'R')\n\t  tmpStr[i] = R + '0';\n      }\n\n      while(true){\n\tif(tmpStr.length() != 1)\n\t  solve(0);\n\telse\n\t  break;\n      }\n\n      if(solve(0))\n\tans++;\n\n    }\n\n    ans_list.push_back(ans);\n\n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n\nint val[200];\n\n\nint analysis(string str){\n\tif(str == \"P\")\n\t\treturn val['P'];\n\telse if(str == \"Q\"){\n\t\treturn val['Q'];\n\t}\n\telse if(str == \"R\"){\n\t\treturn val['R'];\n\t}\n\telse if(str == \"0\" || str == \"1\" || str == \"2\")\n\t\treturn str[0] - '0';\n\n\t// ツ環古環づーツ偲ヲツづィツ渉慊つュ\n\tif(str[0] == '('){\n\t\tint cnt = 1;\n\t\tfor(int i = 1; i < str.size(); i++){\n\t\t\tif(str[i] == '(')\n\t\t\t\tcnt++;\n\t\t\telse if(str[i] == ')'){\n\t\t\t\tcnt--;\n\t\t\t\t//if(cnt == 0 && str.size()-1 != i){\n\t\t\t\t//\tbreak;\n\t\t\t\t//}\n\t\t\t\t//else if(cnt == 0 && i == str.size()-1){\n\t\t\t\t//\treturn analysis(str.substr(1,str.size()-2));\n\t\t\t\t//}\n\t\t\t}\n\t\t\tif(cnt == 1 && str[i] == '*'){\n\t\t\t\tint v1 = analysis(str.substr(1,i-1));\n\t\t\t\tint v2 = analysis(str.substr(i+1,str.size()-2-i));\n\t\t\t\tif(v1 == 0 || v2 == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(v1 == 1 || v2 == 1)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse if(cnt == 1 && str[i] == '+'){\n\t\t\t\tint v1 = analysis(str.substr(1,i-1));\n\t\t\t\tint v2 = analysis(str.substr(i+1,str.size()-2-i));\n\t\t\t\tif(v1 == 0 && v2 == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(v1 == 1 && v2 != 2)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if(v2 == 1 && v1 != 2)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\telse if(str[0] == '-'){\n\t\tint v2 = analysis(str.substr(1));\n\t\tif(v2 == 0)\n\t\t\treturn 2;\n\t\telse if(v2 == 1)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n}\n\nint main(){\n\tstring str;\n\twhile(cin >> str && str != \".\"){\n\t\tint cnt =0;\n\t\tfor(int P = 0; P <= 2; P++){\n\t\t\tfor(int Q = 0; Q <= 2; Q++){\n\t\t\t\tfor(int R = 0; R <= 2; R++){\n\t\t\t\t\tval['P'] = P;\n\t\t\t\t\tval['Q'] = Q;\n\t\t\t\t\tval['R'] = R;\n\t\t\t\t\tif(analysis(str) == 2)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint check(char op, int x, int y) {\n    switch (op) {\n    case '*':\n        if (x == 2 && y == 2) return 2;\n        return x & y;\n    case '+':\n        if (x == 2 || y == 2) return 2;\n        return x | y;\n    }\n    assert(0);\n}\n\nint formula(string& form, int& idx) {\n    switch (form[idx]) {\n    case '0':\n    case '1':\n    case '2':\n        return form[idx] - '0';\n    case '-':\n        return 2 - formula(form, ++idx);\n    case '(':\n        int x = formula(form, ++idx);\n        char op = form[++idx];\n        int y = formula(form, ++idx);\n        ++idx;\n        return check(op, x, y);\n    }\n    assert(0);\n}\n\nint solve(string line, int p, int q, int r) {\n    REP(i, line.length()) {\n        switch (line[i]) {\n        case 'P':\n            line[i] = p + '0';\n            break;\n        case 'Q':\n            line[i] = q + '0';\n            break;\n        case 'R':\n            line[i] = r + '0';\n            break;\n        }\n    }\n    int idx = 0;\n    return formula(line, idx);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \".\") {\n            break;\n        }\n\n        int n = 0;\n        REP(p, 3) REP(q, 3) REP(r, 3) {\n            if (solve(line, p, q, r) == 2) {\n                n++;\n            }\n        }\n        cout << n << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n \n#define REP(i,b,n) for(int i=b;i<n;++i)\n#define REPR(i,b,n) for(int i=n-1;i>=b;--i)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\nstatic const int LIM = 2000000;\n\nstring s;\nint var[3];\n\nint parse(int x){\n\t\n\tif( '0' <= s[x] && s[x] <= '2' ){\n\t\treturn s[x] - '0';\n\t}\n\tif( 'P' <= s[x] && s[x] <= 'R'){\n\t\treturn var[s[x]-'P'];\n\t}\n\tif( s[x] == '-'){\n\t\treturn 2-parse(x+1);\n\t}\n\t\n\tif( s[x] == '(' ){\n\t\t\n\t\tint y = x+1, par = 0;\n\t\t\n\t\twhile(1){\n\t\t\t\n\t\t\tif(s[y] == '('){\n\t\t\t\tpar++;\n\t\t\t}\n\t\t\telse if(s[y] ==')'){\n\t\t\t\tpar--;\n\t\t\t}\n\t\t\t\n\t\t\tif( (s[y] == '*' || s[y] == '+') && par==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ty++;\n\t\t}\n\t\t\n\t\tif(s[y]=='*'){\n\t\t\treturn min(parse(x+1), parse(y+1));\n\t\t}\n\t\telse{\n\t\t\treturn max(parse(x+1), parse(y+1));\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin >> s, s[0]!='.'){\t\n\t\t\n\t\tint cnt = 0;\n\t\t\n\t\tfor(var[0]=0; var[0]<3; ++var[0]){\n\t\t\tfor(var[1]=0; var[1]<3; ++var[1]){\n\t\t\t\tfor(var[2]=0; var[2]<3; ++var[2]){\n\t\t\t\t\t\n\t\t\t\t\tcnt += parse(0) == 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << cnt << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntypedef string::const_iterator State;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstring in;\nmap<char, int> mp;\n\nint f(State &itr) {\n    //cerr << *itr << endl;\n    int now;\n        if(*itr <= '2' && *itr >= '0') {\n            now = (int)(*itr - '0');\n            itr++;\n            return now;\n        }\n        if(*itr <= 'R' && *itr >= 'P') {\n            now = mp[*itr];\n            itr++;\n            return now;\n        }\n        if(*itr == '-') {\n            itr++;\n            return 2 - f(itr);\n        }\n        if(*itr == '(') {\n            itr++;\n            now = f(itr);\n            char ope = *itr;\n            itr++;\n            int now2 = f(itr);\n            itr++;\n            if(ope == '*') return min(now, now2);\n            else return max(now, now2);\n        }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> in;\n        if(in == \".\") break;\n        State itr = in.begin();\n        int ans = 0;\n        for(mp['P'] = 0; mp['P'] <= 2; mp['P']++) {\n            for(mp['Q'] = 0; mp['Q'] <= 2; mp['Q']++) {\n                for(mp['R'] = 0; mp['R'] <= 2; mp['R']++) {\n                    itr = in.begin();\n                    int ret = f(itr);\n                    //cerr << mp['P'] << \" \" << mp['Q'] << \" \" << mp['R'] << \" \" << ret << endl;\n                    if(ret == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tswitch (T[pos++]) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '-': return 2 - solve();\n\t\tcase '(':\n\t\t\tint a = solve();\n\t\t\tswitch (T[pos++]) {\n\t\t\t\tcase '+': a = max(a, solve()); break;\n\t\t\t\tcase '*': a = min(a, solve()); break;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn a;\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nint n;\nstring s;\n\nint getValue(int v, int i) {\n    if(i == 0) return v%3;\n    if(i == 1) return (v/3)%3;\n    if(i == 2) return (v/9)%3;\n    assert(false);\n}\n\nbool isNum(int i) {\n    return s[i] >= '0' && s[i] <= '9';\n} \nbool isAlpha(int i) {\n    return s[i] >= 'A' && s[i] <= 'Z';\n}\n\nint fomula(int& i, int v) {\n    if(i == n) assert(false);\n    if(isNum(i)) return s[i++] - '0';\n    if(isAlpha(i)) return getValue(v, s[i++] - 'P');\n    if(s[i] == '-') return 2 - fomula(++i, v);\n    assert(s[i] == '(');\n    ++i;\n    int x = fomula(i, v);\n    char op = s[i++];\n    int y = fomula(i, v);\n    assert(s[i] == ')');\n    ++i;\n    if(op == '+') return max(x, y);\n    else if(op == '*') return min(x, y);\n    else assert(false);\n    assert(false);\n}\n\nint main(){\n    while(cin >> s) {\n        if(s == \".\") break;\n        n = s.size();\n        int ans = 0;\n        rep(i, 27) {\n            int id = 0;\n            if(fomula(id, i) == 2) ++ans;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring repr(string s,int p,int q,int r){\n  int tmp;\n  string s_tmp=s;\n  while ((tmp = s_tmp.find(\"P\")) >= 0){s_tmp.replace(s_tmp.find(\"P\"),1,to_string(p));}\n  while ((tmp = s_tmp.find(\"Q\")) >= 0){s_tmp.replace(s_tmp.find(\"Q\"),1,to_string(q));}\n  while ((tmp = s_tmp.find(\"R\")) >= 0){s_tmp.replace(s_tmp.find(\"R\"),1,to_string(r));}\n  return s_tmp;\n}\n\nstring op_plus(string left,string right){\n  int l,r;\n  if (left[0]=='-'){l=2-(left[1]-'0');}\n  else {l=left[0]-'0';}\n  if (right[0]=='-'){r=2-(right[1]-'0');}\n  else {r=right[0]-'0';}\n  return to_string(max(l,r));\n}\n\nstring times(string left,string right){\n  int l,r;\n  if (left[0]=='-'){l=2-(left[1]-'0');}\n  else {l=left[0]-'0';}\n  if (right[0]=='-'){r=2-(right[1]-'0');}\n  else {r=right[0]-'0';}\n  return to_string(min(l,r));\n}\n\nstring solve(string str){\n  while (str.substr(0,2) == \"--\"){str.erase(str.begin(),str.begin()+2);}\n  if (str.length() == 1||str.length() == 2){\n    if (str == \"0\"){\n      return \"0\";\n    } else if (str == \"1\"){\n      return \"1\";\n    } else if (str == \"2\"){\n      return \"2\";\n    } else if (str == \"-0\"){\n      return \"2\";\n    } else if (str == \"-1\"){\n      return \"1\";\n    } else if (str == \"-2\"){\n      return \"0\";\n    } else {\n      cout << str << \" :Error\" << endl;\n      return \"-1\";\n    }\n  }\n  if (str[0] == '(') {\n    str.erase(str.begin());\n    str.pop_back();\n  }\n  int brcount = 0;\n  int ind = 0;\n  while (ind < str.length()){\n    if (str[ind] == '('){++brcount;}\n    if (str[ind] == ')'){--brcount;}\n    if ((brcount == 0)&&(str[ind] == '+' || str[ind] == '*')) break;\n    ++ind;\n  }\n  if (ind == str.length()-1){\n    cout << \"search error\" << endl;\n    return \"-1\";\n  }\n  string left,right;\n  left = solve(str.substr(0,ind));\n  right = solve(str.substr(ind+1,str.length()-(ind+1)));\n  if (str[ind] == '+'){\n    return op_plus(left,right);\n  }\n  if (str[ind] == '*'){\n    return times(left,right);\n  }\n}\n\nint main(){\n  string s,s_tmp;\n  int sum;\n  while (1){\n    cin >> s;\n    if (s == \".\") {\n      break;\n    }\n    sum = 0;\n    for (int p=0;p<3;p++){\n      for (int q=0;q<3;q++){\n        for (int r=0;r<3;r++){\n          s_tmp = repr(s,p,q,r);\n          if (solve(s_tmp) == \"2\" ){++sum;}\n        }\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint v[3],n;\nstring s;\n\nint f(){\n  n++;\n  if(s[n-1]=='('){\n    int res=f();\n    n++;\n    if(s[n-1]=='+')res=max(res,f());\n    if(s[n-1]=='*')res=min(res,f());\n    n++;\n    return res;\n  }\n  if(isdigit(s[n-1]))return s[n-1]-'0';\n  if(isupper(s[n-1]))return v[s[n-1]-'P'];\n  if(s[n-1]=='-')return 2-f();\n}\n\nint main(){\n  while(cin >> s,s!=\".\"){\n    int cnt=0;\n    rep(v[0],3)rep(v[1],3)rep(v[2],3)n=0,cnt+=f()/2;\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cctype>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring s, s2;\nsize_t cur;\n\nstring change_string(const string &s, int i, int j, int k){\n  int size = s.size();\n  string s1;\n  for(int l = 0; l < size; l++){\n    if(s[l] == 'P'){\n      s1.push_back(char('0' + i));\n    }else if(s[l] == 'Q'){\n      s1.push_back(char('0' + j));\n    }else if(s[l] == 'R'){\n      s1.push_back(char('0' + k));\n    }else{\n      s1.push_back(s[l]);\n    }\n  }\n  return s1;\n}\n\nint formula(){\n  if(isdigit(s2[cur])){\n    return s2[cur++] - '0';\n  }else if(s2[cur] == '-'){\n    cur++;\n    assert(cur < s2.size());\n    return 2 - formula();\n  }else{\n    assert(s2[cur] == '(');\n    cur++;\n    int a = formula();\n    char op = s2[cur++];\n    assert(cur < s2.size());\n    int b = formula();\n    cur++;\n    if(op == '+'){\n      return max(a, b);\n    }else{\n      return min(a, b);\n    }\n  }\n}\n    \n\nint main(){\n  while(cin >> s && s != \".\"){\n    int count = 0;\n    for(int i = 0; i <= 2; i++){\n      for(int j = 0; j <= 2; j++){\n\tfor(int k = 0; k <= 2; k++){\n\t  cur = 0;\n\t  s2 = change_string(s, i, j, k);\n\t  if(formula() == 2) count++;\n\t}\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll INF=2e18;\n\nmap<char,int> mp;\ntypedef string::const_iterator SC;\nstring s;\n\nll NumParse(SC& it){\n    ll ret;\n    if(isdigit(*it)){\n        ret=*it-'0';\n    }else{\n        ret=mp[*it];\n    }\n    it++;\n    return ret;\n}\nll Form(SC &it){\n    if(*it=='-'){\n        it++;\n        return 2-Form(it);\n    }else if(*it=='('){\n        it++;\n        ll l=Form(it);\n        char op=*it;\n        it++;\n        ll r=Form(it);\n        ll ret;\n        if(op=='+'){\n            if(l==1 && r==1){\n                ret=1;\n            }else{\n                ret=min(2LL,l+r);\n            }\n        }else{\n            ret=(l*r+1)/2;\n        }\n        it++;\n        return ret;\n    }else{\n        return NumParse(it);\n    }\n}\nint main(){\n    while(cin>>s,s[0]!='.'){\n        ll ans=0;\n        ll a,b,c;\n        /*for(ll i=0;i<27;i++){\n        cin>>a>>b>>c;\n        mp['P']=a;\n        mp['Q']=b;\n        mp['R']=c;\n        SC it=s.begin();\n        cout<<Form(it)<<endl;\n        }*/\n\n        for(ll i=0;i<3;i++)\n            for(ll j=0;j<3;j++)\n                for(ll k=0;k<3;k++){\n                    mp['P']=i;\n                    mp['Q']=j;\n                    mp['R']=k;\n                    SC it=s.begin();\n                    if(Form(it)==2){\n                        ans++;\n                    }\n                }\n        cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n\nusing namespace std;\n\ntypedef string::const_iterator state;\n\nint p,q,r;\n\nint expression(state &begin);\nint term(state &begin);\nint number(state &begin);\nint factor(state &begin);\n\nint number(state &begin){\n\tint ans;\n\tif(*begin=='0'){\n\t\tans =0;\n\t}\n\tif(*begin=='1'){\n\t\tans =1;\n\t}\n\tif(*begin=='2'){\n\t\tans =2;\n\t}\n\tif(*begin=='P'){\n\t\tans =p;\n\t}\n\tif(*begin=='Q'){\n\t\tans =q;\n\t}\n\tif(*begin=='R'){\n\t\tans =r;\n\t}\n\tbegin++;\n\treturn ans;\n}\n\nint factor(state &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ans = expression(begin);\n\t\tbegin++;\n\t\treturn ans;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(state &begin){\n\tint ans;\n\tint t=0;\n\twhile(*begin=='-'){\n\t\tt+=1;\n\t\tbegin++;\n\t}\n\tans = factor(begin);\n\tif(t%2==0)return ans;\n\treturn 2-ans;\n}\n\nint expression(state &begin){\n\tint ans = term(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tint ans2 = term(begin);\n\t\t\tif(ans==0||ans2==0){\n\t\t\t\tans = 0;\n\t\t\t}else if(ans==1||ans2==1){\n\t\t\t\tans = 1;\n\t\t\t}else{\n\t\t\t\tans = 2;\n\t\t\t}\n\t\t}else if(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tint ans2 = term(begin);\n\t\t\tif(ans==2||ans2==2){\n\t\t\t\tans = 2;\n\t\t\t}else if(ans==1||ans2==1){\n\t\t\t\tans = 1;\n\t\t\t}else{\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin >> s&&s!=\".\"){\n\t\tint ans = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tp=i;\n\t\t\t\t\tq=j;\n\t\t\t\t\tr=k;\n\t\t\t\t\tstate begin =s.begin();\n\t\t\t\t\tif(expression(begin)==2){\n\t\t\t\t\t\tans +=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<stack>\n#include<queue>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint NOT(int x){ return 2-x; }\nint AND(int x, int y){ return min(x,y); }\nint OR(int x, int y){ return max(x,y); }\nbool is_operator(char op){\n\treturn (op == '-' || op == '*' || op == '+');\n}\n\nstring postfix(string fml)\n{\n\tstring res=\"\";\n\tstack<char> st;\n\tqueue<char> que;\n\trep(i, fml.size())\n\t{\n\t\tif(is_operator(fml[i])){\n\t\t\twhile(!st.empty()){\n\t\t\t\tif(!is_operator(st.top())) break;\n\t\t\t\tif(fml[i] == '-') break;\n\t\t\t\tque.push(st.top());\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.push(fml[i]);\n\t\t}\n\t\telse if(fml[i] == '('){\n\t\t\tst.push(fml[i]);\n\t\t}\n\t\telse if(fml[i] == ')'){\n\t\t\twhile(!(st.top() == '(')){\n\t\t\t\tque.push(st.top());\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t\telse{\n\t\t\tque.push(fml[i]);\n\t\t}\n\t}\n\n\twhile(!st.empty()){\n\t\tque.push(st.top());\n\t\tst.pop();\n\t}\n\n\twhile(!que.empty()){\n\t\tres += que.front();\n\t\tque.pop();\n\t}\n\treturn res;\n}\n\nint solve(int p, int q, int r, string fml)\n{\n\tint res=0;\n\tstack<int> st;\n\trep(i,fml.size())\n\t{\n\t\tif(fml[i] == 'P'){\n\t\t\tst.push(p);\n\t\t}\n\t\telse if(fml[i] == 'Q'){\n\t\t\tst.push(q);\n\t\t}\n\t\telse if(fml[i] == 'R'){\n\t\t\tst.push(r);\n\t\t}\n\t\telse if(isdigit(fml[i])){\n\t\t\tst.push(fml[i]-'0');\n\t\t}\n\t\telse if(fml[i] == '-'){\n\t\t\tint x = st.top();\n\t\t\tst.pop();\n\t\t\tst.push(NOT(x));\n\t\t}\n\t\telse if(fml[i] == '*'){\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tst.push(AND(x,y));\n\t\t}\n\t\telse if(fml[i] == '+'){\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tst.push(OR(x,y));\n\t\t\t\n\t\t}\n\t}\n\n\treturn (st.top() == 2) ? 1 : 0;\n}\n\nint main()\n{\n\tstring formula;\n\twhile(cin >> formula)\n\t{\n\t\tif(formula == \".\") break;\n\n\t\tformula = postfix(formula);\n\n\t\tint ans=0;\n\t\trep(p,3){\n\t\t\trep(q,3){\n\t\t\t\trep(r,3){\n\t\t\t\t\tans += solve(p,q,r,formula);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define END '.'\n#define SB '('\n#define CB ')'\n#define P 'P'\n#define Q 'Q'\n#define R 'R'\n#define zero '\\0'\n#define Su '-'\n#define cal '*'\nchar input[100]={0};\nint coun=0;\nint index;\nusing namespace std;\nint func(int p,int q,int r);\nint nega(int p,int q,int r){\n\t//cout<<input[index]<<endl;\nint left=0;\nint sw=input[index++];\nswitch(sw){\ncase SB:left=func(p,q,r);break;\ncase Su:left=nega(p,q,r);break;\ncase P:left=p;break;\ncase Q:left=q;break;\ncase R:left=r;break;\ndefault:left=sw-'0';break;\n}\n\n\nreturn(2-left);\n}\n\nint func(int p,int q,int r){\n\tint left=0,right=0;\n\tchar ac;\n\tchar sw=input[index++];\n\tswitch(sw){\n\tcase SB:left=func(p,q,r);break;\n\tcase Su:left=nega(p,q,r);break;\n\tcase P:left=p;break;\n\tcase Q:left=q;break;\n\tcase R:left=r;break;\n\tdefault:left=sw-'0';break;\n\t}\n\tac=input[index++];\n\tsw=input[index++];\n\t\tswitch(sw){\n\t\tcase SB:right=func(p,q,r);break;\n\t\tcase Su:right=nega(p,q,r);break;\n\t\tcase P:right=p;break;\n\t\tcase Q:right=q;break;\n\t\tcase R:right=r;break;\n\t\tdefault:right=sw-'0';break;\n\t\t}\n\t\tindex++;\n\t\t//printf(\"%d%c%d\\n\",left,ac,right);\n\tif(ac==cal){\n\t\tif(left<right)return (left);\n\t\telse return right;\n\t}\n\tif(left<right)return (right);\n\telse return left;\n\n\n}\nint fun(int p,int q,int r){\n\tif(input[1]==zero)\n\t\tswitch(input[0]){\n\t\tcase P:return(p);\n\t\tcase Q:return(q);\n\t\tcase R:return(r);\n\t\t}\n\tindex++;\n\tif(input[0]==Su)return(nega(p,q,r));\n\tif(input[0]==SB)\n\treturn(func(p,q,r));\n\treturn(input[0]-'0');\n}\n\nint main(){\n\n\tcin>>input;\n\twhile(input[0]!=END){\n\tcoun=0;\n\tindex=0;\n\t\trep(p,0,3)rep(q,0,3)rep(r,0,3){\n\t\t\tindex=0;\n\t\t\t\tif(fun(p,q,r)==2)coun++;\n\t\t}\n\t\tcout<<coun<<endl;\n\t\tcin>>input;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    cnt++;\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return (int)(tmp[cnt]-'0');\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=(char)(i+'0');\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=(char)(j+'0');\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=(char)(k+'0');\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  cnt=0;\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint add(int x, int y){ return max(x,y); }\nint imul(int x, int y){ return min(x,y); }\nint inv(int x){ return 2-x; }\n\nint p,q,r;\n\nint parse(string in){\n\n  //printf(\"init:%s\\n\",in.c_str());\n\n  switch(in[0]){\n  case '0': case '1': case '2':\n    return in[0]-'0';\n  case 'P': return p;\n  case 'Q': return q;\n  case 'R': return r;\n  case '-': return inv(parse(in.substr(1)));\n  case '(':\n    int x=0;\n    int idx=1;\n    for(;idx<in.size();idx++){\n      if( in[idx]=='(' )x++;\n      if( in[idx]==')' )x--;\n      if( x==0 && (in[idx]=='*' || in[idx]=='+') )break;\n    }\n    //printf(\"idx:%d\\n\",idx);\n    if( in[idx]=='*' ){\n      //printf(\"%d\\n\",idx);\n      return imul(parse(in.substr(1,idx-1)), parse(in.substr(idx+1)));\n    }else{\n      return add(parse(in.substr(1,idx-1)), parse(in.substr(idx+1)));\n    }\n  }\n}\n\nint main(){\n  string in;\n  while(cin>>in, in!=\".\"){\n    int ans = 0;\n    for(p=0; p<=2; p++){\n      for(q=0; q<=2; q++){\n\tfor(r=0; r<=2; r++){\n\t  if( parse(in)==2 )ans++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<string>\n#include<cstdio>\n#include<cstring>\ntypedef unsigned long long ull;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define loop(i,a,b) for(int i=a;i<b;i++)\nusing namespace std;\nconst double eps = 1e-10;\nconst double pi = acos(-1);\nconst double inf = (int)1e8;\n\nstring s;\nint n;\nint value[128];\n\nint multiply(int x,int y){\n  if(x==2 && y==2) return 2;\n  else if(min(x,y) == 0) return 0;\n  else return 1;\n}\n\nint add(int x,int y){\n  if(x==0 && y==0) return 0;\n  else if(max(x,y) == 2) return 2;\n  else return 1;\n}\n\nint form(){\n  if(s[n] == '-'){\n    n++;\n    return 2-form();\n  }else if(s[n] =='('){\n    n++;\n    int x = form();\n    char c = s[n++];\n    int y = form();\n    n++;\n    if(c == '*'){ // *\n      return multiply(x,y);\n    }else{ // +\n      return add(x,y);\n    }\n  }else{\n    return value[s[n++]];\n  }\n}\nint main(void){\n  value['0'] = 0;\n  value['1'] = 1;\n  value['2'] = 2;\n  \n  while(cin>>s,s!=\".\"){\n    \n    s += \"$\";\n    int res = 0;\n    for(int P = 0 ; P <= 2 ; P ++){\n      for(int Q = 0 ; Q <= 2 ; Q ++){\n\tfor(int R = 0 ; R <= 2 ; R ++){\n\t  value['P'] = P;\n\t  value['Q'] = Q;\n\t  value['R'] = R;\n\t  n = 0;\n\t  res += (form() == 2);\n\t}\n      }\n    }\n    cout<<res<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint bar[3] = {2,1,0};\n\nint mul[3][3] = {\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint add[3][3] = {\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\n\nstring s;\nint PQR[3];\n\nbool isvar(char c) { return (c - '0' >= 0 && c - '0' <= 2) || (c - 'P' >= 0 && c - 'P' <= 2); }\nint getvar(char c) {\n\tif (0 <= c - '0' && c - '0' <= 2) return c - '0';\n\treturn PQR[c - 'P'];\n}\n\nint rec(int lft, int rgt) {\n\t//cerr << s.substr(lft, rgt-lft) << endl;\n\tint open_cnt = 0, close_cnt = 0, bar_cnt = 0;\n\tint nxt_lft = -1;\n\t\n\tstack< int > st;\n\tstack< char > op;\n\tfor_(i,lft,rgt) {\n\t\tif (open_cnt == close_cnt && s[i] == '-') {\n\t\t\t++bar_cnt;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && isvar(s[i])) {\n\t\t\tint x = getvar(s[i]);\n\t\t\tfor_(rep,0,bar_cnt) x = bar[x];\n\t\t\tst.push(x);\n\t\t\tbar_cnt = 0;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '*') op.push('*');\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '+') op.push('+');\n\t\t\n\t\tif (s[i] == '(') {\n\t\t\tif (open_cnt == close_cnt) nxt_lft = i+1;\n\t\t\t++open_cnt;\n\t\t}\n\t\t\n\t\tif (s[i] == ')') {\n\t\t\t++close_cnt;\n\t\t\tif (open_cnt == close_cnt) st.push(rec(nxt_lft, i));\n\t\t}\n\t\t\n\t\twhile (st.size() >= 2 && !op.empty()) {\n\t\t\tchar opr = op.top(); op.pop();\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tif (opr == '*') st.push(mul[x][y]);\n\t\t\tif (opr == '+') st.push(add[x][y]);\n\t\t}\n\t}\n\t\n\treturn st.top();\n}\n\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \".\") break;\n\t\tint ans = 0;\n\t\tfor_(p,0,3) for_(q,0,3) for_(r,0,3) {\n\t\t\tPQR[0] = p; PQR[1] = q; PQR[2] = r;\n\t\t\tif (rec(0, s.size()) == 2) ++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError\n{\n};\nint expr(State &begin);\nint P, Q, R;\nint NOT(int x)\n{\n    return 2 - x;\n}\nint AND(int x, int y)\n{\n    return min(x, y);\n}\nint OR(int x, int y)\n{\n    return max(x, y);\n}\nint main()\n{\n    string S;\n    while (cin >> S)\n    {\n        if (S == \".\")\n            return 0;\n        int ans = 0;\n        for (P = 0; P < 3; P++)\n        {\n            for (Q = 0; Q < 3; Q++)\n            {\n                for (R = 0; R < 3; R++)\n                {\n                    State c = S.begin();\n                    if (expr(c) == 2)\n                        ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n//パースして、その評価結果を返す。\nint expr(State &begin)\n{\n\n    int ret;\n    if (*begin == 'P')\n        ret = P;\n    else if (*begin == 'Q')\n        ret = Q;\n    else if (*begin == 'R')\n        ret = R;\n    else if (isdigit(*begin))\n        ret = *begin - '0';\n    else if (*begin == '-')\n    {\n        begin++;\n        return NOT(expr(begin));\n    }\n    else if (*begin == '(')\n    {\n        begin++;\n        ret = expr(begin);\n        if (*begin == '*')\n        {\n            begin++;\n            ret = AND(ret, expr(begin));\n        }\n        else if (*begin == '+')\n        {\n            begin++;\n            ret = OR(ret, expr(begin));\n        }\n    }\n    begin++;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint get_minus(int size, int p) {\n    if (p == 1) return 1;\n    if (p == 2) {\n        if (size % 2 == 0) return 2;\n        else return 0;\n    }\n    if (size % 2 == 0) return 0;\n    else return 2;\n}\n\nint get_plus(int a, int b) {\n    if (a == 2 || b == 2) return 2;\n    if (a == 1 || b == 1) return 1;\n    return 0;\n}\n\nint get_mult(int a, int b) {\n    if (a == 0 || b == 0) return 0;\n    if (a == 1 || b == 1) return 1;\n    return 2;\n}\n\nint main(void) {\n    while (1) {\n        string str;\n        cin >> str;\n        if (str == \".\") break;\n        stack<char> enzan;\n        stack<int> kazu;\n        int ans = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    for (int i = 0; i < str.size(); i++) {\n                        if ('0' <= str[i] && str[i] <= '2') {\n                            int num = str[i] - '0';\n                            kazu.push(num);\n                        }\n                        else if (str[i] == 'P') kazu.push(p);\n                        else if (str[i] == 'Q') kazu.push(q);\n                        else if (str[i] == 'R') kazu.push(r);\n                        else if (str[i] == '-') {\n                            int size = 0;\n                            while (str[i] == '-') {\n                                size++;\n                                i++;\n                            }\n                            if ('0' <= str[i] && str[i] <= '2') {\n                                int num = str[i] - '0';\n                                kazu.push(get_minus(size, num));\n                            }\n                            else if (str[i] == 'P') kazu.push(get_minus(size, p));\n                            else if (str[i] == 'Q') kazu.push(get_minus(size, q));\n                            else if (str[i] == 'R') kazu.push(get_minus(size, r));\n                        }\n                        else if (str[i] == ')') {\n                            int a = kazu.top(); kazu.pop();\n                            int b = kazu.top(); kazu.pop();\n                            char c = enzan.top(); enzan.pop();\n//                            printf(\"%d%c%d\\n\", a, c, b);\n                            if (c == '*') kazu.push(get_mult(a, b));\n                            if (c == '+') kazu.push(get_plus(a, b));\n                        }\n                        else if (str[i] == '+') enzan.push(str[i]);\n                        else if (str[i] == '*') enzan.push(str[i]);\n                    }\n                    if (kazu.top() == 2) ans++;\n                    while (!kazu.empty()) kazu.pop();\n                    while (!enzan.empty()) enzan.pop();\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\nusing namespace std;\n\nmap<char,int> nanm;\nint nani;\nint narec(string s){\n\tif(s[nani]=='P'||s[nani]=='Q'||s[nani]=='R'){\n\t\tnani++;\n\t\treturn nanm[s[nani-1]];\n\t}\n\tif(isdigit(s[nani])){\n\t\tnani++;\n\t\treturn (s[nani-1]-'0'-1);\n\t}\n\tif(s[nani]=='-'){\n\t\tnani++;\n\t\treturn -narec(s);\n\t}\n\tif(s[nani]=='('){\n\t\tnani++;\n\t\tint left=narec(s);\n\t\tchar op=s[nani];\n\t\tnani++;\n\t\tint right=narec(s);\n\t\tnani++;\n\t\tif(op=='*')\treturn min(left,right);\n\t\tif(op=='+')\treturn max(left,right);\n\t}\n\treturn -2;\n}\n\n\nint main(){\n\tstring s;\n\tint P,Q,R;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint ans=0;\n\t\tfor(P=-1;P<=1;P++){\n\t\t\tfor(Q=-1;Q<=1;Q++){\n\t\t\t\tfor(R=-1;R<=1;R++){\n\t\t\t\t\tnani=0;\n\t\t\t\t\tnanm['P']=P;nanm['Q']=Q;nanm['R']=R;\n\t\t\t\t\tif(narec(s)==1){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring S, T; int pos;\nint solve() {\n\tif (T[pos] == '0') { pos++; return 0; }\n\tif (T[pos] == '1') { pos++; return 1; }\n\tif (T[pos] == '2') { pos++; return 2; }\n\tif (T[pos] == '-') { pos++; return 2 - solve(); }\n\tif (T[pos] == '(') {\n\t\tpos++; int a = solve(); char c = T[pos];\n\t\tpos++; int b = solve(); pos++;\n\t\tif (c == '+') return max(a, b);\n\t\tif (c == '*') return min(a, b);\n\t}\n\treturn 0;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \".\") break;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tT = S;\n\t\t\t\t\tfor (int l = 0; l < S.size(); l++) {\n\t\t\t\t\t\tif (S[l] == 'P') T[l] = i + 48;\n\t\t\t\t\t\tif (S[l] == 'Q') T[l] = j + 48;\n\t\t\t\t\t\tif (S[l] == 'R') T[l] = k + 48;\n\t\t\t\t\t}\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tif (solve() == 2) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n#include<string>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n//構文を実際に計算する\nbool play(const string& s) {\n\tstack<char> info;\n\tfor (const char& c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(const string& formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=k+'0';\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint negation(int x)\n{\n    if(x == 0) return 2;\n    if(x == 2) return 0;\n    return 1;\n}\n\nint conjuction(int x, int y)\n{\n    if(x == 2 && y == 2) return 2;\n    else if(x != 0 && y != 0) return 1;\n    else return 0; \n}\n\nint disjunction(int x, int y){\n    if(x == 2 || y == 2) return 2;\n    else if(x == 1 || y == 1) return 1;\n    else return 0;\n}\n\n\n\nint solve(string s, int p, int q, int r)\n{\n    stack<int> st;\n    stack<char> op;\n    for(int i = 0; i < s.length(); i++){\n        if(s[i] == '-' || s[i] == '+' || s[i] == '*'){\n            op.push(s[i]);\n        } else {\n            int tmp1, tmp2;\n            if(s[i] == '('){\n                i++;\n                string news = \"\";\n                int kakkonum = 1;\n                while(1){\n                    // cout << i << endl;\n                    if(s[i] == ')') kakkonum--;\n                    else if(s[i] == '(') kakkonum++;\n                    if(kakkonum == 0) break;\n                    news += s[i];\n                    i++;\n                }\n                // cout << news << endl;\n                st.push(solve(news, p, q, r));\n            } else if(isdigit(s[i])){\n                st.push(s[i] - '0');\n            } else {\n                if(s[i] == 'P') st.push(p);\n                else if(s[i] == 'Q') st.push(q);\n                else st.push(r);\n            }\n            while(!op.empty() && op.top() == '-'){\n                op.pop();\n                tmp1 = st.top();\n                st.pop();\n                st.push(negation(tmp1));\n            }\n            if(!op.empty() && op.top() == '+'){\n                op.pop();\n                tmp1 = st.top();\n                st.pop();\n                tmp2 = st.top();\n                st.pop();\n                st.push(disjunction(tmp1, tmp2));\n            } else if(!op.empty() && op.top() == '*'){\n                op.pop();\n                tmp1 = st.top();\n                st.pop();\n                tmp2 = st.top();\n                st.pop();\n                st.push(conjuction(tmp1, tmp2));\n            }\n        }\n    }\n    // cout << s  << \" \" << p << \" \" << q << \" \" << r << \" \" << st.top() << endl;\n    return st.top();\n}\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \".\") break;\n        int ans = 0;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                for(int k = 0; k < 3; k++){\n                    if(solve(s, i, j, k) == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tr = 2-r;\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2)\n\t\t\t\tl = 2-l;\n\t\t\tst.pop();\n\t\t\t\n\t\t\tint tmp;\n\t\t\tif(o == '*')\n\t\t\t\ttmp = AND[r][l];\n\t\t\telse\n\t\t\t\ttmp = OR[r][l];\n\t\t\t\t\n\t\t\tif(!st.empty() && st.top()=='-'){\n\t\t\t\tfor(m=0; !st.empty(); m++)\n\t\t\t\t\tst.pop();\n\t\t\t\tif(m%2)\n\t\t\t\t\ttmp = 2-tmp;\n\t\t\t}\n\t\t\t\n\t\t\tst.push((char)(tmp+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\n\tif(st.top() == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[100];\n\n\twhile(true){\n\t\tstd::cin >> x;\n\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint p,q,r,now;\nstring s;\n\nint formula(){\n\t\n\tif(isdigit(s[now])){return s[now++]-'0';}\n\telse if(s[now]=='P'){now++;return p;}\n\telse if(s[now]=='Q'){now++;return q;}\n\telse if(s[now]=='R'){now++;return r;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\telse if(s[now]=='('){\n\t\tnow++;\n\t\tres=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\trep(p,3)rep(q,3)rep(r,3){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint bit(int c,int d);\nint minus(int c);\nint kake(int c,int d);\nint plus(int c,int d);\nstring tstring(int c);\n\nstring S,T;\nint sum;\nchar U[4]=\"012\";\nint x[MAX_N];\n\nint bit(int c,bool d){\n\tif(d==true){return c;}\n\treturn minus(c);\n}\nint minus(int c){return 2-c;}\nint plus(int c,int d){return max(c,d);}\nint kake(int c,int d){return max(c,d);}\n\nstring tstring(int c)\n{\n\tif(c==0)\n\t{\n\t\treturn \"0\";\n\t}\n\tif(c==1)\n\t{\n\t\treturn \"1\";\n\t}\n\treturn \"2\";\n}\n\nint kaiseki2(string Z){\n\tint ans=3,ans2=3;\n\tbool ok=true;\n\tchar op=' ';\n\tfor(int i=0;i<Z.size();i++)\n\t{\n\t\tif(Z[i]=='-')\n\t\t{\n\t\t\tif(ok==true){ok=false;}\n\t\t\tif(ok==false){ok=true;}\n\t\t}\n\t\tif(ans==3){\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Z[i]=='0')\n\t\t\t{\n\t\t\t\tans2=bit(0,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='1')\n\t\t\t{\n\t\t\t\tans2=bit(1,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(Z[i]=='2')\n\t\t\t{\n\t\t\t\tans2=bit(2,ok);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\tif(Z[i]=='+')\n\t\t{\n\t\t\top='+';\n\t\t}\n\t\tif(Z[i]=='*')\n\t\t{\n\t\t\top='*';\n\t\t}\n\t}\n\tif(op==' '){return ans;}\n\tif(op=='+'){return plus(ans,ans2);}\n\treturn kake(ans,ans2);\n}\n\nint kaiseki(string V){\n\twhile(V.size()>=2)\n\t{\n\t\tint s=0,maxn=0;\n\t\tstring W=\"\",X=\"\";\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(V[i]=='(')\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif(V[i]==')')\n\t\t\t{\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tx[i]=s;\n\t\t\tmaxn=max(s,maxn);\n\t\t}\n\t\tfor(int i=0;i<V.size();i++)\n\t\t{\n\t\t\tif(x[i]==maxn)\n\t\t\t{\n\t\t\t\tif(V[i]!='(')\n\t\t\t\t{\n\t\t\t\t\tW+=V[i];\n\t\t\t\t}\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\tif(x[i-1]==maxn)\n\t\t\t\t{\n\t\t\t\t\tX+=tstring((long long)kaiseki2(W));\n\t\t\t\t\tW=\"\";\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX+=V[i];\nE:;\n\t\t}\n\t}\n\tif(V==\"2\"){return 1;}\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>S;\n\t\tsum=0;\n\t\tif(S==\".\"){break;}\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tT=\"\";\n\t\t\t\t\tfor(int l=0;l<S.size();l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(S[l]=='P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='Q')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(S[l]=='R')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tT+=U[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsum+=kaiseki(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define State string::const_iterator\nclass ParseError {};\n\n\nint expression(State &begin);\n//int term(State &begin);\nint number(State &begin);\nint factor(State &begin);\nint denial(State &begin);\nvoid consume(State &begin, char expected);\nint p,q,r;\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '+'){\n            consume(begin, '+');\n            int num = factor(begin);\n            //cout << num << \" + \" << ret;\n            if(ret == 0 && num == 0){\n                ret = 0;\n            }\n            else if(ret == 1 || num == 1){\n                if(ret != 2 && num != 2){\n                    ret = 1;\n                }\n                else{\n                    ret = 2;\n                }\n            }\n            else{\n                ret = 2;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else if(*begin == '*'){\n            consume(begin, '*');\n            int num = factor(begin);\n            //cout << num << \" * \" << ret;\n            if(num == 2 && ret == 2){\n                ret = 2;\n            }\n            else if(num == 0 || ret == 0){\n                ret = 0;\n            }\n            else{\n                ret = 1;\n            }\n            //cout << \" = \" << ret << endl;\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n/*\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State &begin) {\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '*'){\n            consume(begin, '*');\n            ret *= factor(begin);\n        }\n        else if(*begin == '/'){\n            consume(begin, '/');\n            ret /= factor(begin);\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n}\n*/\n\nint denial(State &begin){\n    if(*begin == '-'){\n        /*\n        int count = 1;\n        consume(begin, '-');\n        while(*begin == '-'){\n            count++;\n            consume(begin, '-');\n        }\n        int ret = number(begin);\n        if(count%2 == 1){\n            if(ret == 2){\n                ret = 0;\n            }\n            else if(ret == 0){\n                ret = 2;\n            }\n        }\n         */\n\n        consume(begin, '-');\n\n        int ret = denial(begin);\n\n        if(ret == 2){\n            ret = 0;\n        }\n        else if(ret == 0){\n            ret = 2;\n        }\n\n        return ret;\n    }\n    return number(begin);\n}\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\n    if(*begin == 'P'){\n        consume(begin, 'P');\n        return p;\n    }\n    else if(*begin == 'Q'){\n        consume(begin, 'Q');\n        return q;\n    }\n    else if(*begin == 'R'){\n        consume(begin, 'R');\n        return r;\n    }\n\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        int ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return denial(begin);\n    }\n}\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true){\n\n        string input;\n\n        cin >> input;\n\n        if(input[0] == '.'){\n            break;\n        }\n\n        int ans = 0;\n\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                for(int k=0; k<3; k++){\n                    p = i;\n                    q = j;\n                    r = k;\n                    State s = input.begin();\n                    if(factor(s) == 2){\n                        ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V=1e3+5;\nconst int INF=1e9;\nvector< vector<int> > board(25,vector<int>(25,0) );\nint w,h;\nint sy,sx,gy,gx;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint goal=100;\n//Prototype\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint number(string &s,int &i)\n{\n  int n=s[i++]-'0';\n  while(isdigit(s[i])) n=n*10+s[i++]-'0';\n  return n;\n}\n\nint factor(string &s,int &i)\n{\n  if(isdigit(s[i])) return number(s,i);\n  assert(s[i]=='(');\n  i++;\n  int ret=expr(s,i);\n  i++;\n  return ret;\n}\nint term(string &s, int &i)\n{\n  int val;\n  if(s[i]!='-')\n    {\n      val=factor(s,i);\n    }\n  while(s[i]=='-')\n    {\n      i++;\n      int val2=term(s,i);\n      if(val2==0) val=2;\n      if(val2==1) val=1;\n      if(val2==2) val=0;\n    }\n  return val;\n}\nint expr(string &s, int &i)\n{\n  int val=term(s,i);\n  while(s[i]=='*' || s[i]=='+')\n    {\n      char op=s[i];\n      i++;\n      int val2=term(s,i);\n      if(op=='*') val=min(val,val2);\n      else if(op=='+') val=max(val,val2); \n    }\n  return val;\n}\nint main(void)\n{\n  string s;\n  while(cin >> s && s!=\".\")\n    {\n      int ans=0;\n      string origin=s;\n      for(int r=0;r<=2;r++)\n\t{\n\t  for(int p=0;p<=2;p++)\n\t    {\n\t      for(int q=0;q<=2;q++)\n\t\t{\n\t\t  s=origin;\n\t\t  for(int i=0;i<int(s.size());i++)\n\t\t    {\n\t\t      if(s[i]=='P') s[i]='0'+p;\n\t\t      if(s[i]=='Q') s[i]='0'+q;\n\t\t      if(s[i]=='R') s[i]='0'+r;\n\t\t    }\n\t\t  //cout << s << endl;\n\t\t  int i=0;\n\t\t  if(expr(s,i)==2) ans++;\n\t\t}\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint get_minus(int size, int p) {\n    if (p == 1) return 1;\n    if (p == 2) {\n        if (size % 2 == 0) return 2;\n        else return 0;\n    }\n    if (size % 2 == 0) return 0;\n    else return 2;\n}\n\nint get_plus(int a, int b) {\n    if (a == 2 || b == 2) return 2;\n    if (a == 1 || b == 1) return 1;\n    return 0;\n}\n\nint get_mult(int a, int b) {\n    if (a == 0 || b == 0) return 0;\n    if (a == 1 || b == 1) return 1;\n    return 2;\n}\n\nint main(void) {\n    while (1) {\n        string str;\n        cin >> str;\n        if (str == \".\") break;\n        stack<char> enzan;\n        stack<int> kazu;\n        int ans = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    for (int i = 0; i < str.size(); i++) {\n                        if ('0' <= str[i] && str[i] <= '2') {\n                            int num = str[i] - '0';\n                            kazu.push(num);\n                        }\n                        else if (str[i] == 'P') kazu.push(p);\n                        else if (str[i] == 'Q') kazu.push(q);\n                        else if (str[i] == 'R') kazu.push(r);\n                        else if (str[i] == '-') {\n                            int size = 0;\n                            while (str[i] == '-') {\n                                size++;\n                                i++;\n                            }\n                            if ('0' <= str[i] && str[i] <= '2') {\n                                int num = str[i] - '0';\n                                kazu.push(get_minus(size, num));\n                            }\n                            else if (str[i] == 'P') kazu.push(get_minus(size, p));\n                            else if (str[i] == 'Q') kazu.push(get_minus(size, q));\n                            else if (str[i] == 'R') kazu.push(get_minus(size, r));\n                        }\n                        else if (str[i] == ')') {\n                            int a = kazu.top(); kazu.pop();\n                            int b = kazu.top(); kazu.pop();\n                            char c = enzan.top(); enzan.pop();\n//                            printf(\"%d%c%d\\n\", a, c, b);\n                            if (c == '*') kazu.push(get_mult(a, b));\n                            if (c == '+') kazu.push(get_plus(a, b));\n                        }\n                        else if (str[i] == '+') enzan.push(str[i]);\n                        else if (str[i] == '*') enzan.push(str[i]);\n                    }\n                    if (kazu.top() == 2) ans++;\n                    while (!kazu.empty()) kazu.pop();\n                    while (!enzan.empty()) enzan.pop();\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(true);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res =formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    cin.ignore();\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring str;\nint ps;\nmap<char, int> mpp;\n\nint formula()\n{\n  int v, u;\n  if(isalpha(str[ps])){\n    return mpp[str[ps++]];\n  } else if(isdigit(str[ps])){\n    return (int)(str[ps++]-'0');\n  } else if(str[ps] == '-'){\n    ++ps;\n    return (2-formula());\n  } if(str[ps] == '('){\n    ++ps;\n\n    v = formula();\n    char ch = str[ps++];\n    u = formula();\n    ++ps;\n\n    if(ch == '*') v = min(v, u);\n    else v = max(v, u);\n  }\n\n  return v;\n}\n\nint solve(int p, int q, int r)\n{\n  int res;\n  ps = 0;\n  mpp['P'] = p;\n  mpp['Q'] = q;\n  mpp['R'] = r;\n\n  res = formula();\n\n  mpp.clear();\n  return res;\n}\n\nint main()\n{\n  int cnt;\n\n  while(cin>>str && str != \".\"){\n    cnt = 0;\n\n    for(int i = 0; i < 3; ++i)\n      for(int j = 0; j < 3; ++j)\n        for(int k = 0; k < 3; ++k)\n          if(solve(i, j, k) == 2) ++cnt;\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring op = \"+*()\";\n\nint calc (string exp) {\n    if (exp[0] == '(') {\n        int count = 0;\n        string lhs_;\n        for (int i = 1; count || (exp[i] != '*' && exp[i] != '+'); i++) {\n            lhs_ += exp[i];\n            if (exp[i] == '(') count++;\n            if (exp[i] == ')') count--;\n        }\n        int lhs = calc(lhs_);\n        char op = exp[lhs_.size() + 1];\n        count = 0;\n        string rhs_;\n        for(int i = lhs_.size()+2;; i++) {\n            if (exp[i] == '(') count++;\n            if (exp[i] == ')') if (count == 0) break; else count--;\n            rhs_ += exp[i];\n        }\n        int rhs = calc(rhs_);\n        if (op == '*') return min(lhs,rhs);\n        else return max(rhs,lhs);\n\n    } else {\n        int count = 0;\n        int i = 0;\n        while (exp[i] == '-') i++, count++;\n        int num;\n        if (exp[i] == '(') num = calc(string(exp.begin()+i, exp.end()));\n        else num = atoi(&exp[i]);\n\n        if (num == 1) return 1;\n        else if (count % 2) return num == 2 ? 0 : 2;\n        else return num;\n\n    }\n}\n\nint main () {\n    string str;\n    while (cin >> str, str != \".\") {\n        int res = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string tmp(str.begin(), str.end());\n                    for (int c = 0; c < str.size(); c++) {\n                        if (tmp[c] == 'P') tmp[c] = ('0' + i);\n                        if (tmp[c] == 'Q') tmp[c] = ('0' + j);\n                        if (tmp[c] == 'R') tmp[c] = ('0' + k);\n                    }\n                    if (calc(tmp) == 2) res++;\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {-1,0,1,0};\nint ty[] = {0,1,0,-1};\n\nP formula(const string &str, int pos=0);\nP factor(const string &str, int pos = 0);\nP term(const string &str, int pos = 0);\n\nP formula(const string &str, int pos){\n\tif(str[pos] == '('){\n\t\tP res1_ = formula(str,pos+1);\n\t\tpos = res1_.second;\n\t\tchar ch = str[pos];\n\t\tP res2_ = formula(str,pos+1);\n\n\t\tif(ch=='*') return P(min(res1_.first,res2_.first),res2_.second+1);\n\t\tif(ch=='+') return P(max(res1_.first,res2_.first),res2_.second+1);\n\t}\n\telse if(isdigit(str[pos])){\n\t\treturn P(str[pos]-'0',pos+1);\n\t}\n\n\telse if(str[pos] == '-'){\n\t\tP res_ = formula(str,pos+1);\n\t\tif(res_.first==0) res_.first=2;\n\t\telse if(res_.first==2) res_.first=0;\n\n\t\treturn res_;\n\t}\n}\n\n\nint main()\n{\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tif(str == \".\") break;\n\t\tint res = 0;\n\t\tfor(int p=0;p<=2;p++){\n\t\t\tfor(int q=0;q<=2;q++){\n\t\t\t\tfor(int r=0;r<=2;r++){\n\t\t\t\t\tstring tmp = str;\n\t\t\t\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\t\t\t\tif(tmp[i]=='P') tmp[i] = '0' + p;\n\t\t\t\t\t\telse if(tmp[i]=='Q') tmp[i] = '0' + q;\n\t\t\t\t\t\telse if(tmp[i]=='R') tmp[i] = '0' + r;\n\t\t\t\t\t}\n\t\t\t\t\tP result;\n\t\t\t\t\tresult = formula(tmp,0);\n\t\t\t\t\t//printf(\"%s = %d\\n\",tmp.c_str(),result.first);\n\t\t\t\t\tif(formula(tmp,0).first == 2) res++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i&#8212;-)\n\nint not_[3]={2,1,0};\nint and_[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint or_[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\nint i,p,q,r;\nint rec(string s)\n{\n  stack<char>key;\n  int ans=0,v;\n  key.push('+');\n  while(i<s.size())\n    {\n      if(s[i]==')')\n\t{return ans;}\n      else if(s[i]=='+'||s[i]=='-'||s[i]=='*')\n\t  key.push(s[i++]);\n      else\n\t{\n\t  if(s[i]=='(')\n\t    {i++;v=rec(s);}\n\t  else if(s[i]=='P')v=p;\n\t  else if(s[i]=='Q')v=q;\n\t  else if(s[i]=='R')v=r;\n\t  else\n\t      v=s[i]-'0';\n\t  while(!key.empty())\n\t    {\n\t      if(key.top()=='+')\n\t\tans=or_[ans][v];\n\t      else if(key.top()=='-')\n\t\t{\n\t\t  v=not_[v];\n\t\t  if(key.size()==1)ans=v;\n\t\t}\n\t      else if(key.top()=='*')\n\t\tans=and_[ans][v];\n\t      key.pop();\n\t    }\n\t  i++;\n\t}\n    }\n  return ans;\n}\n\nint main()\n{\n  string s;\n  while(cin>>s)\n    {\n      if(s[0]=='.')return 0;\n      int a,b,c;\n      int cnt=0;\n      rep(a,3)rep(b,3)rep(c,3)\n\t{\n\t  p=a;q=b;r=c;\n\t  i=0;\n\t  if(rec(s)==2)cnt++;\n\t}\n      cout<<cnt<<endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint num[3];\n\nint formula(State &begin){\n  int res,res2;\n  if(*begin == '('){\n    begin++;\n    res=formula(begin);\n    if(*begin=='*'){\n      begin++;\n      res2=formula(begin);\n       begin++;\n      return min(res,res2);\n    }else if(*begin=='+'){\n      begin++;\n      res2=formula(begin);\n       begin++;\n      return max(res,res2);\n    }\n   \n  }\n  if(*begin=='-'){\n    begin++;\n    return 2-formula(begin);\n  }\n  if(isdigit(*begin)){\n    res=(*begin)-'0';\n    begin++;\n    return res;\n  }\n  if('P'<=(*begin) && (*begin)<='R'){\n    res=num[(*begin)-'P'];\n    begin++;\n    return res;\n  }\n  \n}\n\n\n\n\nsigned main(){\n  cin.tie(0);\t\n  //ios::sync_with_stdio(false);\n  while(1){\n    string s;\n    cin>>s;\n    if(s==\".\") break;\n    int ans=0;\n    rep(i,3){\n      num[0]=i;\n      rep(j,3){\n\tnum[1]=j;\n\trep(k,3){\n\t  num[2]=k;\n\t  State begin=s.begin();\n\t  if(formula(begin)==2){\n\t    // cout<<num[0]<<\" \"<<num[1]<<\" \"<<num[2]<<endl;\n\t    ans++;\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n    \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nint term(State& begin);\nint expression(State& begin) {\n\tint now_value = 0;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tint d1 = expression(begin);\n\t\tint d2;\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\td2 = expression(begin);\n\t\t\tnow_value = max(d1, d2);\n\t\t}\n\t\telse if(*begin == '*'){\n\t\t\tbegin++;\n\t\t\td2 = expression(begin);\n\t\t\tnow_value = min(d1, d2);\n\t\t}\n\t\tbegin++;\n\t}\n\telse {\n\t\tnow_value = term(begin);\n\t}\n\treturn now_value;\n}\nint term(State& begin) {\n\tint now_value = 0;\n\tif (*begin == '-') {\n\t\tbegin++;\n\t\tnow_value = 2 - expression(begin);\n\t}\n\telse if (*begin >= '0' && *begin <= '9') {\n\t\tnow_value = *begin - '0';\n\t\tbegin++;\n\t}\n\treturn now_value;\n}\nint main() {\n\twhile (true) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s == \".\") return 0;\n\t\tint ans = 0;\n\t\tREP(i, 3) {\n\t\t\tREP(q, 3) {\n\t\t\t\tREP(j, 3) {\n\t\t\t\t\tstring a;\n\t\t\t\t\tREP(t, s.length()) {\n\t\t\t\t\t\tif (s[t] == 'P') {\n\t\t\t\t\t\t\ta.push_back(i+'0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[t] == 'Q') {\n\t\t\t\t\t\t\ta.push_back(q + '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[t] == 'R') {\n\t\t\t\t\t\t\ta.push_back(j + '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ta.push_back(s[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tauto d = a.cbegin();\n\t\t\t\t\tif (expression(d) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nstring s;\nint p, q, r;\nint pos;\nint get_val(int x, int y, char op)\n{\n    int res;\n    if(op == '*') res = min(x, y);\n    else res = max(x, y);\n    return res;\n}\nint Solve()\n{\n    char op = '#';;\n    if(s[pos] == '(') \n    {\n        pos++;\n        int A = Solve();\n        char op = s[pos];\n        pos++;\n        int B = Solve();\n        pos++;\n        return get_val(A, B, op);\n    }\n    else if(s[pos] == ')') return 0;\n    else if(s[pos] == '-')\n    {\n        pos++;\n        return 2 - Solve();\n    }\n    else\n    {\n        int num;\n        if(s[pos] == 'P') num = p;\n        else if(s[pos] == 'Q') num = q;\n        else if(s[pos] == 'R') num = r;\n        else num = s[pos] - '0';\n        pos++;\n        return num;\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> s)\n    {\n        if(s == \".\") break;\n        int ans = 0;\n        for(p = 0; p < 3; p++)\n        {\n            for(q = 0; q < 3; q++)\n            {\n                for(r = 0; r < 3; r++) \n                {\n                    pos = 0;\n                    if(Solve() == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str; int pos, P, Q, R;\n\nint formula() {\n  pos = -1;\n  if(str[pos] == '(') {\n    int f = formula(); pos++;\n    if(str[pos] == '*') f = min(f, formula());\n    if(str[pos] == '+') f = max(f, formula());\n    pos ++;\n    return f;\n  }\n  if(str[pos] == '-') return 2-formula();\n  if(str[pos] == 'P') return P;\n  if(str[pos] == 'Q') return Q;\n  if(str[pos] == 'R') return R;\n  if(isdigit(str[pos])) return str[pos]-'0';\n}\n\nint main() {\n  while(cin >> str) {\n    if(str == \".\") return 0;\n    int cnt = 0;\n    for(P=0; P<=2; P++)\n      for(Q=0; Q<=2; Q++)\n\tfor(R=0; R<=2; R++) {\n\t  pos = -1;\n\t  cnt += formula() == 2;\n\t}\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nvoid stack_op(vector<int> &S, int a){\n\tint tmp;\n\tint minus[3] = {2, 1, 0};\n\tint mul[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\n\tint add[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\n\tswitch(S[S.size()-1]){\n\tcase -1:\n\t\tS.push_back(a);\n\t\tbreak;\n\tcase 4:\n\t\tS.pop_back();\n\t\tstack_op(S, minus[a]);\n\t\tbreak;\n\tcase 5:\n\t\tS.pop_back();\n\t\ttmp = S[S.size()-1];\n\t\tS.pop_back();\n\t\tstack_op(S, mul[tmp][a]);\n\t\tbreak;\n\tcase 6:\n\t\tS.pop_back();\n\t\ttmp = S[S.size()-1];\n\t\tS.pop_back();\n\t\tstack_op(S, add[tmp][a]);\n\t\tbreak;\n\t}\n}\n\nint cal(string str, int p, int q, int r){\n\tvector<int> S;\n\tint tmp;\n\n\tS.push_back(-1);\n\tfor(int i=0;i<str.length();i++){\n\t\tswitch(str[i]){\n\t\tcase '(':\n\t\t\tS.push_back(-1);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\ttmp = S[S.size()-1];\n\t\t\tS.pop_back();\n\t\t\tS.pop_back();\n\t\t\tif((S[S.size()-1] >= 4) && (S[S.size()-1] <= 6))\n\t\t\t\tstack_op(S, tmp);\n\t\t\telse\n\t\t\t\tS.push_back(tmp);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tS.push_back(4);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tS.push_back(5);\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tS.push_back(6);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tstack_op(S, p);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tstack_op(S, q);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tstack_op(S, r);\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\tstack_op(S, 0);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tstack_op(S, 1);\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tstack_op(S, 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn S[S.size()-1];\n}\n\nint count(string str){\n\tint count = 0;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\tif(cal(str, i, j, k) == 2)\n\t\t\t\t\tcount++;\n\treturn count;\n}\n\nint main(){\n\twhile(1){\n\t\tstring str;\n\n\t\tgetline(cin, str);\n\t\tif(str == \".\")\n\t\t\tbreak;\n\t\t\n\t\tcout<<count(str)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint a[3];\nstring s;\n\nint f(int &I){\n\tif(isdigit(s[I])) return s[I++]-'0';\n\tif(isalpha(s[I])) return a[s[I++]-'P'];\n\tif(s[I]=='-'){\n\t\tint t=f(++I);\n\t\tif(t==2) t=0;\n\t\telse if(t==0) t=2;\n\t\treturn t;\n\t}\n\tint x=f(++I);\n\tchar c=s[I];\n\tint y=f(++I);\n\tI++;\n\tif(c=='*') return min(x,y);\n\telse return max(x,y);\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tcin>>s;\n\t\tif(s==\".\") break;\n\t\tint res=0;\n\t\tfor(int i=0;i<27;i++){\n\t\t\ta[0]=i%3;\n\t\t\ta[1]=i/3%3;\n\t\t\ta[2]=i/9%3;\n\t\t\tint I=0;\n\t\t\tif(f(I)==2) res++;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nchar tmp[100];\nint place;\n\nint m_minus(int num){\n\treturn 2 - num;\n}\n\nint m_op(int a,int b,char c){\n\tif(c == '*'){\n\t\tif(a * b == 0)return 0;\n\t\telse if(a * b < 3)return 1;\n\t\treturn 2;\n\t}\n\telse{\n\t\tif(a == 2 || b == 2)return 2;\n\t\telse if(a == 1 || b == 1)return 1;\n\t\treturn 0;\n\t}\n}\n\nint dfs(){\n\tif(tmp[place] == '-'){\n\t\tplace++;\n\t\treturn m_minus(dfs());\n\t}\n\telse if(tmp[place] == '('){\n\t\tplace++;\n\t\tint a = dfs();\n\t\tchar c = tmp[place];\n\t\tplace++;\n\t\tint b = dfs();\n\t\tplace++;\n\t\treturn m_op(a,b,c);\n\t}\n\telse{\n\t\tint ret = tmp[place] - '0';\n\t\tplace++;\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\t\n\tstring str;\n\twhile(cin >> str,str[0] != '.'){\t\t\t\n\t\tint ans = 0;\n\t\t\n\t\tREP(i,3){\n\t\t\tREP(j,3){\n\t\t\t\tREP(k,3){\n\t\t\t\t\tREP(l,str.size()){\n\t\t\t\t\t\tif(str[l] == 'P'){\n\t\t\t\t\t\t\ttmp[l] = '0' + i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(str[l] == 'Q'){\n\t\t\t\t\t\t\ttmp[l] = '0' + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(str[l] == 'R'){\n\t\t\t\t\t\t\ttmp[l] = '0' + k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse tmp[l] = str[l];\n\t\t\t\t\t}\n\t\t\t\t\tplace = 0;\n\t\t\t\t\tDBG(\n\t\t\t\t\tcout << tmp << endl;\n\t\t\t\t\tcout << \"ijk : \" << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\tcout << \"place : \" << place << endl;)\n\t\t\t\t\tif(dfs() == 2){\n\t\t\t\t\t\tDBG(cout << \"OK\" << endl;)\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\n\nvoid assume(State &begin, char expected) {\n    // cerr << \"assume: \" << *begin << \" \" << expected << endl;\n    assert(*begin == expected);\n    begin++;\n}\n\nint term(State&, vi);\nint formula(State&, vi);\n\nint term(State &begin, vi v) {\n    // cerr << \"term: \" << *begin << endl;\n    int ret = formula(begin, v);\n\n    if (*begin == '*') {\n        begin++;\n        ret = min(ret, formula(begin, v));\n    } else {\n        assume(begin, '+');\n        ret = max(ret, formula(begin, v));\n    }\n\n    return ret;\n}\n\nint formula(State &begin, vi v) {\n    // cerr << \"formula: \" << *begin << endl;\n    int ret;\n\n    if (isdigit(*begin)) {\n        ret = *begin - '0';\n        begin++;\n    } else if (isalpha(*begin)) {\n        ret = v[*begin - 'P'];\n        begin++;\n    } else if (*begin == '-') {\n        begin++;\n        ret = 2 - formula(begin, v);\n    } else {\n        assume(begin, '(');\n        ret = term(begin, v);\n        assume(begin, ')');\n    }\n\n    return ret;\n}\n\nint solve(string s) {\n    int ret = 0;\n    rep(i, 27) {\n        // cerr << \"i = \" << i << \":\" << endl;\n        State begin = s.begin();\n        vi v({i % 3, (i / 3) % 3, i / 9});\n        if (formula(begin, v) == 2) {\n            ret++;\n        }\n    }\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    int t = 0;\n    while (cin >> s, s[0] - '.') {\n        // cerr << \"--- t = \" << t++ << \" ---\"<< endl;\n        cout << solve(s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\n//構文を実際に計算する\nbool play(const string& s) {\n\tstack<char> info;\n\tfor (const char& c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(const string& formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint vari[3];\nstring s;\n\nstring regenerate(string t) {\n    int n = t.length();\n    string ret = \"\";\n    rep(i,0,n) {\n        if(i < n-1 && t[i] == '-' && t[i+1] == '-') i++;\n        else ret += t[i];\n    }\n    return ret;\n}\n\nint opnot(int m) {\n    return 2 - m;\n}\n\nvector< vector<int> > opmul{ {0, 0, 0}, {0, 1, 1}, {0, 1, 2} };\nvector< vector<int> > oppls{ {0, 1, 2}, {1, 1, 2}, {2, 2, 2} };\n\nint retvari(char c) {\n    string chk = \"PQR\";\n    if(chk.find(c) != string::npos) return vari[ chk.find(c) ];\n    else return c - '0';\n}\n\nint solve(int l, int r) {\n    if(r - l == 1) return retvari(s[l]);\n    else if(s[l] == '-' && r - l == 2) return opnot(retvari(s[l+1]));\n    else {\n        int cnt = 0, nl = -1, nr = -1;\n        int vl, vr;\n        rep(i,l,r) {\n            if(s[i] == '(') {\n                cnt++;\n            }\n            if(s[i] == ')') {\n                cnt--;\n            }\n            if(s[i] == '*' && cnt == 0) {\n                vl = solve(l, i);\n                vr = solve(i+1, r);\n                return opmul[vl][vr];\n            }\n            if(s[i] == '+' && cnt == 0) {\n                vl = solve(l, i);\n                vr = solve(i+1, r);\n                return oppls[vl][vr];\n            }\n        }\n    }\n    return solve(l+1, r-1);\n}\n\nsigned main() {\n    while(cin >> s, s != \".\") {\n        s = regenerate(s);\n        int n = s.length(), cnt = 0;\n        rep(i,0,3) rep(j,0,3) rep(k,0,3) {\n            vari[0] = i, vari[1] = j, vari[2] = k;\n            if(solve(0, n) == 2) cnt++;\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\n#define rep(i,n) for((i)=0;(i)<(n);i++)\n\nusing namespace std;\n\nint p,q,r,now;\nstring s;\n\nint formula(void){\n\t\n\tif(isdigit(s[now])){return s[now++]-'0';}\n\tif(s[now]=='P'){now++;return p;}\n\tif(s[now]=='Q'){now++;return q;}\n\tif(s[now]=='R'){now++;return r;}\n\t\n\tint res=0;\n\tif(s[now]=='-'){now++;return 2-formula();}\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tres=formula();\n\t\tif(s[now]=='*'){now++;res=min(res,formula());}\n\t\telse if(s[now]=='+'){now++;res=max(res,formula());}\n\t\tnow++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\".\"){\n\t\t\n\t\tint cnt=0;\n\t\trep(p,3)rep(q,3)rep(r,3){\n\t\t\tnow=0;\n\t\t\tif(formula()==2)cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\nusing namespace std;\n\nstring s,t;\nint a,p;\n\nint A(int x){return x==2?0:x==1?1:2;}\nint B(int x,int y){return x==0||y==0?0:x==1||y==1?1:2;}\nint C(int x,int y){return x==2||y==2?2:x==1||y==1?1:0;}\nint E(){\n\twhile(s[p]==')')p++;\n\tif(s[p]!='('){\n\t\tint q=p;\n\t\twhile(s[p]=='-')p++;\n\t\tq=(p-q)%2;\n\t\tif(s[p]=='(') q?A(E()):E();\n\t\telse return q?A(s[p]-'0'):s[p]-'0';\n\t}\n\tint x,y;char z;\n\tp++;x=E();p++;z=s[p];p++;y=E();p++;\n\treturn z!='+'?B(x,y):C(x,y);\n}\n\nint main(){\n\twhile(cin>>t,t!=\".\"){\n\t\ta=0;\n\t\trep(i,3)rep(j,3)rep(k,3){\n\t\t\tp=0;\n\t\t\ts=t;\n\t\t\trep(v,s.size())s[v]=s[v]=='P'?'0'+i:s[v]=='Q'?'0'+j:s[v]=='R'?'0'+k:s[v];\n\t\t\tif(E()==2)a++;\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nbool is_num(char c){return '0'<=c && c<='2';}\n\nll mns(ll a){\n    if(a==1){return a;}\n    return a^2;\n}\n\nll OR(ll a,ll b){\n    return min(a,b);\n}\n\nll pls(ll a,ll b){\n    return max(a,b);\n}\n\nll Ans(const string &s){\n    stack<char> S;\n    for(int i=0;i<s.size();i++){\n        if(is_num(s[i]) && !S.empty() && S.top()!='('){\n            ll a=s[i]-'0';\n            while(!S.empty() && S.top()!='('){\n                char c=S.top(); S.pop();\n                if(c=='-'){\n                    a=mns(a);\n                    continue;\n                }\n                ll b=S.top(); S.pop();\n                b-='0';\n                if(c=='*'){\n                    a=OR(a,b);\n                }\n                else if(c=='+'){\n                    a=pls(a,b);\n                }\n            }\n            S.push(a+'0');\n        }\n        else if(s[i]==')'){\n            ll a=S.top(); a-='0'; S.pop();\n            S.pop();\n            while(!S.empty() && S.top()!='('){\n                char c=S.top(); S.pop();\n                if(c=='-'){\n                    a=mns(a);\n                    continue;\n                }\n                ll b=S.top(); S.pop();\n                b-='0';\n                if(c=='*'){\n                    a=OR(a,b);\n                }\n                else if(c=='+'){\n                    a=pls(a,b);\n                }\n            }\n            S.push(a+'0');\n        }\n        else{\n            S.push(s[i]);\n        }\n    }\n    return S.top()-'0';\n}\n\n\n\nint main(){\n    string s;\n    while(cin>>s){\n        if(s==\".\"){break;}\n    vector<vector<ll>> A(3);\n    ll ans=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='P'){A[0].push_back(i);}\n        if(s[i]=='Q'){A[1].push_back(i);}\n        if(s[i]=='R'){A[2].push_back(i);}\n    }\n    for(int i=0;i<3;i++){\n        for(auto &I:A[0]){s[I]=i+'0';}\n        for(int t=0;t<3;t++){\n            for(auto &I:A[1]){s[I]=t+'0';}\n            for(int h=0;h<3;h++){\n                for(auto &I:A[2]){s[I]=h+'0';}\n                if(Ans(s)==2){ans++;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\nint eval(const string& s, int &pos)\n{\n\tif(s[pos] == '0') { ++pos; return 0; }\n\tif(s[pos] == '1') { ++pos; return 1; }\n\tif(s[pos] == '2') { ++pos; return 2; }\n\tif(s[pos] == '-') { ++pos; int v = eval(s, pos); return 2 - v;}\n\tif(s[pos] == '(') {\n\t\t++pos;\n\t\tint a = eval(s,pos);\n\t\t// evalの値には計算済みの値が帰ってくるはずだ\n\t\tchar c = s[pos++];\n\t\tint b = eval(s,pos);\n\t\t++pos;\n\t\tif(c == '*') {return (a * b + 1) / 2; }\n\t\tif(c == '+') {return max(a, b); }\n\t}\n\treturn 2;\n}\n\n\n\nint main (void)\n{\n\twhile(true)\n\t{\n\t\tstring s, temp;\n\t\tcin >> s;\n\t\tif(s == \".\") break;\n\t\tstring p, q, r;\n\t\tint count = 0;\n\t\tint pos;\n\t\t\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tif(j == 0) p = '0'; if(j == 1) p = '1'; if(j == 2) p = '2';\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tif(k == 0) q = '0'; if(k == 1) q = '1'; if(k == 2) q = '2';\n\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\tif(l == 0) r = '0'; if(l == 1) r = '1'; if(l == 2) r = '2';\n\t\t\t\t\ttemp = s;\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\t\t\t\tif(s.at(i) == 'P') { temp.replace(i, 1, p); }\n\t\t\t\t\t\tif(s.at(i) == 'Q') { temp.replace(i, 1, q); }\n\t\t\t\t\t\tif(s.at(i) == 'R') { temp.replace(i, 1, r); }\n\t\t\t\t\t}\n\t\t\t\t\tif(eval(temp, pos) == 2) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvoid change(string &s, char x, char b) {\n\trep(i, 0, s.size()) {\n\t\tif (s[i] == x) {\n\t\t\ts[i] = b;\n\t\t}\n\t}\n}\nvector<vector<int>>AND({ { 0,0,0 }, { 0,1,1 }, { 0,1,2 } }), OR({ {0,1,2},{1,1,2},{2,2,2} });\nvector<int>NOT({ 2,1,0 });\nvector<char>vc{ 'P', 'Q', 'R' };\n\nint eval(string &s, int &k) {\n\tdump(s.substr(k));\n\tdump(k);\n\tif (isdigit(s[k])) {\n\t\treturn s[k] - '0';\n\t}\n\telse if (s[k] == '-') {\n\t\treturn NOT[eval(s, ++k)];\n\t}\n\telse if (s[k] == '(') {\n\t\tk++;\n\t\tint a = eval(s, k);\n\t\tdump(a);\n\t\tk++;\n\t\tchar op = s[k];\n\t\tdump(op);\n\t\tk++;\n\t\tint b = eval(s, k);\n\t\tk++;\n\t\tdump(b);\n\t\tif (op == '*') return AND[a][b];\n\t\telse if (op == '+')return OR[a][b];\n\t}\n}\n\nsigned main() {\n\tstring s;\n\twhile (cin >> s, s != \".\") {\n\t\tint cnt(0);\n\t\tfor (char P = '0'; P <= '2'; P++) {\n\t\t\tfor (char Q = '0'; Q <= '2'; Q++) {\n\t\t\t\tfor (char R = '0'; R <= '2'; R++) {\n\t\t\t\t\tstring ex(s);\n\n\t\t\t\t\tchange(ex, 'P', P);\n\t\t\t\t\tchange(ex, 'Q', Q);\n\t\t\t\t\tchange(ex, 'R', R);\n\n\t\t\t\t\tint k(0);\n\t\t\t\t\tif (eval(ex, k) == 2)cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint a[] = {2, 1, 0}, b[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}}, c[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tREP(p, 3) REP(q, 3) REP(r, 3) {\n\t\t\t//cout << p << \" \" << q << \" \" << r << endl;\n\t\t\t//???????????°??????????????????\n\t\t\tstring t = s;\n\t\t\tREP(i, t.size()) {\n\t\t\t\tif(t[i] == 'P') t[i] = p + '0';\n\t\t\t\tif(t[i] == 'Q') t[i] = q + '0';\n\t\t\t\tif(t[i] == 'R') t[i] = r + '0';\n\t\t\t}\n\t\t\t//cout << t << endl;\n\t\t\twhile(true) {\n\t\t\t\t//???????????????\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '-') cnt++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cnt > 0) {\n\t\t\t\t\t\t\tif('0'<=t[i]&&t[i]<'3') {\n\t\t\t\t\t\t\t\tint tmp = t[i] - '0';\n\t\t\t\t\t\t\t\t//cout << \"cnt:\" << cnt << endl << tmp << \" \";\n\t\t\t\t\t\t\t\tREP(j, cnt) {\n\t\t\t\t\t\t\t\t\ttmp = a[tmp];\n\t\t\t\t\t\t\t\t\t//if(p == 0 && q == 0 && r == 0) cout << tmp << \" \";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//if(p == 0 && q == 0 && r == 0) cout << endl;\n\t\t\t\t\t\t\tt = t.substr(0, i-cnt) + (char)(tmp+'0') + t.substr(i+1);\n\t\t\t\t\t\t\ti -= cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << \"i:\" << i << \" cnt:\" << cnt << endl;\n\t\t\t\t}\n\t\t\t\t//cout << \"a:\" << t << endl;\n\t\t\t\t//?????£?????????+??¨*?????????\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '+') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1]) && t[i-2] == '(' && t[i+2] == ')') {\n\t\t\t\t\t\t\tint tmp = c[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t\ti -= 3;\n\t\t\t\t\t\t\t//cout << \"c:\" << t << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(t[i] == '*') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1]) && t[i-2] == '(' && t[i+2] == ')') {\n\t\t\t\t\t\t\tint tmp = b[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t\ti -= 3;\n\t\t\t\t\t\t\t//cout << \"d:\" << t << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"b:\" << t << endl;\n\t\t\t\tif(t.size() == 1) break;\n\t\t\t}\n\t\t\tif(t == \"2\") ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvoid change(string &s, char x, char b) {\n\trep(i, 0, s.size()) {\n\t\tif (s[i] == x) {\n\t\t\ts[i] = b;\n\t\t}\n\t}\n}\nvector<vector<int>>AND({ { 0,0,0 }, { 0,1,1 }, { 0,1,2 } }), OR({ {0,1,2},{1,1,2},{2,2,2} });\nvector<int>NOT({ 2,1,0 });\nvector<char>vc{ 'P', 'Q', 'R' };\n\nint eval(string &s, int &k) {\n\tdump(s.substr(k));\n\tdump(k);\n\tif (isdigit(s[k])) {\n\t\treturn s[k] - '0';\n\t}\n\telse if (s[k] == '-') {\n\t\treturn NOT[eval(s, ++k)];\n\t}\n\telse if (s[k] == '(') {\n\t\tk++;\n\t\tint a = eval(s, k);\n\t\tdump(a);\n\t\tk++;\n\t\tchar op = s[k];\n\t\tdump(op);\n\t\tk++;\n\t\tint b = eval(s, k);\n\t\tk++;\n\t\tdump(b);\n\t\tif (op == '*') return AND[a][b];\n\t\telse if (op == '+')return OR[a][b];\n\t}\n}\n\nsigned main() {\n\tstring s;\n\twhile (cin >> s, s != \".\") {\n\t\tint cnt(0);\n\t\tfor (char P = '0'; P <= '2'; P++) {\n\t\t\tfor (char Q = '0'; Q <= '2'; Q++) {\n\t\t\t\tfor (char R = '0'; R <= '2'; R++) {\n\t\t\t\t\tstring ex(s);\n\n\t\t\t\t\tchange(ex, 'P', P);\n\t\t\t\t\tchange(ex, 'Q', Q);\n\t\t\t\t\tchange(ex, 'R', R);\n\n\t\t\t\t\tint k(0);\n\t\t\t\t\tif (eval(ex, k) == 2)cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<climits>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define\tpf\tpush_front\n#define\tpb\tpush_back\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint not3(int p)\n{\n\tint res[3]={2,1,0};\n\treturn res[p];\n}\n\nint or3(int p,int q)\n{\n\tint res[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\treturn res[p][q];\n}\n\nint and3(int p,int q)\n{\n\tint res[3][3]={{0,0,0},{0,1,1},{0,1,2}};\n\treturn res[p][q];\n}\n\nstring subst(string x,int p,int q,int r)\n{\n\tfor(int i=0;i<x.length();i++){\n\t\tswitch(x[i]){\n\t\t\tcase 'P':\tx[i]=p+'0';\tbreak;\n\t\t\tcase 'Q':\tx[i]=q+'0';\tbreak;\n\t\t\tcase 'R':\tx[i]=r+'0';\tbreak;\n\t\t}\n\t}\n\treturn x;\n}\n\nint satisfy(string x,int p,int q,int r)\n{\n\tint len=x.length();\n\n\tif(x[0]=='(' && x[len-1]==')'){\n\t\tbool chk=true;\n\t\tfor(int i=1,d=1;i<len-1;i++){\n\t\t\tif(x[i]=='(')\td++;\n\t\t\tif(x[i]==')')\td--;\n\t\t\tif(d==0)\tchk=false;\n\t\t}\n\t\tif(chk)\treturn satisfy(x.substr(1,len-2),p,q,r);\n\t}\n\n\tint divpos=-1;\n\tfor(int i=0,d=0;i<len;i++){\n\t\tif(x[i]=='(')\td++;\n\t\tif(x[i]==')')\td--;\n\t\tif(d==0){\n\t\t\tif(x[i]=='-' && divpos==-1)\tdivpos=i;\n\t\t\tif(x[i]=='+')\tdivpos=i;\n\t\t\tif(x[i]=='*')\tdivpos=i;\n\t\t}\n\t}\n\n\tif(divpos!=-1){\n\t\tswitch(x[divpos]){\n\t\t\tcase '-':\n\t\t\t\treturn not3(satisfy(x.substr(divpos+1),p,q,r));\n\t\t\tcase '+':\n\t\t\t\treturn  or3(satisfy(x.substr(0,divpos),p,q,r),satisfy(x.substr(divpos+1),p,q,r));\n\t\t\tcase '*':\n\t\t\t\treturn and3(satisfy(x.substr(0,divpos),p,q,r),satisfy(x.substr(divpos+1),p,q,r));\n\t\t}\n\t}\n\telse{\n\t\treturn x[0]-'0';\n\t}\n}\n\nint main()\n{\n\tfor(string x;cin>>x,x!=\".\";){\n\t\tint cnt=0;\n\t\tfor(int p=0;p<3;p++)for(int q=0;q<3;q++)for(int r=0;r<3;r++)\n\t\t\tcnt+=satisfy(subst(x,p,q,r),p,q,r)==2?1:0;\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint rev[3] = {2,1,0};\nint seki[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint wa[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nint f(const string &s, int b, int e){ // [begin,end]\n    if(s[b] == '(' && s[e] == ')'){\n        return f(s, b+1, e-1);\n    }\n    vi v;\n    int ind = -1;\n    int nest = 0;\n    loop(i,b,e){\n        if(s[i] == '(') nest++;\n        if(s[i] == ')') nest--;\n        if((s[i] == '*' || s[i] == '+') && nest == 0)  ind = i;\n    }\n    int ret = -1;\n    if(ind < 0){\n        int t = 0;\n        loop(i,b,e)\n            if(s[i] == '-') t++;\n        if(t%2){\n            ret = rev[s[e] - '0'];\n        }else{\n            ret = s[e] - '0';\n        }\n        //cout << b <<\" \" << e << \" \" <<ret <<endl;\n        return ret;\n    }else{\n        ret = f(s, b, ind-1);\n        if(s[ind] == '+') ret = wa[ret][f(s,ind+1,e)];\n        else ret = seki[ret][f(s,ind+1,e)];\n    //    cout << b << \" \" << e <<\" \" <<ret << endl;\n        return ret;\n    }\n}\n\nint solve(string s, int a, int b, int c){\n    int n = s.size();\n    rep(i,n){\n        if(s[i] == 'P') s[i] = '0' + a;\n        if(s[i] == 'Q') s[i] = '0' + b;\n        if(s[i] == 'R') s[i] = '0' + c;\n    }\n    //cout << s << endl;\n    int ret = f(s, 0, n-1);\n    //cout << ret << endl;\n    return ret;\n}\n\nint main(void) {\n  string s;\n  while(cin >> s, s != \".\"){\n      int ans = 0;\n      rep(i,3)rep(j,3)rep(k,3){\n          //cout << i << \" \" << j << \" \" << k <<endl;\n          if(solve(s,i,j,k) == 2)ans++;\n        //  cout << solve(s,i,j,k) << endl;\n      }\n      cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint a[] = {2, 1, 0}, b[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}}, c[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tREP(p, 3) REP(q, 3) REP(r, 3) {\n\t\t\t//cout << p << \" \" << q << \" \" << r << endl;\n\t\t\t//???????????°??????????????????\n\t\t\tstring t = s;\n\t\t\tREP(i, t.size()) {\n\t\t\t\tif(t[i] == 'P') t[i] = p + '0';\n\t\t\t\tif(t[i] == 'Q') t[i] = q + '0';\n\t\t\t\tif(t[i] == 'R') t[i] = r + '0';\n\t\t\t}\n\t\t\t//cout << t << endl;\n\t\t\twhile(true) {\n\t\t\t\t//???????????????\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '-') cnt++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(cnt > 0) {\n\t\t\t\t\t\t\tif('0'<=t[i]&&t[i]<'3') {\n\t\t\t\t\t\t\t\tint tmp = t[i] - '0';\n\t\t\t\t\t\t\t\t//cout << \"cnt:\" << cnt << endl << tmp << \" \";\n\t\t\t\t\t\t\t\tREP(j, cnt) {\n\t\t\t\t\t\t\t\t\ttmp = a[tmp];\n\t\t\t\t\t\t\t\t\t//if(p == 0 && q == 0 && r == 0) cout << tmp << \" \";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//if(p == 0 && q == 0 && r == 0) cout << endl;\n\t\t\t\t\t\t\tt = t.substr(0, i-cnt) + (char)(tmp+'0') + t.substr(i+1);\n\t\t\t\t\t\t\ti -= cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << \"i:\" << i << \" cnt:\" << cnt << endl;\n\t\t\t\t}\n\t\t\t\t//cout << \"a:\" << t << endl;\n\t\t\t\t//?????£?????????+??¨*?????????\n\t\t\t\tREP(i, t.size()) {\n\t\t\t\t\tif(t[i] == '+') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1])) {\n\t\t\t\t\t\t\tint tmp = c[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t\ti -= 3;\n\t\t\t\t\t\t\t//cout << \"c:\" << t << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(t[i] == '*') {\n\t\t\t\t\t\tif(IN('0', '3', t[i-1]) && IN('0', '3', t[i+1]) && t[i-2] == '(' && t[i+2] == ')') {\n\t\t\t\t\t\t\tint tmp = b[t[i-1]-'0'][t[i+1]-'0'];\n\t\t\t\t\t\t\tt = t.substr(0, i-2) + (char)(tmp + '0') + t.substr(i+3);\n\t\t\t\t\t\t\ti -= 3;\n\t\t\t\t\t\t\t//cout << \"d:\" << t << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"b:\" << t << endl;\n\t\t\t\tif(t.size() == 1) break;\n\t\t\t}\n\t\t\tif(t == \"2\") ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint o=0;\nvoid rec(string str){\n  //cout << str << endl;\n  string next,buf;\n  if(str[0]!='('){\n    //cout << str << endl;\n    if(str[0]=='2') o++;\n    return;\n  }\n  for(int i=1;i<str.size();i++){\n    if('0'<=str[i]&&str[i]<='2') {\n      if(str[i-1]=='-') {\n\tif(str[i]=='0')  str[i]='2';\n\telse if(str[i]=='1')  str[i]='0';\n\telse if(str[i]=='2')  str[i]='1';\n\tstr[i-1]=' ';\n      }else if(str[i-1]=='*') {\n\tif(str[i-3]=='('){\n\tif(str[i]=='0'||str[i-2]=='0') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='0';\n\t  str[i+1]=' ';\n\t}else if(str[i]=='2'&&str[i-2]=='2') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='2';\n\t  str[i+1]=' ';\n\t}else if('0'<=str[i-2]&&str[i-2]<='2'){\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='1';\n\t  str[i+1]=' ';\n\t}\n\t}\n      }else if(str[i-1]=='+') {\n\tif(str[i-3]=='('){\n\tif(str[i]=='2'||str[i-2]=='2') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='2';\n\t  str[i+1]=' ';\n\t}else if(str[i]=='0'&&str[i-2]=='0') {\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='0';\n\t  str[i+1]=' ';\n\t}else if('0'<=str[i-2]&&str[i-2]<='2'){\n\t  str[i-3]=' ';\n\t  str[i-2]=' ';\n\t  str[i-1]=' ';\n\t  str[i]='1';\n\t  str[i+1]=' ';\n\t}\n\t}\n      }\n    }\n  }\n  for(int i=0;i<str.size();i++){\n    if(str[i]!=' ') next+=str[i];\n  }\n  rec(next);\n}\nint main(){\n  string str,buf;\n  cin >> str;\n  while(str!=\".\"){\n    int p[]={0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2};\n    int q[]={0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2};\n    int r[]={0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2};\n    o=0;\n    for(int i=0;i<27;i++){\n      buf=str;\n      for(int j=0;j<str.size();j++){\n\tif(buf[j]=='P') buf[j]=p[i]+'0';\n\tif(buf[j]=='Q') buf[j]=q[i]+'0';\n\tif(buf[j]=='R') buf[j]=r[i]+'0';\n      }\n      rec(buf);\n    }\n    cout << o << endl;\n    cin >> str;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint mynot(int i){\n  return 2 - i;\n}\n\nint myand(int i, int j){\n  if(i == 2 && j == 2){return 2;}\n  if(i == 0 || j == 0){return 0;}\n  return 1;\n}\n\nint myor(int i, int j){\n  if(i == 0 && j == 0){return 0;}\n  if(i == 2 || j == 2){return 2;}\n  return 1;\n}\n\nint interp(int P, int Q, int R, char* formula){\n  char* snd;\n  int   lcnt = 0;\n  int   ptr  = 0;\n\n  switch(formula[0]){\n    case '0':\n      return 0;\n      break;\n    case '1':\n      return 1;\n      break;\n    case '2':\n      return 2;\n      break;\n    case 'P':\n      return P;\n      break;\n    case 'Q':\n      return Q;\n      break;\n    case 'R':\n      return R;\n      break;\n    case '-':\n      return mynot(interp(P, Q, R, formula + 1));\n      break;\n    case '(':\n      int left, right;\n      ptr++;\n\n        if(formula[ptr] == '('){\n          int cnt = 1; ptr++;\n          while(cnt != 0){\n            if( formula[ptr] == '(' ){cnt++;}\n            if( formula[ptr] == ')' ){cnt--;}\n            ptr++;\n          }\n        }else if(formula[ptr] == '-'){\n          while(formula[ptr] == '-'){ptr++;}\n\n          if(formula[ptr] == '('){\n            int cnt = 1; ptr++;\n            while(cnt != 0){\n              if( formula[ptr] == '(' ){cnt++;}\n              if( formula[ptr] == ')' ){cnt--;}\n              ptr++;\n            }\n          }else{ptr++;}\n        }else{\n          ptr++;\n        }\n\n      if(formula[ptr] == '*'){\n        left  = interp(P, Q, R, formula + 1);\n        right = interp(P, Q, R, formula + ptr + 1);\n        return myand(left, right);\n      }\n      if(formula[ptr] == '+'){\n        left  = interp(P,Q,R, formula + 1);\n        right = interp(P,Q,R, formula + ptr + 1);\n        return myor(left, right);\n      }\n    }\n}\n\n\nint main(void){\n  while(1){\n    char formula[80];\n    cin >> formula;\n    if(formula[0] == '.') return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < 3 ; i++){\n      for(int j = 0; j < 3 ; j++){\n        for(int k = 0; k < 3 ; k++){\n          if(interp(i,j,k,formula) == 2) cnt++;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    cnt++;\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    return mminus(dfs());\n  }else{\n    return (int)(tmp[cnt]-'0');\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=(char)(i+'0');\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=(char)(j+'0');\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=(char)(k+'0');\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  cnt=0;\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint dot(int a, int b){\n    if(a == 0 || b == 0) return 0;\n    else if(a == 2 && b == 2) return 2;\n    else return 1;\n}\n\nint add(int a, int b){\n    if(a == 2 || b == 2) return 2;\n    else if(a == 0 && b == 0) return 0;\n    else return 1;\n}\n\n//[l, r)の真理値を返す\nint rec(int P, int Q, int R, string s, int l, int r){\n\n    int resp;\n    \n    //二項\n    if(s[l] == '('){\n        int a, b;\n        //必ずa+bの形をしている\n        int d = 0;\n        int enzan_idx;\n        \n        //演算子の位置を決める\n        for(int i = l + 1; i < n; i++){\n            if(s[i] == '(') d++;\n            else if(s[i] == ')') d--;\n\n\n\n            if((s[i] == '+' || s[i] == '*') && d == 0){\n                enzan_idx = i;\n                break;\n            }\n        }\n        \n        a = rec(P,Q,R,s, l + 1, enzan_idx);\n        b = rec(P,Q,R,s, enzan_idx + 1, r - 1);\n        \n        if(s[enzan_idx] == '+') resp = add(a, b);\n        else resp = dot(a, b);\n\n    }else{\n\n        //一項\n        int mainus = 0;\n        int idx;\n        for(int i = l; i < n; i++){\n            if(s[i] == '-') mainus = (mainus + 1) % 2;\n            else{\n                idx = i;\n                break;\n            }\n        }\n\n        //if(l == 1 && r == 3) cout << idx << endl;\n        int res;\n        if(s[idx] == 'P') res = P;\n        else if(s[idx] == 'Q') res = Q;\n        else if(s[idx] == 'R') res = R;\n        else res = (int)(s[idx] - '0');\n        //if(l == 1 && r == 3) cout << res << endl;\n\n        if(mainus){\n            if(res == 2) res = 0;\n            else if(res == 0) res = 2;\n        }\n\n        \n        resp = res;\n    }\n\n    //cout << l << \" \" << r << \" \" << resp << endl;\n    return resp;\n}\n\nint main(){\n\n    while(1){\n        string s; cin >> s;\n        if(s == \".\") break;\n        n = (int)s.size();\n        int ans = 0;\n        for(int P = 0; P < 3; P++){\n            for(int Q = 0; Q < 3; Q++){\n                for(int R = 0; R < 3; R++){\n                    ans += (rec(P, Q, R, s, 0, n) == 2);\n                }\n            }\n        }\n\n        //ans = rec(1, 1, 1, s, 0, n);\n        cout << ans << endl;\n    }\n\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nstring S;\nint t;\n\nint and3(int n1, int n2) {\n  if(n1 == 2 && n2 == 2) return 2;\n  if(n1 == 0 || n2 == 0) return 0;\n  return 1;\n}\n\nint or3(int n1, int n2) {\n  if(n1 == 0 && n2 == 0) return 0;\n  if(n1 == 2 || n2 == 2) return 2;\n  return 1;\n}\n\nint dfs(int p, int q, int r) {\n  if(S[t] == '0') {\n    t++;\n    return 0;\n  }\n  if(S[t] == '1') {\n    t++;\n    return 1;\n  }\n  if(S[t] == '2') {\n    t++;\n    return 2;\n  }\n  if(S[t] == 'P') {\n    t++;\n    return p;\n  }\n  if(S[t] == 'Q') {\n    t++;\n    return q;\n  }\n  if(S[t] == 'R') {\n    t++;\n    return r;\n  }\n  if(S[t] == '-') {\n    t++;\n    return 2 - dfs(p, q, r);\n  }\n  if(S[t] == '(') {\n    t++;\n    int n1 = dfs(p, q, r);\n    char op = S[t++];\n    int n2 = dfs(p, q, r);\n    int ret;\n    if(op == '*') ret = and3(n1, n2);\n    if(op == '+') ret = or3(n1, n2);\n    // cout << n1 << \" \" << op << \" \" << n2 << \" = \" << ret << endl;\n    t++;\n    return ret;\n  }\n}\n\nint main(void) {\n  while(cin >> S, S != \".\") {\n    int ans = 0;\n    REP(i, 0, 3) REP(j, 0, 3) REP(k, 0, 3) {\n      t = 0;\n      if(dfs(i, j, k) == 2) ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef string::const_iterator State;\n \nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\n \nint expression(State &begin){\n    int ret = term(begin); \n    for(;;){\n        if(*begin == '+'){\n            begin++; \n            ret = max(ret, term(begin)); \n        }else if(*begin == '*'){\n            begin++;\n            ret = min(ret, term(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(State &begin){\n    if(*begin == '-'){\n        begin++;\n        return 2 - (term(begin));\n    }else{\n        return factor(begin);\n    }\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;      \n    }else{\n        return number(begin);\n    }\n}\n \n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n \nint main(){\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \".\") break;\n        int ans = 0;\n        rep(i, 0, 3){\n            rep(j, 0, 3){\n                rep(k, 0, 3){\n                    string t = s;\n                    rep(l, 0, t.size()){\n                        if(t[l] == 'P') t[l] = '0' + i;\n                        if(t[l] == 'Q') t[l] = '0' + j;\n                        if(t[l] == 'R') t[l] = '0' + k;\n                    }\n                    State begin = t.begin();\n                    int tmp = expression(begin);\n                    if(tmp == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <ctype.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint P, Q, R;\nchar str[10000];\n\nint parse(int &index) {\n  char c = str[index++];\n  if (isdigit(c)) { return c - '0'; }\n  if (isalpha(c)) {\n    if (c == 'P') { return P; }\n    if (c == 'Q') { return Q; }\n    if (c == 'R') { return R; }\n    assert(false);\n  }\n  if (c == '-') {\n    int ans = parse(index);\n    if (ans == 0) { return 2; }\n    if (ans == 1) { return 1; }\n    if (ans == 2) { return 0; }\n    assert(false);\n  }\n  assert(c == '(');\n  int l, r;\n  l = parse(index);\n  char o = str[index++];\n  r = parse(index);\n  assert(str[index] == ')');\n  index++;\n  if (o == '+') {\n    if (l == 2 || r == 2) { return 2; }\n    if (l == 1 || r == 1) { return 1; }\n    if (l == 0 || r == 0) { return 0; }\n    assert(false);\n  } else if (o == '*') {\n    if (l == 0 || r == 0) { return 0; }\n    if (l == 1 || r == 1) { return 1; }\n    if (r == 2 || r == 2) { return 2; }\n    assert(false);\n  }\n  return 0;\n}\n\nint main() {\n  while (fgets(str, 9999, stdin), str[0] != '.') {\n    int ans = 0;\n    REP(P, 3) REP(Q,3) REP(R, 3) {\n      int index = 0;\n      if (parse(index) == 2) { ans++; }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring exp;\nint now,ans,p,q,r;\n\nint multi(int x,int y){\n\treturn min(x,y);\n}\n\nint plus(int x,int y){\n\treturn max(x,y);\n}\n\nint minus(int x){\n\tif(x==2)\n\t\treturn 0;\n\tif(x==1)\n\t\treturn 1;\n\tif(x==0)\n\t\treturn 2;\n\treturn false;\n}\nint calc(){\n\tif(exp[now]=='0' || exp[now]=='1' || exp[now]=='2'){\n\t\tchar temp=exp[now];\n\t\tnow++;\n\t\treturn temp-'0';\n\t}\n\tif(exp[now]=='P'){\n\t\tnow++;\n\t\treturn p;\n\t}else if(exp[now]=='Q'){\n\t\tnow++;\n\t\treturn q;\n\t}else if(exp[now]=='R'){\n\t\tnow++;\n\t\treturn r;\n\t}else if(exp[now]=='-'){\n\t\tnow++;\n\t\treturn minus(calc());\n\t}else if(exp[now]=='('){\n\t\tnow++;\n\t\tint left=calc(),right;\n\t\tif(exp[now]=='*'){\n\t\t\tnow++;\n\t\t\tright=calc();\n\t\t\tnow++;\n\t\t\treturn multi(left,right);\n\t\t}\n\t\telse if(exp[now]=='+'){\n\t\t\tnow++;\n\t\t\tright=calc();\n\t\t\tnow++;\n\t\t\treturn plus(left,right);\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tnow=0;\n\tans=0;\n\tint k;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int z=0;z<3;z++){\n\t\t\t\tp=i;\n\t\t\t\tq=j;\n\t\t\t\tr=z;\t\n\t\t\t\tk=calc();\n\t\t\t\tif(k==2){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tnow=0;\n\t\t\t}\n\tcout<<ans<<\"\\n\";\n}\n\n\nint main()\n{\n\tcin>>exp;\n\twhile(exp!=\".\"){\n\t\tsolve();\n\t\tcin>>exp;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nstring s;\n\nstring func(string s) {\n    stack<char> st;\n    string t = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i]) || isdigit(s[i])) {\n            t += s[i];\n            while (st.size() && st.top() == '-') t += st.top(), st.pop();\n        }\n        else if (s[i] != ')') st.push(s[i]);\n        else {\n            while (st.top() != '(') t += st.top(), st.pop();\n            st.pop();\n            while (st.size() && st.top() == '-') t += st.top(), st.pop();\n        }\n    }\n    return t;\n}\n\nstring func2(string s, int p, int q, int r) {\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'P') s[i] = '0'+p;\n        if (s[i] == 'Q') s[i] = '0'+q;\n        if (s[i] == 'R') s[i] = '0'+r;\n    }\n    return s;\n}\n\nint solve(string s) {\n    stack<int> st;\n    for (int i = 0; i < s.size(); i++) {\n        if (isdigit(s[i])) st.push(s[i]-'0');\n        if (s[i] == '-') {\n            int a = st.top(); st.pop();\n            a = 2 - a;\n            st.push(a);\n        }\n        if (s[i] == '+') {\n            int a = st.top(); st.pop();\n            int b = st.top(); st.pop();\n            a = max(a, b);\n            st.push(a);\n        }\n        if (s[i] == '*') {\n            int a = st.top(); st.pop();\n            int b = st.top(); st.pop();\n            a = min(a, b);\n            st.push(a);\n        }\n    }\n    if (st.top() == 2) return 1;\n    else return 0;\n}\n\nint main(void){\n    while (cin>>s && s != \".\") {\n        s = func(s);\n        int ans = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    string t = s;\n                    t = func2(t, i, j, k);\n                    ans += solve(t);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nmap<char,int> val;\nmap<char,function<int(int,int)>> op;\n\nbool nextval(){\n  val['R']++;\n  if(val['R'] == 3){\n    val['R'] = 0;\n    val['Q']++;\n    if(val['Q'] == 3){\n      val['Q'] = 0;\n      val['P']++;\n      if(val['P'] == 3){\n\tval['P'] = 0;\n\treturn false;\n      }\n    }\n  }\n  return true;\n}\n\nint solve(const string &s,int &i){\n  if(isdigit(s[i])){\n    return s[i++] - '0';\n    \n  }else if(val.count(s[i])){\n    return val[s[i++]];\n    \n  }else if(s[i] == '-'){\n    i++; // '-'\n    return  2 - solve(s,i);\n\n  }else if(s[i] == '('){\n    i++; // '('\n    int l = solve(s,i);\n    char m = s[i];\n    assert(op.count(m));\n    i++; // '+' or '*'\n    int r = solve(s,i);\n    i++; // ')'\n    return op[m](l,r);\n  }\n  assert(false);\n}\n\nint main(void){\n  string s;\n  val['P'] = val['Q'] = val['R'] = 0;\n  op['+'] = [](int x,int y){\n    if(x == 2 or y == 2) return 2;\n    else if(x == 1 or y == 1) return 1;\n    else return 0;\n  };\n  op['*'] = [](int x,int y){\n    if(x == 0 or y == 0) return 0;\n    else if(x == 1 or y == 1) return 1;\n    else return 2;\n  };\n  \n  while(cin >> s, s != \".\"){\n    int res = 0;\n    \n    do{\n      int index = 0;\n      if(solve(s,index) == 2)\n\tres++;\n    }while(nextval()); // 0,0,0で始まり0,0,0で終わる\n    \n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\nint Minus[3] = {2, 1, 0};\nint Prod[3][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\nint Sum[3][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus[res.first], res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum[lhs.first][rhs.first], rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod[lhs.first][rhs.first], rhs.second + 1);\n    }\n\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  } \n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        if (formula(0).first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint expression(string &s, string::iterator &begin) {\n    int ret = 0;\n    if (*begin >= '0') ret = *begin - '0';\n    if (*begin == '-') {\n        ret = 2 - expression(s, ++begin);\n    }\n    if (*begin == '(') {\n        ret = expression(s, ++begin);\n        begin++;\n        if (*begin == '*') {\n            ret = min(ret, expression(s, ++begin));\n        } else if (*begin == '+') {\n            ret = max(ret, expression(s, ++begin));\n        }\n        begin++;\n    }\n    return ret;\n}\n\nint solve(string S) {\n    int ret = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                string s;\n                for (int l = 0; l < S.length(); l++) {\n                    if (S[l] == 'P') s.push_back('0' + i);\n                    else if (S[l] == 'Q') s.push_back('0' + j);\n                    else if (S[l] == 'R') s.push_back('0' + k);\n                    else s.push_back(S[l]);\n                }\n                string::iterator begin = s.begin();\n                int tmp = expression(s, begin);\n                if (tmp == 2) ret++;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(void) {\n    string s;\n    vector<int> ans;\n    while (1) {\n        cin >> s;\n        if (s[0] == '.') break;\n        ans.push_back(solve(s));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring str;\n\nvoid a() {\n  for(int i = 0; i < str.length(); ++i) {\n    if(str[i] != '-') continue;\n    int j;\n    for(j = i+1; j < str.length() && str[j] == '-'; ++j);\n    if(j == i+1) continue;\n    if((j-i) % 2 == 0)\n      str = str.substr(0, i) + str.substr(j, str.length()-j);\n    else\n      str = str.substr(0, i+1) + str.substr(j, str.length()-j);\n  }\n}\n\nvoid b(string &s) {\n  for(int i = 0; i < s.length(); ++i) {\n    if(s[i] == '-') {\n      s = s.substr(0, i) + s.substr(i+1, s.length()-(i+1));\n      s[i] = '2'-(s[i]-'0');\n    }\n  }\n}\n\nint rec(string &, int);\nint rec2(string &, int);\nint rec3(string &, int);\nint pos;\n\nint rec2(string &s, int ans) {\n  int tmp = pos++;\n  if(tmp < s.length()) {\n    if(s[tmp] == '*') return min(ans, rec(s, 0));\n    else if(s[tmp] == '+') return max(ans, rec(s, 0));\n  }\n  return ans;\n}\n\nint rec(string &s,  int ans) {\n  int tmp = pos++;\n  if(tmp < s.length() && s[tmp] == '(') {\n    int aaa = rec(s, ans);\n    return rec2(s, aaa);\n  }\n  return rec2(s, s[tmp]-'0');\n}\n\nint solve() {\n  int cnt = 0;\n  a();\n  for(char p = '0'; p <= '2'; ++p) {\n    for(char q = '0'; q <= '2'; ++q) {\n      for(char r = '0'; r <= '2'; ++r) {\n\tstring tmp = str;\n\tfor(int i = 0; i < tmp.length(); ++i) {\n\t  if(tmp[i] == 'P') tmp[i] = p;\n\t  if(tmp[i] == 'Q') tmp[i] = q;\n\t  if(tmp[i] == 'R') tmp[i] = r;\n\t}\n\tpos = 0;\n\tb(tmp);\n\tif(rec(tmp, 0) == 2) {\n\t  //cout << tmp << endl;\n\t  cnt++;\n\t}\n      }\n    }\n  }\n  return cnt;\n}\n\nmain() {\n  while((cin >> str) && str != \".\") {\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n \n#define INF 100000000\n#define EPS 1e-9\n \nusing namespace std;\n \ntypedef long long ll;  \n\nint P, Q, R;\nstring str, tmpStr;\n\nint myNot[] = {2,1,0};\nint myAnd[3][3] = {{0,0,0},{0,1,1},{0,1,2}};\nint myOr[3][3] = {{0,1,2},{1,1,2},{2,2,2}};\n\nvector<int> ans_list;\n\n//左から何番目を基準にしているか\nbool solve(int num){\n\n  int tmai = 0;\n  int s = -1;\n  if(tmpStr[num] == '-')\n    tmai++;\n\n  for(int i = num + 1; i < tmpStr.length(); i++){\n    if(tmpStr[i] == '('){\n      solve(i);\n      break;\n    }\n    else if(tmpStr[i] == ')'){\n      int mai = 0; //マイナスが何回現れたか\n      int left = -1;\n      int right = -1; //左と右の数字\n      int ope = -1; //1:ans 2:or\n      for(int k = num+1; k < i; k++){\n\tif(tmpStr[k] == '-')\n\t  mai++;\n\telse if(tmpStr[k] == '*')\n\t  ope = 1;\n\telse if(tmpStr[k] == '+')\n\t  ope = 2;\n\telse{\n\t  mai %= 2;\n\t  int tmp = tmpStr[k] - '0';\n\t  if(left == -1)\n\t    left = tmp;\n\t  else\n\t    right = tmp;\n\t  mai = 0;\n\t}\n      }\n      int tmp = -1;\n      if(ope == 1)\n\ttmp = myAnd[left][right];\n      else\n\ttmp = myOr[left][right];\n      tmpStr.erase(num,i - num + 1);\n      tmpStr.insert(tmpStr.begin() + num, tmp + '0'); \n      break;\n    }\n    \n    else if(tmpStr[i] == '-'){\n      tmai++;\n      if(s == -1)\n\ts = i;\n    }\n    if(tmai > 0 && '0' <= tmpStr[i] && tmpStr[i] <= '2'){\n      int t = tmpStr[i] - '0';\n      if(tmai%2 == 1)\n\tt = myNot[t];\n      if(tmpStr[num] == '-'){\n\ttmpStr.erase(num, i-num+1);\n\ttmpStr.insert(tmpStr.begin() + num, t + '0');\n      }\n      else{\n\ttmpStr.erase(s, i-s + 1);\n\ttmpStr.insert(tmpStr.begin() + s, t + '0');\n      }\n      break;\n    }\n    \n  }\n\n  //文字の長さが1なら、それが2になっているかの判定\n  if(tmpStr.length() == 1){\n    if(tmpStr == \"2\")\n      return true;\n    else\n      return false;\n  }\n  \n  return false;\n\n}\n\nint main(){\n\n  while(true){\n    \n    cin >> str;\n    if(str == \".\")\n      break;\n\n    int ans = 0;\n    for(int i = 0; i < 27; i++){\n      P = i%3;\n      Q = (i/3)%3;\n      R = (i/9)%3;\n      tmpStr.clear();\n      tmpStr = str;\n      \n      for(int i = 0; i < tmpStr.length(); i++){\n\tif(tmpStr[i] == 'P')\n\t  tmpStr[i] = P + '0';\n\telse if(tmpStr[i] == 'Q')\n\t  tmpStr[i] = Q + '0';\n\telse if(tmpStr[i] == 'R')\n\t  tmpStr[i] = R + '0';\n      }\n\n      while(true){\n\tif(tmpStr.length() != 1)\n\t  solve(0);\n\telse\n\t  break;\n      }\n\n      if(solve(0))\n\tans++;\n\n    }\n\n    ans_list.push_back(ans);\n\n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    cnt++;\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return (int)(tmp[cnt]-'0');\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    for(int i=0;i<20000;i++)\n      tmp[i]='\\0';\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[l]=(char)(i+'0');\n\t    }else if(s[l]=='Q'){\n\t      tmp[l]=(char)(j+'0');\n\t    }else if(s[l]=='R'){\n\t      tmp[l]=(char)(k+'0');\n\t    }else{\n\t      tmp[l]=s[l];\n\t    }\n\t  }\n\t  cnt=0;\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    string s;\n    cin >> s;\n    if (s == \".\") break;\n    vector<int> v(3);\n    function<int(int &)> dfs = [&](int &i) -> int {\n      if (s[i] == '(') {\n        i++;\n        int e = dfs(i);\n        if (s[i] == '+') {\n          i++;\n          cmax(e, dfs(i));\n        }\n        if (s[i] == '*') {\n          i++;\n          cmin(e, dfs(i));\n        }\n        i++; // ')'\n        return e;\n      }\n      if (s[i] == '-') {\n        i++;\n        return 2 - dfs(i);\n      }\n      if (isdigit(s[i])) return s[i++] - '0';\n      return v[s[i++] - 'P'];\n    };\n    int cnt = 0;\n    for (v[0] = 0; v[0] < 3; v[0]++) {\n      for (v[1] = 0; v[1] < 3; v[1]++) {\n        for (v[2] = 0; v[2] < 3; v[2]++) {\n          int i = 0;\n          cnt += dfs(i) == 2;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//p,q,rに代入(これで、P,Q,Rが消滅)\nstring substitute(string s, int p, int q, int r) {\n\tREP(i, s.size()) {\n\t\tswitch (s[i]) {\n\t\tcase 'P':s[i] = '0' + p; break;\n\t\tcase 'Q':s[i] = '0' + q; break;\n\t\tcase 'R':s[i] = '0' + r; break;\n\t\t}\n\t}\n\treturn s;\n}\n\n\n//末尾にある数値に対して、インバースを適用(これで、-が消滅)\nvoid apply_inverse(stack<char>& info)\n{\n\tchar t = info.top();\n\tif (t < '0' || '2' < t)return;\n\tinfo.pop();\n\n\twhile (!info.empty() && info.top() == '-') {\n\t\tinfo.pop();\n\t\tif (t == '2')t = '0';\n\t\telse if (t == '0')t = '2';\n\t}\n\tinfo.push(t);\n}\n\n\n//演算子を実際に適用(これで、(,+,*,)が消滅 )\nvoid apply_operator(stack<char>& info)\n{\n\tchar r = info.top(); info.pop();\n\tchar ope = info.top(); info.pop();\n\tchar l = info.top(); info.pop();\n\n\tchar err = info.top(); info.pop();\n\tif (err != '(') {\n\t\texit(1);\n\t}\n\tl -= '0';\n\tr -= '0';\n\tchar res;\n\tswitch (ope) {\n\tcase '+':\n\t\tif (max(l, r) == 2)res = '2';\n\t\telse if (l + r == 0)res = '0';\n\t\telse res = '1';\n\t\tbreak;\n\tcase '*':\n\t\tif (min(l, r) == 0)res = '0';\n\t\telse if (l + r == 4)res = '2';\n\t\telse res = '1';\n\t\tbreak;\n\tdefault:\n\t\texit(1);\n\t}\n\tinfo.push(res);\n}\n\nvoid de(stack<char> s) {\n\tstring tmp;\n\twhile (!s.empty()) {\n\t\ttmp += s.top();\n\t\ts.pop();\n\t}\n\treverse(tmp.begin(), tmp.end());\n\tcout << tmp << endl;\n}\n\n//構文を実際に計算する\nbool play(string s) {\n\t//cout << s << endl;\n\n\tstack<char> info;\n\tfor (char c : s) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tinfo.push(c);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tapply_operator(info);\n\t\t\tapply_inverse(info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.push(c);\n\t\t\tbreak;\n\t\t}\n\t\tde(info);\n\t}\n\n\tif (info.size() != 1) {\n\t\texit(1);\n\t}\n\telse {\n\t\treturn info.top() == '2';\n\t}\n}\n\n\n//全探索を行う\nvoid calc(string formula)\n{\n\tint res = 0;\n\tREP(p, 3)REP(q, 3)REP(r, 3) {\n\t\tstring target = substitute(formula, p, q, r);\n\t\t//cout << \"pqr:: \" << p << q << r << endl;\n\t\tif (play(target)) {\n\t\t\tres++;\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tstring formula;\n\t\tcin >> formula;\n\n\t\tif (formula == \".\")break;\n\t\tcalc(formula);\n\t}\n\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\nstring s;\nint i;\nvector<int> v(3);\nint add(int a, int b) {\n\tif (a == 2 || b == 2)return 2;\n\tif (a == 1 || b == 1)return 1;\n\treturn 0;\n}\nint mult(int a, int b) {\n\tif (a == 0 || b == 0)return 0;\n\tif (a == 1 || b == 1)return 1;\n\treturn 2;\n}\nint nt(int a) {\n\treturn 2 - a;\n}\nint form() {\n\tif (isdigit(s[i]))return s[i++] - '0';\n\telse if (isalpha(s[i]))return v[s[i++] - 'P'];\n\telse if (s[i] == '(') {\n\t\t++i;\n\t\tint a = form();\n\t\tchar c = s[i];\n\t\t++i;\n\t\tint b = form();\n\t\t++i;\n\t\tif (c == '+') {\n\t\t\treturn add(a, b);\n\t\t}\n\t\telse if (c == '*') {\n\t\t\treturn mult(a, b);\n\t\t}\n\t}\n\telse {\n\t\t++i;\n\t\tint a = form();\n\t\treturn nt(a);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> s) {\n\t\tif (s == \".\")break;\n\t\t\n\t\tint cnt = 0;\n\t\tREP(j, 27) {\n\t\t\ti = 0;\n\t\t\tv[0] = j / 9;\n\t\t\tv[1] = j % 9 / 3;\n\t\t\tv[2] = j % 3;\n\t\t\tif (form() == 2)cnt++;\n\t\t}\n\t\n\t\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nint parse(string& s, int &pos) {\n\tif ('0' <= s[pos] and s[pos] <= '2') {\n\t\tpos++;\n\t\treturn s[pos - 1] - '0';\n\t}\n\telse if (s[pos] == '-') {\n\t\tpos++;\n\t\tint res = parse(s, pos);\n\t\treturn 2 - res;\n\t}\n\telse {\n\t\tpos++;\n\t\tint p = parse(s, pos);\n\t\tchar c = s[pos];\n\t\tpos++;\n\t\tint q = parse(s, pos);\n\t\tpos++;\n\t\tif (c == '+') return max(p, q);\n\t\telse return min(p, q);\n\t}\n}\n\nvoid solve() {\n\tstring s; cin >> s; if (s == \".\") exit(0);\n\tint res = 0;\n\tfor (char P = '0'; P < '3'; P++) {\n\t\tfor (char Q = '0'; Q < '3'; Q++) {\n\t\t\tfor (char R = '0'; R < '3'; R++) {\n\t\t\t\tstring t = s;\n\t\t\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\t\t\tif (t[i] == 'P') t[i] = P;\n\t\t\t\t\tif (t[i] == 'Q') t[i] = Q;\n\t\t\t\t\tif (t[i] == 'R') t[i] = R;\n\t\t\t\t}\n\t\t\t\tint pos = 0;\n\t\t\t\tif (parse(t, pos) == 2) res++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}\nint main()\n{\n\t\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include <string>\n#define cinf(n,x,y) for(int i=0;i<(n);i++) cin >> x[i] >> y[i];\ntypedef long long int ll;\nusing namespace std;\nint eval(string s,int&pos){\n\tif(s[pos]=='0'){\n\t\t++pos; return 0;\n\t}\n\tif(s[pos]=='1'){\n\t\t++pos; return 1;\n\t}\n\tif(s[pos]=='2'){\n\t\t++pos; return 2;\n\t}\n\tif(s[pos]=='-'){\n\t\t++pos; return 2- eval(s,pos);\n\t}\n\tif(s[pos]=='('){\n\t\t++pos;\n\t\tint a=eval(s,pos);\n\t\tchar c =s[pos++];\n\t\tint b= eval(s,pos);\n\t\tpos++;\n\t\tif(c =='*'){\n\t\t\treturn min(a,b);\n\t\t}\n\t\tif(c =='+'){\n\t\t\treturn max(a,b);\n\t\t}\n\t}\n}\n\nint solve(const string&str){\n\tint cnt=0;\n\tfor(int p=0;p<=2;p++){\n\t\tfor(int q=0;q<=2;q++){\n\t\t\tfor(int r=0;r<=2;r++){\n\t\t\t\tstring s=str;\n\t\t\t\tfor(int i=0;i<s.size();i++){\n\t\t\t\t\tif(s[i]=='P'){\n\t\t\t\t\t\ts[i]=p+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif(s[i]=='Q'){\n\t\t\t\t\t\ts[i]=q+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif(s[i]=='R'){\n\t\t\t\t\t\ts[i]=r+'0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint t=0;\n\t\t\t\tif(eval(s,t)==2){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\nint main(){\n \tstring str;\n \twhile(1){\n \t\tcin >>str;\n \t\tif(str==\".\")break;\n \t\tcout << solve(str) << endl;\n \t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int INF=INT_MAX,MOD=1e9+7;\n\nstack<int> num;\nstack<char> cal;\n\nvoid calc_and(int x,int y){\n\tif(x==0||y==0) num.push(0);\n\telse if(x==1||y==1) num.push(1);\n\telse num.push(2);\n}\nvoid calc_or(int x,int y){\n\tif(x==2||y==2) num.push(2);\n\telse if(x==1||y==1) num.push(1);\n\telse num.push(0);\n}\nvoid calc_not(){\n\tint x=num.top(); num.pop();\n\tif(x==0) num.push(2);\n\tif(x==1) num.push(1);\n\tif(x==2) num.push(0);\n}\nvoid calc(){\n\tint x=num.top(); num.pop();\n\tint y=num.top(); num.pop();\n\tchar c=cal.top(); cal.pop();\n\tif(c=='+') calc_or(x,y);\n\tif(c=='*') calc_and(x,y);\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\treverse(s.begin(),s.end());\n\t\tint cnt=0;\n\t\tfor(int p=0;p<3;p++){\n\t\t\tfor(int q=0;q<3;q++){\n\t\t\t\tfor(int r=0;r<3;r++){\n\t\t\t\t\tfor(int i=0;i<(int)s.size();i++){\n\t\t\t\t\t\tif('0'<=s[i]&&s[i]<='2') num.push(s[i]-'0');\n\t\t\t\t\t\tif(s[i]=='P') num.push(p);\n\t\t\t\t\t\tif(s[i]=='Q') num.push(q);\n\t\t\t\t\t\tif(s[i]=='R') num.push(r);\n\t\t\t\t\t\tif(s[i]=='+') cal.push('+');\n\t\t\t\t\t\tif(s[i]=='*') cal.push('*');\n\t\t\t\t\t\tif(s[i]=='-') calc_not();\n\t\t\t\t\t\tif(s[i]=='(') calc();\n\t\t\t\t\t}\n\t\t\t\t\tint x=num.top(); num.pop();\n\t\t\t\t\tif(x==2) cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint bar[3] = {2,1,0};\n\nint mul[3][3] = {\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint add[3][3] = {\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\n\nstring s;\nint PQR[3];\n\nbool isvar(char c) { return (c - '0' >= 0 && c - '0' <= 2) || (c - 'P' >= 0 && c - 'P' <= 2); }\nint getvar(char c) {\n\tif (0 <= c - '0' && c - '0' <= 2) return c - '0';\n\treturn PQR[c - 'P'];\n}\n\nint rec(int lft, int rgt) {\n\t//cerr << s.substr(lft, rgt-lft) << endl;\n\tint open_cnt = 0, close_cnt = 0, bar_cnt = 0;\n\tint nxt_lft = -1;\n\t\n\tstack< int > st;\n\tstack< char > op;\n\tfor_(i,lft,rgt) {\n\t\tif (open_cnt == close_cnt && s[i] == '-') {\n\t\t\t++bar_cnt;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && isvar(s[i])) {\n\t\t\tint x = getvar(s[i]);\n\t\t\tfor_(rep,0,bar_cnt) x = bar[x];\n\t\t\tst.push(x);\n\t\t\tbar_cnt = 0;\n\t\t}\n\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '*') op.push('*');\t\t\n\t\tif (open_cnt == close_cnt && s[i] == '+') op.push('+');\n\t\t\n\t\tif (s[i] == '(') {\n\t\t\tif (open_cnt == close_cnt) nxt_lft = i+1;\n\t\t\t++open_cnt;\n\t\t}\n\t\t\n\t\tif (s[i] == ')') {\n\t\t\t++close_cnt;\n\t\t\tif (open_cnt == close_cnt) {\n\t\t\t\tint x = rec(nxt_lft, i);\n\t\t\t\tfor_(rep,0,bar_cnt) x = bar[x];\n\t\t\t\tst.push(x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (st.size() >= 2 && !op.empty()) {\n\t\t\tchar opr = op.top(); op.pop();\n\t\t\tint x = st.top(); st.pop();\n\t\t\tint y = st.top(); st.pop();\n\t\t\tif (opr == '*') st.push(mul[x][y]);\n\t\t\tif (opr == '+') st.push(add[x][y]);\n\t\t}\n\t}\n\t\n\treturn st.top();\n}\n\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \".\") break;\n\t\tint ans = 0;\n\t\tfor_(p,0,3) for_(q,0,3) for_(r,0,3) {\n\t\t\tPQR[0] = p; PQR[1] = q; PQR[2] = r;\n\t\t\tif (rec(0, s.size()) == 2) ++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nvi alpha(3);\nint t;\nint formula(int a){\n\tint out=-1;\n\tint co=0;\n\tif(s[t]=='(')++t,out=formula(0);\n\telse if(s[t]=='-')++t,out=2-formula(1);\n\telse if(isdigit(s[t]))out=s[t]-'0';\n\telse if(isalpha(s[t]))out=alpha[s[t]-'P'];\n\t\n\tif(a)return out;\n\tt++;\n\tif(s[t]=='*'){\n\t\tt++;\n\t\tout=min(out,formula(0));\n\t}else if(s[t]=='+'){\n\t\tt++;\n\t\tout=max(out,formula(0));\n\t}\n\t\n\tif(co%2)out=2-out;\n\t\n\treturn out;\n}\nvoid f(){\n\tint co=0;\n\trep(P,3)rep(Q,3)rep(R,3){\n\t\tt=0;\n\t\talpha[0]=P;\n\t\talpha[1]=Q;\n\t\talpha[2]=R;\n\t\tif(formula(0)==2)co++;\n\t}\n\tcout<<co<<endl;\n}\nint main(){\n\twhile(cin>>s,s!=\".\")f();\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nchar tmp[20000];\nint cnt=0;\nint mminus(int num){\n  if(num==1)return 1;\n  else if(num==2)return 0;\n  else return 2;\n}\nint dfs(){\n  if(tmp[cnt]=='('){\n    cnt++;\n    int le=dfs();\n    if(tmp[cnt]=='*'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      //cout<<le<<\" \"<<ri<<endl;\n      if(le==2&&ri==2){\n\treturn 2;\n      }else if(le!=0&&ri!=0){\n\treturn 1;\n      }else\n\treturn 0;\n    }else if(tmp[cnt]=='+'){\n      cnt++;\n      int ri=dfs();\n      cnt++;\n      if(le==0&&ri==0)return 0;\n      else if(le==2||ri==2)return 2;\n      else return 1;\n    }\n  }else if(tmp[cnt]=='-'){\n    cnt++;\n    mminus(dfs());\n  }else{\n    return tmp[cnt++]-'0';\n  }\n}\nint main(){\n  string s;\n  while(cin>>s,s!=\".\"){\n    int ans=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  int tm=0;\n\t  cnt=0;\n\t  for(int l=0;l<s.size();l++){\n\t    if(s[l]=='P'){\n\t      tmp[tm++]=i+'0';\n\t    }else if(s[l]=='Q'){\n\t      tmp[tm++]=j+'0';\n\t    }else if(s[l]=='R'){\n\t      tmp[tm++]=k+'0';\n\t    }else{\n\t      tmp[tm++]=s[l];\n\t    }\n\t  }\n\t  if(dfs()==2)ans++;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\n\nint Minus(int a) {\n  return 2 - a;\n}\n\nint Prod(int a, int b) {\n  if (a == 0) {\n    return 0;\n  }\n  if (b == 0) {\n    return 0;\n  }\n  if (a == 1) {\n    return 1;\n  }\n  if (b == 1) {\n    return 1;\n  }\n  if (a == 2) {\n    return 2;\n  }\n}\n\nint Sum(int a, int b) {\n  return 2 - Prod(2 - a, 2 - b);\n}\n/*\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\n\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n*/\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus(res.first), res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum(lhs.first, rhs.first), rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod(lhs.first, rhs.first), rhs.second + 1);\n    }\n    assert(false);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt = 0;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res = formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring str;\nint p;\n\nint negate_(int f) { return 2 - f; }\n\nint add(int a, int b) {\n  if (a == 2 || b == 2) {\n    return 2;\n  } else if (a == 0 && b == 0) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint mult(int a, int b) {\n  if (a * b == 0) {\n    return 0;\n  } else if (a * b == 4) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nint P, Q, R;\n\nint term(char c) {\n  switch (c) {\n    case 'P':\n     return P;\n    case 'Q':\n      return Q;\n    case 'R':\n      return R;\n  }\n}\n\nint formula() {\n  if (str[p] == '-') {\n    p++; // read -\n    int f = formula();\n    return negate_(f);\n  } else if (isdigit(str[p])) {\n    int f = str[p] - '0';\n    p++; // read [0-2]\n    return f;\n  } else if (isalpha(str[p])) {\n    int f = term(str[p]);\n    p++; // read [P-R]\n    return f;\n  } else {\n    p++; // read (\n    int a = formula();\n    if (str[p] == '*') {\n      p++; // read *\n      int b = formula();\n      p++; // read )\n      return mult(a, b);\n    } else {\n      p++; // read +\n      int b = formula();\n      p++; // read )\n      return add(a, b);\n    }\n  }\n}\n\nint main() {\n  while (cin >> str and str != \".\") {\n    p = 0;\n    int ans = 0;\n    for (P = 0; P < 3; P++) \n      for (Q = 0; Q < 3; Q++)\n        for (R = 0; R < 3; R++)\n          if (p = 0, formula() == 2) \n            ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nint main()\n{\n\t//真理値表\n\tchar getminus[3], getmulti[3][3], getplus[3][3];\n\tgetminus[0] = '2';\n\tgetminus[1] = '1';\n\tgetminus[2] = '0';\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (i == 0 || j == 0){\n\t\t\t\tgetmulti[i][j] = '0';\n\t\t\t}\n\t\t\telse if (i == 2 && j == 2){\n\t\t\t\tgetmulti[i][j] = '2';\n\t\t\t}\n\t\t\telse\n\t\t\t\tgetmulti[i][j] = '1';\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (i == 2 || j == 2){\n\t\t\t\tgetplus[i][j] = '2';\n\t\t\t}\n\t\t\telse if (i == 0 && j == 0){\n\t\t\t\tgetplus[i][j] = '0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tgetplus[i][j] = '1';\n\t\t}\n\t}\n\n\tstring s, inits;\n\twhile (cin >> inits, inits[0] != '.'){\n\t\tint counter = 0;\n\t\tfor (char p = '0'; p < '3'; p++){\n\t\t\tfor (char q = '0'; q < '3'; q++){\n\t\t\t\tfor (char r = '0'; r < '3'; r++){\n\t\t\t\t\ts = inits;\n\t\t\t\t\twhile (s.length()>1){\n\t\t\t\t\t\t//代入\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length(); i++){\n\t\t\t\t\t\t\tif (s[i] == 'P'){\n\t\t\t\t\t\t\t\ts[i] = p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (s[i] == 'Q'){\n\t\t\t\t\t\t\t\ts[i] = q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (s[i] == 'R'){\n\t\t\t\t\t\t\t\ts[i] = r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \"-\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length() - 1; i++){\n\t\t\t\t\t\t\tif (s[i] == '-'&& s[i + 1] != '-' && s[i + 1] != '('){\n\t\t\t\t\t\t\t\ts[i] = getminus[(int)s[i + 1] - '0'];\n\t\t\t\t\t\t\t\ts.erase(s.begin() + i + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//\"*\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length() - 4; i++){\n\t\t\t\t\t\t\tif (s[i] == '('&& s[i + 2] == '*' && s[i + 4] == ')'){\n\t\t\t\t\t\t\t\ts[i] = getmulti[(int)s[i + 1] - '0'][(int)s[i + 3] - '0'];\n\t\t\t\t\t\t\t\ts.erase(i + 1, 4);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//\"+\"を探索し，書き換える\n\t\t\t\t\t\tfor (int i = 0; i < (signed)s.length() - 4; i++){\n\t\t\t\t\t\t\tif (s[i] == '('&& s[i + 2] == '+' && s[i + 4] == ')'){\n\t\t\t\t\t\t\t\ts[i] = getplus[(int)s[i + 1] - '0'][(int)s[i + 3] - '0'];\n\t\t\t\t\t\t\t\ts.erase(i + 1, 4);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s.length() == 1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (s[0] == '2'){\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter++ << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint solve(string s, int p, int q, int r){\n    s=regex_replace(s,regex(\"P\"),to_string(p));\n    s=regex_replace(s,regex(\"Q\"),to_string(q));\n    s=regex_replace(s,regex(\"R\"),to_string(r));\n    string a=\"\";\n    for(auto c:s){\n        int n=\"012\"s.find(c);\n        if(n!=-1 and a.back()=='-'){\n            a.back()=\"210\"[n];\n        }else{\n            a+=c;\n        }\n        if(c==')'){\n            auto f=a.substr(0,a.size()-5);\n            auto p=a.substr(a.size()-5);\n            if(f.back()=='-'){\n                if(p[2]=='+'){\n                    a=f.substr(0,f.size()-1)+\"210\"[\"012\"s.find(max(p[1],p[3]))];\n                }else{\n                    a=f.substr(0,f.size()-1)+\"210\"[\"012\"s.find(min(p[1],p[3]))];\n                }\n            }else{\n                if(p[2]=='+'){\n                    a=f+max(p[1],p[3]);\n                }else{\n                    a=f+min(p[1],p[3]);\n                }\n            }\n        }\n    }\n    return a==\"2\"?1:0;\n}\n\nint main(void){\n    string s;\n    while(cin>>s,s!=\".\"){\n        auto cp=regex_replace(s,regex(\"--\"),\"\");\n        int ans=0;\n        rep(p,3)rep(q,3)rep(r,3){\n            ans+=solve(cp,p,q,r);\n        }\n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing Int = long long int;\nusing String = std::string;\ntemplate <class T>\nusing Vector = std::vector<T>;\n\nstruct {\n    Vector<Int> var;\n    String s;\n    Int i;\n\n    Int expr() {\n        Int ret;\n        if (s[i] == '(') {\n            ++i;\n            Int a = expr();\n            char c = s[i];\n            ++i;\n            Int b = expr();\n            ++i;\n\n            if (c == '*') {\n                ret = std::min(a, b);\n            } else if (c == '+') {\n                ret = std::max(a, b);\n            }\n        } else if (s[i] == '-') {\n            ++i;\n            Int a = expr();\n            ret = 2 - a;\n        } else if (isdigit(s[i])) {\n            ret = s[i] - '0';\n            ++i;\n        } else if ('P' <= s[i] && s[i] <= 'R') {\n            ret = var[s[i] - 'P'];\n            ++i;\n        }\n        return ret;\n    }\n\n    Int operator()() {\n        i = 0;\n        return expr();\n    }\n} parser;\n\nbool solve() {\n    std::cin >> parser.s;\n    if (parser.s == \".\") return false;\n\n    Int ans = 0;\n    Vector<Int> v(3);\n    for (v[0] = 0; v[0] <= 2; ++v[0]) {\n        for (v[1] = 0; v[1] <= 2; ++v[1]) {\n            for (v[2] = 0; v[2] <= 2; ++v[2]) {\n                parser.var = v;\n                if (parser() == 2) ++ans;\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring str;\nint p, q, r;\n\nint negation( int &pt);\nint prod( int x, int y );\nint disj( int x, int y );\nint calc( int &pt );\nint getv( char ch);\nint getlhs( int &pt );\nint getrhs( int &pt );\n\nint solve(){\n\n\tint cnt = 0;\n\tcin >> str;\n\tif( str == \".\" ) { return 0; }\n\t\n\t\n\tfor( p = 0; p < 3; p++ )\n\t\tfor( q = 0; q < 3; q++ )\n\t\t\tfor( r = 0; r < 3; r++ ) {\n\t\t\t\tint ptr = 0;\n\t\t\t\tif( calc( ptr ) == 2 )\n\t\t\t\t\tcnt ++;\n\t\t\t}\n\n\tcout << cnt << endl;\n\n\treturn 1;\n\n}\n\nint main( void ) {\n\n\twhile( solve() ) {}\n\n\treturn 0;\n}\n\nint getvalue( int &pt ) {\n\tswitch( str[pt] ) {\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tbreak;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tbreak;\n\t\tcase '2':\n\t\t\treturn 2;\n\t\tbreak;\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tbreak;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tbreak;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tbreak;\n\t}\n\treturn 0;\n}\nint negation( int &pt ) {\n\tif( str[pt] == '-' ) {\n\t\tpt ++;\n\t\treturn 2 - negation(pt);\n\t}\n\tif( str[pt] == '(' ) {\n\t\tpt ++;\n\t\treturn 2-calc(pt);\n\t}\n\tint ret = 2-getvalue(pt);\n\tpt ++;\n\treturn ret;\n}\nint disj( int x, int y ) {\n\t//?????????\n\tif( x == y ) { return x; }\n\tif( x + y > 2 ) { return 2; }\n\treturn x + y;\n}\nint prod( int x, int y ) {\n\t//?????????\n\tif( x == 0 || y == 0 ) { return 0; }\n\tif( x == 2 && y == 2 ) { return 2; }\n\treturn 1;\n}\n\nint calc( int &pt ) {\n\n\t//?????????????????????\n\tint lhs;\n\tif( str[pt] == '-' ) {\n\t\tlhs = negation(++pt);\n\t} else if( str[pt] == '(' ) {\n\t\tlhs = calc(++pt);\n\t} else {\n\t\tlhs = getvalue(pt);\n\t\t++pt;\n\t}\n\n\t\n\t//????????????lhs?????????\n\tif( ( pt >= str.length() - 1 ) || ( str[pt] == ')' ) ) {\n\t\t++pt;\n\t\treturn lhs;\n\t}\n\n\t//?????????????????????\n\tchar op = str[pt];\n\t++pt;\n\n\t//?????????????????????\n\tint rhs;\n\tif( str[pt] == '-' ) {\n\t\trhs = negation(++pt);\n\t} else if( str[pt] == '(' ) {\n\t\trhs = calc(++pt);\n\t} else {\n\t\trhs = getvalue(pt);\n\t\t++pt;\n\t}\n\n\tif( pt < str.length() && str[pt] == ')' ) {\n\t\tpt ++;\n\t}\n\n\n\tswitch( op ) {\n\t\tcase '+':\n\t\t\treturn disj( lhs, rhs );\n\t\tbreak;\n\t\tcase '*':\n\t\t\treturn prod( lhs, rhs );\n\t\tbreak;\n\t}\n\n\treturn -1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm> // min, max\n#include<cctype> // isdigit\n#include<cassert> //assert\nusing namespace std;\n\nstring exp;\nint pos;\nmap<char,int>value;\n\nint formula()\n{\n  if(isdigit(exp[pos])){\n    return exp[pos++]-'0';\n  }\n  if(isalpha(exp[pos])){\n    return value[ exp[pos++] ];\n  }\n  if(exp[pos]=='-'){\n    pos++;\n    return 2-formula();\n  }\n  if(exp[pos]=='('){\n    pos++;\n    int left=formula();\n    char op=exp[pos++];\n    int right=formula();\n    assert(exp[pos++]==')');\n    if(op=='*'){\n      return min(left,right);\n    }\n    if(op=='+'){\n      return max(left,right);\n    }\n  }\n}\n\nint main()\n{\n  int ans;\n  while(cin>>exp,exp!=\".\"){\n    ans=0;\n    for(int p=0;p<=2;p++)for(int q=0;q<=2;q++)for(int r=0;r<=2;r++){\n      value['P']=p;\n      value['Q']=q;\n      value['R']=r;\n      pos=0;\n      if(formula()==2)ans++;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint _and[3][3]={0,0,0,0,1,1,0,1,2};\nint _or[3][3]={0,1,2,1,1,2,2,2,2};\nint _not[3]={2,1,0};\nchar pyon(string s,int p,int q,int r){\n\tint cnt=0,f;\n\tvector<int> V;\n\tREP(i,s.size()){\n\t\tif(s[i]=='*')f=0;\n\t\telse if(s[i]=='+')f=1;\n\t\telse if(s[i]=='-')cnt++;\n\t\telse{\n\t\t\tint mt=s[i]=='P'?p:s[i]=='Q'?q:s[i]=='R'?r:s[i]-'0';\n\t\t\tif(cnt%2==1){\n\t\t\t\tmt=_not[mt];\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\tV.PB(mt);\n\t\t}\n\t}\n\tif(f==0)return (char)(_and[V[0]][V[1]]+'0');\n\telse return (char)(_or[V[0]][V[1]]+'0');\n}\nint rec(string s,int p,int q,int r){\n\tstack<int> pr;\n\twhile(s.size()>1){\n\t\tREP(i,s.size()){\n\t\t\tif(s[i]=='(')pr.push(i);\n\t\t\tif(s[i]==')'){\n\t\t\t\tint top=pr.top();pr.pop();\n\t\t\t\tstring t;\n\t\t\t\tt.assign(s,top+1,i-top-1);\n\t\t\t\tchar tt=pyon(t,p,q,r);\n\t\t\t\ts.erase(top,i-top+1);\n\t\t\t\ts.insert(s.begin()+top,tt);\n\t\t\t\ti=top-1;\n\t\t\t}\n\t\t}\n\t}\n\treturn (s[0]-'0');\n}\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\".\"){\n\t\tint cnt=0;\n\t\tREP(i,3)REP(j,3)REP(k,3){\n\t\t\tint res=rec(s,i,j,k);\n\t\t\tif(res==2)cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint parse(const string& f)\n{\n\tif (f.size() == 1)\n\t\treturn f[0] - '0';\n\telse if (f[0] == '-')\n\t{\n\t\tint r = parse(f.substr(1));\n\t\tif (r == 0 || r == 2)\n\t\t\t r ^= 2;\n\t\treturn r;\n\t}\n\telse\n\t{\n\t\tchar op;\n\t\tint pos;\n\t\tfor (int i = 1, paren = 0; ; ++i)\n\t\t{\n\t\t\tif (f[i] == '(')\n\t\t\t\t++paren;\n\t\t\telse if (f[i] == ')')\n\t\t\t\t--paren;\n\t\t\telse if (paren == 0 && (f[i] == '+' || f[i] == '*'))\n\t\t\t{\n\t\t\t\tpos = i;\n\t\t\t\top = f[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint left = parse(f.substr(1, pos - 1));\n\t\tint right = parse(f.substr(pos + 1, f.size() - (pos + 2)));\n\t\tif (op == '*')\n\t\t\treturn min(left, right);\n\t\telse\n\t\t\treturn max(left, right);\n\t}\n}\nstring set_value(const string& f, int p, int q, int r)\n{\n\tstring res = f;\n\tfor (int i = 0; i < f.size(); ++i)\n\t{\n\t\tif (res[i] == 'P')\n\t\t\tres[i] = p + '0';\n\t\telse if (res[i] == 'Q')\n\t\t\tres[i] = q + '0';\n\t\telse if (res[i] == 'R')\n\t\t\tres[i] = r + '0';\n\t}\n\treturn res;\n}\nint main()\n{\n\tstring f;\n\twhile (cin >> f, f[0] != '.')\n\t{\n\t\tint res = 0;\n\t\tfor (int p = 0; p < 3; ++p)\n\t\t\tfor (int q = 0; q < 3; ++q)\n\t\t\t\tfor (int r = 0; r < 3; ++r)\n\t\t\t\t\tif (parse(set_value(f, p, q, r)) == 2)\n\t\t\t\t\t\t++res;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\n// <formula> ::= 0 | 1 | 2 | P | Q | R |\n// -<formula> | (<formula>*<formula>) | (<formula>+<formula>)\n\nint eval(string &s,int &i,map<char,int> &v){\n    char c = s[i];\n    i++;\n    if(isdigit(c) || isalpha(c)) return v[c];\n    if(c == '-') return 2-eval(s,i,v);\n    int l = eval(s,i,v);\n    char op = s[i];\n    i++;\n    int r = eval(s,i,v);\n    i++;\n    if(op == '*'){\n        if(l*r == 0) return 0;\n        if(l*r == 4) return 2;\n        return 1;\n    }\n    if(op == '+'){\n        if(l+r == 0) return 0;\n        if(l== 2 || r == 2) return 2;\n        return 1;\n    }\n    assert(false);\n}\n\nint main(void){\n    string s;\n    while(cin>>s, s!=\".\"){\n        int cnt = 0;\n        map<char,int> v;\n        rep(i,3) v['0'+i] = i;\n        rep(p,3)rep(q,3)rep(r,3){\n            int i = 0;\n            v['P'] = p;\n            v['Q'] = q;\n            v['R'] = r;\n            if(eval(s,i,v)==2) cnt++;\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nint Minus(int _a)\n{\n    return 2 - _a;\n}\n\nint Plus(int _a, int _b)\n{\n    return max(_a, _b);\n}\n\nint Product(int _a, int _b)\n{\n    return min(_a, _b);\n}\n\nint calc(int _p, int _q, int _r, string _in)\n{\n//    cout << _in << endl;\n    if(_in.size() == 1)\n    {\n        return _in == \"P\" ? _p : \n               _in == \"Q\" ? _q :\n               _in == \"R\" ? _r :\n               stoi(_in);\n    }\n\n\n    if(_in[0] == '-'){\n        //cout << \" - \" << _in.substr(1) << endl;\n        return Minus(calc(_p, _q, _r, _in.substr(1)));\n    }\n\n    int num = 1;\n    int count = 1;\n    string mae = \"\";\n    while(num < _in.size())\n    {\n        if(count == 1)\n        {            \n            if(_in[num] == '*'){\n                //cout << mae << \" * \" << _in.substr(num + 1, _in.size() - mae.size() - 2) << endl;\n                return Product( calc(_p, _q, _r, mae), calc(_p, _q, _r, _in.substr(num + 1, _in.size() - num - 2) ) );\n            }\n            if(_in[num] == '+'){\n                //cout << mae << \" + \" << _in.substr(num + 1, _in.size() - mae.size() - 2) << endl;\n                 return Plus( calc(_p, _q, _r, mae), calc(_p, _q, _r, _in.substr(num + 1, _in.size() - num - 2)) );\n            }\n        }\n    \n        if(_in[num] == '(')count++;\n        if(_in[num] == ')')count--;\n        \n        mae += _in[num];\n        num++;\n    }\n    \n}\n\nint main()\n{\n    string input;\n\n    while(cin >> input, input != \".\")\n    {\n        int ans = 0;\n        for(int p = 0; p <= 2; p++)\n        {\n            for(int q = 0; q <= 2; q++)\n            {\n                for(int r = 0; r <= 2; r++)\n                {\n                    ans += ( calc(p, q, r, input) == 2 );\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    /*\n    cout << calc(0, 1, 0, \"((---P+Q)*(--Q+---R))*(-R+-P))\") << endl;\n    cout << calc(0, 1, 0, \"(---P+Q)\") << endl;\n    cout << calc(0, 1, 0, \"(--Q+---R)\") << endl;\n    cout << calc(0, 1, 0, \"(-R+-P)\") << endl;\n    cout << calc(0, 1, 0, \"--Q)\") << endl;\n    cout << calc(0, 1, 0, \"---R)\") << endl;\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\n#define inRange(x,a,b) (a <= x && x <= b)\n\nint p, q, r;\n\nint NOT(int a){\n    return 2-a;\n}\nint AND(int a, int b){\n    if(a == 2 & b == 2)     return 2;\n    if(a >= 1 && b >= 1)    return 1;\n    return 0;\n}\nint OR(int a, int b){\n    if(a == 2 || b == 2)    return 2;\n    if(a == 1 || b == 1)    return 1;\n    return 0;\n}\n\nint formula(State &begin){\n    if(inRange(*begin, '0', '2')){\n        int ret = (*begin)-'0';\n        begin++;\n        return ret;\n    }\n    if(inRange(*begin, 'P', 'R')){\n        char c = *(begin);\n        begin++;\n        if(c == 'P')    return p;\n        if(c == 'Q')    return q;\n        if(c == 'R')    return r;\n    }\n    if(*begin == '-'){\n        begin++;\n        return NOT(formula(begin));\n    }\n    if(*begin == '('){\n        begin++;\n        int ret = formula(begin);\n        while(true){\n            if(*begin == '*'){\n                begin++;\n                ret = AND(ret, formula(begin));\n            }else if(*begin == '+'){\n                begin++;\n                ret = OR(ret, formula(begin));\n            }else{\n                break;\n            }\n        }\n        begin++;    // ')'\n        return ret;\n    }\n}\n\nint main(){\n    string s;\n    while(cin >> s, s != \".\"){\n        int ans = 0;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                for(int k = 0; k < 3; k++){\n                    p = i, q = j, r = k;\n                    State begin = s.begin();\n                    if(formula(begin) == 2) ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nint saiki(string str){\n\t//cout<<str<<endl;\n\t\n\tif(str[0]>='0' && str[0]<='2')return str[0]-'0';\n\t\n\tif(str[0]=='-'){\n\t\tint val = saiki(str.substr(1,str.size()-1));\n\t\treturn (val-1)*-1+1;\n\t}\n\t\n\tif(str[0]=='('){\n\t\tint count = 0;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='(')count++;\n\t\t\tif(str[i]==')')count--;\n\t\t\t\n\t\t\tif(count==1 && str[i]=='*'){\n\t\t\t\treturn min(saiki(str.substr(1,i-1)),saiki(str.substr(i+1,str.size()-i-2)));\n\t\t\t}\n\t\t\tif(count==1 && str[i]=='+'){\n\t\t\t\treturn max(saiki(str.substr(1,i-1)),saiki(str.substr(i+1,str.size()-i-2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tB:;\n\t\n\tstring str;\n\tcin>>str;\n\tif(str.size()==1 && str[0]=='.')return 0;\n\t\n\tint ans = 0;\n\trep(i,3){\n\t\trep(j,3){\n\t\t\trep(k,3){\n\t\t\t\tstring strcopy = str;\n\t\t\t\trep(p,str.size()){\n\t\t\t\t\tif(str[p]=='P')str[p]='0'+i;\n\t\t\t\t\tif(str[p]=='Q')str[p]='0'+j;\n\t\t\t\t\tif(str[p]=='R')str[p]='0'+k;\n\t\t\t\t}\n\t\t\t\tint val = saiki(str);\n\t\t\t\tstr = strcopy;\n\t\t\t\t\n\t\t\t\tif(val==2)ans++;\n\t\t\t}\n\t\t}\n\t}\n\tA:;\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto B;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = ((int)a) - 1; i >= ((int)a); --i)\n#define all(x) x.begin(), x.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (p == 0 && x == ',') {\n            cerr << \"=\" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#ifdef LOCAL\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0) \n#else\n#define dump(...)\n#endif\n\nconstexpr int DY[8] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconstexpr int DX[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nstruct State {\n    string s;\n    int i;\n    char next() {\n        char ret = check();\n        i++;\n        return ret;\n    }\n    char check() {\n        if (sz(s) == i) {\n            return '$';\n        }\n        return s[i];\n    }\n};\n\nint neg(int a) {\n    if (a == 0) return 2;\n    if (a == 1) return 1;\n    if (a == 2) return 0;\n    assert(false);\n}\nint mul(int a, int b) {\n    return min(a, b);\n}\nint add(int a, int b) {\n    return max(a, b);\n}\n\nint P, Q, R;\n\nint num(State &st) {\n    char x = st.next();\n    if ('0' <= x && x <= '2') return x - '0';\n    if (x == 'P') return P;\n    if (x == 'Q') return Q;\n    if (x == 'R') return R;\n    assert(false);\n}\nint formula(State &st) {\n    char x = st.check();\n    if (x == '-') {\n        st.next();\n        return neg(formula(st));\n    } else if (x == '(') {\n        st.next();\n        int left = formula(st);\n        char op = st.next();\n        int right = formula(st);\n        x = st.next();\n        assert(x == ')');\n        if (op == '*') {\n            return mul(left, right);\n        } else {\n            return add(left, right);\n        }\n    } else {\n        return num(st);\n    }\n}\n\nvoid solve(string s) {\n    int ans = 0;\n    rep(p, 0, 3) {\n        rep(q, 0, 3) {\n            rep(r, 0, 3) {\n                P = p, Q = q, R = r;\n                State st = {s, 0};\n                int res = formula(st);\n                if (res == 2) {\n                    ans++;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \".\") break;\n        solve(s);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint it, n;\nint vals;\n\nint formula() {\n\tint res;\n\tif (s[it] == '-') {\n\t\tit++;\n\t\tres = 2 - formula();\n\t}\n\telse if ('0' <= s[it] && s[it] <= '2') {\n\t\tres = s[it] - '0';\n\t\tit++;\n\t}\n\telse if (s[it] == 'P') {\n\t\tit++;\n\t\tres = vals % 3;\n\t}\n\telse if (s[it] == 'Q') {\n\t\tit++;\n\t\tres = vals / 3 % 3;\n\t}\n\telse if (s[it] == 'R') {\n\t\tit++;\n\t\tres = vals / 9;\n\t}\n\telse {\n\t\tassert(s[it++] == '(');\n\t\tres = formula();\n\t\tif (s[it] == '*') {\n\t\t\tit++;\n\t\t\tres = min(res, formula());\n\t\t}\n\t\telse {\n\t\t\tassert(s[it++] == '+');\n\t\t\tres = max(res, formula());\n\t\t}\n\t\tassert(s[it++] == ')');\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> s, s != \".\") {\n\t\tn = s.size();\n\t\tint res = 0;\n\t\tfor (vals = 0; vals < 27; vals++) {\n\t\t\tit = 0;\n\t\t\tif (formula() == 2) res++;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nmap<char, int> gensi;\nint NOT[3] = {2, 1, 0};\nint AND[3][3] = {{0, 0, 0},\n\t       {0, 1, 1},\n\t       {0, 1, 2},};\nint OR[3][3]  = {{0, 1, 2},\n\t       {1, 1, 2},\n\t       {2, 2, 2},};\nint formular(string&, int&);\nint factor(string&, int&);\nint term(string&, int&);\n\nint formular(string& str, int& p){\n  int res = term(str, p);\n  while(str[p] == '*' || str[p] == '+'){\n    if(str[p] == '*'){\n      p++;\n      return(AND[res][term(str, p)]);\n    }else{\n      p++;\n      return(OR[res][term(str, p)]);\n    }\n  }\n  return res;\n}\n\nint term(string& str, int& p){\n  int res;\n  while(str[p] == '('){\n    while(str[p] != ')'){\n      p++;\n      res = formular(str, p);\n      p++;\n      return res;\n    }\n  }\n  while(str[p] == '-'){\n    p++;\n    return(NOT[term(str, p)]);\n  }\n  while(isdigit(str[p])){\n    res = str[p] - '0';\n    p++;\n    return res;\n  }\n  while(str[p] == 'P' || str[p] == 'Q' || str[p] == 'R'){\n    res = gensi[str[p]];\n    p++;\n    return res;\n  }\n}\n\nint main(void){\n  string str;\n  while(cin >> str, str != \".\"){\n    int ans = 0;\n    for(gensi['P'] = 0; gensi['P'] < 3; gensi['P']++){\n      for(gensi['Q'] = 0; gensi['Q'] < 3; gensi['Q']++){\n        for(gensi['R'] = 0; gensi['R'] < 3; gensi['R']++){\n          int p = 0;\n          if(formular(str, p) == 2){\n            ans++;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nvi alpha(3);\nint t;\nint formula(int a){\n\tint out=-1;\n\tint co=0;\n\tif(s[t]=='(')++t,out=formula(0);\n\telse if(s[t]=='-')++t,out=2-formula(1);\n\telse if(isdigit(s[t]))out=s[t]-'0';\n\telse if(isalpha(s[t]))out=alpha[s[t]-'P'];\n\t\n\tif(a)return out;\n\tt++;\n\tif(s[t]=='*'){\n\t\tt++;\n\t\tout=min(out,formula(0));\n\t}else if(s[t]=='+'){\n\t\tt++;\n\t\tout=max(out,formula(0));\n\t}\n\t\n\tif(co%2)out=2-out;\n\t\n\treturn out;\n}\nvoid f(){\n\tint co=0;\n\trep(P,3)rep(Q,3)rep(R,3){\n\t\tt=0;\n\t\talpha[0]=P;\n\t\talpha[1]=Q;\n\t\talpha[2]=R;\n\t\tif(formula(0)==2)co++;\n\t}\n\tcout<<co<<endl;\n}\nint main(){\n\twhile(cin>>s,s!=\".\")f();\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nint OR[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint AND[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nint conv(char a, int p, int q, int r){\n\tswitch(a){\n\t\tcase 'P':\n\t\t\treturn p;\n\t\tcase 'Q':\n\t\t\treturn q;\n\t\tcase 'R':\n\t\t\treturn r;\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t}\n}\n\nbool calc(char *s, int P, int Q, int R){\n\tstd::stack<char> st;\n\t\n\tfor(int i=0; s[i]!='\\0'; i++){\n\t\n\t\tif(s[i] == ')'){\n\t\t\tint m;\n\t\t\n\t\t\tchar rc = st.top();\n\t\t\tst.pop();\n\t\t\tint r = conv(rc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2){\n\t\t\t\tif(r == 0)\n\t\t\t\t\tr = 2;\n\t\t\t\telse if(r == 2)\n\t\t\t\t\tr = 0;\n\t\t\t}\n\t\t\t\n\t\t\tchar o = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tchar lc = st.top();\n\t\t\tst.pop();\n\t\t\tint l = conv(lc, P, Q, R);\n\t\t\tfor(m=0; st.top()=='-'; m++)\n\t\t\t\tst.pop();\n\t\t\tif(m%2){\n\t\t\t\tif(l == 0)\n\t\t\t\t\tl = 2;\n\t\t\t\telse if(l == 2)\n\t\t\t\t\tl = 0;\n\t\t\t}\n\t\t\tst.pop();\n\t\t\n\t\t\t\n\t\t\tif(o == '*')\n\t\t\t\tst.push((char)(AND[r][l]+'0'));\n\t\t\telse\n\t\t\t\tst.push((char)(OR[r][l]+'0'));\n\t\t}\n\t\telse\n\t\t\tst.push(s[i]);\n\t\t\t\n\t}\n\t\n\tif(st.top() == '2')\n\t\treturn true;\n\treturn false;\n}\n\nint solve(char *s){\n\tint ans = 0;\n\tfor(int p=0; p<3; p++)\n\t\tfor(int q=0; q<3; q++)\n\t\t\tfor(int r=0; r<3; r++)\n\t\t\t\tif(calc(s, p, q, r))\n\t\t\t\t\tans++;\n\treturn ans; \n}\n\nint main(){\n\n\tchar x[80];\n\t\n\twhile(true){\n\t\tstd::cin >> x;\n\t\t\n\t\tif(x[0] == '.')\n\t\t\tbreak;\n\t\t\t\n\t\tstd::cout << solve(x) << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint p,q,r,i;\nint dfs(){\n  int t[2]={},c=0,m=0,w=0,k=0,a=0,pp=0;\n  t[0]=t[1]=-100;\n  if(s[i]=='(')i++;\n  for(;i<s.size();i++){pp=0;\n    if(s[i]=='(')t[c++]=dfs(),a++,pp++;\n    else if(s[i]>='0'&&s[i]<='2')t[c++]=s[i]-'0',a++;\n    else if(s[i]=='P')t[c++]=p,a++;\n    else if(s[i]=='Q')t[c++]=q,a++;\n    else if(s[i]=='R')t[c++]=r,a++;\n    else if(s[i]=='-')m++;\n    else if(s[i]=='+')w++,a=0;\n    else if(s[i]=='*')k++,a=0;\n    if(m%2&&a){\n     t[c-1]=abs(t[c-1]-2);\n     a=m=0;\n   }\n    if(s[i]==')'&&!pp){\n      if(c==1)return t[0];\n      if(w)return max(t[0],t[1]);\n      if(k)return min(t[0],t[1]);\n    }\n  }\n  return t[0];\n}\nint main(){\n  while(cin>>s,s!=\".\"){\n      int res=0;\n      r(x,3)r(y,3)r(z,3){\n\tp=x;q=y;r=z;i=0;\n\tif(dfs()==2)res++;\n      }\n      cout<<res<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nint wa[3][3]{\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\nint se[3][3]{\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\nint calc(string& s, int &idx);\nint brac(string& s, int &idx);\nint number(string& s, int &idx);\nint calc(string& s, int &idx) {\n\tint val1 = brac(s, idx);\n\twhile (s[idx] == '*' || s[idx] == '+') {\n\t\tidx++;\n\t\tif (s[idx - 1] == '+') {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = wa[val1][val2];\n\t\t}\n\t\telse {\n\t\t\tint val2 = brac(s, idx);\n\t\t\tval1 = se[val1][val2];\n\t\t}\n\t}\n\treturn val1;\n}\nint brac(string& s, int &idx) {\n\tint re = 0;\n\twhile (s[idx] == '-') {\n\t\tre++;\n\t\tidx++;\n\t}\n\tif (isdigit(s[idx])) {\n\t\tint val = number(s, idx);\n\t\tif (re % 2 == 0)\n\t\t\treturn val;\n\t\telse {\n\t\t\tif (re % 2 == 1)\n\t\t\t\tif (val == 0)\n\t\t\t\t\tval = 2;\n\t\t\t\telse if (val == 2)\n\t\t\t\t\tval = 0;\n\t\t\treturn val;\n\t\t}\n\t}\n\tidx++;\n\tint val=calc(s, idx);\n\tidx++;\n\tif (re % 2 == 1)\n\t\tif (val == 0)\n\t\t\tval = 2;\n\t\telse if (val == 2)\n\t\t\tval = 0;\n\treturn val;\n\treturn val;\n}\nint number(string& s, int &idx) {\n\tint val = s[idx] - '0';\n\tidx++;\n\t\n\treturn val;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s,s!=\".\") {\n\t\tint ans = 0;\n\t\tREP(i,3) {\n\t\t\tREP(j,3) {\n\t\t\t\tREP(k,3) {\n\t\t\t\t\tstring s2 = s;\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'P',(char)('0'+i) );\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'Q', (char)('0' + j));\n\t\t\t\t\treplace(s2.begin(), s2.end(), 'R', (char)('0' + k));\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (calc(s2,num) == 2)\n\t\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\nstring s,tmp;\nchar aa[]={'P','Q','R'};\n\nstring schange(string s,char a,char b){\n\trep(i,s.size()){\n\t\tif(s[i]==a){\n\t\t\ts[i]=b;\n\t\t}\n\t}\n\treturn s;\n}\n\nstring NOT(string t){\n\tif(t[1]=='1') return \"1\";\n\telse if(t[1]=='2') return \"0\";\n\treturn \"2\";\n}\nstring AND(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==0||b==0) return \"0\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"2\";\n}\nstring OR(string t){\n\tint a,b;\n\tchar r;\n\tstringstream ss1;\n\tss1<<t;\n\tss1>>a;\n\tss1>>r;\n\tss1>>b;\n\tif(a==2||b==2) return \"2\";\n\telse if(a==1||b==1) return \"1\";\n\treturn \"0\";\n}\nbool isnum(char t){\n\tif(t>='0'&&t<='2') return true;\n\treturn false;\n}\n\nint calc(string tmp){\n\t// cout<<tmp<<endl;\n\tif(tmp.size()==1&&tmp[0]=='2') return 2;\n\telse if(tmp.size()==1) return 0;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='('){\n\t\t\tif(tmp[i+2]==')'){\n\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\t\t\ttmp=tmp.substr(0,i)+tmp.substr(i+1,1)+tmp.substr(i+3);\n\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\n\t\t\t}\n\t\t}\n\t\telse if(tmp[i]=='-'){\n\t\t\tif(isnum(tmp[i+1])){\n\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\t\t\ttmp=tmp.substr(0,i)+NOT(tmp.substr(i,2))+tmp.substr(i+2);\n\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\n\t\t\t}\n\t\t}\n\t\telse if(tmp[i]=='*'){\n\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\n\t\t\t\ttmp=tmp.substr(0,i-1)+AND(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\n\t\t\t}\n\t\t}\n\t\telse if(tmp[i]=='+'){\n\t\t\tif(isnum(tmp[i-1])&&isnum(tmp[i+1])){\n\t\t\t\t// cout<<\"before \"<<tmp<<endl;\n\t\t\t\t\n\t\t\t\ttmp=tmp.substr(0,i-1)+OR(tmp.substr(i-1,3))+tmp.substr(i+2);\n\t\t\t\t// cout<<\"after \"<<tmp<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn calc(tmp);\n}\n\nint solve(){\n\tint ans=0;\n\tint c=0;\n\trep(i,3){\n\t\tif(s.find(aa[i])){\n\t\t\ts = schange(s,aa[i],'a'+c);\n\t\t\tc++;\n\t\t}\n\t}\n\t// cout<<s<<endl;\n\trep(i,3){\n\t\trep(j,3){\n\t\t\trep(k,3){\n\t\t\t\ttmp=s;\n\t\t\t\t// cout<<tmp<<endl;\n\t\t\t\ttmp = schange(tmp,'a',i+'0');\n\t\t\t\ttmp = schange(tmp,'b',j+'0');\n\t\t\t\ttmp = schange(tmp,'c',k+'0');\n\t\t\t\t// cout<<tmp<<endl;\n\t\t\t\tif(calc(tmp)==2){\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout<<\"ans \"<<ans<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\n}\n\n\nint main(){\n\twhile(cin>>s,s!=\".\"){\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n \ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n \nint not_[3]={2,1,0};\nint and_[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint or_[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n \nint i,p,q,r;\nint rec(string s)\n{\n  stack<char>key;\n  int ans=0,v;\n  key.push('+');\n  while(i<s.size())\n    {\n      if(s[i]==')')\n    {return ans;}\n      else if(s[i]=='+'||s[i]=='-'||s[i]=='*')\n      key.push(s[i++]);\n      else\n    {\n      if(s[i]=='(')\n        {i++;v=rec(s);}\n      else if(s[i]=='P')v=p;\n      else if(s[i]=='Q')v=q;\n      else if(s[i]=='R')v=r;\n      else\n          v=s[i]-'0';\n      while(!key.empty())\n        {\n          if(key.top()=='+')\n        ans=or_[ans][v];\n          else if(key.top()=='-')\n        {\n          v=not_[v];\n          if(key.size()==1)ans=v;\n        }\n          else if(key.top()=='*')\n        ans=and_[ans][v];\n          key.pop();\n        }\n      i++;\n    }\n    }\n  return ans;\n}\n \nint main()\n{\n  string s;\n  while(cin>>s)\n    {\n      if(s[0]=='.')return 0;\n      int a,b,c;\n      int cnt=0;\n      rep(a,3)rep(b,3)rep(c,3)\n    {\n      p=a;q=b;r=c;\n      i=0;\n      if(rec(s)==2)cnt++;\n    }\n      cout<<cnt<<endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\n\nint P,Q,R;\n\n\nint Minus(int a) {\n  return 2 - a;\n}\n\nint Prod(int a, int b) {\n  if (a == 0) {\n    return 0;\n  }\n  if (b == 0) {\n    return 0;\n  }\n  if (a == 1) {\n    return 1;\n  }\n  if (b == 1) {\n    return 1;\n  }\n  if (a == 2) {\n    return 2;\n  }\n}\n\nint Sum(int a, int b) {\n  return 2 - Prod(2 - a, 2 - b);\n}\n/*\nint Minus[] = {2, 1, 0};\n\nint Prod[][3] = {\n  {0, 0, 0},\n  {0, 1, 1},\n  {0, 1, 2}};\n\nint Sum[][3] = {\n  {0, 1, 2},\n  {1, 1, 2},\n  {2, 2, 2}};\n*/\ntypedef pair<int, int> Res;\n\nRes formula(int i) {\n  if (str[i] == '-') {\n    Res res = formula(i + 1);\n    return Res(Minus(res.first), res.second);\n  } else if (str[i] == '(') {\n    Res lhs = formula(i + 1);\n    i = lhs.second;\n    if (str[i] == '+') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Sum(lhs.first, rhs.first), rhs.second + 1);\n    } else if (str[i] == '*') {\n      Res rhs = formula(i + 1);\n      assert(str[rhs.second] == ')');\n      return Res(Prod(lhs.first, rhs.first), rhs.second + 1);\n    }\n    assert(true);\n  } else if (str[i] == 'P') {\n    return Res(P, i + 1);\n  } else if (str[i] == 'Q') {\n    return Res(Q, i + 1);\n  } else if (str[i] == 'R') {\n    return Res(R, i + 1);\n  } else if (str[i] == '0') {\n    return Res(0, i + 1);\n  } else if (str[i] == '1') {\n    return Res(1, i + 1);\n  } else if (str[i] == '2') {\n    return Res(2, i + 1);\n  }\n  assert(false);\n}\n\nvoid solve() {\n  int cnt;\n  for (P = 0; P < 3; P++) {\n    for (Q = 0; Q < 3; Q++) {\n      for (R = 0; R < 3; R++) {\n        Res res = formula(0);\n        //        assert(res.second == str.size());\n        if (res.first == 2) {\n          cnt++;\n        }\n      }\n    }\n  }\n  cout << cnt << endl;\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \".\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n//using P = pair<int, int>;\nusing namespace std;\n\n// 構文解析\nusing State = string::const_iterator;\nclass ParseError{};\n\nint P, Q, R;\n\nint number(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\n// 数字の列をパースして，その数を返す\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    if (*begin == 'P') {\n        ret = P;\n        ++begin;\n    }\n    else if (*begin == 'Q') {\n        ret = Q;\n        ++begin;\n    }\n    else if (*begin == 'R') {\n        ret = R;\n        ++begin;\n    }\n\n    return ret;\n}\n\n\n// 乗算除算の式をパースして，その評価結果を返す\nint term(State &begin) {\n    if (*begin == '-') {\n        begin++;\n        return abs(2-term(begin));\n    }\n    else {\n        return factor(begin);\n    }\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n\n// 四則演算の式をパースして，その評価結果を返す\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret = max(ret, term(begin));\n        }\n        else if (*begin == '*') {\n            begin++;\n            ret = min(ret, term(begin));\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    }\n    else {\n        cerr << \"Expected \" << expected << \" but got \" << *begin << endl;\n        cerr << \"Rest string is \";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n    while (true) {\n        string s;\n        getline(cin, s);\n\n        if (s == \".\") break;\n\n        int ans = 0;\n        rep(p, 3) rep(q, 3) rep(r, 3) {\n            P = p; Q = q; R = r;\n            State begin = s.begin();\n            int tmp = expression(begin);\n            if (tmp == 2) ans++;\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nint P,Q,R;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\n\n//\t\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\n\tclass ParseError{};\n\tint expression(Cursor&);\n\tint number(Cursor&);\n \n\tint expression(Cursor &c){\n\t\tif(*c=='-'){\n\t\t\tc++;// -\n\t\t\tint res=expression(c);\n\t\t\treturn 2-res;\n\t\t}if(*c=='('){\n\t\t\tc++;// (\n\t\t\tint res;\n\t\t\tint l=expression(c);\n\t\t\tif(*c=='+'){\n\t\t\t\tc++;// +\n\t\t\t\tint r=expression(c);\n\t\t\t\tres=max(l,r);\n\t\t\t}else if(*c=='*'){\n\t\t\t\tc++;// *\n\t\t\t\tint r=expression(c);\n\t\t\t\tres=min(l,r);\n\t\t\t}\n\t\t\tc++;// )\n\t\t\treturn res;\n\t\t}\n\t\tif(isdigit(*c)){\n\t\t\tint res=*c-'0';c++;\n\t\t\treturn res;\n\t\t}\n\t\tif(*c=='P'){c++;return P;}\n\t\tif(*c=='Q'){c++;return Q;}\n\t\tif(*c=='R'){c++;return R;}\n\t\treturn -1;\n\t}\n}\nusing namespace SyntaxAnalysis;\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tstring str;cin >> str;if(str==\".\")break;\n\n\t\t\tint res=0;\n\t\t\tREP(p,3)REP(q,3)REP(r,3){\n\t\t\t\tP=p;Q=q;R=r;\n\t\t\t\tCursor c=str.begin();\n\t\t\t\tint val=expression(c);\n\t\t\t\tif(val==2)res++;\n\t\t\t}\n\n\t\t\tcout <<res <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef string::const_iterator Cursol;\n\nint P, Q, R;\nint op1[3] = {2, 1, 0};\nint op2[3][3] = {{0, 0, 0}, {0, 1, 1}, {0, 1, 2}};\nint op3[3][3] = {{0, 1, 2}, {1, 1, 2}, {2, 2, 2}};\n\nint expr(Cursol &c) {\n\tint res = 0;\n\tif(*c == 'P') {\n\t\tres = P;\n\t} else if(*c == 'Q') {\n\t\tres = Q;\n\t} else if(*c == 'R') {\n\t\tres = R;\n\t} else if(isdigit(*c)) {\n\t\tres = *c - '0';\n\t} else if(*c == '-') {\n\t\treturn op1[expr(++c)];\n\t} else if(*c == '(') {\n\t\tres = expr(++c);\n\t\tif(*c == '*') {\n\t\t\tres = op2[res][expr(++c)];\n\t\t} else if(*c == '+') {\n\t\t\tres = op3[res][expr(++c)];\n\t\t}\n\t}\n\tc++;\n\treturn res;\n}\n\nint main() {\n\tstring s;\n\tCursol c;\n\twhile(cin >> s) {\n\t\tif(s == \".\") break;\n\t\tint ans = 0;\n\t\tfor(P = 0; P < 3; P++) {\n\t\t\tfor(Q = 0; Q < 3; Q++) {\n\t\t\t\tfor(R = 0; R < 3; R++) {\n\t\t\t\t\tc = s.begin();\n\t\t\t\t\tif(expr(c) == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint p, q, r, res = 0, pt;\nstring str;\n\nint solve_rec()\n{\n\tif( str[pt] == '0' )\n\t\treturn 0;\n\telse if( str[pt] == '1' )\n\t\treturn 1;\n\telse if( str[pt] == '2' )\n\t\treturn 2;\n\telse if( str[pt] == 'P' )\n\t\treturn p;\n\telse if( str[pt] == 'Q' )\n\t\treturn q;\n\telse if( str[pt] == 'R' )\n\t\treturn r;\n\telse if( str[pt] == '-')\n\t{\n\t\tpt++;\n\t\tint a = solve_rec();\n\t\treturn 2-a;\n\t}\n\telse if( str[pt] == '(')\n\t{\n\t\tpt++;\n\t\tint a = solve_rec();\n\t\tpt++;\n\t\tchar op = str[pt];\n\t\tpt++;\n\t\tint b = solve_rec();\n\t\tpt++;\n\n\t\tif( op == '*' )\n\t\t\treturn min(a, b);\n\t\telse if( op == '+' )\n\t\t\treturn max(a, b);\n\t}\n\telse\n\t{\n\t\tpt++;\n\t}\n}\n\n\nvoid solve()\n{\n\tfor( p = 0; p <= 2; p++ )\n\t\tfor( q = 0; q <= 2; q++ )\n\t\t\tfor( r = 0; r <= 2; r++ )\n\t\t\t{\n\t\t\t\tpt = 0;\n\t\t\t\t\n\t\t\t\tif( solve_rec() == 2 )\n\t\t\t\t\tres++;\n\t\t\t}\n\n\treturn;\n}\n\nint main()\n{\n\twhile(cin >> str, str[0] != '.')\n\t{\n\t\tres = 0;\n\t\tsolve();\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nint inv[3] = {2, 1, 0};\n\nint mul[3][3] = {\n\t{ 0, 0, 0 },\n\t{ 0, 1, 1 },\n\t{ 0, 1, 2 }\n};\n\nint pul[3][3] = {\n\t{ 0, 1, 2 },\n\t{ 1, 1, 2 },\n\t{ 2, 2, 2 }\n};\n\nstring s;\n\nint parse(int p, int q, int r) {\n\tstack<char> oper;\n\tstack<int> var;\n\t\n\tfor (int i=0; i<(int)s.size(); i++) {\n\t\tif (s[i]=='(') oper.push('(');\n\t\tif (s[i]==')') {\n\t\t\tchar op = oper.top(); oper.pop();\n\t\t\twhile (op!='(') {\n\t\t\t\twhile (op=='-') {\n\t\t\t\t\tint v = var.top(); var.pop();\n\t\t\t\t\tvar.push(inv[v]);\n\t\t\t\t\top = oper.top(); oper.pop();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (op!='(') {\n\t\t\t\t\tint v1 = var.top(); var.pop();\n\t\t\t\t\tint v2 = var.top(); var.pop();\n\t\t\t\t\tchar nop = oper.top();\n\t\t\t\t\twhile (nop=='-') {\n\t\t\t\t\t\tv2 = inv[v2];\n\t\t\t\t\t\toper.pop(); nop = oper.top();\n\t\t\t\t\t}\n\t\t\t\t\tif (op=='+') var.push(pul[v1][v2]);\n\t\t\t\t\tif (op=='*') var.push(mul[v1][v2]);\n\t\t\t\t\top = oper.top(); oper.pop();\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (s[i]=='-' || s[i]=='+' || s[i]=='*') oper.push(s[i]);\n\t\tif (s[i]=='P') var.push(p);\n\t\tif (s[i]=='Q') var.push(q);\n\t\tif (s[i]=='R') var.push(r);\n\t\tif ('0' <= s[i] && s[i] <= '2') var.push(s[i] - '0');\n\t}\n\t\n\treturn var.top();\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> s; if (s[0] == '.') break;\n\t\tint ans = 0;\n\t\tfor (int p=0; p<3; p++)\n\t\t\tfor (int q=0; q<3; q++)\n\t\t\t\tfor (int r=0; r<3; r++)\n\t\t\t\t\tans += (parse(p, q, r) == 2) ? 1 : 0;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>), (<*), (*>), (<$))\nimport Control.Monad\nimport Data.List\nimport Text.Parsec\nimport Text.Parsec.String\n\nmain :: IO ()\nmain = do\n  s <- getLine\n  unless (s == \".\") $ do\n    print $ solve s\n    main\n\nsolve :: String -> Int\nsolve s = length . filter f $ ls\n  where\n    f :: (Char, Char, Char) -> Bool\n    f x = '2' == either (const ' ') id (parse formula \"\" (tr s x))\n    ls = [(p,q,r)|p <- \"012\", q <- \"012\", r <- \"012\"]\n\nminus :: Char -> Char\nminus '0' = '2'\nminus '1' = '1'\nminus _ = '0'\n\nmul :: Char -> Char -> Char\nmul '2' '2' = '2'\nmul '0' _ = '0'\nmul _ '0' = '0'\nmul _ _ = '1'\n\nadd :: Char -> Char -> Char\nadd '0' '0' = '0'\nadd '2' _ = '2'\nadd _ '2' = '2'\nadd _ _ = '1'\n\naddmul :: Char -> Char -> Char -> Char\naddmul x '*' y = mul x y\naddmul x _ y = add x y\n\nformula :: Parser Char\nformula = num <|> ht <|> skwa\n\nnum :: Parser Char\nnum = char '0' <|> char '1' <|> char '2'\n\nht :: Parser Char\nht = char '-' *> (minus <$> formula)\n\nskwa :: Parser Char\nskwa = char '(' *> (addmul <$> formula <*> (char '*' <|> char '+') <*> formula) <* char ')'\n\ntr :: String -> (Char, Char, Char) -> String\ntr expr (x,y,z) = map g expr\n  where\n    g 'P' = x\n    g 'Q' = y\n    g 'R' = z\n    g w = w\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1155\n   How can I satisfy thee? Let me count the ways...\n   \n*/\n\n#include<stdio.h>\n#define MAX_STR 100\nchar not[3] = {'2', '1', '0'};\nchar and[3][3] = {{'0', '0', '0'}, {'0', '1', '1'}, {'0', '1', '2'}};\nchar or[3][3] = {{'0', '1', '2'}, {'1', '1', '2'}, {'2', '2', '2'}};\n\nchar instr[MAX_STR];\nint pp;\n\n  \n\nchar interpreter(int p, int q, int r)\n{\n  char c = instr[pp];\n  switch(c)\n    {\n    case '0':\n    case '1':\n    case '2':\n      return instr[pp++];\n    case 'P':\n      pp++;\n      return p + '0';\n    case 'Q':\n      pp++;\n      return q + '0';\n    case 'R':\n      pp++;\n      return r + '0';\n    case '-':\n      pp++;\n      return not[interpreter(p, q, r) - '0'];\n    case '(':\n      pp++;\n      char f0 = interpreter(p, q, r);\n      char op = instr[pp++];\n      char f1 = interpreter(p, q, r);\n      pp++;\n      if(op == '*')\n\treturn and[f0 - '0'][f1 - '0'];\n      else\n\treturn or[f0 - '0'][f1 - '0'];\n    }\n}\n\nint main(void)\n{\n  int p, q, r, ans = 0;\n  while(scanf(\"%s\", instr), instr[0] != '.')\n    {\n      for(p = 0; p < 3; p++)\n\tfor(q = 0; q < 3; q++)\n\t  for(r = 0; r < 3; r++)\n\t    {\n\t      if(interpreter(p, q, r) == '2')\n\t\tans++;\n\t      pp = 0;\n\t    }\n      printf(\"%d\\n\", ans);\n      ans = 0;\n      pp = 0;\n      for(p = 0; p < MAX_STR; p++)\n\tinstr[p] = '\\0';\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1155: How can I satisfy thee? Let me count the...\n// 2017.9.13 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\nchar buf[100], *bp;\nint p, q, r;\n\nint term();\n\nint factor()\n{\n\tint x;\n\n\tif      (*bp == '(') bp++, x = term(), bp++;\n\telse if (*bp == '-') bp++, x = 2-factor();\n\telse if (isdigit(*bp)) x = *bp++ - '0';\n\telse if (*bp == 'P') bp++, x = p;\n\telse if (*bp == 'Q') bp++, x = q;\n\telse bp++, x = r;\n\treturn x;\n}\n\nint term()\n{\n\tint x, y, op;\n\n\tx = factor();\n\tif      (*bp == '*') bp++, op = 1;\n\telse if (*bp == '+') bp++, op = 0;\n\ty = factor();\n\tif (op) {\n\t\tif (x == 2 && y == 2) x = 2;\n\t\telse if (x == 0 || y == 0) x = 0;\n\t\telse x = 1;\n\t} else {\n\t\tif (x == 0 && y == 0) x = 0;\n\t\telse if (x == 2 || y == 2) x = 2;\n\t\telse x = 1;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tint ans;\n\n\twhile (scanf(\"%s\", buf) && *buf != '.') {\n\t\tans = 0;\n\t\tfor (p = 0; p <= 2; p++) for (q = 0; q <= 2; q++) for (r = 0; r <= 2; r++) {\n\t\t\tbp = buf; if (factor() == 2) ans++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 80\n\nint not(int x)\n{\n    return (x==0)? 2:((x==1)? 1: 0);\n}\n\nint and(int x,int y)\n{\n    return (x==0 || y==0)? 0: ((x==1 || y==1)? 1: 2);\n}\n\nint or(int x,int y)\n{\n    return (x==2 || y==2)? 2: ((x==1 || y==1)? 1: 0);\n}\n\nint main(void)\n{\n    int pqr[27][3]; //prt[pattern][p/q/r]\n    int i,j,k,l,c=0,num=0;\n\n    for(i=0;i<3;i++)        //initialize\n    {\n        for(j=0;j<3;j++)\n        {\n            for(k=0;k<3;k++)\n            {\n                pqr[num][0]=i;\n                pqr[num][1]=j;\n                pqr[num][2]=k;\n                num++;\n            }\n        }\n    }\n\n    while(1)\n    {\n        int operand[MAX]={},operator[MAX]={},command[MAX]={};\n        int rand=0,rator=0,mand=0,jud=0,count=0;\n\n        while(1)\n        {\n            scanf(\"%c\",&c);\n            if(c=='.')\n            {\n                jud=1;\n                break;\n            }\n            if(c=='\\n')\n            {\n                break;\n            }\n\n            switch(c)       //???????????????????¨????\n            {\n                case '+':\n                case '*':\n                    operator[rator]=c;\n                    rator++;\n                    break;\n                case '-':\n                    if(operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                    }\n                    else\n                    {\n                        operator[rator]='-';\n                        rator++;\n                    }\n                    break;\n                case ')':\n                    rator--;\n                    command[mand]=operator[rator];\n                    operator[rator]=0;\n                    mand++;\n                    break;\n                case '(':\n                    break;\n                default:\n                    command[mand]=c;\n                    mand++;\n                    if(rator>0 && operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                        command[mand]='-';\n                        mand++;\n                    }\n                    break;\n            }\n        }\n        if(jud==1)\n        {\n            break;\n        }\n\n        for(l=0;l<27;l++)       //calculate\n        {\n            char calculate[mand];\n            for(j=0;j<mand;j++)\n            {\n                calculate[j]=0;\n                switch(command[j])\n                {\n                    case 'P':\n                        calculate[j]=pqr[l][0];\n                        break;\n                    case 'Q':\n                        calculate[j]=pqr[l][1];\n                        break;\n                    case 'R':\n                        calculate[j]=pqr[l][2];\n                        break;\n                    default:\n                        if(isdigit(command[j]))\n                        {\n                               command[j]-='0';\n                        }\n                        calculate[j]=command[j];\n                        break;\n                }\n            }\n\n            char temporary[mand];\n\n            for(i=0;i<mand;i++)\n            {\n                temporary[i]=calculate[i];\n            }\n\n/*           for(i=0;i<mand;i++)\n            {\n                if(temporary[i]<3) printf(\"%d\",temporary[i]);\n                else printf(\"%c\",temporary[i]);\n            }\n            printf(\":\");*/\n\n            j=0;\n            while(1)\n            {\n                //printf(\"j=%d...\",j );\n                switch(temporary[j])\n                {\n                    case '+':\n                        temporary[j-2]=or(temporary[j-2],temporary[j-1]);\n                        temporary[j]=-1;\n                        temporary[j-1]=-1;\n                        for(k=j-1;k<mand-2;k++)\n                        {\n                            temporary[k]=temporary[k+2];\n                        }\n                        temporary[mand-2]=-1;\n                        temporary[mand-1]=-1;\n                        j-=2;\n                        break;\n                    case '*':\n                        temporary[j-2]=and(temporary[j-2],temporary[j-1]);\n//                        printf(\"(%d,%d)=%d...\",temporary[j-2],temporary[j-1],and(temporary[j-2],temporary[j-1]));\n                        temporary[j]=-1;\n                        temporary[j-1]=-1;\n                        for(k=j-1;k<mand-1;k++)\n                        {\n                            temporary[k]=temporary[k+2];\n                        }\n                        temporary[mand-2]=-1;\n                        temporary[mand-1]=-1;\n                        j-=2;\n                        break;\n                    case '-':\n                        temporary[j-1]=not(temporary[j-1]);\n                        //printf(\"not(%d)=%d\\n\",temporary[j-1],not(temporary[j-1]));\n                        for(k=j;k<mand-1;k++)\n                        {\n                            temporary[k]=temporary[k+1];\n                        }\n                        temporary[mand-1]=-1;\n                        j--;\n                        break;\n                    default:\n                        break;\n                }\n\n                /*for(k=0;k<mand;k++)\n                {\n                    if(temporary[k]<3) printf(\"%d\",temporary[k]);\n                    else printf(\"%c\",temporary[k]);\n                }\n                printf(\".\\n\");*/\n//                printf(\"%d\\n\",temporary[0]);\n                if(temporary[1]==-1 || mand==1)\n                {\n    //                printf(\"\\n\\n\");\n                    if(temporary[0]==2)\n                    {\n                        count++;\n                    }\n                    break;\n                }\n                j++;\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar S[100],St[100],T[100],c;\nint P,Q,R,p,i,j,sp,St2[100],Res;\nint not[3]={2,1,0};\nint and[3][3]={{},{0,1,1},{0,1,2}};\nint or[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nvoid pop(){T[p++]=St[--sp];}\nvoid push(){St[sp++]=S[i];}\nvoid NotPOP(){for(;St[sp-1]=='-';T[p++]=St[--sp]);}\nint pop2(){return St2[--sp];}\nvoid push2(int n){St2[sp++]=n;}\n\n\nint cal()\n{\n\tmemset(St2,-1,sizeof(St2));\n\tfor(i=sp=0;c=T[i];i++)\n\t{\n\t\tswitch(T[i])\n\t\t{\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':push2(T[i]-'0');break;\n\t\tcase 'P':push2(P);break;\n\t\tcase 'Q':push2(Q);break;\n\t\tcase 'R':push2(R);break;\n\t\tcase '*':push2(and[pop2()][pop2()]);break;\n\t\tcase '+':push2(or[pop2()][pop2()]);break;\n\t\tcase '-':push2(not[pop2()]);break;\n\t\t}\n\t}\n\treturn St2[0];\n}\n\nint main()\n{\n\tfor(;scanf(\"%s\",S),S[0]!='.';)\n\t{\n\t\tmemset(St,0,sizeof(St));\n\t\tmemset(T,0,sizeof(T));\n\t\tfor(i=p=sp=0;S[i];i++)\n\t\t{\n\t\t\tswitch(S[i])\n\t\t\t{\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase 'P':\n\t\t\tcase 'Q':\n\t\t\tcase 'R':T[p++]=S[i];NotPOP();break;\n\t\t\tcase ')':pop();NotPOP();break;\n\t\t\tcase '*':\n\t\t\tcase '+':\n\t\t\tcase '-':push();break;\n\t\t\t}\n\t\t}\n\t\tfor(P=Res=0;P<3;P++)\n\t\t\tfor(Q=0;Q<3;Q++)\n\t\t\t\tfor(R=0;R<3;R++)\n\t\t\t\t\tif(cal()==2)\n\t\t\t\t\t\tRes++;\n\t\tprintf(\"%d\\n\",Res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nstatic const char * e;\nstatic int p, q, r;\n\nstatic int expr ( void );\n\nstatic int\nterm (\n  void\n  )\n{\n  int res;\n\n  switch ( *( e++ ) )\n  {\n    case '-':\n      res = expr ( );\n      switch ( res )\n      {\n        case 0: res = 2; break ;\n        case 2: res = 0; break ;\n      }\n      break ;\n    case 'P': res = p; break ;\n    case 'Q': res = q; break ;\n    case 'R': res = r; break ;\n    case '0': res = 0; break ;\n    case '1': res = 1; break ;\n    case '2': res = 2; break ;\n  }\n\n  return ( res );\n}\n\nstatic int\nnanikaka (\n  void\n  )\n{\n  int lt, rt;\n  char opr;\n  int res;\n\n  lt = expr ( );\n  opr = *( e++ );\n  rt = expr ( );\n\n  switch ( opr )\n  {\n    case '*':\n      res = 1;\n      if ( lt == 0 || rt == 0 ) res = 0;\n      if ( lt == 2 && rt == 2 ) res = 2;\n      break ;\n    case '+':\n      res = 0;\n      if ( lt == 1 || rt == 1 ) res = 1;\n      if ( lt == 2 || rt == 2 ) res = 2;\n      break ;\n  }\n\n  return ( res );\n}\n\nstatic int\nexpr (\n  void\n  )\n{\n  int lt, rt, res;\n\n  switch ( *e )\n  {\n    case '(':\n      ++e;\n      res = nanikaka ( );\n      ++e;\n      break ;\n    default:\n      res = term ( );\n      break ;\n  }\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  char s[ 128 ];\n\n  for ( ; ; )\n  {\n    int res = 0;\n\n    scanf ( \" %s\", s );\n    if ( !strcmp ( s, \".\" ) ) break ;\n\n    for ( p = 0; p <= 2; ++p )\n    for ( q = 0; q <= 2; ++q )\n    for ( r = 0; r <= 2; ++r )\n    {\n      e = s;\n      res += !!( expr ( ) == 2 );\n    }\n\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "/*\n\t????????????\n\t????±??????????\n\t????????\\???\n*/\n\n#include<stdio.h>\n\n#define SIZE 81\t//??\\???????????????????????°+1\n#define FALSE '0'\n#define UNKNOWN '1'\n#define TRUE '2'\n#define X -1\t//?????£???\n\ntypedef struct LOGIC Logic;\nstruct LOGIC{\n\tchar formula[SIZE];\t//??\\????????????????????????\n\tchar v[3];\t//?????°???\n};\n\nint Main();\nchar Calc(Logic *logic);\t//???????????????????????????????????£??\\???????????????????????????\nint Not(int a);\t//?????????\nint And(int a, int b);\t//?????????\nint Or(int a, int b);\t//?????????\n\nint main(int argc, char *argv[]){\n\twhile( Main() == 0 );\n\treturn 0;\n}\n\nint Main(){\n\tLogic logic;\n\tint num = 0, count = 0, i = 0;\t//????????§??????????????????????????????????????????????????°???\n\tfor( i = 0; i < SIZE; i++ ){ logic.formula[i] = '\\0'; }\n\tif( scanf(\"%s\", logic.formula) != 1 ){ return -1; }\n\tif( logic.formula[0] == '.' ){ return 1; }\nprintf(\"%s\\n\", logic.formula);\n\tfor( logic.v[0] = FALSE; logic.v[0] <= TRUE; logic.v[0]++ ){\n\t\tfor( logic.v[1] = FALSE; logic.v[1] <= TRUE; logic.v[1]++ ){\n\t\t\tfor( logic.v[2] = FALSE; logic.v[2] <= TRUE; logic.v[2]++ ){\n\t\t\t\tnum = 0;\n\t\t\t\tcount += (Calc(&logic) == TRUE);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", count);\n\treturn 0;\n}\n\nchar Calc(Logic *logic){\n\tint a[2], sc = 0, i = 0;\t//?????????????????°?????????????????????????????????\n\tchar stack[SIZE], s = '\\0', ope = '\\0';\t//?????????????????????????????????????????????????????????????????????\n\tfor( i = 0; i < SIZE; i++ ){ stack[i] = '\\0'; }\n\tfor( i = 0; logic->formula[i] != '\\0'; i++ ){\n\t\tif( 'P' <= logic->formula[i] && logic->formula[i] <= 'R' ){\n\t\t\tstack[sc++] = logic->v[logic->formula[i] - 'P'];\n\t\t}else{\n\t\t\tstack[sc++] = logic->formula[i];\n\t\t}\n\t\tif( logic->formula[i] == ')' ){\n\t\t\t//??????????????????????????§???a[1]????¨?????????????\n\t\t\tfor( s = stack[--sc]; s != '+' && s != '*'; s = stack[--sc] ){\n\t\t\t\tstack[sc+1] = '\\0';\n\t\t\t\tif( 'P' <= s && s <= 'R' ){\n\t\t\t\t\ta[1] = logic->v[s-'P'] + '0';\n\t\t\t\t}else if( '0' <= s && s <= '2' ){\n\t\t\t\t\ta[1] = s;\n\t\t\t\t}else if( s == '-' ){\n\t\t\t\t\ta[1] = Not(a[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[sc+1] = '\\0';\n\t\t\tope = stack[sc];\n\t\t\t//'('?????????????????§a[0]????¨?????????????\n\t\t\tfor( s = stack[--sc]; stack[sc] != '('; s = stack[--sc] ){\n\t\t\t\tstack[sc+1] = '\\0';\n\t\t\t\tif( 'P' <= s && s <= 'R' ){\n\t\t\t\t\ta[0] = logic->v[s-'P'] + '0';\n\t\t\t\t}else if( '0' <= s && s <= '2' ){\n\t\t\t\t\ta[0] = s;\n\t\t\t\t}else if( s == '-' ){\n\t\t\t\t\ta[0] = Not(a[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[sc+1] = '\\0';\n\t\t\tif( ope == '*' ){\n\t\t\t\tstack[sc++] = And(a[0], a[1]);\n\t\t\t}else if( ope == '+' ){\n\t\t\t\tstack[sc++] = Or(a[0], a[1]);\n\t\t\t}\n\t\t}\n\t}\n\t//??\\??????????????????????????§??°??????????????§?????????????¨?????????????\n\ta[0] = stack[--sc];\t//?????????????????????\n\t//?????¨???????????????NOT?????¨???'-'?????????\n\tfor( sc-- ; sc >= 0; sc-- ){\n\t\tif( stack[sc] == '-' ){ a[0] = Not(a[0]); }\n\t}\n\tstack[++sc] = a[0];\n\treturn stack[0];\n}\n\nint Not(int a){\n\tswitch( a ){\n\t\tcase FALSE:\n\t\t\treturn TRUE;\n\t\tcase UNKNOWN:\n\t\t\treturn UNKNOWN;\n\t\tcase TRUE:\n\t\t\treturn FALSE;\n\t}\n\treturn X;\n}\n\nint And(int a, int b){\n\tif( a == X || b == X ){ return X; }\t//?????§?????????\n\tif( a == FALSE || b == FALSE ){\n\t\treturn FALSE;\n\t}else if( a == UNKNOWN || b == UNKNOWN ){\n\t\treturn UNKNOWN;\n\t}else if( a == TRUE && b == TRUE ){\n\t\treturn TRUE;\n\t}\n\treturn X;\n}\n\nint Or(int a, int b){\n\tif( a == X || b == X ){ return X; }\t//?????§?????????\n\tif( a == TRUE || b == TRUE ){\n\t\treturn TRUE;\n\t}else if( a == UNKNOWN || b == UNKNOWN ){\n\t\treturn UNKNOWN;\n\t}else if( a == FALSE && b == FALSE ){\n\t\treturn FALSE;\n\t}\n\treturn X;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#define or(a,b) a > b ? a : b\n#define and(a,b) a > b ? b : a\n#define not(n) 1 - (n - 1)\n\nint p[3];\nchar str[81];\n\nint formula(int i){\n\tif(isupper(str[i]))\n\t\treturn p[str[i] - 'P'];\n\telse if(isdigit(str[i]))\n\t\treturn str[i] - '0';\n\telse if(str[i] == '-')\n\t\treturn not(formula(i + 1));\n\telse if(str[i] == '('){\n\t\tint j = i;\n\t\tint cen = 0;\n\t\twhile(1){\n\t\t\tif(str[++j] == '(')\n\t\t\t\tcen++;\n\t\t\telse if(str[j] == ')')\n\t\t\t\tcen--;\n\t\t\tif(cen == 0 && (str[j] == '*' || str[j] == '+')){\n\t\t\t\tif(str[j] == '*')\n\t\t\t\t\treturn and(formula(i + 1),formula(j + 1));\n\t\t\t\telse\n\t\t\t\t\treturn or(formula(i + 1),formula(j + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint count;\n\tgets(str);\n\twhile(str[0] != '.'){\n\t\tstr[strlen(str)] = '\\0';\n\t\tcount = 0;\n\t\tfor(p[0] = 0;p[0] <= 2;p[0]++){\n\t\t\tfor(p[1] = 0;p[1] <= 2;p[1]++){\n\t\t\t\tfor(p[2] = 0;p[2] <= 2;p[2]++){\n\t\t\t\t\tif(formula(0) == 2)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t\tgets(str);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define M(x,y)(x>y?x:y)\n#define m(x,y)(x<y?x:y)\nI;int parse(char *p){switch(*p){\n\tcase'0':return 0;\n\tcase'1':return 1;\n\tcase'2':return 2;\n\tcase'P':return I%3;\n\tcase'Q':return I/3%3;\n\tcase'R':return I/9%3;\n\tcase'-':return 2-parse(p+1);\n\tcase'(':{\n\t\tint x=0,y;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\treturn(*(++p)=='*')?m(parse(q),parse(p+1)):M(parse(q),parse(p+1));\n\t}\n}}\nchar p[81];main(s){for(;scanf(\"%s\",p),*p-'.';printf(\"%d\\n\",s))for(s=I=0;I<27;I++)s+=parse(p)==2;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nstatic const char * e;\nstatic int p, q, r;\n\nstatic int expr ( void );\n\nstatic int\nterm (\n  void\n  )\n{\n  int res;\n\n  switch ( *( e++ ) )\n  {\n    case '-':\n      res = expr ( );\n      switch ( res )\n      {\n        case 0: res = 2; break ;\n        case 2: res = 0; break ;\n      }\n      break ;\n    case 'P': res = p; break ;\n    case 'Q': res = q; break ;\n    case 'R': res = r; break ;\n    case '0': res = 0; break ;\n    case '1': res = 1; break ;\n    case '2': res = 2; break ;\n  }\n\n  return ( res );\n}\n\nstatic int\nnanikaka (\n  void\n  )\n{\n  int lt, rt;\n  char opr;\n  int res;\n\n  lt = expr ( );\n  opr = *( e++ );\n  rt = expr ( );\n\n  switch ( opr )\n  {\n    case '*':\n      res = 1;\n      if ( lt == 0 || rt == 0 ) res = 1;\n      if ( lt == 2 && rt == 2 ) res = 2;\n      break ;\n    case '+':\n      res = 0;\n      if ( lt == 1 || rt == 1 ) res = 1;\n      if ( lt == 2 || rt == 2 ) res = 2;\n      break ;\n  }\n\n  return ( res );\n}\n\nstatic int\nexpr (\n  void\n  )\n{\n  int lt, rt, res;\n\n  switch ( *e )\n  {\n    case '(':\n      ++e;\n      res = nanikaka ( );\n      ++e;\n      break ;\n    default:\n      res = term ( );\n      break ;\n  }\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  char s[ 128 ];\n\n  for ( ; ; )\n  {\n    int res = 0;\n\n    scanf ( \" %s\", s );\n    if ( !strcmp ( s, \".\" ) ) break ;\n\n    for ( p = 0; p <= 2; ++p )\n    for ( q = 0; q <= 2; ++q )\n    for ( r = 0; r <= 2; ++r )\n    {\n      e = s;\n      res += !!( expr ( ) == 2 );\n    }\n\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint formula();\nint min(int,int);\nint max(int,int);\n\nint p,q,r;\nint position;\n    char str[10000];\n\n\nmain(){\n    int count=0;\n    \n    while(1){\n        \n        scanf(\"%s\",str);\n        if(str[0] == '.') break;\n        count = 0;\n        \n    for(p=0; p<3; p++){\n        for(q=0; q<3; q++){\n            for(r=0; r<3; r++){\n                position = 0;\n               if(formula() == 2)\n               count++;\n            }\n        }\n    }\n    printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}\n\nint formula(){\n    int result;\n    \n    if(str[position] == '-'){\n                position++;\n\n        result = 2-formula();\n    }   \n    \n    else if(str[position] == '('){\n    position++;\n    result = formula();\n    if(str[position] == '*'){\n        position++;\n        result = min(result,formula());\n    position++;\n    }\n    else if(str[position] == '+'){\n        position++;\n        result = max(result,formula());\n    position++;\n\t}\n}\n\nelse{\n    if(str[position] >= '0' && str[position] <= '2')\n    result = str[position] - '0';\n    \n    if(str[position] == 'P')\n    result = p;\n    else if(str[position] == 'Q')\n    result = q;\n    else if(str[position] == 'R')\n    result = r;\n    \n    position++;\n    }\n    return result;\n}\n\nint min(int x,int y){\n    if(x > y)\n    return y;\n    else return x;\n}\n\nint max(int x,int y){\n    if(x > y)\n    return x;\n    else return y;\n}"
  },
  {
    "language": "C",
    "code": "#define max(x,y) ((x)>(y)?(x):(y))\n#define min(x,y) ((x)<(y)?(x):(y))\n#define mul min\n#define add max\n#define n(x) (2-(x))\n\nint I;\n\nint parse(char *p){\n  switch(*p){\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case 'P': return I%3;\n    case 'Q': return I/3%3;\n    case 'R': return I/9%3;\n    case '-': return n(parse(p+1));\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return mul(parse(q),parse(p+1));\n                  case '+': return add(parse(q),parse(p+1));\n                }\n              }\n  }\n}\n\nint main(){\n  char p[81];\n  int s;\n  while(1){\n    s=0;\n    scanf(\"%s\",p);\n    if(*p=='.')return 0;\n    for(I=0;I<27;I++)\n        if(parse(p)==2)s++;\n    printf(\"%d\\n\",s);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint F(int p,int q,int r,char ft[100],int fc){//+=3 -=4 *=5\n\tint fit[100],ic,x,t;\n\tic=1;\n\tfor(t=0;t<100;t++){\n\t\tfit[t]=0;\n\t}\n\twhile(ic<fc){\n\t\tif(ft[ic]=='P'){\n\t\t\tfit[ic]=p;\n\t\t}\n\t\tif(ft[ic]=='Q'){\n\t\t\tfit[ic]=q;\n\t\t}\n\t\tif(ft[ic]=='R'){\n\t\t\tfit[ic]=r;\n\t\t}\n\t\tif(ft[ic]=='0'){\n\t\t\tfit[ic]=0;\n\t\t}\n\t\tif(ft[ic]=='1'){\n\t\t\tfit[ic]=1;\n\t\t}\n\t\tif(ft[ic]=='2'){\n\t\t\tfit[ic]=2;\n\t\t}\n\t\tif(ft[ic]=='+'){\n\t\t\tfit[ic]=3;\n\t\t}\n\t\tif(ft[ic]=='-'){\n\t\t\tfit[ic]=4;\n\t\t}\n\t\tif(ft[ic]=='*'){\n\t\t\tfit[ic]=5;\n\t\t}\n\t\tic++;\n\t}\n\tic--;\n\tx=1;\n\twhile(x<ic){\n\t\tif(fit[x]==3){\n\t\t\tif(fit[x-1]==0&&fit[x-2]==0){\n\t\t\t\tfit[x-2]=0;\n\t\t\t}\n\t\t\telse if(fit[x-1]==2||fit[x-2]==2){\n\t\t\t\tfit[x-2]=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfit[x-2]=1;\n\t\t\t}\n\t\t\tic-=2;\n\t\t\tfor(t=x-1;t<=ic;t++){\n\t\t\t\tfit[t]=fit[t+2];\n\t\t\t}\n\t\t\tx-=2;\n\t\t}\n\t\tif(fit[x]==4){\n\t\t\tfit[x-1]=2-fit[x-1];\n\t\t\tic--;\n\t\t\tfor(t=x;t<=ic;t++){\n\t\t\t\tfit[t]=fit[t+1];\n\t\t\t}\n\t\t\tx--;\n\t\t}\n\t\tif(fit[x]==5){\n\t\t\tif(fit[x-1]==0||fit[x-2]==0){\n\t\t\t\tfit[x-2]=0;\n\t\t\t}\n\t\t\telse if(fit[x-1]==2&&fit[x-2]==2){\n\t\t\t\tfit[x-2]=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfit[x-2]=1;\n\t\t\t}\n\t\t\tic-=2;\n\t\t\tfor(t=x-1;t<=ic;t++){\n\t\t\t\tfit[t]=fit[t+2];\n\t\t\t}\n\t\t\tx-=2;\n\t\t}\n\t\tx++;\n\t}\n\treturn fit[1];\n}\nint main(void){\n\tint c,nc,oc,fc;\n\tchar txt[100],ng[100],op[100],ft[100];\n\twhile(1){\n\t\tscanf(\"%s\",&txt);\n\t\tif(txt[0]=='.'){\n\t\t\tbreak;\n\t\t}\n\t\tnc=oc=fc=0;\n\t\tfor(c=0;c<strlen(txt);c++){\n\t\t\tif(txt[c]==0||txt[c]==1||txt[c]==2||txt[c]=='P'||txt[c]=='Q'||txt[c]=='R'){\n\t\t\t\tfc++;\n\t\t\t\tft[fc]=txt[c];\n\t\t\t\tif(nc!=0){\n\t\t\t\t\twhile(nc!=0){\n\t\t\t\t\t\tfc++;\n\t\t\t\t\t\tft[fc]=ng[nc];\n\t\t\t\t\t\tnc--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(txt[c]=='+'){\n\t\t\t\tif(oc==0||op[oc]=='('){\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(oc!=0){\n\t\t\t\t\t\tfc++;\n\t\t\t\t\t\tft[fc]=op[oc];\n\t\t\t\t\t\toc--;\n\t\t\t\t\t}\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(txt[c]=='*'){\n\t\t\t\tif(oc==0||op[oc]=='+'||op[oc]=='('){\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(oc!=0){\n\t\t\t\t\t\tfc++;\n\t\t\t\t\t\tft[fc]=op[oc];\n\t\t\t\t\t\toc--;\n\t\t\t\t\t}\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(txt[c]=='('){\n\t\t\t\toc++;\n\t\t\t\top[oc]=txt[c];\n\t\t\t}\n\t\t\tif(txt[c]==')'){\n\t\t\t\twhile(op[oc]!='('){\n\t\t\t\t\tfc++;\n\t\t\t\t\tft[fc]=op[oc];\n\t\t\t\t\toc--;\n\t\t\t\t}\n\t\t\t\top[oc]=0;\n\t\t\t\toc--;\n\t\t\t}\n\t\t\tif(txt[c]=='-'){\n\t\t\t\tnc++;\n\t\t\t\tng[nc]=txt[c];\n\t\t\t}\n\t\t}\n\t\tif(oc!=0){\n\t\t\twhile(oc!=0){\n\t\t\t\tfc++;\n\t\t\t\tft[fc]=op[oc];\n\t\t\t\toc--;\n\t\t\t}\n\t\t}\n\t\tfor(c=1;c<=fc;c++){\n\t\t\tprintf(\"%c\",ft[c]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(c=0;c<100;c++){\n\t\t\tng[c]=op[c]=0;\n\t\t}\n\t\tint p,q,r,ans;\n\t\tans=0;\n\t\tfor(p=0;p<3;p++){\n\t\t\tfor(q=0;q<3;q++){\n\t\t\t\tfor(r=0;r<3;r++){\n\t\t\t\t\tif(F(p,q,r,ft,fc)==2){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int minus_table[3]={2,1,0};\n\nconst int mul_table[3][3]={\n\t{0,0,0},\n\t{0,1,1},\n\t{0,1,2}\n};\n\nconst int plus_table[3][3]={\n\t{0,1,2},\n\t{1,1,2},\n\t{2,2,2}\n};\n\nint get_num(char now,int tansaku) {\n\tif(now=='P')return tansaku%3;\n\tif(now=='Q')return (tansaku/3)%3;\n\tif(now=='R')return (tansaku/9)%3;\n\treturn now-'0';\n}\n\nint main_stack_num;\nint main_stack[100];\n\nint enzansi_stack_num;\nchar enzansi_stack[100];\nint calc_stack_num;\nchar calc_stack[100];\n\nint main(void) {\n\tint i;\n\tchar now_siki[100];\n\tint tansaku;\n\tint count;\n\twhile(1) {\n\t\tscanf(\"%s\",now_siki);\n\t\tif(now_siki[0]=='.' && now_siki[1]==0)break;\n\t\tcount=0;\n\t\tfor(tansaku=0;tansaku<27;tansaku++) {\n\t\t\tmain_stack_num=enzansi_stack_num=calc_stack_num=0;\n\t\t\tfor(i=0;now_siki[i];i++) {\n\t\t\t\tif(now_siki[i]=='-' || now_siki[i]=='+' ||\n\t\t\t\t\t\tnow_siki[i]=='*' || now_siki[i]=='(' ||\n\t\t\t\t\t\tnow_siki[i]==')') {\n\t\t\t\t\tif(enzansi_stack_num>0) {\n\t\t\t\t\t\tif(now_siki[i]=='(') {\n\t\t\t\t\t\t\tenzansi_stack[enzansi_stack_num++]=now_siki[i];\n\t\t\t\t\t\t} else if(now_siki[i]==')') {\n\t\t\t\t\t\t\twhile(enzansi_stack_num>0 &&\n\t\t\t\t\t\t\t\t\tenzansi_stack[enzansi_stack_num-1]!='(') {\n\t\t\t\t\t\t\t\tcalc_stack[calc_stack_num++]=\n\t\t\t\t\t\t\t\t\tenzansi_stack[--enzansi_stack_num];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(enzansi_stack_num>0)enzansi_stack_num--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile(enzansi_stack_num>0 &&\n\t\t\t\t\t\t\t\t\tenzansi_stack[enzansi_stack_num-1]=='-' &&\n\t\t\t\t\t\t\t\t\tnow_siki[i]!='-') {\n\t\t\t\t\t\t\t\tcalc_stack[calc_stack_num++]=\n\t\t\t\t\t\t\t\t\tenzansi_stack[--enzansi_stack_num];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tenzansi_stack[enzansi_stack_num++]=now_siki[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tenzansi_stack[enzansi_stack_num++]=now_siki[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[calc_stack_num++]=now_siki[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(enzansi_stack_num>0) {\n\t\t\t\tcalc_stack[calc_stack_num++]=\n\t\t\t\t\tenzansi_stack[--enzansi_stack_num];\n\t\t\t}\n\t\t\tfor(i=0;i<calc_stack_num;i++) {\n\t\t\t\tif(calc_stack[i]=='-') {\n\t\t\t\t\tif(main_stack_num<1)return 1;\n\t\t\t\t\tmain_stack[main_stack_num-1]=minus_table\n\t\t\t\t\t\t[main_stack[main_stack_num-1]];\n\t\t\t\t} else if(calc_stack[i]=='*') {\n\t\t\t\t\tif(main_stack_num<2)return 1;\n\t\t\t\t\tmain_stack[main_stack_num-2]=mul_table\n\t\t\t\t\t\t[main_stack[main_stack_num-2]][main_stack[main_stack_num-1]];\n\t\t\t\t\tmain_stack_num--;\n\t\t\t\t} else if(calc_stack[i]=='+') {\n\t\t\t\t\tif(main_stack_num<2)return 1;\n\t\t\t\t\tmain_stack[main_stack_num-2]=plus_table\n\t\t\t\t\t\t[main_stack[main_stack_num-2]][main_stack[main_stack_num-1]];\n\t\t\t\t\tmain_stack_num--;\n\t\t\t\t} else {\n\t\t\t\t\tmain_stack[main_stack_num++]=get_num(calc_stack[i],tansaku);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(main_stack[0]==2)count++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 80\n\nint not(int x)\n{\n    return (x==0)? 2:((x==1)? 1: 0);\n}\n\nint and(int x,int y)\n{\n    return (x==0 || y==0)? 0: ((x==1 || y==1)? 1: 2);\n}\n\nint or(int x,int y)\n{\n    return (x==2 || y==2)? 2: ((x==1 || y==1)? 1: 0);\n}\n\nint main(void)\n{\n    int pqr[27][3]; //prt[pattern][p/q/r]\n    int i,j,k,l,c=0,num=0;\n\n    for(i=0;i<3;i++)        //initialize\n    {\n        for(j=0;j<3;j++)\n        {\n            for(k=0;k<3;k++)\n            {\n                pqr[num][0]=i;\n                pqr[num][1]=j;\n                pqr[num][2]=k;\n                num++;\n            }\n        }\n    }\n\n    while(1)\n    {\n        int operand[MAX]={},operator[MAX]={},command[MAX]={},kakko[MAX]={};\n        int rand=0,rator=0,mand=0,jud=0,count=0,kko=0;\n\n        while(1)\n        {\n            scanf(\"%c\",&c);\n            if(c=='.')\n            {\n                jud=1;\n                break;\n            }\n            if(c=='\\n')\n            {\n                break;\n            }\n\n            switch(c)       //???????????????????¨????\n            {\n                case '+':\n                case '*':\n                    operator[rator]=c;\n                    rator++;\n                    break;\n                case '-':\n                    if(operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                    }\n                    else\n                    {\n                        operator[rator]='-';\n                        rator++;\n                    }\n                    break;\n                case ')':\n                    rator--;\n                    command[mand]=operator[rator];\n                    operator[rator]=0;\n                    mand++;\n                    if(kakko[kko-1]==1)\n                    {\n                        kakko[kko-1]=0;\n                        command[mand]='-';\n                        mand++;\n                    }\n                    kko--;\n                    break;\n                case '(':\n                    if(operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                        kakko[kko]=1;\n                    }\n                    kko++;\n                    break;\n                default:\n                    command[mand]=c;\n                    mand++;\n                    if(rator>0 && operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                        command[mand]='-';\n                        mand++;\n                    }\n                    break;\n            }\n        }\n\n        /*for(i=0;i<mand;i++)\n        {\n            printf(\"%c\",command[i]);\n        }\n        printf(\"\\n\");*/\n\n        if(jud==1)\n        {\n            break;\n        }\n\n        for(l=0;l<27;l++)       //calculate\n        {\n            char calculate[mand];\n            for(j=0;j<mand;j++)\n            {\n                calculate[j]=0;\n                switch(command[j])\n                {\n                    case 'P':\n                        calculate[j]=pqr[l][0];\n                        break;\n                    case 'Q':\n                        calculate[j]=pqr[l][1];\n                        break;\n                    case 'R':\n                        calculate[j]=pqr[l][2];\n                        break;\n                    default:\n                        if(isdigit(command[j]))\n                        {\n                               command[j]-='0';\n                        }\n                        calculate[j]=command[j];\n                        break;\n                }\n            }\n\n            char temporary[mand];\n\n            for(i=0;i<mand;i++)\n            {\n                temporary[i]=calculate[i];\n            }\n\n/*           for(i=0;i<mand;i++)\n            {\n                if(temporary[i]<3) printf(\"%d\",temporary[i]);\n                else printf(\"%c\",temporary[i]);\n            }\n            printf(\":\");*/\n\n            j=0;\n            while(1)\n            {\n                //printf(\"j=%d...\",j );\n                switch(temporary[j])\n                {\n                    case '+':\n                        temporary[j-2]=or(temporary[j-2],temporary[j-1]);\n                        temporary[j]=-1;\n                        temporary[j-1]=-1;\n                        for(k=j-1;k<mand-2;k++)\n                        {\n                            temporary[k]=temporary[k+2];\n                        }\n                        temporary[mand-2]=-1;\n                        temporary[mand-1]=-1;\n                        j-=2;\n                        break;\n                    case '*':\n                        temporary[j-2]=and(temporary[j-2],temporary[j-1]);\n//                        printf(\"(%d,%d)=%d...\",temporary[j-2],temporary[j-1],and(temporary[j-2],temporary[j-1]));\n                        temporary[j]=-1;\n                        temporary[j-1]=-1;\n                        for(k=j-1;k<mand-1;k++)\n                        {\n                            temporary[k]=temporary[k+2];\n                        }\n                        temporary[mand-2]=-1;\n                        temporary[mand-1]=-1;\n                        j-=2;\n                        break;\n                    case '-':\n                        temporary[j-1]=not(temporary[j-1]);\n                        //printf(\"not(%d)=%d\\n\",temporary[j-1],not(temporary[j-1]));\n                        for(k=j;k<mand-1;k++)\n                        {\n                            temporary[k]=temporary[k+1];\n                        }\n                        temporary[mand-1]=-1;\n                        j--;\n                        break;\n                    default:\n                        break;\n                }\n\n                /*for(k=0;k<mand;k++)\n                {\n                    if(temporary[k]<3) printf(\"%d\",temporary[k]);\n                    else printf(\"%c\",temporary[k]);\n                }\n                printf(\".\\n\");*/\n//                printf(\"%d\\n\",temporary[0]);\n                if(temporary[1]==-1 || mand==1)\n                {\n    //                printf(\"\\n\\n\");\n                    if(temporary[0]==2)\n                    {\n                        count++;\n                    }\n                    break;\n                }\n                j++;\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1155\nTitle How can I satisfy thee? Let me count the ways...\n@kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nchar exp1[100];\nint  exp_idx;\nint  cnt=0;\nint and_3[3][3]={{0,0,0},{0,1,1},{0,1,2}};\nint or_3[3][3]={{0,1,2},{1,1,2},{2,2,2}};\n\n//\nint eval_exp(char * exp)\n{ \n        char exp2[100],*p1,*p2;\n\n\n        if(strlen(exp)==1)\n                return(*exp-'0');\n        p1=exp;\n        p2=exp2;\n        while(p1[0])\n        {\n                if(p1[0]=='-')\n                {\n                        if(p1[1]=='-')\n                        {\n                                p1+=2;\n                        }\n                        else if(p1[1]=='0')\n                        {\n                                p1+=2;\n                                *p2++='2';\n                        }\n                        else if(p1[1]=='1')\n                        {\n                                p1+=2;\n                                *p2++='1';\n                        }\n                        else if(p1[1]=='2')\n                        {\n                                p1+=2;\n                                *p2++='0';\n                        }\n                        else\n                        {\n                                p1++;\n                                *p2++='-';\n                        }\n                }\n                else if(0==strncmp(\"(0)\",p1,3))\n                {\n                        p1+=3;\n                        *p2++='0';\n                }\n                else if(0==strncmp(\"(1)\",p1,3))\n                {\n                        p1+=3;\n                        *p2++='1';\n                }\n                else if(0==strncmp(\"(2)\",p1,3))\n                {\n                        p1+=3;\n                        *p2++='2';\n                }\n                else if(p1[1]=='*' && isdigit(p1[0]) && isdigit(p1[2]))\n                {\n                        *p2++='0'+and_3[p1[0]-'0'][p1[2]-'0'];\n                        p1+=3;\n\n                }\n                else if(p1[1]=='+' && isdigit(p1[0]) && isdigit(p1[2]))\n                {\n                        *p2++='0'+or_3[p1[0]-'0'][p1[2]-'0'];\n                        p1+=3;\n                }\n                else\n                {\n                        *p2=*p1;\n                        p1++;p2++;\n                }\n        }\n\n        *p2='\\0';\n      \n        return(eval_exp(exp2));\n}\nint replace_eval_exp(char * exp1,int p,int q,int r)\n{ \n        char exp2[100],*ep;\n        int ret;\n\n        strcpy(exp2,exp1);\n        ep=exp2;\n        while(*ep)\n        {\n                if(*ep=='P')\n                        *ep='0'+p;\n                else if(*ep=='Q')\n                        *ep='0'+q;\n                else if(*ep=='R')\n                        *ep='0'+r;\n                ep++;\n        }\n\n        ret=eval_exp(exp2);\n#ifdef DEBUG\n        printf(\"R:%s ret=%d\\n\",exp2,ret);\n#endif\n        return(ret);\n}\nmain()\n{\n        int i,j,k,ret;\n\n        while(EOF!=scanf(\"%s\",exp1) && exp1[0]!='.')\n        {\n\n                //printf(\"EXP=%s\\n\",exp1);\n\n                cnt=0;\n                for(i=0;i<=2;i++)\n                        for(j=0;j<=2;j++)\n                                for(k=0;k<=2;k++)\n                                {\n                                        ret = replace_eval_exp(exp1,i,j,k);\n                                        cnt += (2==ret);\n                                }\n                printf(\"%d\\n\",cnt);\n\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#define M(x,y)(x>y?x:y)\n#define m(x,y)(x<y?x:y)\nI;int parse(char *p){switch(*p){\n\tcase'0':return 0;\n\tcase'1':return 1;\n\tcase'2':return 2;\n\tcase'P':return I%3;\n\tcase'Q':return I/3%3;\n\tcase'R':return I/9%3;\n\tcase'-':return 2-parse(p+1);\n\tcase'(':{\n\t\tint x=0;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\treturn (*(++p)=='*')?m(parse(q),parse(p+1)):M(parse(q),parse(p+1));\n\t}\n}}\nchar p[81];main(s){for(;scanf(\"%s\",p),*p-'.';printf(\"%d\\n\",s))for(s=I=0;I<27;I++)s+=parse(p)==2;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint bind[128];\nchar *i;\n\nint rdp(void)\n{\n    int a, b;\n    char c, op;\n\n    switch (c = *i++) {\n        case '0':\n        case '1':\n        case '2':\n            return c - '0';\n        case 'P':\n        case 'Q':\n        case 'R':\n            return bind[c];\n        case '-':\n            return -(rdp() - 1) + 1;\n        case '(':\n            a = rdp();\n            switch (op = *i++) {\n                case '*':\n                    a = (a * rdp() + 1) / 2;\n                    break;\n                case '+':\n                    b = rdp();\n                    a = (a == 1 && b == 1) ? 1 : (a + b >= 2 ? 2 : a + b);\n                    break;\n            }\n            ++i;    // skip ')'\n            return a;\n    }\n    return a;\n}\n\nint main(void)\n{\n    for (;;) {\n        char s[81];\n        int p, q, r, c = 0;\n\n        scanf(\"%s\", s);\n        if (strcmp(s, \".\") == 0)\n            break;\n\n        for (p = 0; p < 3; ++p) {\n            bind['P'] = p;\n            for (q = 0; q < 3; ++q) {\n                bind['Q'] = q;\n                for (r = 0; r < 3; ++r) {\n                    bind['R'] = r;\n                    i = s;\n                    if (rdp() == 2)\n                        ++c;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", c);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint F(int p,int q,int r,char ft[100],int fc){//+=3 -=4 *=5\n\tint fit[100],ic,x,t;\n\tic=1;\n\tfor(t=0;t<100;t++){\n\t\tfit[t]=0;\n\t}\n\twhile(ic<fc){\n\t\tif(ft[ic]=='P'){\n\t\t\tfit[ic]=p;\n\t\t}\n\t\tif(ft[ic]=='Q'){\n\t\t\tfit[ic]=q;\n\t\t}\n\t\tif(ft[ic]=='R'){\n\t\t\tfit[ic]=r;\n\t\t}\n\t\tif(ft[ic]=='0'){\n\t\t\tfit[ic]=0;\n\t\t}\n\t\tif(ft[ic]=='1'){\n\t\t\tfit[ic]=1;\n\t\t}\n\t\tif(ft[ic]=='2'){\n\t\t\tfit[ic]=2;\n\t\t}\n\t\tif(ft[ic]=='+'){\n\t\t\tfit[ic]=3;\n\t\t}\n\t\tif(ft[ic]=='-'){\n\t\t\tfit[ic]=4;\n\t\t}\n\t\tif(ft[ic]=='*'){\n\t\t\tfit[ic]=5;\n\t\t}\n\t\tic++;\n\t}\n\tic--;\n\tx=1;\n\twhile(x<ic){\n\t\tif(fit[x]==3){\n\t\t\tif(fit[x-1]==0&&fit[x-2]==0){\n\t\t\t\tfit[x-2]=0;\n\t\t\t}\n\t\t\telse if(fit[x-1]==2||fit[x-2]==2){\n\t\t\t\tfit[x-2]=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfit[x-2]=1;\n\t\t\t}\n\t\t\tic-=2;\n\t\t\tfor(t=x-1;t<=ic;t++){\n\t\t\t\tfit[t]=fit[t+2];\n\t\t\t}\n\t\t\tx-=2;\n\t\t}\n\t\tif(fit[x]==4){\n\t\t\tfit[x-1]=2-fit[x-1];\n\t\t\tic--;\n\t\t\tfor(t=x;t<=ic;t++){\n\t\t\t\tfit[t]=fit[t+1];\n\t\t\t}\n\t\t\tx--;\n\t\t}\n\t\tif(fit[x]==5){\n\t\t\tif(fit[x-1]==0||fit[x-2]==0){\n\t\t\t\tfit[x-2]=0;\n\t\t\t}\n\t\t\telse if(fit[x-1]==2&&fit[x-2]==2){\n\t\t\t\tfit[x-2]=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfit[x-2]=1;\n\t\t\t}\n\t\t\tic-=2;\n\t\t\tfor(t=x-1;t<=ic;t++){\n\t\t\t\tfit[t]=fit[t+2];\n\t\t\t}\n\t\t\tx-=2;\n\t\t}\n\t\tx++;\n\t}\n\treturn fit[1];\n}\nint main(void){\n\tint c,nc,oc,fc;\n\tchar txt[100],ng[100],op[100],ft[100];\n\twhile(1){\n\t\tscanf(\"%s\",&txt);\n\t\tif(txt[0]=='.'){\n\t\t\tbreak;\n\t\t}\n\t\tnc=oc=fc=0;\n\t\tfor(c=0;c<strlen(txt);c++){\n\t\t\tif(txt[c]==0||txt[c]==1||txt[c]==2||txt[c]=='P'||txt[c]=='Q'||txt[c]=='R'){\n\t\t\t\tfc++;\n\t\t\t\tft[fc]=txt[c];\n\t\t\t\tif(nc!=0){\n\t\t\t\t\twhile(nc!=0){\n\t\t\t\t\t\tfc++;\n\t\t\t\t\t\tft[fc]=ng[nc];\n\t\t\t\t\t\tnc--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(txt[c]=='+'){\n\t\t\t\tif(oc==0||op[oc]=='('){\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(oc!=0){\n\t\t\t\t\t\tfc++;\n\t\t\t\t\t\tft[fc]=op[oc];\n\t\t\t\t\t\toc--;\n\t\t\t\t\t}\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(txt[c]=='*'){\n\t\t\t\tif(oc==0||op[oc]=='+'||op[oc]=='('){\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(oc!=0){\n\t\t\t\t\t\tfc++;\n\t\t\t\t\t\tft[fc]=op[oc];\n\t\t\t\t\t\toc--;\n\t\t\t\t\t}\n\t\t\t\t\toc++;\n\t\t\t\t\top[oc]=txt[c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(txt[c]=='('){\n\t\t\t\toc++;\n\t\t\t\top[oc]=txt[c];\n\t\t\t}\n\t\t\tif(txt[c]==')'){\n\t\t\t\twhile(op[oc]!='('){\n\t\t\t\t\tfc++;\n\t\t\t\t\tft[fc]=op[oc];\n\t\t\t\t\toc--;\n\t\t\t\t}\n\t\t\t\top[oc]=0;\n\t\t\t\toc--;\n\t\t\t}\n\t\t\tif(txt[c]=='-'){\n\t\t\t\tnc++;\n\t\t\t\tng[nc]=txt[c];\n\t\t\t}\n\t\t}\n\t\tif(oc!=0){\n\t\t\twhile(oc!=0){\n\t\t\t\tfc++;\n\t\t\t\tft[fc]=op[oc];\n\t\t\t\toc--;\n\t\t\t}\n\t\t}\n\t\tfor(c=1;c<=fc;c++){\n\t\t\tprintf(\"%c\",ft[c]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(c=0;c<100;c++){\n\t\t\tng[c]=op[c]=0;\n\t\t}\n\t\tint p,q,r,ans;\n\t\tans=0;\n\t\tfor(p=0;p<3;p++){\n\t\t\tfor(q=0;q<3;q++){\n\t\t\t\tfor(r=0;r<3;r++){\n\t\t\t\t\tif(F(p,q,r,ft,fc)==2){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint P,Q,R,a;\nchar *p;\n\nint formula(){\n  int l,r;\n  char c = *p++;\n  if(isdigit(c)) return c-'0';\n  if(isupper(c)) return (c == 'P' ? P : c == 'Q' ? Q : R);\n  if(c == '-') return 2-formula();\n  if(c == '('){\n    l = formula(); c = *p++; r = formula(); *p++;\n    if(c == '*') return (l < r ? l : r);\n    return (l > r ? l : r);\n  }\n  return 0;\n}\n\nint main(){\n  char s[100];\n  while(scanf(\"%s\",s), s[0] != '.'){\n    a = 0; \n    for(P = 0 ; P < 3 ; P++){\n      for(Q = 0 ; Q < 3 ; Q++){\n        for(R = 0 ; R < 3 ; R++){\n          p = s;\n          if(formula() == 2) a++;\n        }\n      }\n    }\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint formula(char *);\nint min(int,int);\nint max(int,int);\n\nint p,q,r;\nint position;\n\nmain(){\n    int count=0;\n    char str[10000];\n    \n    while(1){\n        \n        scanf(\"%s\",str);\n        if(str[0] == '.') break;\n        count = 0;\n        \n    for(p=0; p<3; p++){\n        for(q=0; q<3; q++){\n            for(r=0; r<3; r++){\n                position = 0;\n               if(formula(str) == 2)\n               count++;\n            }\n        }\n    }\n    printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}\n\nint formula(char *str){\n    int result;\n    \n    if(str[position] == '-'){\n        result = 2-formula(str);\n        position++;\n    }   \n    \n    else if(str[position] == '('){\n    position++;\n    result = formula(str);\n    if(str[position] == '*'){\n        position++;\n        result = min(result,formula(str));\n    }\n    else if(str[position] == '+'){\n        position++;\n        result = max(result,formula(str));\n    }\n}\n\nelse{\n    if(str[position] >= '0' && str[position] <= '2')\n    return str[position] - '0';\n    \n    if(str[position] == 'P')\n    return p;\n    else if(str[position] == 'Q')\n    return q;\n    else if(str[position] == 'R')\n    return r;\n    }\n}\n\nint min(int x,int y){\n    if(x > y)\n    return y;\n    else return x;\n}\n\nint max(int x,int y){\n    if(x > y)\n    return x;\n    else return y;\n}"
  },
  {
    "language": "C",
    "code": "/*\n\t????????????\n\t????±??????????\n\t????????\\???\n*/\n\n#include<stdio.h>\n\n#define SIZE 81\t//??\\???????????????????????°+1\n#define FALSE '0'\n#define UNKNOWN '1'\n#define TRUE '2'\n#define X -1\t//?????£???\n\ntypedef struct LOGIC Logic;\nstruct LOGIC{\n\tchar formula[SIZE];\t//??\\????????????????????????\n\tchar v[3];\t//?????°???\n};\n\nint Main();\nchar Calc(Logic *logic);\t//???????????????????????????????????£??\\???????????????????????????\nint Not(int a);\t//?????????\nint And(int a, int b);\t//?????????\nint Or(int a, int b);\t//?????????\n\nint main(int argc, char *argv[]){\n\twhile( Main() == 0 );\n\treturn 0;\n}\n\nint Main(){\n\tLogic logic;\n\tint num = 0, count = 0, i = 0;\t//????????§??????????????????????????????????????????????????°???\n\tfor( i = 0; i < SIZE; i++ ){ logic.formula[i] = '\\0'; }\n\tif( scanf(\"%s\", logic.formula) != 1 ){ return -1; }\n\tif( logic.formula[0] == '.' ){ return 1; }\n\tfor( logic.v[0] = FALSE; logic.v[0] <= TRUE; logic.v[0]++ ){\n\t\tfor( logic.v[1] = FALSE; logic.v[1] <= TRUE; logic.v[1]++ ){\n\t\t\tfor( logic.v[2] = FALSE; logic.v[2] <= TRUE; logic.v[2]++ ){\n\t\t\t\tnum = 0;\n\t\t\t\tcount += (Calc(&logic) == TRUE);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", count);\n\treturn 0;\n}\n\nchar Calc(Logic *logic){\n\tint a[2], sc = 0, i = 0;\t//?????????????????°?????????????????????????????????\n\tchar stack[SIZE], s = '\\0', ope = '\\0';\t//?????????????????????????????????????????????????????????????????????\n\tfor( i = 0; i < SIZE; i++ ){ stack[i] = '\\0'; }\n\tfor( i = 0; logic->formula[i] != '\\0'; i++ ){\n\t\tif( 'P' <= logic->formula[i] && logic->formula[i] <= 'R' ){\n\t\t\tstack[sc++] = logic->v[logic->formula[i] - 'P'];\n\t\t}else{\n\t\t\tstack[sc++] = logic->formula[i];\n\t\t}\n\t\tif( logic->formula[i] == ')' ){\n\t\t\t//??????????????????????????§???a[1]????¨?????????????\n\t\t\tfor( s = stack[--sc]; s != '+' && s != '*'; s = stack[--sc] ){\n\t\t\t\tstack[sc+1] = '\\0';\n\t\t\t\tif( 'P' <= s && s <= 'R' ){\n\t\t\t\t\ta[1] = logic->v[s-'P'] + '0';\n\t\t\t\t}else if( '0' <= s && s <= '2' ){\n\t\t\t\t\ta[1] = s;\n\t\t\t\t}else if( s == '-' ){\n\t\t\t\t\ta[1] = Not(a[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[sc+1] = '\\0';\n\t\t\tope = stack[sc];\n\t\t\t//'('?????????????????§a[0]????¨?????????????\n\t\t\tfor( s = stack[--sc]; stack[sc] != '('; s = stack[--sc] ){\n\t\t\t\tstack[sc+1] = '\\0';\n\t\t\t\tif( 'P' <= s && s <= 'R' ){\n\t\t\t\t\ta[0] = logic->v[s-'P'] + '0';\n\t\t\t\t}else if( '0' <= s && s <= '2' ){\n\t\t\t\t\ta[0] = s;\n\t\t\t\t}else if( s == '-' ){\n\t\t\t\t\ta[0] = Not(a[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[sc+1] = '\\0';\n\t\t\tif( ope == '*' ){\n\t\t\t\tstack[sc++] = And(a[0], a[1]);\n\t\t\t}else if( ope == '+' ){\n\t\t\t\tstack[sc++] = Or(a[0], a[1]);\n\t\t\t}\n\t\t}\n\t}\n\t//??\\??????????????????????????§??°??????????????§?????????????¨?????????????\n\ta[0] = stack[--sc];\t//?????????????????????\n\t//?????¨???????????????NOT?????¨???'-'?????????\n\tfor( sc-- ; sc >= 0; sc-- ){\n\t\tif( stack[sc] == '-' ){ a[0] = Not(a[0]); }\n\t}\n\tstack[++sc] = a[0];\n\treturn stack[0];\n}\n\nint Not(int a){\n\tswitch( a ){\n\t\tcase FALSE:\n\t\t\treturn TRUE;\n\t\tcase UNKNOWN:\n\t\t\treturn UNKNOWN;\n\t\tcase TRUE:\n\t\t\treturn FALSE;\n\t}\n\treturn X;\n}\n\nint And(int a, int b){\n\tif( a == X || b == X ){ return X; }\t//?????§?????????\n\tif( a == FALSE || b == FALSE ){\n\t\treturn FALSE;\n\t}else if( a == UNKNOWN || b == UNKNOWN ){\n\t\treturn UNKNOWN;\n\t}else if( a == TRUE && b == TRUE ){\n\t\treturn TRUE;\n\t}\n\treturn X;\n}\n\nint Or(int a, int b){\n\tif( a == X || b == X ){ return X; }\t//?????§?????????\n\tif( a == TRUE || b == TRUE ){\n\t\treturn TRUE;\n\t}else if( a == UNKNOWN || b == UNKNOWN ){\n\t\treturn UNKNOWN;\n\t}else if( a == FALSE && b == FALSE ){\n\t\treturn FALSE;\n\t}\n\treturn X;\n}"
  },
  {
    "language": "C",
    "code": "#define M(x,y)(x>y?x:y)\n#define m(x,y)(x<y?x:y)\nI;int parse(char *p){switch(*p){\n\tcase'0':return 0;\n\tcase'1':return 1;\n\tcase'2':return 2;\n\tcase'P':return I%3;\n\tcase'Q':return I/3%3;\n\tcase'R':return I/9%3;\n\tcase'-':return 2-parse(p+1);\n\tcase'(':{\n\t\tint x=0;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\treturn(*(++p)=='*')?m(parse(q),parse(p+1)):M(parse(q),parse(p+1));\n\t}\n}}\nchar p[81];main(s){for(;scanf(\"%s\",p),*p-'.';printf(\"%d\\n\",s))for(s=I=0;I<27;I++)s+=parse(p)==2;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n/* 三値論理の否定を計算する */\nint tnot(int a) {\n\treturn 2 - a;\n}\n/* 三値論理の積を計算する */\nint tand(int a, int b) {\n\treturn a < b ? a : b;\n}\n/* 三値論理の和を計算する */\nint tor(int a, int b) {\n\treturn a > b ? a : b;\n}\n\n/* 三値論理の式を計算する */\n#define SIGN_NOT 3\n#define SIGN_AND 4\n#define SIGN_OR 5\n#define SIGN_LEFT_PAREN 6\n#define SIGN_RIGHT_PAREN 7\nint calculate(const char *formula, int n, int p, int q, int r) {\n\tint stack[81];\n\tint size = 0;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\t/* 式を1文字読む */\n\t\tswitch (formula[i]) {\n\t\t\tcase '-': stack[size] = SIGN_NOT; break;\n\t\t\tcase '*': stack[size] = SIGN_AND; break;\n\t\t\tcase '+': stack[size] = SIGN_OR; break;\n\t\t\tcase '(': stack[size] = SIGN_LEFT_PAREN; break;\n\t\t\tcase ')': stack[size] = SIGN_RIGHT_PAREN; break;\n\t\t\tcase 'P': stack[size] = p; break;\n\t\t\tcase 'Q': stack[size] = q; break;\n\t\t\tcase 'R': stack[size] = r; break;\n\t\t\tdefault: stack[size] = formula[i] - '0'; /* 値 */\n\t\t}\n\t\tsize++;\n\n\t\t/* 構文に一致する箇所がなくなるまで処理する */\n\t\tint b = 1;\n\t\twhile (b) {\n\t\t\tb = 0;\n\t\t\t/* 構文に一致する箇所を計算する */\n\t\t\tif (size >= 2 && stack[size-2] == SIGN_NOT && (stack[size-1] >= 0 && stack[size-1] <= 2)) {\n\t\t\t\t/* 否定 */\n\t\t\t\tstack[size-2] = tnot(stack[size-1]);\n\t\t\t\tsize--;\n\t\t\t\tb = 1;\n\t\t\t} else if (size >= 5 && stack[size-5] == SIGN_LEFT_PAREN  && stack[size-1] == SIGN_RIGHT_PAREN) {\n\t\t\t\tif (stack[size-3] == SIGN_AND) {\n\t\t\t\t\t/* 論理積 */\n\t\t\t\t\tstack[size-5] = tand(stack[size-4], stack[size-2]);\n\t\t\t\t\tsize -= 4;\n\t\t\t\t\tb = 1;\n\t\t\t\t} else if (stack[size-3] == SIGN_OR) {\n\t\t\t\t\t/* 論理和 */\n\t\t\t\t\tstack[size-5] = tor(stack[size-4], stack[size-2]);\n\t\t\t\t\tsize -= 4;\n\t\t\t\t\tb = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stack[0];\n}\n\nint main(void) {\n\tchar s[81];\n\tint i, l, n;\n\n\t/* データセット毎の処理 */\n\twhile (scanf(\"%s\", s) == 1 && s[0] != '.') {\n\t\tl = strlen(s); /* 式の長さ */\n\t\tn = 0;\n\t\t/* (P,Q,R) を総当たりで調べ計算結果が 2 となる場合の数を数える */\n\t\tfor (i = 0; i < 3 * 3 * 3; i++) {\n\t\t\tif (calculate(s, l, (i / 3 / 3) % 3, (i / 3) % 3, i % 3) == 2) n++;\n\t\t}\n\t\tprintf(\"%d\\n\", n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint P,Q,R;\nchar *p;\n\nint formula(){\n  int l,r;\n  char c = *p++;\n  if(isdigit(c)) return c-'0';\n  if(isupper(c)) return (c == 'P' ? P : c == 'Q' ? Q : R);\n  if(c == '-') return 2-formula();\n  if(c == '('){\n    l = formula();\n    if(*p++ == '*'){\n      r = formula();\n      *p++;\n      return (l < r ? l : r);\n    }else{\n      r = formula();\n      *p++;\n      return (l > r ? l : r);\n    }  \n  }\n  return 0;\n}\n\nint main(){\n  int ans;\n  char s[1000];\n  while(scanf(\"%s\",s), strcmp(s,\".\") != 0){\n    ans = 0; \n    for(P = 0 ; P < 3 ; P++){\n      for(Q = 0 ; Q < 3 ; Q++){\n        for(R = 0 ; R < 3 ; R++){\n          p = s;\n          if(formula() == 2) ans++;\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define max(x,y) ((x)>(y)?(x):(y))\n#define min(x,y) ((x)<(y)?(x):(y))\n#define mul min\n#define add max\n#define n(x) (2-(x))\n\nint _p,_q,_r;\n\nint parse(char *p){\n  switch(*p){\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case 'P': return _p;\n    case 'Q': return _q;\n    case 'R': return _r;\n    case '-': return n(parse(p+1));\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return mul(parse(q),parse(p+1));\n                  case '+': return add(parse(q),parse(p+1));\n                }\n              }\n  }\n}\n\nint main(){\n  char p[81];\n  int s;\n  while(1){\n    s=0;\n    scanf(\"%s\",p);\n    if(*p=='.')return 0;\n    for(_p=0;_p<3;_p++)\n      for(_q=0;_q<3;_q++)\n        for(_r=0;_r<3;_r++)\n        if(parse(p)==2)s++;\n    printf(\"%d\\n\",s);\n  }\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1155\n   How can I satisfy thee? Let me count the ways...\n   2016/5/26\n*/\n\n#include<stdio.h>\n#define MAX_STR 100\nchar instr[MAX_STR];\nchar not[3] = {'2', '1', '0'};\nchar and[3][3] = {{'0', '0', '0'}, {'0', '1', '1'}, {'0', '1', '2'}};\nchar or[3][3] = {{'0', '1', '2'}, {'1', '1', '2'}, {'2', '2', '2'}};\nint pp, p, q, r;\n\n  \n\nchar interpreter(void)\n{\n  char c = instr[pp];\n  switch(c)\n    {\n    case '0':\n    case '1':\n    case '2':\n      return instr[pp++];\n    case 'P':\n      pp++;\n      return p + '0';\n    case 'Q':\n      pp++;\n      return q + '0';\n    case 'R':\n      pp++;\n      return r + '0';\n    case '-':\n      pp++;\n      return not[interpreter() - '0'];\n    case '(':\n      pp++;\n      char f0 = interpreter();\n      char op = instr[pp++];\n      char f1 = interpreter();\n      pp++;\n      if(op == '*')\n\treturn and[f0 - '0'][f1 - '0'];\n      else\n\treturn or[f0 - '0'][f1 - '0'];\n    }\n}\n\nint main(void)\n{\n  int ans = 0, i;\n  while(scanf(\"%s\", instr), instr[0] != '.')\n    {\n      for(p = 0; p < 3; p++)\n\tfor(q = 0; q < 3; q++)\n\t  for(r = 0; r < 3; r++)\n\t    {\n\t      if(interpreter() == '2')\n\t\tans++;\n\t      pp = 0;\n\t    }\n      printf(\"%d\\n\", ans);\n      ans = 0;\n      for(i = 0; i < MAX_STR; i++)\n\tinstr[i] = '\\0';\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar str[81];\nint P, Q, R, ans, p;\n\nint min(int a, int b){ return a > b ? b : a; }\nint max(int a, int b){ return a < b ? b : a; }\n\nint formula(){\n  int x, res;\n  if(str[p] == '('){\n    p++;\n    x = formula();\n    if(str[p++] == '*') res = min(x, formula());\n    else res = max(x, formula());\n    p++;\n  }else if(str[p] == '-'){\n    p++;\n    res = 2 - formula();\n  }else{\n    if(str[p] == '0') res = 0;\n    if(str[p] == '1') res = 1;\n    if(str[p] == '2') res = 2;\n    if(str[p] == 'P') res = P;\n    if(str[p] == 'Q') res = Q;\n    if(str[p] == 'R') res = R;\n    p++;\n  }\n  return res;\n}\n\nmain(){\n  while(1){\n    scanf(\"%s\", str);\n    if(str[0] == '.') break;\n    ans = 0;\n    for(P=0;P<3;P++){\n      for(Q=0;Q<3;Q++){\n        for(R=0;R<3;R++){\n          p = 0;\n          if(formula() == 2) ans++;\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define M(x,y)(x>y?x:y)\n#define m(x,y)(x<y?x:y)\nI;int parse(char *p){switch(*p){\n\tcase'0':return 0;\n\tcase'1':return 1;\n\tcase'2':return 2;\n\tcase'P':return I%3;\n\tcase'Q':return I/3%3;\n\tcase'R':return I/9%3;\n\tcase'-':return 2-parse(p+1);\n\tcase'(':{\n\t\tint x=0;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\treturn (*(++p)=='*')?m(parse(q),parse(p+1)):M(parse(q),parse(p+1));\n\t}\n}\nchar p[81];main(s){for(;scanf(\"%s\",p),*p-'.';printf(\"%d\\n\",s))for(s=I=0;I<27;I++)s+=parse(p)==2;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 80\n\nint not(int x)\n{\n    return (x==0)? 2:((x==1)? 1: 0);\n}\n\nint and(int x,int y)\n{\n    return (x==0 || y==0)? 0: ((x==1 || y==1)? 1: 2);\n}\n\nint or(int x,int y)\n{\n    return (x==2 || y==2)? 2: ((x==1 || y==1)? 1: 0);\n}\n\nint main(void)\n{\n    int pqr[27][3]; //prt[pattern][p/q/r]\n    int i,j,k,l,c=0,num=0;\n\n    for(i=0;i<3;i++)        //initialize\n    {\n        for(j=0;j<3;j++)\n        {\n            for(k=0;k<3;k++)\n            {\n                pqr[num][0]=i;\n                pqr[num][1]=j;\n                pqr[num][2]=k;\n                num++;\n            }\n        }\n    }\n\n    while(1)\n    {\n        int operand[MAX]={},operator[MAX]={},command[MAX]={},kakko[MAX]={};\n        int rand=0,rator=0,mand=0,jud=0,count=0,kko=0;\n\n        while(1)\n        {\n            scanf(\"%c\",&c);\n            if(c=='.')\n            {\n                jud=1;\n                break;\n            }\n            if(c=='\\n')\n            {\n                break;\n            }\n\n            switch(c)       //???????????????????¨????\n            {\n                case '+':\n                case '*':\n                    operator[rator]=c;\n                    rator++;\n                    break;\n                case '-':\n                    if(operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                    }\n                    else\n                    {\n                        operator[rator]='-';\n                        rator++;\n                    }\n                    break;\n                case ')':\n                    rator--;\n                    command[mand]=operator[rator];\n                    operator[rator]=0;\n                    mand++;\n                    if(kakko[kko-1]==1)\n                    {\n                        kakko[kko-1]=0;\n                        command[mand]='-';\n                        mand++;\n                    }\n                    kko--;\n                    break;\n                case '(':\n                    if(operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                        kakko[kko]=1;\n                    }\n                    kko++;\n                    break;\n                default:\n                    command[mand]=c;\n                    mand++;\n                    if(rator>0 && operator[rator-1]=='-')\n                    {\n                        rator--;\n                        operator[rator]=0;\n                        command[mand]='-';\n                        mand++;\n                    }\n                    break;\n            }\n        }\n\n        for(i=0;i<mand;i++)\n        {\n            printf(\"%c\",command[i]);\n        }\n        printf(\"\\n\");\n\n        if(jud==1)\n        {\n            break;\n        }\n\n        for(l=0;l<27;l++)       //calculate\n        {\n            char calculate[mand];\n            for(j=0;j<mand;j++)\n            {\n                calculate[j]=0;\n                switch(command[j])\n                {\n                    case 'P':\n                        calculate[j]=pqr[l][0];\n                        break;\n                    case 'Q':\n                        calculate[j]=pqr[l][1];\n                        break;\n                    case 'R':\n                        calculate[j]=pqr[l][2];\n                        break;\n                    default:\n                        if(isdigit(command[j]))\n                        {\n                               command[j]-='0';\n                        }\n                        calculate[j]=command[j];\n                        break;\n                }\n            }\n\n            char temporary[mand];\n\n            for(i=0;i<mand;i++)\n            {\n                temporary[i]=calculate[i];\n            }\n\n/*           for(i=0;i<mand;i++)\n            {\n                if(temporary[i]<3) printf(\"%d\",temporary[i]);\n                else printf(\"%c\",temporary[i]);\n            }\n            printf(\":\");*/\n\n            j=0;\n            while(1)\n            {\n                //printf(\"j=%d...\",j );\n                switch(temporary[j])\n                {\n                    case '+':\n                        temporary[j-2]=or(temporary[j-2],temporary[j-1]);\n                        temporary[j]=-1;\n                        temporary[j-1]=-1;\n                        for(k=j-1;k<mand-2;k++)\n                        {\n                            temporary[k]=temporary[k+2];\n                        }\n                        temporary[mand-2]=-1;\n                        temporary[mand-1]=-1;\n                        j-=2;\n                        break;\n                    case '*':\n                        temporary[j-2]=and(temporary[j-2],temporary[j-1]);\n//                        printf(\"(%d,%d)=%d...\",temporary[j-2],temporary[j-1],and(temporary[j-2],temporary[j-1]));\n                        temporary[j]=-1;\n                        temporary[j-1]=-1;\n                        for(k=j-1;k<mand-1;k++)\n                        {\n                            temporary[k]=temporary[k+2];\n                        }\n                        temporary[mand-2]=-1;\n                        temporary[mand-1]=-1;\n                        j-=2;\n                        break;\n                    case '-':\n                        temporary[j-1]=not(temporary[j-1]);\n                        //printf(\"not(%d)=%d\\n\",temporary[j-1],not(temporary[j-1]));\n                        for(k=j;k<mand-1;k++)\n                        {\n                            temporary[k]=temporary[k+1];\n                        }\n                        temporary[mand-1]=-1;\n                        j--;\n                        break;\n                    default:\n                        break;\n                }\n\n                /*for(k=0;k<mand;k++)\n                {\n                    if(temporary[k]<3) printf(\"%d\",temporary[k]);\n                    else printf(\"%c\",temporary[k]);\n                }\n                printf(\".\\n\");*/\n//                printf(\"%d\\n\",temporary[0]);\n                if(temporary[1]==-1 || mand==1)\n                {\n    //                printf(\"\\n\\n\");\n                    if(temporary[0]==2)\n                    {\n                        count++;\n                    }\n                    break;\n                }\n                j++;\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar S[100],St[100],T[100],c;\nint P,Q,R,p,i,j,sp,St2[100],Res;\nint not[3]={2,1,0};\nint and[3][3]={{},{0,1,1},{0,1,2}};\nint or[3][3]={{0,1,2},{1,1,2},{2,2,2}};\nvoid pop(){T[p++]=St[--sp];}\nvoid push(){St[sp++]=S[i];}\nvoid NotPOP(){for(;St[sp-1]=='-';T[p++]=St[--sp]);}\nint pop2(){return St2[--sp];}\nvoid push2(int n){St2[sp++]=n;}\n\n\nint cal()\n{\n\tmemset(St2,-1,sizeof(St2));\n\tfor(i=sp=0;c=T[i];i++)\n\t{\n\t\tswitch(T[i])\n\t\t{\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':push2(T[i]-'0');break;\n\t\tcase 'P':push2(P);break;\n\t\tcase 'Q':push2(Q);break;\n\t\tcase 'R':push2(R);break;\n\t\tcase '*':push2(and[pop2()][pop2()]);break;\n\t\tcase '+':push2(or[pop2()][pop2()]);break;\n\t\tcase '-':push2(not[pop2()]);break;\n\t\t}\n\t}\n\treturn St2[0];\n}\n\nint main()\n{\n\tfor(;scanf(\"%s\",S),S[0]!='.';)\n\t{\n\t\tmemset(St,0,sizeof(St));\n\t\tmemset(T,0,sizeof(T));\n\t\tfor(i=p=sp=0;S[i];i++)\n\t\t{\n\t\t\tswitch(S[i])\n\t\t\t{\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase 'P':\n\t\t\tcase 'Q':\n\t\t\tcase 'R':T[p++]=S[i];NotPOP();break;\n\t\t\tcase '(':push();break;\n\t\t\tcase ')':pop();sp--;NotPOP();break;\n\t\t\tcase '*':\n\t\t\tcase '+':\n\t\t\tcase '-':push();break;\n\t\t\t}\n\t\t}\n\t\tfor(P=Res=0;P<3;P++)\n\t\t\tfor(Q=0;Q<3;Q++)\n\t\t\t\tfor(R=0;R<3;R++)\n\t\t\t\t\tif(cal()==2)\n\t\t\t\t\t\tRes++;\n\t\tprintf(\"%d\\n\",Res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint formula(char *);\nint min(int,int);\nint max(int,int);\n\nint p,q,r;\nint position;\n\nmain(){\n    int count=0;\n    char str[100000];\n    \n    while( scanf(\"%s\",str) !=EOF){\n        if(str[0] == '.') break;\n        count = 0;\n        \n    for(p=0; p<3; p++){\n        for(q=0; q<3; q++){\n            for(r=0; r<3; r++){\n                position = 0;\n               if(formula(str) == 2)\n               count++;\n            }\n        }\n    }\n    printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}\n\nint formula(char *str){\n    int result;\n    \n    if(str[position] == '-'){\n        result = 2-formula(str);\n        position++;\n    }   \n    \n    else if(str[position] == '('){\n    position++;\n    result = formula(str);\n    if(str[position] == '*'){\n        position++;\n        result = min(result,formula(str));\n    }\n    else if(str[position] == '+'){\n        position++;\n        result = max(result,formula(str));\n    }\n}\n\nelse{\n    if(str[position] >= '0' && str[position] <= '2')\n    return str[position] - '0';\n    \n    if(str[position] == 'P')\n    return p;\n    else if(str[position] == 'Q')\n    return q;\n    else if(str[position] == 'R')\n    return r;\n    }\n}\n\nint min(int x,int y){\n    if(x > y)\n    return y;\n    else return x;\n}\n\nint max(int x,int y){\n    if(x > y)\n    return x;\n    else return y;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint P,Q,R;\nint Not(int x){\n    if(x==0) return 2;\n    else if(x==1) return 1;\n    else return 0;\n}\nint seki(int x,int y){\n    if(x==0||y==0) return 0;\n    else if(x==1||y==1) return 1;\n    else return 2;\n}\nint wa(int x,int y){\n    if(x==2||y==2) return 2;\n    else if(x==1||y==1) return 1;\n    else return 0;\n}\nint eval_pos;                   // 現在処理中の論理式の位置\nint eval(char *str){\n    char token;                 // これから処理する文字\n    unsigned short v1, v2;                 // 引数の値\n    token = str[eval_pos++];    // １文字取得\n    switch(token){\n        case '0':                   // 定数 0\n            return 0;\n        case '1':                   // 定数 1\n            return 1;\n        case '2':                   // 定数 2\n            return 2;\n        case 'P':\n            return P;\n        case 'Q':\n            return Q;\n        case 'R':\n            return R;\n        case '-':                   // 論理否定\n            v1 = eval(str);         // 引数の値を求める\n            return Not(v1);\n        case '(':                   // 左括弧開始\n            v1 = eval(str);                 // 第一引数の値を求める\n            if(str[eval_pos++]=='+'){       // EXOR演算\n                v2 = eval(str);             // 第二引数の値を求める\n                if(str[eval_pos++] != ')')\n                    fprintf(stderr, \"missing ) for ^\\n\");   // 文法誤り\n                return wa(v1,v2);             // EXOR演算を適用\n            }\n            else {                          // 論理積演算\n                v2 = eval(str);             // 第二引数の値を求める\n                if(str[eval_pos++] != ')')\n                    fprintf(stderr, \"missing ) for ^\\n\");   // 文法誤り\n                return seki(v1,v2);             // 論理積演算を適用\n            }\n        default:\n            break;\n    }\n    return 0;\n}\nint value(char *str){\n    eval_pos = 0;\n    return eval(str);\n}\nint main(void){\n    while(1){\n        char buff[90];\n        fgets(buff,85,stdin);\n        if(buff[0]=='.') break;\n        int count=0;\n        for(int i=0;i<=2;i++){\n            for(int j=0;j<=2;j++){\n                for(int k=0;k<=2;k++){\n                    P=i,Q=j,R=k;\n                    if(value(buff)==2) count++;\n                }\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar str[81];\nint P, Q, R, ans, p;\n\nint min(int a, int b){ return a > b ? b : a; }\nint max(int a, int b){ return a < b ? b : a; }\n\nint formula(){\n  int x, res;\n  if(str[p] == '('){\n    p++;\n    x = formula();\n    if(str[p++] == '*') res = min(x, formula());\n    else res = max(x, formula());\n    p++;\n  }else if(str[p] == '-'){\n    p++;\n    res = 2 - formula();\n  }else{\n    if(str[p] == '0') res = 0;\n    if(str[p] == '1') res = 1;\n    if(str[p] == '2') res = 2;\n    if(str[p] == 'P') res = P;\n    if(str[p] == 'Q') res = Q;\n    if(str[p] == 'R') res = R;\n    p++;\n  }\n  return res;\n}\n\nmain(){\n  while(1){\n    scanf(\"%s\", str);\n    if(str[0] == '.') break;\n    ans = 0;\n    for(P=0;P<3;P++){\n      for(Q=0;Q<3;Q++){\n        for(R=0;R<3;R++){\n          p = 0;\n          if(formula() == 2) ans++;\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by S64 on 15/07/29.\n */\n\n\n// ????§?: 1??????34???43?§?\n// ??????: 0??????00???00?§? (????????????)\nclass Main {\n\n    enum Logic {\n        False,   // 0\n        Unknown, // 1\n        True,    // 2\n    }\n\n    enum Operator {\n        Not, // -\n        And, // *\n        Or,  // +\n    }\n\n    static class FormulaPattern {\n\n        public final Logic P;\n        public final Logic Q;\n        public final Logic R;\n\n        public FormulaPattern(Logic p, Logic q, Logic r) {\n            this.P = p;\n            this.Q = q;\n            this.R = r;\n        }\n\n    }\n\n    public static void main(String _[]) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true) {\n            String line = in.readLine();\n            if(line.equals(\".\"))\n                break;\n\n            int trueCount = 0;\n            int falseCount = 0;\n            int unknownCount = 0;\n\n            for(Logic p : Logic.values()) {\n                for(Logic q : Logic.values()) {\n                    for(Logic r : Logic.values()) {\n                        FormulaPattern x = new FormulaPattern(p, q, r);\n                        Logic result = Do(line.toCharArray(), x);\n\n                        if(result == Logic.True)\n                            trueCount++;\n                        if(result == Logic.False)\n                            falseCount++;\n                        if(result == Logic.Unknown)\n                            unknownCount++;\n                    }\n                }\n            }\n\n            System.out.println( String.format(\"%d\", trueCount) );\n            //System.out.println( String.format(\"  F: %d\", falseCount) );\n            //System.out.println( String.format(\"  U: %d\", unknownCount) );\n        }\n    }\n\n    static Logic Do(char[] line, FormulaPattern x) {\n        return Do(line, 0, x);\n    }\n\n    static Logic Do(char[] line, int position, FormulaPattern pattern) {\n        List<Operator> nextOperations = new ArrayList<>();\n        int previousValue = -1;\n\n        for(int i = position; i < line.length ; i++) {\n            char chr = line[i];\n\n            if(chr == '(') {\n                previousValue = (Do(line, i + 1, pattern)).ordinal();\n                break;\n            } else if(chr == ')') {\n                break;\n            }\n\n            switch(chr) {\n                case '-':\n                    nextOperations.add(Operator.Not);\n                    break;\n                case '*':\n                    nextOperations.add(Operator.And);\n                    break;\n                case '+':\n                    nextOperations.add(Operator.Or);\n                    break;\n                case 'P':\n                case 'Q':\n                case 'R':\n                case '0':\n                case '1':\n                case '2':\n                    {\n                        int val;\n                        switch(chr) {\n                            case 'P':\n                                val = pattern.P.ordinal();\n                                break;\n                            case 'Q':\n                                val = pattern.Q.ordinal();\n                                break;\n                            case 'R':\n                                val = pattern.R.ordinal();\n                                break;\n                            default:\n                                val = Integer.parseInt(String.valueOf(chr));\n                                break;\n                        }\n                        for(Operator opr : nextOperations) {\n                            switch(opr) {\n                                case And:\n                                    /*\n                                    if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else if(previousValue == Logic.True.ordinal())\n                                        if(val != Logic.True.ordinal())\n                                            val = Logic.False.ordinal();\n                                    else if(previousValue == Logic.False.ordinal())\n                                            if(val != Logic.False.ordinal())\n                                                val = Logic.True.ordinal();\n                                    */\n                                    if(previousValue == val)\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    break;\n                                case Or:\n                                    /*\n                                    if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    */\n                                    if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    break;\n                                case Not:\n                                    if(val == Logic.True.ordinal())\n                                        val = Logic.False.ordinal();\n                                    else if(val == Logic.False.ordinal())\n                                        val = Logic.True.ordinal();\n                                    break;\n                            }\n                        }\n                        nextOperations.clear();\n                        {\n                            previousValue = val;\n                        }\n                    }\n                    break;\n            }\n\n        }\n\n        return Logic.values()[ previousValue ];\n    }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\tsb.delete(i, i + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegRemove(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegate(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tcalc(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tremoveNest(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.printf(\"p,q,r = %d %d %d -> %s\\n\", p, q,\n\t\t\t\t\t\t// r,\n\t\t\t\t\t\t// f.toString());\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * How can I satisfy thee? Let me count the ways...\n */\npublic class Main {\n\n\tstatic enum OP {NOT, AND, OR}\n\n\tstatic enum VALUE {FALSE, UNK, TRUE}\n\n\tstatic VALUE[] TableNot = new VALUE[]{\n\t\t\tVALUE.TRUE, VALUE.UNK, VALUE.FALSE\n\t};\n\tstatic VALUE[][] TableAnd = new VALUE[][]{\n\t\t\t{VALUE.FALSE, VALUE.FALSE, VALUE.FALSE},\n\t\t\t{VALUE.FALSE, VALUE.UNK, VALUE.UNK},\n\t\t\t{VALUE.FALSE, VALUE.UNK, VALUE.TRUE},\n\t};\n\tstatic VALUE[][] TableOr = new VALUE[][]{\n\t\t\t{VALUE.FALSE, VALUE.UNK, VALUE.TRUE},\n\t\t\t{VALUE.UNK, VALUE.UNK, VALUE.TRUE},\n\t\t\t{VALUE.TRUE, VALUE.TRUE, VALUE.TRUE},\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.equals(\".\")) break;\n\n\t\t\t//parse\n\t\t\tVar var = main.new Var();\n\t\t\tExp exp = null;\n\n\t\t\tDeque<OP> ops = new ArrayDeque<>();\n\t\t\tDeque<Exp> exps = new ArrayDeque<>();\n\t\t\tDeque<Character> signs = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < line.length(); i++) {\n\n\t\t\t\tchar c = line.charAt(i);\n\t\t\t\tboolean mono = false;\n\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')': {\n\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\tExp s = exps.pollLast();\n\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\texps.add(main.new Exp(op, f, s));\n\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\tmono = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tops.add(OP.AND);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tops.add(OP.OR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tops.add(OP.NOT);\n\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\texps.add(main.new Exp(c, var));\n\t\t\t\t\t\tmono = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//monominal?\n\t\t\t\tif (signs.peekLast() != null && mono) {\n\t\t\t\t\twhile (signs.peekLast() != null && signs.peekLast() == '-') {\n\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\texps.add(main.new Exp(op, f));\n\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//solve\n\t\t\texp = exps.poll();\n//\t\t\tSystem.out.println(exp.toString());\n\n\t\t\tint count = 0;\n\t\t\tfor (VALUE p : VALUE.values()) {\n\t\t\t\tfor (VALUE q : VALUE.values()) {\n\t\t\t\t\tfor (VALUE r : VALUE.values()) {\n\t\t\t\t\t\tvar.substitution(p, q, r);\n\t\t\t\t\t\tif (exp.eval().equals(VALUE.TRUE)) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}//end while\n\t} //end main\n\n\tclass Var {\n\n\t\tVALUE P, Q, R;\n\n\t\tvoid substitution(VALUE P, VALUE Q, VALUE R) {\n\t\t\tthis.P = P;\n\t\t\tthis.Q = Q;\n\t\t\tthis.R = R;\n\t\t}\n\n\t\tVALUE eval(char name) {\n\t\t\tVALUE ret = VALUE.FALSE;\n\t\t\tswitch (name) {\n\t\t\t\tcase '0':\n\t\t\t\t\tret = VALUE.FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tret = VALUE.UNK;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tret = VALUE.TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tret = P;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Q':\n\t\t\t\t\tret = Q;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tret = R;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclass Exp {\n\n\t\tOP op;\n\t\tExp f, s;\n\t\tchar name;\n\t\tVar var;\n\n\t\tExp(OP op, Exp f, Exp s) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = f;//first term\n\t\t\tthis.s = s;//second term\n\t\t}\n\n\t\tExp(OP op, Exp F) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = F;\n\t\t}\n\n\t\tExp(char name, Var var) {\n\t\t\tthis.name = name;\n\t\t\tthis.var = var;\n\t\t}\n\n\t\tVALUE eval() {\n\t\t\tVALUE ret = VALUE.FALSE;\n\t\t\tif (var != null) {\n\t\t\t\tret = var.eval(name);\n\t\t\t} else {\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase NOT:\n\t\t\t\t\t\tret = TableNot[f.eval().ordinal()];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AND:\n\t\t\t\t\t\tret = TableAnd[f.eval().ordinal()][s.eval().ordinal()];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OR:\n\t\t\t\t\t\tret = TableOr[f.eval().ordinal()][s.eval().ordinal()];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString ret = \"\";\n\t\t\tif (var != null) {\n\t\t\t\tret += name;\n\t\t\t} else {\n\t\t\t\tif (op == OP.NOT) {\n\t\t\t\t\tret = \"-\" + f.toString();\n\t\t\t\t} else {\n\t\t\t\t\tString _op = \"\";\n\t\t\t\t\tswitch (op) {\n\t\t\t\t\t\tcase AND:\n\t\t\t\t\t\t\t_op = \"*\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase OR:\n\t\t\t\t\t\t\t_op = \"+\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tret = \"(\" + f.toString() + _op + s.toString() + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tchar[] c;\n\tint id;\n\t\n\tchar not(char x){\n\t\tif(x=='0') return '2';\n\t\telse if(x=='2') return '0';\n\t\telse return '1';\n\t}\n\t\n\tchar plus(char x, char y){\n\t\tif(x=='0' && y=='0') return '0';\n\t\telse if(x=='2' || y=='2') return '2';\n\t\telse return '1';\n\t}\n\t\n\tchar mul(char x, char y){\n\t\tif(x=='0' || y=='0') return '0';\n\t\telse if(x=='2' && y=='2') return '2';\n\t\telse return '1';\n\t}\n\t\n\tchar exp(){\n\t\tchar a = fact();\n\t\tid++;\n\t\tif(id<c.length){\n\t\t\tif(c[id]=='+'){\n\t\t\t\tid++;\n\t\t\t\ta = plus(a, exp());\n\t\t\t}else if(c[id]=='*'){\n\t\t\t\tid++;\n\t\t\t\ta = mul(a, exp());\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tchar fact(){\n\t\tchar b = c[id];\n\t\tif(b=='('){\n\t\t\tid++;\n\t\t\tb = exp();\n\t\t}else if(b=='-'){\n\t\t\tid++;\n\t\t\tb = not(fact());\n\t\t}\n\t\treturn b;\n\t}\n\t\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.compareTo(\".\")==0) break;\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tString t;\n\t\t\tfor(int p=48;p<51;p++){\n\t\t\t\tfor(int q=48;q<51;q++){\n\t\t\t\t\tfor(int r=48;r<51;r++){\n\t\t\t\t\t\tt = s;\n\t\t\t\t\t\tt = t.replaceAll(\"--\", \"\");\n\t\t\t\t\t\tt = t.replace('P', (char)p).replace('Q', (char)q).replace('R', (char)r);\n\t\t\t\t\t\tc = t.toCharArray();\n\t\t\t\t\t\t\n\t\t\t\t\t\tid = 0;\n\t\t\t\t\t\tif(exp()=='2') cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic char[] var;\n\tstatic int[] PQR;\n\tstatic int[] tuf = {0, 1, 2};// true, unknown, false\n\tstatic int idx;\n\tstatic int varCount;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tvarCount=idx=0;\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = new char[80];\n\t\t\tvar = new char[80];\n\t\t\tPQR=new int[3];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\tchar c = str.charAt(i);\n\t\t\t\tif(c == '-' || c == '*' || c == '+' || c == '(' || c == ')'){\n\t\t\t\t\ts[idx++]=c;\n\t\t\t\t}\n\t\t\t\telse if(c=='P'){\n\t\t\t\t\tvar[varCount++]=0;\n\t\t\t\t}\n\t\t\t\telse if(c=='Q'){\n\t\t\t\t\tvar[varCount++]=1;\n\t\t\t\t}\n\t\t\t\telse if(c=='R'){\n\t\t\t\t\tvar[varCount++]=2;\n\t\t\t\t}\n\t\t\t\telse if(c=='0'){\n\t\t\t\t\tvar[varCount++]=3;\n\t\t\t\t}\n\t\t\t\telse if(c=='1'){\n\t\t\t\t\tvar[varCount++]=4;\n\t\t\t\t}\n\t\t\t\telse if(c=='2'){\n\t\t\t\t\tvar[varCount++]=5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint count=0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tvarCount=idx=0;\n\t\t\t\t\t\tPQR[0]=tuf[i];\n\t\t\t\t\t\tPQR[1]=tuf[j];\n\t\t\t\t\t\tPQR[2]=tuf[k];\n\t\t\t\t\t\tif(expression()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\tres = or(res, expression());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres = and(res, term());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=expression();\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = not(fact());\n\t\t}\n\t\telse{\n\t\t\tres = variable();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int variable(){\n\t\tif(var[varCount]>=3){\n\t\t\treturn var[varCount++]-3;\n\t\t}\n\t\treturn PQR[var[varCount++]];\n\t}\n\tstatic int or(int x, int y){\n\t\tif(x <= 1 && y <= 1){\n\t\t\tif(x == 0 && y == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t}\n\tstatic int and(int x, int y){\n\t\tif(x >= 1 && y >= 1){\n\t\t\tif(x == 2 && y == 2){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic int not(int x){\n\t\tif(x ==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(x==1){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tchar[] c;\n\tint id;\n\tint[] var;\n\n\tint exp() {\n\t\tif ('0' <= c[id] && c[id] <= '2') {\n\t\t\treturn c[id++] - '0';\n\t\t} else if ('P' <= c[id] && c[id] <= 'R') {\n\t\t\treturn var[c[id++] - 'P'];\n\t\t} else if (c[id] == '-') {\n\t\t\tid++;\n\t\t\treturn not(exp());\n\t\t} else {\n\t\t\tid++;\n\t\t\tint res = exp();\n\t\t\tif (c[id] == '*') {\n\t\t\t\tid++;\n\t\t\t\tres = and(res, exp());\n\t\t\t} else {\n\t\t\t\tid++;\n\t\t\t\tres = or(res, exp());\n\t\t\t}\n\t\t\tid++;\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint and(int a, int b) {\n\t\tif (a == 0 || b == 0)\n\t\t\treturn 0;\n\t\tif (a == 2 && b == 2)\n\t\t\treturn 2;\n\t\treturn 1;\n\t}\n\n\tint or(int a, int b) {\n\t\tif (a == 0 && b == 0)\n\t\t\treturn 0;\n\t\tif (a == 2 || b == 2)\n\t\t\treturn 2;\n\t\treturn 1;\n\t}\n\n\tint not(int a) {\n\t\tif (a == 2)\n\t\t\treturn 0;\n\t\tif (a == 0)\n\t\t\treturn 2;\n\t\treturn 1;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tc = (sc.next()+\"=\").toCharArray();\n\t\t\tif (c[0] == '.') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar = new int[3];\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tvar[0] = i;\n\t\t\t\t\t\tvar[1] = j;\n\t\t\t\t\t\tvar[2] = k;\n\t\t\t\t\t\tid = 0;\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.print(\"(P, Q, R) = (\" + var[0] + \", \" + var[1] + \", \" + var[2] + \") -- \");\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(exp());\n\t\t\t\t\t\tcount += exp() == 2 ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] var = new int[3];\n\tstatic char[] str;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tstr = sc.next().toCharArray();\n\t\t\tif (str[0] == '.') break;\n\t\t\tpos = 0;\n\t\t\tFormula root = parse();\n\t\t\tint ans = 0;\n\t\t\tfor (var[0] = 0; var[0] < 3; ++var[0]) {\n\t\t\t\tfor (var[1] = 0; var[1] < 3; ++var[1]) {\n\t\t\t\t\tfor (var[2] = 0; var[2] < 3; ++var[2]) {\n\t\t\t\t\t\tif (root.eval() == 2) ++ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic Formula parse() {\n\t\tchar c = str[pos++];\n\t\tif ('0' <= c && c <= '2') return new Constant(c - '0');\n\t\tif ('P' <= c && c <= 'R') return new Var(c);\n\t\tif (c == '-') return new Not(parse());\n\t\tFormula l = parse();\n\t\tchar op = str[pos++];\n\t\tFormula r = parse();\n\t\tpos++;\n\t\tif (op == '*') {\n\t\t\treturn new And(l, r);\n\t\t} else {\n\t\t\treturn new Or(l, r);\n\t\t}\n\t}\n\n\tstatic abstract class Formula {\n\t\tabstract int eval();\n\t}\n\n\tstatic class Constant extends Formula {\n\t\tint v;\n\n\t\tConstant(int v) {\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tint eval() {\n\t\t\treturn this.v;\n\t\t}\n\t}\n\n\tstatic class Var extends Formula {\n\t\tint p;\n\n\t\tVar(char name) {\n\t\t\tif (name == 'P') {\n\t\t\t\tthis.p = 0;\n\t\t\t} else if (name == 'Q') {\n\t\t\t\tthis.p = 1;\n\t\t\t} else {\n\t\t\t\tthis.p = 2;\n\t\t\t}\n\t\t}\n\n\t\tint eval() {\n\t\t\treturn var[p];\n\t\t}\n\t}\n\n\tstatic class Not extends Formula {\n\t\tFormula f;\n\n\t\tNot(Formula f) {\n\t\t\tthis.f = f;\n\t\t}\n\n\t\tint eval() {\n\t\t\tint v = f.eval();\n\t\t\treturn v == 1 ? v : 2 - v;\n\t\t}\n\t}\n\n\tstatic class And extends Formula {\n\t\tFormula left, right;\n\n\t\tAnd(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tint eval() {\n\t\t\tint vl = left.eval();\n\t\t\tint vr = right.eval();\n\t\t\tif (vl == 0 || vr == 0) return 0;\n\t\t\tif (vl == 1 || vr == 1) return 1;\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tstatic class Or extends Formula {\n\t\tFormula left, right;\n\n\t\tOr(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tint eval() {\n\t\t\tint vl = left.eval();\n\t\t\tint vr = right.eval();\n\t\t\tif (vl == 2 || vr == 2) return 2;\n\t\t\tif (vl == 1 || vr == 1) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*; \n \npublic class Main\n{\n\tpublic static void main(String args[]) throws Exception{\n\t\tnew Main().run();\n\t}\n\t\n\tpublic void run()\n\t{\n\t\tint i,j,k;\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString s = cin.nextLine();\n\t\t\tif(s.equals(\".\")) break;\n\t\t\tint count = 0;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\tfor(k=0;k<3;k++){\n\t\t\t\t\t\tString ss = s;\n\t\t\t\t\t\tss = ss.replace(\"P\", i + \"\");\n\t\t\t\t\t\tss = ss.replace(\"Q\", j + \"\");\n\t\t\t\t\t\tss = ss.replace(\"R\", k + \"\");\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tss = ss.replace(\"-0\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"-1\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"-2\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0+0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0+1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0+2)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1+0)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1+1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1+2)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2+0)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2+1)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2+2)\", \"2\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tss = ss.replace(\"(0*0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0*1)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0*2)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1*0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1*1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1*2)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2*0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2*1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2*2)\", \"2\");\n\t\t\t\t\t\t\tif(ss.length()==1) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ss.equals(\"2\")){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint p,q,r,pos;\n\tString str;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tstr = in.next();\n\t\t\tif(str.equals(\".\")) return ;\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint formula(){\n\t\tchar c = str.charAt(pos);\n\t\tpos++;\n\t\tif(c=='0') return 0;\n\t\tif(c=='1') return 1;\n\t\tif(c=='2') return 2;\n\t\tif(c=='P') return p;\n\t\tif(c=='Q') return q;\n\t\tif(c=='R') return r;\n\t\tif(c=='-'){\n\t\t\tint a = formula();\n\t\t\treturn 2-a;\n\t\t}\n\t\tif(c=='('){\n\t\t\tint a = formula();\n\t\t\tboolean multi = str.charAt(pos)=='*';\n\t\t\tpos++;\n\t\t\tint b = formula();\n\t\t\tpos++;\n\t\t\tif(multi){\n\t\t\t\tif(a==0||b==0) return 0;\n\t\t\t\tif(a==2&&b==2) return 2;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a==2||b==2) return 2;\n\t\t\t\tif(a==0&&b==0) return 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint solve(){\n\t\tint ans = 0;\n\t\tfor(p=0;p<3;p++){\n\t\t\tfor(q=0;q<3;q++){\n\t\t\t\tfor(r=0;r<3;r++){\n\t\t\t\t\tpos=0;\n\t\t\t\t\tif(formula() == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.charAt(0) == '.')\n\t\t\t\tbreak;\n\t\t\tsolve(s);\n\t\t}\n\t}\n\n\tpublic void solve(String s) {\n\t\tint res = 0;\n\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\tcur = 0;\n\t\t\t\t\tfomula = s.replaceAll(\"P\", p + \"\")\n\t\t\t\t\t\t\t.replaceAll(\"Q\", q + \"\").replaceAll(\"R\", r + \"\");\n\t\t\t\t\tint v = scan();\n\t\t\t\t\tif (v == 2){\n//\t\t\t\t\t\tSystem.out.println(fomula);\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tString fomula;\n\tint cur = 0;\n\n\tprivate int scan() {\n\t\tint v = -1;\n\t\tchar c = next();\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\tv = c - '0';\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tv = 2 - scan();\n\t\t\tbreak;\n\t\t\n\t\tcase '(':\n\t\t\tv = op();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn v;\n\n\t}\n\n\tprivate int op() {\n\t\tint v = scan();\n\t\tchar c = next();\n\t\tswitch(c){\n\t\tcase '+':\n\t\t\tv = Math.max(v, scan());\n\t\t\tbreak;\n\t\t\t\n\t\tcase '*':\n\t\t\tv = Math.min(v, scan());\n\t\t\tbreak;\n\t\t}\n\t\tnext();\n\t\treturn v;\n\t}\n\n\tprivate char next() {\n\t\tchar c = fomula.charAt(cur);\n\t\tcur++;\n\t\treturn c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tint past = sb.length() + 10, now;\n\t\twhile (true) {\n\t\t\tnow = sb.length();\n\t\t\tif (past == now) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\t\tsb.delete(i, i + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpast = now;\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\tSystem.out.printf(\"p q r = %d %d %d\\n\", p, q, r);\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\n\t\t\t\t\t\t\tnegRemove(f);\n\n\t\t\t\t\t\t\tnegate(f);\n\n\t\t\t\t\t\t\tcalc(f);\n\n\t\t\t\t\t\t\tremoveNest(f);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    while(true){\n      String s = sc.next();\n      if(s.equals(\".\")){\n        break;\n      }\n\n      int cnt = 0;\n      for(int P=0;P<3;P++){\n        for(int Q=0;Q<3;Q++){\n          for(int R=0;R<3;R++){\n            String p = \"\" + P;\n            String q = \"\" + Q;\n            String r = \"\" + R;\n            String ss = s.replaceAll(\"P\",p).replaceAll(\"Q\",q).replaceAll(\"R\",r);\n\n            while(ss.length() != 1){\n              ss = ss.replaceAll(\"\\\\-0\",\"2\");\n              ss = ss.replaceAll(\"\\\\-1\",\"1\");\n              ss = ss.replaceAll(\"\\\\-2\",\"0\");\n\n              ss = ss.replaceAll(\"(\\\\(0\\\\*0\\\\))|(\\\\(0\\\\*1\\\\))|(\\\\(0\\\\*2\\\\))|(\\\\(1\\\\*0\\\\))|(\\\\(2\\\\*0\\\\))\",\"0\");\n              ss = ss.replaceAll(\"(\\\\(1\\\\*1\\\\))|(\\\\(1\\\\*2\\\\))|(\\\\(2\\\\*1\\\\))\",\"1\");\n              ss = ss.replaceAll(\"(\\\\(2\\\\*2\\\\))\",\"2\");\n\n              ss = ss.replaceAll(\"(\\\\(0\\\\+2\\\\))|(\\\\(1\\\\+2\\\\))|(\\\\(2\\\\+2\\\\))|(\\\\(2\\\\+1\\\\))|(\\\\(2\\\\+0\\\\))\",\"2\");\n              ss = ss.replaceAll(\"(\\\\(0\\\\+1\\\\))|(\\\\(1\\\\+1\\\\))|(\\\\(1\\\\+0\\\\))\",\"1\");\n              ss = ss.replaceAll(\"(\\\\(0\\\\+0\\\\))\",\"0\");\n            }\n\n            if(ss.equals(\"2\")){\n              cnt++;\n            }\n          }\n        }\n      }\n\n      System.out.println(cnt);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tchar[] s;//原文\n\tint index;//今なん文字目か\n\tint[] table;//PQRの値\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str=sc.next();\n\t\t\tif(str.equals(\".\")) break;\n\t\t\t//s=(str+\"$\").toCharArray();\n\t\t\ts=str.toCharArray();\n\t\t\ttable=new int[3];\n\t\t\tint ans=0;\n\t\t\tfor(int p=0; p<3; p++){\n\t\t\t\ttable[0]=p;\n\t\t\t\tfor(int q=0; q<3; q++){\n\t\t\t\t\ttable[1]=q;\n\t\t\t\t\tfor(int r=0; r<3; r++){\n\t\t\t\t\t\ttable[2]=r;\n\t\t\t\t\t\tindex=0;\n\t\t\t\t\t\tif(formura()==2) ans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tint formura(){\n\t\tint r=term();\n\t\twhile(index < s.length){\n\t\t\tchar c = c();\n\t\t\tif(c == '*'){\n\t\t\t\tint a = term();\n\t\t\t\tr = Math.min(r, a);\n\t\t\t}\n\t\t\telse if(c == '+'){\n\t\t\t\tint a = term();\n\t\t\t\tr = Math.max(r, a);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn r;\n\t}\n\tint term(){\n\t\tchar c=c();\n\t\tif(c=='('){\n\t\t\tint r=formura();\n\t\t\treturn r;\n\t\t}\n\t\tif(c=='-'){\n\t\t\tint r=term();\n\t\t\tif(r==2){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(r==1){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(r==0){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t\tif(Character.isDigit(c)) return c-'0';\n\t\tif(c=='P'){\n\t\t\treturn table[0];\n\t\t}\n\t\telse if(c=='Q'){\n\t\t\treturn table[1];\n\t\t}\n\t\telse if(c=='R'){\n\t\t\treturn table[2];\n\t\t}\n\t\treturn -1;\n\t}\n\tchar c(){\n\t\treturn s[index++];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\tpublic static interface Fomula{\n\t\tint eval(int[] input);\n\t}\n\t\n\tpublic static class Minus implements Fomula{\n\t\tFomula inner;\n\t\t\n\t\tpublic Minus(Fomula in){\n\t\t\tinner = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn 2 - inner.eval(input);\n\t\t}\n\t}\n\t\n\tpublic static class Add implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Add(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.max(left.eval(input), right.eval(input));\n\t\t}\n\t}\n\t\n\tpublic static class Mul implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Mul(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.min(left.eval(input), right.eval(input));\n\t\t}\n\t}\n\t\n\tpublic static class Const implements Fomula{\n\t\tint con;\n\t\t\n\t\tpublic Const(int con){\n\t\t\tthis.con = con;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn con;\n\t\t}\n\t}\n\t\n\tpublic static class Var implements Fomula{\n\t\tint var;\n\t\t\n\t\tpublic Var(int v){\n\t\t\tvar = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn input[var];\n\t\t}\n\t}\n\t\n\tpublic static Fomula parse(char[] input, int start, int end){\n\t\tint k_lv = 0;\n\t\tint k_s = -1, k_e = -1;\n\t\tint m_s = -1;\n\t\tint a_p = -1, m_p = -1;\n\t\t\n\t\tfor(int pos = start; pos <= end; pos++){\n\t\t\tif(input[pos] == '('){\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_s = pos;\n\t\t\t\t}\n\t\t\t\tk_lv++;\n\t\t\t}else if(input[pos] == ')'){\n\t\t\t\tk_lv--;\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_e = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(input[pos] == '-' && k_lv == 0){\n\t\t\t\tm_s = pos;\n\t\t\t}else if(input[pos] == '*' && k_lv == 1){\n\t\t\t\tm_p = pos;\n\t\t\t}else if(input[pos] == '+' && k_lv == 1){\n\t\t\t\ta_p = pos;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(k_s != -1 && k_e != -1){\n\t\t\tif(m_p != -1){\n\t\t\t\treturn new Mul(parse(input, k_s + 1, m_p - 1), parse(input, m_p + 1, k_e - 1));\n\t\t\t}else{\n\t\t\t\treturn new Add(parse(input, k_s + 1, a_p - 1), parse(input, a_p + 1, k_e - 1));\n\t\t\t}\n\t\t}else if(m_s != -1){\n\t\t\treturn new Minus(parse(input, m_s + 1, end));\n\t\t}else if('0' <= input[start] && input[start] <= '2'){\n\t\t\treturn new Const(input[start] - '0');\n\t\t}else {\n\t\t\treturn new Var(input[start] - 'P');\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\t\n\t\t\tif(\".\".equals(str)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tchar[] input = str.toCharArray();\n\t\t\t\n\t\t\tFomula fomula = parse(input, 0, input.length - 1);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tint[] array = new int[3];\n\t\t\tfor(int p = 0; p <= 2; p++){\n\t\t\t\tarray[0] = p;\n\t\t\t\t\n\t\t\t\tfor(int q = 0; q <= 2; q++){\n\t\t\t\t\tarray[1] = q;\n\t\t\t\t\t\n\t\t\t\t\tfor(int r = 0; r <= 2; r++){\n\t\t\t\t\t\tarray[2] = r;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(fomula.eval(array) == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ5\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\n\t//AOJ1155\n\tString str;\n\tchar p,q,r;\n\tint ind;\n\t//AOJ1155\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ1155();\n\t}\n\tvoid AOJ1155(){\n\t\twhile(true){\n\t\t\t str = sc.next();\n\t\t\t \n\t\t\t if(str.equals(\".\")){\n\t\t\t\t break;\n\t\t\t }\n\t\t\t ind = 0;\n\t\t\t int count  = 0;\n\t\t\t for(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tp = (char) (i + '0');\n\t\t\t\t\t\tq = (char) (j + '0');\n\t\t\t\t\t\tr = (char) (k + '0');\n\t\t\t\t\t\tchar res = formula();\n\t\t\t\t\t\tif(res == '2'){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tind = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t }\n\t\t\t System.out.println(count);\n\t\t}\n\t}\n\t\n\tprivate char formula() {\n\t\tchar now = str.charAt(ind++);\n\t\tif(now == '-'){\n\t\t\treturn rev(formula());\n\t\t}\n\t\telse if(now == '('){\n\t\t\tchar temp1 = formula();\n\t\t\tchar temp2 = str.charAt(ind++);\n\t\t\tchar temp3 = formula();\n\t\t\tstr.charAt(ind++);\n\t\t\tif(temp2 == '+'){\n\t\t\t\treturn add(temp1, temp3);\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn mul(temp1, temp3);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(now == 'P'){\n\t\t\treturn p;\n\t\t}\n\t\telse if(now == 'Q'){\n\t\t\treturn q;\n\t\t}\n\t\telse if(now == 'R'){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn now;\n\t\t}\n\t}\n\tprivate char mul(char c1, char c2) {\n\t\tint t1 = c1 - '0';\n\t\tint t2 = c2 - '0';\n\t\tint t3 = Math.min(t1, t2);\n\t\tchar ans = (char) (t3 + '0');\n\t\treturn ans;\n\t}\n\tprivate char add(char c1, char c2) {\n\t\tint t1 = c1 - '0';\n\t\tint t2 = c2 - '0';\n\t\tint t3 = Math.max(t1, t2);\n\t\tchar ans = (char) (t3 + '0');\n\t\treturn ans;\n\t}\n\tprivate char rev(char c) {\n\t\tswitch (c){\n\t\tcase '0': return '2';\n\t\tcase '1': return '1';\n\t\tcase '2': return '0';\n\t\t}\n\t\treturn '0';\n\t}\n\t\n\t\n\tvoid AOJ1156(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tint[] c=new int[4];\n\t\t\tfor(int i=0; i<4; i++)\tc[i]=sc.nextInt();\n\t\t\tLinkedList<C1156> open=new LinkedList<C1156>();\n\t\t\tint[][][] close=new int[W][H][4];\t// [x][y][v]\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int k=0; k<4; k++)\tclose[i][j][k]=Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1156(0,0,1,0));\n\t\t\tclose[0][0][1]=0;\n\t\t\tint ans=Integer.MAX_VALUE;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1156 now=open.poll();\n\t\t\t\tfor(int i=0; i<=4; i++){\n\t\t\t\t\tif(i==b[now.x][now.y])\tcontinue;\n\t\t\t\t\tC1156 temp=m(now,(i<4?i:b[now.x][now.y]));\n\t\t\t\t\tif(temp==null)\tcontinue;\n\t\t\t\t\tif(!Point.ok(temp.x, temp.y, W, H))\tcontinue;\n\t\t\t\t\ttemp.cost+=(i<4?c[i]:0);\n\t\t\t\t\tif(temp.x==W-1 && temp.y==H-1){\n\t\t\t\t\t\tans=min(ans,now.cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(close[temp.x][temp.y][temp.v]<temp.cost)\tcontinue;\n\t\t\t\t\topen.add(temp);\n\t\t\t\t\tclose[temp.x][temp.y][temp.v]=temp.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tC1156 m(C1156 c1156,int m){\n\t\tC1156 now=new C1156(c1156);\n\t\tif(m==4)\treturn null;\n\t\telse\tnow.v=4%(now.v+m);\n\t\t/*\n\t\telse if(m==1)\t;\t// 右折\n\t\telse if(m==2)\tnow.v=4%(now.v+2);\t// 反転\n\t\telse if(m==3)\tnow.v=4%(now.v+3);\t// 左折\n\t\t\tnow.v=(now.v>0?now.v-1:3);\n\t\t}else\treturn null;\n\t\t*/\n\t\tnow.x+=vx[now.v];\tnow.y+=vy[now.v];\n\t\treturn now;\n\t}\n\t// v: 0=上 1=右 2=下 3=左\n\tclass C1156 implements Comparable<C1156>{\n\t\tint x,y,v,cost;\n\t\tC1156(int x,int y,int v,int cost){this.x=x; this.y=y; this.v=v; this.cost=cost;}\n\t\tC1156(C1156 a){this.x=a.x; this.y=a.y; this.v=a.v; this.cost=a.cost;}\n\t\t@Override\n\t\tpublic int compareTo(C1156 o) {\n\t\t\tif(this.cost<o.cost)\treturn -1;\n\t\t\tif(this.cost>o.cost)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1154(){\n\t\tfinal int MAX=300000;\n\t\tboolean[] list=list(MAX);\n\t\t//debug\n\t\t//for(int i=6; i<=MAX; i++)\tif(list[i])\tout.print(\" \"+i);\n\t\t//out.println();\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==1)\tbreak;\n\t\t\tout.print(n+\":\");\n\t\t\tfor(int i=6; i<=n; i+=7){\n\t\t\t\tif(list[i] && n%i==0)\tout.print(\" \"+i);\n\t\t\t\tif(list[i+2] && n%(i+2)==0)\tout.print(\" \"+(i+2));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\tboolean[] list(int MAX){\n\t\tboolean[] b=new boolean[MAX+1];\n\t\tArrays.fill(b, false);\n\t\tfor(int i=6; i<=MAX; i+=7){\n\t\t\tb[i]=true;\tb[i+2]=true;\n\t\t}\n\t\tfor(int i=6; i<=MAX; i+=7){\n\t\t\tif(b[i])\tfor(int j=i+i; j<=MAX; j+=(i))\tb[j]=false;\n\t\t\tif(b[i+2])\tfor(int j=i+i+4; j<=MAX; j+=(i+2))\tb[j]=false;\n\t\t}\n\t\treturn b;\n\t}\n\t\n\tvoid A(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint [] taro = new int[n];\n\t\t\tint [] hanako = new int[m];\n\t\t\tint sum1 = 0,sum2 = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ttaro[i] = sc.nextInt();\n\t\t\t\tsum1 += taro[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < m ;i++){\n\t\t\t\thanako[i] = sc.nextInt();\n\t\t\t\tsum2 += hanako[i];\n\t\t\t}\n\t\t\tArrays.sort(taro);\n\t\t\tArrays.sort(hanako);\n\t\t\tboolean flg = true;\n\t\t\tfor(int i =0; i < n ;i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tint temp1 = sum1 - taro[i] + hanako[j];\n\t\t\t\t\tint temp2 = sum2 - hanako[j] + taro[i];\n\t\t\t\t\tif(temp1 ==  temp2){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tSystem.out.println(taro[i] + \" \" + hanako[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tif(! flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().start();\n\t}\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tString s = in.nextLine();\n\t\t\tif(s.equals(\".\"))break;\n\t\t\tint count = 0;\n\t\t\tfor(int p = 0; p < 3; p++){\n\t\t\t\tfor(int q = 0; q < 3; q++){\n\t\t\t\t\tfor(int r = 0; r < 3; r++){\n\t\t\t\t\t\tn = 0;\n\t\t\t\t\t\tint value = formula(s, p, q, r);\n\t\t\t\t\t\tif(value == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tint n = 0;\n\tint formula(String s, int p, int q, int r){\n\t\tif(s.charAt(n) == '('){\n\t\t\tchar operand = ' ';\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\twhile(true){\n\t\t\t\tn++;\n\t\t\t\tchar next = s.charAt(n);\n\t\t\t\tif(next == ')')break;\n\t\t\t\telse if(next == '('){\n\t\t\t\t\tstack.push(formula(s, p, q, r));\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\telse if(next == '+' || next == '*')operand = next;\n\t\t\t\telse if(next == '-'){\n\t\t\t\t\tn++;\n\t\t\t\t\tstack.push(not(formula(s, p, q, r)));\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar c = s.charAt(n);\n\t\t\t\t\tif(c == '0' || c == '1' || c == '2'){\n\t\t\t\t\t\tint result = Integer.parseInt(\"\"+s.charAt(n));\n\t\t\t\t\t\tstack.push(result);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(c == 'R')stack.push(r);\n\t\t\t\t\t\telse if(c == 'Q')stack.push(q);\n\t\t\t\t\t\telse stack.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++;\n\t\t\tint a = stack.pop();\n\t\t\tint b = stack.pop();\n\t\t\tint result = 0;\n\t\t\tif(operand == '+')result = or(a,b);\n\t\t\telse result = and(a,b);\n\t\t\treturn result;\n\t\t}else if(s.charAt(n) == '-'){\n\t\t\tn++;\n\t\t\tint a = not(formula(s, p, q, r));\n\t\t\treturn a;\n\t\t}else{\n\t\t\tchar c = s.charAt(n);\n\t\t\tif(c == '0' || c == '1' || c == '2'){\n\t\t\t\tint result = Integer.parseInt(\"\"+s.charAt(n));\n\t\t\t\tn++;\n\t\t\t\treturn result;\n\t\t\t}else{\n\t\t\t\tn++;\n\t\t\t\tif(c == 'R')return r;\n\t\t\t\telse if(c == 'Q')return q;\n\t\t\t\telse return p;\n\t\t\t}\n\t\t}\n\t}\n\tint not(int a){\n\t\tif(a == 0){\n\t\t\treturn  2;\n\t\t}else if(a == 1){\n\t\t\treturn  1;\n\t\t}else{\n\t\t\treturn  0;\n\t\t}\n\t}\n\tint and(int a, int b){\n\t\tif(a == 0 || b == 0){\n\t\t\treturn  0;\n\t\t}else if(a == 1 || b == 1){\n\t\t\treturn  1;\n\t\t}else{\n\t\t\treturn  2;\n\t\t}\n\t}\n\tint or(int a, int b){\n\t\tif(a == 0 && b == 0){\n\t\t\treturn  0;\n\t\t}else if(a == 2 || b == 2){\n\t\t\treturn  2;\n\t\t}else{\n\t\t\treturn  1;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint p,q,r;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString s = sc.next() + \"#\";\n\t\t\tif(s.equals(\".#\")) break;\n\t\t\t p = 0;\n\t\t\t q = 0;\n\t\t\t r = 0;\n\t\t\t int count = 0;\n\t\t\t \n\t\t\t for(p = 0; p < 3; p++){\n\t\t\t\t for(q = 0; q < 3; q++){\n\t\t\t\t\t for(r = 0; r < 3; r++){\n\t\t\t\t\t\t int res = new Parse(s + \"\", 0).exp();\n\t\t\t\t\t\t if(res == 2){\n\t\t\t\t\t\t\t count++;\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t }\n\t\t\t System.out.println(count);\n\t\t}\n\t\t\n\t}\n\t\n\tclass Parse{\n\t\tString str;\n\t\tint pos;\n\t\t\n\t\tpublic Parse(String str, int pos) {\n\t\t\tthis.str = str;\n\t\t\tthis.pos = pos;\n\t\t}\n\n\n\t\tprivate int exp() {\n\t\t\tint res = fact();\n\t\t\twhile(true){\n\t\t\t\tchar op = str.charAt(pos);\n\t\t\t\tif((op == '+') || (op == '*')){\n\t\t\t\t\tint old = res;\n\t\t\t\t\tpos++;\n\t\t\t\t\tres = fact();\n\t\t\t\t\tswitch(op){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tres = Math.max(old, res);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tres = Math.min(old, res);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\n\t\tprivate int fact() {\n\t\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\t\tint t = str.charAt(pos) - '0';\n\t\t\t\tpos++;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\telse if(str.charAt(pos) == '('){\n\t\t\t\tpos++;\n\t\t\t\tint res = exp();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\telse if(str.charAt(pos) == '-'){\n\t\t\t\tpos++;\n\t\t\t\tint res = fact();\n\t\t\t\tif(res == 0){\n\t\t\t\t\tres = 2;\n\t\t\t\t}\n\t\t\t\telse if(res == 1){\n\t\t\t\t\tres  = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tres = 0;\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\telse if(str.charAt(pos) == 'P'){\n\t\t\t\tpos++;\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\telse if(str.charAt(pos) == 'Q'){\n\t\t\t\tpos++;\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\telse if(str.charAt(pos) == 'R'){\n\t\t\t\tpos++;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\t//dead code\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tString s = ir.next();\n\t\t\tif (s.charAt(0) == '.')\n\t\t\t\treturn;\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tString t = s.replace(\"P\", String.valueOf(i)).replace(\"Q\", String.valueOf(j)).replace(\"R\",\n\t\t\t\t\t\t\t\tString.valueOf(k));\n\t\t\t\t\t\tif (calc(t) == 2)\n\t\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ret);\n\t\t}\n\t}\n\n\tstatic int calc(String s) {\n\t\tif (s.charAt(0) != '(')\n\t\t\treturn convert(s);\n\t\telse {\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tif (s.charAt(i) == '(')\n\t\t\t\t\td++;\n\t\t\t\telse if (s.charAt(i) == ')')\n\t\t\t\t\td--;\n\t\t\t\telse if (d == 1 && (s.charAt(i) == '+' || s.charAt(i) == '*')) {\n\t\t\t\t\tif (s.charAt(i) == '+')\n\t\t\t\t\t\treturn Math.max(calc(s.substring(1, i)), calc(s.substring(i + 1, s.length() - 1)));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn Math.min(calc(s.substring(1, i)), calc(s.substring(i + 1, s.length() - 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic int convert(String s) {\n\t\tint p = 0;\n\t\twhile (p < s.length() && s.charAt(p) == '-')\n\t\t\tp++;\n\t\tif (s.length() - p == 1) {\n\t\t\tint a = Integer.parseInt(s.substring(s.length() - 1));\n\t\t\tif (a == 1)\n\t\t\t\treturn 1;\n\t\t\tif (s.length() % 2 == 0)\n\t\t\t\treturn (a + 2) % 4;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t} else {\n\t\t\tint a = calc(s.substring(p));\n\t\t\tif (a == 1)\n\t\t\t\treturn 1;\n\t\t\tif (p % 2 == 1)\n\t\t\t\treturn (a + 2) % 4;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tString s = ir.next();\n\t\t\tif (s.charAt(0) == '.')\n\t\t\t\treturn;\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tString t = s.replace(\"P\", String.valueOf(i)).replace(\"Q\", String.valueOf(j)).replace(\"R\",\n\t\t\t\t\t\t\t\tString.valueOf(k));\n\t\t\t\t\t\tif (calc(t) == 2)\n\t\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ret);\n\t\t}\n\t}\n\n\tstatic int calc(String s) {\n\t\tif (s.charAt(0) != '(')\n\t\t\treturn convert(s);\n\t\telse {\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tif (s.charAt(i) == '(')\n\t\t\t\t\td++;\n\t\t\t\telse if (s.charAt(i) == ')')\n\t\t\t\t\td--;\n\t\t\t\telse if (d == 1 && (s.charAt(i) == '+' || s.charAt(i) == '*')) {\n\t\t\t\t\tif (s.charAt(i) == '+')\n\t\t\t\t\t\treturn Math.max(calc(s.substring(1, i)), calc(s.substring(i + 1, s.length() - 1)));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn Math.min(calc(s.substring(1, i)), calc(s.substring(i + 1, s.length() - 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic int convert(String s) {\n\t\tint a = Integer.parseInt(s.substring(s.length() - 1));\n\t\tif (a == 1)\n\t\t\treturn 1;\n\t\tif (s.length() % 2 == 0)\n\t\t\treturn (a + 2) % 4;\n\t\telse\n\t\t\treturn a;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1155();\n\t}\n\t\n\tclass AOJ1155{\n\t\tAOJ1155(){\n\t\t\twhile(true){\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\".\"))\tbreak;\n\t\t\t\tsolve(str);\n\t\t\t}\n\t\t}\n\t\tvoid solve(String str){\n\t\t\tint cnt=0;\n\t\t\tstr+=\"#\";\n\t\t\tfor(int p=0; p<=2; ++p)for(int q=0; q<=2; ++q)for(int r=0; r<=2; ++r){\n\t\t\t\tString tmp=str.replaceAll(\"P\", \"\"+p).replaceAll(\"Q\", \"\"+q).replaceAll(\"R\", \"\"+r);\n//\t\t\t\tSystem.out.println(tmp);\n\t\t\t\tthis.line=tmp.toCharArray();\n\t\t\t\tthis.pos=0;\n\t\t\t\tint ret=expr();\n//\t\t\t\tSystem.out.println(ret);\n\t\t\t\tcnt += (ret==2?1:0);\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tfinal int[][]\tand={{0,0,0},{0,1,1},{0,1,2}},\n\t\t\t\tor={{0,1,2},{1,1,2},{2,2,2}};\n\t\tfinal int[] m={2,1,0};\n\t\tchar[] line;\n\t\tint pos=0;\n\t\tprivate int expr(){\n\t\t\tint ret=term();\n\t\t\twhile(true){\n\t\t\t\tchar op=line[pos];\n\t\t\t\tif( op=='+' ){\n\t\t\t\t\tint old=ret;\n\t\t\t\t\t++pos;\n\t\t\t\t\tret=term();\n\t\t\t\t\tret=or[old][ret];\n//\t\t\t\t\tSystem.out.println(old+\"+\"+ret+\" = \"+or[old][ret]);\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tprivate int term(){\n\t\t\tint ret=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line[pos];\n\t\t\t\tif( op=='*' ){\n\t\t\t\t\tint old=ret;\n\t\t\t\t\t++pos;\n\t\t\t\t\tret=fact();\n\t\t\t\t\tret=and[old][ret];\n//\t\t\t\t\tSystem.out.println(old+\"*\"+ret+\" = \"+and[old][ret]);\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tprivate int fact(){\n\t\t\tif(line[pos]=='-'){\n\t\t\t\t++pos;\n\t\t\t\treturn m[fact()];\n\t\t\t}else if(Character.isDigit(line[pos])){\n\t\t\t\tint ret=line[pos]-'0';\n\t\t\t\t++pos;\n\t\t\t\treturn ret;\n\t\t\t}else if(line[pos]=='('){\n\t\t\t\t++pos;\n\t\t\t\tint ret=expr();\n\t\t\t\t++pos;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tclass AOJ1153{\n\t\tAOJ1153(){\n\t\t\twhile(true){\n\t\t\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\t\t\tif((n|m)==0)\tbreak;\n\t\t\t\tsolve(n,m);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int n,int m){\n\t\t\tint[] nn=new int[n],\n\t\t\t\t\tmm=new int[m];\n\t\t\tint ns=0, ms=0;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tnn[i]=sc.nextInt();\n\t\t\t\tns+=nn[i];\n\t\t\t}\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tmm[i]=sc.nextInt();\n\t\t\t\tms+=mm[i];\n\t\t\t}\n\t\t\tArrays.sort(nn);\n\t\t\tArrays.sort(mm);\n\t\t\tint cand1=-1,cand2=-1,sum=Integer.MAX_VALUE/4;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfor(int j=0; j<m; ++j){\n\t\t\t\t\tif(ns-nn[i]+mm[j] == ms-mm[j]+nn[i] && sum>nn[i]+mm[j]){\n\t\t\t\t\t\tcand1=i;\n\t\t\t\t\t\tcand2=j;\n\t\t\t\t\t\tsum=nn[i]+mm[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cand1<0? \"-1\" : nn[cand1]+\" \"+mm[cand2]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int[] vvx={0,1,0,-1,-1,1}, vvy={-1,0,1,0,-1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1155();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ1155(){\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tif(str.equals(\".\"))\tbreak;\n\t\t\tint ans=0;\n\t\t\tfor(int p=0; p<=2; p++){\n\t\t\t\tfor(int q=0; q<=2; q++){\n\t\t\t\t\tfor(int r=0; r<=2; r++){\n\t\t\t\t\t\tString s2=str.replaceAll(\"P\", Integer.toString(p)).replaceAll(\"Q\", Integer.toString(q)).replaceAll(\"R\", Integer.toString(r))+\"#\";\n\t\t\t\t\t\t//out.println(s2+\" \"+new parsed(s2).intValue());\n\t\t\t\t\t\tif(new parsed(s2).intValue()==2)\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//out.print(\"ANS=\");\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t// for AOJ1155\n\tpublic class parsed{\n\t\tString line;\n\t\tint pos=0,ans=0;\n\t\tparsed(String line){\n\t\t\tthis.line=line;\n\t\t\tans=term();\n\t\t}\n\t\tprivate int term(){\n\t\t\tint res=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tint old=res;\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res==2 || old==2)\tres=2;\n\t\t\t\t\telse if(res==0 && old==0)\tres=0;\n\t\t\t\t\telse\tres=1;\n\t\t\t\t}else if(op=='*'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res==0 || old==0)\tres=0;\n\t\t\t\t\telse if(res==2 && old==2)\tres=2;\n\t\t\t\t\telse\tres=1;\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate int fact(){\n\t\t\tif(line.charAt(pos)=='-'){\n\t\t\t\tpos++;\n\t\t\t\tint temp=fact();\n\t\t\t\treturn temp==0?2:temp==2?0:temp;\n\t\t\t}\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tint r=(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\treturn r;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tint res=term();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpublic int intValue(){return ans;}\n\t}\n\t\n\t\n\t// AOJ2255 2011MOGI - D\n\tHashSet<Integer> ans=new HashSet<Integer>();\n\tArrayList<Integer> d,k;\tArrayList<Character> e;\n\tvoid D(){\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.next().toCharArray();\n\t\t\tif(c[0]=='#')\tbreak;\n\t\t\td=new ArrayList<Integer>();\n\t\t\tk=new ArrayList<Integer>();\n\t\t\te=new ArrayList<Character>();\n\t\t\tint p=0;\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(Character.isDigit(c[i])){\n\t\t\t\t\tint dd=c[i]-'0';\n\t\t\t\t\twhile(i+1<c.length){\n\t\t\t\t\t\tif(!Character.isDigit(c[i+1]))\tbreak;\n\t\t\t\t\t\tdd=dd*10+(c[++i]-'0');\n\t\t\t\t\t}\n\t\t\t\t\td.add(dd);\n\t\t\t\t}else if(c[i]=='(')\tp++;\n\t\t\t\telse if(c[i]==')')\tp--;\n\t\t\t\telse{\n\t\t\t\t\te.add(c[i]);\n\t\t\t\t\tk.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(d);\n\t\t\tout.println(e);\n\t\t\tout.println(k);\n\t\t\t\n\t\t\tout.println(DtoString(d,e,k));\n\t\t\tfor(int i=0; i<k.size(); i++)\tsolveD(k,new boolean[k.size()],i,k.size());\n\t\t\t\n\t\t\tout.println(ans.size());\n\t\t}\n\t}\n\tvoid solveD(ArrayList<Integer> k,boolean[] b,int idx,int n){\n\t\tif(n<=0){\n\t\t\tans.add(new parsed(DtoString(d,e,k)).intValue());\n\t\t}else{\n\t\t\t// バックトラック\n\t\t}\n\t}\n\tString DtoString(ArrayList<Integer> d,ArrayList<Character> e,ArrayList<Integer> k){\n\t\tStringBuilder ans=new StringBuilder();\n\t\tint kk=0;\n\t\tfor(int i=0; i<e.size(); i++){\n\t\t\tif(kk<k.get(i)){\n\t\t\t\tfor(int j=0; j<abs(kk-k.get(i)); j++)\tans.append((kk<k.get(i)?\"(\":\")\"));\n\t\t\t\tkk=k.get(i);\n\t\t\t}\n\t\t\tans.append(d.get(i));\n\t\t\tif(kk>k.get(i)){\n\t\t\t\tfor(int j=0; j<abs(kk-k.get(i)); j++)\tans.append((kk<k.get(i)?\"(\":\")\"));\n\t\t\t\tkk=k.get(i);\n\t\t\t}\n\t\t\tans.append(e.get(i));\n\t\t}\n\t\tans.append(d.get(d.size()-1));\n\t\twhile(--kk>=0)\tans.append(\")\");\n\t\treturn ans.toString();\n\t}\n\t\n\t// 2011MOGI - A 15:02-15:08\n\tvoid AOJ2252(){\n\t\tHashSet<Character> right=new HashSet<Character>();\n\t\tright.add('y');\tright.add('h');\tright.add('n');\tright.add('u');\tright.add('j');\tright.add('m');\n\t\tright.add('i');\tright.add('k');\tright.add('o');\tright.add('l');\tright.add('p');\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.next().toCharArray();\n\t\t\tif(c[0]=='#')\tbreak;\n\t\t\tboolean r=false;\n\t\t\tif(right.contains(c[0]))\tr=true;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<c.length; i++){\n\t\t\t\tif(right.contains(c[i])){\n\t\t\t\t\tans+=!r?1:0;\n\t\t\t\t\tr=true;\n\t\t\t\t}else{\n\t\t\t\t\tans+=r?1:0;\n\t\t\t\t\tr=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// 2012MOGI - A\t14:50-14:57\n\tvoid AOJ2399(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tboolean[][] b=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int j=0; j<m; j++)\tb[i][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tboolean[] ans=new boolean[N+1];\n\t\t\tArrays.fill(ans, true);\n\t\t\tint k=sc.nextInt();\n\t\t\tfor(int i=0; i<k; i++){\n\t\t\t\tint p=sc.nextInt();\n\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\tif(!b[j][p])\tans[j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res=-1;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tif(ans[i]){\n\t\t\t\t\tif(res<0)\tres=i;\n\t\t\t\t\telse{\n\t\t\t\t\t\tres=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t}\n\t\n\t\n\t// AOJ2253 2011MOGI - B\n\tvoid AOJ2253(){\n\t\twhile(sc.hasNext()){\n\t\t\tint t=sc.nextInt(),n=sc.nextInt(),ans=0;\n\t\t\tfinal int BASE=100,MAX=BASE+50;\n\t\t\tif(t==0)\tbreak;\n\t\t\tboolean[][] close=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<n; i++)\tclose[sc.nextInt()+BASE][sc.nextInt()+BASE]=true;\n\t\t\tint sx=sc.nextInt()+BASE,sy=sc.nextInt()+BASE;\n\t\t\tLinkedList<ClassB> open=new LinkedList<ClassB>();\n\t\t\topen.add(new ClassB(sx,sy,0));\n\t\t\tclose[sx][sy]=true;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tClassB now=open.poll();\n\t\t\t\tans++;\n\t\t\t\tif(now.t>=t)\tcontinue;\n\t\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\t\tint xx=now.x+vvx[i],yy=now.y+vvy[i];\n\t\t\t\t\t//if(!Point.ok(xx, yy, MAX, MAX))\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new ClassB(xx,yy,now.t+1));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass ClassB{\n\t\tint x,y,t;\n\t\tClassB(int x,int y,int t){this.x=x; this.y=y; this.t=t;}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\tpublic static interface Fomula{\n\t\tint eval(int[] input);\n\t}\n\t\n\tpublic static class Minus implements Fomula{\n\t\tFomula inner;\n\t\t\n\t\tpublic Minus(Fomula in){\n\t\t\tinner = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn 2 - inner.eval(input);\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"-\" + inner;\n\t\t}\n\t}\n\t\n\tpublic static class Add implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Add(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.max(left.eval(input), right.eval(input));\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + left + \"+\" + right + \")\";\n\t\t}\n\t}\n\t\n\tpublic static class Mul implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Mul(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.min(left.eval(input), right.eval(input));\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + left + \"*\" + right + \")\";\n\t\t}\n\t}\n\t\n\tpublic static class Const implements Fomula{\n\t\tint con;\n\t\t\n\t\tpublic Const(int con){\n\t\t\tthis.con = con;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn con;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"\" + con;\n\t\t}\n\t}\n\t\n\tpublic static class Var implements Fomula{\n\t\tint var;\n\t\t\n\t\tpublic Var(int v){\n\t\t\tvar = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn input[var];\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn (char)(var + 'P')+\"\";\n\t\t}\n\t}\n\t\n\tpublic static Fomula parse(char[] input, int start, int end){\n\t\tint k_lv = 0;\n\t\tint k_s = -1, k_e = -1;\n\t\tint m_s = -1;\n\t\tint a_p = -1, m_p = -1;\n\t\t\n\t\tfor(int pos = start; pos <= end; pos++){\n\t\t\tif(input[pos] == '('){\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_s = pos;\n\t\t\t\t}\n\t\t\t\tk_lv++;\n\t\t\t}else if(input[pos] == ')'){\n\t\t\t\tk_lv--;\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_e = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(input[pos] == '-' && k_lv == 0 && m_s == -1){\n\t\t\t\tm_s = pos;\n\t\t\t\tbreak;\n\t\t\t}else if(input[pos] == '*' && k_lv == 1){\n\t\t\t\tm_p = pos;\n\t\t\t}else if(input[pos] == '+' && k_lv == 1){\n\t\t\t\ta_p = pos;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(k_s != -1 && k_e != -1){\n\t\t\tif(m_p != -1){\n\t\t\t\treturn new Mul(parse(input, k_s + 1, m_p - 1), parse(input, m_p + 1, k_e - 1));\n\t\t\t}else{\n\t\t\t\treturn new Add(parse(input, k_s + 1, a_p - 1), parse(input, a_p + 1, k_e - 1));\n\t\t\t}\n\t\t}else if(m_s != -1){\n\t\t\treturn new Minus(parse(input, m_s + 1, end));\n\t\t}else if('0' <= input[start] && input[start] <= '2'){\n\t\t\treturn new Const(input[start] - '0');\n\t\t}else {\n\t\t\treturn new Var(input[start] - 'P');\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\t\n\t\t\tif(\".\".equals(str)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tchar[] input = str.toCharArray();\n\t\t\t\n\t\t\tFomula fomula = parse(input, 0, input.length - 1);\n\t\t\t\n\t\t\t//System.out.println(fomula);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tint[] array = new int[3];\n\t\t\tfor(int p = 0; p <= 2; p++){\n\t\t\t\tarray[0] = p;\n\t\t\t\t\n\t\t\t\tfor(int q = 0; q <= 2; q++){\n\t\t\t\t\tarray[1] = q;\n\t\t\t\t\t\n\t\t\t\t\tfor(int r = 0; r <= 2; r++){\n\t\t\t\t\t\tarray[2] = r;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(fomula.eval(array) == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\tstatic int id;\nstatic int minus(int a) {\n\t if(a==0)return 2;\n\t if(a==2)return 0;\n\t return 1;\n}\n\nstatic int seki(int a,int b) {\n\t if(a==0 || b==0) return 0;\n\t if(a==2 && b==2) return 2;\n\t return 1;\n}\n\nstatic int plus(int a,int b) {\n\t if(a==2||b==2) return 2;\n\t if(a==1||b==1) return 1;\n\t return 0;\n}\n\nstatic int lastInd(String str,char ch1,char ch2) {\n\t int n = 0;\n\t for(int i=str.length()-1;i>0;i--) {\n\t  char c = str.charAt(i);\n\t  if(c=='(')\n\t   n++;\n\t  if(c==')')\n\t   n--;\n\t  if((ch1==c||ch2==c) && n==0)\n\t   return i;\n\t }\n\t return -1;\n}\n\nstatic int parse(String str) {\n\t if(id==str.length())return 0;\n\t if(Character.isDigit(str.charAt(id))) {\n\t\t id++;\n\t\t  return Integer.parseInt(String.valueOf(str.charAt(id-1)));\n\t }\n\t if(str.charAt(id)=='-') {\n\t\t id++;\n\t\t return minus(parse(str));\n\t }\n\t if(str.charAt(id)=='(') {\n\t\t id++;\n\t\t int a = parse(str);\n\t\t char c = str.charAt(id);\n\t\t id++;\n\t\t int b = parse(str);\n\t\t id++;\n\t\t if(c=='+') return plus(a,b);\n\t\t else if(c=='*')return seki(a,b);\n\t }\n\t return 0;\n \n}\n\npublic static void main(String[] args) {\n\t Scanner sc = new Scanner(System.in);\n\t while(sc.hasNext()) {\n\t  String str = sc.next();\n\t  String str1 = str;\n\t  if(str.equals(\".\")) break;\n\t \n\t  int cnt = 0;\n\t   for(int p=0;p<3;p++) {\n\t    for(int r=0;r<3;r++) {\n\t     for(int q=0;q<3;q++) {\n\t    \t str1 = str1.replaceAll(\"--\",\"\");\n\t    \t str1 = str.replace(\"P\", String.valueOf(p)).replace(\"R\", String.valueOf(r)).replace(\"Q\", String.valueOf(q));\n\t    \t id = 0;\n\t\t     if(parse(str1)==2) {\n\t\t   \t   cnt++;\n\t\t      }     \n\t\t      str1 = str;\n\t     }\n\t    }\n\t   }\n\t   System.out.println(cnt);\n\t  }\t \n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s = null;\n\tint at = 0;\n\tint p = -1, q = -1, r = -1;\n\t\n\tint[] t = {0, 1, 2};\n\tint[] f = {2, 1, 0};\n\t\n\tint[][] mu = {\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 1, 2}\n\t};\n\t\n\tint[][] ad = {\n\t\t\t{0, 1, 2},\n\t\t\t{1, 1, 2},\n\t\t\t{2, 2, 2}\n\t};\n\t\n\tint calc(int value, boolean not) {\n\t\treturn not ? f[value] : t[value];\n\t}\n\t\n\tint mult(int a, int b) {\n\t\treturn mu[a][b];\n\t}\n\t\n\tint add(int a, int b) {\n\t\treturn ad[a][b];\n\t}\n\t\n\tint formula() {\n\t\tboolean not = false;\n\t\tint n = s.length();\n\t\tint res = 0;\n\t\twhile (at < n) {\n\t\t\tchar c = s.charAt(at);\n\t\t\tswitch (c) {\n\t\t\tcase 'P' :\n\t\t\t\tres = calc(p, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Q' :\n\t\t\t\tres = calc(q, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tres = calc(r, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '0' :\n\t\t\tcase '1' :\n\t\t\tcase '2' :\n\t\t\t\tres = not ? f[c - '0'] : t[c - '0'];\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '-' :\n\t\t\t\tnot = not ? false : true;\n\t\t\t\tbreak;\n\t\t\tcase '*' :\n\t\t\t\tat++;\n\t\t\t\tres = mult(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '+' :\n\t\t\t\tat++;\n\t\t\t\tres = add(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '(' :\n\t\t\t\tat++;\n\t\t\t\tres = calc(formula(), not);\n\t\t\t\tbreak;\n\t\t\tcase ')' :\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tat++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"[.]\")) break;\n\t\t\t\n\t\t\tthis.s = s;\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\t\tp = i; q = j; r = k;\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tint x = formula();\n\t\t\t\t\t\tif (x == 2) res++;\n\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// How can I satisfy thee? Let me count the ways...\nimport java.util.*;\n\npublic class Main {\n\tstatic int pos, p, q, r;\n\tstatic String formura;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tformura = scanner.next();\n\t\t\tif (formura.equals(\".\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint result = 0;\n\t\t\tfor (p = 0; p < 3; p++)\n\t\t\t\tfor (q = 0; q < 3; q++)\n\t\t\t\t\tfor (r = 0; r < 3; r++) {\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\tif (eval() == 2) {\n\t\t\t\t\t\t\tresult++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tpublic static int eval() {\n\t\tchar c = formura.charAt(pos);\n\t\tpos++;\n\t\tif (c == '0')\n\t\t\treturn 0;\n\t\tif (c == '1')\n\t\t\treturn 1;\n\t\tif (c == '2')\n\t\t\treturn 2;\n\t\tif (c == 'P')\n\t\t\treturn p;\n\t\tif (c == 'Q')\n\t\t\treturn q;\n\t\tif (c == 'R')\n\t\t\treturn r;\n\t\tif (c == '-') {\n\t\t\tint result = eval();\n\t\t\treturn 2 - result;\n\t\t}\n\t\tif (c == '(') {\n\t\t\tint a = eval();\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = eval();\n\t\t\tpos++;\n\t\t\tif (op == '*')\n\t\t\t\treturn Math.min(a, b);\n\t\t\tif (op == '+')\n\t\t\t\treturn Math.max(a, b);\n\t\t}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//How can I satisfy thee? Let me count the ways...\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int index;\n\tstatic int[] table;\n\t\n\tstatic char c(){\n\t\treturn s[index++];\n\t}\n\t\n\tstatic int formura(){\n\t\tint r = term();\n\t\twhile(index < s.length){\n\t\t\tchar c = c();\n\t\t\tif(c=='*'){\n\t\t\t\tint p = term();\n\t\t\t\tr = Math.min(r, p);\n\t\t\t}\n\t\t\telse if(c=='+'){\n\t\t\t\tint p = term();\n\t\t\t\tr = Math.max(r, p);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tchar c = c();\n\t\tif(c=='('){\n\t\t\tint r = formura();\n\t\t\treturn r;\n\t\t}\n\t\tif(c=='-'){\n\t\t\tint r = term();\n\t\t\treturn r==0?2:r==1?1:0;\n\t\t}\n\t\tif(Character.isDigit(c))return c-'0';\n\t\treturn table[c-'P'];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\tif(str.equals(\".\"))break;\n\t\t\ts = (str+\"$\").toCharArray();\n\t\t\ttable = new int[3];\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\ttable[0]=i;\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\ttable[1]=j;\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\ttable[2]=k;\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\tans += formura()==2?1:0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "  "
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx,p,q,r;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts=(cin.next()+\"     \").toCharArray();\n\t\t\tif(s[0]=='.')break;\n\t\t\tint ans=0;\n\t\t\t\n\t\t\tfor(p=0;p<=2;p++){\n\t\t\t\tfor(q=0;q<=2;q++){\n\t\t\t\t\tfor(r=0;r<=2;r++){\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tif(formula()==2){\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int formula(){\n\t\tif(s[idx]=='0'){\n\t\t\tidx++;\n\t\t\treturn 0;\n\t\t}\n\t\telse if(s[idx]=='1'){\n\t\t\tidx++;\n\t\t\treturn 1;\n\t\t}\n\t\telse if(s[idx]=='2'){\n\t\t\tidx++;\n\t\t\treturn 2;\n\t\t}\n\t\telse if(s[idx]=='P'){\n\t\t\tidx++;\n\t\t\treturn p;\n\t\t}\n\t\telse if(s[idx]=='Q'){\n\t\t\tidx++;\n\t\t\treturn q;\n\t\t}\n\t\telse if(s[idx]=='R'){\n\t\t\tidx++;\n\t\t\treturn r;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\treturn minus(formula());\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tint a=formula();\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\ta=mult(a,formula());\n\t\t\t\tidx++;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tidx++;\n\t\t\t\ta=add(a,formula());\n\t\t\t\tidx++;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"aaaaaaaa\");\n\t\treturn 0;\n\t}\n\tstatic int mult(int a,int b){\n\t\tif(a==0||b==0)return 0;\n\t\tif(a+b==4)return 2;\n\t\treturn 1;\n\t}\n\tstatic int add(int a,int b){\n\t\tif(a==2||b==2){\n\t\t\treturn 2;\n\t\t}\n\t\tif(a+b==1){\n\t\t\treturn 1;\n\t\t}\n\t\tif((a|b)==1){\n\t\t\treturn 1;\n\t\t}\n\t\tif((a|b)==0){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}\n\tstatic int minus(int a){\n\t\tif(a==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(a==2){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tstatic int cur=0, p, q, r;\n\tstatic String str;\n\t\n\tstatic int no() {\n\t\tint start=cur;\n\t\twhile(cur<str.length()&&str.charAt(cur)=='-') {\n\t\t\tcur++;\n\t\t}\n\t\tint end=cur;\n\t\tint now=solve();\n\t\t//int now=str.charAt(cur)=='P'?p:(str.charAt(cur)=='Q'?q:(str.charAt(cur)=='R'?r:str.charAt(cur)-'0'));\n\t\tfor(int i=0; i<(end-start); i++) {\n\t\t\tnow=2-now;\n\t\t}\n\t\treturn now;\n\t}\n\t\n\tstatic int solve2() {\n\t\tint a=solve();\n\t\tcur++;\n\t\twhile(cur<str.length()&&(str.charAt(cur)=='+'||str.charAt(cur)=='*')) {\n\t\t\tchar op=str.charAt(cur++);\n\t\t\tint b=solve();\n\t\t\tif(op=='+')\ta=Math.max(a, b);\n\t\t\telse if(op=='*') a=Math.min(a, b);\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tstatic int solve() {\n\t\tif(str.charAt(cur)!='(') {\n\t\t\tif(str.charAt(cur)=='-') {\n\t\t\t\treturn no();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn str.charAt(cur)=='P'?p:(str.charAt(cur)=='Q'?q:(str.charAt(cur)=='R'?r:str.charAt(cur)-'0'));\n\t\t\t}\n\t\t}\n\t\tcur++;\n\t\tint n=solve2();\n\t\tcur++;\n\t\treturn n;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tstr=sc.next();\n\t\t\t\tif(str.equals(\".\")) break;\n\t\t\t\tint count=0;\n\t\t\t\tfor(p=0; p<3; p++){\n\t\t\t\t\tfor(q=0; q<3; q++){\n\t\t\t\t\t\tfor(r=0; r<3; r++){\n\t\t\t\t\t\t\tcur=0;\n\t\t\t\t\t\t\tif(solve()==2)  count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(count);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    String line;\n    int[][] pqr;\n    int idx,cnt;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        idx = 0;\n        pqr = new int[27][3];\n        getPQR(0,new int[3]);\n\n        while(true){\n            line = sc.next();\n            if(line.equals(\".\")) break;\n\n            cnt = 0;\n            String line2 = line;\n            LinkedList<Integer> left = new LinkedList<Integer>();\n            for(int i=0; i<27; i++){\n                line = line2;\n                char[] c = line.toCharArray();\n                for(int j=0; j<line.length(); j++){\n                    if(c[j]=='P' || c[j]=='Q' || c[j]=='R'){\n                        c[j] = (char)(pqr[i][c[j]-'P']+'0');\n                    }\n                    line = String.valueOf(c);\n                }\n                for(int j=0; j<line.length(); j++){\n                    if(line.charAt(j)=='(') left.add(j);\n                    if(line.charAt(j)==')'){\n                        int l = left.pollLast();\n                        String s = line.substring(l+1,j);\n                        String front = line.substring(0,l);\n                        String rear = \"\";\n                        if(line.length()>=j+1) rear = line.substring(j+1,line.length());\n                        String newS = getAns(s);\n                        line = front + newS + rear;\n                        j = j-(s.length()-newS.length())-2;\n                    }\n                }\n                if(getAns(line).equals(\"2\")) cnt++;\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    String getAns(String s){\n        String x = \"\",y = \"\";\n        boolean and = false,or = false;\n        for(int i=0; i<s.length(); i++){\n            if(s.charAt(i)=='*'){\n                and = true;\n                x = s.substring(0,i);\n                y = s.substring(i+1,s.length());\n            }else if(s.charAt(i)=='+'){\n                or = true;\n                x = s.substring(0,i);\n                y = s.substring(i+1,s.length());\n            }\n        }\n\n        if(and){\n            return getAND(x,y);\n        }else if(or){\n            return getOR(x,y);\n        }else{\n            return String.valueOf(getNum(s));\n        }\n    }\n\n    String getAND(String x,String y){\n        int xx = getNum(x);\n        int yy = getNum(y);\n        return String.valueOf(Math.min(xx,yy));\n    }\n\n    String getOR(String x,String y){\n        int xx = getNum(x);\n        int yy = getNum(y);\n        return String.valueOf(Math.max(xx,yy));\n    }\n\n    int getNum(String s){\n        int ii = 0;\n        while(s.charAt(ii)=='-') ii++;\n\n        int n = Integer.parseInt(s.substring(ii,s.length()));\n        for(int i=0; i<ii; i++) n = 2-n;\n\n        return n;\n    }\n\n    void getPQR(int pos,int[] num){\n        if(pos==3){\n            for(int i=0; i<3; i++) pqr[idx][i] = num[i];\n            idx++;\n            return;\n        }\n\n        for(int i=0; i<3; i++){\n            num[pos] = i;\n            getPQR(pos+1,num);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s = null;\n\tint at = 0;\n\tint p = -1, q = -1, r = -1;\n\t\n\tint[] t = {0, 1, 2};\n\tint[] f = {2, 1, 0};\n\t\n\tint[][] mu = {\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 1, 2}\n\t};\n\t\n\tint[][] ad = {\n\t\t\t{0, 1, 2},\n\t\t\t{1, 1, 2},\n\t\t\t{2, 2, 2}\n\t};\n\t\n\tint calc(int value, boolean not) {\n\t\treturn not ? f[value] : t[value];\n\t}\n\t\n\tint mult(int a, int b) {\n\t\treturn mu[a][b];\n\t}\n\t\n\tint add(int a, int b) {\n\t\treturn ad[a][b];\n\t}\n\t\n\tint formula() {\n\t\tboolean not = false;\n\t\tint n = s.length();\n\t\tint res = 0;\n\t\twhile (at < n) {\n\t\t\tchar c = s.charAt(at);\n\t\t\tswitch (c) {\n\t\t\tcase 'P' :\n\t\t\t\tres = calc(p, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Q' :\n\t\t\t\tres = calc(q, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tres = calc(r, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '0' :\n\t\t\tcase '1' :\n\t\t\tcase '2' :\n\t\t\t\tres = not ? f[c - '0'] : t[c - '0'];\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '-' :\n\t\t\t\tnot = not ? false : true;\n\t\t\t\tbreak;\n\t\t\tcase '*' :\n\t\t\t\tat++;\n\t\t\t\tres = mult(res, formula());\n\t\t\t\tat--;\n\t\t\t\tbreak;\n\t\t\tcase '+' :\n\t\t\t\tat++;\n\t\t\t\tres = add(res, formula());\n\t\t\t\tat--;\n\t\t\t\tbreak;\n\t\t\tcase '(' :\n\t\t\t\tat++;\n\t\t\t\tres = calc(formula(), not);\n\t\t\t\tbreak;\n\t\t\tcase ')' :\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tat++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"[.]\")) break;\n\t\t\t\n\t\t\tthis.s = s;\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\t\tp = i; q = j; r = k;\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tint x = formula();\n\t\t\t\t\t\tif (x == 2) res++;\n\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().start();\n\t}\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tString s = in.nextLine();\n\t\t\tif(s.equals(\".\"))break;\n\t\t\tint count = 0;\n\t\t\tfor(int p = 0; p < 3; p++){\n\t\t\t\tfor(int q = 0; q < 3; q++){\n\t\t\t\t\tfor(int r = 0; r < 3; r++){\n\t\t\t\t\t\tn = 0;\n\t\t\t\t\t\tint value = formula(s, p, q, r);\n\t\t\t\t\t\tif(value == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tint n = 0;\n\tint formula(String s, int p, int q, int r){\n\t\tif(s.charAt(n) == '('){\n\t\t\tchar operand = ' ';\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\twhile(true){\n\t\t\t\tn++;\n\t\t\t\tchar next = s.charAt(n);\n\t\t\t\tif(next == ')')break;\n\t\t\t\telse if(next == '(')stack.push(formula(s, p, q, r));\n\t\t\t\telse if(next == '+' || next == '*')operand = next;\n\t\t\t\telse if(next == '-'){\n\t\t\t\t\tn++;\n\t\t\t\t\tstack.push(not(formula(s, p, q, r)));\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar c = s.charAt(n);\n\t\t\t\t\tif(c == '0' || c == '1' || c == '2'){\n\t\t\t\t\t\tint result = Integer.parseInt(\"\"+s.charAt(n));\n\t\t\t\t\t\tstack.push(result);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(c == 'R')stack.push(r);\n\t\t\t\t\t\telse if(c == 'Q')stack.push(q);\n\t\t\t\t\t\telse stack.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a = stack.pop();\n\t\t\tint b = stack.pop();\n\t\t\tint result = 0;\n\t\t\tif(operand == '+')result = or(a,b);\n\t\t\telse result = and(a,b);\n\t\t\treturn result;\n\t\t}else if(s.charAt(n) == '-'){\n\t\t\tn++;\n\t\t\tint a = not(formula(s, p, q, r));\n\t\t\treturn a;\n\t\t}else{\n\t\t\tchar c = s.charAt(n);\n\t\t\tif(c == '0' || c == '1' || c == '2'){\n\t\t\t\tint result = Integer.parseInt(\"\"+s.charAt(n));\n\t\t\t\tn++;\n\t\t\t\treturn result;\n\t\t\t}else{\n\t\t\t\tn++;\n\t\t\t\tif(c == 'R')return r;\n\t\t\t\telse if(c == 'Q')return q;\n\t\t\t\telse return p;\n\t\t\t}\n\t\t}\n\t}\n\tint not(int a){\n\t\tif(a == 0){\n\t\t\treturn  2;\n\t\t}else if(a == 1){\n\t\t\treturn  1;\n\t\t}else{\n\t\t\treturn  0;\n\t\t}\n\t}\n\tint and(int a, int b){\n\t\tif(a == 0 || b == 0){\n\t\t\treturn  0;\n\t\t}else if(a == 1 || b == 1){\n\t\t\treturn  1;\n\t\t}else{\n\t\t\treturn  2;\n\t\t}\n\t}\n\tint or(int a, int b){\n\t\tif(a == 0 && b == 0){\n\t\t\treturn  0;\n\t\t}else if(a == 2 || b == 2){\n\t\t\treturn  2;\n\t\t}else{\n\t\t\treturn  1;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tint past = sb.length() + 10, now;\n\t\twhile (true) {\n\t\t\tnow = sb.length();\n\t\t\tif (past == now) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\t\tsb.delete(i, i + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpast = now;\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\t// System.out.printf(\"p q r = %d %d %d\\n\", p, q, r);\n\t\t\t\t\t\treplace(f, p, q, r);\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\n\t\t\t\t\t\t\tnegRemove(f);\n\n\t\t\t\t\t\t\tnegate(f);\n\n\t\t\t\t\t\t\tcalc(f);\n\n\t\t\t\t\t\t\tremoveNest(f);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\tpublic static interface Fomula{\n\t\tint eval(int[] input);\n\t}\n\t\n\tpublic static class Minus implements Fomula{\n\t\tFomula inner;\n\t\t\n\t\tpublic Minus(Fomula in){\n\t\t\tinner = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn 2 - inner.eval(input);\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"-\" + inner;\n\t\t}\n\t}\n\t\n\tpublic static class Add implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Add(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.max(left.eval(input), right.eval(input));\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + left + \"+\" + right + \")\";\n\t\t}\n\t}\n\t\n\tpublic static class Mul implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Mul(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.min(left.eval(input), right.eval(input));\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + left + \"*\" + right + \")\";\n\t\t}\n\t}\n\t\n\tpublic static class Const implements Fomula{\n\t\tint con;\n\t\t\n\t\tpublic Const(int con){\n\t\t\tthis.con = con;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn con;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"\" + con;\n\t\t}\n\t}\n\t\n\tpublic static class Var implements Fomula{\n\t\tint var;\n\t\t\n\t\tpublic Var(int v){\n\t\t\tvar = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn input[var];\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn (char)(var + 'P')+\"\";\n\t\t}\n\t}\n\t\n\tpublic static Fomula parse(char[] input, int start, int end){\n\t\tint k_lv = 0;\n\t\tint k_s = -1, k_e = -1;\n\t\tint m_s = -1;\n\t\tint a_p = -1, m_p = -1;\n\t\t\n\t\tfor(int pos = start; pos <= end; pos++){\n\t\t\tif(input[pos] == '('){\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_s = pos;\n\t\t\t\t}\n\t\t\t\tk_lv++;\n\t\t\t}else if(input[pos] == ')'){\n\t\t\t\tk_lv--;\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_e = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(input[pos] == '-' && k_lv == 0 && m_s == -1){\n\t\t\t\tm_s = pos;\n\t\t\t}else if(input[pos] == '*' && k_lv == 1){\n\t\t\t\tm_p = pos;\n\t\t\t}else if(input[pos] == '+' && k_lv == 1){\n\t\t\t\ta_p = pos;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(k_s != -1 && k_e != -1){\n\t\t\tif(m_p != -1){\n\t\t\t\treturn new Mul(parse(input, k_s + 1, m_p - 1), parse(input, m_p + 1, k_e - 1));\n\t\t\t}else{\n\t\t\t\treturn new Add(parse(input, k_s + 1, a_p - 1), parse(input, a_p + 1, k_e - 1));\n\t\t\t}\n\t\t}else if(m_s != -1){\n\t\t\treturn new Minus(parse(input, m_s + 1, end));\n\t\t}else if('0' <= input[start] && input[start] <= '2'){\n\t\t\treturn new Const(input[start] - '0');\n\t\t}else {\n\t\t\treturn new Var(input[start] - 'P');\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\t\n\t\t\tif(\".\".equals(str)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tchar[] input = str.toCharArray();\n\t\t\t\n\t\t\tFomula fomula = parse(input, 0, input.length - 1);\n\t\t\t\n\t\t\t//System.out.println(fomula);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tint[] array = new int[3];\n\t\t\tfor(int p = 0; p <= 2; p++){\n\t\t\t\tarray[0] = p;\n\t\t\t\t\n\t\t\t\tfor(int q = 0; q <= 2; q++){\n\t\t\t\t\tarray[1] = q;\n\t\t\t\t\t\n\t\t\t\t\tfor(int r = 0; r <= 2; r++){\n\t\t\t\t\t\tarray[2] = r;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(fomula.eval(array) == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tl = sc.next() + \"=\";\n\t\t\tif(l.equals(\".=\")) break;\n\t\t\tint cnt = 0;\n\t\t\targ = new int[3];\n\t\t\tfor (int p = 0; p < 3; p++) for (int q = 0; q < 3; q++) for (int r = 0; r < 3; r++) {\n\t\t\t\tthis.p = 0;\n\t\t\t\targ[0] = p;\n\t\t\t\targ[1] = q;\n\t\t\t\targ[2] = r;\n//\t\t\t\tdebug(p, q, r, exp());\n\t\t\t\tif (exp() == 2) cnt++;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tString l;\n\tint p;\n\tint[] arg;\n\n\tchar next() {\n\t\treturn l.charAt(p++);\n\t}\n\n\tint exp() {\n\t\tchar c = next();\n\t\tif (c == '-') return not(exp());\n\t\tif (c == '(') {\n\t\t\tint a = exp();\n\t\t\tc = next();\n\t\t\tint b = exp();\n\t\t\tp++;\n//\t\t\tdebug(a, b, c);\n\t\t\tif (c == '+') return add(a, b);\n\t\t\treturn mult(a, b);\n\t\t}\n\t\tp--;\n\t\treturn val();\n\t}\n\n\tint not(int x) {\n\t\treturn 2 - x;\n\t}\n\n\tint mult(int x, int y) {\n\t\treturn min(x, y);\n\t}\n\n\tint add(int x, int y) {\n\t\treturn max(x, y);\n\t}\n\n\tint val() {\n\t\tchar c = next();\n\t\tswitch (c) {\n\t\tcase 'P': return arg[0];\n\t\tcase 'Q': return arg[1];\n\t\tcase 'R': return arg[2];\n\t\tdefault:  return c - '0';\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tprivate static String str = null;\n\tprivate static boolean satisfy(int p, int q, int r) {\n\t\tString formula = str.replaceAll(\"P\", Integer.toString(p))\n\t\t\t.replaceAll(\"Q\", Integer.toString(q))\n\t\t\t.replaceAll(\"R\", Integer.toString(r));\n\t\twhile (formula.indexOf('+') != -1 || formula.indexOf('*') != -1 || formula.indexOf('-') != -1) {\n\t\t\tformula = formula.replaceAll(\"-0\", \"2\")\n\t\t\t\t.replaceAll(\"-1\", \"1\")\n\t\t\t\t.replaceAll(\"-2\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\+0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\+1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\+2\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\+0\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\+1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\+2\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\+0\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\+1\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\+2\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\*0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\*1\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\*2\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\*0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\*1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\*2\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\*0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\*1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\*2\\\\)\", \"2\");\n\t\t}\n\t\treturn formula.equals(\"2\");\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (!(str = sc.next()).equals(\".\")) {\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tif (satisfy(i, j, k)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\t\n\tstatic int getsimplecon(String minicon)\n\t{ //minicon is 0 1 2 but may also include -s\n\t\tboolean not = false;\n\t\twhile(minicon.charAt(0) == '-')\n\t\t{\n\t\t\tnot = !not;\n\t\t\tminicon = minicon.substring(1);\n\t\t}\n\t\t\n\t\tint ans;\n\t\tif(not)\n\t\t{\n\t\t\tans = 2-(Integer.parseInt(minicon));\n//\t\t\tSystem.out.println(\"simplecon \" + minicon + \": \" + ans);\n\t\t\treturn ans;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans = Integer.parseInt(minicon);\n//\t\t\tSystem.out.println(\"simplecon \" + minicon + \": \" + ans);\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\n\tstatic int getvalue(String content, int p, int q, int r, boolean replace)\n\t{\n\t\tint curdepth = 0;\n\t\tint startbracket = -1;\n\t\t\n\t\tif(replace)\n\t\t{\n\t\t\tcontent = content.replaceAll(\"P\", Integer.toString(p));\n\t\t\tcontent = content.replaceAll(\"Q\", Integer.toString(q));\n\t\t\tcontent = content.replaceAll(\"R\", Integer.toString(r));\n\t\t\t\n//\t\t\tSystem.out.println(\"Trying \" + content);\n\t\t}\n\t\t\n\t\t//get rid of brackets\n\t\tfor(int i = 0; i < content.length(); i++)\n\t\t{\n\t\t\tchar cur = content.charAt(i);\n\t\t\t\n\t\t\tif(cur == '(')\n\t\t\t{\n\t\t\t\tif(curdepth == 0)\n\t\t\t\t{\n\t\t\t\t\tstartbracket = i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcurdepth += 1;\n\t\t\t}\n\t\t\tif(cur == ')')\n\t\t\t{\n\t\t\t\tcurdepth -= 1;\n\t\t\t\t\n\t\t\t\tif(curdepth == 0)\n\t\t\t\t{\n\t\t\t\t\tString subcontent = content.substring(startbracket+1, i);\n\t\t\t\t\tString left = content.substring(0, startbracket);\n\t\t\t\t\tString right = content.substring(i+1);\n\t\t\t\t\t\n\t\t\t\t\tint subvalue = getvalue(subcontent, p, q, r, false);\n\t\t\t\t\t\n\t\t\t\t\tcontent = left + subvalue + right;\n\t\t\t\t\ti = startbracket;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//no more brackets\n\t\tfor(int i = 0; i < content.length(); i++)\n\t\t{\n\t\t\tchar cur = content.charAt(i);\n\t\t\t\n\t\t\tif(cur == '*' || cur == '+')\n\t\t\t{\n\t\t\t\tString leftcon = content.substring(0, i);\n\t\t\t\t\n\t\t\t\t//get rightcon\n\t\t\t\tString rightcon = \"\";\n\t\t\t\tint endofrightcon = -1; //inclusive\n\t\t\t\t\n\t\t\t\tfor(int j = i+1; j < content.length(); j++)\n\t\t\t\t{\n\t\t\t\t\tchar curj = content.charAt(j);\n\t\t\t\t\tif(curj == '*' || curj == '+')\n\t\t\t\t\t{\n\t\t\t\t\t\t//rightcon ends here\n\t\t\t\t\t\trightcon = content.substring(i+1, j);\n\t\t\t\t\t\tendofrightcon = j-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j == content.length()-1)\n\t\t\t\t\t{\n\t\t\t\t\t\trightcon = content.substring(i+1);\n\t\t\t\t\t\tendofrightcon = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tint leftv = getsimplecon(leftcon);\n\t\t\t\tint rightv = getsimplecon(rightcon);\n\t\t\t\tint minires = -1;\n\t\t\t\t\n\t\t\t\tif(cur == '*')\n\t\t\t\t{\n\t\t\t\t\tminires = Math.min(leftv, rightv);\n\t\t\t\t}\n\t\t\t\telse if(cur == '+')\n\t\t\t\t{\n\t\t\t\t\tminires = Math.max(leftv, rightv);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"leftv \" + leftv + \" \" + cur + \" rightv \" + rightv + \": \" + minires);\n\t\t\t\t\n\t\t\t\tcontent = minires + content.substring(endofrightcon+1);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(\"content now \" + content);\n\t\t\t\t\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn getsimplecon(content);\n\t}\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tString s;\n\n\t\twhile(true)\n\t\t{\n\t\t\ts = scan.next();\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tif(s.equals(\".\"))break;\n\t\t\t\n\t\t\t//- NOT,   * AND,   + OR\n\t\t\t\n\t\t\tfor(int p = 0; p <= 2; p++)\n\t\t\t{\n\t\t\t\tfor(int q = 0; q <= 2; q++)\n\t\t\t\t{\n\t\t\t\t\tfor(int r = 0; r <= 2; r++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(getvalue(s,p,q,r, true) == 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    String line;\n    int[][] pqr;\n    int idx,cnt;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        idx = 0;\n        pqr = new int[27][3];\n        getPQR(0,new int[3]);\n\n        while(true){\n            line = sc.next();\n            if(line.equals(\".\")) break;\n\n            cnt = 0;\n            String line2 = line;\n            LinkedList<Integer> left = new LinkedList<Integer>();\n            for(int i=0; i<27; i++){\n                line = line2;\n                char[] c = line.toCharArray();\n                for(int j=0; j<line.length(); j++){\n                    if(c[j]>='P' && c[j]<='R') c[j] = (char)(pqr[i][c[j]-'P']+'0');  \n                }\n                line = String.valueOf(c);\n\n                for(int j=0; j<line.length(); j++){\n                    if(line.charAt(j)=='(') left.add(j);\n                    if(line.charAt(j)==')'){\n                        int l = left.pollLast();\n                        String s = line.substring(l+1,j);\n                        String front = line.substring(0,l);\n                        String rear = line.substring(j+1,line.length());\n                        String newS = getAns(s);\n                        line = front + newS + rear;\n                        j = j-(s.length()-newS.length())-2;\n                    }\n                }\n                if(getAns(line).equals(\"2\")) cnt++;\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    String getAns(String s){\n        String x = \"\",y = \"\";\n        boolean and = false,or = false;\n        for(int i=0; i<s.length(); i++){\n            if(s.charAt(i)=='*'){\n                and = true;\n                x = s.substring(0,i);\n                y = s.substring(i+1,s.length());\n            }else if(s.charAt(i)=='+'){\n                or = true;\n                x = s.substring(0,i);\n                y = s.substring(i+1,s.length());\n            }\n        }\n\n        if(and){\n            return String.valueOf(Math.min(getNum(x),getNum(y)));\n        }else if(or){\n            return String.valueOf(Math.max(getNum(x),getNum(y)));\n        }else{\n            return String.valueOf(getNum(s));\n        }\n    }\n\n    int getNum(String s){\n        int ii = 0;\n        while(s.charAt(ii)=='-') ii++;\n\n        int n = Integer.parseInt(s.substring(ii,s.length()));\n        for(int i=0; i<ii; i++) n = 2-n;\n  \n        return n;\n    }\n\n    void getPQR(int pos,int[] num){\n        if(pos==3){\n            for(int i=0; i<3; i++) pqr[idx][i] = num[i];\n            idx++;\n            return;\n        }\n\n        for(int i=0; i<3; i++){\n            num[pos] = i;\n            getPQR(pos+1,num);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic final int[] p = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2};\n\tstatic final int[] q = {0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 2, 2};\n\tstatic final int[] r = {0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2};\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\tif(str.equals(\".\")) break;\n\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0; i<27; i++){\n\t\t\t\tString tmp = str;\n\t\t\t\ttmp = tmp.replace('P', (char)('0'+p[i]));\n\t\t\t\ttmp = tmp.replace('Q', (char)('0'+q[i]));\n\t\t\t\ttmp = tmp.replace('R', (char)('0'+r[i]));\n\t\t\t\tint tf;\n\t\t\t\tif(tmp.charAt(0)=='('){\n\t\t\t\t\ttf = formula(tmp.substring(1, tmp.length()-1));\n\t\t\t\t}else{\n\t\t\t\t\ttf = formula(tmp);\n\t\t\t\t}\n\t\t\t\tif(tf==2) cnt++;\n\t\t\t}\n\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tstatic public int formula(String str){\n\t\tif(str.length()==1) return str.charAt(0) - '0';\n\t\tint left, right;\n\t\tint i = 0, flag = 0;\n\n\t\tint j = 0;\n\t\twhile(str.charAt(j)=='-') j++;\n\n\t\twhile(true){\n\t\t\tif(str.charAt(i)=='('){\n\t\t\t\tflag++;\n\t\t\t}else if(str.charAt(i)==')'){\n\t\t\t\tflag--;\n\t\t\t}else if(flag==0 && (str.charAt(i)=='+' || str.charAt(i)=='*')){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(++i==str.length()) break;\n\t\t}\n\n\t\tif(i==str.length()){\n\t\t\tif(j%2==0){\n\t\t\t\tif(str.charAt(j)=='('){\n\t\t\t\t\treturn formula(str.substring(j+1, i-1));\n\t\t\t\t}else{\n\t\t\t\t\treturn formula(str.substring(j, i));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(str.charAt(j)=='('){\n\t\t\t\t\treturn 2 - formula(str.substring(j+1, i-1));\n\t\t\t\t}else{\n\t\t\t\t\treturn 2 - formula(str.substring(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(str.charAt(i-1)==')'){\n\t\t\t\tleft = formula(str.substring(j+1, i-1));\n\t\t\t}else{\n\t\t\t\tleft = formula(str.substring(j, i));\n\t\t\t}\n\t\t\tif(j%2==1) left = 2- left;\n\n\t\t\tif(str.charAt(i+1)=='('){\n\t\t\t\tright = formula(str.substring(i+2, str.length()-1));\n\t\t\t}else{\n\t\t\t\tright = formula(str.substring(i+1, str.length()));\n\t\t\t}\n\n\t\t\tif(str.charAt(i)=='+'){\n\t\t\t\tif(left==2||right==2){\n\t\t\t\t\treturn 2;\n\t\t\t\t}else if(left==1||right==1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(left==0||right==0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(left==1||right==1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tprivate static String str = null;\n\tprivate static boolean satisfy(int p, int q, int r) {\n\t\tString formula = str.replaceAll(\"P\", Integer.toString(p))\n\t\t\t.replaceAll(\"Q\", Integer.toString(q))\n\t\t\t.replaceAll(\"R\", Integer.toString(r));\n\t\twhile (formula.indexOf('-') != -1) {\n\t\t\tformula = formula.replaceAll(\"-0\", \"2\")\n\t\t\t\t.replaceAll(\"-1\", \"1\")\n\t\t\t\t.replaceAll(\"-2\", \"0\");\n\t\t}\n\t\twhile (formula.indexOf('+') != -1 || formula.indexOf('*') != -1) {\n\t\t\tformula = formula.replaceAll(\"\\\\(0\\\\+0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\+1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\+2\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\+0\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\+1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\+2\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\+0\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\+1\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\+2\\\\)\", \"2\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\*0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\*1\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(0\\\\*2\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\*0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\*1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(1\\\\*2\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\*0\\\\)\", \"0\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\*1\\\\)\", \"1\")\n\t\t\t\t.replaceAll(\"\\\\(2\\\\*2\\\\)\", \"2\");\n\t\t}\n\t\treturn formula.equals(\"2\");\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (!(str = sc.next()).equals(\".\")) {\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tif (satisfy(i, j, k)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tStack<Integer> st = new Stack<Integer>();\n    \tint stack(int P,int Q,int R,char ctr[]){\n    \t\tint cnt = 0;\n    \t\tfor(int i = 0;i < ctr.length;i++){\n    \t\t\tif(ctr[i] == ')'){\n    \t\t\t\tint result = st.pop();\n    \t\t\t\twhile(true){\n    \t\t\t\t\tint num = st.pop();\n    \t\t\t\t\tif(num == -1){\n    \t\t\t\t\t\tst.push(result);\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\telse if(num == -2){\n    \t\t\t\t\t\tif(result == 0)result = 2;\n    \t\t\t\t\t\telse if(result == 1)result = 1;\n    \t\t\t\t\t\telse result = 0;\n    \t\t\t\t\t}else if(num == -3){\n    \t\t\t\t\t\tint num2 = st.pop();\n    \t\t\t\t\t\tresult = ((result|num2) == 3 ? 2:(result|num2));\n    \t\t\t\t\t}else if(num == -4){\n    \t\t\t\t\t\tint num2 = st.pop();\n    \t\t\t\t\t\tresult = result == num2 ? result:(result+num2) == 3 ? 1:0;\n    \t\t\t\t\t}\n    \t\t\t\t}\n//    \t\t\t\tSystem.out.println(st.toString());\n//    \t\t\t\tSystem.out.println(result);\n    \t\t\t}else{\n    \t\t\t\t//??°?????????\n    \t\t\t\tif(ctr[i] == '('){\n    \t\t\t\t\tif(cnt % 2 == 1)st.push(-2);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t\tst.push(-1);\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == 'P'){\n    \t\t\t\t\tif(cnt % 2 == 1){\n    \t\t\t\t\t\tif(P == 0)st.push(2);\n    \t\t\t\t\t\telse if(P == 1)st.push(1);\n    \t\t\t\t\t\telse st.push(0);\n    \t\t\t\t\t}else st.push(P);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == 'Q'){\n    \t\t\t\t\tif(cnt % 2 == 1){\n    \t\t\t\t\t\tif(Q == 0)st.push(2);\n    \t\t\t\t\t\telse if(Q == 1)st.push(1);\n    \t\t\t\t\t\telse st.push(0);\n    \t\t\t\t\t}else st.push(Q);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == 'R'){\n    \t\t\t\t\tif(cnt % 2 == 1){\n    \t\t\t\t\t\tif(R == 0)st.push(2);\n    \t\t\t\t\t\telse if(R == 1)st.push(1);\n    \t\t\t\t\t\telse st.push(0);\n    \t\t\t\t\t}else st.push(R);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '-'){\n    \t\t\t\t\tcnt++;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '+')st.push(-3);\n    \t\t\t\telse if(ctr[i] == '*')st.push(-4);\n    \t\t\t\telse if(ctr[i] == '0'){\n    \t\t\t\t\tif(cnt % 2 == 1)st.push(2);\n    \t\t\t\t\telse st.push(0);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '1'){\n    \t\t\t\t\tst.push(1);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '2'){\n    \t\t\t\t\tif(cnt % 2 == 1)st.push(0);\n    \t\t\t\t\telse st.push(2);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn st.pop();\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tString str = sc.next();\n    \t\t\tif(str.equals(\".\"))break;\n    \t\t\tint ans = 0;\n    \t\t\tfor(int i = 0;i < 3;i++){\n    \t\t\t\tfor(int j = 0;j < 3;j++){\n    \t\t\t\t\tfor(int k = 0;k < 3;k++){\n//    \t\t\t\t\t\tSystem.out.println(\"+++++++\");\n    \t\t\t\t\t\tif(stack(i,j,k,str.toCharArray()) == 2)ans++;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println(ans);\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s = null;\n\tint at = 0;\n\tint p = -1, q = -1, r = -1;\n\t\n\tint[] t = {0, 1, 2};\n\tint[] f = {2, 1, 0};\n\t\n\tint[][] mu = {\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 1, 2}\n\t};\n\t\n\tint[][] ad = {\n\t\t\t{0, 1, 2},\n\t\t\t{1, 1, 2},\n\t\t\t{2, 2, 2}\n\t};\n\t\n\tint calc(int value, boolean not) {\n\t\treturn not ? f[value] : t[value];\n\t}\n\t\n\tint mult(int a, int b) {\n\t\treturn mu[a][b];\n\t}\n\t\n\tint add(int a, int b) {\n\t\treturn ad[a][b];\n\t}\n\t\n\tint formula() {\n\t\tboolean not = false;\n\t\tint n = s.length();\n\t\tint res = 0;\n\t\twhile (at < n) {\n\t\t\tchar c = s.charAt(at);\n\t\t\tswitch (c) {\n\t\t\tcase 'P' :\n\t\t\t\tres = calc(p, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Q' :\n\t\t\t\tres = calc(q, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tres = calc(r, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '0' :\n\t\t\tcase '1' :\n\t\t\tcase '2' :\n\t\t\t\tres = not ? f[c - '0'] : t[c - '0'];\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '-' :\n\t\t\t\tnot = not ? false : true;\n\t\t\t\tbreak;\n\t\t\tcase '*' :\n\t\t\t\tat++;\n\t\t\t\tres = mult(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '+' :\n\t\t\t\tat++;\n\t\t\t\tres = add(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '(' :\n\t\t\t\tat++;\n\t\t\t\tres = calc(formula(), not);\n\t\t\t\tbreak;\n\t\t\tcase ')' :\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tat++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"-1\")) break;\n\t\t\t\n\t\t\tthis.s = s;\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\t\tp = i; q = j; r = k;\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tint x = formula();\n\t\t\t\t\t\tif (x == 2) res++;\n\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main1 {\n\n\tstatic char[] s;\n\tstatic char[] var;\n\tstatic int[] PQR;\n\tstatic int[] tuf = {0, 1, 2};// true, unknown, false\n\tstatic int idx;\n\tstatic int varCount;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tvarCount=idx=0;\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = new char[80];\n\t\t\tvar = new char[80];\n\t\t\tPQR=new int[3];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\tchar c = str.charAt(i);\n\t\t\t\tif(c == '-' || c == '*' || c == '+' || c == '(' || c == ')'){\n\t\t\t\t\ts[idx++]=c;\n\t\t\t\t}\n\t\t\t\telse if(c=='P'){\n\t\t\t\t\tvar[varCount++]=0;\n\t\t\t\t}\n\t\t\t\telse if(c=='Q'){\n\t\t\t\t\tvar[varCount++]=1;\n\t\t\t\t}\n\t\t\t\telse if(c=='R'){\n\t\t\t\t\tvar[varCount++]=2;\n\t\t\t\t}\n\t\t\t\telse if(c=='0'){\n\t\t\t\t\tvar[varCount++]=3;\n\t\t\t\t}\n\t\t\t\telse if(c=='1'){\n\t\t\t\t\tvar[varCount++]=4;\n\t\t\t\t}\n\t\t\t\telse if(c=='2'){\n\t\t\t\t\tvar[varCount++]=5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint count=0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tvarCount=idx=0;\n\t\t\t\t\t\tPQR[0]=tuf[i];\n\t\t\t\t\t\tPQR[1]=tuf[j];\n\t\t\t\t\t\tPQR[2]=tuf[k];\n\t\t\t\t\t\tif(expression()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\tres = or(res, expression());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres = and(res, term());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=expression();\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = not(fact());\n\t\t}\n\t\telse{\n\t\t\tres = variable();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int variable(){\n\t\tif(var[varCount]>=3){\n\t\t\treturn var[varCount++]-3;\n\t\t}\n\t\treturn PQR[var[varCount++]];\n\t}\n\tstatic int or(int x, int y){\n\t\tif(x <= 1 && y <= 1){\n\t\t\tif(x == 0 && y == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t}\n\tstatic int and(int x, int y){\n\t\tif(x >= 1 && y >= 1){\n\t\t\tif(x == 2 && y == 2){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic int not(int x){\n\t\tif(x ==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(x==1){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class C {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\tsb.delete(i, i + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegRemove(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegate(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tcalc(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tremoveNest(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.printf(\"p,q,r = %d %d %d -> %s\\n\", p, q,\n\t\t\t\t\t\t// r,\n\t\t\t\t\t\t// f.toString());\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n// 7/26\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tidx=0;\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint count=0;\n\t\t\tfor(int i = 0; i < 3;i++){\n\t\t\t\tfor(int j = 0;j < 3;j++){\n\t\t\t\t\tfor(int k =0; k < 3;k++){\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tString a = str.replace('P', (char)('0'+i));\n\t\t\t\t\t\ta = a.replace('Q', (char)('0'+j));\n\t\t\t\t\t\ta = a.replace('R', (char)('0'+k));\n\t\t\t\t\t\ts = new char[a.length()+100];\n\t\t\t\t\t\tfor(int m= 0; m < a.length();m++){\n\t\t\t\t\t\t\ts[m]=a.charAt(m);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(s);\n\t\t\t\t\t\tif(expression()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\t\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\tres = or(res, expression());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\t\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres = and(res, fact());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = bikkuri(fact());\n\t\t}\n\t\telse{\n\t\t\treturn variable();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int variable(){\n\t\tif(s[idx]=='0'){\n\t\t\tidx++;\n\t\t\treturn 0;\n\t\t}\n\t\telse if(s[idx]=='1'){\n\t\t\tidx++;\n\t\t\treturn 1;\n\t\t}\n\t\telse if(s[idx]=='2'){\n\t\t\tidx++;\n\t\t\treturn 2;\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t}\n\tstatic int bikkuri(int a){\n\t\tif(a==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(a==2){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n\tstatic int or(int a,int b){\n\t\tif(a==2||b==2){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(a+b==0){\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t\treturn 1;\n\t}\n\tstatic int and(int a,int b){\n\t\tif(a==0||b==0){\n\t\t\treturn 0;\n\t\t}\n\t\telse if(a+b==4){\n\t\t\treturn 2;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint[] eq;\n\tint len;\n\t\n\tint index;\n\tint token;\n\tint value;\n\tint ch;\n\t\n\tfinal int NUM = -256;\n\tfinal int LF = '\\n';\n\t\n\tint[] pqr = new int[3];\n\t\n\tint not(int x) {\n\t\tif (x == 0)\n\t\t\treturn 2;\n\t\telse if (x == 1)\n\t\t\treturn 1;\n\t\telse if (x == 2)\n\t\t\treturn 0;\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tint and(int x, int y) {\n\t\tif (x == 0 || y == 0)\n\t\t\treturn 0;\n\t\telse if (x == 1 || y == 1)\n\t\t\treturn 1;\n\t\telse if (x == 2 || y == 2)\n\t\t\treturn 2;\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tint or(int x, int y) {\n\t\tif (x == 2 || y == 2)\n\t\t\treturn 2;\n\t\telse if (x == 1 || y == 1)\n\t\t\treturn 1;\n\t\telse if (x == 0 || y == 0)\n\t\t\treturn 0;\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t\n\tvoid gettoken() {\n\t\tif (ch == '-' || ch == '(' || ch == ')' || ch == '*' || ch == '+') {\n\t\t\ttoken = ch;\n\t\t\tch = eq[index++];\n\t\t} else if (ch == LF){\n\t\t\ttoken = ch;\n\t\t} else {\n\t\t\ttoken = NUM;\n\t\t\t\n\t\t\tswitch (ch) {\n\t\t\tcase '0': value = 0; break;\n\t\t\tcase '1': value = 1; break;\n\t\t\tcase '2': value = 2; break;\n\t\t\tcase 'P': value = pqr[0]; break;\n\t\t\tcase 'Q': value = pqr[1]; break;\n\t\t\tcase 'R': value = pqr[2]; break;\n\t\t\t}\n\t\t\t\n\t\t\tch = eq[index++];\n\t\t}\n\t}\n\t\n\tint F() {\n\t\tint v = 0;\n\t\tif (token == NUM) {\n\t\t\tv = value;\n\t\t\tgettoken();\n\t\t} else if (token == '-') {\n\t\t\tgettoken();\n\t\t\tv = not(F());\n\t\t} else if (token == '(') {\n\t\t\tint vnext, savetoken;\n\t\t\tgettoken(); \n\t\t\tv = F();\n\t\t\tsavetoken = token;\n\t\t\tgettoken();\n\t\t\tvnext = F();\n\t\t\tif (savetoken == '*') {\n\t\t\t\tv = and(v, vnext);\n\t\t\t} else if (savetoken == '+') {\n\t\t\t\tv = or(v, vnext);\n\t\t\t}\n\t\t\tif (token == ')') gettoken();\n\t\t}\n\t\t\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\".\")) break;\n\t\t\tlen = s.length();\n\t\t\teq = new int[len+1];\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\teq[i] = s.charAt(i);\n\t\t\teq[len] = LF;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tpqr[0] = p;\n\t\t\t\t\t\tpqr[1] = q;\n\t\t\t\t\t\tpqr[2] = r;\n\t\t\t\t\t\t\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\tch = eq[index++];\n\t\t\t\t\t\tgettoken();\n\t\t\t\t\t\tif (F() == 2) ans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static interface Expr{\n\t\tpublic int exec(int p, int q, int r);\n\t}\n\t\n\tpublic static class Number implements Expr{\n\t\tint num;\n\t\t\n\t\tpublic Number(int n){\n\t\t\tnum = n;\n\t\t}\n\t\t\n\t\tpublic int exec(int p, int q, int r){\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tpublic static class Val implements Expr{\n\t\tint num;\n\t\t\n\t\tpublic Val(int n){\n\t\t\tnum = n;\n\t\t}\n\t\t\n\t\tpublic int exec(int p, int q, int r){\n\t\t\tif(num == 0){\n\t\t\t\treturn p;\n\t\t\t}else if(num == 1){\n\t\t\t\treturn q;\n\t\t\t}else if(num == 2){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tpublic static class Minus implements Expr{\n\t\tExpr inner;\n\t\t\n\t\tpublic Minus(Expr in){\n\t\t\tinner = in;\n\t\t}\n\t\t\n\t\tpublic int exec(int p, int q, int r){\n\t\t\treturn 2 - inner.exec(p,q,r);\n\t\t}\n\t}\n\t\n\tpublic static class Plus implements Expr{\n\t\tExpr le, ri;\n\t\t\n\t\tpublic Plus(Expr l, Expr r){\n\t\t\tle = l;\n\t\t\tri = r;\n\t\t}\n\t\t\n\t\tpublic int exec(int p, int q, int r){\n\t\t\treturn Math.max(le.exec(p, q, r), ri.exec(p, q, r));\n\t\t}\n\t}\n\t\n\tpublic static class Mult implements Expr{\n\t\tExpr le, ri;\n\t\t\n\t\tpublic Mult(Expr l, Expr r){\n\t\t\tle = l;\n\t\t\tri = r;\n\t\t}\n\t\t\n\t\tpublic int exec(int p, int q, int r){\n\t\t\treturn Math.min(le.exec(p, q, r), ri.exec(p, q, r));\n\t\t}\n\t}\n\t\n\tpublic static Expr parse(char[] input, int start, int end){\n\t\tint c_level = 0;\n\t\tint op_pos = -1;\n\t\tint op_type = -1;\n\t\tint c_start = start, c_end = end;\n\t\t\n\t\tfor(int i = start; i <= end; i++){\n\t\t\tif(c_level == 0 && input[i] == '-' && op_pos == -1){\n\t\t\t\top_type = 0;\n\t\t\t\top_pos = i;\n\t\t\t\tc_start = i;\n\t\t\t\tc_end++;\n\t\t\t}else if(input[i] == '('){\n\t\t\t\tif(c_start == -1){\n\t\t\t\t\tc_start = i;\n\t\t\t\t}\n\t\t\t\tc_level++;\n\t\t\t}else if(input[i] == ')'){\n\t\t\t\tc_level--;\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_end = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(c_level == 1 && input[i] == '*'){\n\t\t\t\top_pos = i;\n\t\t\t\top_type = 2;\n\t\t\t}else if(c_level == 1 && input[i] == '+'){\n\t\t\t\top_pos = i;\n\t\t\t\top_type = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(op_type == 0){\n\t\t\treturn new Minus(parse(input, c_start + 1, c_end - 1));\n\t\t}else if(op_type == 1){\n\t\t\treturn new Plus(parse(input,c_start + 1, op_pos - 1),parse(input,op_pos + 1, c_end - 1));\n\t\t}else if(op_type == 2){\n\t\t\treturn new Mult(parse(input,c_start + 1, op_pos - 1),parse(input,op_pos + 1, c_end - 1));\n\t\t}else{\n\t\t\tif(input[start] == '0' || input[start] == '1' || input[start] == '2'){\n\t\t\t\treturn new Number(input[start] - '0');\n\t\t\t}else{\n\t\t\t\treturn new Val(input[start] - 'P');\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tString input = sc.next();\n\t\t\t\n\t\t\tif(\".\".equals(input)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tExpr tree = parse(input.toCharArray(), 0, input.length() - 1);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tif(tree.exec(i, j, k) == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s = null;\n\tint at = 0;\n\tint p = -1, q = -1, r = -1;\n\t\n\tint[] t = {0, 1, 2};\n\tint[] f = {2, 1, 0};\n\t\n\tint[][] mu = {\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 1, 2}\n\t};\n\t\n\tint[][] ad = {\n\t\t\t{0, 1, 2},\n\t\t\t{1, 1, 2},\n\t\t\t{2, 2, 2}\n\t};\n\t\n\tint calc(int value, boolean not) {\n\t\treturn not ? f[value] : t[value];\n\t}\n\t\n\tint mult(int a, int b) {\n\t\treturn mu[a][b];\n\t}\n\t\n\tint add(int a, int b) {\n\t\treturn ad[a][b];\n\t}\n\t\n\tint formula() {\n\t\tboolean not = false;\n\t\tint n = s.length();\n\t\tint res = 0;\n\t\twhile (at < n) {\n\t\t\tchar c = s.charAt(at);\n\t\t\tswitch (c) {\n\t\t\tcase 'P' :\n\t\t\t\tres = calc(p, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Q' :\n\t\t\t\tres = calc(q, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tres = calc(r, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '0' :\n\t\t\tcase '1' :\n\t\t\tcase '2' :\n\t\t\t\tres = not ? f[c - '0'] : t[c - '0'];\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '-' :\n\t\t\t\tnot = not ? false : true;\n\t\t\t\tbreak;\n\t\t\tcase '*' :\n\t\t\t\tat++;\n\t\t\t\tres = mult(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '+' :\n\t\t\t\tat++;\n\t\t\t\tres = add(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '(' :\n\t\t\t\tat++;\n\t\t\t\tres = calc(formula(), not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase ')' :\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tat++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"[.]\")) break;\n\t\t\t\n\t\t\tthis.s = s;\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\t\tp = i; q = j; r = k;\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tint x = formula();\n\t\t\t\t\t\tif (x == 2) res++;\n\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p1155;\n\n\nimport java.util.Scanner;\n\npublic class Main3 {\n\n\tstatic char[] s;\n\tstatic int[] PQR;\n\tstatic int[] tuf = {0, 1, 2};// true, unknown, false\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tidx=0;\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = new char[81];\n\t\t\tPQR=new int[3];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i] = str.charAt(i);\n\t\t\t}\n\n\t\t\tint count=0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tPQR[0]=tuf[i];\n\t\t\t\t\t\tPQR[1]=tuf[j];\n\t\t\t\t\t\tPQR[2]=tuf[k];\n\t\t\t\t\t\tif(expression()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\tres = or(res, expression());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres = and(res, term());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=expression();\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = not(fact());\n\t\t}\n\t\telse{\n\t\t\tres = variable();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int variable(){\n\t\tif(s[idx]=='P'){\n\t\t\tidx++;\n\t\t\treturn PQR[0];\n\t\t}\n\t\telse if(s[idx]=='Q'){\n\t\t\tidx++;\n\t\t\treturn PQR[1];\n\t\t}\n\t\telse if(s[idx]=='R'){\n\t\t\tidx++;\n\t\t\treturn PQR[2];\n\t\t}\n\t\telse{\n\t\t\treturn s[idx++] - '0';\n\t\t}\n\t}\n\tstatic int or(int x, int y){\n\t\tif(x <= 1 && y <= 1){\n\t\t\tif(x == 0 && y == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t}\n\tstatic int and(int x, int y){\n\t\tif(x >= 1 && y >= 1){\n\t\t\tif(x == 2 && y == 2){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic int not(int x){\n\t\tif(x ==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(x==1){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/** top-down syntax analysis (BNF) */\npublic class Main {\n\tprivate static int pos;\n\tprivate static int p;\n\tprivate static int q;\n\tprivate static int r;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString input = sc.nextLine();\n\t\t\tif(input.equals(\".\")) break;\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(p = 0; p < 3; p++){\n\t\t\t\tfor(q = 0; q < 3; q++){\n\t\t\t\t\tfor(r = 0; r < 3; r++){\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\tint ret = formula(input);\n\t\t\t\t\t\tif(ret == 2) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate static int formula(String input){\n\t\tchar c = input.charAt(pos++);\n\t\t\n\t\tif(c == '0') return 0;\n\t\tif(c == '1') return 1;\n\t\tif(c == '2') return 2;\n\t\tif(c == 'P') return p;\n\t\tif(c == 'Q') return q;\n\t\tif(c == 'R') return r;\n\t\t\n\t\tif(c == '-'){\n\t\t\tint ret = formula(input);\n\t\t\treturn (2 - ret);\n\t\t}\n\t\t\n\t\t// c = '('\n\t\tint n1 = formula(input);\n\t\tboolean multi = (input.charAt(pos++) == '*');\n\t\tint n2 = formula(input);\n\t\tpos++;/*   next char   <-   c = ')' */\n\t\tif(multi){\n\t\t\t/* (2 * 2 = 2) , (1 * 1 = 1), (0 * 0 = 0) */\n\t\t\tif(n1 == n2) return n1;\n\t\t\treturn 0;/* (0 * ? = 0) */\n\t\t}else{\n\t\t\treturn Math.max(n1, n2);/* n1 + n2 */\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.*;\nimport java.io.*;\nimport java.util.*; \n \npublic class Main\n{\n\tpublic static void main(String args[]) throws Exception{\n\t\tnew Main().run();\n\t}\n\t\n\t\n\tpublic void run()\n\t{\n\t\tint i,j,k;\n\t\twhile(true){\n\t\t\tScanner cin=new Scanner(System.in);\n\t\t\tString s = cin.nextLine();\n\t\t\tif(s.equals(\".\")) break;\n\t\t\tint count = 0;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\tfor(k=0;k<3;k++){\n\t\t\t\t\t\t//System.out.println(i + \" \" + j + \" \" + k);\n\t\t\t\t\t\tString ss = s;\n\t\t\t\t\t\tss = ss.replace(\"P\", i + \"\");\n\t\t\t\t\t\tss = ss.replace(\"Q\", j + \"\");\n\t\t\t\t\t\tss = ss.replace(\"R\", k + \"\");\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tss = ss.replace(\"-0\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"-1\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"-2\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0+0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0+1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0+2)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1+0)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1+1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1+2)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2+0)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2+1)\", \"2\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2+2)\", \"2\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tss = ss.replace(\"(0*0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0*1)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(0*2)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1*0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1*1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(1*2)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2*0)\", \"0\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2*1)\", \"1\");\n\t\t\t\t\t\t\tss = ss.replace(\"(2*2)\", \"2\");\n\t\t\t\t\t\t\tif(ss.length()==1) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ss.equals(\"2\")){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tString input = in.next();\n\t\t\tif(input.equals(\".\"))break;\n\t\t\tnew AOJ1155().doIt(input+\"=\");\n\t\t}\n\t}\n\tclass AOJ1155{\n\t\tchar[] line;\n\t\tint pos;\n\t\tint P,Q,R;\n\t\tint exp(){\n//\t\t\tSystem.out.println(\"exp-- \"+pos);\n\t\t\tint r = term();\n//\t\t\tSystem.out.println(\"exp-- \"+r);\n\t\t\twhile(true){\n\t\t\t\tchar c = line[pos++];\n\t\t\t\tif(c=='+'){\n\t\t\t\t\tint a = term();\n\t\t\t\t\tif(r==2||a==2)r = 2;\n\t\t\t\t\telse if(r==1||a==1)r=1;\n\t\t\t\t\telse r = 0;\n\t\t\t\t}else if(c=='*'){\n\t\t\t\t\tint a = term();\n\t\t\t\t\tr = Math.min(a, r);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tint term(){\n\t\t\treturn fact();\n\t\t}\n\n\t\tint fact(){\n\t\t\tchar c = line[pos++];\n\t\t\tif(c=='(')return exp();\n\t\t\tif(c=='-'){\n\t\t\t\tint a = fact();\n\t\t\t\treturn Math.abs(a-2);\n\t\t\t}\n\t\t\tif(c=='P')return P;\n\t\t\tif(c=='Q')return Q;\n\t\t\tif(c=='R')return R;\n\t\t\tint x = c-'0';\n\t\t\twhile(true){\n\t\t\t\tc = line[pos++];\n\t\t\t\tif(Character.isDigit(c)){\n\t\t\t\t\tx *= 10;\n\t\t\t\t\tx += c-'0';\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tpos--;\n\t\t\treturn x;\n\t\t}\n\t\t\n\t\tvoid doIt(String input){\n\t\t\tline = input.toCharArray();\n\t\t\tint cnt = 0;\n\t\t\tfor(P=0;P<3;P++)for(Q=0;Q<3;Q++)for(R=0;R<3;R++){\n//\t\t\t\tSystem.out.println(P+\" \"+Q+\" \"+R);\n\t\t\t\tpos = 0;\n\t\t\t\tif(exp()==2)cnt++;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic final int[] p = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2};\n\tstatic final int[] q = {0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 0, 0, 1, 1, 1, 2, 2, 2};\n\tstatic final int[] r = {0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2};\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\tif(str.equals(\".\")) break;\n\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0; i<27; i++){\n\t\t\t\tString tmp = str;\n\t\t\t\ttmp = tmp.replace('P', (char)('0'+p[i]));\n\t\t\t\ttmp = tmp.replace('Q', (char)('0'+q[i]));\n\t\t\t\ttmp = tmp.replace('R', (char)('0'+r[i]));\n\t\t\t\tint tf;\n\t\t\t\tif(tmp.charAt(0)=='('){\n\t\t\t\t\ttf = formula(tmp.substring(1, tmp.length()-1));\n\t\t\t\t}else{\n\t\t\t\t\ttf = formula(tmp);\n\t\t\t\t}\n\t\t\t\tif(tf==2) cnt++;\n\t\t\t}\n\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tstatic public int formula(String str){\n\t\tint left, right;\n\t\tint i = 0, flag = 0;\n\t\twhile(true){\n\t\t\tif(str.charAt(i)=='('){\n\t\t\t\tflag++;\n\t\t\t}else if(str.charAt(i)==')'){\n\t\t\t\tflag--;\n\t\t\t}else if(flag==0 && (str.charAt(i)=='+' || str.charAt(i)=='*')){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(++i==str.length()) break;\n\t\t}\n\n\t\tif(i==str.length()){\n\t\t\tint j = 0;\n\t\t\twhile(str.charAt(j)=='-') j++;\n\t\t\tif(j%2==0){\n\t\t\t\treturn str.charAt(j) - '0';\n\t\t\t}else{\n\t\t\t\treturn '2' - str.charAt(j);\n\t\t\t}\n\t\t}else{\n\t\t\tif(str.charAt(i-1)==')'){\n\t\t\t\tleft = formula(str.substring(1, i-1));\n\t\t\t}else{\n\t\t\t\tleft = formula(str.substring(0, i));\n\t\t\t}\n\t\t\tif(str.charAt(i+1)=='('){\n\t\t\t\tright = formula(str.substring(i+2, str.length()-1));\n\t\t\t}else{\n\t\t\t\tright = formula(str.substring(i+1, str.length()));\n\t\t\t}\n\n\t\t\tif(str.charAt(i)=='+'){\n\t\t\t\tif(left==2||right==2){\n\t\t\t\t\treturn 2;\n\t\t\t\t}else if(left==1||right==1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(left==0||right==0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(left==1||right==1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by S64 on 15/07/29.\n */\n\n\n// ????§?: 1??????34???43?§?\n// ??????: 0??????00???00?§? (????????????)\nclass Main {\n\n    enum Logic {\n        False,   // 0\n        Unknown, // 1\n        True,    // 2\n    }\n\n    enum Operator {\n        Not, // -\n        And, // *\n        Or,  // +\n    }\n\n    static class FormulaPattern {\n\n        public final Logic P;\n        public final Logic Q;\n        public final Logic R;\n\n        public FormulaPattern(Logic p, Logic q, Logic r) {\n            this.P = p;\n            this.Q = q;\n            this.R = r;\n        }\n\n    }\n\n    public static void main(String _[]) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true) {\n            String line = in.readLine();\n            if(line.equals(\".\"))\n                break;\n\n            int trueCount = 0;\n            int falseCount = 0;\n            int unknownCount = 0;\n\n            for(Logic p : Logic.values()) {\n                for(Logic q : Logic.values()) {\n                    for(Logic r : Logic.values()) {\n                        FormulaPattern x = new FormulaPattern(p, q, r);\n                        Logic result = Do(line.toCharArray(), x);\n\n                        if(result == Logic.True)\n                            trueCount++;\n                        if(result == Logic.False)\n                            falseCount++;\n                        if(result == Logic.Unknown)\n                            unknownCount++;\n                    }\n                }\n            }\n\n            System.out.println( String.format(\"%d\", trueCount) );\n            //System.out.println( String.format(\"  F: %d\", falseCount) );\n            //System.out.println( String.format(\"  U: %d\", unknownCount) );\n        }\n    }\n\n    static Logic Do(char[] line, FormulaPattern x) {\n        return Do(line, 0, x);\n    }\n\n    static Logic Do(char[] line, int position, FormulaPattern pattern) {\n        List<Operator> nextOperations = new ArrayList<Operator>();\n        int previousValue = -1;\n\n        for(int i = position; i < line.length ; i++) {\n            char chr = line[i];\n\n            if(chr == '(') {\n                previousValue = (Do(line, i + 1, pattern)).ordinal();\n                break;\n            } else if(chr == ')') {\n                break;\n            }\n\n            switch(chr) {\n                case '-':\n                    nextOperations.add(Operator.Not);\n                    break;\n                case '*':\n                    nextOperations.add(Operator.And);\n                    break;\n                case '+':\n                    nextOperations.add(Operator.Or);\n                    break;\n                case 'P':\n                case 'Q':\n                case 'R':\n                case '0':\n                case '1':\n                case '2':\n                    {\n                        int val;\n                        switch(chr) {\n                            case 'P':\n                                val = pattern.P.ordinal();\n                                break;\n                            case 'Q':\n                                val = pattern.Q.ordinal();\n                                break;\n                            case 'R':\n                                val = pattern.R.ordinal();\n                                break;\n                            default:\n                                val = Integer.parseInt(String.valueOf(chr));\n                                break;\n                        }\n                        for(Operator opr : nextOperations) {\n                            switch(opr) {\n                                case And:\n                                    /*\n                                    if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else if(previousValue == Logic.True.ordinal())\n                                        if(val != Logic.True.ordinal())\n                                            val = Logic.False.ordinal();\n                                    else if(previousValue == Logic.False.ordinal())\n                                            if(val != Logic.False.ordinal())\n                                                val = Logic.True.ordinal();\n                                    */\n                                    if(previousValue == val)\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    break;\n                                case Or:\n                                    /*\n                                    if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    */\n                                    if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    break;\n                                case Not:\n                                    if(val == Logic.True.ordinal())\n                                        val = Logic.False.ordinal();\n                                    else if(val == Logic.False.ordinal())\n                                        val = Logic.True.ordinal();\n                                    break;\n                            }\n                        }\n                        nextOperations.clear();\n                        {\n                            previousValue = val;\n                        }\n                    }\n                    break;\n            }\n\n        }\n\n        return Logic.values()[ previousValue ];\n    }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int p, q, r;\n\tstatic String s;\n\n\tstatic int and(int x, int y) {\n\t\treturn x < y ? x : y;\n\t}\n\n\tstatic int or(int x, int y) {\n\t\treturn x > y ? x : y;\n\t}\n\n\tstatic int not(int x) {\n\t\treturn x == 1 ? 1 : (x == 0 ? 2 : 0);\n\t}\n\n\tstatic int factor(int l) {\n\t\tif ('0' <= s.charAt(l) && s.charAt(l) <= '2') {\n\t\t\treturn s.charAt(l) - '0';\n\t\t}\n\t\tif (s.charAt(l) == 'P') {\n\t\t\treturn p;\n\t\t} else if (s.charAt(l) == 'Q') {\n\t\t\treturn q;\n\t\t} else {\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tstatic int formula(int l, int r) {\n\t\tif (l == r) return factor(l);\n\t\tif (s.charAt(l) == '-') {\n\t\t\treturn not(formula(l+1, r));\n\t\t}\n\t\tint lv = 0;\n\t\tfor (int i=l; i<=r; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tlv++;\n\t\t\t} else if (s.charAt(i) == ')') {\n\t\t\t\tlv--;\n\t\t\t}\n\n\t\t\tif (lv == 1 && s.charAt(i) == '*') {\n\t\t\t\treturn and(formula(l+1, i-1), formula(i+1, r-1));\n\t\t\t} else if (lv == 1 && s.charAt(i) == '+') {\n\t\t\t\treturn or(formula(l+1, i-1), formula(i+1, r-1));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tstatic boolean solve() {\n\t\ts = in.next();\n\t\tif (s.equals(\".\")) return false;\n\n\t\tint ans = 0;\n\n\t\tfor (p=0; p<=2; p++) {\n\t\t\tfor (q=0; q<=2; q++) {\n\t\t\t\tfor (r=0; r<=2; r++) {\n\t\t\t\t\tif (formula(0, s.length()-1) == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile (solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\tdump((end-start) + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.xml.crypto.Data;\n\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n     \n     \npublic class Main {\n\tstatic int W;\n\tstatic int H;\n\tstatic int N;\n\tstatic boolean[][] fld;\n\tstatic int[] vx = new int[] {0,1,0,-1};\n\tstatic int[] vy = new int[] {1,0,-1,0};\n\tstatic int id;\n\tstatic int P;\n\tstatic int Q;\n\tstatic int R;\n\tstatic String S;\n\tstatic int[][] A = new int[][] {{0,1,2},{1,1,2},{2,2,2}};\n\tstatic int[][] B = new int[][] {{0,0,0},{0,1,1},{0,1,2}};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tString in = sc.next();\n\t\t\tif(in.equals(\".\")) break;\n\t\t\tS = in;\n\t\t\tid = 0;\n\t\t\tint count = 0;\n\t\t\tfor(P = 0; P < 3; P++) {\n\t\t\t\tfor(Q = 0; Q < 3; Q++) {\n\t\t\t\t\tfor(R = 0; R < 3; R++) {\n\t\t\t\t\t\tid = 0;\n\t\t\t\t\t\tint ans = formula();\n\t\t\t\t\t\tif(ans == 2) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\tstatic int formula() {\n\t\tif(id == S.length()) return 0;\n\t\tif(S.charAt(id) == '0') {\n\t\t\tid++;\n\t\t\treturn 0;\n\t\t}\n\t\tif(S.charAt(id) == '1') {\n\t\t\tid++;\n\t\t\treturn 1;\n\t\t}\n\t\tif(S.charAt(id) == '2') {\n\t\t\tid++;\n\t\t\treturn 2;\n\t\t}\n\t\tif(S.charAt(id) == 'P') {\n\t\t\tid++;\n\t\t\treturn P;\n\t\t}\n\t\tif(S.charAt(id) == 'Q') {\n\t\t\tid++;\n\t\t\treturn Q;\n\t\t}\n\t\tif(S.charAt(id) == 'R') {\n\t\t\tid++;\n\t\t\treturn R;\n\t\t}\n\t\tif(S.charAt(id) == '-') {\n\t\t\tid++;\n\t\t\tint ret = formula();\n\t\t\tif(ret == 0) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif(ret == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(ret == 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(S.charAt(id) == '(') {\n\t\t\tid++;\n\t\t\tint A = formula();\n\t\t\tchar K = S.charAt(id);\n\t\t\tid++;\n\t\t\tint B = formula();\n\t\t\tid++;\n\t\t\tif(K == '*') {\n\t\t\t\treturn(Main.B[A][B]);\n\t\t\t}\n\t\t\telse if(K == '+') {\n\t\t\t\treturn Main.A[A][B];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn 0;\n\t\t\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by S64 on 15/07/29.\n */\n\n\n// ????§?: 1??????34???43?§?\n// ??????: 0??????00???00?§? (????????????)\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1460613\n    \n// ??????: -0??????07???03?§?\n// \n\nclass Main {\n\n    enum Logic {\n        False,   // 0\n        Unknown, // 1\n        True,    // 2\n    }\n\n    enum Operator {\n        Not, // -\n        And, // *\n        Or,  // +\n    }\n\n    static class FormulaPattern {\n\n        public final Logic P;\n        public final Logic Q;\n        public final Logic R;\n\n        public FormulaPattern(Logic p, Logic q, Logic r) {\n            this.P = p;\n            this.Q = q;\n            this.R = r;\n        }\n\n    }\n\n    public static void main(String _[]) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true) {\n            String line = in.readLine();\n            if(line.equals(\".\"))\n                break;\n\n            int trueCount = 0;\n            int falseCount = 0;\n            int unknownCount = 0;\n\n            for(Logic p : Logic.values()) {\n                for(Logic q : Logic.values()) {\n                    for(Logic r : Logic.values()) {\n                        FormulaPattern x = new FormulaPattern(p, q, r);\n                        Logic result = Do(line.toCharArray(), x);\n\n                        if(result == Logic.True)\n                            trueCount++;\n                        if(result == Logic.False)\n                            falseCount++;\n                        if(result == Logic.Unknown)\n                            unknownCount++;\n                    }\n                }\n            }\n\n            System.out.println( String.format(\"%d\", trueCount) );\n            //System.out.println( String.format(\"  F: %d\", falseCount) );\n            //System.out.println( String.format(\"  U: %d\", unknownCount) );\n        }\n    }\n\n    static Logic Do(char[] line, FormulaPattern x) {\n        return Do(line, 0, x);\n    }\n\n    static Logic Do(char[] line, int position, FormulaPattern pattern) {\n        List<Operator> nextOperations = new ArrayList<Operator>();\n        int previousValue = -1;\n\n        for(int i = position; i < line.length ; i++) {\n            char chr = line[i];\n\n            if(chr == '(') {\n                previousValue = (Do(line, i + 1, pattern)).ordinal();\n                break;\n            } else if(chr == ')') {\n                break;\n            }\n\n            switch(chr) {\n                case '-':\n                    nextOperations.add(Operator.Not);\n                    break;\n                case '*':\n                    nextOperations.add(Operator.And);\n                    break;\n                case '+':\n                    nextOperations.add(Operator.Or);\n                    break;\n                case 'P':\n                case 'Q':\n                case 'R':\n                case '0':\n                case '1':\n                case '2':\n                    {\n                        int val;\n                        switch(chr) {\n                            case 'P':\n                                val = pattern.P.ordinal();\n                                break;\n                            case 'Q':\n                                val = pattern.Q.ordinal();\n                                break;\n                            case 'R':\n                                val = pattern.R.ordinal();\n                                break;\n                            default:\n                                val = Integer.parseInt(String.valueOf(chr));\n                                break;\n                        }\n                        for(Operator opr : nextOperations) {\n                            switch(opr) {\n                                case And:\n                                    /*\n                                    if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else if(previousValue == Logic.True.ordinal())\n                                        if(val != Logic.True.ordinal())\n                                            val = Logic.False.ordinal();\n                                    else if(previousValue == Logic.False.ordinal())\n                                            if(val != Logic.False.ordinal())\n                                                val = Logic.True.ordinal();\n                                    */\n                                    /*\n                                    if(previousValue == val)\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    break;\n                                    */\n                                    if(previousValue == Logic.False.ordinal() || val == Logic.False.ordinal())\n                                        val = Logic.False.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.True.ordinal();\n\n                                case Or:\n                                    /*\n                                    if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    */\n                                    /*\n                                    if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                    break;\n                                    */\n                                    if(previousValue == Logic.True.ordinal() || val == Logic.True.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else if(previousValue == Logic.Unknown.ordinal() || val == Logic.Unknown.ordinal())\n                                        val = Logic.Unknown.ordinal();\n                                    else\n                                        val = Logic.False.ordinal();\n                                case Not:\n                                    if(val == Logic.False.ordinal())\n                                        val = Logic.True.ordinal();\n                                    else if(val == Logic.True.ordinal())\n                                        val = Logic.False.ordinal();\n                                    else\n                                        val = Logic.Unknown.ordinal();\n                                    break;\n                            }\n                        }\n                        nextOperations.clear();\n                        {\n                            previousValue = val;\n                        }\n                    }\n                    break;\n            }\n\n        }\n\n        return Logic.values()[ previousValue ];\n    }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\tpublic static interface Fomula{\n\t\tint eval(int[] input);\n\t}\n\t\n\tpublic static class Minus implements Fomula{\n\t\tFomula inner;\n\t\t\n\t\tpublic Minus(Fomula in){\n\t\t\tinner = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn 2 - inner.eval(input);\n\t\t}\n\t}\n\t\n\tpublic static class Add implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Add(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.max(left.eval(input), right.eval(input));\n\t\t}\n\t}\n\t\n\tpublic static class Mul implements Fomula{\n\t\tFomula left, right;\n\t\t\n\t\tpublic Mul(Fomula left, Fomula right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn Math.min(left.eval(input), right.eval(input));\n\t\t}\n\t}\n\t\n\tpublic static class Const implements Fomula{\n\t\tint con;\n\t\t\n\t\tpublic Const(int con){\n\t\t\tthis.con = con;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn con;\n\t\t}\n\t}\n\t\n\tpublic static class Var implements Fomula{\n\t\tint var;\n\t\t\n\t\tpublic Var(int v){\n\t\t\tvar = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int eval(int[] input) {\n\t\t\treturn input[var];\n\t\t}\n\t}\n\t\n\tpublic static Fomula parse(char[] input, int start, int end){\n\t\tint k_lv = 0;\n\t\tint k_s = -1, k_e = -1;\n\t\tint m_s = -1;\n\t\tint a_p = -1, m_p = -1;\n\t\t\n\t\tfor(int pos = start; pos <= end; pos++){\n\t\t\tif(input[pos] == '('){\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_s = pos;\n\t\t\t\t}\n\t\t\t\tk_lv++;\n\t\t\t}else if(input[pos] == ')'){\n\t\t\t\tk_lv--;\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_e = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(input[pos] == '-' && k_lv == 0){\n\t\t\t\tm_s = pos;\n\t\t\t}else if(input[pos] == '*' && k_lv == 1){\n\t\t\t\tm_p = pos;\n\t\t\t}else if(input[pos] == '+' && k_lv == 1){\n\t\t\t\ta_p = pos;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(k_s != -1 && k_e != -1){\n\t\t\tif(m_p != -1){\n\t\t\t\treturn new Mul(parse(input, k_s + 1, m_p - 1), parse(input, m_p + 1, k_e));\n\t\t\t}else{\n\t\t\t\treturn new Add(parse(input, k_s + 1, a_p - 1), parse(input, a_p + 1, k_e));\n\t\t\t}\n\t\t}else if(m_s != -1){\n\t\t\treturn new Minus(parse(input, m_s + 1, end));\n\t\t}else if('0' <= input[start] && input[start] <= '2'){\n\t\t\treturn new Const(input[start] - '0');\n\t\t}else {\n\t\t\treturn new Var(input[start] - 'P');\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\t\n\t\t\tif(\".\".equals(str)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tchar[] input = str.toCharArray();\n\t\t\t\n\t\t\tFomula fomula = parse(input, 0, input.length - 1);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tint[] array = new int[3];\n\t\t\tfor(int p = 0; p <= 2; p++){\n\t\t\t\tarray[0] = p;\n\t\t\t\t\n\t\t\t\tfor(int q = 0; q <= 2; q++){\n\t\t\t\t\tarray[1] = q;\n\t\t\t\t\t\n\t\t\t\t\tfor(int r = 0; r <= 2; r++){\n\t\t\t\t\t\tarray[2] = r;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(fomula.eval(array) == 2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p1155;\n\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int[] PQR;\n\tstatic int[] tuf = {0, 1, 2};// true, unknown, false\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tidx=0;\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = new char[80];\n\t\t\tPQR=new int[3];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i] = str.charAt(i);\n\t\t\t}\n\n\t\t\tint count=0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tPQR[0]=tuf[i];\n\t\t\t\t\t\tPQR[1]=tuf[j];\n\t\t\t\t\t\tPQR[2]=tuf[k];\n\t\t\t\t\t\tif(expression()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\tres = or(res, expression());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres = and(res, term());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=expression();\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = not(fact());\n\t\t}\n\t\telse{\n\t\t\tres = variable();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int variable(){\n\t\tif(s[idx]=='P'){\n\t\t\tidx++;\n\t\t\treturn PQR[0];\n\t\t}\n\t\telse if(s[idx]=='Q'){\n\t\t\tidx++;\n\t\t\treturn PQR[1];\n\t\t}\n\t\telse if(s[idx]=='R'){\n\t\t\tidx++;\n\t\t\treturn PQR[2];\n\t\t}\n\t\telse{\n\t\t\treturn s[idx++] - '0';\n\t\t}\n\t}\n\tstatic int or(int x, int y){\n\t\tif(x <= 1 && y <= 1){\n\t\t\tif(x == 0 && y == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t}\n\tstatic int and(int x, int y){\n\t\tif(x >= 1 && y >= 1){\n\t\t\tif(x == 2 && y == 2){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic int not(int x){\n\t\tif(x ==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(x==1){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int[] PQR;\n\tstatic int[] tuf = {0, 1, 2};// true, unknown, false\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tidx=0;\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = new char[81];\n\t\t\tPQR=new int[3];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i] = str.charAt(i);\n\t\t\t}\n\n\t\t\tint count=0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tPQR[0]=tuf[i];\n\t\t\t\t\t\tPQR[1]=tuf[j];\n\t\t\t\t\t\tPQR[2]=tuf[k];\n\t\t\t\t\t\tif(expression()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\tres = or(res, expression());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres = and(res, term());\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=expression();\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = not(fact());\n\t\t}\n\t\telse{\n\t\t\tres = variable();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int variable(){\n\t\tif(s[idx]=='P'){\n\t\t\tidx++;\n\t\t\treturn PQR[0];\n\t\t}\n\t\telse if(s[idx]=='Q'){\n\t\t\tidx++;\n\t\t\treturn PQR[1];\n\t\t}\n\t\telse if(s[idx]=='R'){\n\t\t\tidx++;\n\t\t\treturn PQR[2];\n\t\t}\n\t\telse{\n\t\t\treturn s[idx++] - '0';\n\t\t}\n\t}\n\tstatic int or(int x, int y){\n\t\tif(x <= 1 && y <= 1){\n\t\t\tif(x == 0 && y == 0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t}\n\tstatic int and(int x, int y){\n\t\tif(x >= 1 && y >= 1){\n\t\t\tif(x == 2 && y == 2){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic int not(int x){\n\t\tif(x ==0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(x==1){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tStack<Integer> st = new Stack<Integer>();\n    \tint stack(int P,int Q,int R,char ctr[]){\n    \t\tint cnt = 0;\n    \t\tfor(int i = 0;i < ctr.length;i++){\n    \t\t\tif(ctr[i] == ')'){\n    \t\t\t\tint result = st.pop();\n    \t\t\t\twhile(true){\n    \t\t\t\t\tint num = st.pop();\n    \t\t\t\t\tif(num == -1){\n    \t\t\t\t\t\tif(st.size() > 0){\n    \t\t\t\t\t\t\tint mainus = st.pop();\n    \t\t\t\t\t\t\tif(mainus == -2){\n    \t\t\t\t\t\t\t\tif(result == 0)result = 2;\n    \t    \t\t\t\t\t\telse if(result == 1)result = 1;\n    \t    \t\t\t\t\t\telse result = 0;\n    \t\t\t\t\t\t\t\tst.push(result);\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tst.push(mainus);\n    \t\t\t\t\t\t\t\tst.push(result);\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\tst.push(result);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\telse if(num == -2){\n    \t\t\t\t\t\tif(result == 0)result = 2;\n    \t\t\t\t\t\telse if(result == 1)result = 1;\n    \t\t\t\t\t\telse result = 0;\n    \t\t\t\t\t}else if(num == -3){\n    \t\t\t\t\t\tint num2 = st.pop();\n    \t\t\t\t\t\tresult = ((result|num2) == 3 ? 2:(result|num2));\n    \t\t\t\t\t}else if(num == -4){\n    \t\t\t\t\t\tint num2 = st.pop();\n    \t\t\t\t\t\tresult = result == num2 ? result:(result+num2) == 3 ? 1:0;\n    \t\t\t\t\t}\n    \t\t\t\t}\n//    \t\t\t\tSystem.out.println(st.toString());\n//    \t\t\t\tSystem.out.println(result);\n    \t\t\t}else{\n    \t\t\t\t//??°?????????\n    \t\t\t\tif(ctr[i] == '('){\n    \t\t\t\t\tif(cnt % 2 == 1)st.push(-2);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t\tst.push(-1);\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == 'P'){\n    \t\t\t\t\tif(cnt % 2 == 1){\n    \t\t\t\t\t\tif(P == 0)st.push(2);\n    \t\t\t\t\t\telse if(P == 1)st.push(1);\n    \t\t\t\t\t\telse st.push(0);\n    \t\t\t\t\t}else st.push(P);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == 'Q'){\n    \t\t\t\t\tif(cnt % 2 == 1){\n    \t\t\t\t\t\tif(Q == 0)st.push(2);\n    \t\t\t\t\t\telse if(Q == 1)st.push(1);\n    \t\t\t\t\t\telse st.push(0);\n    \t\t\t\t\t}else st.push(Q);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == 'R'){\n    \t\t\t\t\tif(cnt % 2 == 1){\n    \t\t\t\t\t\tif(R == 0)st.push(2);\n    \t\t\t\t\t\telse if(R == 1)st.push(1);\n    \t\t\t\t\t\telse st.push(0);\n    \t\t\t\t\t}else st.push(R);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '-'){\n    \t\t\t\t\tcnt++;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '+')st.push(-3);\n    \t\t\t\telse if(ctr[i] == '*')st.push(-4);\n    \t\t\t\telse if(ctr[i] == '0'){\n    \t\t\t\t\tif(cnt % 2 == 1)st.push(2);\n    \t\t\t\t\telse st.push(0);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '1'){\n    \t\t\t\t\tst.push(1);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t\telse if(ctr[i] == '2'){\n    \t\t\t\t\tif(cnt % 2 == 1)st.push(0);\n    \t\t\t\t\telse st.push(2);\n    \t\t\t\t\tcnt = 0;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn st.pop();\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tString str = sc.next();\n    \t\t\tif(str.equals(\".\"))break;\n    \t\t\tint ans = 0;\n    \t\t\tfor(int i = 0;i < 3;i++){\n    \t\t\t\tfor(int j = 0;j < 3;j++){\n    \t\t\t\t\tfor(int k = 0;k < 3;k++){\n//    \t\t\t\t\t\tSystem.out.println(\"+++++++\");\n    \t\t\t\t\t\tif(stack(i,j,k,str.toCharArray()) == 2)ans++;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println(ans);\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s = null;\n\tint at = 0;\n\tint p = -1, q = -1, r = -1;\n\t\n\tint[] t = {0, 1, 2};\n\tint[] f = {2, 1, 0};\n\t\n\tint[][] mu = {\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 1, 2}\n\t};\n\t\n\tint[][] ad = {\n\t\t\t{0, 1, 2},\n\t\t\t{1, 1, 2},\n\t\t\t{2, 2, 2}\n\t};\n\t\n\tint calc(int value, boolean not) {\n\t\treturn not ? f[value] : t[value];\n\t}\n\t\n\tint mult(int a, int b) {\n\t\treturn mu[a][b];\n\t}\n\t\n\tint add(int a, int b) {\n\t\treturn ad[a][b];\n\t}\n\t\n\tint formula() {\n\t\tboolean not = false;\n\t\tint n = s.length();\n\t\tint res = 0;\n\t\twhile (at < n) {\n\t\t\tchar c = s.charAt(at);\n\t\t\tswitch (c) {\n\t\t\tcase 'P' :\n\t\t\t\tres = calc(p, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Q' :\n\t\t\t\tres = calc(q, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase 'R' :\n\t\t\t\tres = calc(r, not);\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '0' :\n\t\t\tcase '1' :\n\t\t\tcase '2' :\n\t\t\t\tres = not ? f[c - '0'] : t[c - '0'];\n\t\t\t\tnot = false;\n\t\t\t\tbreak;\n\t\t\tcase '-' :\n\t\t\t\tnot = not ? false : true;\n\t\t\t\tbreak;\n\t\t\tcase '*' :\n\t\t\t\tat++;\n\t\t\t\tres = mult(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '+' :\n\t\t\t\tat++;\n\t\t\t\tres = add(res, formula());\n\t\t\t\tbreak;\n\t\t\tcase '(' :\n\t\t\t\tat++;\n\t\t\t\tres = formula();\n\t\t\t\tbreak;\n\t\t\tcase ')' :\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tat++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"-1\")) break;\n\t\t\t\n\t\t\tthis.s = s;\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\t\tfor (int j = 0; j <= 2; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 2; k++) {\n\t\t\t\t\t\tp = i; q = j; r = k;\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tint x = formula();\n\t\t\t\t\t\tif (x == 2) res++;\n\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tif(s[0] == '.') break;\n\t\t\tcount = 0;\n\t\t\ttable = new int[3];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic static int count;\n\tpublic static char[] s;\n\tpublic static int[] table;\n\tpublic static void dfs(int dep){\n\t\tif(dep == 3){\n\t\t\tidx = 0;\n\t\t\tif(formula() == 2) count++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0; i<3; i++){\n\t\t\ttable[dep] = i;\n\t\t\tdfs(dep+1);\n\t\t}\n\t}\n\t\n//\tpublic static final String var = \"012PQR\";\n\tpublic static final int[] not = {2, 1, 0};\n\tpublic static final int[][] mult = {\n\t\t{0, 0, 0},\n\t\t{0, 1, 1},\n\t\t{0, 1, 2},\n\t};\n\tpublic static final int[][] add = {\n\t\t{0, 1, 2},\n\t\t{1, 1, 2},\n\t\t{2, 2, 2},\n\t};\n\tpublic static int idx;\n\tpublic static int formula(){\n\t\tif(s[idx] == '-'){\n\t\t\tidx++;\n\t\t\treturn not[formula()];\n\t\t}\n\t\tif(s[idx] == '('){\n\t\t\tidx++;\n\t\t\tint val = formula();\n\t\t\tif(s[idx++] == '+'){\n\t\t\t\tval = add[val][formula()];\n\t\t\t}else{\n\t\t\t\tval = mult[val][formula()];\n\t\t\t}\n\t\t\tidx++;\n\t\t\treturn val;\n\t\t}\n\t\tif('0' <= s[idx] && s[idx] <= '2'){\n\t\t\treturn s[idx++] - '0';\n\t\t}\n\t\treturn table[s[idx++]-'P'];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n\tstatic char[] key = new char[100];\n\tstatic int[] vari = new int[3];\n\tstatic int idx;\n\tstatic int cnt;\n\t\n\tstatic int formula(){\n\t\t\n\t\tif(key[idx]=='0'||key[idx]=='1'||key[idx]=='2'){\n\t\t\treturn (int)key[idx]-'0';\n\t\t}\n\t\telse if(key[idx]=='P'){\n\t\t\treturn vari[0];\n\t\t}\n\t\telse if(key[idx]=='Q'){\n\t\t\treturn vari[1];\n\t\t}\n\t\telse if(key[idx]=='R'){\n\t\t\treturn vari[2];\n\t\t}\n\t\telse if(key[idx]=='-'){\n\t\t\tidx++;\n\t\t\tint tmp = formula();\n\t\t\treturn 2-tmp;\n\t\t}\n\t\telse if(key[idx]=='('){\n\t\t\tidx++;\n\t\t\tint tmp1=formula();\n\t\t\tidx++;\n\t\t\tint op = key[idx];\n\t\t\tidx++;\n\t\t\tint tmp2 =formula();\n\t\t\tidx++;\n\t\t\tif(op=='*'){\n\t\t\t\tif(tmp1==2&&tmp2==2){\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\telse if(tmp1>=1&&tmp2>=1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op=='+'){\n\t\t\t\tif(tmp1==0&&tmp2==0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if(tmp1==2||tmp2==2){\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -100;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString a = stdIn.readLine();\n\t\t\tkey = a.toCharArray();\n\t\t\tif(key[0]=='.'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tidx=0;\n\t\t\tcnt=0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\t\tvari[0]=i;\n\t\t\t\t\t\tvari[1]=j;\n\t\t\t\t\t\tvari[2]=k;\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tint result=formula();\n\t\t\t\t\t\tif(result==2){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tString s;\n\tint[] map;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\ts = sc.next();\n\t\t\tif (s.equals(\".\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tmap = new int[256];\n\t\tmap['0'] = 0;\n\t\tmap['1'] = 1;\n\t\tmap['2'] = 2;\n\t\tint ans = 0;\n\n\t\t/*\n\t\tmap['P'] = 0;\n\t\tmap['Q'] = 0;\n\t\tmap['R'] = 1;\n\n\t\tdebug(f(0).value);\n\n\t\tif (5 == 5) {\n\t\t\treturn;\n\t\t}*/\n\n\t\tfor (int p = 0; p < 3; p++) {\n\t\t\tfor (int q = 0; q < 3; q++) {\n\t\t\t\tfor (int r = 0; r < 3; r++) {\n\t\t\t\t\tmap['P'] = p;\n\t\t\t\t\tmap['Q'] = q;\n\t\t\t\t\tmap['R'] = r;\n\t\t\t\t\tResult res = f(0);\n\t\t\t\t\t//debug(p, q, r, res.value);\n\t\t\t\t\tif (res.value == 2) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(ans + \"\");\n\t}\n\n\tResult f(int p) {\n\t\t// debug(\"f\",p);\n\t\tif (Character.isDigit(s.charAt(p))\n\t\t\t\t|| Character.isUpperCase(s.charAt(p))) {\n\t\t\treturn new Result(p + 1, map[s.charAt(p)]);\n\t\t} else if (s.charAt(p) == '-') {\n\t\t\tResult r = f(p + 1);\n\t\t\tr.value = 2 - r.value;\n\t\t\treturn r;\n\t\t} else {\n\t\t\tResult r = f(p + 1);\n\t\t\tResult r2 = f(r.p + 1); // skip '*' or '+'\n\n\t\t\t// debug(\"res1\",r.p, r.value);\n\t\t\t// debug(\"res2\",r2.p, r2.value);\n\t\t\t// debug(s.charAt(r.p));\n\t\t\t\n\t\t\tif (s.charAt(r.p) == '*') {\n\t\t\t\tr.value = min(r.value, r2.value);\n\t\t\t} else {\n\t\t\t\t// '+'\n\t\t\t\tr.value = max(r.value, r2.value);\n\t\t\t}\n\t\t\tr.p=r2.p+1;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tclass Result {\n\t\tint p, value;\n\n\t\tResult(int p, int value) {\n\t\t\tthis.p = p;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    String[] AND = {\"(0*0)\",\"(0*1)\",\"(0*2)\",\n                    \"(1*0)\",\"(1*1)\",\"(1*2)\",\n                    \"(2*0)\",\"(2*1)\",\"(2*2)\"};\n    String[] AND_RESULT = {\"0\",\"0\",\"0\",\n                           \"0\",\"1\",\"1\",\n                           \"0\",\"1\",\"2\"};\n    String[] OR = {\"(0+0)\",\"(0+1)\",\"(0+2)\",\n                   \"(1+0)\",\"(1+1)\",\"(1+2)\",\n                   \"(2+0)\",\"(2+1)\",\"(2+2)\"};\n    String[] OR_RESULT = {\"0\",\"1\",\"2\",\n                          \"1\",\"1\",\"2\",\n                          \"2\",\"2\",\"2\"};\n    String[] INV = {\"-0\",\"-1\",\"-2\"};\n    String[] INV_RESULT = {\"2\",\"1\",\"0\"};\n    \n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            String exp = sc.next().replace(\"--\", \"\");\n            if(exp.equals(\".\")){\n                break;\n            }\n            int count = 0;\n            for(int p = 0; p <= 2; p++){\n                for(int q = 0; q <= 2; q++){\n                    for(int r = 0; r <= 2; r++){\n                        String tmp = exp.replace(\"P\", p + \"\");\n                        tmp = tmp.replace(\"Q\", q + \"\");\n                        tmp = tmp.replace(\"R\", r + \"\");\n                        if(calc(tmp).equals(\"2\")){\n                            count++;\n                        }\n                    }\n                }                \n            }\n            System.out.println(count);\n        }\n\n    }\n    String calc(String exp){\n        //System.out.println(\"init: \" + exp);\n        while(exp.length() != 1){\n            for(int i = 0; i < INV.length; i++){\n                exp = exp.replace(INV[i], INV_RESULT[i]);\n            }\n            for(int i = 0; i < AND.length; i++){\n                exp = exp.replace(AND[i], AND_RESULT[i]);\n            }\n            for(int i = 0; i < OR.length; i++){\n                exp = exp.replace(OR[i], OR_RESULT[i]);\n            }\n        }\n        //System.out.println(\"return: \" + exp);\n        return exp;\n    }\n    public static void main(String[] args){\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package icpc2008_java;\n\nimport java.util.Scanner;\n\npublic class C {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\tsb.delete(i, i + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ティツィツ暗ァツョツ療ァツオツ静ヲツ楪? c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegRemove(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegate(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tcalc(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tremoveNest(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.printf(\"p,q,r = %d %d %d -> %s\\n\", p, q,\n\t\t\t\t\t\t// r,\n\t\t\t\t\t\t// f.toString());\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tStack<Integer> st = new Stack<Integer>();\n    \tint stack(int P,int Q,int R,char ctr[]){\n    \t\tfor(int i = 0;i < ctr.length;i++){\n    \t\t\tif(ctr[i] == ')'){\n    \t\t\t\tint result = st.pop();\n    \t\t\t\twhile(true){\n    \t\t\t\t\tint num = st.pop();\n    \t\t\t\t\tif(num == -1){\n    \t\t\t\t\t\tst.push(result);\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\telse if(num == -2){\n    \t\t\t\t\t\tif(result == 0)result = 2;\n    \t\t\t\t\t\telse if(result == 1)result = 1;\n    \t\t\t\t\t\telse result = 0;\n    \t\t\t\t\t}else if(num == -3){\n    \t\t\t\t\t\tint num2 = st.pop();\n    \t\t\t\t\t\tresult = ((result|num2) == 3 ? 2:(result|num2));\n    \t\t\t\t\t}else if(num == -4){\n    \t\t\t\t\t\tint num2 = st.pop();\n    \t\t\t\t\t\tresult = result == num2 ? result:(result+num2) == 3 ? 1:0;\n    \t\t\t\t\t}\n    \t\t\t\t}\n//    \t\t\t\tSystem.out.println(st.toString());\n//    \t\t\t\tSystem.out.println(result);\n    \t\t\t}else{\n    \t\t\t\t//??°?????????\n    \t\t\t\tif(ctr[i] == '(')st.push(-1);\n    \t\t\t\telse if(ctr[i] == 'P')st.push(P);\n    \t\t\t\telse if(ctr[i] == 'Q')st.push(Q);\n    \t\t\t\telse if(ctr[i] == 'R')st.push(R);\n    \t\t\t\telse if(ctr[i] == '-')st.push(-2);\n    \t\t\t\telse if(ctr[i] == '+')st.push(-3);\n    \t\t\t\telse if(ctr[i] == '*')st.push(-4);\n    \t\t\t\telse if(ctr[i] == '0')st.push(0);\n    \t\t\t\telse if(ctr[i] == '1')st.push(1);\n    \t\t\t\telse if(ctr[i] == '2')st.push(2);\n    \t\t\t}\n    \t\t}\n    \t\treturn st.pop();\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tString str = sc.next();\n    \t\t\tif(str.equals(\".\"))break;\n    \t\t\tint ans = 0;\n    \t\t\tfor(int i = 0;i < 3;i++){\n    \t\t\t\tfor(int j = 0;j < 3;j++){\n    \t\t\t\t\tfor(int k = 0;k < 3;k++){\n//    \t\t\t\t\t\tSystem.out.println(\"+++++++\");\n    \t\t\t\t\t\tif(stack(i,j,k,str.toCharArray()) == 2)ans++;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println(ans);\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint P,Q, R;\n\tString line;\n\tint pos;\n\tvoid run() {\n\t\tfor(;;) {\n\t\t\tline = sc.nextLine();\n\t\t\tif( line.equals(\".\") ) break;\n\t\t\tint cnt = 0;\n\t\t\tfor(P=0;P<3;P++) for(Q=0;Q<3;Q++) for(R=0;R<3;R++) {\n\t\t\t\tpos = 0;\n\t\t\t\tif(formula() == 2) cnt++;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\t\n\t}\n\t\n\tint formula() {\n\t\tchar c = line.charAt(pos);\n\t\tint value = val( c );\n\t\tif( value >= 0 ) { pos++; return value; }\n\t\t\n\t\tif( c == '-' ){\n\t\t\tpos++;\n\t\t\treturn not(formula());\n\t\t}\n\t\tpos++;\n\t\tint a = formula();\n\t\tchar cc = line.charAt(pos++);\n\t\tint b = formula();\n\t\tpos++;\n\t\t\n\t\tif( cc == '*' ) {\n\t\t\treturn and(a, b);\n\t\t}\n\t\t\n\t\treturn or(a, b);\n\t}\n\t\n\tint val(char c) {\n\t\tswitch (c) {\n\t\tcase ('0'): return 0;\n\t\tcase ('1'): return 1;\n\t\tcase ('2'): return 2;\n\t\tcase ('P'): return P;\n\t\tcase ('Q'): return Q;\n\t\tcase ('R'): return R;\n\t\tdefault:    return -1;\n\t\t}\n\t}\n\t\t\n\t\n\tint not( int x ) {\n\t\treturn 2-x;\n\t}\n\t\n\tint and (int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\t\n\tint or ( int x, int y ) {\n\t\treturn Math.max(x, y);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    String line = sc.next();\n\t    if(line.equals(\".\")) break;\n\t    \n\t    in = new char[line.length()];\n\t    p = 0;\n\t    \n\t    int cnt = 0;\n\t    for(int P=0; P<=2; P++){\n\t\tfor(int Q=0; Q<=2; Q++){\n\t\t    for(int R=0; R<=2; R++){\n\t\t\t\n\t\t\tfor(int i=0; i<line.length(); i++){\n\t\t\t    in[i] = line.charAt(i);\n\t\t\t    if(in[i]=='P') in[i] = (char)(P+'0');\n\t\t\t    if(in[i]=='Q') in[i] = (char)(Q+'0');\n\t\t\t    if(in[i]=='R') in[i] = (char)(R+'0');\n\t\t\t}\n\t\t\tp = 0;\n\t\t\tint ans = formula();\n\t\t\t//System.out.println(Arrays.toString(in)+\" \"+ans);\n\t\t\tif(ans==2) cnt++;\n\t\t\t\n\t\t    }\n\t\t}\n\t    }\n\t    \n\t    System.out.println(cnt);\n\t}\n    }\n\n    int formula(){\n\tint res = 0;\n\tif(p<in.length && Character.isDigit(in[p])){\n\t    res = in[p] - '0';\n\t    p++;\n\t}else if(p<in.length && in[p]=='-'){\n\t    p++;\n\t    res = mai(formula());\n\t    //p++;\n\t}else if(p<in.length && in[p]=='('){\n\t    p++;\n\t    int a = formula();\n\t    //p++;\n\t    boolean boo = false;\n\t    if(in[p]=='+') boo = true;\n\t    p++;\n\t    int b = formula();\n\t    //System.out.println(a+\" \"+b);\n\t    p++;\n\t    if(boo) res = plus(a, b);\n\t    else res = mul(a, b);\n\t}\n\treturn res;\n    }\n\n    int[] c1 = {2,1,0};\n    int[][] c2 = {{0,0,0},{0,1,1},{0,1,2}};\n    int[][] c3 = {{0,1,2},{1,1,2},{2,2,2}};\n    int mai(int x){ return c1[x]; }\n    int mul(int x, int y){ return c2[x][y]; }\n    int plus(int x, int y){ return c3[x][y]; }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}\n\n\t       "
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int and[][] = { { 0, 0, 0 }, { 0, 1, 1 }, { 0, 1, 2 } };// i*j\n\tstatic int or[][] = { { 0, 1, 2 }, { 1, 1, 2 }, { 2, 2, 2 } };\n\n\tstatic boolean isNum(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tstatic void replace(StringBuilder sb, int p, int q, int r) {\n\t\tfor (int i = 0; i < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == 'P') {\n\t\t\t\tsb.setCharAt(i, (char) (p + '0'));\n\t\t\t} else if (sb.charAt(i) == 'Q') {\n\t\t\t\tsb.setCharAt(i, (char) (q + '0'));\n\t\t\t} else if (sb.charAt(i) == 'R') {\n\t\t\t\tsb.setCharAt(i, (char) (r + '0'));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negRemove(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && sb.charAt(i + 1) == '-') {\n\t\t\t\tsb.delete(i, i + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void negate(StringBuilder sb) {\n\t\tfor (int i = 0; i + 1 < sb.length(); i++) {\n\t\t\tif (sb.charAt(i) == '-' && isNum(sb.charAt(i + 1))) {\n\t\t\t\t// -0 -> 2\n\t\t\t\t// -1 -> 1\n\t\t\t\t// -2 -> 0\n\t\t\t\tchar c = sb.charAt(i + 1);\n\t\t\t\tif (c == '0') {\n\t\t\t\t\tsb.setCharAt(i + 1, '2');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else if (c == '1') {\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tsb.setCharAt(i + 1, '0');\n\t\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void calc(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ?¨??????????, c=l+r, c=l*r\n\t\t\tif (isNum(l) && isNum(r)) {\n\t\t\t\tif (m == '+') {\n\t\t\t\t\tc = (char) (or[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t} else if (m == '*') {\n\t\t\t\t\tc = (char) (and[l - '0'][r - '0'] + '0');\n\t\t\t\t\tsb.setCharAt(i, c);\n\t\t\t\t\tsb.delete(i + 1, i + 1 + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void removeNest(StringBuilder sb) {\n\t\tfor (int i = 0; i + 2 < sb.length(); i++) {\n\t\t\tchar l, m, r;\n\t\t\tl = sb.charAt(i);\n\t\t\tm = sb.charAt(i + 1);\n\t\t\tr = sb.charAt(i + 2);\n\t\t\tchar c;// ?¨??????????, c=l+r, c=l*r\n\t\t\tif (l == '(' && r == ')' && isNum(m)) {\n\t\t\t\tsb.delete(i, i + 1);\n\t\t\t\tsb.delete(i + 1, i + 1 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tStringBuilder f = new StringBuilder(in.next());\n\t\t\tStringBuilder origin = new StringBuilder(f.toString());\n\t\t\tif (f.toString().equals(\".\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tf = new StringBuilder(origin.toString());\n\t\t\t\t\t\twhile (f.length() > 1) {\n\t\t\t\t\t\t\treplace(f, p, q, r);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegRemove(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tnegate(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tcalc(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t\tremoveNest(f);\n\t\t\t\t\t\t\t// System.out.println(f.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// System.out.printf(\"p,q,r = %d %d %d -> %s\\n\", p, q,\n\t\t\t\t\t\t// r,\n\t\t\t\t\t\t// f.toString());\n\t\t\t\t\t\tif (f.charAt(0) == '2') {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = sc.next();\n\t\t\tif (line.equals(\".\")) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int p = 0; p <= 2; p++) {\n\t\t\t\tfor (int q = 0; q <= 2; q++) {\n\t\t\t\t\tfor (int r = 0; r <= 2; r++) {\n\t\t\t\t\t\tString tmp = line.replaceAll(\"P\", String.valueOf(p));\n\t\t\t\t\t\ttmp = tmp.replaceAll(\"Q\", String.valueOf(q));\n\t\t\t\t\t\ttmp = tmp.replaceAll(\"R\", String.valueOf(r));\n\t\t\t\t\t\twhile (tmp.length() > 1) {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tint k = tmp.length();\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"-0\", \"2\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"-1\", \"1\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"-2\", \"0\");\n\t\t\t\t\t\t\t\tif (tmp.length() == k) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tint k = tmp.length();\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\(2\\\\*2\\\\)\", \"2\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\([12]\\\\*1\\\\)\", \"1\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\(1\\\\*[12]\\\\)\", \"1\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\([012]\\\\*0\\\\)\", \"0\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\(0\\\\*[012]\\\\)\", \"0\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\(0\\\\+0\\\\)\", \"0\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\(1\\\\+[01]\\\\)\", \"1\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\([01]\\\\+1\\\\)\", \"1\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\([012]\\\\+2\\\\)\", \"2\");\n\t\t\t\t\t\t\t\ttmp = tmp.replaceAll(\"\\\\(2\\\\+[012]\\\\)\", \"2\");\n\t\t\t\t\t\t\t\tif (tmp.length() == k) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tmp.equals(\"2\")) {\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tString s = ir.next();\n\t\t\tif (s.charAt(0) == '.')\n\t\t\t\treturn;\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tString t = s.replace(\"P\", String.valueOf(i)).replace(\"Q\", String.valueOf(j)).replace(\"R\",\n\t\t\t\t\t\t\t\tString.valueOf(k));\n\t\t\t\t\t\tif (calc(t) == 2)\n\t\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ret);\n\t\t}\n\t}\n\n\tstatic int calc(String s) {\n\t\tif (s.charAt(0) != '(')\n\t\t\treturn convert(s);\n\t\telse {\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tif (s.charAt(i) == '(')\n\t\t\t\t\td++;\n\t\t\t\telse if (s.charAt(i) == ')')\n\t\t\t\t\td--;\n\t\t\t\telse if (d == 1 && (s.charAt(i) == '+' || s.charAt(i) == '*')) {\n\t\t\t\t\tif (s.charAt(i) == '+')\n\t\t\t\t\t\treturn Math.max(calc(s.substring(1, i)), calc(s.substring(i + 1, s.length() - 1)));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn Math.min(calc(s.substring(1, i)), calc(s.substring(i + 1, s.length() - 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic int convert(String s) {\n\t\tint p = 0;\n\t\twhile (p < s.length() && s.charAt(p) == '-')\n\t\t\tp++;\n\t\tif (s.length() - p == 1) {\n\t\t\tint a = Integer.parseInt(s.substring(s.length() - 1));\n\t\t\tif (a == 1)\n\t\t\t\treturn 1;\n\t\t\tif (s.length() % 2 == 0)\n\t\t\t\treturn (a + 2) % 4;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t} else {\n\t\t\tint a = calc(s.substring(p));\n\t\t\tif (a == 1)\n\t\t\t\treturn 1;\n\t\t\tif (s.length() % 2 == 0)\n\t\t\t\treturn (a + 2) % 4;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tint p,q,r;\n\tclass Token{\n\t\t/**\n\t\t * 0 0 \n\t\t * 1 1 \n\t\t * 2 2\n\t\t * + 3\n\t\t * * 4\n\t\t * p 5\n\t\t * q 6\n\t\t * r 7\n\t\t * - 8\n\t\t */\n\t\tint type;\n\t\t\n\t\t\n\t\tToken(String str){\n\t\t\tif(str.length() == 1){\n\t\t\t\tif(str.equals(\"0\")){\n\t\t\t\t\tthis.type = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str.equals(\"1\")){\n\t\t\t\t\tthis.type = 1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str.equals(\"2\")){\n\t\t\t\t\tthis.type = 2;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str.equals(\"P\")){\n\t\t\t\t\tthis.type = 5;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str.equals(\"Q\")){\n\t\t\t\t\tthis.type = 6;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str.equals(\"R\")){\n\t\t\t\t\tthis.type = 7;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str.startsWith(\"-\")){\n\t\t\t\tthis.type = 8;\n\t\t\t\tthis.child1 = new Token(str.substring(1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint depth = 0;\n\t\t\tint tp = 0;\n\t\t\tfor(int i = 1; i < str.length() - 1 ; i++){\n\t\t\t\tif(str.charAt(i) == '('){\n\t\t\t\t\tdepth++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(str.charAt(i) == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t}\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tif(str.charAt(i) == '+'){\n\t\t\t\t\t\tthis.type = 3;\n\t\t\t\t\t\ttp = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.charAt(i) == '*'){\n\t\t\t\t\t\tthis.type = 4;\n\t\t\t\t\t\ttp = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.child1 = new Token(str.substring(1,tp));\n\t\t\tthis.child2 = new Token(str.substring(tp+1,str.length()-1));\n\t\t}\n\t\t\n\t\tToken child1;\n\t\tToken child2;\n\t\t\n\t\tint getValue(){\n\t\t\tswitch(type){\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t\tcase 1 :\n\t\t\t\treturn 1;\n\t\t\tcase 2 : \n\t\t\t\treturn 2;\n\t\t\tcase 3 :\n\t\t\t\treturn Math.max(child1.getValue() , child2.getValue());\n\t\t\tcase 4 :\n\t\t\t\treturn Math.min(child1.getValue() , child2.getValue());\n\t\t\tcase 5 :\n\t\t\t\treturn p;\n\t\t\tcase 6 :\n\t\t\t\treturn q;\n\t\t\tcase 7 :\n\t\t\t\treturn r;\n\t\t\tcase 8 :\n\t\t\t\treturn 2 - child1.getValue();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\n\t\tfor (;;) {\n\t\t\tString in = sc.next();\n\t\t\tif(in.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tToken t = new Token(in);\n\t\t\tfor(p = 0; p < 3; p++){\n\t\t\t\tfor(q = 0; q < 3; q++){\n\t\t\t\t\tfor(r = 0; r < 3; r++){\n\t\t\t\t\t\tif(t.getValue() == 2){\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] Aregs) {\n\t\tMain a = new Main();\n\t\ta.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n\tScanner sc;\n\tpublic void run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString n = sc.next();\n\t\t\tif(n.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcalc(n);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void calc(String line){\n\t\tstr = line;\n\t\tFormula tree = getTree();\n\t\t\n\t\tint ans = 0;\n\t\tfor(int p = 0; p < 3; p++){\n\t\t\tfor(int q = 0; q < 3; q++){\n\t\t\t\tfor(int r = 0; r < 3; r++){\n\t\t\t\t\tint n = tree.calc(p, q, r);\n\t\t\t\t\tif(n == 2) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tString str;\n\t\n\tpublic Formula getTree(){\n\t\tString s = str.substring(0,1);\n\t\tstr = str.substring(1);\n\t\t\n\t\tif(s.equals(\"0\") || s.equals(\"1\") || s.equals(\"2\")){\n\t\t\treturn new NumFormula(Integer.valueOf(s));\n\t\t}\n\t\telse if(s.equals(\"P\") || s.equals(\"Q\") || s.equals(\"R\")){\n\t\t\treturn new StringFormula(s);\n\t\t}\n\t\telse if(s.equals(\"-\")){\n\t\t\tFormula f = getTree();\n\t\t\treturn new NotFormula(f);\n\t\t}\n\t\telse{\n\t\t\tFormula f1 = getTree();\n\t\t\ts = str.substring(0,1);\n\t\t\tstr = str.substring(1);\n\t\t\tFormula f2 = getTree();\n\t\t\tFormula f;\n\t\t\tif(s.equals(\"*\")){\n\t\t\t\tf = new AndFormula(f1, f2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf = new OrFormula(f1, f2);\n\t\t\t}\n\t\t\tstr = str.substring(1);\n\t\t\treturn f;\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}\n\nclass Formula{\n\tint calc(int p, int q, int r){\n\t\treturn 0;\n\t}\n}\nclass NotFormula extends Formula{\n\tFormula f1;\n\tint[] list = new int[]{2,1,0};\n\tNotFormula(Formula f){\n\t\tthis.f1 = f;\n\t}\n\tint calc(int p, int q, int r){\n\t\tint c = f1.calc(p, q, r);\n\t\treturn list[c];\n\t}\n}\nclass AndFormula extends Formula{\n\tFormula f1;\n\tFormula f2;\n\tint[][] list = new int[][]{{0,0,0},{0,1,1},{0,1,2}};\n\tAndFormula(Formula f1, Formula f2){\n\t\tthis.f1 = f1;\n\t\tthis.f2 = f2;\n\t}\n\tint calc(int p, int q, int r){\n\t\tint c1 = f1.calc(p, q, r);\n\t\tint c2 = f2.calc(p, q, r);\n\t\treturn list[c1][c2];\n\t}\n}\nclass OrFormula extends Formula{\n\tFormula f1;\n\tFormula f2;\n\tint[][] list = new int[][]{{0,1,2},{1,1,2},{2,2,2}};\n\tOrFormula(Formula f1, Formula f2){\n\t\tthis.f1 = f1;\n\t\tthis.f2 = f2;\n\t}\n\tint calc(int p, int q, int r){\n\t\tint c1 = f1.calc(p,q,r);\n\t\tint c2 = f2.calc(p,q,r);\n\t\treturn list[c1][c2];\n\t}\n}\nclass NumFormula extends Formula{\n\tint num;\n\tNumFormula(int n){\n\t\tthis.num = n;\n\t}\n\tint calc(int p, int q, int r){\n\t\treturn num;\n\t}\n}\nclass StringFormula extends Formula{\n\tString s;\n\tStringFormula(String s){\n\t\tthis.s = s;\n\t}\n\tint calc(int p, int q, int r){\n\t\tif(s.equals(\"P\")) return p;\n\t\telse if(s.equals(\"Q\")) return q;\n\t\telse return r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tstatic int[] PQR = {0,0,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str = cin.next();\n\t\t\tif(str.equals(\".\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = (str+\"     \").toCharArray();\n\t\t\tidx=0;\n\t\t\tint count=0;\n\t\t\tfor(int i = 0;i <3;i++){\n\t\t\t\tfor(int j = 0;j<3;j++){\n\t\t\t\t\tfor(int k = 0;k<3;k++){\n\t\t\t\t\t\tidx=0;\n\t\t\t\t\t\tPQR[0]=i;\n\t\t\t\t\t\tPQR[1]=j;\n\t\t\t\t\t\tPQR[2]=k;\n\t\t\t\t\t\tif(formula()==2){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic int formula(){\n\t\tint res = 0;\n\t\tif(s[idx]=='0'){\n\t\t\tres = 0;\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='1'){\n\t\t\tres = 1;\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='2'){\n\t\t\tres = 2;\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='P'){\n\t\t\tres = PQR[0];\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='Q'){\n\t\t\tres = PQR[1];\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='R'){\n\t\t\tres = PQR[2];\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\tres = minus(formula());\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = formula();\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres = and(res, formula());\n\t\t\t}\n\t\t\telse if(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres = or(res, formula());\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int minus(int a){\n\t\tif(a == 0){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(a==2){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n\tstatic int and(int a, int b){\n\t\tif(a+b==4){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(a==0||b==0){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n\tstatic int or(int a,int b){\n\t\tif(a+b==0){\n\t\t\treturn 0;\n\t\t}\n\t\telse if(a==2||b==2){\n\t\t\treturn 2;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/** top-down syntax analysis (BNF) */\npublic class Main {\n\tprivate static int pos;\n\tprivate static int p;\n\tprivate static int q;\n\tprivate static int r;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString input = sc.nextLine();\n\t\t\tif(input.equals(\".\")) break;\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(p = 0; p < 3; p++){\n\t\t\t\tfor(q = 0; q < 3; q++){\n\t\t\t\t\tfor(r = 0; r < 3; r++){\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\tint ret = formula(input);\n\t\t\t\t\t\tif(ret == 2) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate static int formula(String input){\n\t\tchar c = input.charAt(pos++);\n\t\t\n\t\tif(c == '0') return 0;\n\t\tif(c == '1') return 1;\n\t\tif(c == '2') return 2;\n\t\tif(c == 'P') return p;\n\t\tif(c == 'Q') return q;\n\t\tif(c == 'R') return r;\n\t\t\n\t\tif(c == '-'){\n\t\t\tint ret = formula(input);\n\t\t\treturn (2 - ret);\n\t\t}\n\t\t\n\t\t// c = '('\n\t\tint n1 = formula(input);\n\t\tboolean multi = (input.charAt(pos++) == '*');\n\t\tint n2 = formula(input);\n\t\tpos++;/*   next char   <-   c = ')' */\n\t\tif(multi){\n\t\t\t/* (2 * 2 = 2) , (1 * 1 = 1), (0 * 0 = 0) */\n\t\t\tif(n1 == n2) return n1;\n\t\t\tif(n1 * n2 > 0) return 1;/* (1 * 2 = 1) */\n\t\t\treturn 0;/* (0 * ? = 0) */\n\t\t}else{\n\t\t\treturn Math.max(n1, n2);/* n1 + n2 */\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  int[] atom = new int[3];\n  char[] str;\n  int index;\n\n  boolean isAtom(char c) {\n    switch ( c ) {\n    case '0':\n    case '1':\n    case '2':\n    case 'P':\n    case 'Q':\n    case 'R':\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  Tree make() {\n    Tree tree = new Tree();\n    if ( isAtom(str[index]) ) {\n      tree.type = str[index];\n      ++index;\n    } else {\n      if(str[index] == '-') {\n        tree.type = str[index++];\n        tree.left = make();\n      } else {\n        ++index; // (\n        tree.left = make();\n//        debug(index, str[index]);\n        tree.type = str[index++];\n        tree.right = make();\n        ++index; // )\n      }\n    }\n    return tree;\n  }\n\n  class Tree {\n    char type;\n\n    Tree left;\n    Tree right;\n\n    Tree() {\n    }\n\n    int exp() {\n      switch ( type ) {\n      case '0':\n      case '1':\n      case '2':\n        return type - '0';\n      case 'P':\n      case 'Q':\n      case 'R':\n        return atom[ type - 'P' ];\n      case '+':\n        return Math.max( left.exp(), right.exp() );\n      case '*':\n        return Math.min( left.exp(), right.exp() );\n      case '-':\n        return 2 - left.exp();\n      default:\n        return -1;\n      }\n    }\n  }\n\n  void run() {\n    for ( ;; ) {\n      str = sc.next().toCharArray();\n      if ( str[ 0 ] == '.' ) {\n        break;\n      }\n      index = 0;\n      Tree root = make();\n      int cnt = 0;\n      for ( int i = 0; i < 3; ++i ) {\n        for ( int j = 0; j < 3; ++j ) {\n          for ( int k = 0; k < 3; ++k ) {\n            atom[ 0 ] = i;\n            atom[ 1 ] = j;\n            atom[ 2 ] = k;\n            if ( root.exp() == 2 ) {\n              ++cnt;\n            }\n          }\n        }\n      }\n      System.out.println( cnt );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Contest\n{\n    class Program\n    {\n        static int Main(string[] args)\n        {\n            new Program().Process();\n\n            return 0;\n        }\n\n        private CommonInput cin;\n\n        private void Process()\n        {\n            cin = new CommonInput();\n\n            string formula;\n\n            int count;\n            bool inP, inQ, inR;\n\n            while (true)\n            {\n                formula = cin.GetNext();\n\n                // ??\\????????????????????¨???????????????????????????????????¨???????????¨??????????????\\??????????????????\n                if (formula == \".\")\n                    break;\n\n                count = 0;\n\n                inP = formula.Contains(\"P\");\n                inQ = formula.Contains(\"Q\");\n                inR = formula.Contains(\"R\");\n\n                for (int i = inP ? 0 : 2; i < 3; i++)\n                {\n                    for (int j = inQ ? 0 : 2; j < 3; j++)\n                    {\n                        for (int k = inR ? 0 : 2; k < 3; k++)\n                        {\n                            if (Calc(formula.Replace(\"P\", i.ToString()).Replace(\"Q\", j.ToString()).Replace(\"R\", k.ToString())) == 2)\n                                count++;\n                        }\n                    }\n                }\n\n                if (!inP)\n                    count *= 3;\n                if (!inQ)\n                    count *= 3;\n                if (!inR)\n                    count *= 3;\n\n                Console.WriteLine(count);\n            }\n        }\n\n        private int Not(string x)\n        {\n            if (x[0] == '-')\n                return 2 - Not(x.Remove(0, 1));\n            else if (x[0] == '(')\n                return Calc(x);\n            else\n                return int.Parse(x);\n        }\n\n        private int Calc(string x)\n        {\n            int count = 0;\n            int i = 0;\n            int j = 0;\n            StringBuilder tmp = new StringBuilder();\n            string f1, f2;\n            f1 = f2 = \"\";\n            Func<string, string, int> func = new Func<string, string, int>((a, b) => 0);\n\n            if (x[0] == '(')\n            {\n                count++;\n                i = 1;\n\n                while (count > 0)\n                {\n                    if (count == 1 && x[i] == '+')\n                    {\n                        f1 = tmp.ToString();\n                        tmp.Clear();\n                        func = new Func<string, string, int>((a, b) => Or(a, b));\n                        j = i + 2;\n                    }\n                    else if (count == 1 && x[i] == '*')\n                    {\n                        f1 = tmp.ToString();\n                        tmp.Clear();\n                        func = new Func<string, string, int>((a, b) => And(a, b));\n                        j = i;\n                    }\n                    else\n                    {\n                        if (x[i] == '(')\n                            count++;\n                        else if (x[i] == ')')\n                            count--;\n\n                        tmp.Append(x[i]);\n                    }\n\n                    i++;\n                }\n\n                f2 = tmp.ToString();\n                f2 = f2.Remove(f2.Length - 1, 1);\n\n                return func(f1, f2);\n            }\n            else\n            {\n                return Not(x);\n            }\n        }\n\n        private int And(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx < yy ? xx : yy;\n        }\n\n        private int Or(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx > yy ? xx : yy;\n        }\n    }\n\n    public class CommonInput\n    {\n        public CommonInput()\n        {\n            this._s = new string[0];\n            this._i = 0;\n        }\n\n        public string Line { get; set; }\n        private string[] _s;\n        private int _i;\n        private char[] _sep = { ' ' };\n\n        public void GetLine()\n        {\n            this._i = 0;\n            do\n            {\n                this.Line = Console.ReadLine();\n            } while (this.Line == \"\");\n\n            if (this.Line != null)\n                this._s = this.Line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public string GetNext()\n        {\n            if (this._i < this._s.Length)\n                return this._s[this._i++];\n\n            this.GetLine();\n\n            return this._s[this._i++];\n        }\n\n        public int GetNextToInt()\n        {\n            return int.Parse(this.GetNext());\n        }\n\n        public long GetNextToLong()\n        {\n            return long.Parse(this.GetNext());\n        }\n\n        public double GetNextToDouble()\n        {\n            return double.Parse(this.GetNext());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Contest\n{\n    class Program\n    {\n        static int Main(string[] args)\n        {\n            new Program().Process();\n\n            return 0;\n        }\n\n        private CommonInput cin;\n\n        private void Process()\n        {\n            cin = new CommonInput();\n\n            string formula;\n\n            int inNum, count;\n            bool inP, inQ, inR;\n\n            while (true)\n            {\n                formula = cin.GetNext();\n\n                // ??\\????????????????????¨???????????????????????????????????¨???????????¨??????????????\\??????????????????\n                if (formula == \".\")\n                    break;\n\n                inNum = count = 0;\n\n                inP = formula.Contains(\"P\");\n                inQ = formula.Contains(\"Q\");\n                inR = formula.Contains(\"R\");\n\n                for (int i = inP ? 0 : 2; i < 3; i++)\n                {\n                    for (int j = inQ ? 0 : 2; j < 3; j++)\n                    {\n                        for (int k = inR ? 0 : 2; k < 3; k++)\n                        {\n                            if (Calc(formula.Replace(\"P\", i.ToString()).Replace(\"Q\", j.ToString()).Replace(\"R\", k.ToString())) == 2)\n                                count++;\n                        }\n                    }\n                }\n\n                if (!inP)\n                    count *= 3;\n                if (!inQ)\n                    count *= 3;\n                if (!inR)\n                    count *= 3;\n\n                Console.WriteLine(count);\n            }\n        }\n\n        private int Not(string x)\n        {\n            if (x[0] == '-')\n                return 2 - Not(x.Remove(0, 1));\n            else if (x[0] == '(')\n                return Calc(x);\n            else\n                return int.Parse(x);\n        }\n\n        private int Calc(string x)\n        {\n            int count = 0;\n            int i = 0;\n            int j = 0;\n            StringBuilder tmp = new StringBuilder();\n            string f1, f2;\n            f1 = f2 = \"\";\n            Func<string, string, int> func = new Func<string, string, int>((a, b) => 0);\n\n            if (x[0] == '(')\n            {\n                count++;\n                i = 1;\n\n                while (count > 0)\n                {\n                    if (count == 1 && x[i] == '+')\n                    {\n                        f1 = tmp.ToString();\n                        tmp.Clear();\n                        func = new Func<string, string, int>((a, b) => Or(a, b));\n                        j = i + 2;\n                    }\n                    else if (count == 1 && x[i] == '*')\n                    {\n                        f1 = tmp.ToString();\n                        tmp.Clear();\n                        func = new Func<string, string, int>((a, b) => And(a, b));\n                        j = i;\n                    }\n                    else\n                    {\n                        if (x[i] == '(')\n                            count++;\n                        else if (x[i] == ')')\n                            count--;\n\n                        tmp.Append(x[i]);\n                    }\n\n                    i++;\n                }\n\n                f2 = tmp.ToString();\n                f2 = f2.Remove(f2.Length - 1, 1);\n\n                return func(f1, f2);\n            }\n            else\n            {\n                return Not(x);\n            }\n        }\n\n        private int And(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx < yy ? xx : yy;\n        }\n\n        private int Or(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx > yy ? xx : yy;\n        }\n    }\n\n    public class CommonInput\n    {\n        public CommonInput()\n        {\n            this._s = new string[0];\n            this._i = 0;\n        }\n\n        public string Line { get; set; }\n        private string[] _s;\n        private int _i;\n        private char[] _sep = { ' ' };\n\n        public void GetLine()\n        {\n            this._i = 0;\n            do\n            {\n                this.Line = Console.ReadLine();\n            } while (this.Line == \"\");\n\n            if (this.Line != null)\n                this._s = this.Line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public string GetNext()\n        {\n            if (this._i < this._s.Length)\n                return this._s[this._i++];\n\n            this.GetLine();\n\n            return this._s[this._i++];\n        }\n\n        public int GetNextToInt()\n        {\n            return int.Parse(this.GetNext());\n        }\n\n        public long GetNextToLong()\n        {\n            return long.Parse(this.GetNext());\n        }\n\n        public double GetNextToDouble()\n        {\n            return double.Parse(this.GetNext());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            for (; ; )\n            {\n                var s = sc.ScanLine();\n                if (s == \".\") return;\n                Debug.WriteLine(s);\n                var ans = 0;\n                for (a[0] = 0; a[0] < 3; a[0]++)\n                    for (a[1] = 0; a[1] < 3; a[1]++)\n                        for (a[2] = 0; a[2] < 3; a[2]++)\n                        {\n                            if (parse(s) == 2) ans++;\n                        }\n                Console.WriteLine(ans);\n\n            }\n        }\n        int[] a = new int[3];\n        const string S = \"PQR\";\n        int parse(string s)\n        {\n            int ptr = 0;\n            return expression(s, ref ptr);\n        }\n        int expression(string s, ref int ptr)\n        {\n            if (s[ptr] == '(')\n            {\n                ptr++;\n                var x = expression(s, ref ptr);\n                var c = s[ptr++];\n                var y = expression(s, ref ptr);\n                if (x > y) Swap(ref x, ref y);\n                if (c == '*')\n                {\n                    if (x * y == 4) x = 2;\n                    else if (x * y != 0) x = 1;\n                    else x = 0;\n\n                }\n                else\n                {\n                    if (y == 0) x = 0;\n                    else if (y == 1) x = 1;\n                    else x = 2;\n                }\n                ptr++;\n                return x;\n            }\n            return token(s, ref ptr);\n        }\n        int token(string s, ref int ptr)\n        {\n            if (s[ptr] == '-') { ptr++; return 2 - expression(s, ref ptr); }\n            if (char.IsDigit(s[ptr])) return s[ptr++] - '0';\n            else return a[S.IndexOf(s[ptr++])];\n\n        }\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read())\n                if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Contest\n{\n    class Program\n    {\n        static int Main(string[] args)\n        {\n            new Program().Process();\n\n            return 0;\n        }\n\n        private CommonInput cin;\n\n        private void Process()\n        {\n            cin = new CommonInput();\n\n            string formula;\n\n            int count;\n            bool inP, inQ, inR;\n\n            while (true)\n            {\n                formula = cin.GetNext();\n\n                // ??\\????????????????????¨???????????????????????????????????¨???????????¨??????????????\\??????????????????\n                if (formula == \".\")\n                    break;\n\n                count = 0;\n\n                inP = formula.Contains(\"P\");\n                inQ = formula.Contains(\"Q\");\n                inR = formula.Contains(\"R\");\n\n                for (int i = inP ? 0 : 2; i < 3; i++)\n                {\n                    for (int j = inQ ? 0 : 2; j < 3; j++)\n                    {\n                        for (int k = inR ? 0 : 2; k < 3; k++)\n                        {\n                            if (Calc(formula.Replace(\"P\", i.ToString()).Replace(\"Q\", j.ToString()).Replace(\"R\", k.ToString())) == 2)\n                                count++;\n                        }\n                    }\n                }\n\n                if (!inP)\n                    count *= 3;\n                if (!inQ)\n                    count *= 3;\n                if (!inR)\n                    count *= 3;\n\n                Console.WriteLine(count);\n            }\n        }\n\n        private int Not(string x)\n        {\n            if (x[0] == '-')\n                return 2 - Not(x.Remove(0, 1));\n            else if (x[0] == '(')\n                return Calc(x);\n            else\n                return int.Parse(x);\n        }\n\n        private int Calc(string x)\n        {\n            int count = 0;\n            int i = 0;\n            StringBuilder tmp = new StringBuilder();\n            string f1, f2;\n            f1 = f2 = \"\";\n            Func<string, string, int> func = new Func<string, string, int>((a, b) => 0);\n\n            if (x[0] == '(')\n            {\n                count++;\n                i = 1;\n\n                while (count > 0)\n                {\n                    if (count == 1 && x[i] == '+')\n                    {\n                        f1 = tmp.ToString();\n                        tmp = new StringBuilder();\n                        func = new Func<string, string, int>((a, b) => Or(a, b));\n                    }\n                    else if (count == 1 && x[i] == '*')\n                    {\n                        f1 = tmp.ToString();\n                        tmp = new StringBuilder();\n                        func = new Func<string, string, int>((a, b) => And(a, b));\n                    }\n                    else\n                    {\n                        if (x[i] == '(')\n                            count++;\n                        else if (x[i] == ')')\n                            count--;\n\n                        tmp.Append(x[i]);\n                    }\n\n                    i++;\n                }\n\n                f2 = tmp.ToString();\n                f2 = f2.Remove(f2.Length - 1, 1);\n\n                return func(f1, f2);\n            }\n            else\n            {\n                return Not(x);\n            }\n        }\n\n        private int And(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx < yy ? xx : yy;\n        }\n\n        private int Or(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx > yy ? xx : yy;\n        }\n    }\n\n    public class CommonInput\n    {\n        public CommonInput()\n        {\n            this._s = new string[0];\n            this._i = 0;\n        }\n\n        public string Line { get; set; }\n        private string[] _s;\n        private int _i;\n        private char[] _sep = { ' ' };\n\n        public void GetLine()\n        {\n            this._i = 0;\n            do\n            {\n                this.Line = Console.ReadLine();\n            } while (this.Line == \"\");\n\n            if (this.Line != null)\n                this._s = this.Line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public string GetNext()\n        {\n            if (this._i < this._s.Length)\n                return this._s[this._i++];\n\n            this.GetLine();\n\n            return this._s[this._i++];\n        }\n\n        public int GetNextToInt()\n        {\n            return int.Parse(this.GetNext());\n        }\n\n        public long GetNextToLong()\n        {\n            return long.Parse(this.GetNext());\n        }\n\n        public double GetNextToDouble()\n        {\n            return double.Parse(this.GetNext());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Contest\n{\n    class Program\n    {\n        static int Main(string[] args)\n        {\n            new Program().Process();\n\n            return 0;\n        }\n\n        private CommonInput cin;\n\n        private void Process()\n        {\n            cin = new CommonInput();\n\n            string formula;\n\n            int count;\n            bool inP, inQ, inR;\n\n            while (true)\n            {\n                formula = cin.GetNext();\n\n                // ??\\????????????????????¨???????????????????????????????????¨???????????¨??????????????\\??????????????????\n                if (formula == \".\")\n                    break;\n\n                count = 0;\n\n                inP = formula.Contains(\"P\");\n                inQ = formula.Contains(\"Q\");\n                inR = formula.Contains(\"R\");\n\n                for (int i = inP ? 0 : 2; i < 3; i++)\n                {\n                    for (int j = inQ ? 0 : 2; j < 3; j++)\n                    {\n                        for (int k = inR ? 0 : 2; k < 3; k++)\n                        {\n                            if (Calc(formula.Replace(\"P\", i.ToString()).Replace(\"Q\", j.ToString()).Replace(\"R\", k.ToString())) == 2)\n                                count++;\n                        }\n                    }\n                }\n\n                if (!inP)\n                    count *= 3;\n                if (!inQ)\n                    count *= 3;\n                if (!inR)\n                    count *= 3;\n\n                Console.WriteLine(count);\n            }\n        }\n\n        private int Not(string x)\n        {\n            if (x[0] == '-')\n                return 2 - Not(x.Remove(0, 1));\n            else if (x[0] == '(')\n                return Calc(x);\n            else\n                return int.Parse(x);\n        }\n\n        private int Calc(string x)\n        {\n            int count = 0;\n            int i = 0;\n            int j = 0;\n            StringBuilder tmp = new StringBuilder();\n            string f1, f2;\n            f1 = f2 = \"\";\n            Func<string, string, int> func = new Func<string, string, int>((a, b) => 0);\n\n            if (x[0] == '(')\n            {\n                count++;\n                i = 1;\n\n                while (count > 0)\n                {\n                    if (count == 1 && x[i] == '+')\n                    {\n                        f1 = tmp.ToString();\n                        tmp = new StringBuilder();\n                        func = new Func<string, string, int>((a, b) => Or(a, b));\n                        j = i + 2;\n                    }\n                    else if (count == 1 && x[i] == '*')\n                    {\n                        f1 = tmp.ToString();\n                        tmp = new StringBuilder();\n                        func = new Func<string, string, int>((a, b) => And(a, b));\n                        j = i;\n                    }\n                    else\n                    {\n                        if (x[i] == '(')\n                            count++;\n                        else if (x[i] == ')')\n                            count--;\n\n                        tmp.Append(x[i]);\n                    }\n\n                    i++;\n                }\n\n                f2 = tmp.ToString();\n                f2 = f2.Remove(f2.Length - 1, 1);\n\n                return func(f1, f2);\n            }\n            else\n            {\n                return Not(x);\n            }\n        }\n\n        private int And(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx < yy ? xx : yy;\n        }\n\n        private int Or(string x, string y)\n        {\n            int xx, yy;\n\n            if (x[0] == '(')\n                xx = Calc(x);\n            else\n                xx = Not(x);\n\n            if (y[0] == '(')\n                yy = Calc(y);\n            else\n                yy = Not(y);\n\n            return xx > yy ? xx : yy;\n        }\n    }\n\n    public class CommonInput\n    {\n        public CommonInput()\n        {\n            this._s = new string[0];\n            this._i = 0;\n        }\n\n        public string Line { get; set; }\n        private string[] _s;\n        private int _i;\n        private char[] _sep = { ' ' };\n\n        public void GetLine()\n        {\n            this._i = 0;\n            do\n            {\n                this.Line = Console.ReadLine();\n            } while (this.Line == \"\");\n\n            if (this.Line != null)\n                this._s = this.Line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public string GetNext()\n        {\n            if (this._i < this._s.Length)\n                return this._s[this._i++];\n\n            this.GetLine();\n\n            return this._s[this._i++];\n        }\n\n        public int GetNextToInt()\n        {\n            return int.Parse(this.GetNext());\n        }\n\n        public long GetNextToLong()\n        {\n            return long.Parse(this.GetNext());\n        }\n\n        public double GetNextToDouble()\n        {\n            return double.Parse(this.GetNext());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var a = Console.ReadLine().Trim();\n            if (a == \".\") break;\n            var count = 0;\n            for (int i = 0; i < 3; i++)\n                for (int j = 0; j < 3; j++)\n                    for (int k = 0; k < 3; k++)\n                    {\n                        var b = a.Replace('P', i.ToString()[0]);\n                        var c = b.Replace('Q', j.ToString()[0]);\n                        var d = c.Replace('R', k.ToString()[0]);\n                        var ans = getAns(d);\n                        if (ans == 2) count++;\n                    }\n            Console.WriteLine(count);\n        }\n    }\n    static int getAns(string s)\n    {\n        var k = s.Length - s.Replace(\"(\", \"\").Length;\n        if (k == 0) return calc(s);\n        var kp0 = -1; var kp1 = -1;\n        var p = 0;\n        while (true)\n        {\n            if (s[p] == '(') kp0 = p;\n            if (s[p] == ')')\n            {\n                kp1 = p;\n                var s2 = s.Substring(kp0 + 1, kp1 - kp0 - 1);\n                var s3 = s.Substring(0, kp0) + calc(s2).ToString() + s.Substring(kp1 + 1);\n                return getAns(s3);\n            }\n            p++;\n        }\n    }\n\n    static int calc(string s)\n    {\n        if (s.IndexOf('+') < 0 && s.IndexOf('*') < 0) return minuss(s);\n        else\n        {\n            string[] line = s.Split('+', '*');\n            var w0 = minuss(line[0]);\n            var w1 = minuss(line[1]);\n            return s.IndexOf('+') >= 1 ? plus(w0, w1) : multi(w0, w1);\n        }\n    }\n    static int minuss(string s)\n    {\n        var sL = s.Length;\n        var ans = s[sL - 1] - '0';\n        var p = 0;\n        while (p++ < sL - 1)\n            ans = 2 - ans;\n        return ans;\n    }\n    static int plus(int a, int b) => a >= b ? a : b;\n    static int multi(int a, int b) => a <= b ? a : b;\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def mul(x, y)\n  if x == '2' && y == '2' then '2'\n  elsif x == '0' || y == '0' then '0'\n  else '1'\n  end\nend\n\ndef plus(x, y)\n  if x == '0' && y == '0' then '0'\n  elsif x == '2' || y == '2' then '2'\n  else '1'\n  end\nend\n\ndef to_num(s)\n  ['0', '1', '2'].repeated_permutation(3).map { |p, q, r|\n    s.gsub(/P|Q|R/, 'P' => p, 'Q' => q, 'R' => r)\n  }\nend\n\ndef calc(expr)\n  while expr.size > 1\n    expr.gsub!(/-(\\d)/) {\n      x = $1\n      (2 - x.to_i).to_s\n    }\n    expr.gsub!(/\\((\\d)\\+(\\d)\\)/) {\n      x, y = $1, $2\n      plus($1, $2)\n    }\n    expr.gsub!(/\\((\\d)\\*(\\d)\\)/) {\n      x, y = $1, $2\n      mul($1, $2)\n    }\n  end\n  if expr == '2' then return true\n  else return false\n  end\nend\n\nwhile s = gets.chomp\n  break if s == \".\"\n  puts to_num(s).count{ |expr| calc(expr) }\nend"
  },
  {
    "language": "Ruby",
    "code": "\n\nclass Fixnum\n  def !@\n    -1*self+2\n  end\n\n  def &(n)\n    [self,n].min\n  end\n\n  def |(n)\n    [self,n].max\n  end\nend\n\ndef expr(idx)\n  c = $a[idx]\n  if c == \"-\"\n    e,idx = expr(idx+1)\n    return [!e,idx]\n  elsif c==\"(\"\n    e1,idx = expr(idx+1)\n    idx+=1\n    op=$a[idx]\n    e2,idx = expr(idx+1)\n    idx+=1\n    if op == \"+\"\n      return [e1|e2,idx]\n    else \n      return [e1&e2,idx]\n    end\n  else\n    return [c.to_i,idx]\n  end\nend\n\ndef calc\n  expr(0)\nend\n\n$a = Array.new\nloop do\n  line = gets.chomp\n  break if line ==\".\"\n  ans=0\n  3.times do |p|\n    l1 = line.gsub(/P/,p.to_s)\n    3.times do |q|\n      l2 = l1.gsub(/Q/,q.to_s)\n      3.times do |r|\n        $a = l2.gsub(/R/,r.to_s).split(\"\")\n        result,i = calc\n        ans+=1 if result == 2\n      end\n    end\n  end\n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nUOPS = {'-' => [2, 1, 0]}\n\nBOPS = {\n  '*' => [[0, 0, 0], [0, 1, 1], [0, 1, 2]],\n  '+' => [[0, 1, 2], [1, 1, 2], [2, 2, 2]]\n}\n\nVARNAME = 'PQR'\n\n### subroutines\n#<fml> := '0'-'2' | '-'<fml> | '('<fml>'*'<fml>')' | '('<fml>'+'<fml>')'\n\ndef formula(fml)\n  chpos = fml[$pos]\n  $pos += 1\n  val = nil\n\n  case chpos\n  when '0'..'2'\n    val = chpos.to_i\n  when '-'\n    v0 = formula(fml)\n    val = UOPS[chpos][v0]\n  else\n    v0 = formula(fml)\n    op = fml[$pos]\n    $pos += 1\n    v1 = formula(fml)\n    $pos += 1\n    #p [v0, op, v1]\n    val = BOPS[op][v0][v1]\n  end\n\n  val\nend\n\n### main\n\nloop do\n  fml = gets.strip\n  break if fml == '.'\n\n  count = 0\n  vvals = [0, 0, 0]\n\n  loop do\n    fml0 = fml.clone.tr(VARNAME, vvals.join(''))\n    $pos = 0\n    val = formula(fml0)\n    count += 1 if val == 2\n\n    k = 0\n    while k < 3\n      vvals[k] += 1\n      break if vvals[k] <= 2\n      vvals[k] = 0\n      k += 1\n    end\n    break if k >= 3\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "\n\nclass Fixnum\n  def &(n)\n    [self,n].min\n  end\n\n  def |(n)\n    [self,n].max\n  end\nend\n\ndef negate(n)\n  -n+2\nend\n\ndef expr(idx)\n  c = $a[idx]\n  if c == \"-\"\n    e,idx = expr(idx+1)\n    return [negate(e),idx]\n  elsif c==\"(\"\n    e1,idx = expr(idx+1)\n    idx+=1\n    op=$a[idx]\n    e2,idx = expr(idx+1)\n    idx+=1\n    if op == \"+\"\n      return [e1|e2,idx]\n    else \n      return [e1&e2,idx]\n    end\n  else\n    return [c.to_i,idx]\n  end\nend\n\ndef calc\n  expr(0)\nend\n\n$a = Array.new\nloop do\n  line = gets.chomp\n  break if line ==\".\"\n  ans=0\n  3.times do |p|\n    l1 = line.gsub(/P/,p.to_s)\n    3.times do |q|\n      l2 = l1.gsub(/Q/,q.to_s)\n      3.times do |r|\n        $a = l2.gsub(/R/,r.to_s).split(\"\")\n        result,i = calc\n        ans+=1 if result == 2\n      end\n    end\n  end\n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "def mul(x, y)\n  if x == '2' && y == '2' then '2'\n  elsif x == '0' || y == '0' then '0'\n  else '1'\n  end\nend\n\ndef plus(x, y)\n  if x == '0' && y == '0' then '0'\n  elsif x == '2' || y == '2' then '2'\n  else '1'\n  end\nend\n\ndef to_num(s)\n  ['0', '1', '2'].repeated_permutation(3).map { |p, q, r|\n    s.gsub(/P|Q|R/, 'P' => p, 'Q' => q, 'R' => r)\n  }\nend\n\ndef calc(expr)\n  while expr.size > 1\n    expr.gsub!(/-(\\d)/) {\n      (2 - $1.to_i).to_s\n    }\n    expr.gsub!(/\\((\\d)\\+(\\d)\\)/) {\n      plus($1, $2)\n    }\n    expr.gsub!(/\\((\\d)\\*(\\d)\\)/) {\n      mul($1, $2)\n    }\n  end\n  if expr == '2' then return true\n  else return false\n  end\nend\n\nwhile s = gets.chomp\n  break if s == \".\"\n  puts to_num(s).count{ |expr| calc(expr) }\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Ternary\n\tdef initialize(n)\n\t\t@n=n\n\tend\n\tdef to_i\n\t\t@n\n\tend\n\tdef coerce(o)\n\t\t[Ternary.new(o),self]\n\tend\n\tdef -@\n\t\tTernary.new(2-to_i)\n\tend\n\tdef *(o)\n\t\tTernary.new([to_i,o.to_i].min)\n\tend\n\tdef +(o)\n\t\tTernary.new([to_i,o.to_i].max)\n\tend\nend\nR=[*0..2]\nloop{\n\ts=gets.chomp\n\tbreak if s=='.'\n\tr=0\n\tR.each{|a|R.each{|b|R.each{|c|\n\t\tr+=1 if eval(s.gsub('P','Ternary.new(%d)'%a).gsub('Q','Ternary.new(%d)'%b).gsub('R','Ternary.new(%d)'%c)).to_i==2\n\t}}}\n\tp r\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class String\n\tdef del_neg\n\t\ts, t = self, nil\n\t\tloop {\n\t\t\tt = s.gsub(/-\\d/){|x| (2+x.to_i).to_s}\n\t\t\tbreak if s == t\n\t\t\ts = t\t\n\t\t}\n\t\tt\n\tend\n\n\tdef del_or\n\t\tgsub(/(\\d)\\+(\\d)/){|x| [$1, $2].max.to_s}\n\tend\n\n\tdef del_and\n\t\tgsub(/(\\d)\\*(\\d)/){|x| [$1, $2].min.to_s}\n\tend\n\n\tdef del_par\n\t\tgsub(/\\((\\d)\\)/){|x| $1.to_s}\n\tend\n\n\tdef calc\n\t\ts = dup\n\t\tuntil s.size == 1\n\t\t\ts = s.del_neg\n\t\t\ts = s.del_or\n\t\t\ts = s.del_and\n\t\t\ts = s.del_par\n\t\tend\n\t\ts.to_i\n\tend\nend\n\n\nloop {\n\ts = gets.chomp\n\tbreak if s == ?.\n\tp (0..2).to_a.repeated_permutation(3).count{|a|\n\t\texp = s.tr(\"PQR\", a.join)\n\t\texp.calc == 2\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Ternary\n\tdef initialize(n)\n\t\t@n=n\n\tend\n\tdef to_i\n\t\t@n\n\tend\n\tdef coerce(o)\n\t\t[Ternary.new(o<0 ? 2-o : o),self]\n\tend\n\tdef -@\n\t\tTernary.new(2-to_i)\n\tend\n\tdef *(o)\n\t\tTernary.new([to_i,o.to_i].min)\n\tend\n\tdef +(o)\n\t\tTernary.new([to_i,o.to_i].max)\n\tend\nend\nR=[*0..2]\nloop{\n\ts=gets.chomp\n\tbreak if s=='.'\n\tr=0\n\tR.each{|a|R.each{|b|R.each{|c|\n\t\tr+=1 if eval(s.gsub('P','Ternary.new(%d)'%a).gsub('Q','Ternary.new(%d)'%b).gsub('R','Ternary.new(%d)'%c)).to_i==2\n\t}}}\n\tp r\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def mul(x, y)\n  if x == '2' && y == '2' then '2'\n  elsif x == '0' || y == '0' then '0'\n  else '1'\n  end\nend\n\ndef plus(x, y)\n  if x == '0' && y == '0' then '0'\n  elsif x == '2' || y == '2' then '2'\n  else '1'\n  end\nend\n\ndef to_num(s)\n  ['0', '1', '2'].repeated_permutation(3).map { |p, q, r|\n    s.gsub(/P|Q|R/, 'P' => p, 'Q' => q, 'R' => r)\n  }\nend\n\ndef calc(expr)\n  while expr.match(/-/)\n    expr.gsub!(/-(\\d)/) {\n      x = $1\n      (2 - x.to_i).to_s\n    }\n  end\n  while expr.size > 1\n    expr.gsub!(/\\((\\d)\\+(\\d)\\)/) {\n      x, y = $1, $2\n      plus($1, $2)\n    }\n    expr.gsub!(/\\((\\d)\\*(\\d)\\)/) {\n      x, y = $1, $2\n      mul($1, $2)\n    }\n  end\n  if expr == '2' then return true\n  else return false\n  end\nend\n\nwhile s = gets.chomp\n  break if s == \".\"\n  puts to_num(s).count{ |expr| calc(expr) }\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Ternary\n\tdef initialize(n)\n\t\t@n=n\n\tend\n\tdef to_i\n\t\t@n\n\tend\n\tdef -@\n\t\tTernary.new(2-to_i)\n\tend\n\tdef *(o)\n\t\tTernary.new([to_i,o.to_i].min)\n\tend\n\tdef +(o)\n\t\tTernary.new([to_i,o.to_i].max)\n\tend\nend\nR=[*0..2]\nloop{\n\ts=gets.chomp\n\tbreak if s=='.'\n\tr=0\n\tR.each{|a|R.each{|b|R.each{|c|\n\t\tr+=1 if eval([['0',0],['1',1],['2',2],['P',a],['Q',b],['R',c]].reduce(s){|x,(y,z)|x.gsub(y,'Ternary.new(%d)'%z)}).to_i==2\n\t}}}\n\tp r\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def parse(s,p,q,r)\n    case s[0]\n    when \"0\"\n        return 0\n    when \"1\"\n        return 1\n    when \"2\"\n        return 2\n    when \"P\"\n        return p\n    when \"Q\"\n        return q\n    when \"R\"\n        return r\n    when \"-\"\n        return 2 - parse(s[1...s.length],p,q,r)\n    when \"(\"\n        index = 1\n        level = 0\n        while index < s.length\n            if s[index] == \"(\"\n                level += 1\n            elsif s[index] == \")\"\n                level -= 1\n            elsif s[index] == \"*\" && level == 0\n                a = parse(s[1...index],p,q,r)\n                b = parse(s[(index+1)...s.length],p,q,r)\n                return 0 if a == 0 || b == 0\n                return 2 if a == 2 && b == 2\n                return 1\n            elsif s[index] == \"+\" && level == 0\n                a = parse(s[1...index],p,q,r)\n                b = parse(s[(index+1)...s.length],p,q,r)\n                return 0 if a == 0 && b == 0\n                return 2 if a == 2 || b == 2\n                return 1\n            end\n            index += 1\n        end\n        return -1\n    end\nend\nloop do\n    s = gets.chomp\n    break if s == \".\"\n    ans = 0\n    3.times do |p|\n        3.times do |q|\n            3.times do |r|\n                if parse(s,p,q,r) == 2\n                    ans += 1\n                end\n            end\n        end\n    end\n    puts ans\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction check($T) {\n        $memo = $T;\n        $T = str_replace(\"-0\", \"2\", $T);\n        $T = str_replace(\"-1\", \"1\", $T);\n        $T = str_replace(\"-2\", \"0\", $T);\n        if($memo !== $T) {\n                return check($T);\n        }\n\n        $T = str_replace(\"0*0\", \"0\", $T);\n        $T = str_replace(\"0*1\", \"0\", $T);\n        $T = str_replace(\"0*2\", \"0\", $T);\n        $T = str_replace(\"1*0\", \"0\", $T);\n        $T = str_replace(\"1*1\", \"1\", $T);\n        $T = str_replace(\"1*2\", \"1\", $T);\n        $T = str_replace(\"2*0\", \"0\", $T);\n        $T = str_replace(\"2*1\", \"1\", $T);\n        $T = str_replace(\"2*2\", \"2\", $T);\n        if($memo !== $T) {\n                return check($T);\n        }\n\n        $T = str_replace(\"0+0\", \"0\", $T);\n        $T = str_replace(\"0+1\", \"1\", $T);\n        $T = str_replace(\"0+2\", \"2\", $T);\n        $T = str_replace(\"1+0\", \"1\", $T);\n        $T = str_replace(\"1+1\", \"1\", $T);\n        $T = str_replace(\"1+2\", \"2\", $T);\n        $T = str_replace(\"2+0\", \"2\", $T);\n        $T = str_replace(\"2+1\", \"2\", $T);\n        $T = str_replace(\"2+2\", \"2\", $T);\n        if($memo !== $T) {\n                return check($T);\n        }\n\n\n        $T = str_replace(\"(0)\", \"0\", $T);\n        $T = str_replace(\"(1)\", \"1\", $T);\n        $T = str_replace(\"(2)\", \"2\", $T);\n        if($memo !== $T) {\n                return check($T);\n        }\n\n        return $T;\n}\n\nwhile(true){\n        $S = trim(fgets(STDIN));\n        if($S === \".\") break;\n        $ans = 0;\n        for($P = 0; $P < 3; $P++){\n                for($Q = 0; $Q < 3; $Q++){\n                        for($R = 0; $R < 3; $R++){\n                                $T = $S;\n                                $T = str_replace(\"P\", $P, $T);\n                                $T = str_replace(\"Q\", $Q, $T);\n                                $T = str_replace(\"R\", $R, $T);\n                                if(check($T) === \"2\") $ans++;\n                        }\n                }\n        }\n        echo $ans.PHP_EOL;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.array;\n\nstring inv( string v ) {\n  return to!string(2 - to!int(v));\n}\n\nstring mult( string x, string y ) {\n  if ( x == \"0\" || y == \"0\" ) return \"0\";\n  else if ( x == \"1\" || y == \"1\" ) return \"1\";\n  else return \"2\";\n}\n\nstring add( string x, string y ) {\n  if ( x == \"2\" || y == \"2\" ) return \"2\";\n  else if ( x == \"1\" || y == \"1\" ) return \"1\";\n  else return \"0\";\n}\n\nvoid main()\n{\n  while ( true ) {\n\tstring input = strip( readln );\n\tif ( input == \".\" ) break;\n\tint count = 0;\n\tforeach ( p; [ \"0\", \"1\", \"2\" ] ) {\n\t  foreach ( q; [ \"0\", \"1\", \"2\" ] ) {\n\t\tforeach ( r; [ \"0\", \"1\", \"2\" ] ) {\n\t\t  auto exp =  replace( replace( replace( input, \"P\", p ), \"Q\", q ), \"R\", r );\n\t\t  Tokenizer tk = new Tokenizer( exp );\n\t\t  // stderr.writeln( exp );\n\t\t  if ( apply( tk ) == \"2\" ) {\n\t\t\tcount++;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\twriteln( count );\n  }\n}\n\nclass Tokenizer {\n  string str;\n  int index;\n  this( string str ) {\n\tthis.str = str;\n\tthis.index = 0;\n  }\n  string nextToken() {\n\tauto ans = str[ index..index+1 ];\n\tindex++;\n\treturn ans;\n  }\n  bool eof() {\n\treturn index == str.length;\n  }\n}\n\nstring apply( Tokenizer tk ) {\n  if ( !tk.eof ) {\n\tauto nt = tk.nextToken;\n\tswitch( nt ) {\n\tcase \"0\":\n\tcase \"1\":\n\tcase \"2\":\n\t  return nt;\n\tcase \"-\":\n\t  auto token = apply( tk );\n\t  return inv( token );\n\tcase \"(\":\n\t  auto token1 = apply( tk );\n\t  auto op = tk.nextToken();\n\t  auto token2 = apply( tk );\n\t  tk.nextToken(); // )\n\t  if ( op == \"+\" ) {\n\t\treturn add( token1, token2 );\n\t  } else if ( op == \"*\" ) {\n\t\treturn mult( token1, token2 );\n\t  } else {\n\t\treturn \"\";\n\t  }\n\tdefault:\n\t  return \"\";\n\t}\n  } else {\n\treturn \"\";\n  }\n}"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#2005_c\n\"\"\"\nn = int(input())\nk = list(\"mcxi\")\nfor i in range(n):\n    d = {\"m\":0,\"c\":0,\"x\":0,\"i\":0}\n    a,b  = input().split()\n    a = list(a)\n    b = list(b)\n    a.insert(0,1)\n    b.insert(0,1)\n    for j in range(1,len(a)):\n        if a[j] in k:\n            if a[j-1] in k:\n                d[a[j]] += 1\n            else:\n                d[a[j]] += int(a[j-1])\n    for j in range(1,len(b))[::-1]:\n        if b[j] in k:\n            if b[j-1] in k:\n                d[b[j]] += 1\n            else:\n                d[b[j]] += int(b[j-1])\n            if d[b[j]] >= 10:\n                l = b[j]\n                while d[l] >= 10:\n                    d[l] -= 10\n                    l = k[k.index(l)-1]\n                    d[l] += 1\n    for j in k:\n        if d[j]:\n            if d[j] == 1:\n                print(j,end = \"\")\n            else:\n                print(str(d[j])+j,end = \"\")\n    print()\n\"\"\"\n\n#2017_c\n\"\"\"\nwhile 1:\n    h, w = map(int, input().split())\n    if h == w == 0:\n        break\n    s = [list(map(int, input().split())) for i in range(h)]\n\n    ans = 0\n    for u in range(h):\n        for d in range(u+2,h):\n            for l in range(w):\n                for r in range(l+2,w):\n                    m = float(\"inf\")\n                    for i in range(u,d+1):\n                        m = min(m,s[i][l],s[i][r])\n                    for i in range(l,r+1):\n                        m = min(m,s[u][i],s[d][i])\n                    f = 1\n                    su = 0\n                    for i in range(u+1,d):\n                        for j in range(l+1,r):\n                            su += (m-s[i][j])\n                            if s[i][j] >= m:\n                                f = 0\n                                break\n                        if not f:\n                            break\n                    if f:\n                        ans = max(ans,su)\n    print(ans)\n\"\"\"\n\n#2016_c\n\"\"\"\nwhile 1:\n    m,n = map(int, input().split())\n    if m == n == 0:\n        break\n    ma = 7368791\n    d = [0]*(ma+1)\n    z = m\n    for i in range(n):\n        while d[z]:\n            z += 1\n        j = z\n        while j <= ma:\n            d[j] = 1\n            j += z\n    for j in range(z,ma+1):\n        if not d[j]:\n            print(j)\n            break\n\"\"\"\n\n#2018_c\n\"\"\"\ndef factorize(n):\n    if n < 4:\n        return [1,n]\n    i = 2\n    l = [1]\n    while i**2 <= n:\n        if n%i == 0:\n            l.append(i)\n            if n//i != i:\n                l.append(n//i)\n        i += 1\n    l.append(n)\n    l.sort()\n    return l\nwhile 1:\n    b = int(input())\n    if b == 0:\n        break\n    f = factorize(2*b)\n    for n in f[::-1]:\n        a = 1-n+(2*b)//n\n        if a >= 1 and a%2 == 0:\n            print(a//2,n)\n            break\n\"\"\"\n\n#2010_c\n\"\"\"\nimport sys\ndp = [100]*1000000\ndp_2 = [100]*1000000\ndp[0] = 0\ndp_2[0] = 0\nfor i in range(1,181):\n    s = i*(i+1)*(i+2)//6\n    for j in range(s,1000000):\n        if dp[j-s]+1 < dp[j]:\n            dp[j] = dp[j-s]+1\n    if s%2:\n        for j in range(s,1000000):\n            if dp_2[j-s]+1 < dp_2[j]:\n                dp_2[j] = dp_2[j-s]+1\nwhile 1:\n    m = int(sys.stdin.readline())\n    if m == 0:\n        break\n    print(dp[m],dp_2[m])\n\"\"\"\n\n#2015_c\n\"\"\"\nfrom collections import deque\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    s = [input() for i in range(n)]\n    d = [s[i].count(\".\") for i in range(n)]\n    m = max(d)\n    c = [s[i][-1] for i in range(n)]\n    q = deque()\n    for i in range(1,m+1)[::-1]:\n        j = 0\n        while j < n:\n            for k in range(j,n):\n                if d[k] == i:break\n            else:\n                break\n            j = k\n            op = c[j-1]\n            while j < n and d[j] == i:\n                q.append(j)\n                j += 1\n            j = k\n            if op == \"+\":\n                k = 0\n                while q:\n                    x = q.pop()\n                    k += int(c[x])\n                    c.pop(x)\n                    d.pop(x)\n                    n -= 1\n            else:\n                k = 1\n                while q:\n                    x = q.pop()\n                    k *= int(c[x])\n                    c.pop(x)\n                    d.pop(x)\n                    n -= 1\n            c[j-1] = k\n    print(c[0])\n\"\"\"\n\n#2013_c\n\"\"\"\nfrom collections import defaultdict\n\ndef parse_expr(s,i):\n    i += 1\n    if s[i] == \"[\":\n        q = []\n        while s[i] != \"]\":\n            e,i = parse_expr(s,i)\n            q.append(e)\n        return (calc(q),i+1)\n    else:\n        n,i = parse_num(s,i)\n        return (calc([n]),i+1)\n\ndef parse_num(s,i):\n    m = int(s[i])\n    i += 1\n    while f_num[s[i]]:\n        m *= 10\n        m += int(s[i])\n        i += 1\n    return (m,i)\n\ndef calc(q):\n    if len(q) == 1:\n        return (q[0]+1)//2\n    q.sort()\n    return sum(q[:len(q)//2+1])\n\nf_num = defaultdict(lambda : 0)\nfor i in range(10):\n    f_num[str(i)] = 1\n\nn = int(input())\nfor i in range(n):\n    s = input()\n    print(parse_expr(s,0)[0])\n\"\"\"\n\n#2003_C\n\"\"\"\nwhile 1:\n    w,h = LI()\n    if w == h == 0:\n        break\n    s = SR(h)\n    dp = [[0]*w for i in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if s[y][x].isdecimal():\n                dp[y][x] = max(dp[y-1][x],dp[y][x-1])*10+int(s[y][x])\n    ans = 0\n    for i in dp:\n        ans = max(ans,max(i))\n    print(ans)\n\"\"\"\n#2008_C\ndef parse_formula(s,i):\n    if s[i] == \"-\":\n        i += 1\n        e,i = parse_formula(s,i)\n        return 2-e,i\n    elif s[i] == \"(\":\n        i += 1\n        e1,i = parse_formula(s,i)\n        op = s[i]\n        i += 1\n        e2,i = parse_formula(s,i)\n        i += 1\n        return calc(op,e1,e2),i\n    else:\n        return int(s[i]),i+1\n\ndef calc(op,a,b):\n    if op == \"*\":\n        return min(a,b)\n    else:\n        return max(a,b)\n\nwhile 1:\n    s = S()\n    if s[0] == \".\":\n        break\n    t = []\n    f = defaultdict(int)\n    for p in range(3):\n        f[\"P\"] = p\n        for q in range(3):\n            f[\"Q\"] = q\n            for r in range(3):\n                f[\"R\"] = r\n                t.append([f[s[i]] if s[i] in \"PQR\" else s[i] for i in range(len(s))])\n    ans = 0\n    for s in t:\n        if parse_formula(s,0)[0] == 2:\n            ans += 1\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nclass mybool:\n    def __init__(self, value):\n        self.value = value\n    def __neg__(self):\n        return mybool(2-self.value)\n    def __mul__(self, other):\n        return mybool(min(self.value,other.value))\n    def __add__(self, other):\n        return mybool(max(self.value,other.value))\n\nwhile 1:\n    s = raw_input()\n    if s == \".\": break\n\n    for i in xrange(3):\n        s = s.replace(str(i),\"mybool(%d)\"%i)\n    \n    ans = 0\n    for p,q,r in it.product([0,1,2],repeat=3):\n        P,Q,R = mybool(p),mybool(q),mybool(r)\n        if eval(s).value == 2:\n            ans += 1\n    \n    print ans\n    "
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    m = {}\n    def f(s):\n        k = s\n        if k in m:\n            return m[k]\n        t = set(re.findall(r\"\\([^()]+\\)\", s))\n        while t:\n            for c in t:\n                s = s.replace(c, f(c[1:-1]))\n            t = set(re.findall(r\"\\([^()]+\\)\", s))\n        while '-' in s:\n            s = s.replace('-1', '1')\n            s = s.replace('-2', '0')\n            s = s.replace('-0', '2')\n        r = s[0]\n        for i in range(len(s)//2):\n            if s[i*2+1] == '*':\n                r = min(r,s[i*2+2])\n            else:\n                r = max(r,s[i*2+2])\n        m[k] = r\n        return r\n\n    while True:\n        s = S()\n        if s == '.':\n            break\n\n        tr = 0\n        for P,Q,R in itertools.product(['0', '1', '2'], repeat=3):\n            ts = s.replace('P', P)\n            ts = ts.replace('Q', Q)\n            ts = ts.replace('R', R)\n            if f(ts) == '2':\n                tr += 1\n\n        rr.append(tr)\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef AND(a, b):\n    if a == \"0\" or b == \"0\":\n        return \"0\"\n    elif a == b == \"2\":\n        return \"2\"\n    else:\n        return \"1\"\n\n\ndef OR(a, b):\n    if a == \"2\" or b == \"2\":\n        return 2\n    elif a == b == \"0\":\n        return \"0\"\n    else:\n        return \"1\"\n\n\ndef NOT(a):\n    if a.count(\"-\") % 2 == 1:\n        if a[0] == \"0\":\n            return \"2\"\n        elif a[0] == \"2\":\n            return \"0\"\n        else:\n            return \"1\"\n    else:\n        return a[0]\n\n\ndef solve(S):\n    que = deque()\n    for s in S:\n        if s == \")\":\n            formula = \"\"\n            while True:\n                q = que.pop()\n                if q == \"(\":\n                    break\n                formula += q\n            if \"+\" in formula:\n                a, b = formula.split(\"+\")\n                a = NOT(a)\n                b = NOT(b)\n                que.append(str(OR(a, b)))\n            if \"*\" in formula:\n                a, b = formula.split(\"*\")\n                a = NOT(a)\n                b = NOT(b)\n                que.append(str(AND(a, b)))\n        else:\n            que.append(s)\n    return NOT(\"\".join(reversed(que)))\n\n\nwhile True:\n    S = input()\n    if S == \".\":\n        break\n    count = 0\n    for p in range(3):\n        for q in range(3):\n            for r in range(3):\n                if solve(S.replace(\"P\", str(p)).replace(\"Q\", str(q)).replace(\"R\", str(r))) == \"2\":\n                    count += 1\n    print(count)\n"
  },
  {
    "language": "Python",
    "code": "def multi(a, b) :\n    if a == 0 :\n        return 0\n    elif a == 1 :\n        if b == 0 :\n            return 0\n        else :\n            return 1\n    else :\n        return b\n\ndef add(a, b) :\n    if a == 0 :\n        return b\n    elif a == 1 :\n        if b == 2 :\n            return 2\n        else :\n            return 1\n    else :\n        return 2\n\ndef minus(a) :\n    return (2 - a)\n\ndef calc(l) : # '('、')'のない計算式\n    l = list(l)\n    \n    #'-'を計算\n    i = len(l)-1\n    while True :\n        if i < 0 :\n            break\n        if l[i] == '-' :\n            print\n            l[i] = str(minus(int(l[i+1])))\n            del l[i+1]\n        i -= 1 \n        \n    #'*'を計算\n    i = 0\n    while True :\n        if i >= len(l) :\n            break\n        if l[i] == '*' :\n            l[i-1] = str(multi(int(l[i-1]), int(l[i+1])))\n            del l[i:i+2]\n        else :\n            i += 1\n    \n    #'+'を計算\n    i = 0\n    while True :\n        if i >= len(l) :\n            break\n        if l[i] == '+' :\n            l[i-1] = str(add(int(l[i-1]), int(l[i+1])))\n            del l[i:i+2]\n        else :\n            i += 1\n    return ''.join(l)\n    \n\n        \n            \ndef main(l) :\n    l = list(l)\n    while '(' in l :\n        for i in range(len(l)) :\n            if l[i] == '(' :\n                start = i\n            elif l[i] == ')' :\n                A = ''.join(l[start+1:i])\n                del l[start:i+1]\n                l.insert(start, calc(A))\n                break\n    if len(l) != 1 :\n        l = calc(l)\n    return ''.join(l)\n\nwhile True :\n    input_l = input()\n    if input_l == '.' :\n        break\n    \n    cnt = 0\n    for p in ['0', '1', '2'] :\n        for q in ['0', '1', '2'] :\n            for r in ['0', '1', '2'] :\n                l = input_l\n                if 'P' in l :\n                    l = l.replace('P', p)\n                if 'Q' in l :\n                    l = l.replace('Q', q)\n                if 'R' in l :\n                    l = l.replace('R', r)\n                if main(l) == '2' :\n                    cnt += 1\n    print(cnt)\n    \n\n"
  },
  {
    "language": "Python",
    "code": "import itertools\ns = \"\"\ndef satisfy(p, q, r):\n\tglobal s\n\tf = s.replace(\"P\", str(p)).replace(\"Q\", str(q)).replace(\"R\", str(r))\n\twhile len(f) > 1:\n\t\tf = f.replace(\"-0\", \"2\").replace(\"-1\", \"1\").replace(\"-2\", \"0\")\n\t\tfor x, y in itertools.product(xrange(3), repeat=2):\n\t\t\tf = f.replace(\"(%d*%d)\" % (x, y), str(min(x, y)))\n\t\t\tf = f.replace(\"(%d+%d)\" % (x, y), str(max(x, y)))\n\treturn f == \"2\"\nwhile True:\n\ts = raw_input()\n\tif s == \".\": break\n\tcount = 0\n\tfor p, q, r in itertools.product(xrange(3), repeat=3):\n\t\tif satisfy(p, q, r):\n\t\t\tcount += 1\n\tprint count"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\nclass thee(int):\n    def __add__(self, that):\n        return thee(max(int(self), int(that)))\n\n    def __mul__(self, that):\n        return thee(min(int(self), int(that)))\n    \n    def __neg__(self):\n        T = [2, 1, 0]\n        return thee(T[int(self)])\n\nS = input()\nwhile S != \".\":\n    for x in list(\"012PQR\"):\n        S = S.replace(x, \"thee({})\".format(x))\n    ans = 0\n    for P, Q, R in product(range(3), repeat=3):\n        ans += 2 == int(eval(S))\n    print(ans)\n    S = input()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nwhile True:\n    S_ = raw_input()\n    if S_ == '.':\n        break\n\n    ans = 0\n    for p, q, r in it.product([0, 1, 2], repeat = 3):\n        S = S_\n        S = S.replace(\"P\", str(p)).replace(\"Q\", str(q)).replace(\"R\", str(r))\n\n        for loop in range(100):\n            S = S.replace(\"-0\", \"2\")\n            S = S.replace(\"-1\", \"1\")\n            S = S.replace(\"-2\", \"0\")\n            for a, b in it.product([0, 1, 2], repeat = 2):\n                S = S.replace(\"(%d*%d)\" % (a, b), str(min(a, b)))\n                S = S.replace(\"(%d+%d)\" % (a, b), str(max(a, b)))\n            \n        if S == \"2\":\n            ans += 1\n    print ans\n"
  },
  {
    "language": "Python",
    "code": "def parser(left, right):\n    if S[left] == '(' and S[right - 1] == ')':\n        cnt = 0\n        for i in range(left + 1, right - 1):\n            if S[i] == '(':\n                cnt += 1\n            elif S[i] == ')':\n                cnt -= 1\n            elif cnt == 0 and S[i] == '+':\n                return [max(x, y) for x, y in zip(parser(left + 1, i), parser(i + 1, right - 1))]\n            elif cnt == 0 and S[i] == '*':\n                return [min(x, y) for x, y in zip(parser(left + 1, i), parser(i + 1, right - 1))]\n    elif S[left] == '-':\n        return [2 - x for x in parser(left + 1, right)]\n    elif S[left] == 'P':\n        return [i // 9 % 3 for i in range(27)]\n    elif S[left] == 'Q':\n        return [i // 3 % 3 for i in range(27)]\n    elif S[left] == 'R':\n        return [i % 3 for i in range(27)]\n    else:\n        return [int(S[left]) for _ in range(27)]\n\n\nwhile True:\n    S = input()\n    if S == '.':\n        break\n    print(parser(0, len(S)).count(2))"
  },
  {
    "language": "Python",
    "code": "class F:\n __neg__=lambda s:F(2-s.v)\n __add__=lambda s,t:F(max(s.v, t.v))\n __mul__=lambda s,t:F(min(s.v, t.v))\n def __init__(s,v):s.v = v\nimport itertools as i,re\nwhile 1:\n s=raw_input()\n if s==\".\":break\n s=re.sub(\"([0-R])\",\"F(\\\\1)\",s)\n print sum(eval(s).v==2 for P,Q,R in i.product([0,1,2],repeat=3))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nwhile True:\n    S_ = raw_input()\n    if S_ == '.':\n        break\n\n    ans = 0\n    for p, q, r in it.product([0, 1, 2], repeat = 3):\n        S = S_\n        S = S.replace(\"P\", p).replace(\"Q\", q).replace(\"R\", r)\n        \n        for loop in range(50):\n            for loop2 in range(100):\n                S_pre = S\n                S = S.replace(\"-0\", \"2\")\n                S = S.replace(\"-1\", \"1\")\n                S = S.replace(\"-2\", \"0\")\n                if S == S_pre:\n                    break\n            for loop2 in range(50):\n                S_pre = S\n                for a, b in it.product([0, 1, 2], repeat = 2):\n                    S = S.replace(\"(%d*%d)\" % (x, y), str(min(x, y)))\n                    S = S.replace(\"(%d+%d)\" % (x, y), str(max(x, y)))\n                if S == S_pre:\n                    break\n        if S == \"2\":\n            ans += 1\n    print ans\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\nclass Ternary:\n\tdef __init__(self,n): \n\t\tself.n=n\n\tdef __int__(self):\n\t\treturn self.n\n\tdef __neg__(self):\n\t\treturn Ternary(2-int(self))\n\tdef __mul__(self,o):\n\t\treturn Ternary(min(int(self),int(o)))\n\tdef __add__(self,o):\n\t\treturn Ternary(max(int(self),int(o)))\n\nimport sys, itertools\nfrom functools import reduce\nR=[0,1,2]\nwhile True:\n\ts=sys.stdin.readline().rstrip()\n\tif s=='.': break\n\tr=0\n\tfor (a,b,c) in itertools.product(R,repeat=3):\n\t\tt=reduce(lambda t,e:t.replace(e[0],'Ternary(%d)'%e[1]),[['0',0],['1',1],['2',2],['P',a],['Q',b],['R',c]],s)\n\t\tif int(eval(t))==2: r+=1\n\tprint(r)\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1155: How can I satisfy thee? Let me count\n# Python3 2018.7.17 bal4u\n\ndef term(idx):\n    x, idx = factor(idx)\n    op = buf[idx]\n    y, idx = factor(idx+1);\n    if op == '*':\n        if x == 2 and y == 2: x = 2\n        elif x == 0 or y == 0: x = 0\n        else: x = 1\n    else:\n        if x == 0 and y == 0: x = 0\n        elif x == 2 or y == 2: x = 2\n        else: x = 1\n    return [x, idx]\n\ndef factor(idx):\n    global p, q, r\n    if buf[idx] == '(': x, idx = term(idx+1)\n    elif buf[idx] == '-':\n        x, idx = factor(idx+1)\n        x = 2-x; idx -= 1\n    elif '0'<= buf[idx] <='9': x = int(buf[idx])\n    elif buf[idx] == 'P': x = p\n    elif buf[idx] == 'Q': x = q\n    else: x = r\n    return [x, idx+1]\n\nwhile True:\n    buf = list(input())\n    if buf[0] == '.': break\n    ans = 0\n    for p in range(3):\n        for q in range(3):\n            for r in range(3):\n                if factor(0)[0] == 2: ans += 1\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "just_len = 60\n\nimport re\nimport collections\n\nNUM     = r'(?P<NUM>\\d+)'\nPLUS    = r'(?P<PLUS>\\+)'\nMINUS   = r'(?P<MINUS>-)'\nTIMES   = r'(?P<TIMES>\\*)'\nLPAREN  = r'(?P<LPAREN>\\()'\nRPAREN  = r'(?P<RPAREN>\\))'\nWS      = r'(?P<WS>\\s+)'\n\nmaster_pattern = re.compile('|'.join((NUM, PLUS, MINUS, TIMES, LPAREN, RPAREN, WS)))\nToken = collections.namedtuple('Token', ['type', 'value'])\n\n\ndef generate_tokens(pattern, text):\n    scanner = pattern.scanner(text)\n    for m in iter(scanner.match, None):\n        token = Token(m.lastgroup, m.group())\n\n        if token.type != 'WS':\n            yield token\n\n\ndef minus(x):\n  if x==0: ans=2\n  if x==1: ans=1\n  if x==2: ans=0\n  return ans\n\ndef mult(x,y):\n  if x==0:\n    a=0\n  if x==1:\n    if y==0: a=0\n    if y==1: a=1\n    if y==2: a=1\n  if x==2:\n    if y==0: a=0\n    if y==1: a=1\n    if y==2: a=2\n  return a\n\ndef add(x,y):\n  if x==0:\n    if y==0: a=0\n    if y==1: a=1\n    if y==2: a=2\n  if x==1:\n    if y==0: a=1\n    if y==1: a=1\n    if y==2: a=2\n  if x==2:\n    a=2\n  return a\n\nclass ExpressionEvaluator:\n    def parse(self, text):\n        self.tokens = generate_tokens(master_pattern, text)\n        self.current_token = None\n        self.next_token = None\n        self._advance()\n\n        # expr is the top level grammar. So we invoke that first.\n        # it will invoke other function to consume tokens according to grammar rule.\n        return self.expr()\n\n    def _advance(self):\n        self.current_token, self.next_token = self.next_token, next(self.tokens, None)\n\n    def _accept(self, token_type):\n        # if there is next token and token type matches\n        if self.next_token and self.next_token.type == token_type:\n            self._advance()\n            return True\n        else:\n            return False\n\n    def _expect(self, token_type):\n        if not self._accept(token_type):\n            raise SyntaxError('Expected ' + token_type)\n\n    def expr(self):\n        '''\n        expression ::= term { ( +|-) term } *\n        '''\n        expr_value = self.term()\n        while self._accept('PLUS') or self._accept('MINUS'):\n            op = self.current_token.type\n\n            right = self.term()\n            if op == 'PLUS':\n                #expr_value += right\n                expr_value = add(expr_value, right)\n            elif op == 'MINUS':\n                #expr_value -= right\n                expr_value = add(expr_value, minus(right))\n            else:\n                raise SyntaxError('Should not arrive here ' + op)\n\n        return expr_value\n\n    def term(self):\n        '''\n        term    ::= factor { ('*') factor } *\n        '''\n        term_value = self.factor()\n        while self._accept('TIMES') or self._accept('DIVIDE'):\n            op = self.current_token.type\n\n            if op == 'TIMES':\n                #term_value *= self.factor()\n                term_value = mult(term_value, self.factor())\n            else:\n                raise SyntaxError('Should not arrive here ' + op)\n\n        return term_value\n\n    def factor(self):\n        '''\n        factor  ::= NUM | (expr) | -(factor)\n\n        '''\n\n        # it can be a number\n        if self._accept('NUM'):\n            expr_value = int(self.current_token.value)\n        # or (expr)\n        elif self._accept('LPAREN'):\n            expr_value = self.expr()\n            self._expect('RPAREN')\n        elif self._accept('MINUS'):\n            expr_value = minus(self.factor())\n        else:\n            raise SyntaxError('Expect NUMBER or LPAREN')\n        return expr_value\n\n\ne = ExpressionEvaluator()\n# print('parse 2'.ljust(just_len),\n#       e.parse('2'))\n#\n# print('parse 2 + 3'.ljust(just_len),\n#       e.parse('2 + 3'))\n# print('parse 2 + 3 * 4'.ljust(just_len),\n#       e.parse('2 + 3 * 4'))\n#\n# print('parse (2 + 3) * 4'.ljust(just_len),\n#       e.parse('(2 + 3) * 4'))\nwhile True:\n  rS=input()\n  if rS=='.': break\n\n  ans=0\n  for p in range(3):\n    for q in range(3):\n      for r in range(3):\n        S = rS.replace('P',str(p))\\\n              .replace('Q',str(q))\\\n              .replace('R',str(r))\n        if e.parse(S)==2: ans+=1\n  print(ans)"
  },
  {
    "language": "Python",
    "code": "import itertools\ns = \"\"\nwhile True:\n\ts = raw_input()\n\tif s == \".\": break\n\tcount = 0\n\tfor p, q, r in itertools.product(xrange(3), repeat=3):\n\t\tf = s.replace(\"P\", str(p)).replace(\"Q\", str(q)).replace(\"R\", str(r))\n\t\twhile len(f) > 1:\n\t\t\tf = f.replace(\"-0\", \"2\").replace(\"-1\", \"1\").replace(\"-2\", \"0\")\n\t\t\tfor x, y in itertools.product(xrange(3), repeat=2):\n\t\t\t\tf = f.replace(\"(%d*%d)\" % (x, y), str(min(x, y)))\n\t\t\t\tf = f.replace(\"(%d+%d)\" % (x, y), str(max(x, y)))\n\t\tif f == \"2\":\n\t\t\tcount += 1\n\tprint count"
  },
  {
    "language": "Python",
    "code": "import re\n# and\ndef and_def(a, b):\n    return str(min(int(a), int(b)))\n\n# or\ndef or_def(a, b):\n    return str(max(int(a), int(b)))\n\n# not\ndef not_def(a):\n    return str(2 - int(a))\n\ndef match(struct):\n    if re.fullmatch(r'\\-[0,1,2]', struct):\n        return not_def(struct[-1])\n    if re.fullmatch(r'[0,1,2]\\+[0,1,2]', struct):\n        return or_def(struct[0], struct[-1])\n    if re.fullmatch(r'[0,1,2]\\*[0,1,2]', struct):\n        return and_def(struct[0], struct[-1])\n    if re.fullmatch(r'[0,1,2]', struct):\n        return struct\n    if re.fullmatch(r'\\([0,1,2]\\)', struct):\n        return struct[1]\n    return struct\n\ndef parse(struct):\n    tmpstruct = ''\n    check, minas = False, False\n    if len(struct) == 1:\n        return struct\n\n    for i in range(len(struct)):\n        if not check:\n            if struct[i] == '(':\n                check = [')', '(']\n                tmp = 1\n                num = i\n            elif struct[i] == '-':\n                check = ['0', '1', '2', '(']\n                minas = True\n                num = i\n            else:\n                tmpstruct += struct[i]\n\n        else:\n            if struct[i] in check:\n                if struct[i] == ')':\n                    tmp -= 1\n                    if not tmp:\n                        if not minas:\n                            tmpstruct += parse(struct[num+1: i])\n                        else:\n                            tmpstruct += not_def(parse(struct[num + 1: i + 1]))\n                            minas = False\n                        check = False\n                elif struct[i] == '(' and check == ['0', '1', '2', '(']:\n                    check = [')', '(']\n                    tmp = 1\n                elif struct[i] == '(':\n                    tmp += 1\n                else:\n                    tmpstruct += not_def(parse(struct[num + 1: i + 1]))\n                    check = False\n                    minas = False\n        tmpstruct = match(tmpstruct)\n    return tmpstruct\n\n\ndef change_PQR(string, P, Q, R):\n    ret = ''\n    for i in string:\n        if i == 'P':\n            ret += str(P)\n        elif i == 'Q':\n            ret += str(Q)\n        elif i == 'R':\n            ret += str(R)\n        else:\n            ret += i\n    return ret\n\n\nwhile True:\n    struct = input()\n    if struct == '.':\n        break\n\n    ans = 0\n    for i in (0, 1, 2):\n        for j in (0, 1, 2):\n            for k in (0, 1, 2):\n                tmpstr = struct\n                if parse(change_PQR(tmpstr, i, j, k)) == '2':\n                    ans += 1\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nclass mybool:\n    def __init__(self, value):\n        self.value = value\n    def __neg__(self):\n        return mybool(2-self.value)\n    def __mul__(self, other):\n        return mybool(min(self.value,other.value))\n    def __add__(self, other):\n        return mybool(max(self.value,other.value))\n\nwhile 1:\n    s = raw_input()\n    if s == \".\": break\n    \n    while \"--\" in s: s = s.replace(\"--\",\"\")\n    s = s.replace(\"2\",\"mybool(2)\").replace(\"1\",\"mybool(1)\").replace(\"0\",\"mybool(0)\")\n    \n    ans = 0\n    for p,q,r in it.product([0,1,2],repeat=3):\n        P,Q,R = mybool(p),mybool(q),mybool(r)\n        if eval(s).value == 2:\n            ans += 1\n    \n    print ans\n    "
  },
  {
    "language": "Python",
    "code": "def parse_formula(s, pointer):\n    head = s[pointer]\n    if head == \"-\":\n        pointer += 1\n        result, pointer = parse_formula(s, pointer)\n        result = 2 - result\n    elif head == \"(\":\n        pointer += 1\n        result_left, pointer = parse_formula(s, pointer)\n        op, pointer = parse_op(s, pointer)\n        result_right, pointer = parse_formula(s, pointer)\n        result = calc(op, result_left, result_right)\n        pointer += 1\n    else:\n        result = int(head)\n        pointer += 1\n    return result, pointer\n\n\ndef parse_op(s, pointer):\n    return s[pointer], pointer + 1\n\n\ncalc_table1 = {(0, 0):0, (0, 1):0, (0, 2):0,\n               (1, 0):0, (1, 1):1, (1, 2):1,\n               (2, 0):0, (2, 1):1, (2, 2):2}\ncalc_table2 = {(0, 0):0, (0, 1):1, (0, 2):2,\n               (1, 0):1, (1, 1):1, (1, 2):2,\n               (2, 0):2, (2, 1):2, (2, 2):2}\n\n\ndef calc(op, left, right):\n    if op == \"*\":return calc_table1[(left, right)]\n    if op == \"+\":return calc_table2[(left, right)]\n\n\nwhile True:\n    formula = input()\n    if formula == \".\":\n        break\n    ans = 0\n    for p in (\"0\", \"1\", \"2\"):\n        sp = formula.replace(\"P\", p)\n        for q in (\"0\", \"1\", \"2\"):\n            sq = sp.replace(\"Q\", q)\n            for r in (\"0\", \"1\", \"2\"):\n                sr = sq.replace(\"R\", r)\n                if parse_formula(sr, 0)[0] == 2:\n                    ans += 1\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\nclass Ternary:\n\tdef __init__(self,n): \n\t\tself.n=n\n\tdef __int__(self):\n\t\treturn self.n\n\tdef __neg__(self):\n\t\treturn Ternary(2-int(self))\n\tdef __mul__(self,o):\n\t\treturn Ternary(min(int(self),int(o)))\n\tdef __add__(self,o):\n\t\treturn Ternary(max(int(self),int(o)))\n\nimport sys, itertools\nfrom functools import reduce\nR=[0,1,2]\nwhile True:\n\ts=sys.stdin.readline().rstrip()\n\tif s=='.': break\n\tr=0\n\tfor (a,b,c) in itertools.product(R,repeat=3):\n\t\tt=reduce(lambda t,e:t.replace(e[0],'Ternary(%d)'%e[1]),[['0',0],['1',1],['2',2],['P',a],['Q',b],['R',c]],s)\n\t\tif int(eval(t))==2: r+=1\n\tprint(r)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nwhile True:\n    S_ = raw_input()\n    if S_ == '.':\n        break\n\n    ans = 0\n    for p, q, r in it.product([0, 1, 2], repeat = 3):\n        S = S_\n        S = S.replace(\"P\", str(p)).replace(\"Q\", str(q)).replace(\"R\", str(r))\n\n        while len(S) != 1:\n            S = S.replace(\"-0\", \"2\")\n            S = S.replace(\"-1\", \"1\")\n            S = S.replace(\"-2\", \"0\")\n            for a, b in it.product([0, 1, 2], repeat = 2):\n                S = S.replace(\"(%d*%d)\" % (a, b), str(min(a, b)))\n                S = S.replace(\"(%d+%d)\" % (a, b), str(max(a, b)))\n            \n        if S == \"2\":\n            ans += 1\n    print ans\n"
  },
  {
    "language": "Python",
    "code": "def parseParenthesis(formula):\n    pos = 0\n    count = 0\n    while True:\n        if formula[pos] == '(':\n            count += 1\n        elif formula[pos] == ')':\n            count -= 1\n        elif count == 1 and (formula[pos] == '+' or formula[pos] == '*'):\n            sign = formula[pos]\n            formulaA = formula[1:pos]\n            formulaB = formula[pos + 1: -1]\n            return formulaA, sign, formulaB\n        pos += 1\n\ndef eval_or(a, b):\n    if a == '0':\n        return b\n    elif a == '1':\n        return '1' if b == '0' else b\n    elif a == '2':\n        return '2'\n\ndef eval_and(a, b):\n    if a == '0':\n        return '0'\n    elif a == '1':\n        return '0' if b == '0' else '1'\n    elif a == '2':\n        return b\n\ndef eval_neg(a):\n    if a == '1':\n        return '1'\n    return '2' if a == '0' else '0'\n\ndef evaluate(formula, p, q, r):\n    if formula == '0' or formula == '1' or formula == '2':\n        return formula\n    if formula == 'P':\n        return p\n    if formula == 'Q':\n        return q\n    if formula == 'R':\n        return r\n\n    if formula[0] == '(':\n        formulaA, sign, formulaB = parseParenthesis(formula)\n        evalA = evaluate(formulaA, p, q, r)\n        evalB = evaluate(formulaB, p, q, r)\n        if sign == '+':\n            return eval_or(evalA, evalB)\n        elif sign == '*':\n            return eval_and(evalA, evalB)\n    elif formula[0] == '-':\n        return eval_neg(evaluate(formula[1:], p, q, r))\n\nif __name__ == '__main__':\n    while True:\n        formula = input().strip()\n        if formula == '.':\n            break\n\n        count = 0\n        for p in range(3):\n            for q in range(3):\n                for r in range(3):\n                    if evaluate(formula, str(p), str(q), str(r)) == '2':\n                        count += 1\n        print(count)\n"
  },
  {
    "language": "Python",
    "code": "class N:\n    def __init__(self, a):\n        self.a = a\n\n    def __mul__(self, b):\n        if self.a == 0:\n            return N(0)\n        elif self.a == 1:\n            return N((b.a >= 1) * 1)\n        else:\n            return b\n\n    def __add__(self, b):\n        if self.a == 0:\n            return b\n        elif self.a == 1:\n            return N((b.a > 1) + 1)\n        else:\n            return N(2)\n\n    def __neg__(self):\n        if self.a == 2:\n            return N(0)\n        elif self.a == 1:\n            return N(1)\n        else:\n            return N(2)\n\nwhile True:\n    s = input().replace(\"-\", \"-\").replace(\"0\", \"N(0)\").replace(\"1\", \"N(1)\").replace(\"2\", \"N(2)\")\n    N(1) + N(2)\n    if s == \".\": break\n\n    result = []\n    for P in map(N, range(3)):\n        for Q in map(N, range(3)):\n            for R in map(N, range(3)):\n                result.append(eval(s).a)\n    print(result.count(2))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nwhile True:\n    S_ = raw_input()\n    if S_ == '.':\n        break\n\n    lst = []\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                lst.append((str(i), str(j), str(k)))\n    \n    ans = 0\n    for p in lst:\n        S = S_\n        S = S.replace(\"P\", p[0])\n        S = S.replace(\"Q\", p[1])\n        S = S.replace(\"R\", p[2])\n        for loop in range(50):\n            for loop2 in range(100):\n                S_pre = S\n                S = S.replace(\"-0\", \"2\")\n                S = S.replace(\"-1\", \"1\")\n                S = S.replace(\"-2\", \"0\")\n                if S == S_pre:\n                    break\n            for loop2 in range(50):\n                S_pre = S\n                S = S.replace(\"(0*0)\", \"0\")\n                S = S.replace(\"(0*1)\", \"0\")\n                S = S.replace(\"(0*2)\", \"0\")\n                S = S.replace(\"(1*0)\", \"0\")\n                S = S.replace(\"(1*1)\", \"1\")\n                S = S.replace(\"(1*2)\", \"1\")\n                S = S.replace(\"(2*0)\", \"0\")\n                S = S.replace(\"(2*1)\", \"1\")\n                S = S.replace(\"(2*2)\", \"2\")\n                S = S.replace(\"(0+0)\", \"0\")\n                S = S.replace(\"(0+1)\", \"1\")\n                S = S.replace(\"(0+2)\", \"2\")\n                S = S.replace(\"(1+0)\", \"1\")\n                S = S.replace(\"(1+1)\", \"1\")\n                S = S.replace(\"(1+2)\", \"2\")\n                S = S.replace(\"(2+0)\", \"2\")\n                S = S.replace(\"(2+1)\", \"2\")\n                S = S.replace(\"(2+2)\", \"2\")\n                if S == S_pre:\n                    break\n        if S == \"2\":\n            ans += 1\n    print ans\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\n\ndef parse(expr):\n    if expr == \"P\":\n        return lambda p, q, r: p\n    if expr == \"Q\":\n        return lambda p, q, r: q\n    if expr == \"R\":\n        return lambda p, q, r: r\n    if expr == \"0\":\n        return lambda p, q, r: 0\n    if expr == \"1\":\n        return lambda p, q, r: 1\n    if expr == \"2\":\n        return lambda p, q, r: 2\n    if expr[0] == \"-\":\n        t = parse(expr[1:])\n        return lambda p, q, r: 2 - t(p, q, r)\n    if expr[0] != \"(\" or expr[-1] != \")\":\n        raise SyntaxError(\"invalid syntax\")\n    depth = 0\n    i = 1\n    l = len(expr) - 1\n    op_pos = -1\n    while i < l:\n        c = expr[i]\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c in (\"+\", \"*\"):\n            if op_pos != -1:\n                raise SyntaxError(\"invalid syntax\")\n            op_pos = i\n        i += 1\n    if depth != 0 or op_pos == -1:\n        raise SyntaxError(\"invalid syntax\")\n    op = {\n        \"+\": lambda x, y: max(x, y),\n        \"*\": lambda x, y: min(x, y)\n    }[expr[op_pos]]\n    lhs = parse(expr[1:op_pos])\n    rhs = parse(expr[op_pos + 1:-1])\n    return lambda p, q, r: op(lhs(p, q, r), rhs(p, q, r))\n\n\n# first part\nwhile True:\n    line = raw_input()\n    if line == \".\":\n        break\n    ans = 0\n\n    f = parse(line)\n    for p, q, r in itertools.product((0, 1, 2), repeat=3):\n        if f(p, q, r) == 2:\n            ans += 1\n\n    print ans"
  }
]