[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint evaluate(char *expr, int P, int Q, int R);\nint parse_expression(char **expr, int P, int Q, int R);\nint parse_term(char **expr, int P, int Q, int R);\nint parse_factor(char **expr, int P, int Q, int R);\n\nint evaluate(char *expr, int P, int Q, int R) {\n    char *ptr = expr;\n    return parse_expression(&ptr, P, Q, R);\n}\n\nint parse_expression(char **expr, int P, int Q, int R) {\n    int left = parse_term(expr, P, Q, R);\n    while (**expr == '+' || **expr == '-') {\n        char op = **expr;\n        (*expr)++;\n        int right = parse_term(expr, P, Q, R);\n        if (op == '+') {\n            left = (left > right) ? left : right;\n        } else {\n            left = (left < right) ? left : right;\n        }\n    }\n    return left;\n}\n\nint parse_term(char **expr, int P, int Q, int R) {\n    int left = parse_factor(expr, P, Q, R);\n    while (**expr == '*') {\n        (*expr)++;\n        int right = parse_factor(expr, P, Q, R);\n        left = (left < right) ? left : right;\n    }\n    return left;\n}\n\nint parse_factor(char **expr, int P, int Q, int R) {\n    if (**expr == '(') {\n        (*expr)++;\n        int val = parse_expression(expr, P, Q, R);\n        (*expr)++;\n        return val;\n    } else if (**expr == '-') {\n        (*expr)++;\n        int val = parse_factor(expr, P, Q, R);\n        return 2 - val;\n    } else {\n        char c = **expr;\n        (*expr)++;\n        if (c == 'P') return P;\n        if (c == 'Q') return Q;\n        if (c == 'R') return R;\n        return c - '0';\n    }\n}\n\nint main() {\n    char formula[1000];\n    while (scanf(\"%s\", formula) == 1) {\n        if (formula[0] == '.') break;\n        int count = 0;\n        for (int P = 0; P < 3; P++) {\n            for (int Q = 0; Q < 3; Q++) {\n                for (int R = 0; R < 3; R++) {\n                    char *expr = strdup(formula);\n                    int result = evaluate(expr, P, Q, R);\n                    free(expr);\n                    if (result == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ThreeValuedLogic {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String formula = scanner.nextLine();\n            if (formula.equals(\".\")) break;\n            System.out.println(countSatisfyingTriples(formula));\n        }\n        scanner.close();\n    }\n\n    static int countSatisfyingTriples(String formula) {\n        int count = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    if (evaluateFormula(formula, p, q, r) == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    static int evaluateFormula(String formula, int p, int q, int r) {\n        formula = formula.replace('P', (char)(p + '0'))\n                         .replace('Q', (char)(q + '0'))\n                         .replace('R', (char)(r + '0'));\n        return evaluateExpression(formula);\n    }\n\n    static int evaluateExpression(String expr) {\n        expr = expr.trim();\n        if (expr.length() == 1) return expr.charAt(0) - '0';\n        \n        if (expr.charAt(0) == '(') {\n            int parenthesesCount = 0;\n            for (int i = 0; i < expr.length(); i++) {\n                if (expr.charAt(i) == '(') parenthesesCount++;\n                if (expr.charAt(i) == ')') parenthesesCount--;\n                \n                if (parenthesesCount == 0 && (expr.charAt(i) == '+' || expr.charAt(i) == '*')) {\n                    int left = evaluateExpression(expr.substring(1, i));\n                    int right = evaluateExpression(expr.substring(i + 1, expr.length() - 1));\n                    \n                    if (expr.charAt(i) == '+') return threeValuedOr(left, right);\n                    if (expr.charAt(i) == '*') return threeValuedAnd(left, right);\n                }\n            }\n        }\n        \n        if (expr.charAt(0) == '-') {\n            return threeValuedNot(evaluateExpression(expr.substring(1)));\n        }\n        \n        return expr.charAt(0) - '0';\n    }\n\n    static int threeValuedNot(int a) {\n        return 2 - a;\n    }\n\n    static int threeValuedAnd(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    static int threeValuedOr(int a, int b) {\n        return Math.max(a, b);\n    }\n}",
    "timestamp": "2025-08-05 19:07:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint evaluate(int P, int Q, int R, const string& expr) {\n    stack<int> values;\n    stack<char> ops;\n    map<char, int> vars = {{'P', P}, {'Q', Q}, {'R', R}};\n\n    auto precedence = [](char op) {\n        if (op == '-') return 3;\n        if (op == '*') return 2;\n        if (op == '+') return 1;\n        return 0;\n    };\n\n    auto applyOp = [](int a, int b, char op) {\n        if (op == '*') return min(a, b);\n        if (op == '+') return max(a, b);\n        return 0;\n    };\n\n    auto applyNeg = [](int a) {\n        if (a == 0) return 2;\n        if (a == 2) return 0;\n        return 1;\n    };\n\n    for (int i = 0; i < expr.size(); ++i) {\n        if (expr[i] == ' ') continue;\n        if (expr[i] == '(') {\n            ops.push(expr[i]);\n        } else if (isdigit(expr[i])) {\n            values.push(expr[i] - '0');\n        } else if (vars.find(expr[i]) != vars.end()) {\n            values.push(vars[expr[i]]);\n        } else if (expr[i] == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                char op = ops.top();\n                ops.pop();\n                if (op == '-') {\n                    int val = values.top();\n                    values.pop();\n                    values.push(applyNeg(val));\n                } else {\n                    int val2 = values.top();\n                    values.pop();\n                    int val1 = values.top();\n                    values.pop();\n                    values.push(applyOp(val1, val2, op));\n                }\n            }\n            ops.pop();\n        } else {\n            while (!ops.empty() && precedence(ops.top()) >= precedence(expr[i])) {\n                char op = ops.top();\n                ops.pop();\n                if (op == '-') {\n                    int val = values.top();\n                    values.pop();\n                    values.push(applyNeg(val));\n                } else {\n                    int val2 = values.top();\n                    values.pop();\n                    int val1 = values.top();\n                    values.pop();\n                    values.push(applyOp(val1, val2, op));\n                }\n            }\n            ops.push(expr[i]);\n        }\n    }\n\n    while (!ops.empty()) {\n        char op = ops.top();\n        ops.pop();\n        if (op == '-') {\n            int val = values.top();\n            values.pop();\n            values.push(applyNeg(val));\n        } else {\n            int val2 = values.top();\n            values.pop();\n            int val1 = values.top();\n            values.pop();\n            values.push(applyOp(val1, val2, op));\n        }\n    }\n\n    return values.top();\n}\n\nint main() {\n    string formula;\n    while (getline(cin, formula)) {\n        if (formula == \".\") break;\n        string expr;\n        for (char c : formula) {\n            if (c == '.') break;\n            expr += c;\n        }\n        int count = 0;\n        for (int P = 0; P <= 2; ++P) {\n            for (int Q = 0; Q <= 2; ++Q) {\n                for (int R = 0; R <= 2; ++R) {\n                    if (evaluate(P, Q, R, expr) == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint evaluate(char* formula, int p, int q, int r) {\n    char expr[100];\n    strcpy(expr, formula);\n    int len = strlen(expr);\n    \n    for (int i = 0; i < len; i++) {\n        if (expr[i] == 'P') expr[i] = p + '0';\n        if (expr[i] == 'Q') expr[i] = q + '0';\n        if (expr[i] == 'R') expr[i] = r + '0';\n    }\n    \n    int stack[100];\n    int top = -1;\n    \n    for (int i = 0; i < len; i++) {\n        if (expr[i] >= '0' && expr[i] <= '2') {\n            stack[++top] = expr[i] - '0';\n        } else if (expr[i] == '-') {\n            int val = stack[top--];\n            stack[++top] = 2 - val;\n        } else if (expr[i] == '*') {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = (a < b) ? a : b;\n        } else if (expr[i] == '+') {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = (a > b) ? a : b;\n        }\n    }\n    \n    return stack[top];\n}\n\nint main() {\n    char formula[100];\n    \n    while (1) {\n        scanf(\"%s\", formula);\n        \n        if (formula[0] == '.') break;\n        \n        int count = 0;\n        for (int p = 0; p < 3; p++) {\n            for (int q = 0; q < 3; q++) {\n                for (int r = 0; r < 3; r++) {\n                    if (evaluate(formula, p, q, r) == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cctype>\n\nusing namespace std;\n\nint apply_negation(int val) {\n    return (val == 0) ? 2 : (val == 2) ? 0 : 1;\n}\n\nint apply_conjunction(int a, int b) {\n    if (a == 0 || b == 0) return 0;\n    if (a == 2 && b == 2) return 2;\n    return 1;\n}\n\nint apply_disjunction(int a, int b) {\n    if (a == 2 || b == 2) return 2;\n    if (a == 0 && b == 0) return 0;\n    return 1;\n}\n\nint evaluate(const string& expr, int p, int q, int r) {\n    stack<int> values;\n    stack<char> ops;\n\n    for (int i = 0; i < expr.length(); ++i) {\n        if (expr[i] == ' ') continue;\n\n        if (expr[i] == 'P') values.push(p);\n        else if (expr[i] == 'Q') values.push(q);\n        else if (expr[i] == 'R') values.push(r);\n        else if (isdigit(expr[i])) values.push(expr[i] - '0');\n        else if (expr[i] == '(') ops.push(expr[i]);\n        else if (expr[i] == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                char op = ops.top();\n                ops.pop();\n                int b = values.top(); values.pop();\n                int a = values.top(); values.pop();\n\n                if (op == '*') values.push(apply_conjunction(a, b));\n                else if (op == '+') values.push(apply_disjunction(a, b));\n            }\n            if (!ops.empty() && ops.top() == '(') ops.pop();\n        }\n        else if (expr[i] == '-') {\n            int val = values.top(); values.pop();\n            values.push(apply_negation(val));\n        }\n        else if (expr[i] == '*' || expr[i] == '+') {\n            while (!ops.empty() && ops.top() != '(') {\n                char top_op = ops.top();\n                int b = values.top(); values.pop();\n                int a = values.top(); values.pop();\n\n                if (top_op == '*') values.push(apply_conjunction(a, b));\n                else if (top_op == '+') values.push(apply_disjunction(a, b));\n                ops.pop();\n            }\n            ops.push(expr[i]);\n        }\n    }\n\n    while (!ops.empty()) {\n        char op = ops.top(); ops.pop();\n        int b = values.top(); values.pop();\n        int a = values.top(); values.pop();\n\n        if (op == '*') values.push(apply_conjunction(a, b));\n        else if (op == '+') values.push(apply_disjunction(a, b));\n    }\n\n    return values.top();\n}\n\nint main() {\n    string formula;\n    while (getline(cin, formula) && formula != \".\") {\n        int count = 0;\n        for (int p = 0; p < 3; ++p) {\n            for (int q = 0; q < 3; ++q) {\n                for (int r = 0; r < 3; ++r) {\n                    if (evaluate(formula, p, q, r) == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ThreeValuedLogic {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine().trim();\n            if (line.equals(\".\")) {\n                break;\n            }\n            String formula = line.substring(0, line.length() - 1).trim();\n            int count = 0;\n            for (int p = 0; p < 3; p++) {\n                for (int q = 0; q < 3; q++) {\n                    for (int r = 0; r < 3; r++) {\n                        if (evaluate(formula, p, q, r) == 2) {\n                            count++;\n                        }\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n        scanner.close();\n    }\n\n    private static int evaluate(String expr, int p, int q, int r) {\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (c == ' ') {\n                continue;\n            }\n            if (c == 'P' || c == 'Q' || c == 'R') {\n                int val = 0;\n                if (c == 'P') val = p;\n                else if (c == 'Q') val = q;\n                else if (c == 'R') val = r;\n                values.push(val);\n            } else if (c == '0' || c == '1' || c == '2') {\n                values.push(c - '0');\n            } else if (c == '(') {\n                ops.push(c);\n            } else if (c == ')') {\n                while (ops.peek() != '(') {\n                    values.push(applyOp(ops.pop(), values.pop(), values.isEmpty() ? 0 : values.pop()));\n                }\n                ops.pop();\n            } else if (c == '-' || c == '*' || c == '+') {\n                while (!ops.isEmpty() && precedence(c) <= precedence(ops.peek())) {\n                    values.push(applyOp(ops.pop(), values.pop(), values.isEmpty() ? 0 : values.pop()));\n                }\n                ops.push(c);\n            }\n        }\n        while (!ops.isEmpty()) {\n            values.push(applyOp(ops.pop(), values.pop(), values.isEmpty() ? 0 : values.pop()));\n        }\n        return values.pop();\n    }\n\n    private static int precedence(char op) {\n        if (op == '-') return 3;\n        if (op == '*') return 2;\n        if (op == '+') return 1;\n        return 0;\n    }\n\n    private static int applyOp(char op, int b, int a) {\n        switch (op) {\n            case '-':\n                return (3 - b) % 3;\n            case '*':\n                return Math.min(a, b);\n            case '+':\n                return Math.max(a, b);\n        }\n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 19:09:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def three_valued_logic(formula):\n    ops = {\n        '-': lambda x: 2-x,\n        '*': lambda x, y: min(x, y),\n        '+': lambda x, y: max(x, y),\n    }\n    \n    def eval_expr(expr, values):\n        stack = []\n        for token in expr:\n            if token in 'PQR':\n                stack.append(values[token])\n            elif token in '012':\n                stack.append(int(token))\n            elif token == '-':\n                val = stack.pop()\n                stack.append(ops['-'](val))\n            elif token in '*+':\n                b = stack.pop()\n                a = stack.pop()\n                stack.append(ops[token](a, b))\n        return stack[0] == 2\n    \n    def to_rpn(expr):\n        precedence = {'-': 3, '*': 2, '+': 1}\n        output = []\n        operators = []\n        i = 0\n        while i < len(expr):\n            char = expr[i]\n            if char in '012PQR':\n                output.append(char)\n            elif char in '-':\n                operators.append(char)\n            elif char in '*+':\n                while operators and precedence[operators[-1]] >= precedence[char]:\n                    output.append(operators.pop())\n                operators.append(char)\n            elif char == '(':\n                operators.append(char)\n            elif char == ')':\n                while operators and operators[-1] != '(':\n                    output.append(operators.pop())\n                operators.pop()\n            i += 1\n            if expr[i] == '.':\n                break\n        while operators:\n            output.append(operators.pop())\n        return output\n    \n    expr = formula.rstrip('.')\n    if not expr:\n        return 0\n    \n    expr_rpn = to_rpn(expr)\n    \n    count = 0\n    for p in range(3):\n        for q in range(3):\n            for r in range(3):\n                values = {'P': p, 'Q': q, 'R': r}\n                if eval_expr(expr_rpn, values):\n                    count += 1\n    return count\n\n# Example usage:\n# formula = \"P*Q+R-.\"\n# print(three_valued_logic(formula))",
    "timestamp": "2025-08-13 02:37:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class ThreeValuedLogic {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String input = scanner.nextLine().trim();\n            if (input.equals(\".\")) break;\n            input = input.substring(0, input.length() - 1); // Remove the ending period\n            int count = countSatisfyingTriples(input);\n            System.out.println(count);\n        }\n        scanner.close();\n    }\n\n    private static int countSatisfyingTriples(String formula) {\n        int count = 0;\n        int[] values = {0, 1, 2};\n        for (int p : values) {\n            for (int q : values) {\n                for (int r : values) {\n                    if (evaluate(formula, p, q, r) == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    private static int evaluate(String formula, int p, int q, int r) {\n        int[] stack = new int[formula.length()];\n        int top = -1;\n\n        for (int i = 0; i < formula.length(); i++) {\n            char c = formula.charAt(i);\n            \n            if (c == 'P') stack[++top] = p;\n            else if (c == 'Q') stack[++top] = q;\n            else if (c == 'R') stack[++top] = r;\n            else if (c >= '0' && c <= '2') stack[++top] = c - '0';\n            else if (c == '-') {\n                int a = stack[top--];\n                stack[++top] = negate(a);\n            } else if (c == '*') {\n                int b = stack[top--];\n                int a = stack[top--];\n                stack[++top] = conjunction(a, b);\n            } else if (c == '+') {\n                int b = stack[top--];\n                int a = stack[top--];\n                stack[++top] = disjunction(a, b);\n            } else if (c == '(' || c == ')') {\n                // Do nothing, just ignore parentheses\n            }\n        }\n        return stack[top];\n    }\n\n    private static int negate(int value) {\n        return 2 - value;\n    }\n\n    private static int conjunction(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    private static int disjunction(int a, int b) {\n        return Math.max(a, b);\n    }\n}",
    "timestamp": "2025-08-13 02:37:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n// Truth table for operations in 3-valued logic\nint negation[3] = {2, 1, 0}; // -, negation\nint conjunction[3][3] = {     // *, conjunction\n    {0, 0, 0},\n    {0, 1, 1},\n    {0, 1, 2}\n};\nint disjunction[3][3] = {     // +, disjunction\n    {0, 1, 2},\n    {1, 1, 2},\n    {2, 2, 2}\n};\n\n// Evaluate expression recursively\nint evaluate(char *expr, int p, int q, int r) {\n    char stack[100];\n    int top = -1;\n    int len = strlen(expr);\n    for (int i = 0; i < len; i++) {\n        char c = expr[i];\n        if (c == 'P') {\n            stack[++top] = p;\n        } else if (c == 'Q') {\n            stack[++top] = q;\n        } else if (c == 'R') {\n            stack[++top] = r;\n        } else if (c >= '0' && c <= '2') {\n            stack[++top] = c - '0';\n        } else if (c == '-') {\n            int operand = stack[top--];\n            stack[++top] = negation[operand];\n        } else if (c == '*' || c == '+') {\n            int operand2 = stack[top--];\n            int operand1 = stack[top--];\n            if (c == '*') {\n                stack[++top] = conjunction[operand1][operand2];\n            } else if (c == '+') {\n                stack[++top] = disjunction[operand1][operand2];\n            }\n        } else if (c == ' ') {\n            continue; // ignore spaces\n        }\n    }\n    return stack[top];\n}\n\n// Main driver\nint main() {\n    char formula[100];\n    while (scanf(\"%s\", formula) && formula[0] != '.') {\n        int count = 0;\n        for (int p = 0; p <= 2; ++p) {\n            for (int q = 0; q <= 2; ++q) {\n                for (int r = 0; r <= 2; ++r) {\n                    if (evaluate(formula, p, q, r) == 2) {\n                        count++;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 02:38:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate(formula, p, q, r):\n    formula = formula.replace('P', str(p)).replace('Q', str(q)).replace('R', str(r))\n    return eval(formula.replace('-', 'not ').replace('*', ' and ').replace('+', ' or '))\n\ndef solve_formula(formula):\n    count = 0\n    for p in range(3):\n        for q in range(3):\n            for r in range(3):\n                if evaluate(formula, p, q, r) == True:\n                    count += 1\n    return count\n\ndef main():\n    while True:\n        formula = input().strip()\n        if formula == '.':\n            break\n        print(solve_formula(formula))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:38:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef evaluate(formula, P, Q, R):\n    stack = []\n    for token in formula:\n        if token in ['0', '1', '2']:\n            stack.append(int(token))\n        elif token == 'P':\n            stack.append(P)\n        elif token == 'Q':\n            stack.append(Q)\n        elif token == 'R':\n            stack.append(R)\n        elif token == '-':\n            a = stack.pop()\n            res = 2 - a\n            stack.append(res)\n        elif token == '*':\n            a = stack.pop()\n            b = stack.pop()\n            res = min(a, b)\n            stack.append(res)\n        elif token == '+':\n            a = stack.pop()\n            b = stack.pop()\n            res = max(a, b)\n            stack.append(res)\n    return stack[0]\n\ndef count_satisfying_triples(formula):\n    count = 0\n    for P in [0, 1, 2]:\n        for Q in [0, 1, 2]:\n            for R in [0, 1, 2]:\n                if evaluate(formula, P, Q, R) == 2:\n                    count += 1\n    return count\n\ndef parse_formula(s):\n    output = []\n    op_stack = []\n    precedence = {'-': 3, '*': 2, '+': 1}\n    i = 0\n    while i < len(s):\n        c = s[i]\n        if c in ['P', 'Q', 'R', '0', '1', '2']:\n            output.append(c)\n        elif c == '(':\n            op_stack.append(c)\n        elif c == ')':\n            while op_stack and op_stack[-1] != '(':\n                output.append(op_stack.pop())\n            op_stack.pop()  # Remove '('\n        elif c in ['-', '*', '+']:\n            while op_stack and op_stack[-1] != '(' and precedence.get(op_stack[-1], 0) >= precedence.get(c, 0):\n                output.append(op_stack.pop())\n            op_stack.append(c)\n        i += 1\n    while op_stack:\n        output.append(op_stack.pop())\n    return output\n\ndef main():\n    for line in sys.stdin:\n        line = line.strip()\n        if line == '.':\n            break\n        formula = parse_formula(line)\n        print(count_satisfying_triples(formula))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:38:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n// Function to evaluate the logic expression\nint evaluate(const string& expr, int P, int Q, int R) {\n    vector<int> stack;\n    unordered_map<char, int> values = {{'P', P}, {'Q', Q}, {'R', R}};\n    \n    for (char ch : expr) {\n        if (ch == '0' || ch == '1' || ch == '2') {\n            stack.push_back(ch - '0');\n        } else if (ch == 'P' || ch == 'Q' || ch == 'R') {\n            stack.push_back(values[ch]);\n        } else if (ch == '-') {\n            int a = stack.back(); stack.pop_back();\n            stack.push_back(a == 2 ? 0 : a == 0 ? 2 : 1);\n        } else if (ch == '*') {\n            int b = stack.back(); stack.pop_back();\n            int a = stack.back(); stack.pop_back();\n            stack.push_back(a == 0 || b == 0 ? 0 : (a == 2 && b == 2) ? 2 : 1);\n        } else if (ch == '+') {\n            int b = stack.back(); stack.pop_back();\n            int a = stack.back(); stack.pop_back();\n            stack.push_back(a == 2 || b == 2 ? 2 : (a == 1 || b == 1) ? 1 : 0);\n        }\n    }\n    \n    return stack.back();\n}\n\n// Function to convert infix expression to postfix\nstring infixToPostfix(const string& infix) {\n    string postfix;\n    vector<char> ops;\n    unordered_map<char, int> precedence = {{'+', 1}, {'*', 2}, {'-', 3}};\n    \n    for (char ch : infix) {\n        if (isdigit(ch) || ch == 'P' || ch == 'Q' || ch == 'R') {\n            postfix += ch;\n        } else if (ch == '(') {\n            ops.push_back(ch);\n        } else if (ch == ')') {\n            while (!ops.empty() && ops.back() != '(') {\n                postfix += ops.back(); ops.pop_back();\n            }\n            ops.pop_back();\n        } else if (ch == '-' || ch == '*' || ch == '+') {\n            while (!ops.empty() && precedence[ops.back()] >= precedence[ch]) {\n                postfix += ops.back(); ops.pop_back();\n            }\n            ops.push_back(ch);\n        }\n    }\n    \n    while (!ops.empty()) {\n        postfix += ops.back(); ops.pop_back();\n    }\n    \n    return postfix;\n}\n\nint main() {\n    string formula;\n    while (cin >> formula) {\n        if (formula == \".\") break;\n\n        string postfix = infixToPostfix(formula);\n        int count = 0;\n\n        for (int P = 0; P <= 2; ++P) {\n            for (int Q = 0; Q <= 2; ++Q) {\n                for (int R = 0; R <= 2; ++R) {\n                    if (evaluate(postfix, P, Q, R) == 2) {\n                        ++count;\n                    }\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:59"
  }
]