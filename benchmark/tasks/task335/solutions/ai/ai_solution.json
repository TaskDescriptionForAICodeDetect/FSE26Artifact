[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        int *initial = (int *)malloc(n * sizeof(int));\n        int *final = (int *)malloc(n * sizeof(int));\n        int *pos = (int *)malloc(n * sizeof(int));\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &initial[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &final[i]);\n            pos[final[i]] = i;\n        }\n        \n        int cost = 0;\n        int machine_pos = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (initial[i] != final[i]) {\n                int target_pos = pos[initial[i]];\n                cost += abs(machine_pos - i) + abs(i - target_pos);\n                machine_pos = target_pos;\n                \n                int temp = initial[i];\n                initial[i] = initial[target_pos];\n                initial[target_pos] = temp;\n            }\n        }\n        \n        printf(\"%d\\n\", cost);\n        \n        free(initial);\n        free(final);\n        free(pos);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n) {\n        vector<char> initial(n), target(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> initial[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            cin >> target[i];\n        }\n\n        map<char, vector<int>> target_positions;\n        for (int i = n - 1; i >= 0; --i) {\n            target_positions[target[i]].push_back(i);\n        }\n\n        vector<int> permutation;\n        for (char c : initial) {\n            permutation.push_back(target_positions[c].back());\n            target_positions[c].pop_back();\n        }\n\n        vector<int> fenwick(n + 1, 0);\n        auto update = [&](int idx, int delta) {\n            for (; idx <= n; idx += idx & -idx) {\n                fenwick[idx] += delta;\n            }\n        };\n\n        auto query = [&](int idx) {\n            int res = 0;\n            for (; idx > 0; idx -= idx & -idx) {\n                res += fenwick[idx];\n            }\n            return res;\n        };\n\n        long long cost = 0;\n        for (int i = 0; i < n; ++i) {\n            int pos = permutation[i] + 1;\n            cost += i - query(pos);\n            update(pos, 1);\n        }\n\n        cout << cost << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PanelRearrangement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] initial = new int[n];\n            int[] target = new int[n];\n            for (int i = 0; i < n; i++) {\n                initial[i] = scanner.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                target[i] = scanner.nextInt();\n            }\n            \n            Map<Integer, Integer> targetPositions = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                targetPositions.put(target[i], i);\n            }\n            \n            int[] positions = new int[n];\n            for (int i = 0; i < n; i++) {\n                positions[i] = targetPositions.get(initial[i]);\n            }\n            \n            long cost = 0;\n            int machinePos = 0;\n            for (int i = 0; i < n; i++) {\n                if (positions[i] != i) {\n                    cost += Math.abs(machinePos - i);\n                    machinePos = i;\n                    int j = positions[i];\n                    while (j != i) {\n                        cost += Math.abs(machinePos - j);\n                        machinePos = j;\n                        int temp = positions[j];\n                        positions[j] = j;\n                        j = temp;\n                    }\n                    cost += Math.abs(machinePos - i);\n                    machinePos = i;\n                    positions[i] = i;\n                }\n            }\n            System.out.println(cost);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:08:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PanelRearrangement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            int n = scanner.nextInt();\n            int[] initial = new int[n];\n            int[] target = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                initial[i] = scanner.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                target[i] = scanner.nextInt();\n            }\n\n            System.out.println(minimumCost(initial, target));\n        }\n    }\n\n    static int minimumCost(int[] initial, int[] target) {\n        int n = initial.length;\n        int[] position = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            position[initial[i]] = i;\n        }\n\n        int[] sorted = Arrays.copyOf(target, n);\n        Arrays.sort(sorted);\n        \n        int totalCost = 0;\n        for (int i = 0; i < n; i++) {\n            if (initial[i] != target[i]) {\n                int correctPos = position[target[i]];\n                int currentPos = i;\n                \n                while (currentPos != correctPos) {\n                    swap(initial, currentPos, currentPos + 1);\n                    position[initial[currentPos]] = currentPos;\n                    position[initial[currentPos + 1]] = currentPos + 1;\n                    currentPos++;\n                    totalCost++;\n                }\n            }\n        }\n        return totalCost;\n    }\n\n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
    "timestamp": "2025-08-05 21:08:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PANELS 100\n\nint calculate_min_cost(int panels, int *initial, int *final) {\n    int cost = 0;\n    int used[MAX_PANELS] = {0};\n    \n    for (int i = 0; i < panels; i++) {\n        if (used[i]) continue;\n        \n        int current = i;\n        int cycle_length = 0;\n        \n        while (!used[current]) {\n            used[current] = 1;\n            current = initial[final[current]];\n            cycle_length++;\n        }\n        \n        cost += cycle_length > 1 ? cycle_length - 1 : 0;\n    }\n    \n    return cost;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int d = 0; d < datasets; d++) {\n        int panels;\n        scanf(\"%d\", &panels);\n        \n        int initial[MAX_PANELS], final[MAX_PANELS];\n        int mapping[MAX_PANELS];\n        \n        for (int i = 0; i < panels; i++) {\n            scanf(\"%d\", &initial[i]);\n            initial[i]--;\n        }\n        \n        for (int i = 0; i < panels; i++) {\n            scanf(\"%d\", &final[i]);\n            final[i]--;\n            mapping[final[i]] = i;\n        }\n        \n        int min_cost = calculate_min_cost(panels, mapping, initial);\n        printf(\"%d\\n\", min_cost);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint calculateMinCost(vector<int>& initial, vector<int>& final) {\n    int n = initial.size();\n    vector<int> mapping(n);\n\n    for (int i = 0; i < n; i++) {\n        mapping[initial[i] - 1] = final[i] - 1;\n    }\n\n    vector<bool> visited(n, false);\n    int totalCost = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            int current = i;\n            int cycleCost = 0;\n            int cycleLength = 0;\n\n            while (!visited[current]) {\n                visited[current] = true;\n                current = mapping[current];\n                cycleLength++;\n            }\n\n            if (cycleLength > 0) {\n                totalCost += min(cycleLength, 2 * (n - cycleLength));\n            }\n        }\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    for (int d = 0; d < datasets; d++) {\n        int n;\n        cin >> n;\n\n        vector<int> initial(n);\n        vector<int> final(n);\n\n        for (int i = 0; i < n; i++) {\n            cin >> initial[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            cin >> final[i];\n        }\n\n        int minCost = calculateMinCost(initial, final);\n        cout << minCost << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_cost_to_rearrange_panels(n, initial, final):\n    # Create a map of where each panel in the final array needs to go\n    final_positions = {panel: i for i, panel in enumerate(final)}\n    # Create a permutation of positions based on initial to final mapping\n    permutation = [final_positions[panel] for panel in initial]\n\n    # Function to calculate minimum swaps needed to sort a permutation\n    def min_swaps_to_sort_permutation(permutation):\n        visited = [False] * len(permutation)\n        swap_count = 0\n        for i in range(len(permutation)):\n            if visited[i] or permutation[i] == i:\n                continue\n            cycle_size = 0\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = permutation[x]\n                cycle_size += 1\n            if cycle_size > 0:\n                swap_count += (cycle_size - 1)\n        return swap_count\n\n    swaps = min_swaps_to_sort_permutation(permutation)\n    return swaps\n\n# Example usage\ndatasets = [\n    (5, \"WBWBW\", \"WWBWB\"),\n    (6, \"WWBWBW\", \"BWWWBB\")\n]\n\nfor n, initial, final in datasets:\n    cost = minimum_cost_to_rearrange_panels(n, initial, final)\n    print(cost)",
    "timestamp": "2025-08-13 05:08:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PanelRearrangement {\n    public static int calculateMinCost(int n, String initial, String target) {\n        Map<Character, Queue<Integer>> targetPositions = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            char panel = target.charAt(i);\n            targetPositions.computeIfAbsent(panel, k -> new LinkedList<>()).offer(i);\n        }\n\n        List<Integer> swaps = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            char panel = initial.charAt(i);\n            if (targetPositions.containsKey(panel) && !targetPositions.get(panel).isEmpty()) {\n                swaps.add(targetPositions.get(panel).poll());\n            }\n        }\n\n        int cost = 0;\n        for (int i = 0; i < swaps.size(); i++) {\n            for (int j = i + 1; j < swaps.size(); j++) {\n                if (swaps.get(i) > swaps.get(j)) {\n                    Collections.swap(swaps, i, j);\n                    cost++;\n                }\n            }\n        }\n\n        return cost;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasetCount = scanner.nextInt();\n        \n        while (datasetCount-- > 0) {\n            int n = scanner.nextInt();\n            String initial = scanner.next();\n            String target = scanner.next();\n            \n            int minCost = calculateMinCost(n, initial, target);\n            System.out.println(minCost);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 05:08:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint findMinCost(int n, char initial[], char final[]) {\n    int cost = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (initial[i] != final[i]) {\n            for (int j = i + 1; j < n; j++) {\n                if (initial[j] == final[i] && initial[j] != final[j]) {\n                    char temp = initial[i];\n                    initial[i] = initial[j];\n                    initial[j] = temp;\n                    cost += abs(i - j);\n                    break;\n                }\n            }\n        }\n    }\n    \n    return cost;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    for (int i = 0; i < t; i++) {\n        int n;\n        scanf(\"%d\", &n);\n\n        char initial[n + 1];\n        char final[n + 1];\n\n        scanf(\"%s\", initial);\n        scanf(\"%s\", final);\n        \n        int minCost = findMinCost(n, initial, final);\n        printf(\"%d\\n\", minCost);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:08:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_panel_rearrangement(n, initial, final):\n    # Find the position of each panel in the final arrangement\n    panel_pos = {final[i]: i for i in range(n)}\n    \n    # Translate initial arrangement to final arrangement positions\n    current = [panel_pos[initial[i]] for i in range(n)]\n    \n    # Minimum moves calculation using inversion count\n    def count_inversions(arr):\n        inv_count = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[i] > arr[j]:\n                    inv_count += 1\n        return inv_count\n    \n    # Minimum cost is the number of inversions\n    return count_inversions(current)\n\n# Read input and solve each dataset\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    initial = list(map(int, input().split()))\n    final = list(map(int, input().split()))\n    \n    # Output minimum cost for each dataset\n    print(solve_panel_rearrangement(n, initial, final))",
    "timestamp": "2025-08-13 05:08:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_min_cost(N, initial, final):\n    pos_in_final = {val: idx for idx, val in enumerate(final)}\n    swaps = 0\n    cost = 0\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle_size = 0\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = pos_in_final[initial[j]]\n                cycle_size += 1\n            if cycle_size > 0:\n                swaps += (cycle_size - 1)\n    \n    # The cost is the number of swaps multiplied by 2 (since each swap involves moving to and fro)\n    cost = swaps * 2\n    return cost\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    T = int(input[ptr])\n    ptr += 1\n    for _ in range(T):\n        N = int(input[ptr])\n        ptr += 1\n        initial = input[ptr:ptr+N]\n        ptr += N\n        final = input[ptr:ptr+N]\n        ptr += N\n        print(calculate_min_cost(N, initial, final))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:08:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint calculateMinimumCost(const std::vector<int>& initial, const std::vector<int>& final) {\n    int n = initial.size();\n    std::vector<int> initialPos(n), finalPos(n), position(n);\n\n    for (int i = 0; i < n; ++i) {\n        initialPos[initial[i]] = i;\n        finalPos[final[i]] = i;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        position[i] = initialPos[i];\n    }\n\n    int cost = 0;\n    for (int i = 0; i < n; ++i) {\n        while (position[i] != finalPos[i]) {\n            std::swap(position[i], position[finalPos[i]]);\n            cost += std::abs(position[i] - position[finalPos[i]]);\n        }\n    }\n\n    return cost;\n}\n\nint main() {\n    int testCases;\n    std::cin >> testCases;\n    while (testCases--) {\n        int numPanels;\n        std::cin >> numPanels;\n\n        std::vector<int> initial(numPanels);\n        std::vector<int> final(numPanels);\n\n        for (int i = 0; i < numPanels; ++i) {\n            std::cin >> initial[i];\n        }\n        for (int i = 0; i < numPanels; ++i) {\n            std::cin >> final[i];\n        }\n\n        int cost = calculateMinimumCost(initial, final);\n        std::cout << cost << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:23:07"
  }
]