[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXN = 16;\nint N;\nstring S, T;\nint start, goal;\nint cost[MAXN][1<<MAXN];\n\nstruct State {\n  int pos, bit, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\n\nint dijkstra() {\n  priority_queue<State> que;\n  fill(cost[0], cost[MAXN], INF);\n  for(int i = 0; i < N; ++i) {\n    que.push((State){i, start, 0});\n    cost[i][start] = 0;\n  }\n  while(que.size()) {\n    const State s = que.top();\n    que.pop();\n    if(cost[s.pos][s.bit] < s.cost) continue;\n    if(s.bit == goal) return s.cost;\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        if((s.bit&(1<<i)) ^ (s.bit&(1<<j))); else continue;\n        State t = {j, s.bit^(1<<i)^(1<<j), s.cost+abs(i-s.pos)+abs(j-i)};\n        if(cost[t.pos][t.bit] <= t.cost) continue;\n        que.push(t);\n        cost[t.pos][t.bit] = t.cost;\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> N && N) {\n    cin >> S >> T;\n    start = goal = 0;\n    for(int i = 0; i < N; ++i) {\n      if(S[i] == 'W') start |= 1<<i;\n      if(T[i] == 'W') goal  |= 1<<i;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#define MAX 20\n#define ABS(a) (((a) > 0) ? (a) : -(a))\n\nchar init[MAX], fin[MAX];\nint n, cnt, val, ans;\nint w[MAX], b[MAX], order[MAX], o2[MAX];\n\nvoid reset(void){\n\tstd::fill(w+1, w+cnt+1, 0);\n\tstd::fill(b+1, b+cnt+1, 0);\n\tstd::fill(order+1, order+cnt+1, 0);\n\tstd::fill(o2+1, o2+cnt+1, 0);\n}\n\nvoid go(int now, int dep, int sw){\n\tint nex=order[dep+1];\n\tval+=ABS(w[now]-b[o2[now]]);\n\n\tif (dep==cnt){\n\t\tif (val<ans) ans=val;\n\t}else{\n\t\tif (sw==0){\n\t\t\tval+=ABS(w[nex]-b[o2[now]]);\n\t\t\tgo(nex, dep+1, 0);\n\t\t\tval-=ABS(w[nex]-b[o2[now]]);\n\t\t\tval+=ABS(b[o2[nex]]-b[o2[now]]);\n\t\t\tgo(nex, dep+1, 1);\n\t\t\tval-=ABS(b[o2[nex]]-b[o2[now]]);\n\t\t}else{\n\t\t\tval+=ABS(w[nex]-w[now]);\n\t\t\tgo(nex, dep+1, 0);\n\t\t\tval-=ABS(w[nex]-w[now]);\n\t\t\tval+=ABS(b[o2[nex]]-w[now]);\n\t\t\tgo(nex, dep+1, 1);\n\t\t\tval-=ABS(b[o2[nex]]-w[now]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint i;\n\tint wcnt, bcnt;\n\tfor (;;){\n\t\twcnt=bcnt=0;\n\t\tscanf(\"%d\", &n);\n\t\tif (n==0) break;\n\t\tscanf(\"%s\", &init[1]);\n\t\tscanf(\"%s\", &fin[1]);\n\t\tfor (i=1;i<=n;i++){\n\t\t\tif (init[i]!=fin[i]){\n\t\t\t\tif (init[i]=='W') w[++wcnt]=i;\n\t\t\t\telse b[++bcnt]=i;\n\t\t\t}\n\t\t}\n\t\tcnt=wcnt;\n\t\tfor (i=1;i<=cnt;i++){\n\t\t\torder[i]=i;\n\t\t\to2[i]=i;\n\t\t}\n\t\tif (cnt>=2){\n\t\t\tans=10000000;\n\t\t\tfor (;;){\n\t\t\t\tfor (;;){\n\t\t\t\t\tval=0;\n\t\t\t\t\tgo(order[1], 1 ,0);\n\t\t\t\t\tval=0;\n\t\t\t\t\tgo(order[1], 1, 1);\n\t\t\t\t\tif (std::next_permutation(o2+1, o2+cnt+1)) break;\n\t\t\t\t}\n\t\t\t\tif (std::next_permutation(order+1, order+cnt+1)) break;\n\t\t\t}\n\t\t}else if (cnt==1){\n\t\t\tans=ABS(w[1]-b[1]);\n\t\t}else ans=0;\n\t\tprintf(\"%d\\n\", ans);\n\t\treset();\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <map>\n#include <queue>\n#include <functional>\n#include <assert.h>\nusing namespace std;\ninline int pack(int p, int ps, int n) {\n  return (p << n) | ps;\n}\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n==0) break;\n    string sa, sb;\n    getline(cin, sa);\n    getline(cin, sa);\n    getline(cin, sb);\n    auto conv = [n](string &s) {\n      int r = 0;\n      for(int i = 0; i < n; i++) {\n        r = (r<<1) + (s[i] == 'W' ? 1 : 0); \n      }\n      return r;\n    };\n    const int a = conv(sa);\n    const int b = conv(sb);\n    //cout << \"a = \" << static_cast<std::bitset<8> >(a) << endl;\n    //cout << \"b = \" << static_cast<std::bitset<8> >(b) << endl;\n    // better DP: state = (head-pos, difference)\n    vector<int> ds(n<<n, -1);\n    function<int(int)> rec = [&rec,&b,&n,&ds](const int v){\n      if(ds[v] >= 0) return ds[v];\n      const int p = v >> n;\n      const int s = v & ((1<<n) - 1);\n      if(s == 0) return 0;\n      int e = 10000000;\n      for(int i = 0; i < n; i++) {\n        if((s & (1<<i)) == 0) continue;\n        for(int j = 0; j < n; j++) {\n          if(i == j) continue;\n          if((s & (1<<j)) == 0) continue;\n          if((((b>>i) ^ (b>>j))&1) == 0) continue;\n          const int c = abs(i - p) + abs(j - i);\n          const int u = pack(j, s ^ (1<<i) ^ (1<<j), n); // swap\n          e = min(e, c + rec(u));\n        }\n      }\n      ds[v] = e;\n      return e;\n    };\n    int e = 10000000;\n    for(int i = 0; i < n; i++) {\n      e = min(e, rec(pack(i, a^b, n)));\n    }\n    cout << e << endl;\n/*  // naive Dijkstra search: state = (head-pos, panels)\n    vector<int> ds(n<<n, 100000000);\n    priority_queue<pair<int,int>> que;\n    for(int i = 0; i < n; i++) {\n      int v = pack(i, a, n);\n      ds[v] = 0;\n      que.push(make_pair(-ds[v], v));\n      \n    }\n    vector<bool> done(n, false);\n    int rest = n;\n    while(que.size() > 0) {\n      auto dv = que.top(); que.pop();\n      const int v = dv.second;\n      const int d = -dv.first;\n      const int p = v >> n;\n      const int s = v & ((1<<n) - 1);\n      //cout << \"popped: \" << static_cast<std::bitset<8> >(s) << \" at \" << p << \" with cost \" << d << endl;\n      if(s == b) {\n        if(!done[p]) {\n          done[p] = true;\n          rest--;\n        }\n        if(rest == 0) {\n          int e = d;\n          for(int i = 0; i < n; i++) {\n            e = min(e, ds[pack(i, b, n)]);\n          }\n          cout << e << endl;\n          break;\n        }\n      }\n      // generate all possible transitions: marking i, and then j.\n      for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n          if(i == j) continue;\n          if((((s>>i) ^ (s>>j))&1) == 0) continue;\n          const int c = abs(i - p) + abs(j - i);\n          const int u = pack(j, s ^ (1<<i) ^ (1<<j), n); // swap\n          if(ds[u] > d + c) {\n            ds[u] = d + c;\n            que.push(make_pair(-ds[u], u));\n            //cout << \" to \" << i << \" and \" << j << \" cost \" << ds[u] << \" for \" << static_cast<std::bitset<8> >(u) << endl;\n          }\n        }\n      }\n    }\n*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXN = 16;\nint N;\nstring S, T;\nint start, goal;\nint cost[MAXN][1<<MAXN];\n\nstruct State {\n  int pos, bit, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\n\nint dijkstra() {\n  priority_queue<State> que;\n  fill(cost[0], cost[MAXN], INF);\n  for(int i = 0; i < N; ++i) {\n    que.push((State){i, start, 0});\n    cost[i][start] = 0;\n  }\n  while(que.size()) {\n    const State s = que.top();\n    que.pop();\n    if(cost[s.pos][s.bit] < s.cost) continue;\n    if(s.bit == goal) return s.cost;\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        if((s.bit&(1<<i)) ^ (s.bit&(1<<j))); else continue;\n        State t = {j, s.bit^(1<<i)^(1<<j), s.cost+abs(i-s.pos)+abs(j-i)};\n        if(cost[t.pos][t.bit] <= t.cost) continue;\n        que.push(t);\n        cost[t.pos][t.bit] = t.cost;\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> N && N) {\n    cin >> S >> T;\n    start = goal = 0;\n    for(int i = 0; i < N; ++i) {\n      if(S[i] == 'W') start |= 1<<i;\n      if(T[i] == 'W') goal  |= 1<<i;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    // ifstream cin(\"/Volumes/env1/work/aoj/2040/a\");\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        string init;\n        string final;\n        cin >> init;\n        cin >> final;\n\n        auto encode = [](const string& s) {\n            int r = 0b0;\n            for (int i = 0; i < s.size(); ++i) {\n                if (i != 0) {\n                    r <<= 1;\n                }\n                if (s[i] == 'B') {\n                    r |= 0b1;\n                }\n            }\n            return r;\n        };\n\n        auto pow = [](int b, int e) {\n            int r = 1;\n            for (int i = 0; i < e; ++i) {\n                r *= b;\n            }\n            return r;\n        };\n\n        auto target = encode(final);\n        auto start = encode(init);\n\n        vector<vector<int>> memo(n, vector<int>(pow(2, n), -1));\n        // p ??????????????´?????¶?????? s ?????¨??????????°???????????????????\n        function<int(int, int)> f = [&f, &memo, n, &pow, start](int p,\n                                                                int s) -> int {\n            // cout << static_cast<bitset<8>>(s) << endl;\n            if (memo[p][s] != -1) {\n                return memo[p][s];\n            }\n\n            // ??????????????´????????????\n            if (s == 0) {\n                return 0;\n            }\n\n            int min_ = numeric_limits<int>::max();\n            int pp = -1;\n            for (int i = 0; i < n; ++i) {\n                // i ??????????????§????????´????????????\n                if (((s >> i) & 1) == 0) {\n                    continue;\n                }\n                for (int j = 0; j < n; ++j) {\n                    if (i == j) {\n                        continue;\n                    }\n                    // j ??????????????§????????´????????????\n                    else if ((s >> j & 1) == 0) {\n                        continue;\n                    }\n                    // ?????????????????\\????????????????°???????????????????\n                    else if ((((start >> i) & 1) ^ ((start >> j) & 1)) == 0) {\n                        continue;\n                    }\n                    else {\n                        // p ?????? i ?????§?????£???, i ?????? j ?????§??????\n                        auto cost = abs(i - p) + abs(j - i);\n                        auto ss = s;\n                        ss ^= 1 << i;\n                        ss ^= 1 << j;\n                        // cout << \"pos: \" << p << \" swap \" << i << \", \" << j\n                        //     << \": \" << static_cast<bitset<8>>(s) << \" to \"\n                        //     << static_cast<bitset<8>>(ss) << \" cost \" << cost\n                        //     << endl;\n                        auto min__ = min_;\n                        min_ = min(min_, cost + f(j, ss));\n                        if (min__ != min_) {\n                            // cout << \"change\" << endl;\n                            pp = j;\n                        }\n                    }\n                }\n            }\n            memo[pp][s] = min_;\n            assert(min_ != -1);\n\n            return min_;\n        };\n\n        int min_ = numeric_limits<int>::max();\n        for (int i = 0; i < n; ++i) {\n            min_ = min(min_, f(i, start ^ target));\n        }\n        cout << min_ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint f(string s){\n\tint a=0;\n\trep(i,s.size()){\n\t\ta*=2;\n\t\ta+=(s[i]=='B'?1:0);\n\t}\n\treturn a;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s,t;\n\t\tcin>>s>>t;\n\t\tint a=f(s),b=f(t);\n\t\tint N=1<<n;\n\t\tvvi dp(n,vi(N,inf));\n\t\trep(i,n)dp[i][N-(a^b)-1]=0;\n\t\trep(i,n)loop(j,N-(a^b)-1,N)if(dp[i][j]!=inf){\n\t\t\trep(k,n)if(i!=k){\n\t\t\t\tbool q=(a&1<<i),w=(a&1<<k);\n\t\t\t\tif(q+w==1){\n\t\t\t\t\tint J=j|1<<i;\n\t\t\t\t\tJ|=1<<k;\n\t\t\t\t\trep(l,n)\n\t\t\t\t\t\tdp[l][J]=min(dp[l][J],dp[i][j]+abs(i-k)+abs(l-k));\n\t\t\t\t\t\n//\t\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<J<<\" \"<<k<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,n)out=min(out,dp[i][N-1]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 16;\nconst int MAX_BITS = 1 << MAX_N;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Stat {\n  int d, bits, pos;\n\n  Stat() {}\n  Stat(int _d, int _bits, int _pos) { d = _d, bits = _bits, pos = _pos; }\n  bool operator<(const Stat& st0) const { return d > st0.d; }\n};\n\n/* global variables */\n\nint n;\nint dists[MAX_BITS][MAX_N];\n\n/* subroutines */\n\nint str2bits(string str, int n) {\n  int bits = 0;\n  for (int i = 0; i < n; i++) {\n    bits <<= 1;\n    if (str[i] == 'B') bits |= 1;\n  }\n  return bits;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    string sstr, gstr;\n    cin >> sstr >> gstr;\n\n    int sbits = str2bits(sstr, n);\n    int gbits = str2bits(gstr, n);\n    //printf(\"%x -> %x\\n\", sbits, gbits);\n\n    int maxbits = 1 << n;\n    for (int i = 0; i < maxbits; i++)\n      for (int j = 0; j < n; j++)\n\tdists[i][j] = INF;\n    \n    priority_queue<Stat> q;\n\n    for (int i = 0; i < n; i++) {\n      dists[sbits][i] = 0;\n      q.push(Stat(0, sbits, i));\n    }\n\n    int mind = INF;\n    \n    while (! q.empty()) {\n      Stat u = q.top();\n      q.pop();\n\n      if (u.d != dists[u.bits][u.pos]) continue;\n      if (u.bits == gbits) {\n\tmind = u.d;\n\tbreak;\n      }\n\n      for (int i0 = 0; i0 < n; i0++) {\n\tint b0 = (u.bits >> i0) & 1;\n\tint vc0 = (u.pos > i0) ? u.pos - i0 : i0 - u.pos;\n\tfor (int i1 = 0; i1 < n; i1++) {\n\t  if (i0 == i1) continue;\n\t  int b1 = (u.bits >> i1) & 1;\n\t  if (b0 == b1) continue;\n\n\t  int vc1 = (i0 > i1) ? i0 - i1 : i1 - i0;\n\t  int vbits = (u.bits ^ (1 << i0)) ^ (1 << i1);\n\t  int vd = u.d + vc0 + vc1;\n\t  if (dists[vbits][i1] > vd) {\n\t    dists[vbits][i1] = vd;\n\t    q.push(Stat(vd, vbits, i1));\n\t  }\n\t}\n      }\n    }\n\n    cout << mind << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n \ntypedef pair<int, int> paii;\ntypedef long long ll;\n\ntypedef\tpair<int, paii> tupl;\n\nint n;\nstring a, b;\nint vtx[18][66000];\n\nint solve(){\n\t\n\tint x = 0, y = 0, res = 100000;\n\n\tfor(int i = 0; i < n; i++){\n\t\tx = x<<1; \n\t\ty = y<<1;\n\t\tx += (a[i]=='W'?0:1);\n\t\ty += (b[i]=='W'?0:1);\n\t}\n\t\n\tfor(int k = 0; k < n; ++k){\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < 66000; ++j)\n\t\t\t\tvtx[i][j] = (j!=x?100000:0);\n\t\t\n\t\tpriority_queue<tupl, vector<tupl>, greater<tupl> > qu;\n\t\tqu.push(make_pair(0, make_pair(k, x)));\n\t\tvtx[k][x] = 0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t\n\t\t\tint m = qu.top().second.first;\n\t\t\tint w = qu.top().second.second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = i; j < n; ++j){\n\t\t\t\t\n\t\t\t\t\tif( i!=j && ((w>>i&1) != (w>>j&1))\n\t\t\t\t\t\t\t&& ((w>>i&1) != (y>>i&1)) && ((w>>j&1) != (y>>j&1)) ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tint z = w^( (1<<i)|(1<<j) );\n\t\t\t\t\t\tint dsta = abs(j-m)+abs(i-j);\n\t\t\t\t\t\tint dstb = abs(i-m)+abs(j-i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( vtx[i][z] > vtx[m][w] + dsta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[i][z] = vtx[m][w] + dsta;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[i][z], make_pair(i, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( vtx[j][z] > vtx[m][w] + dstb){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[j][z] = vtx[m][w] + dstb;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[j][z], make_pair(j, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tres = min(res, vtx[i][y]);\n\t\t}\n\t\t\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> n, n){\n\t\n\t\tcin >> a;\n\t\tcin >> b;\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<16> initial, final;\n        for(int i=0; i<n; ++i){\n            char c;\n            cin >> c;\n            initial[i] = (c == 'B');\n        }\n        for(int i=0; i<n; ++i){\n            char c;\n            cin >> c;\n            final[i] = (c == 'B');\n        }\n\n        vector<vector<int> > memo(1<<n, vector<int>(n, INF));\n        multimap<int, pair<bitset<16>, int> > mm;\n        for(int i=0; i<n; ++i){\n            memo[initial.to_ulong()][i] = 0;\n            mm.insert(make_pair(0, make_pair(initial, i)));\n        }\n\n        for(;;){\n            int cost = mm.begin()->first;\n            bitset<16> bs = mm.begin()->second.first;\n            int pos = mm.begin()->second.second;\n            mm.erase(mm.begin());\n            if(cost > memo[bs.to_ulong()][pos])\n                continue;\n\n            if(bs == final){\n                cout << cost << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                for(int j=0; j<n; ++j){\n                    if(!(bs[i] ^ bs[j]))\n                        continue;\n                    if(!((bs[i] ^ final[i]) && (bs[j] ^ final[j])))\n                        continue;\n\n                    int cost2 = cost + abs(pos - i) + abs(i - j);\n                    bitset<16> bs2 = bs;\n                    bs2[i] = !bs2[i];\n                    bs2[j] = !bs2[j];\n                    if(cost2 < memo[bs2.to_ulong()][j]){\n                        memo[bs2.to_ulong()][j] = cost2;\n                        mm.insert(make_pair(cost2, make_pair(bs2, j)));\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\n//int dp[2][16][1<<16];\n//typedef pair<int,int> pii;\n//typedef pair<int,pii> pipii;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\n\nint d[16][1<<16];\npriority_queue<Sit> que;\nint bfs(){\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        Sit sit;\n        sit.cost=0;sit.pos=i;sit.mask=s;\n        que.push(sit);\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        //int cpos=s.pos;\n        //int ccost=s.cost;\n        //int cmask=s.mask;\n        if(d[s.pos][s.mask]<s.cost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-s.pos)+abs(j-i);\n                int nmask=s.mask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>j)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,j,a);\n                if(d[j][nmask]>d[s.pos][s.mask]+cost){\n                    d[j][nmask]=d[s.pos][s.mask]+cost;\n                    Sit sit;\n                    sit.cost=d[j][nmask];\n                    sit.pos=j;\n                    sit.mask=nmask;\n                    que.push(sit);\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,d[i][t]);\n    return res;\n}\n//int solve(){\n//    return bfs();\n//    //for(int tern=n;tern>=0;tern--){\n//    //    int nxt=tern%2;\n//    //    int cur=(tern+1)%2;\n//    //    for(int pos=0;pos<n;pos++){\n//    //        for(int sit=0;sit<(1<<n);sit++){\n//    //            int res=INF;\n//    //            if(tern==n){\n//    //                if(sit==t)res=0;\n//    //            }\n//    //            else{\n//    //                for(int to=0;to<n;to++){\n//    //                    // ®©·¾¯\n//    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n//    //                    // trade\n//    //                    int cost=abs(to-pos);\n//    //                    int nsit=sit;\n//    //                    int a=(sit>>pos)&1;\n//    //                    int b=(sit>>to)&1;\n//    //                    setBit(nsit,pos,b);\n//    //                    setBit(nsit,to,a);\n//    //                    res=min(res,dp[cur][to][nsit]+cost);\n//    //                }\n//    //            }\n//    //            dp[nxt][pos][sit]=res;\n//    //        }\n//    //    }\n//    //}\n//    //int res=INF;\n//    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n//    //return res;\n//}\nint main(){\n\n    string ss,tt;\n    while(cin>>n&&n){\n        s=t=0;\n        cin>>ss>>tt;\n        for(int i=0;i<n;i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<n;i++)if(tt[i]=='B')t|=(1<<i);\n        printf(\"%d\\n\",bfs());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring A,B;\nint n,Ab,Bb;\n\nint Bit(int bit ,int i,int x){\n  while((bit>>i&1)!=x)bit ^= 1<<i;\n  return bit;\n}\n\nint mem[16][1<<16],used[16][1<<16];\nint dep = 0;\nint dfs(int pos,int bit){\n  dep++;\n  if(dep>100000)return 0;\n  if(bit ==Bb) return 0;\n  if(used[pos][bit]++) return mem[pos][bit];\n  \n  int &res = mem[pos][bit] = 1e9;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int nbit = bit;\n      nbit = Bit(nbit,i,bit>>j&1);\n      nbit = Bit(nbit,j,bit>>i&1);\n      res = min(res,abs(pos-i)+abs(i-j)+dfs(j,nbit));\n    }\n  dep--;\n  return mem[pos][bit];\n}\n\n\nint main(){\n \n  while(cin>>n,n){\n    cin>>A>>B;\n    \n    Ab = Bb = 0;\n    for(int i=0;i<n;i++)Ab|=(A[i]=='W')<<i, Bb|=(B[i]=='W')<<i;\n    \n    memset(used,0,sizeof(used));\n    int ans = 1e9;\n    for(int i=0;i<n;i++) ans=min(ans,dfs(i,Ab));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint dp[16][1<<16];\nint n;\nint src, dst;\n\nint encode(char *buff, int len){\n  int ret = 0;\n  REP(i,len) if(buff[i] == 'W')\n    ret |= (1 << i);\n  return ret;\n}\n\nint solve(int pos, int panel){\n  if(panel == dst) return 0;\n  if(dp[pos][panel] != -1) return dp[pos][panel];\n  \n  int ret = INT_MAX;\n  for(int i = 0; i < n; i++){\n    if(((dst ^ panel) & (1 << i)) != 0){\n      for(int j = i + 1; j < n; j++){\n\tif((((dst ^ panel) & (1 << j)) != 0) &&\n\t   ((((panel >> i) ^ (panel >> j)) & 1) != 0)){\n\t  int cost1 = abs(pos - i) + (j - i);\n\t  int cost2 = abs(pos - j) + (j - i);\n\t  int next = panel ^ (1 << i) ^ (1 << j);\n\t  ret = min(ret, cost1 + solve(j, next));\n\t  ret = min(ret, cost2 + solve(i, next));\n\t}\n      }\n    }\n  }\n\n  return dp[pos][panel] = ret;\n}\n\nint main(){\n\n  while(scanf(\"%d\", &n), n){\n    char buff[20];\n    int ans = INT_MAX;\n\n    scanf(\"%s\", buff); src = encode(buff, n);\n    scanf(\"%s\", buff); dst = encode(buff, n);\n\n\n    REP(i,n) REP(j,1<<n) dp[i][j] = -1;\n    REP(i,n){\n      ans = min(ans, solve(i, src));\n    }\n    print(ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nint N, endbit, Mask;\nint dp[1 << 16][16];\n\nint rec(int bit, int ptr){\n  if(bit == endbit) return 0;\n  if(~dp[bit][ptr]) return dp[bit][ptr];\n  int ret = INF;\n  for(int i = 0; i < N; i++){\n    if((bit ^ endbit) & (1 << i)){\n      for(int j = i + 1; j < N; j++){\n        if((bit ^ endbit) & (1 << j) && ((bit >> i) & 1) ^ ((bit >> j) & 1)){\n          int nextbit = bit&~((1 << i)|(1 << j))|(endbit & (1 << i))|(endbit & (1 << j));\n          int cost = abs(ptr - i) + j - i;\n          ret = min( ret, rec( nextbit, j) + cost);\n          cost = abs(ptr - j) + j - i;\n          ret = min( ret, rec( nextbit, i) + cost);\n        }\n      }\n    }\n  }\n  return dp[bit][ptr] = ret;\n}\n\nint main(){\n  int bit;\n  string A, B;\n\n  while(cin >> N, N){\n    cin >> A >> B;\n\n    Mask = (1 << N) - 1;\n    bit = 0, endbit = 0;\n    for(int i = 0; i < A.length(); i++){\n      bit |= (A[i] == 'W') << i;\n      endbit |= (B[i] == 'W') << i;\n    }\n\n    fill_n( *dp, (1 << 16) * 16, -1);\n    int ret = INF;\n    for(int i = 0; i < A.length(); i++){\n      ret = min( ret, rec(bit, i));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n;\nstring a,b;\n\nint f(int pos,int bit){\n\tif(bit == 0) return 0;\n\tint ans = 99999;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif(bit>>i&1){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(bit>>j&1){\n\t\t\t\t\tif(a[j] != a[i]){\n\t\t\t\t\t\tint dist1 = abs(pos - i);\n\t\t\t\t\t\tint dist2 = abs(i - j);\n\t\t\t\t\t\tans = min(ans,f(j,bit&~((1<<i)|(1<<j)))+dist1+dist2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tcin >> a >> b;\n\t\tint bit = 0;\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tif(a[i] != b[i]) bit |= (1<<i);\n\t\tint ans = 9999;\n\t\tfor(int i = 0 ; i < n ; i++) ans = min(f(i,bit),ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint f(string s){\n\tint a=0;\n\trep(i,s.size()){\n\t\ta*=2;\n\t\ta+=(s[i]=='B'?1:0);\n\t}\n\treturn a;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s,t;\n\t\tcin>>s>>t;\n\t\tint a=f(s),b=f(t);\n\t\tint N=1<<n;\n\t\tvvi dp(n,vi(N,inf));\n\t\trep(i,n)if((a&1<<i)^(b&1<<i))dp[i][N-(a^b)-1]=0;\n\t\trep(i,n)loop(j,N-(a^b)-1,N)if(dp[i][j]!=inf){\n\t\t\trep(k,n)if(i!=k){\n\t\t\t\tbool q=(a&1<<i),w=(a&1<<k);\n\t\t\t\tif(q+w==1){\n\t\t\t\t\tint J=j|1<<i;\n\t\t\t\t\tJ|=1<<k;\n\t\t\t\t\trep(l,n)\n\t\t\t\t\t\tdp[l][J]=min(dp[l][J],dp[i][j]+abs(i-k)+abs(l-k));\n\t\t\t\t\t\n//\t\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<J<<\" \"<<k<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,n)out=min(out,dp[i][N-1]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[20];\nint ijk[1<<16][16];\nint v[1<<16][16];\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%s\",str);\n\t\tint A=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(str[i]=='B')A+=(1<<i);\n\t\t}\n\t\tscanf(\"%s\",str);\n\t\tint B=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(str[i]=='B')B+=(1<<i);\n\t\t}\n\t\tfor(int i=0;i<(1<<a);i++)for(int j=0;j<a;j++){\n\t\t\tijk[i][j]=999999999;\n\t\t\tv[i][j]=0;\n\t\t}\n\t\tpriority_queue<pair<int,pair<int,int> > >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tQ.push(make_pair(0,make_pair(A,i)));\n\t\t\tijk[A][i]=0;\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint bit=Q.top().second.first;\n\t\t\tint at=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[bit][at])continue;\n\t\t\tv[bit][at]=1;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif((bit&(1<<i))&&!(bit&(1<<j))){\n\t\t\t\t\t\tint to=bit-(1<<i)+(1<<j);\n\t\t\t\t\t\tif(!v[to][j]&&ijk[to][j]>cost+ABS(at-i)+ABS(i-j)){\n\t\t\t\t\t\t\tijk[to][j]=cost+ABS(at-i)+ABS(i-j);\n\t\t\t\t\t\t\tQ.push(make_pair(-ijk[to][j],make_pair(to,j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(!(bit&(1<<i))&&(bit&(1<<j))){\n\t\t\t\t\t\tint to=bit-(1<<j)+(1<<i);\n\t\t\t\t\t\tif(!v[to][j]&&ijk[to][j]>cost+ABS(at-i)+ABS(i-j)){\n\t\t\t\t\t\t\tijk[to][j]=cost+ABS(at-i)+ABS(i-j);\n\t\t\t\t\t\t\tQ.push(make_pair(-ijk[to][j],make_pair(to,j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=9999999;\n\t\tfor(int i=0;i<a;i++)ret=min(ret,ijk[B][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef unsigned short ushort;\n\nclass QState{\n    public:\n    int cur, str, cost;\n    QState(){}\n    QState(int cur, int str, int c):cur(cur), str(str), cost(c){}\n    bool operator < ( const QState &q ) const{ return cost > q.cost; }\n};\n\nushort T[16];\n\nint dist(int i, int j){\n    return max(i, j) - min(i, j);\n}\t    \n\nint dijkstra(int n, ushort start, ushort goal){\n    priority_queue<QState> PQ;\n    ushort d[n][(1<<n)];\n\n    for ( int i = 0; i < n; i++ ){\n\tfor ( int j = 0; j < (1<<n); j++ ){\n\t    d[i][j] = 10000;\n\t}\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n\td[i][start] = 0;\n\tPQ.push(QState(i, start, 0));\n    }\n\n    QState u;\n    while( !PQ.empty() ){\n\tu = PQ.top(); PQ.pop();\n\tif ( u.str == goal ) return u.cost;\n\n\tfor ( int i = 0; i < n; i++ ){\n\t    for  ( int j = 0; j < n; j++ ){\n\t\tint nstr = u.str;\n\t\tint ncur = u.cur;\n\t\tushort p1 = (nstr & T[i]);\n\t\tushort p2 = (nstr & T[j]);\n\t\t\n\t\tif ( p1 > 0 && p2 == 0 ){\n\t\t    nstr -= p1;\n\t\t    nstr += T[j];\n\t\t} else if ( p1 == 0 && p2 > 0 ){\n\t\t    nstr -= p2;\n\t\t    nstr += T[i];\n\t\t} else continue;\n\n\t\tncur = j;\n\n\t\tint ncost = u.cost + dist(u.cur, i) + dist(i, j);\n\n\t\tif ( ncost < d[ncur][nstr] ){\n\t\t    d[ncur][nstr] = ncost;\n\t\t    PQ.push(QState(ncur, nstr, ncost));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nmain(){\n    int n;\n    string s, g;\n\n    for ( int i = 0; i < 16; i++ ) T[i] = (1<<i);\n    while( cin >> n && n ){\n\tcin >> s >> g;\n\tushort si = 0, gi = 0;\n\tushort p = 1;\n\tfor ( int i = n-1; i >= 0; i--, p *= 2){\n\t    if ( s[i] == 'B' ) si += p;\n\t    if ( g[i] == 'B' ) gi += p;\n\t}\n\tcout << dijkstra(n, si, gi) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 16\n#define INF 1e9\n \ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\n \nint N,S,G;\nint dp[1<<MAX][MAX];\nchar panels[MAX];\n \nvoid solve(int s){\n    priority_queue<piii,vector<piii>,greater<piii> > Q;\n    Q.push(piii(pii(0,s),S));\n   \n    while(!Q.empty()){\n\tpiii p = Q.top(); Q.pop();\n\tint cost = p.first.first, v = p.first.second;\n\tint bit = p.second;\n \n\tif(dp[bit][v] < cost) continue;\n\tfor(int i = 0 ; i < N ; i++){\n\t    if(i == v) continue;\n\t    if(((bit >> v) & 1) == ((bit >> i) & 1)) continue;   \n\t    int c = abs(i-v), nS = bit;\n\t    if((nS >> v) & 1){\n\t\tnS -= (1<<v);\n\t    }else{\n\t\tnS |= (1<<v);\n\t    }\n\t    if((nS >> i) & 1){\n\t\tnS -= (1<<i);\n\t    }else{\n\t\tnS |= (1<<i);\n\t    }\n\t    if(dp[bit][v] + c < dp[nS][i]){\n\t\tdp[nS][i] = dp[bit][v] + c;\n\t\tQ.push(piii(pii(dp[nS][i],i),nS));\n\t    }\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t    if(i == v) continue;\n\t    int c = abs(i-v);\n\t    if(dp[bit][v] + c < dp[bit][i]){\n\t\tdp[bit][i] = dp[bit][v] + c;\n\t\tQ.push(piii(pii(dp[bit][i],i),bit));\n\t    }\n\t}\n    }\n}\n \nint main(){\n    string in;\n    while(cin >> N && N){\n\tS = G = 0;\n\tfor(int i = 0 ; i < (1<<MAX) ; i++){\n\t    for(int j = 0 ; j < MAX ; j++){\n\t\tdp[i][j] = INF;\n\t    }\n\t}\n\tfor(int i = 0 ; i < 2 ; i++){\n\t    cin >> in;\n\t    for(int j = 0 ; j < N ; j++){\n\t\tif(i == 0){\n\t\t    panels[j] = in[j];\n\t\t    if(panels[j] == 'W'){\n\t\t\tS |= (1<<j);\n\t\t    }\n\t\t}else{\n\t\t    if(in[j] == 'W'){\n\t\t\tG |= (1<<j);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    \n\tfor(int i = 0 ; i < N ; i++){\n\t    dp[S][i] = 0;\n\t    solve(i);\n\t}\n \n\tint ans = INF;\n\tfor(int i = 0 ; i < N ; i++){\n\t    ans = min(ans,dp[G][i]);\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nclass State{\npublic:\n  int pos, bit, isFirst, cost;\n\n  State(){}\n  State(int pos, int bit, int isFirst, int cost) : \n    pos(pos), bit(bit), isFirst(isFirst), cost(cost) {}\n\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint n;\nbool closed[16][1 << 16][2];\nstring a, b;\n\nvoid solve(){\n  int start = 0;\n\n  for(int i = n - 1; i >= 0; i--){\n    start <<= 1;\n    if(a[i] != b[i]){\n      start++;\n    }\n  }\n\n  priority_queue<State> open;\n\n  for(int i = 0; i < n; i++){\n    if(start & (1 << i)){\n      open.push(State(i, start, true, 0));\n    }\n  }\n\n  memset(closed, 0, sizeof(closed));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.pos][st.bit][st.isFirst]){\n      continue;\n    }\n    closed[st.pos][st.bit][st.isFirst] = true;\n\n    if(st.bit == 0){\n      cout << st.cost << endl;\n      return;\n    }\n\n    if(st.isFirst){\n      for(int i = 0; i < n; i++){\n        if(i == st.pos || !(st.bit & (1 << i)) || a[st.pos] == a[i]) continue;\n        int nbit = st.bit - (1 << i) - (1 << st.pos);\n        open.push(State(i, nbit, !st.isFirst, st.cost + abs(st.pos - i)));\n      }\n    }\n    else{\n      for(int i = 0; i < n; i++){\n        if(!(st.bit & (1 << i))) continue;\n        open.push(State(i, st.bit, !st.isFirst, st.cost + abs(st.pos - i)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> n, n){\n    cin >> a >> b;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int panel;\n  int cost;\n  int machine_pos;\n  State(int panel,int cost,int machine_pos){\n    this->panel = panel;\n    this->cost = cost;\n    this->machine_pos = machine_pos;\n  }\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint dp[20][1<<20];\n\nint main(){\n  int num_of_panels;\n  while(~scanf(\"%d\",&num_of_panels)){\n    if(num_of_panels == 0) break;\n\n    int panels[2] = {};\n    for(int set_i = 0; set_i < 2; set_i++){\n      string panel;\n      cin >> panel;\n      for(int pos = 0; pos < num_of_panels; pos++){\n        if(panel[pos] == 'B'){\n          panels[set_i] |= (1<<pos);\n        }\n      }\n    }\n  \n    priority_queue<State,vector<State>,greater<State> > que;\n\n    memset(dp,0x3f,sizeof(dp));\n    for(int pos = 0; pos < num_of_panels; pos++){\n      dp[pos][panels[0]] = 0;\n      que.push(State(panels[0],0,pos));      \n    }\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      int from = s.machine_pos;\n      for(int to = 0; to < num_of_panels; to++){\n        if(to == from) continue;\n        int from_bit = (s.panel >> from) & 1;\n        int to_bit = (s.panel >> to) & 1;\n        \n        int next_panel = s.panel;\n        if(to_bit == 1){\n          next_panel = next_panel | (1 << from);\n        }\n        else {\n          next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << from));\n        }\n        if(from_bit == 1){\n          next_panel = next_panel | (1 << to);\n        }\n        else {\n          next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << to));\n        }\n        \n        if(dp[to][next_panel] <= s.cost + abs(to - from)) continue;\n        dp[to][next_panel] = s.cost + abs(to - from);\n        que.push(State(next_panel,s.cost + abs(to - from),to));\n      }\n    }\n\n    int res = INF;\n    for(int pos = 0; pos < num_of_panels; pos++){\n      res = min(res,dp[pos][panels[1]]);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(!(tmp>>i&1)){\n\t  for(int k=0;k<n;k++){\n\t    for(int j=0;j<n;j++){\n\t      if(s[j]!=s[k]){\n\t\tfor(int S=0;S<(1<<n);S++){\n\t\t  if((S>>j&1) || (S>>k&1))continue;\n\t\t  int next=S;\n\t\t  next|=(1<<j)|(1<<k);\n\t\t  if(dp[k][next]>dp[i][S]+abs(j-i)+abs(k-j))\n\t\t    dp[k][next]=dp[i][S]+abs(j-i)+abs(k-j);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n\nclass State{\n    public:\n    int cur, n, str;\n    State(int n = 0, int cur=0, int s=0):n(n), cur(cur), str(s){}\n\n    bool operator < ( const State &s) const{\n\tif ( str != s.str ) return str < s.str;\n\treturn cur < s.cur;\n\t/*\n\tif ( cur != s.cur ) return cur < s.cur;\n\treturn str < s.str;\n\t*/\n    }\n};\n\nclass QState{\n    public:\n    int cost;\n    State state;\n    QState(){}\n    QState(State s, int c):state(s), cost(c){}\n    bool operator < ( const QState &q ) const{ return cost > q.cost; }\n};\n\nint dist(int i, int j){\n    return max(i, j) - min(i, j);\n}\t    \n\nint dijkstra(int n, int start, int goal){\n    priority_queue<QState> PQ;\n    //    map<State, bool> visited;\n    bool visited[16][(1<<n)];\n\n    for ( int i = 0; i < 16; i++ ){\n\tfor ( int j = 0; j < (1<<n); j++ ){\n\t    visited[i][j] = false;\n\t}\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n\tState st = State(n, i, start);\n\tPQ.push(QState(st, 0));\n    }\n\n    QState u;\n    while( !PQ.empty() ){\n\tu = PQ.top(); PQ.pop();\n\tif ( u.state.str == goal ) return u.cost;\n\n\t//visited[u.state] = true;\n\tvisited[u.state.cur][u.state.str] = true;\n\n\tfor ( int i = 0; i < n; i++ ){\n\t    State st = u.state;\n\t    int p1 = (st.str & (1<<st.cur));\n\t    int p2 = (st.str & (1<<i));\n\n\t    if ( p1 == p2 ) continue;\n\n\t    if ( p1 > 0 && p2 == 0 ){\n\t\tst.str -= p1;\n\t\tst.str += (1<<i);\n\t    } else if ( p1 == 0 && p2 > 0 ){\n\t\tst.str -= p2;\n\t\tst.str += (1<<st.cur);\n\t    }\n\n\t    st.cur = i;\n\n\t    //if ( !visited[st] ){\n\t    if ( !visited[st.cur][st.str] ){\n\t\tPQ.push(QState(st, u.cost + dist(u.state.cur, i) ) );\n\t    }\n\t}\n    }\n}\n\nmain(){\n    int n;\n    string s, g;\n    while( cin >> n && n ){\n\tcin >> s >> g;\n\tint si = 0, gi = 0;\n\tint p = 1;\n\tfor ( int i = n-1; i >= 0; i--, p *= 2){\n\t    if ( s[i] == 'B' ) si += p;\n\t    if ( g[i] == 'B' ) gi += p;\n\t}\n\tcout << dijkstra(n, si, gi) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 16\n#define INF 1e9\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\n\nint N,S,G;\nint dp[1<<MAX][MAX];\nchar panels[MAX];\n\nvoid solve(int s){\n  priority_queue<piii,vector<piii>,greater<piii> > Q;\n  Q.push(piii(pii(0,s),S));\n  \n  while(!Q.empty()){\n    piii p = Q.top(); Q.pop();\n    int cost = p.first.first, v = p.first.second;\n    int bit = p.second;\n\n    if(dp[bit][v] < cost) continue;\n\n    for(int i = 0 ; i < N ; i++){\n      if(i == v) continue;\n      if(((bit >> v) & 1) == ((bit >> i) & 1)) continue;   \n      int c = abs(i-v);\n      int nS = bit;\n      nS -= (1<<v); nS |= (1<<i);\n      if(dp[bit][v] + c < dp[nS][i]){\n        dp[nS][i] = dp[bit][v] + c;\n        Q.push(piii(pii(dp[nS][i],i),nS));\n      }\n    }\n    for(int i = 0 ; i < N ; i++){\n      if(i == v) continue;\n      int c = abs(i-v);\n      if(dp[bit][v] + c < dp[bit][i]){\n        dp[bit][i] = dp[bit][v] + c;\n        Q.push(piii(pii(dp[bit][i],i),bit));\n      }\n    }\n  }\n}\n\nint main(){\n  string in;\n  while(cin >> N && N){\n    S = G = 0;\n    for(int i = 0 ; i < (1<<MAX) ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> in;\n      for(int j = 0 ; j < N ; j++){\n        if(i == 0){\n          panels[j] = in[j];\n          if(panels[j] == 'W'){\n            S |= (1<<j);\n          }\n        }else{\n          if(in[j] == 'W'){\n            G |= (1<<j);\n          }\n        }\n      }\n    }\n   \n    for(int i = 0 ; i < N ; i++){\n      dp[S][i] = 0;\n      solve(i);\n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans,dp[G][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nchar p[2][17];\nint mem[1<<16][16];\nint N;\nconst int INF=1<<29;\n\nint rec(int b,int p){\n  if(mem[b][p]<INF)return mem[b][p];\n  if(b==0)return 0;\n  int m=INF;\n  for(int i=0;i<N;i++){\n    if(b>>i&1){\n      for(int j=0;j<N;j++){\n\tif(b>>j&1&&::p[0][i]!=::p[0][j]){\n\t  m=min(m,rec(b^1<<i^1<<j,j)+abs(p-i)+abs(i-j));\n\t}\n      }\n    }\n  }\n  return mem[b][p]=m;\n}\n\nint main(){\n  while(cin>>N,N){\n    cin>>p[0]>>p[1];\n    int b=0;\n    for(int i=0;i<N;i++){\n      b|=(p[0][i]!=p[1][i])<<i;\n    }\n    fill(mem[0],mem[1<<N],INF);\n    int m=INF;\n    for(int i=0;i<N;i++){\n      m=min(m,rec(b,i));\n    }\n    cout<<m<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<16> initial, final;\n        for(int i=0; i<n; ++i){\n            char c;\n            cin >> c;\n            initial[i] = (c == 'B');\n        }\n        for(int i=0; i<n; ++i){\n            char c;\n            cin >> c;\n            final[i] = (c == 'B');\n        }\n\n        vector<vector<int> > memo(1<<n, vector<int>(n, INF));\n        multimap<int, pair<bitset<16>, int> > mm;\n        for(int i=0; i<n; ++i){\n            memo[initial.to_ulong()][i] = 0;\n            mm.insert(make_pair(0, make_pair(initial, i)));\n        }\n\n        for(;;){\n            int cost = mm.begin()->first;\n            bitset<16> bs = mm.begin()->second.first;\n            int pos = mm.begin()->second.second;\n            mm.erase(mm.begin());\n            if(cost > memo[bs.to_ulong()][pos])\n                continue;\n\n            if(bs == final){\n                cout << cost << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                for(int j=0; j<n; ++j){\n                    if(!(bs[i] ^ bs[j]))\n                        continue;\n\n                    int cost2 = cost + abs(pos - i) + abs(i - j);\n                    bitset<16> bs2 = bs;\n                    bs2[i] = !bs2[i];\n                    bs2[j] = !bs2[j];\n                    if(cost2 < memo[bs2.to_ulong()][j]){\n                        memo[bs2.to_ulong()][j] = cost2;\n                        mm.insert(make_pair(cost2, make_pair(bs2, j)));\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar a[32], b[32];\nint x[32], y[32];\n\nint main() {\n\twhile (1) {\n\t\tint i, j, k, n, r = 0;\n\t\tassert(scanf(\"%d\", &n) == 1);\n\t\tif (!n) break;\n\t\tassert(2 <= n && n <= 16);\n\t\tassert(scanf(\"%s%s\", a, b) == 2);\n\t\tassert(strlen(a) == n && strlen(b) == n);\n\t\tj = k = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tassert(a[i] == 'W' || a[i] == 'B');\n\t\t\tassert(b[i] == 'W' || b[i] == 'B');\n\t\t\tif (a[i] == 'W' && b[i] == 'B') x[j++] = i;\n\t\t\tif (a[i] == 'B' && b[i] == 'W') y[k++] = i;\n\t\t}\n\t\twhile (j != k);\n\t\tn = j;\n\t\tsort(x, x + n);\n\t\tsort(y, y + n);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tr += abs(x[i] - y[i]);\n\t\t\tif (i) r += abs(max(x[i - 1], y[i - 1]) - min(x[i], y[i]));\n\t\t}\n\t\tprintf(\"%d\\n\", r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct state {\n  string s;\n  int x;\n  int mark;\n  int dis;\n  state(string s, int x, int mark, int dis) :\n    s(s), x(x), mark(mark), dis(dis) {}\n};\nconst bool operator<(const state &a, const state &b) {\n  return a.s!=b.s?a.s<b.s:a.x!=b.x?a.x<b.x:a.mark<b.mark;\n}\n\nint dx[2] = {-1,1};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    string s,t;\n    cin >> s >> t;\n    queue<state> Q;\n    REP(i, n) Q.push(state(s, i, -1, 0));\n    map<state, bool> visited;\n    int res;\n    while(!Q.empty()) {\n      state now = Q.front();\n      Q.pop();\n\n      if (visited[now]) continue;\n      visited[now] = 1;\n\n      //cout << now.s << \" \" << now.x << \" \" << now.mark << \" \" << now.dis << endl;\n      if (now.s == t) {\n        res = now.dis - 1;\n        break;\n      }\n\n      int nd = now.dis + 1;\n      REP(i, 2) {\n        int nx = now.x + dx[i];\n        if (nx<0||nx>=n) continue;\n        \n        if (now.mark == -1) {\n          Q.push(state(now.s, nx, now.x, nd));\n          Q.push(state(now.s, nx, -1, nd));\n        } else {\n          Q.push(state(now.s, nx, now.mark, nd));\n          string tmp = now.s;\n          swap(tmp[now.mark], tmp[now.x]);\n          Q.push(state(tmp, nx, -1, nd));\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n    \n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n\tfor(int j=0;j<n;j++){\n\t  if(s[j]!=t[k] && s[k]!=t[j])continue;\n\t  for(int S=0;S<(1<<n);S++){\n\t    if((S>>j&1) || (S>>k&1))continue;\n\t    int next=S;\n\t    if(t[j]==s[k])next|=(1<<j);\n\t    if(t[k]==s[j])next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[2][16][1<<16];\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nint solve(){\n    for(int tern=n;tern>=0;tern--){\n        int nxt=tern%2;\n        int cur=(tern+1)%2;\n        for(int pos=0;pos<n;pos++){\n            for(int sit=0;sit<(1<<n);sit++){\n                int res=INF;\n                if(tern==n){\n                    if(sit==t)res=0;\n                }\n                else{\n                    // ツ督ョツつゥツつキツつセツつッ\n                    for(int to=0;to<n;to++)res=min(res,dp[cur][to][sit]+abs(to-pos));\n                    // trade\n                    for(int to=0;to<n;to++){\n                        int cost=abs(to-pos);\n                        int nsit=sit;\n                        int a=(sit>>pos)&1;\n                        int b=(sit>>to)&1;\n                        setBit(nsit,pos,b);\n                        setBit(nsit,to,a);\n                        res=min(res,dp[cur][to][nsit]+cost);\n                    }\n                }\n                dp[nxt][pos][sit]=res;\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    //ifstream cin(\"/Volumes/env1/work/aoj/2040/a\");\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        string init;\n        string final;\n        cin >> init;\n        cin >> final;\n\n        auto encode = [](const string& s) {\n            int r = 0b0;\n            for (int i = 0; i < s.size(); ++i) {\n                if (i != 0) {\n                    r <<= 1;\n                }\n                if (s[i] == 'B') {\n                    r |= 0b1;\n                }\n            }\n            return r;\n        };\n\n        auto pow = [](int b, int e) {\n            int r = 1;\n            for (int i = 0; i < e; ++i) {\n                r *= b;\n            }\n            return r;\n        };\n\n        auto target = encode(final);\n        auto start = encode(init);\n\n        vector<vector<int>> memo(n, vector<int>(pow(2, n), -1));\n        // p ??????????????´?????¶?????? s ?????¨??????????°???????????????????\n        function<int(int, int)> f = [&f, &memo, n, &pow, start](int p,\n                                                                int s) -> int {\n            //cout << static_cast<bitset<8>>(s) << endl;\n            if (memo[p][s] != -1) {\n                //cout << \"memo1\" << p << ' ' << s << endl;\n                return memo[p][s];\n            }\n\n            // ??????????????´????????????\n            if (s == 0) {\n                return 0;\n            }\n\n            int min_ = numeric_limits<int>::max();\n            int pp = -1;\n            for (int i = 0; i < n; ++i) {\n                // i ??????????????§????????´????????????\n                if (((s >> i) & 1) == 0) {\n                    continue;\n                }\n                for (int j = 0; j < n; ++j) {\n                    if (i == j) {\n                        continue;\n                    }\n                    // j ??????????????§????????´????????????\n                    else if ((s >> j & 1) == 0) {\n                        continue;\n                    }\n                    // ?????????????????\\????????????????°???????????????????\n                    else if ((((start >> i) & 1) ^ ((start >> j) & 1)) == 0) {\n                        continue;\n                    }\n                    else {\n                        // p ?????? i ?????§?????£???, i ?????? j ?????§??????\n                        auto cost = abs(i - p) + abs(j - i);\n                        auto ss = s;\n                        ss ^= 1 << i;\n                        ss ^= 1 << j;\n                        //cout << \"pos: \" << p << \" swap \" << i << \", \" << j\n                        //     << \": \" << static_cast<bitset<8>>(s) << \" to \"\n                        //     << static_cast<bitset<8>>(ss) << \" cost \" << cost\n                        //     << endl;\n                        auto min__ = min_;\n                        min_ = min(min_, cost + f(j, ss));\n                        if (min__ != min_) {\n                            pp = p;\n                        }\n                    }\n                }\n            }\n            //cout << \"write memo \" << pp << \" \" << static_cast<bitset<8>>(s) << endl;\n            memo[pp][s] = min_;\n            assert(min_ != -1);\n\n            return min_;\n        };\n\n        int min_ = numeric_limits<int>::max();\n        for (int i = 0; i < n; ++i) {\n            min_ = min(min_, f(i, start ^ target));\n        }\n        cout << min_ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int cost[16][16][16];\n    for(int i=0;i<16;i++)\n      for(int j=0;j<16;j++)\n\tfor(int k=0;k<16;k++)cost[i][j][k]=abs(j-i)+abs(k-j);\n\n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(tmp>>i&1)continue;\n\tfor(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t      int next=S;\n\t      next|=(1<<j)|(1<<k);\n\t      dp[k][next]=min(dp[k][next],dp[i][S]+cost[i][j][k]);\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    if(ans>=INF)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 17;\nconst int INF = 1<<28;\nint N;\nint start, finish;\nint dp[1<<MAXN][MAXN];\n \nint rec(int b, int p, int d) {\n  int &res = dp[b][p];\n  if(res != -1) return res;\n  if(b == finish) return res = 0;\n  res = INF;\n  if(d == 10000) return res;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(i == j) continue;\n      if(((b>>i)&1)^((b>>j)&1)) ; else continue;\n      int nb = b;\n      nb ^= (1<<i);\n      nb ^= (1<<j);\n      int addcost;\n      if(p == N) addcost = abs(j-i);\n      else addcost = abs(i-p) + abs(j-i);\n      res = min(res, rec(nb, j, d+1) + addcost);\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    string a, b;\n    cin >> a >> b;\n    start = finish = 0;\n    for(int i = 0; i < N; ++i) {\n      if(a[i] == 'W') start |= 1<<i;\n      if(b[i] == 'W') finish |= 1<<i;\n    }\n    fill(dp[0], dp[1<<MAXN], -1);\n    int res = rec(start, N, 0);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint n;\nchar start[17],goal[17];\n\nint dp[1<<16][16];\nint dfs(int S,int p){\n\tif(S==(1<<n)-1) return 0;\n\n\tif(dp[S][p]!=-1) return dp[S][p];\n\n\tint res=INF;\n\trep(i,n) if((S&1<<i)==0) rep(j,n) if((S&1<<j)==0 && i!=j && goal[i]!=goal[j]) {\n\t\tres=min(res,abs(p-i)+abs(i-j)+dfs(S|1<<i|1<<j,j));\n\t}\n\treturn dp[S][p]=res;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tscanf(\"%s%s\",start,goal);\n\t\trep(S,1<<n) rep(p,n) dp[S][p]=-1;\n\n\t\tint S=0;\n\t\trep(i,n) if(start[i]==goal[i]) S|=1<<i;\n\n\t\tint ans=INF;\n\t\trep(i,n) ans=min(ans,dfs(S,i));\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[17][(1<<17)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n+1],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n\tfor(int S=0;S<(1<<n);S++){\n\tif(S>>k&1)continue;\n\t  for(int j=0;j<n;j++){\n\t    if(S>>j&1)continue;\n\t    if(j==k)continue;\n\t    if(s[j]==s[k])continue;\n\t    int next=S;\n\t    next|=(1<<j);\n\t    next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<=n;i++){\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef unsigned short ushort;\n\nclass State{\n    public:\n    ushort cur, n, str;\n    State(ushort n = 0, ushort cur=0, ushort s=0):n(n), cur(cur), str(s){}\n\n    bool operator < ( const State &s) const{\n\tif ( str != s.str ) return str < s.str;\n\treturn cur < s.cur;\n    }\n};\n\nclass QState{\n    public:\n    int cost;\n    State state;\n    QState(){}\n    QState(State s, int c):state(s), cost(c){}\n    bool operator < ( const QState &q ) const{ return cost > q.cost; }\n};\n\nint dist(int i, int j){\n    return max(i, j) - min(i, j);\n}\t    \n\nint dijkstra(int n, ushort start, ushort goal){\n    priority_queue<QState> PQ;\n    bool finished[n][(1<<n)];\n    int d[n][(1<<n)];\n\n    for ( int i = 0; i < n; i++ ){\n\tfor ( int j = 0; j < (1<<n); j++ ){\n\t    finished[i][j] = false;\n\t    d[i][j] = (1<<21);\n\t}\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n\tState st = State(n, i, start);\n\td[i][start] = 0;\n\tPQ.push(QState(st, 0));\n    }\n\n    QState u;\n    while( !PQ.empty() ){\n\tu = PQ.top(); PQ.pop();\n\tif ( u.state.str == goal ) return u.cost;\n\n\tfinished[u.state.cur][u.state.str] = true;\n\n\tfor ( int i = 0; i < n; i++ ){\n\t    for  ( int j = 0; j < n; j++ ){\n\t\tState st = u.state;\n\t\tushort p1 = (st.str & (1<<i));\n\t\tushort p2 = (st.str & (1<<j));\n\n\t\tif ( p1 == p2 ) continue;\n\n\t\tif ( p1 > 0 && p2 == 0 ){\n\t\t    st.str -= p1;\n\t\t    st.str += (1<<j);\n\t\t} else if ( p1 == 0 && p2 > 0 ){\n\t\t    st.str -= p2;\n\t\t    st.str += (1<<i);\n\t\t}\n\n\t\tst.cur = j;\n\n\t\tint ncost = u.cost + dist(u.state.cur, i) + dist(i, j);\n\n\t\tif ( finished[st.cur][st.str] ) continue;\n\n\t\tif ( ncost < d[st.cur][st.str] ){\n\t\t    d[st.cur][st.str] = ncost;\n\t\t    PQ.push(QState(st, ncost));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nmain(){\n    int n;\n    string s, g;\n    while( cin >> n && n ){\n\tcin >> s >> g;\n\tushort si = 0, gi = 0;\n\tushort p = 1;\n\tfor ( int i = n-1; i >= 0; i--, p *= 2){\n\t    if ( s[i] == 'B' ) si += p;\n\t    if ( g[i] == 'B' ) gi += p;\n\t}\n\tcout << dijkstra(n, si, gi) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int panel;\n  int cost;\n  int machine_pos;\n  State(int panel,int cost,int machine_pos){\n    this->panel = panel;\n    this->cost = cost;\n    this->machine_pos = machine_pos;\n  }\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint dp[16][1<<16];\n\nint main(){\n  int num_of_panels;\n  while(~scanf(\"%d\",&num_of_panels)){\n    if(num_of_panels == 0) break;\n\n    int panels[2] = {};\n    for(int set_i = 0; set_i < 2; set_i++){\n      string panel;\n      cin >> panel;\n      for(int pos = 0; pos < num_of_panels; pos++){\n        if(panel[pos] == 'B'){\n          panels[set_i] |= (1<<pos);\n        }\n      }\n    }\n  \n    priority_queue<State,vector<State>,greater<State> > que;\n\n    memset(dp,0x3f,sizeof(dp));\n    for(int pos = 0; pos < num_of_panels; pos++){\n      dp[pos][panels[0]] = 0;\n      que.push(State(panels[0],0,pos));      \n    }\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.panel == panels[1]) goto found;\n\n      for(int from = 0; from < num_of_panels; from++){\n        for(int to = 0; to < num_of_panels; to++){\n          if(from == to) continue;\n\n          int from_bit = (s.panel >> from) & 1;\n          int to_bit = (s.panel >> to) & 1;\n          \n          int next_panel = s.panel;\n          if(to_bit == 1){\n            next_panel = next_panel | (1 << from);\n          }\n          else {\n            next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << from));\n          }\n          \n          if(from_bit == 1){\n            next_panel = next_panel | (1 << to);\n          }\n          else {\n            next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << to));\n          }\n          \n          if(dp[to][next_panel] <= s.cost + abs(to - from) + abs(from - s.machine_pos)) continue;\n          dp[to][next_panel] = s.cost + abs(to - from) + abs(from - s.machine_pos);\n          que.push(State(next_panel,s.cost + abs(to - from) + abs(from - s.machine_pos),to));\n        }\n      }\n    }\n  found:;\n    int res = INF;\n    for(int pos = 0; pos < num_of_panels; pos++){\n      res = min(res,dp[pos][panels[1]]);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct state {\n  int s;\n  int x;\n  int mark;\n  int dis;\n  state(int s, int x, int mark, int dis) :\n    s(s), x(x), mark(mark), dis(dis) {}\n};\n// const bool operator<(const state &a, const state &b) {\n//   return a.s!=b.s?a.s<b.s:a.x!=b.x?a.x<b.x:a.mark<b.mark;\n// }\n\nint dx[2] = {-1,1};\nbool visited[1<<16][16][16];\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    string ss,tt;\n    cin >> ss >> tt;\n    int s=0, t=0;\n    REP(i, n) {\n      if (ss[i]=='W') s |= 1<<i;\n      if (tt[i]=='W') t |= 1<<i;\n    }\n    \n    queue<state> Q;\n    REP(i, n) Q.push(state(s, i, -1, 0));\n    int res;\n    memset(visited,0,sizeof(visited));\n    while(!Q.empty()) {\n      state now = Q.front();\n      Q.pop();\n\n      if (visited[now.s][now.x][now.mark]) continue;\n      visited[now.s][now.x][now.mark] = 1;\n\n      //cout << now.s << \" \" << now.x << \" \" << now.mark << \" \" << now.dis << endl;\n      if (now.s == t) {\n        res = now.dis - 1;\n        break;\n      }\n\n      int nd = now.dis + 1;\n      REP(i, 2) {\n        int nx = now.x + dx[i];\n        if (nx<0||nx>=n) continue;\n        \n        if (now.mark == -1) {\n          Q.push(state(now.s, nx, now.x, nd));\n          Q.push(state(now.s, nx, -1, nd));\n        } else {\n          Q.push(state(now.s, nx, now.mark, nd));\n          int tmp = now.s;\n          if (now.s >> now.mark & 1) {\n            tmp |= 1<<now.x;\n          } else {\n            if (now.s >> now.x & 1) tmp ^= 1<<now.x;\n          }\n          if (now.s >> now.x & 1) {\n            tmp |= 1<<now.mark;\n          } else {\n            if (now.s >> now.mark & 1) tmp ^= 1<<now.mark;\n          }\n          Q.push(state(tmp, nx, -1, nd));\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[20][16][1<<16];\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nint solve(){\n    for(int tern=n;tern>=0;tern--){\n        for(int pos=0;pos<n;pos++){\n            for(int sit=0;sit<(1<<n);sit++){\n                int res=INF;\n                if(tern==n){\n                    if(sit==t)res=0;\n                }\n                else{\n                    for(int to=0;to<n;to++){\n                        int cost=abs(to-pos);\n                        int nsit=sit;\n                        int a=(sit>>pos)&1;\n                        int b=(sit>>to)&1;\n                        setBit(nsit,pos,b);\n                        setBit(nsit,to,a);\n                        res=min(res,dp[tern+1][to][nsit]+cost);\n                    }\n                }\n                dp[tern][pos][sit]=res;\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nint N, endbit, Mask;\nint dp[1 << 16][16];\n\nint rec(int bit, int ptr){\n  if(bit == endbit) return 0;\n  if(~dp[bit][ptr]) return dp[bit][ptr];\n  int ret = INF;\n  for(int i = 0; i < N; i++){\n    if((bit ^ endbit) & (1 << i)){\n      for(int j = i + 1; j < N; j++){\n        if((bit ^ endbit) & (1 << j) && ((bit >> i) & 1) ^ ((bit >> j) & 1)){\n          int nextbit = bit&~((1 << i)|(1 << j))|(endbit & (1 << i))|(endbit & (1 << j));\n          int cost = abs(ptr - i) + j - i;\n          ret = min( ret, rec( nextbit, j) + cost);\n          //      cost = abs(ptr - j) + j - i;\n          //      ret = min( ret, rec( nextbit, i) + cost);\n        }\n      }\n    }\n  }\n  return dp[bit][ptr] = ret;\n}\n\nint main(){\n  int bit;\n  string A, B;\n\n  while(cin >> N, N){\n    cin >> A >> B;\n\n    Mask = (1 << N) - 1;\n    bit = 0, endbit = 0;\n    for(int i = 0; i < A.length(); i++){\n      bit |= (A[i] == 'W') << i;\n      endbit |= (B[i] == 'W') << i;\n    }\n\n    fill_n( *dp, (1 << 16) * 16, -1);\n    int ret = INF;\n    for(int i = 0; i < A.length(); i++){\n      ret = min( ret, rec(bit, i));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef unsigned short ushort;\n\nclass QState{\n    public:\n    int cur, str, cost;\n    QState(){}\n    QState(int cur, int str, int c):cur(cur), str(str), cost(c){}\n    bool operator < ( const QState &q ) const{ return cost > q.cost; }\n};\n\nushort T[16];\n\nint dist(int i, int j){\n    return max(i, j) - min(i, j);\n}\t    \n\nint dijkstra(int n, ushort start, ushort goal){\n    priority_queue<QState> PQ;\n    //    bool finished[n][(1<<n)];\n    ushort d[n][(1<<n)];\n\n    for ( int i = 0; i < n; i++ ){\n\tfor ( int j = 0; j < (1<<n); j++ ){\n\t    //    finished[i][j] = false;\n\t    d[i][j] = (1<<10);\n\t}\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n\td[i][start] = 0;\n\tPQ.push(QState(i, start, 0));\n    }\n\n    QState u;\n    while( !PQ.empty() ){\n\tu = PQ.top(); PQ.pop();\n\tif ( u.str == goal ) return u.cost;\n\n\t//\tfinished[u.cur][u.str] = true;\n\n\tfor ( int i = 0; i < n; i++ ){\n\t    for  ( int j = 0; j < n; j++ ){\n\t\tint nstr = u.str;\n\t\tint ncur = u.cur;\n\t\tushort p1 = (nstr & T[i]);\n\t\tushort p2 = (nstr & T[j]);\n\t\t\n\t\tif ( p1 == p2 ) continue;\n\n\t\tif ( p1 > 0 && p2 == 0 ){\n\t\t    nstr -= p1;\n\t\t    nstr += T[j];\n\t\t} else if ( p1 == 0 && p2 > 0 ){\n\t\t    nstr -= p2;\n\t\t    nstr += T[i];\n\t\t}\n\n\t\tncur = j;\n\n\t\tint ncost = u.cost + dist(u.cur, i) + dist(i, j);\n\n\t\t//\t\tif ( finished[ncur][nstr] ) continue;\n\n\t\tif ( ncost < d[ncur][nstr] ){\n\t\t    d[ncur][nstr] = ncost;\n\t\t    PQ.push(QState(ncur, nstr, ncost));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nmain(){\n    int n;\n    string s, g;\n\n    for ( int i = 0; i < 16; i++ ) T[i] = (1<<i);\n    while( cin >> n && n ){\n\tcin >> s >> g;\n\tushort si = 0, gi = 0;\n\tushort p = 1;\n\tfor ( int i = n-1; i >= 0; i--, p *= 2){\n\t    if ( s[i] == 'B' ) si += p;\n\t    if ( g[i] == 'B' ) gi += p;\n\t}\n\tcout << dijkstra(n, si, gi) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n \n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \nint dp[16][(1<<16)];\n \nint main(void){\n \n  int n;\n  string s,t;\n \n  while(cin >> n,n){\n    cin >> s >> t;\n \n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n     \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n    if(!(tmp>>i&1)){\n      for(int k=0;k<n;k++){\n        for(int j=0;j<n;j++){\n          if(s[j]!=s[k]){\n        for(int S=0;S<(1<<n);S++){\n          if(!(S>>j&1) && !(S>>k&1)){\n            int next=S;\n            next|=(1<<j)|(1<<k);\n            if(dp[k][next]>dp[i][S]+abs(j-i)+abs(k-j))\n              dp[k][next]=dp[i][S]+abs(j-i)+abs(k-j);\n          }\n        }\n          }\n        }\n      }\n    }\n    ans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n    \n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int r=0;r<3;r++)\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n\tfor(int j=0;j<n;j++){\n\t  if(s[j]==s[k])continue;\n\t  for(int S=0;S<(1<<n);S++){\n\t    if((S>>j&1) || (S>>k&1))continue;\n\t    int next=S;\n\t    next|=(1<<j);\n\t    next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <limits>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        string init;\n        string final;\n        cin >> init;\n        cin >> final;\n\n        auto encode = [](const string& s) {\n            int r = 0b0;\n            for (int i = 0; i < s.size(); ++i) {\n                if (i != 0) {\n                    r <<= 1;\n                }\n                if (s[i] == 'B') {\n                    r |= 0b1;\n                }\n            }\n            return r;\n        };\n\n        auto target = encode(final);\n        auto start = encode(init);\n\n        vector<vector<int>> memo(n, vector<int>(1 << n, -1));\n        // p ??????????????´?????¶?????? s ?????¨??????????°???????????????????\n        function<int(int, int)> f = [&f, &memo, n, start](int p, int s) -> int {\n            if (memo[p][s] != -1) {\n                return memo[p][s];\n            }\n\n            // ??????????????´????????????\n            if (s == 0) {\n                return 0;\n            }\n\n            int min_ = numeric_limits<int>::max();\n            for (int i = 0; i < n; ++i) {\n                // i ??????????????§????????´????????????\n                if (((s >> i) & 1) == 0) {\n                    continue;\n                }\n                for (int j = 0; j < n; ++j) {\n                    if (i == j) {\n                        continue;\n                    }\n                    // j ??????????????§????????´????????????\n                    else if ((s >> j & 1) == 0) {\n                        continue;\n                    }\n                    // ?????????????????\\????????????????°???????????????????\n                    else if ((((start >> i) & 1) ^ ((start >> j) & 1)) == 0) {\n                        continue;\n                    }\n                    else {\n                        // p ?????? i ?????§?????£???, i ?????? j ?????§??????\n                        auto cost = abs(i - p) + abs(j - i);\n                        min_ = min(min_, cost + f(j, s ^ (1 << i) ^ (1 << j)));\n                    }\n                }\n            }\n            memo[p][s] = min_;\n\n            return min_;\n        };\n\n        int min_ = numeric_limits<int>::max();\n        // ????????????????????????????????????\n        for (int i = 0; i < n; ++i) {\n            min_ = min(min_, f(i, start ^ target));\n        }\n        cout << min_ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nunsigned char dp[65536][16];\nstruct st{\n\tunsigned short haichi;\n\tunsigned char pos;\n};\nqueue<st> P;\nint main() {\n\tint n;\n\twhile (cin >> n,n){\n\t\tstring s, ans_s;\n\t\tcin >> s;\n\t\tcin >> ans_s;\n\t\tunsigned short sh=0;\n\t\tunsigned short ans_sh=0;\n\t\tREP(i, n){\n\t\t\tsh <<= 1;\n\t\t\tans_sh <<= 1;\n\t\t\tif (s[i] == 'W')\n\t\t\t\tsh |= 1;\n\t\t\tif (ans_s[i] == 'W')\n\t\t\t\tans_sh |= 1;\n\t\t}\n\t\tREP(i, 65536 * 16)\n\t\t\tdp[i / 16][i % 16] = 255;\n\t\t\n\t\tREP(i, n){\n\t\t\tP.push({ sh, (unsigned char)i });\n\t\t\tdp[sh][i] = 0;\n\t\t}\n\t\n\t\twhile (!P.empty()){\n\t\t\tst p = P.front(); P.pop();\n\t\t\tunsigned short diff=p.haichi^ans_sh;\n\t\t\tvector<unsigned char> db;\n\t\t\tvector<unsigned char> dw;\n\t\t\tREP (i,n){\n\t\t\t\tif ((diff >> i) & 1)\n\t\t\t\t\tif (!((p.haichi >> i) & 1))\n\t\t\t\t\t\tdb.push_back(i);\n\t\t\t\t\telse\n\t\t\t\t\t\tdw.push_back(i);\n\t\t\t}\n\t\t\tREP(i, db.size()){\n\t\t\t\tREP(j,dw.size()){\n\t\t\t\t\tunsigned short change = (1 << db[i]) + (1 << dw[j]);\n\t\t\t\t\tchange ^= p.haichi;\n\t\t\t\t\tif (dp[change][db[i]]>dp[p.haichi][p.pos]+abs(p.pos - dw[j]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][db[i]] = dp[p.haichi][p.pos] + abs(p.pos - dw[j]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, db[i] });\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[change][dw[j]]>dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][dw[j]] = dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, dw[j] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_ans=255;\n\t\tREP(i,n){\n\t\t\tmin_ans = min((int)dp[ans_sh][i],min_ans);\n\t\t}\n\t\tcout << min_ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nint main(){\n  int N;\n  while(cin>>N && N){\n    string ss, gs; cin>>ss>>gs;\n    int St = 0, G = 0;\n    REP(i, N){\n      St |= (int)(ss[i] == 'B') << i;\n      G |= (int)(gs[i] == 'B') << i;\n    }\n    priority_queue<S> que;\n    int dist[1<<16][16];\n    REP(i, 1<<N)REP(j, N) dist[i][j] = INF;\n    REP(i, N){\n      dist[St][i] = 0;\n      que.push(S(0, P(St, i)));\n    }\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      int d = s.first * -1;\n      int state = s.second.first;\n      int u = s.second.second;\n      if(state == G){\n        cout<<d<<endl;\n        break;\n      }\n      if(dist[state][u] < d) continue;\n      REP(i, N){\n        if(!((state ^ G) >> i & 1)) continue;\n        REP(j, N)if((state >> i & 1) != (state >> j & 1)){\n          int nst = state ^ (1 << i) ^ (1 << j);\n          if(((nst ^ G) >> i & 1) && (nst ^ G) >> j & 1) continue;\n          int nd = d + abs(i - u) + abs(j - i);\n          int nu = j;\n          if(dist[nst][nu] > nd){\n            dist[nst][nu] = nd;\n            que.push(S(nd * -1, P(nst, nu)));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nunsigned char dp[65536][16];\nstruct st{\n\tshort haichi;\n\tunsigned char pos;\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n,n){\n\t\tstring s, ans_s;\n\t\tcin >> s;\n\t\tcin >> ans_s;\n\t\tshort sh=0;\n\t\tshort ans_sh=0;\n\t\tREP(i, n){\n\t\t\tsh <<= 1;\n\t\t\tans_sh <<= 1;\n\t\t\tif (s[i] == 'W')\n\t\t\t\tsh |= 1;\n\t\t\tif (ans_s[i] == 'W')\n\t\t\t\tans_sh |= 1;\n\t\t}\n\t\tREP(i, 65536 * 16)\n\t\t\tdp[i / 16][i % 16] = 255;\n\t\tqueue<st> P;\n\t\tREP(i, n){\n\t\t\tP.push({ sh, i });\n\t\t\tdp[sh][i] = 0;\n\t\t}\n\t\tint pos;\n\t\twhile (!P.empty()){\n\t\t\tst p = P.front(); P.pop();\n\t\t\tif (p.haichi == ans_sh){\n\t\t\t\tpos = p.pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tshort diff=p.haichi^ans_sh;\n\t\t\tvector<int> db;\n\t\t\tvector<int> dw;\n\t\t\tREP (i,n){\n\t\t\t\tif ((diff >> i) & 1)\n\t\t\t\t\tif (!((p.haichi >> i) & 1))\n\t\t\t\t\t\tdb.push_back(i);\n\t\t\t\t\telse\n\t\t\t\t\t\tdw.push_back(i);\n\t\t\t}\n\t\t\tREP(i, db.size()){\n\t\t\t\tREP(j,dw.size()){\n\t\t\t\t\tshort change = (1 << db[i]) + (1 << dw[j]);\n\t\t\t\t\tchange ^= p.haichi;\n\t\t\t\t\tif (dp[change][db[i]]>dp[p.haichi][p.pos]+abs(p.pos - dw[j]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][db[i]] = dp[p.haichi][p.pos] + abs(p.pos - dw[j]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, db[i] });\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[change][dw[j]]>dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][dw[j]] = dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, dw[j] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (int)dp[ans_sh][pos] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        string init;\n        string final;\n        cin >> init;\n        cin >> final;\n\n        auto encode = [](const string& s) {\n            int r = 0b0;\n            for (int i = 0; i < s.size(); ++i) {\n                if (i != 0) {\n                    r <<= 1;\n                }\n                if (s[i] == 'B') {\n                    r |= 0b1;\n                }\n            }\n            return r;\n        };\n\n        auto pow = [](int b, int e) {\n            int r = 1;\n            for (int i = 0; i < e; ++i) {\n                r *= b;\n            }\n            return r;\n        };\n\n        auto target = encode(final);\n        auto start = encode(init);\n\n        vector<vector<int>> memo(n, vector<int>(pow(2, n), -1));\n        // p ??????????????´?????¶?????? s ?????¨??????????°???????????????????\n        function<int(int, int)> f = [&f, &memo, n, &pow, start](int p,\n                                                                int s) -> int {\n            if (memo[p][s] != -1) {\n                return memo[p][s];\n            }\n\n            // ??????????????´????????????\n            if (s == 0) {\n                return 0;\n            }\n\n            int min_ = numeric_limits<int>::max();\n            int pp = -1;\n            for (int i = 0; i < n; ++i) {\n                // i ??????????????§????????´????????????\n                if (((s >> i) & 1) == 0) {\n                    continue;\n                }\n                for (int j = 0; j < n; ++j) {\n                    if (i == j) {\n                        continue;\n                    }\n                    // j ??????????????§????????´????????????\n                    else if ((s >> j & 1) == 0) {\n                        continue;\n                    }\n                    // ?????????????????\\????????????????°???????????????????\n                    else if ((((start >> i) & 1) ^ ((start >> j) & 1)) == 0) {\n                        continue;\n                    }\n                    else {\n                        // p ?????? i ?????§?????£???, i ?????? j ?????§??????\n                        auto cost = abs(i - p) + abs(j - i);\n                        auto ss = s;\n                        ss ^= 1 << i;\n                        ss ^= 1 << j;\n                        auto min__ = min_;\n                        min_ = min(min_, cost + f(j, ss));\n                        if (min__ != min_) {\n                            pp = p;\n                        }\n                    }\n                }\n            }\n            memo[pp][s] = min_;\n\n            return min_;\n        };\n\n        int min_ = numeric_limits<int>::max();\n        for (int i = 0; i < n; ++i) {\n            min_ = min(min_, f(i, start ^ target));\n        }\n        cout << min_ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n \ntypedef pair<int, int> paii;\ntypedef long long ll;\n\ntypedef\tpair<int, paii> tupl;\n\nint n;\nstring a, b;\nint vtx[18][66000];\n\nint solve(){\n\t\n\tint x = 0, y = 0, res = 100000;\n\n\tfor(int i = 0; i < n; i++){\n\t\tx = x<<1; \n\t\ty = y<<1;\n\t\tx += (a[i]=='W'?0:1);\n\t\ty += (b[i]=='W'?0:1);\n\t}\n\t\n\tfor(int k = 0; k < n; ++k){\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < 66000; ++j)\n\t\t\t\tvtx[i][j] = (j!=x?100000:0);\n\t\t\n\t\tpriority_queue<tupl, vector<tupl>, greater<tupl> > qu;\n\t\tqu.push(make_pair(0, make_pair(k, x)));\n\t\tvtx[k][x] = 0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t\n\t\t\tint m = qu.top().second.first;\n\t\t\tint w = qu.top().second.second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = i; j < n; ++j){\n\t\t\t\t\n\t\t\t\t\tif( i!=j && ((w>>i&1) != (w>>j&1))\n\t\t\t\t\t\t\t&& ((w>>i&1) != (y>>i&1)) && ((w>>j&1) != (y>>j&1)) ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tint z = w^( (1<<i)|(1<<j) );\n\t\t\t\t\t\tint dsta = abs(j-m)+abs(i-j);\n\t\t\t\t\t\t//int dstb = abs(i-m)+abs(j-i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( vtx[i][z] > vtx[m][w] + dsta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[i][z] = vtx[m][w] + dsta;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[i][z], make_pair(i, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif( vtx[j][z] > vtx[m][w] + dstb){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[j][z] = vtx[m][w] + dstb;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[j][z], make_pair(j, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tres = min(res, vtx[i][y]);\n\t\t}\n\t\t\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> n, n){\n\t\n\t\tcin >> a;\n\t\tcin >> b;\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n \ntypedef pair<int, int> paii;\ntypedef long long ll;\n\nint n;\nstring a, b;\nint vtx[18][66000];\n\nint solve(){\n\t\n\tint x = 0, y = 0, res = 100000;\n\n\tfor(int i = 0; i < n; i++){\n\t\tx = x<<1; \n\t\ty = y<<1;\n\t\tx += (a[i]=='W'?0:1);\n\t\ty += (b[i]=='W'?0:1);\n\t}\n\t\n\tfor(int k = 0; k < n; ++k){\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < 66000; ++j)\n\t\t\t\tvtx[i][j] = (j!=x?100000:0);\n\t\t\n\t\tqueue<paii> qu;\n\t\tqu.push(make_pair(k, x));\n\t\tvtx[k][x] = 0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t\n\t\t\tint m = qu.front().first;\n\t\t\tint w = qu.front().second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\n\t\t\t\t\tif( i!=j && ((w & 1<<i) != (w & 1<<j))\n\t\t\t\t\t\t\t&& ((w & 1<<i) != (y & 1<<i)) && ((w & 1<<j) != (y & 1<<j)) ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tint z = w^( (1<<i)|(1<<j) );\n\t\t\t\t\t\tint dsta = abs(j-m)+abs(i-j);\n\t\t\t\t\t\tint dstb = abs(i-m)+abs(j-i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( vtx[i][z] > vtx[m][w] + dsta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[i][z] = vtx[m][w] + dsta;\n\t\t\t\t\t\t\tqu.push(make_pair(i, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( vtx[j][z] > vtx[m][w] + dstb){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[j][z] = vtx[m][w] + dstb;\n\t\t\t\t\t\t\tqu.push(make_pair(j, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tres = min(res, vtx[i][y]);\n\t\t}\n\t\t\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> n, n){\n\t\n\t\tcin >> a;\n\t\tcin >> b;\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int LIMIT = (1<<16), IINF = INT_MAX;\n\nbool fin[LIMIT];\nint N,dp[16][LIMIT];\nstring a,b;\n\nint main(){\n  while( cin >> N, N ){\n    cin.ignore();\n    getline(cin,a);\n    getline(cin,b);\n\n    if( a == b ) {\n      puts(\"0\");\n      continue;\n    }\n\n    rep(i,N)rep(j,(1<<N)) dp[i][j] = IINF;\n    rep(i,N) dp[i][0] = 0;\n\n    rep(i,(1<<N)) {\n      fin[i] = true;\n      rep(j,N){\n        if((i>>j) & 1) continue;\n        if( a[j] != b[j] ) {\n          fin[i] = false;\n          break;\n        }\n      }\n    }\n\n    rep(state,(1<<N)){\n      rep(cur,N){\n        if( dp[cur][state] == IINF ) continue;\n        rep(from,N){\n          if( (state>>from) & 1 ) continue;\n          rep(to,N){\n            if( from == to ) continue;\n            if( (state>>to) & 1 ) continue;\n            if( !( a[from] == b[to] && a[to] == b[from] ) ) continue;\n            int nstate = state|(1<<from)|(1<<to);\n            if( fin[nstate] ) nstate = (1<<N)-1;\n            dp[to][nstate] = min(dp[to][nstate],\n                                 dp[cur][state] + abs(cur-from) + abs(from-to));\n          }\n        }\n      }\n    }\n\n    int mini = IINF;\n    rep(i,N) mini = min(mini,dp[i][(1<<N)-1]);\n    cout << mini << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_state,int arg_sum_cost,int arg_loc){\n\t\tstate = arg_state;\n\t\tsum_cost = arg_sum_cost;\n\t\tloc = arg_loc;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint state,sum_cost,loc;\n};\n\n\nint N;\nint POW[17],dp[65536][16],start_state,goal_state,ans_num[16];\nchar buf_start[17],buf_goal[17];\n\nvoid func(){\n\n\tscanf(\"%s\",buf_start);\n\n\tstart_state = 0;\n\n\tfor(int i = 0; buf_start[i] != '\\0'; i++){\n\t\tif(buf_start[i] == 'B'){\n\t\t\tstart_state += POW[i];\n\t\t}\n\t}\n\n\tscanf(\"%s\",buf_goal);\n\n\tgoal_state = 0;\n\n\tfor(int i = 0; buf_goal[i] != '\\0'; i++){\n\t\tif(buf_goal[i] == 'B'){\n\t\t\tgoal_state += POW[i];\n\t\t\tans_num[i] = 1;\n\t\t}else{\n\t\t\tans_num[i] = 0;\n\t\t}\n\t}\n\n\tif(start_state == goal_state){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tfor(int state = 0; state < POW[N]; state++){\n\t\tfor(int loc = 0; loc < N; loc++)dp[state][loc] = BIG_NUM;\n\t}\n\n\tpriority_queue<Info> Q;\n\tfor(int loc = 0; loc < N; loc++){\n\t\tdp[start_state][loc] = 0;\n\t\tQ.push(Info(start_state,0,loc));\n\t}\n\n\tint ans = BIG_NUM;\n\tint next_state,num_1,num_2,tmp_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().state == goal_state){\n\t\t\tans = min(ans,Q.top().sum_cost);\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > dp[Q.top().state][Q.top().loc]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int mark_1 = 0; mark_1 < N; mark_1++){\n\t\t\t\tfor(int mark_2 = 0; mark_2 < N; mark_2++){\n\t\t\t\t\tif(mark_1 == mark_2)continue;\n\n\t\t\t\t\tif(Q.top().state & (1 << mark_1)){\n\t\t\t\t\t\tnum_1 = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnum_1 = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(Q.top().state & (1 << mark_2)){\n\t\t\t\t\t\tnum_2 = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnum_2 = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(num_1 == num_2)continue;\n\n\t\t\t\t\tif(num_1 == ans_num[mark_1] && num_2 == ans_num[mark_2])continue;\n\n\t\t\t\t\tif(num_1 == 1){\n\t\t\t\t\t\tnext_state = Q.top().state-POW[mark_1]+POW[mark_2];\n\t\t\t\t\t}else{ //num_2 == 1\n\t\t\t\t\t\tnext_state = Q.top().state+POW[mark_1]-POW[mark_2];\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp_cost = abs(mark_1-Q.top().loc)+abs(mark_2-mark_1);\n\n\t\t\t\t\tif(dp[next_state][mark_2] > Q.top().sum_cost+tmp_cost){\n\t\t\t\t\t\tdp[next_state][mark_2] = Q.top().sum_cost+tmp_cost;\n\t\t\t\t\t\tQ.push(Info(next_state,Q.top().sum_cost+tmp_cost,mark_2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 17; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <map>\n#include <queue>\n#include <functional>\n#include <assert.h>\nusing namespace std;\ninline int pack(int p, int ps, int n) {\n  return (p << n) | ps;\n}\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n==0) break;\n    string sa, sb;\n    getline(cin, sa);\n    getline(cin, sa);\n    getline(cin, sb);\n    auto conv = [n](string &s) {\n      int r = 0;\n      for(int i = 0; i < n; i++) {\n        r = (r<<1) + (s[i] == 'W' ? 1 : 0); \n      }\n      return r;\n    };\n    int a = conv(sa);\n    int b = conv(sb);\n    //cout << \"a = \" << static_cast<std::bitset<8> >(a) << endl;\n    //cout << \"b = \" << static_cast<std::bitset<8> >(b) << endl;\n\n    // state = (pos, panels)\n    vector<int> ds(n<<n, 100000000);\n    priority_queue<pair<int,int>> que;\n    for(int i = 0; i < n; i++) {\n      int v = pack(i, a, n);\n      ds[v] = 0;\n      que.push(make_pair(-ds[v], v));\n      \n    }\n    vector<bool> done(n, false);\n    int rest = n;\n    while(que.size() > 0) {\n      auto dv = que.top(); que.pop();\n      const int v = dv.second;\n      const int d = -dv.first;\n      const int p = v >> n;\n      const int s = v & ((1<<n) - 1);\n      //cout << \"popped: \" << static_cast<std::bitset<8> >(s) << \" at \" << p << \" with cost \" << d << endl;\n      if(s == b) {\n        if(!done[p]) {\n          done[p] = true;\n          rest--;\n        }\n        if(rest == 0) {\n          int e = d;\n          for(int i = 0; i < n; i++) {\n            e = min(e, ds[pack(i, b, n)]);\n          }\n          cout << e << endl;\n          break;\n        }\n      }\n      // generate all possible transitions: marking i, and then j.\n      for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n          if(i == j) continue;\n          if((((s>>i) ^ (s>>j))&1) == 0) continue;\n          const int c = abs(i - p) + abs(j - i);\n          const int u = pack(j, s ^ (1<<i) ^ (1<<j), n); // swap\n          if(ds[u] > d + c) {\n            ds[u] = d + c;\n            que.push(make_pair(-ds[u], u));\n            //cout << \" to \" << i << \" and \" << j << \" cost \" << ds[u] << \" for \" << static_cast<std::bitset<8> >(u) << endl;\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(tmp>>i&1)continue;\n\tfor(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t      int next=S;\n\t      next|=(1<<j)|(1<<k);\n\t      dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    if(ans>=INF)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint p,c;\n\tstring s;\n\tState(int p, int c, string s)\n\t\t:p(p),c(c),s(s)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c>s.c;\n\t}\n};\n\nint toBin(string s)\n{\n\tint ret=0;\n\tfor(int i=0; i<s.size(); i++)\n\t\tif(s[i]=='B') ret+=(1<<i);\n\n\treturn ret;\n}\n\nbool v[16][1<<16];\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tstring S,D;\n\t\tcin >> S >> D;\n\n\t\tmemset(v,0,sizeof(v));\n\t\tpriority_queue<State> q;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tq.push(State(i,0,S));\n\t\t}\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.top(); q.pop();\n\t\t\tint b=toBin(s.s);\n\t\t\tif(v[s.p][b]) continue;\n\t\t\tv[s.p][b]=1;\n\n\t\t\tif(s.s==D)\n\t\t\t{\n\t\t\t\tcout << s.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<N; i++)\n\t\t\t{\n\t\t\t\tif(!v[i][b]) q.push(State(i,s.c+abs(s.p-i),s.s));\n\t\t\t\tstring ts = s.s;\n\n\t\t\t\tswap(ts[s.p],ts[i]);\n\t\t\t\tint tb=toBin(ts);\n\t\t\t\tif(!v[i][tb]) q.push(State(i,s.c+abs(s.p-i),ts));\n\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint n;\nstring a,b;\n\nint memo[16][1<<16];\n\nint f(int pos,int bit){\n\tif(~memo[pos][bit]) return memo[pos][bit];\n\t\n\tif(bit == 0) return 0;\n\tint ans = 99999;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif(bit>>i&1){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(bit>>j&1){\n\t\t\t\t\tif(a[j] != a[i]){\n\t\t\t\t\t\tint dist1 = abs(pos - i);\n\t\t\t\t\t\tint dist2 = abs(i - j);\n\t\t\t\t\t\tans = min(ans,f(j,bit&~((1<<i)|(1<<j)))+dist1+dist2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[pos][bit] = ans;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcin >> a >> b;\n\t\tint bit = 0;\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tif(a[i] != b[i]) bit |= (1<<i);\n\t\tint ans = 9999;\n\t\tfor(int i = 0 ; i < n ; i++) ans = min(f(i,bit),ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int panel;\n  int cost;\n  int machine_pos;\n  State(int panel,int cost,int machine_pos){\n    this->panel = panel;\n    this->cost = cost;\n    this->machine_pos = machine_pos;\n  }\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint dp[16][1<<16];\n\nint main(){\n  int num_of_panels;\n  while(~scanf(\"%d\",&num_of_panels)){\n    if(num_of_panels == 0) break;\n\n    int panels[2] = {};\n    for(int set_i = 0; set_i < 2; set_i++){\n      string panel;\n      cin >> panel;\n      for(int pos = 0; pos < num_of_panels; pos++){\n        if(panel[pos] == 'B'){\n          panels[set_i] |= (1<<pos);\n        }\n      }\n    }\n  \n    priority_queue<State,vector<State>,greater<State> > que;\n\n    memset(dp,0x3f,sizeof(dp));\n    for(int pos = 0; pos < num_of_panels; pos++){\n      dp[pos][panels[0]] = 0;\n      que.push(State(panels[0],0,pos));      \n    }\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int from = 0; from < num_of_panels; from++){\n        for(int to = 0; to < num_of_panels; to++){\n          if(from == to) continue;\n\n          int from_bit = (s.panel >> from) & 1;\n          int to_bit = (s.panel >> to) & 1;\n          \n          int next_panel = s.panel;\n          if(to_bit == 1){\n            next_panel = next_panel | (1 << from);\n          }\n          else {\n            next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << from));\n          }\n          \n          if(from_bit == 1){\n            next_panel = next_panel | (1 << to);\n          }\n          else {\n            next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << to));\n          }\n          \n          if(dp[to][next_panel] <= s.cost + abs(to - from) + abs(from - s.machine_pos)) continue;\n          dp[to][next_panel] = s.cost + abs(to - from) + abs(from - s.machine_pos);\n          que.push(State(next_panel,s.cost + abs(to - from) + abs(from - s.machine_pos),to));\n        }\n      }\n    }\n\n    int res = INF;\n    for(int pos = 0; pos < num_of_panels; pos++){\n      res = min(res,dp[pos][panels[1]]);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\nint n, s, t; int dp[16][65536], p[16][16];\nqueue<pair<int, int>>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n; s = 0; t = 0; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < (1 << n); j++)dp[i][j] = 999999999; }\n\t\tstring S1; cin >> S1; for (int i = 0; i < S1.size(); i++) { if (S1[i] == 'B')s += (1 << i); }\n\t\tstring S2; cin >> S2; for (int i = 0; i < S2.size(); i++) { if (S2[i] == 'B')t += (1 << i); }\n\t\tfor (int i = 0; i < n; i++) { dp[i][s] = 0; Q.push(make_pair(i, s)); }\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\t\tif (a1 < n - 1 && dp[a1 + 1][a2] > dp[a1][a2] + 1) { dp[a1 + 1][a2] = dp[a1][a2] + 1; Q.push(make_pair(a1 + 1, a2)); }\n\t\t\tif (a1 >= 1 && dp[a1 - 1][a2] > dp[a1][a2] + 1) { dp[a1 - 1][a2] = dp[a1][a2] + 1; Q.push(make_pair(a1 - 1, a2)); }\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint bit[20]; for (int j = 0; j < n; j++)bit[j] = (a2 / (1 << j)) % 2;\n\t\t\t\tswap(bit[i], bit[a1]); int cost = abs(i - a1);\n\t\t\t\tint ret = 0; for (int j = 0; j < n; j++)ret += (1 << j)*bit[j];\n\t\t\t\tif (dp[i][ret] > dp[a1][a2] + cost) { dp[i][ret] = dp[a1][a2] + cost; Q.push(make_pair(i, ret)); }\n\t\t\t}\n\t\t}\n\t\tint minx = 999999999; for (int i = 0; i < n; i++)minx = min(minx, dp[i][t]);\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint Levenstein(string a,string b){\n  int dp[a.size()+1][b.size()+1];\n  \n  for(int i=0;i<=a.size();i++)dp[i][0]=i;\n  for(int i=0;i<=b.size();i++)dp[0][i]=i;\n \n  for(int i=1;i<=a.size();i++){\n    for(int j=1;j<=b.size();j++){\n      int cost=(a[i-1]==b[j-1])?0:1;\n      dp[i][j]=min(dp[i-1][j]+1,min(dp[i][j-1]+1,dp[i-1][j-1]+cost));\n    }\n  }\n  return dp[a.size()][b.size()];\n}\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n\tfor(int j=0;j<n;j++){\n\t  if(abs(j-i)>abs(k-j))continue;\n\t  if(s[j]!=t[k] && s[k]!=t[j])continue;\n\t  for(int S=0;S<(1<<n);S++){\n\t    if((S>>j&1) || (S>>k&1))continue;\n\t    int next=S;\n\t    if(t[j]==s[k])next|=(1<<j);\n\t    if(t[k]==s[j])next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nunsigned char dp[65536][16];\nstruct st{\n\tshort haichi;\n\tunsigned char pos;\n};\nqueue<st> P;\nint main() {\n\tint n;\n\twhile (cin >> n,n){\n\t\tstring s, ans_s;\n\t\tcin >> s;\n\t\tcin >> ans_s;\n\t\tshort sh=0;\n\t\tshort ans_sh=0;\n\t\tREP(i, n){\n\t\t\tsh <<= 1;\n\t\t\tans_sh <<= 1;\n\t\t\tif (s[i] == 'W')\n\t\t\t\tsh |= 1;\n\t\t\tif (ans_s[i] == 'W')\n\t\t\t\tans_sh |= 1;\n\t\t}\n\t\tREP(i, 65536 * 16)\n\t\t\tdp[i / 16][i % 16] = 255;\n\t\t\n\t\tREP(i, n){\n\t\t\tP.push({ sh, (unsigned char)i });\n\t\t\tdp[sh][i] = 0;\n\t\t}\n\t\n\t\twhile (!P.empty()){\n\t\t\tst p = P.front(); P.pop();\n\t\t\tshort diff=p.haichi^ans_sh;\n\t\t\tvector<unsigned char> db;\n\t\t\tvector<unsigned char> dw;\n\t\t\tREP (i,n){\n\t\t\t\tif ((diff >> i) & 1)\n\t\t\t\t\tif (!((p.haichi >> i) & 1))\n\t\t\t\t\t\tdb.push_back(i);\n\t\t\t\t\telse\n\t\t\t\t\t\tdw.push_back(i);\n\t\t\t}\n\t\t\tREP(i, db.size()){\n\t\t\t\tREP(j,dw.size()){\n\t\t\t\t\tshort change = (1 << db[i]) + (1 << dw[j]);\n\t\t\t\t\tchange ^= p.haichi;\n\t\t\t\t\tif (dp[change][db[i]]>dp[p.haichi][p.pos]+abs(p.pos - dw[j]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][db[i]] = dp[p.haichi][p.pos] + abs(p.pos - dw[j]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, db[i] });\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[change][dw[j]]>dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][dw[j]] = dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, dw[j] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_ans=255;\n\t\tREP(i,n){\n\t\t\tmin_ans = min((int)dp[ans_sh][i],min_ans);\n\t\t}\n\t\tcout << min_ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n \ntypedef pair<int, int> paii;\ntypedef long long ll;\n\ntypedef\tpair<int, paii> tupl;\n\nint n;\nstring a, b;\nint vtx[18][66000];\n\nint solve(){\n\t\n\tint x = 0, y = 0, res = 100000;\n\n\tfor(int i = 0; i < n; i++){\n\t\tx = x<<1; \n\t\ty = y<<1;\n\t\tx += (a[i]=='W'?0:1);\n\t\ty += (b[i]=='W'?0:1);\n\t}\n\t\n\tfor(int k = 0; k < n; ++k){\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < 66000; ++j)\n\t\t\t\tvtx[i][j] = (j!=x?100000:0);\n\t\t\n\t\tpriority_queue<tupl, vector<tupl>, greater<tupl> > qu;\n\t\tqu.push(make_pair(0, make_pair(k, x)));\n\t\tvtx[k][x] = 0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t\n\t\t\tint m = qu.top().second.first;\n\t\t\tint w = qu.top().second.second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\n\t\t\t\t\tif( i!=j && ((w>>i&1) != (w>>j&1))\n\t\t\t\t\t\t\t&& ((w>>i&1) != (y>>i&1)) && ((w>>j&1) != (y>>j&1)) ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tint z = w^( (1<<i)|(1<<j) );\n\t\t\t\t\t\tint dsta = abs(j-m)+abs(i-j);\n\t\t\t\t\t\t//int dstb = abs(i-m)+abs(j-i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( vtx[i][z] > vtx[m][w] + dsta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[i][z] = vtx[m][w] + dsta;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[i][z], make_pair(i, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif( vtx[j][z] > vtx[m][w] + dstb){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[j][z] = vtx[m][w] + dstb;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[j][z], make_pair(j, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tres = min(res, vtx[i][y]);\n\t\t}\n\t\t\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> n, n){\n\t\n\t\tcin >> a;\n\t\tcin >> b;\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n \ntypedef pair<int, int> paii;\ntypedef long long ll;\n\ntypedef\tpair<int, paii> tupl;\n\nint n;\nstring a, b;\nint vtx[18][66000];\n\nint solve(){\n\t\n\tint x = 0, y = 0, res = 100000;\n\n\tfor(int i = 0; i < n; i++){\n\t\tx = x<<1; \n\t\ty = y<<1;\n\t\tx += (a[i]=='W'?0:1);\n\t\ty += (b[i]=='W'?0:1);\n\t}\n\t\n\tfor(int k = 0; k < n; ++k){\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < 66000; ++j)\n\t\t\t\tvtx[i][j] = (j!=x?100000:0);\n\t\t\n\t\tpriority_queue<tupl, vector<tupl>, greater<tupl> > qu;\n\t\tqu.push(make_pair(0, make_pair(k, x)));\n\t\tvtx[k][x] = 0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t\n\t\t\tint m = qu.top().second.first;\n\t\t\tint w = qu.top().second.second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\n\t\t\t\t\tif( i!=j && ((w & 1<<i) != (w & 1<<j))\n\t\t\t\t\t\t\t&& ((w & 1<<i) != (y & 1<<i)) && ((w & 1<<j) != (y & 1<<j)) ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tint z = w^( (1<<i)|(1<<j) );\n\t\t\t\t\t\tint dsta = abs(j-m)+abs(i-j);\n\t\t\t\t\t\tint dstb = abs(i-m)+abs(j-i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( vtx[i][z] > vtx[m][w] + dsta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[i][z] = vtx[m][w] + dsta;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[i][z], make_pair(i, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( vtx[j][z] > vtx[m][w] + dstb){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[j][z] = vtx[m][w] + dstb;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[j][z], make_pair(j, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tres = min(res, vtx[i][y]);\n\t\t}\n\t\t\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> n, n){\n\t\n\t\tcin >> a;\n\t\tcin >> b;\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nunsigned char dp[65536][16];\nstruct st{\n\tshort haichi;\n\tunsigned char pos;\n};\nqueue<st> P;\nint main() {\n\tint n;\n\twhile (cin >> n,n){\n\t\tstring s, ans_s;\n\t\tcin >> s;\n\t\tcin >> ans_s;\n\t\tshort sh=0;\n\t\tshort ans_sh=0;\n\t\tREP(i, n){\n\t\t\tsh <<= 1;\n\t\t\tans_sh <<= 1;\n\t\t\tif (s[i] == 'W')\n\t\t\t\tsh |= 1;\n\t\t\tif (ans_s[i] == 'W')\n\t\t\t\tans_sh |= 1;\n\t\t}\n\t\tREP(i, 65536 * 16)\n\t\t\tdp[i / 16][i % 16] = 255;\n\t\t\n\t\tREP(i, n){\n\t\t\tP.push({ sh, i });\n\t\t\tdp[sh][i] = 0;\n\t\t}\n\t\n\t\twhile (!P.empty()){\n\t\t\tst p = P.front(); P.pop();\n\t\t\tshort diff=p.haichi^ans_sh;\n\t\t\tvector<int> db;\n\t\t\tvector<int> dw;\n\t\t\tREP (i,n){\n\t\t\t\tif ((diff >> i) & 1)\n\t\t\t\t\tif (!((p.haichi >> i) & 1))\n\t\t\t\t\t\tdb.push_back(i);\n\t\t\t\t\telse\n\t\t\t\t\t\tdw.push_back(i);\n\t\t\t}\n\t\t\tREP(i, db.size()){\n\t\t\t\tREP(j,dw.size()){\n\t\t\t\t\tshort change = (1 << db[i]) + (1 << dw[j]);\n\t\t\t\t\tchange ^= p.haichi;\n\t\t\t\t\tif (dp[change][db[i]]>dp[p.haichi][p.pos]+abs(p.pos - dw[j]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][db[i]] = dp[p.haichi][p.pos] + abs(p.pos - dw[j]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, db[i] });\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[change][dw[j]]>dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j])){\n\t\t\t\t\t\tdp[change][dw[j]] = dp[p.haichi][p.pos] + abs(p.pos - db[i]) + abs(db[i] - dw[j]);\n\t\t\t\t\t\tP.push({ change, dw[j] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_ans=255;\n\t\tREP(i,n){\n\t\t\tmin_ans = min((int)dp[ans_sh][i],min_ans);\n\t\t}\n\t\tcout << min_ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t    int next=S;\n\t    next|=(1<<j);\n\t    next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nconst int LMAX=2010;\nint f(string s){\n\tint a=0;\n\trep(i,s.size()){\n\t\ta*=2;\n\t\ta+=(s[i]=='B'?1:0);\n\t}\n\treturn a;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s,t;\n\t\tcin>>s>>t;\n\t\tint a=f(s),b=f(t);\n\t\tint N=1<<n;\n\t\tvvi dp(n,vi(N,inf));\n\t\trep(i,n)if((a&1<<i)^(b&1<<i))dp[i][N-(a^b)-1]=0;\n\t\trep(i,n)loop(j,N-(a^b)-1,N)if(dp[i][j]!=inf){\n\t\t\trep(k,n)if(i!=k){\n\t\t\t\tbool q=(a&1<<i),w=(a&1<<k);\n\t\t\t\tif(q+w==1){\n\t\t\t\t\tint J=j|1<<i;\n\t\t\t\t\tJ|=1<<k;\n\t\t\t\t\trep(l,n)\n\t\t\t\t\t\tdp[l][J]=min(dp[l][J],dp[i][j]+abs(i-k)+abs(l-k));\n\t\t\t\t\t\n//\t\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<J<<\" \"<<k<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,n)out=min(out,dp[i][N-1]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1<<16][16];\nint main() {\n  int n;\n  while(cin >> n && n) {\n    string s,s2;\n    cin >> s >> s2;\n    int r=0;\n    for(int t=0;t<(1<<n);t++)for(int i=0;i<n;i++)dp[t][i]=1<<29;\n    for(int i=0;i<n;i++)if(s[i]==s2[i]) r|=1<<i;\n    for(int i=0;i<n;i++)dp[r][i]=0;\n    for(int t=0;t<(1<<n);t++) {\n      for(int i=0;i<n;i++) {\n        if(dp[t][i]==1<<29) continue;\n        string e=\"\";\n        for(int j=0; j<n;j++) {\n          if(t&(1<<j)) e+='1';\n          else e+='0';\n        }\n        for(int j=0;j<n;j++) {\n          if(t&(1<<j)) continue;\n          for(int k=j+1;k<n;k++) {\n            if(t&(1<<k)||s[j]==s[k]) continue;\n            dp[t|(1<<j)|(1<<k)][j]=min(dp[t|(1<<j)|(1<<k)][j],dp[t][i]+abs(i-k)+abs(k-j));\n            dp[t|(1<<j)|(1<<k)][k]=min(dp[t|(1<<j)|(1<<k)][k],dp[t][i]+abs(i-j)+abs(j-k));\n          }\n        }\n      }\n    }\n    int ans=1<<29;\n    for(int i=0;i<n;i++)ans=min(ans,dp[(1<<n)-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<16> initial, final;\n        for(int i=0; i<n; ++i){\n            char c;\n            cin >> c;\n            initial[i] = (c == 'B');\n        }\n        for(int i=0; i<n; ++i){\n            char c;\n            cin >> c;\n            final[i] = (c == 'B');\n        }\n\n        vector<vector<int> > memo(1<<n, vector<int>(n, INF));\n        multimap<int, pair<bitset<16>, int> > mm;\n        for(int i=0; i<n; ++i){\n            memo[initial.to_ulong()][i] = 0;\n            mm.insert(make_pair(0, make_pair(initial, i)));\n        }\n\n        for(;;){\n            int cost = mm.begin()->first;\n            bitset<16> bs = mm.begin()->second.first;\n            int pos = mm.begin()->second.second;\n            mm.erase(mm.begin());\n            if(cost > memo[bs.to_ulong()][pos])\n                continue;\n\n            if(bs == final){\n                cout << cost << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                if(!(bs[i] ^ final[i]))\n                    continue;\n                for(int j=0; j<n; ++j){\n                    if(!(bs[j] ^ final[j]))\n                        continue;\n                    if(!(bs[i] ^ bs[j]))\n                        continue;\n\n                    int cost2 = cost + abs(pos - i) + abs(i - j);\n                    bitset<16> bs2 = bs;\n                    bs2[i] = !bs2[i];\n                    bs2[j] = !bs2[j];\n                    if(cost2 < memo[bs2.to_ulong()][j]){\n                        memo[bs2.to_ulong()][j] = cost2;\n                        mm.insert(make_pair(cost2, make_pair(bs2, j)));\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 17;\nconst int INF = 1<<28;\nint N;\nint start, finish;\nint dp[1<<MAXN][MAXN];\n \nint rec(int b, int p, int d) {\n  int &res = dp[b][p];\n  if(res != -1) return res;\n  if(b == finish) return res = 0;\n  res = INF;\n  if(d == MAXN*MAXN) return res;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(i == j) continue;\n      if(((b>>i)&1)^((b>>j)&1)) ; else continue;\n      int nb = b;\n      nb ^= 1<<i;\n      nb ^= 1<<j;\n      int addcost;\n      if(p == N) addcost = abs(j-i);\n      else addcost = abs(i-p) + abs(j-i);\n      res = min(res, rec(nb, j, d+1) + addcost);\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    string a, b;\n    cin >> a >> b;\n    start = finish = 0;\n    for(int i = 0; i < N; ++i) {\n      if(a[i] == 'W') start |= 1<<i;\n      if(b[i] == 'W') finish |= 1<<i;\n    }\n    int res = INF;\n    fill(dp[0], dp[1<<MAXN], -1);\n    res = rec(start, N, 0);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[2][16][1<<16];\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pipii;\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\nint d[16][1<<16];\nint bfs(){\n    priority_queue<Sit> que;\n    for(int j=0;j<16;j++)for(int k=0;k<(1<<16);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        Sit sit;\n        sit.cost=0;sit.pos=i;sit.mask=s;\n        que.push(sit);\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        int cpos=s.pos;\n        int ccost=s.cost;\n        int cmask=s.mask;\n        if(d[cpos][cmask]<ccost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-cpos)+abs(j-i);\n                int to=j;\n                int nmask=cmask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>to)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,to,a);\n                if(d[to][nmask]>d[cpos][cmask]+cost){\n                    d[to][nmask]=d[cpos][cmask]+cost;\n                    Sit sit;\n                    sit.cost=d[to][nmask];\n                    sit.pos=to;\n                    sit.mask=nmask;\n                    que.push(sit);\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<16;i++)res=min(res,d[i][t]);\n    return res;\n}\n\nint solve(){\n    return bfs();\n    //for(int tern=n;tern>=0;tern--){\n    //    int nxt=tern%2;\n    //    int cur=(tern+1)%2;\n    //    for(int pos=0;pos<n;pos++){\n    //        for(int sit=0;sit<(1<<n);sit++){\n    //            int res=INF;\n    //            if(tern==n){\n    //                if(sit==t)res=0;\n    //            }\n    //            else{\n    //                for(int to=0;to<n;to++){\n    //                    // ®©·¾¯\n    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n    //                    // trade\n    //                    int cost=abs(to-pos);\n    //                    int nsit=sit;\n    //                    int a=(sit>>pos)&1;\n    //                    int b=(sit>>to)&1;\n    //                    setBit(nsit,pos,b);\n    //                    setBit(nsit,to,a);\n    //                    res=min(res,dp[cur][to][nsit]+cost);\n    //                }\n    //            }\n    //            dp[nxt][pos][sit]=res;\n    //        }\n    //    }\n    //}\n    //int res=INF;\n    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    //return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n\tbitset<16>bs;\n\tint cost;\n\tint now;\n};\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.cost>r.cost;\n\t}\n};\n\nint main() {\n\twhile (true) {\n\t\tint N;cin>>N;\n\t\tif(!N)break;\n\t\tstring a,b;cin>>a>>b;\n\t\tbitset<16>start,goal;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif(a[i]=='B')start[i]=true;\n\t\t\tif(b[i]=='B')goal[i]=true;\n\t\t}\n\t\tvector<vector<int>>memo((1<<N),vector<int>(N,1e9));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmemo[start.to_ulong()][i]=0;\n\t\t}\n\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tque.push(aa{ start,0,i });\n\t\t}\n\n\t\tint ans=1e9;\n\t\twhile (!que.empty()) {\n\t\t\tauto atop(que.top());\n\t\t\tque.pop();\n\n\t\t\tbitset<16>bs(atop.bs);\n\t\t\tconst int cost(atop.cost);\n\t\t\tconst int now(atop.now);\n\t\t\tif (bs == goal) {\n\t\t\t\tans=min(ans,cost);\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint u=bs[now];\n\t\t\t\tbs[now]=bs[i];\n\t\t\t\tbs[i]=u;\n\t\t\t\tconst int next_cost=cost+(abs(now-i));\n\t\t\t\tif (memo[bs.to_ulong()][i] > next_cost) {\n\t\t\t\t\tmemo[bs.to_ulong()][i]=next_cost;\n\t\t\t\t\tque.push(aa{ bs,next_cost,i });\n\t\t\t\t}\n\t\t\t\tu = bs[now];\n\t\t\t\tbs[now] = bs[i];\n\t\t\t\tbs[i] = u;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tconst int next_cost = cost + (abs(now - i));\n\t\t\t\tif (memo[bs.to_ulong()][i] > next_cost) {\n\t\t\t\t\tmemo[bs.to_ulong()][i] = next_cost;\n\t\t\t\t\tque.push(aa{ bs,next_cost,i });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[2][16][1<<16];\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nint solve(){\n    for(int tern=n/2;tern>=0;tern--){\n        int nxt=tern%2;\n        int cur=(tern+1)%2;\n        for(int pos=0;pos<n;pos++){\n            for(int sit=0;sit<(1<<n);sit++){\n                int res=INF;\n                if(tern==n/2){\n                    if(sit==t)res=0;\n                }\n                else{\n                    for(int to=0;to<n;to++){\n                        int cost=abs(to-pos);\n                        int nsit=sit;\n                        int a=(sit>>pos)&1;\n                        int b=(sit>>to)&1;\n                        setBit(nsit,pos,b);\n                        setBit(nsit,to,a);\n                        res=min(res,dp[cur][to][nsit]+cost);\n                    }\n                }\n                dp[nxt][pos][sit]=res;\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\n#include <map>\nusing namespace std;\n\n\nconst int INF = 1<<24;\n// B:0, W:1\nint N, T;\n//bool vis[16][16][1<<16];\n\nint swapS(int S, int i, int j) {\n  int fi, fj, nS;\n  fi = S & (1<<i);\n  fj = S & (1<<j);\n  if(fi == T & (1<<i)) return -1;\n  if(fj == T & (1<<j)) return -1;\n  nS = S;\n  nS &= ~(1<<i);\n  nS &= ~(1<<j);\n  if(fi) nS |= (1<<j);\n  if(fj) nS |= (1<<i);\n  return nS;\n}\n\nint cost[16][16][1<<16];\n\nint solve(int p, int S) {\n  for(int i = 0; i < N; ++i) \n    for(int j = 0; j < N; ++j)\n      for(int k = 0; k < (1<<N); ++k)\n\tcost[i][j][k] = -1;\n\n  cost[p][p][S] = 0;\n  queue<pair<pair<int, int>, int> >que;//pos,mark,bit\n  que.push(make_pair(make_pair(p, p), S));\n  int res = INF;\n\n  while(!que.empty()) {\n    p = que.front().first.first;\n    int m = que.front().first.second;\n    S = que.front().second;\n    que.pop();\n    if(S == T) {\n      res = min(res, cost[p][m][S]);\n      continue;\n    }\n    int ncost =  cost[p][m][S] + 1;\n    for(int i = -1; i <= 1; i += 2) {\n      int np = p + i;\n      if(np < 0 || np >= N) continue;\n      if(cost[np][m][S] == -1) {\n\tcost[np][m][S] = ncost;\n\tque.push(make_pair(make_pair(np,m),S)); \n      }\n      if(cost[np][np][S] == -1) {\n\tcost[np][np][S] = ncost;\n\tque.push(make_pair(make_pair(np,np),S));\n      }\n      int nS = swapS(S, m, np);\n      if(nS == -1) continue;\n      if(cost[np][np][nS] == -1) {\n\tcost[np][np][nS] = ncost;\n\tque.push(make_pair(make_pair(np,np),nS));\n      }\n    }\n  }\n  return res;\n}\n/*\nint rec(int p, int S, int cost {\n  if(S == T) return 0;\n  int res = INF;\n  for(int i = 0; i < N; ++i) {\n    int fi = S & (1<<i);\n    if(fi == T & (1<<i)) continue;\n    for(int j = i+1; j < N; ++j) {\n      int fj = S & (1<<j);\n      if(fj == T & (1<<j)) continue;\n      \n      int nS = S;\n      nS &= ~(1<<i);\n      nS &= ~(1<<j);\n      if(fi) nS |= (1<<j);\n      if(fj) nS |= (1<<i);\n      if(dp[j][nS] == -1) res = min(res, rec(j, nS) + abs(i-p) + abs(j-i));\n      if(dp[i][nS] == -1) res = min(res, rec(i, nS) + abs(j-p) + abs(i-j));\n    }\n  }\n  return res;\n  }*/\n\nint main() {\n  while((cin >> N) && N) {\n    char c;\n    int S;\n    S = T = 0;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tcin >> c;\n\tif(c == 'W') {\n\t  if(k == 0) S |= (1<<i);\n\t  else       T |= (1<<i);\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i < N; ++i) {\n      ans = min(ans, solve(i, S));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nconst int MAX_N = 16;\nconst int INF = 1e8;\n\nint dp[MAX_N][(1 << MAX_N)];\nbool vis[MAX_N][(1 << MAX_N)];\n\nint N;\nint B[2];\n\n\nvoid show(int num){\n  int a[N];\n  for(int i = 0 ; i < N ; i++)a[i] = ((num >> i)&1);\n  for(int i = 0 ; i < N ; i++)cout << a[i];\n  cout << endl;\n}\n\nint dfs(int j,int i){\n  int& ret = dp[j][i];\n  if(ret != INF)return ret;\n\n  if(i == B[1]){\n    return ret = 0;\n  }\n\n  if(vis[j][i])return INF;\n  vis[j][i] = true;\n  \n  for(int k = 0 ; k < N ; k++){\n    for(int l = 0 ; l < N; l++){\n      if(((i >> k)&1) == ((i >> l)&1))continue;\n      int bit = i;\n      bit &= (~(1 << k));\n      bit &= (~(1 << l));\n      if(((i >> k)&1) == 0)bit |= (1 << k);\n      if(((i >> l)&1) == 0)bit |= (1 << l);\n      ret = min(ret,dfs(l,bit) + abs(k - j) + abs(k - l));\n    }\n  }\n  vis[j][i] = false;\n  return ret;\n}\n\n\nint main(){\n\n  while(cin >> N,N){\n    for(int i = 0 ; i < N ; i++){      \n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = INF;\t\n\tvis[i][j] = false;\n      }\n    }\n\t    \n    for(int i = 0 ; i < 2 ; i++){\n      B[i] = 0;\n      for(int j = 0 ; j < N ; j++){\n\tchar c; cin >> c;\n\tif(c == 'B')B[i] |= (1 << j);\n      }\n    }\n    int res = INF;\n    for(int i = 0 ; i < N ; i++){\n      res = min(res,dfs(i,B[0]));\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[2][16][1<<16];\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pipii;\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\nint d[16][1<<16];\nint bfs(){\n    priority_queue<Sit> que;\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        Sit sit;\n        sit.cost=0;sit.pos=i;sit.mask=s;\n        que.push(sit);\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        int cpos=s.pos;\n        int ccost=s.cost;\n        int cmask=s.mask;\n        if(d[cpos][cmask]<ccost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-cpos)+abs(j-i);\n                int to=j;\n                int nmask=cmask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>to)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,to,a);\n                if(d[to][nmask]>d[cpos][cmask]+cost){\n                    d[to][nmask]=d[cpos][cmask]+cost;\n                    Sit sit;\n                    sit.cost=d[to][nmask];\n                    sit.pos=to;\n                    sit.mask=nmask;\n                    que.push(sit);\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<16;i++)res=min(res,d[i][t]);\n    return res;\n}\n\nint solve(){\n    return bfs();\n    //for(int tern=n;tern>=0;tern--){\n    //    int nxt=tern%2;\n    //    int cur=(tern+1)%2;\n    //    for(int pos=0;pos<n;pos++){\n    //        for(int sit=0;sit<(1<<n);sit++){\n    //            int res=INF;\n    //            if(tern==n){\n    //                if(sit==t)res=0;\n    //            }\n    //            else{\n    //                for(int to=0;to<n;to++){\n    //                    // ®©·¾¯\n    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n    //                    // trade\n    //                    int cost=abs(to-pos);\n    //                    int nsit=sit;\n    //                    int a=(sit>>pos)&1;\n    //                    int b=(sit>>to)&1;\n    //                    setBit(nsit,pos,b);\n    //                    setBit(nsit,to,a);\n    //                    res=min(res,dp[cur][to][nsit]+cost);\n    //                }\n    //            }\n    //            dp[nxt][pos][sit]=res;\n    //        }\n    //    }\n    //}\n    //int res=INF;\n    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    //return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<set>\nusing namespace std;\n\nclass State{\n    public:\n    int n, cur, pre;\n    string str;\n    State(int cur=0, int pre=0, string str=\"\"):n(n), cur(cur), pre(pre), str(str){\n\tn = str.size();\n    }\n\n    void swap(){\n\tchar ch = str[cur]; str[cur] = str[pre]; str[pre] = ch;\n    }\n\n    bool operator < ( const State &s) const{\n\tif ( cur != s.cur ) return cur < s.cur;\n\tif ( pre != s.pre ) return pre < s.pre;\n\treturn str < s.str;\n    }\n};\n\nclass QState{\n    public:\n    int cost;\n    State state;\n    QState(){}\n    QState(State s, int c):state(s), cost(c){}\n    bool operator < ( const QState &q ) const{ return cost > q.cost; }\n};\n\nint dist(int i, int j){\n    return max(i, j) - min(i, j);\n}\n\nint dijkstra(int n, string start, string goal){\n    priority_queue<QState> PQ;\n    set<State> visited;\n    for ( int i = 0; i < n; i++ ){\n\tfor ( int j = i; j < n; j++ ){\n\t    State s = State(i, j, start);\n\t    s.swap();\n\t    PQ.push(QState(s, dist(i, j)));\n\t}\n    }\n\n    QState u;\n    while( !PQ.empty() ){\n\tu = PQ.top(); PQ.pop();\n\tif ( u.state.str == goal ) return u.cost;\n\n\tfor ( int i = 0; i < n; i++ ){\n\t    if ( u.state.cur == i ) continue;\n\t    State st = u.state;\n\t    st.pre = st.cur;\n\t    st.cur = i;\n\t    st.swap();\n\t    if ( visited.insert(st).second ){\n\t\tPQ.push(QState(st, u.cost + dist(st.cur, st.pre)) );\n\t    }\t\t\n\t}\n    }\n}\n\nmain(){\n    int n;\n    string s, g;\n    while( cin >> n && n ){\n\tcin >> s >> g;\n\tcout << dijkstra(n, s, g) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nstruct P {\n    int cost, pos, panels;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint G[1<<16][16][16];\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        fill_n((bool *)G, (1<<16) * 16 * 16, false);\n\n        int panels[2] = {0}; // start, goal\n        REP(i, 2) {\n           string line;\n           cin >> line;\n           REP(j, n) {\n               panels[i] = (panels[i] << 1) | (line[j] == 'B' ? 1 : 0);\n           }\n        }\n\n        priority_queue<P, vector<P>, greater<P>> que;\n\n        REP(i, n) {\n            // ?§????????????????????????????????????????????§?\n            if (((panels[0]>>i) & 1) != ((panels[1]>>i) & 1)) {\n                que.push({0, i, panels[0]});\n            }\n        }\n\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.panels == panels[1]) {\n                cout << p.cost << endl;\n                break;\n            }\n\n//            LOG(\"--> %d\\n\", p.cost);\n//            LOG(\"--> [%d]\\n\", p.pos);\n//            REP(i, n) {\n//                LOG(\"%c\", (p.panels>>(n-i-1)) & 1 ? 'B' : 'W');\n//            }\n//            LOG(\"\\n\");\n\n//            LOG(\"next: %c\\n\", (p.panels>>p.pos) & 1 ? 'B' : 'W');\n\n            REP(i, n) {\n                if (p.pos == i) continue;\n                // ?§?????????????????????????????????? &&\n                // ?§????????????????????????°?????£?????????\n                int to = (p.panels>>i) & 1;\n//                LOG(\"to: %c\\n\", (p.panels>>i) & 1 ? 'B' : 'W');\n                if (to != ((panels[1]>>i) & 1)) {\n//                if (to != ((panels[1]>>i) & 1) && ((p.panels>>p.pos) & 1) != to) {\n                    int pa = p.panels;\n                    if (to) {\n                        pa &= ~(1<<i);\n                        pa |= 1<<p.pos;\n                    } else {\n                        pa &= ~(1<<p.pos);\n                        pa |= 1<<i;\n                    }\n                    if (!G[pa][p.pos][i]) {\n//                        LOG(\"-------------->\\n\");\n//                        LOG(\"     \");\n//                        REP(i, n) {\n//                            LOG(\"%c\", (pa>>(n-i-1)) & 1 ? 'B' : 'W');\n//                        }\n//                        LOG(\"\\n\");\n                        G[pa][p.pos][i] = true;\n                        que.push({p.cost + abs(p.pos - i), i, pa});\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(!(tmp>>i&1)){\n\t  for(int k=0;k<n;k++){\n\t    for(int j=0;j<n;j++){\n\t      if(s[j]!=s[k]){\n\t\tfor(int S=0;S<(1<<n);S++){\n\t\t  if((S>>j&1) || (S>>k&1))continue;\n\t\t  int next=S;\n\t\t  next|=(1<<j)|(1<<k);\n\t\t  dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n    \n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(tmp>>i&1)continue;\n\tfor(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t      int next=S;\n\t      next|=(1<<j);\n\t      next|=(1<<k);\n\t      dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    if(ans>=INF)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n \ntypedef pair<int, int> paii;\ntypedef long long ll;\n\ntypedef\tpair<int, paii> tupl;\n\nint n;\nstring a, b;\nint vtx[18][66000];\n\nint solve(){\n\t\n\tint x = 0, y = 0, res = 100000;\n\n\tfor(int i = 0; i < n; i++){\n\t\tx = x<<1; \n\t\ty = y<<1;\n\t\tx += (a[i]=='W'?0:1);\n\t\ty += (b[i]=='W'?0:1);\n\t}\n\t\n\tfor(int k = 0; k < n; ++k){\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < 66000; ++j)\n\t\t\t\tvtx[i][j] = (j!=x?100000:0);\n\t\t\n\t\tpriority_queue<tupl, vector<tupl>, greater<tupl> > qu;\n\t\tqu.push(make_pair(0, make_pair(k, x)));\n\t\tvtx[k][x] = 0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t\n\t\t\tint m = qu.top().second.first;\n\t\t\tint w = qu.top().second.second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = i; j < n; ++j){\n\t\t\t\t\n\t\t\t\t\tif( i!=j && ((w & 1<<i) != (w & 1<<j))\n\t\t\t\t\t\t\t&& ((w & 1<<i) != (y & 1<<i)) && ((w & 1<<j) != (y & 1<<j)) ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tint z = w^( (1<<i)|(1<<j) );\n\t\t\t\t\t\tint dsta = abs(j-m)+abs(i-j);\n\t\t\t\t\t\t//int dstb = abs(i-m)+abs(j-i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( vtx[i][z] > vtx[m][w] + dsta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[i][z] = vtx[m][w] + dsta;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[i][z], make_pair(i, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif( vtx[j][z] > vtx[m][w] + dstb){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvtx[j][z] = vtx[m][w] + dstb;\n\t\t\t\t\t\t\tqu.push(make_pair(vtx[j][z], make_pair(j, z)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tres = min(res, vtx[i][y]);\n\t\t}\n\t\t\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> n, n){\n\t\n\t\tcin >> a;\n\t\tcin >> b;\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 17;\nconst int INF = 1<<28;\nint N;\nint start, finish;\nint dp[1<<MAXN][MAXN][2];\n \nint rec(int b, int p, bool first, int d) {\n  int &res = dp[b][p][first];\n  if(res != -1) return res;\n  if(b == finish) return res = 0;\n  res = INF;\n  if(d == 50) return res;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(i == j) continue;\n      if(((b>>i)&1)^((b>>j)&1)) ; else continue;\n      int nb = b;\n      nb ^= 1<<i;\n      nb ^= 1<<j;\n      int addcost;\n      if(first) addcost = abs(j-i);\n      else addcost = abs(i-p) + abs(j-i);\n      res = min(res, rec(nb, j, false, d+1) + addcost);\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    string a, b;\n    cin >> a >> b;\n    start = finish = 0;\n    for(int i = 0; i < N; ++i) {\n      if(a[i] == 'W') start |= 1<<i;\n      if(b[i] == 'W') finish |= 1<<i;\n    }\n    int res = INF;\n    fill(dp[0][0], dp[1<<MAXN][0], -1);\n    for(int i = 0; i < N; ++i) {\n      res = min(res, rec(start, i, true, 0));\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    Sit(int cost_,int pos_,int mask_){\n        cost=cost_;\n        pos=pos_;\n        mask=mask_;\n    }\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\n\nint d[16][1<<16];\npriority_queue<Sit> que;\nint bfs(){\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        que.push(Sit(0,i,s));\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        if(d[s.pos][s.mask]<s.cost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                // ·ÅÉèÏÝ\n                if((!(((s.mask>>i)&1)^((t>>i)&1)))||(!(((s.mask>>j)&1)^((t>>j)&1)))){\n                    continue;\n                }\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-s.pos)+abs(j-i);\n                int nmask=s.mask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>j)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,j,a);\n                if(d[j][nmask]>d[s.pos][s.mask]+cost){\n                    d[j][nmask]=d[s.pos][s.mask]+cost;\n                    que.push(Sit(d[j][nmask],j,nmask));\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,d[i][t]);\n    return res;\n}\n//int solve(){\n//    return bfs();\n//    //for(int tern=n;tern>=0;tern--){\n//    //    int nxt=tern%2;\n//    //    int cur=(tern+1)%2;\n//    //    for(int pos=0;pos<n;pos++){\n//    //        for(int sit=0;sit<(1<<n);sit++){\n//    //            int res=INF;\n//    //            if(tern==n){\n//    //                if(sit==t)res=0;\n//    //            }\n//    //            else{\n//    //                for(int to=0;to<n;to++){\n//    //                    // ®©·¾¯\n//    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n//    //                    // trade\n//    //                    int cost=abs(to-pos);\n//    //                    int nsit=sit;\n//    //                    int a=(sit>>pos)&1;\n//    //                    int b=(sit>>to)&1;\n//    //                    setBit(nsit,pos,b);\n//    //                    setBit(nsit,to,a);\n//    //                    res=min(res,dp[cur][to][nsit]+cost);\n//    //                }\n//    //            }\n//    //            dp[nxt][pos][sit]=res;\n//    //        }\n//    //    }\n//    //}\n//    //int res=INF;\n//    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n//    //return res;\n//}\nint main(){\n\n    string ss,tt;\n    while(cin>>n&&n){\n        s=t=0;\n        cin>>ss>>tt;\n        for(int i=0;i<n;i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<n;i++)if(tt[i]=='B')t|=(1<<i);\n        printf(\"%d\\n\",bfs());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nstring s, t;\nint mincost[16][1<<16];\nint sbit, tbit;\n\nstruct State {\n  int now, cost, bit;\n  State(){}\n  State(int now, int cost, int bit):now(now), cost(cost), bit(bit){}\n  bool operator < (const State &st) const {\n    return cost > st.cost;\n  }\n};\n\nint dijkstra(int pos) {\n  fill(mincost[0], mincost[16], inf);\n  mincost[pos][sbit] = 0;\n  priority_queue<State> que;\n  que.emplace(pos, 0, sbit);\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, cost = st.cost, bit = st.bit;\n    //cout << now << \" \"<< cost << endl;\n    //rep(i, N) cout << (int)((bit>>i)&1);\n    //cout << endl;\n    if(bit == tbit) return cost;\n    if(mincost[now][bit] < cost) continue;\n    rep(i, N) if(i != now) {\n      int ncost = cost + abs(i-now);\n      if(ncost < mincost[i][bit]) {\n\tmincost[i][bit] = ncost;\n\tque.emplace(i, ncost, bit);\n      }\n      if(((bit>>i)&1) == ((bit>>now)&1)) continue;\n      int nbit = bit^(1<<i)^(1<<now);\n      //rep(i, N) cout << (int)((bit>>i)&1);cout<<endl;\n      //cout<<now<<\" \"<<i<<endl;\n      //cout << (int)((bit>>i)&1) << \" \"<<(int)((bit>>now)&1) << endl;\n      //cout<<(int)(((bit>>i)&1) == ((bit>>now)&1)) << endl;\n      //rep(i, N) cout << (int)((nbit>>i)&1);cout<<endl;\n      //assert(__builtin_popcount(nbit) == __builtin_popcount(bit));\n      if(ncost < mincost[i][nbit]) {\n\tmincost[i][nbit] = ncost;\n\tque.emplace(i, ncost, nbit);\n      }\n    }\n  }\n  return inf;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    cin >> s >> t;\n    sbit = tbit = 0;\n    rep(i, N) if(s[i] == 'B') sbit |= 1<<i;\n    rep(i, N) if(t[i] == 'B') tbit |= 1<<i;\n    int ans = inf;\n    rep(i, N) {\n      chmin(ans, dijkstra(i));\n      //cout<<ans<<endl;//exit(0);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring s, g;\nint dp[1<<16][16];\nint dfs(int S, int u){\n  if(S == (1<<N) - 1) return 0;\n  if(dp[S][u] != -1) return dp[S][u];\n  int res = INF;\n  REP(i, N)REP(j, N) if(i != j && (S >> i & 1) == 0 && (S >> j & 1) == 0 && g[i] != g[j]){\n    res = min(res, abs(u - i) + abs(i - j) + dfs(S | 1 << i | 1 << j, j));\n  }\n  return dp[S][u] = res;\n}\nint main(){\n  while(cin>>N && N){\n    cin>>s>>g;\n    REP(S, 1<<N) REP(p, N) dp[S][p] = -1;\n    int S = 0;\n    REP(i, N) if(s[i] == g[i]) S |= 1<<i;\n    int ans = INF;\n    REP(i, N) ans = min(ans, dfs(S, i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nstring s, t;\nint mincost[16][1<<16];\nint sbit, tbit;\n\nstruct State {\n  int now, cost, bit;\n  State(){}\n  State(int now, int cost, int bit):now(now), cost(cost), bit(bit){}\n  bool operator < (const State &st) const {\n    return cost > st.cost;\n  }\n};\n\nint dijkstra(int pos) {\n  fill(mincost[0], mincost[16], inf);\n  mincost[pos][sbit] = 0;\n  priority_queue<State> que;\n  que.emplace(pos, 0, sbit);\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, cost = st.cost, bit = st.bit;\n    //cout << now << \" \"<< cost << endl;\n    //rep(i, N) cout << (int)((bit>>i)&1);\n    //cout << endl;\n    if(bit == tbit) return cost;\n    if(mincost[now][bit] < cost) continue;\n    rep(i, N) if(i != now) {\n      int ncost = cost + abs(i-now);\n      if(ncost < mincost[i][bit]) {\n\tmincost[i][bit] = ncost;\n\tque.emplace(i, ncost, bit);\n      }\n      if(((bit>>i)&1) == ((bit>>now)&1)) continue;\n      int nbit = bit^(1<<i)^(1<<now);\n      //rep(i, N) cout << (int)((bit>>i)&1);cout<<endl;\n      //cout<<now<<\" \"<<i<<endl;\n      //cout << (int)((bit>>i)&1) << \" \"<<(int)((bit>>now)&1) << endl;\n      //cout<<(int)(((bit>>i)&1) == ((bit>>now)&1)) << endl;\n      //rep(i, N) cout << (int)((nbit>>i)&1);cout<<endl;\n      //assert(__builtin_popcount(nbit) == __builtin_popcount(bit));\n      if(ncost < mincost[i][nbit]) {\n\tmincost[i][nbit] = ncost;\n\tque.emplace(i, ncost, nbit);\n      }\n    }\n  }\n  return inf;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    cin >> s >> t;\n    sbit = tbit = 0;\n    rep(i, N) if(s[i] == 'B') sbit |= 1<<i;\n    rep(i, N) if(t[i] == 'B') tbit |= 1<<i;\n    int ans = inf;\n    rep(i, N) {\n      chmin(ans, dijkstra(i));\n      //cout<<ans<<endl;//exit(0);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\n//int dp[2][16][1<<16];\n//typedef pair<int,int> pii;\n//typedef pair<int,pii> pipii;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    Sit(int cost_,int pos_,int mask_){\n        cost=cost_;\n        pos=pos_;\n        mask=mask_;\n    }\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\n\nint d[16][1<<16];\npriority_queue<Sit> que;\nint bfs(){\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        que.push(Sit(0,i,s));\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        if(d[s.pos][s.mask]<s.cost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-s.pos)+abs(j-i);\n                int nmask=s.mask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>j)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,j,a);\n                if(d[j][nmask]>d[s.pos][s.mask]+cost){\n                    d[j][nmask]=d[s.pos][s.mask]+cost;\n                    que.push(Sit(d[j][nmask],j,nmask));\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,d[i][t]);\n    return res;\n}\n//int solve(){\n//    return bfs();\n//    //for(int tern=n;tern>=0;tern--){\n//    //    int nxt=tern%2;\n//    //    int cur=(tern+1)%2;\n//    //    for(int pos=0;pos<n;pos++){\n//    //        for(int sit=0;sit<(1<<n);sit++){\n//    //            int res=INF;\n//    //            if(tern==n){\n//    //                if(sit==t)res=0;\n//    //            }\n//    //            else{\n//    //                for(int to=0;to<n;to++){\n//    //                    // ®©·¾¯\n//    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n//    //                    // trade\n//    //                    int cost=abs(to-pos);\n//    //                    int nsit=sit;\n//    //                    int a=(sit>>pos)&1;\n//    //                    int b=(sit>>to)&1;\n//    //                    setBit(nsit,pos,b);\n//    //                    setBit(nsit,to,a);\n//    //                    res=min(res,dp[cur][to][nsit]+cost);\n//    //                }\n//    //            }\n//    //            dp[nxt][pos][sit]=res;\n//    //        }\n//    //    }\n//    //}\n//    //int res=INF;\n//    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n//    //return res;\n//}\nint main(){\n\n    string ss,tt;\n    while(cin>>n&&n){\n        s=t=0;\n        cin>>ss>>tt;\n        for(int i=0;i<n;i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<n;i++)if(tt[i]=='B')t|=(1<<i);\n        printf(\"%d\\n\",bfs());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nint main(){\n  int N;\n  while(cin>>N && N){\n    string ss, gs; cin>>ss>>gs;\n    int St = 0, G = 0;\n    REP(i, N){\n      St |= (int)(ss[i] == 'B') << i;\n      G |= (int)(gs[i] == 'B') << i;\n    }\n    priority_queue<S> que;\n    int dist[1<<16][16];\n    REP(i, 1<<N)REP(j, N) dist[i][j] = INF;\n    REP(i, N){\n      dist[St][i] = 0;\n      que.push(S(0, P(St, i)));\n    }\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      int d = s.first * -1;\n      int state = s.second.first;\n      int u = s.second.second;\n      if(state == G){\n        cout<<d<<endl;\n        break;\n      }\n      if(dist[state][u] < d) continue;\n      REP(i, N)REP(j, N)if((state >> i & 1) != (state >> j & 1)){\n        int nst = state ^ (1 << i) ^ (1 << j);\n        if(((nst ^ G) >> i & 1) && (nst ^ G) >> j & 1) continue;\n        int nd = d + abs(i - u) + abs(j - i);\n        int nu = j;\n        if(dist[nst][nu] > nd){\n          dist[nst][nu] = nd;\n          que.push(S(nd * -1, P(nst, nu)));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nint N, endbit, Mask;\nint dp[1 << 16][16];\n\nint rec(int bit, int ptr){\n  if(bit == endbit) return 0;\n  if(~dp[bit][ptr]) return dp[bit][ptr];\n  int ret = INF;\n  for(int i = 0; i < N; i++){\n    if((bit ^ endbit) & (1 << i)){\n      for(int j = i + 1; j < N; j++){\n        if((bit ^ endbit) & (1 << j) && ((bit >> i) ^ (bit >> j)) & 1){\n          int nextbit = bit ^ (1 << i) ^ (1 << j);\n          int cost = abs(ptr - i) + j - i;\n          ret = min( ret, rec( nextbit, j) + cost);\n          cost = abs(ptr - j) + j - i;\n          ret = min( ret, rec( nextbit, i) + cost);\n        }\n      }\n    }\n  }\n  return dp[bit][ptr] = ret;\n}\n\nint main(){\n  int bit;\n  string A, B;\n\n  while(cin >> N, N){\n    cin >> A >> B;\n\n    Mask = (1 << N) - 1;\n    bit = 0, endbit = 0;\n    for(int i = 0; i < A.length(); i++){\n      bit |= (A[i] == 'W') << i;\n      endbit |= (B[i] == 'W') << i;\n    }\n\n    fill_n( *dp, (1 << 16) * 16, -1);\n    int ret = INF;\n    for(int i = 0; i < A.length(); i++){\n      ret = min( ret, rec(bit, i));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\nint main()\n{\n\tint result[100];\n\tint num = 0;\n\twhile (1)\n\t{\n\t\tint len; cin >> len;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tstring inp; cin >> inp;\n\t\tstring dest; cin >> dest;\n\t\tint cost = 0;\n\t\tbool* correct = new bool[len];\n\t\t\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tcorrect[i] = 0;\n\t\tint pos = -1;\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tif (inp[i] == dest[i])\n\t\t\t\tcorrect[i] = 1;\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t{\n\t\t\tif (!correct[i])\n\t\t\t{\n\t\t\t\tif (pos != -1)\n\t\t\t\t\tcost = cost + abs(pos - i);\n\t\t\t\tpos = i;\n\t\t\t\tfor (int j = 0; j < len; j++)\n\t\t\t\t{\n\t\t\t\t\tif (i != j && !correct[j] && inp[i] != inp[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost = cost + abs(pos - j);\n\t\t\t\t\t\tcorrect[i] = 1;\n\t\t\t\t\t\tcorrect[j] = 1;\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\ttemp = inp[i];\n\t\t\t\t\t\tinp[i] = inp[j];\n\t\t\t\t\t\tinp[j] = temp;\n\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (inp == dest)\n\t\t\t\tbreak;\n\n\t\t}\n\t\tresult[num] = cost;\n\t\tnum++;\n\t\tdelete correct;\n\t}\n\n\tfor (int i = 0; i < num; i++)\n\t\tcout << result[i] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nint main(){\n  int N;\n  while(cin>>N && N){\n    string ss, gs; cin>>ss>>gs;\n    int St = 0, G = 0;\n    REP(i, N){\n      St |= (int)(ss[i] == 'B') << i;\n      G |= (int)(gs[i] == 'B') << i;\n    }\n    priority_queue<S> que;\n    int dist[1<<16][16];\n    REP(i, 1<<N)REP(j, N) dist[i][j] = INF;\n    REP(i, N){\n      dist[St][i] = 0;\n      que.push(S(0, P(St, i)));\n    }\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      int d = s.first * -1;\n      int state = s.second.first;\n      int u = s.second.second;\n      if(state == G){\n        cout<<d<<endl;\n        break;\n      }\n      if(dist[state][u] < d) continue;\n      REP(i, N)REP(j, N)if((state >> i & 1) != (state >> j & 1)){\n        int nst = state ^ (1 << i) ^ (1 << j);\n        int nd = d + abs(i - u) + abs(j - i);\n        int nu = j;\n        if(dist[nst][nu] > nd){\n          dist[nst][nu] = nd;\n          que.push(S(nd * -1, P(nst, nu)));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<(1<<n);j++)dp[i][j]=INF;\n\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(!(tmp>>i&1)){\n\t  for(int k=0;k<n;k++){\n\t    for(int j=0;j<n;j++){\n\t      if(s[j]!=s[k]){\n\t\tfor(int S=0;S<(1<<n);S++){\n\t\t  if((S>>j&1) || (S>>k&1))continue;\n\t\t  int next=S;\n\t\t  next|=(1<<j)|(1<<k);\n\t\t  if(dp[k][next]>dp[i][S]+abs(j-i)+abs(k-j))\n\t\t    dp[k][next]=dp[i][S]+abs(j-i)+abs(k-j);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    Sit(int cost_,int pos_,int mask_){\n        cost=cost_;\n        pos=pos_;\n        mask=mask_;\n    }\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\n\nint d[16][1<<16];\npriority_queue<Sit> que;\nint bfs(){\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        que.push(Sit(0,i,s));\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        if(d[s.pos][s.mask]<s.cost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                // ·ÅÉèÏÝ\n                if((!(((s.mask>>i)&1)^((t>>i)&1)))&&(!(((s.mask>>j)&1)^((t>>j)&1)))){\n                    continue;\n                }\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-s.pos)+abs(j-i);\n                int nmask=s.mask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>j)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,j,a);\n                if(d[j][nmask]>d[s.pos][s.mask]+cost){\n                    d[j][nmask]=d[s.pos][s.mask]+cost;\n                    que.push(Sit(d[j][nmask],j,nmask));\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,d[i][t]);\n    return res;\n}\n//int solve(){\n//    return bfs();\n//    //for(int tern=n;tern>=0;tern--){\n//    //    int nxt=tern%2;\n//    //    int cur=(tern+1)%2;\n//    //    for(int pos=0;pos<n;pos++){\n//    //        for(int sit=0;sit<(1<<n);sit++){\n//    //            int res=INF;\n//    //            if(tern==n){\n//    //                if(sit==t)res=0;\n//    //            }\n//    //            else{\n//    //                for(int to=0;to<n;to++){\n//    //                    // ®©·¾¯\n//    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n//    //                    // trade\n//    //                    int cost=abs(to-pos);\n//    //                    int nsit=sit;\n//    //                    int a=(sit>>pos)&1;\n//    //                    int b=(sit>>to)&1;\n//    //                    setBit(nsit,pos,b);\n//    //                    setBit(nsit,to,a);\n//    //                    res=min(res,dp[cur][to][nsit]+cost);\n//    //                }\n//    //            }\n//    //            dp[nxt][pos][sit]=res;\n//    //        }\n//    //    }\n//    //}\n//    //int res=INF;\n//    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n//    //return res;\n//}\nint main(){\n\n    string ss,tt;\n    while(cin>>n&&n){\n        s=t=0;\n        cin>>ss>>tt;\n        for(int i=0;i<n;i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<n;i++)if(tt[i]=='B')t|=(1<<i);\n        printf(\"%d\\n\",bfs());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n    \n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int r=0;r<2;r++){\n      for(int i=0;i<n;i++){\n\tfor(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t      int next=S;\n\t      next|=(1<<j);\n\t      next|=(1<<k);\n\t      dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t    }\n\t  }\n\t}\n      ans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(!(tmp>>i&1)){\n\t  for(int k=0;k<n;k++){\n\t    for(int j=0;j<n;j++){\n\t      if(s[j]!=s[k]){\n\t\tfor(int S=0;S<(1<<n);S++){\n\t\t  if(!(S>>j&1) && !(S>>k&1)){\n\t\t    int next=S;\n\t\t    next|=(1<<j)|(1<<k);\n\t\t    if(dp[k][next]>dp[i][S]+abs(j-i)+abs(k-j))\n\t\t      dp[k][next]=dp[i][S]+abs(j-i)+abs(k-j);\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n    int cost[16][16][16];\n    for(int i=0;i<16;i++)\n      for(int j=0;j<16;j++)\n\tfor(int k=0;k<16;k++)cost[i][j][k]=abs(j-i)+abs(k-j);\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(tmp>>i&1)continue;\n\tfor(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t      int next=S;\n\t      next|=(1<<j)|(1<<k);\n\t      dp[k][next]=min(dp[k][next],dp[i][S]+cost[i][j][k]);\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    if(ans>=INF)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[2][16][1<<16];\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nint solve(){\n    for(int tern=n;tern>=0;tern--){\n        int nxt=tern%2;\n        int cur=(tern+1)%2;\n        for(int pos=0;pos<n;pos++){\n            for(int sit=0;sit<(1<<n);sit++){\n                int res=INF;\n                if(tern==n){\n                    if(sit==t)res=0;\n                }\n                else{\n                    for(int to=0;to<n;to++){\n                        int cost=abs(to-pos);\n                        int nsit=sit;\n                        int a=(sit>>pos)&1;\n                        int b=(sit>>to)&1;\n                        setBit(nsit,pos,b);\n                        setBit(nsit,to,a);\n                        res=min(res,dp[cur][to][nsit]+cost);\n                    }\n                }\n                dp[nxt][pos][sit]=res;\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 17;\nconst int INF = 1<<28;\nint N;\nint start, finish;\nint dp[1<<MAXN][MAXN][2];\n \nint rec(int b, int p, bool first, int d) {\n  int &res = dp[b][p][first];\n  if(res != -1) return res;\n  if(b == finish) return res = 0;\n  res = INF;\n  if(d == 16*16) return res;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(i == j) continue;\n      if(((b>>i)&1)^((b>>j)&1)) ; else continue;\n      int nb = b;\n      nb ^= 1<<i;\n      nb ^= 1<<j;\n      int addcost;\n      if(first) addcost = abs(j-i);\n      else addcost = abs(i-p) + abs(j-i);\n      res = min(res, rec(nb, j, false, d+1) + addcost);\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    string a, b;\n    cin >> a >> b;\n    start = finish = 0;\n    for(int i = 0; i < N; ++i) {\n      if(a[i] == 'W') start |= 1<<i;\n      if(b[i] == 'W') finish |= 1<<i;\n    }\n    int res = INF;\n    fill(dp[0][0], dp[1<<MAXN][0], -1);\n    for(int i = 0; i < N; ++i) {\n      res = min(res, rec(start, i, true, 0));\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\n//int dp[2][16][1<<16];\n//typedef pair<int,int> pii;\n//typedef pair<int,pii> pipii;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\nint d[16][1<<16];\nint bfs(){\n    priority_queue<Sit> que;\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        Sit sit;\n        sit.cost=0;sit.pos=i;sit.mask=s;\n        que.push(sit);\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        int cpos=s.pos;\n        int ccost=s.cost;\n        int cmask=s.mask;\n        if(d[cpos][cmask]<ccost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-cpos)+abs(j-i);\n                int to=j;\n                int nmask=cmask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>to)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,to,a);\n                if(d[to][nmask]>d[cpos][cmask]+cost){\n                    d[to][nmask]=d[cpos][cmask]+cost;\n                    Sit sit;\n                    sit.cost=d[to][nmask];\n                    sit.pos=to;\n                    sit.mask=nmask;\n                    que.push(sit);\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)\n        res=min(res,d[i][t]);\n    return res;\n}\n//int solve(){\n//    return bfs();\n//    //for(int tern=n;tern>=0;tern--){\n//    //    int nxt=tern%2;\n//    //    int cur=(tern+1)%2;\n//    //    for(int pos=0;pos<n;pos++){\n//    //        for(int sit=0;sit<(1<<n);sit++){\n//    //            int res=INF;\n//    //            if(tern==n){\n//    //                if(sit==t)res=0;\n//    //            }\n//    //            else{\n//    //                for(int to=0;to<n;to++){\n//    //                    // ®©·¾¯\n//    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n//    //                    // trade\n//    //                    int cost=abs(to-pos);\n//    //                    int nsit=sit;\n//    //                    int a=(sit>>pos)&1;\n//    //                    int b=(sit>>to)&1;\n//    //                    setBit(nsit,pos,b);\n//    //                    setBit(nsit,to,a);\n//    //                    res=min(res,dp[cur][to][nsit]+cost);\n//    //                }\n//    //            }\n//    //            dp[nxt][pos][sit]=res;\n//    //        }\n//    //    }\n//    //}\n//    //int res=INF;\n//    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n//    //return res;\n//}\nint main(){\n\n    //string ss,tt;\n    char ss[101];\n    char tt[101];\n    char tmp;\n    while(scanf(\"%d\",&n)&&n){\n        s=t=0;\n        scanf(\"%c\",&tmp);\n        for(int i=0;i<n;i++)scanf(\"%c\",&ss[i]);\n        scanf(\"%c\",&tmp);\n        for(int i=0;i<n;i++)scanf(\"%c\",&tt[i]);\n        //cin>>ss>>tt;\n        scanf(\"%c\",&tmp);\n        for(int i=0;i<n;i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<n;i++)if(tt[i]=='B')t|=(1<<i);\n        //cout<<bfs()<<endl;\n        printf(\"%d\\n\",bfs());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\n#include <map>\nusing namespace std;\n\n\nconst int INF = 1<<24;\n// B:0, W:1\nint N, T;\n//bool vis[16][16][1<<16];\n\nint swapS(int S, int i, int j) {\n  int fi, fj, nS;\n  fi = S & (1<<i);\n  fj = S & (1<<j);\n  nS = S;\n  nS &= ~(1<<i);\n  nS &= ~(1<<j);\n  if(fi) nS |= (1<<j);\n  if(fj) nS |= (1<<i);\n  return nS;\n}\n\nint cost[16][16][1<<16];\n\nint solve(int p, int S) {\n  for(int i = 0; i < N; ++i) \n    for(int j = 0; j < N; ++j)\n      for(int k = 0; k < (1<<N); ++k)\n\tcost[i][j][k] = -1;\n\n  cost[p][p][S] = 0;\n  queue<pair<pair<int, int>, int> >que;//pos,mark,bit\n  que.push(make_pair(make_pair(p, p), S));\n  int res = INF;\n\n  while(!que.empty()) {\n    p = que.front().first.first;\n    int m = que.front().first.second;\n    S = que.front().second;\n    que.pop();\n    if(S == T) {\n      res = min(res, cost[p][m][S]);\n      continue;\n    }\n    int ncost =  cost[p][m][S] + 1;\n    for(int i = -1; i <= 1; i += 2) {\n      int np = p + i;\n      if(np < 0 || np >= N) continue;\n      if(cost[np][m][S] == -1) {\n\tcost[np][m][S] = ncost;\n\tque.push(make_pair(make_pair(np,m),S)); \n      }\n      if(cost[np][np][S] == -1) {\n\tcost[np][np][S] = ncost;\n\tque.push(make_pair(make_pair(np,np),S)); \n      }\n      int nS = swapS(S, m, np);\n      if(cost[np][np][nS] == -1) {\n\tcost[np][np][nS] = ncost;\n\tque.push(make_pair(make_pair(np,np),nS));\n      }\n    }\n  }\n  return res;\n}\n/*\nint rec(int p, int S, int cost {\n  if(S == T) return 0;\n  int res = INF;\n  for(int i = 0; i < N; ++i) {\n    int fi = S & (1<<i);\n    if(fi == T & (1<<i)) continue;\n    for(int j = i+1; j < N; ++j) {\n      int fj = S & (1<<j);\n      if(fj == T & (1<<j)) continue;\n      \n      int nS = S;\n      nS &= ~(1<<i);\n      nS &= ~(1<<j);\n      if(fi) nS |= (1<<j);\n      if(fj) nS |= (1<<i);\n      if(dp[j][nS] == -1) res = min(res, rec(j, nS) + abs(i-p) + abs(j-i));\n      if(dp[i][nS] == -1) res = min(res, rec(i, nS) + abs(j-p) + abs(i-j));\n    }\n  }\n  return res;\n  }*/\n\nint main() {\n  while((cin >> N) && N) {\n    char c;\n    int S;\n    S = T = 0;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tcin >> c;\n\tif(c == 'W') {\n\t  if(k == 0) S |= (1<<i);\n\t  else       T |= (1<<i);\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i < N; ++i) {\n      ans = min(ans, solve(i, S));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring A,B;\nint n,Ab,Bb;\n\nint mem[16][1<<16],used[16][1<<16];\n\nbool digit(int bit,int i){return bit>>i&1;}\n\nint dfs(int pos,int bit){\n  if(bit ==Bb) return 0;\n  if(used[pos][bit]++) return mem[pos][bit];\n  \n  int l,r;\n  for(int i=0;i<n;i++) if(digit(Bb,i)!=digit(bit,i)) l = i,i=n;\n  for(int i=l+1;i<n;i++) if(digit(Bb,i)!=digit(bit,i) && digit(bit,l) != digit(bit,i)) r = i,i=n;\n  //cout<<pos<<\" \"<<l<<\" \"<<r<<endl;\n  int nbit = bit ^ (1<<l) ^ (1<<r);\n  int res = 1e9;\n  res = min(res,(r-l)+abs(r-pos)+dfs(l,nbit));\n  res = min(res,(r-l)+abs(l-pos)+dfs(r,nbit));\n  return mem[pos][bit]=res;\n}\n\nint main(){\n \n  while(cin>>n,n){\n    cin>>A>>B;\n\n    Ab = Bb = 0;\n    for(int i=0;i<n;i++)Ab|=(A[i]=='W')<<i, Bb|=(B[i]=='W')<<i;\n    if(Ab==Bb) {cout<<0<<endl;continue;}\n    \n    int l,r;\n    for(int i=0;i<n;i++) if(digit(Bb,i)!=digit(Ab,i)) l = i,i=n;\n    for(int i=l+1;i<n;i++) if(digit(Bb,i)!=digit(Ab,i) && digit(Ab,l) != digit(Ab,i)) r = i,i=n;\n  \n    memset(used,0,sizeof(used));\n    int nbit = Ab ^ (1<<l) ^ (1<<r);\n    int ans =min((r-l)+dfs(l,nbit),(r-l)+dfs(r,nbit));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1<<16][16],n;\nint main() {\n  while(cin >> n && n) {\n    string s,s2;cin>>s>>s2;\n    int r=0;\n    for(int t=0;t<(1<<n);t++)for(int i=0;i<n;i++)dp[t][i]=1<<29;\n    for(int i=0;i<n;i++)if(s[i]==s2[i]) r|=1<<i;\n    for(int i=0;i<n;i++)dp[r][i]=0;\n    for(int t=0;t<(1<<n);t++) {\n      for(int i=0;i<n;i++) {\n        if(dp[t][i]==1<<29) continue;\n        for(int j=0;j<n;j++) {\n          if(t&(1<<j)) continue;\n          for(int k=j+1;k<n;k++) {\n            if(t&(1<<k)||s[j]==s[k]) continue;\n            dp[t|(1<<j)|(1<<k)][j]=min(dp[t|(1<<j)|(1<<k)][j],dp[t][i]+abs(i-k)+abs(k-j));\n            dp[t|(1<<j)|(1<<k)][k]=min(dp[t|(1<<j)|(1<<k)][k],dp[t][i]+abs(i-j)+abs(j-k));\n          }\n        }\n      }\n    }\n    int ans=1<<29;\n    for(int i=0;i<n;i++)ans=min(ans,dp[(1<<n)-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n\n    int sz=sqrt(n);\n    int ans=INF;\n    for(int r=0;r<sz;r++){\n      for(int i=0;i<n;i++){\n\tif(!(tmp>>i&1)){\n\t  for(int k=0;k<n;k++){\n\t    for(int j=0;j<n;j++){\n\t      if(s[j]!=s[k]){\n\t\tfor(int S=0;S<(1<<n);S++){\n\t\t  if((S>>j&1) || (S>>k&1))continue;\n\t\t  int next=S;\n\t\t  next|=(1<<j)|(1<<k);\n\t\t  if(dp[k][next]>dp[i][S]+abs(j-i)+abs(k-j))\n\t\t    dp[k][next]=dp[i][S]+abs(j-i)+abs(k-j);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\n//int dp[2][16][1<<16];\n//typedef pair<int,int> pii;\n//typedef pair<int,pii> pipii;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\nint d[16][1<<16];\nint bfs(){\n    priority_queue<Sit> que;\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        Sit sit;\n        sit.cost=0;sit.pos=i;sit.mask=s;\n        que.push(sit);\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        int cpos=s.pos;\n        int ccost=s.cost;\n        int cmask=s.mask;\n        if(d[cpos][cmask]<ccost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-cpos)+abs(j-i);\n                int to=j;\n                int nmask=cmask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>to)&1;\n                setBit(nmask,i,b);\n                setBit(nmask,to,a);\n                if(d[to][nmask]>d[cpos][cmask]+cost){\n                    d[to][nmask]=d[cpos][cmask]+cost;\n                    Sit sit;\n                    sit.cost=d[to][nmask];\n                    sit.pos=to;\n                    sit.mask=nmask;\n                    que.push(sit);\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<16;i++)res=min(res,d[i][t]);\n    return res;\n}\n\nint solve(){\n    return bfs();\n    //for(int tern=n;tern>=0;tern--){\n    //    int nxt=tern%2;\n    //    int cur=(tern+1)%2;\n    //    for(int pos=0;pos<n;pos++){\n    //        for(int sit=0;sit<(1<<n);sit++){\n    //            int res=INF;\n    //            if(tern==n){\n    //                if(sit==t)res=0;\n    //            }\n    //            else{\n    //                for(int to=0;to<n;to++){\n    //                    // ®©·¾¯\n    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n    //                    // trade\n    //                    int cost=abs(to-pos);\n    //                    int nsit=sit;\n    //                    int a=(sit>>pos)&1;\n    //                    int b=(sit>>to)&1;\n    //                    setBit(nsit,pos,b);\n    //                    setBit(nsit,to,a);\n    //                    res=min(res,dp[cur][to][nsit]+cost);\n    //                }\n    //            }\n    //            dp[nxt][pos][sit]=res;\n    //        }\n    //    }\n    //}\n    //int res=INF;\n    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    //return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\n#include <map>\nusing namespace std;\n\n\nconst int INF = 1<<24;\n// B:0, W:1\nint N, T;\nint cost[16][16][1<<16];\nint ans;\n\nint swapS(int S, int i, int j) {\n  int fi, fj, nS;\n  fi = S & (1<<i);\n  fj = S & (1<<j);\n  if(fi == T & (1<<i)) return -1;\n  if(fj == T & (1<<j)) return -1;\n  if(fi == fj) return -1;\n  nS = S;\n  nS &= ~(1<<i);\n  nS &= ~(1<<j);\n  if(fi) nS |= (1<<j);\n  if(fj) nS |= (1<<i);\n  return nS;\n}\n\n\n\nvoid solve(int p, int S) {\n  for(int i = 0; i < N; ++i) \n    for(int j = 0; j < N; ++j)\n      for(int k = 0; k < (1<<N); ++k)\n\tcost[i][j][k] = -1;\n\n  cost[p][p][S] = 0;\n  queue<pair<pair<int, int>, int> >que;//pos,mark,bit\n\n  que.push(make_pair(make_pair(p, p), S));\n\n  while(!que.empty()) {\n    p = que.front().first.first;\n    int m = que.front().first.second;\n    S = que.front().second;\n    que.pop();\n    if(S == T) {\n      ans = min(ans, cost[p][m][S]);\n      return;\n    }\n    int ncost =  cost[p][m][S] + 1;\n    for(int i = -1; i <= 1; i += 2) {\n      int np = p + i;\n      if(np < 0 || np >= N) continue;\n      if(cost[np][m][S] == -1) {\n\tcost[np][m][S] = ncost;\n\tque.push(make_pair(make_pair(np,m),S)); \n      }\n      if(cost[np][np][S] == -1) {\n\tcost[np][np][S] = ncost;\n\tque.push(make_pair(make_pair(np,np),S));\n      }\n      int nS = swapS(S, m, np);\n      if(nS == -1) continue;\n      if(cost[np][np][nS] == -1) {\n\tcost[np][np][nS] = ncost;\n\tque.push(make_pair(make_pair(np,np),nS));\n      }\n    }\n  }\n}\n/*\nint rec(int p, int S, int cost {\n  if(S == T) return 0;\n  int res = INF;\n  for(int i = 0; i < N; ++i) {\n    int fi = S & (1<<i);\n    if(fi == T & (1<<i)) continue;\n    for(int j = i+1; j < N; ++j) {\n      int fj = S & (1<<j);\n      if(fj == T & (1<<j)) continue;\n      \n      int nS = S;\n      nS &= ~(1<<i);\n      nS &= ~(1<<j);\n      if(fi) nS |= (1<<j);\n      if(fj) nS |= (1<<i);\n      if(dp[j][nS] == -1) res = min(res, rec(j, nS) + abs(i-p) + abs(j-i));\n      if(dp[i][nS] == -1) res = min(res, rec(i, nS) + abs(j-p) + abs(i-j));\n    }\n  }\n  return res;\n  }*/\n\nint main() {\n  while((cin >> N) && N) {\n    char c;\n    int S;\n    S = T = 0;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tcin >> c;\n\tif(c == 'W') {\n\t  if(k == 0) S |= (1<<i);\n\t  else       T |= (1<<i);\n\t}\n      }\n    }\n    ans = INF;\n    for(int i = 0; i < N; ++i) {\n      solve(i, S);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nconst int MAX_N = 16;\nconst int INF = 1e8;\n\nint dp[MAX_N][(1 << MAX_N)];\nbool vis[MAX_N][(1 << MAX_N)];\nbool vis2[MAX_N][(1 << MAX_N)];\n\nint N;\nint B[2];\nint ans;\n\nvoid show(int num){\n  int a[N];\n  for(int i = 0 ; i < N ; i++)a[i] = ((num >> i)&1);\n  for(int i = 0 ; i < N ; i++)cout << a[i];\n  cout << endl;\n}\n\nint dfs(int j,int i,int& cnt,int& lim,bool& update,int& cost){\n  if(ans <= cost)return INF;\n  if(cnt > lim)return INF;\n  int& ret = dp[j][i];\n  if(ret != INF)return ret;\n\n  if(i == B[1]){\n    return ret = 0;\n  }\n\n  if(!vis[j][i]){\n    update = true;\n    vis[j][i] = true;\n  }\n\n  if(vis2[j][i])return INF;\n  vis2[j][i] = true;\n  \n  for(int k = 0 ; k < N ; k++){\n    if(((i >> k)&(B[1] >> k))&1)continue;\n    for(int l = 0 ; l < N; l++){\n      if(((i >> l)&(B[1] >> l))&1)continue;\n      if(((i >> k)&1) == ((i >> l)&1))continue;\n      int bit = i;\n      bit &= (~(1 << k));\n      bit &= (~(1 << l));\n      if(((i >> k)&1) == 0)bit |= (1 << k);\n      if(((i >> l)&1) == 0)bit |= (1 << l);\n      cnt++;\n      cost += abs(k - j) + abs(k - l);\n      ret = min(ret,dfs(l,bit,cnt,lim,update,cost) + abs(k - j) + abs(k - l));\n      cost -= abs(k - j) + abs(k - l);\n      cnt--;\n    }\n  }\n\n  vis2[j][i] = false;\n  return ret;\n}\n\n\nint main(){\n  while(cin >> N,N){\n    for(int i = 0 ; i < N ; i++){      \n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = INF;\t\n\tvis[i][j] = false;\n\tvis2[i][j] = false;\n      }\n    }\n    for(int i = 0 ; i < 2 ; i++){\n      B[i] = 0;\n      for(int j = 0 ; j < N ; j++){\n\tchar c; cin >> c;\n\tif(c == 'B')B[i] |= (1 << j);\n      }\n    }\n    ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      for(int lim = 0 ; ; lim++){\n\tint cnt = 0;\n\tbool update = false;\n\tint cost = 0;\n\tans = min(ans,dfs(i,B[0],cnt,lim,update,cost));\n\tif(!update)break;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring s, g;\nint dp[1<<16][16];\nint dfs(int S, int u){\n  if(S == (1<<N) - 1) return 0;\n  if(dp[S][u] != -1) return dp[S][u];\n  int res = INF;\n  REP(i, N)REP(j, N) if(i != j && (S >> i & 1) == 0 && (S >> j & 1) == 0 && g[i] != g[j]){\n    res = min(res, abs(u - i) + abs(i - j) + dfs(S | 1 << i | 1 << j, j));\n  }\n  return dp[S][u] = res;\n}\nint main(){\n  while(cin>>N && N){\n    cin>>s>>g;\n    REP(S, 1<<N) REP(p, N) dp[S][p] = -1;\n    int S = 0;\n    REP(i, N) if(s[i] == g[i]) S |= 1<<i;\n    int ans = INF;\n    REP(i, N) ans = min(ans, dfs(S, i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nconst int MAX_N = 16;\nconst int INF = 1e8;\n\nint dp[MAX_N][(1 << MAX_N)];\nbool vis[MAX_N][(1 << MAX_N)];\n\nint N;\nint B[2];\n\n\nvoid show(int num){\n  int a[N];\n  for(int i = 0 ; i < N ; i++)a[i] = ((num >> i)&1);\n  for(int i = 0 ; i < N ; i++)cout << a[i];\n  cout << endl;\n}\n\nint dfs(int j,int i,int& cnt,int& lim,bool& update){\n  if(cnt > lim)return INF;\n  int& ret = dp[j][i];\n  if(ret != INF)return ret;\n\n  if(i == B[1]){\n    return ret = 0;\n  }\n\n  if(!vis[j][i]){\n    update = true;\n    vis[j][i] = true;\n  }\n  \n  for(int k = 0 ; k < N ; k++){\n    for(int l = 0 ; l < N; l++){\n      if(((i >> k)&1) == ((i >> l)&1))continue;\n      int bit = i;\n      bit &= (~(1 << k));\n      bit &= (~(1 << l));\n      if(((i >> k)&1) == 0)bit |= (1 << k);\n      if(((i >> l)&1) == 0)bit |= (1 << l);\n      cnt++;\n      ret = min(ret,dfs(l,bit,cnt,lim,update) + abs(k - j) + abs(k - l));\n      cnt--;\n    }\n  }\n  return ret;\n}\n\n\nint main(){\n  while(cin >> N,N){\n    for(int i = 0 ; i < N ; i++){      \n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = INF;\t\n\tvis[i][j] = false;\n      }\n    }\n    for(int i = 0 ; i < 2 ; i++){\n      B[i] = 0;\n      for(int j = 0 ; j < N ; j++){\n\tchar c; cin >> c;\n\tif(c == 'B')B[i] |= (1 << j);\n      }\n    }\n    int res = INF;\n    for(int i = 0 ; i < N ; i++){\n      for(int lim = 0 ; ; lim++){\n\tint cnt = 0;\n\tbool update = false;\n\tres = min(res,dfs(i,B[0],cnt,lim,update));\n\tif(!update)break;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\n\nconst int INF = 1<<24;\n// B:0, W:1\nint N, T;\nint dp[16][(1<<16)];\n\nint rec(int p, int S) {\n  if(dp[p][S] != -1 && dp[p][S] != -2) return dp[p][S];\n  if(S == T) return dp[p][S] = 0;\n\n  dp[p][S] = -2;\n  int res = INF;\n  for(int i = 0; i < N; ++i) {\n    int fi = S & (1<<i);\n    if(fi == T & (1<<i)) continue;\n    for(int j = i+1; j < N; ++j) {\n      int fj = S & (1<<j);\n      if(fj == T & (1<<j)) continue;\n\n      int nS = S;\n      nS &= ~(1<<i);\n      nS &= ~(1<<j);\n      if(fi) nS |= (1<<j);\n      if(fj) nS |= (1<<i);\n      if(dp[j][nS] != -2) res = min(res, rec(j, nS)+abs(i-p)+abs(j-i));\n      if(dp[i][nS] != -2) res = min(res, rec(i, nS)+abs(j-p)+abs(i-j));\n    }\n  }\n  return dp[p][S] = res;\n}\n\nint main() {\n  while((cin >> N) && N) {\n    char c;\n    int S = 0;\n    T = 0;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tcin >> c;\n\tif(c == 'W') {\n\t  if(k == 0) S |= (1<<i);\n\t  else       T |= (1<<i);\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i < N; ++i) {\n      fill(dp[0], dp[N], -1);\n      ans = min(ans, rec(i, S));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[20];\nint ijk[1<<16][16];\nint v[1<<16][16];\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%s\",str);\n\t\tint A=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(str[i]=='B')A+=(1<<i);\n\t\t}\n\t\tscanf(\"%s\",str);\n\t\tint B=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(str[i]=='B')B+=(1<<i);\n\t\t}\n\t\tfor(int i=0;i<(1<<a);i++)for(int j=0;j<a;j++)\n\t\t\tijk[i][j]=999999999;\n\t\tpriority_queue<pair<int,pair<int,int> > >Q;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tQ.push(make_pair(0,make_pair(A,i)));\n\t\t\tijk[A][i]=0;\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint bit=Q.top().second.first;\n\t\t\tint at=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[bit][at])continue;\n\t\t\tv[bit][at]=1;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif((bit&(1<<i))&&!(bit&(1<<j))){\n\t\t\t\t\t\tint to=bit-(1<<i)+(1<<j);\n\t\t\t\t\t\tif(!v[to][j]&&ijk[to][j]>cost+ABS(at-i)+ABS(i-j)){\n\t\t\t\t\t\t\tijk[to][j]=cost+ABS(at-i)+ABS(i-j);\n\t\t\t\t\t\t\tQ.push(make_pair(-ijk[to][j],make_pair(to,j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(!(bit&(1<<i))&&(bit&(1<<j))){\n\t\t\t\t\t\tint to=bit-(1<<j)+(1<<i);\n\t\t\t\t\t\tif(!v[to][j]&&ijk[to][j]>cost+ABS(at-i)+ABS(i-j)){\n\t\t\t\t\t\t\tijk[to][j]=cost+ABS(at-i)+ABS(i-j);\n\t\t\t\t\t\t\tQ.push(make_pair(-ijk[to][j],make_pair(to,j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=9999999;\n\t\tfor(int i=0;i<a;i++)ret=min(ret,ijk[B][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint p,c,b;\n\tState(int p, int c, int b)\n\t\t:p(p),c(c),b(b)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c>s.c;\n\t}\n};\n\nint toBin(string s)\n{\n\tint ret=0;\n\tfor(int i=0; i<s.size(); i++)\n\t\tif(s[i]=='B') ret+=(1<<i);\n\n\n\treturn ret;\n}\n\nbool v[16][1<<16];\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tstring S,D;\n\t\tcin >> S >> D;\n\n\t\tint T=toBin(D);\n\n\t\tmemset(v,0,sizeof(v));\n\t\tpriority_queue<State> q;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tq.push(State(i,0,toBin(S)));\n\t\t}\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.top(); q.pop();\n\t\t\tif(v[s.p][s.b]) continue;\n\t\t\tv[s.p][s.b]=1;\n\n\t\t\tif(s.b==T)\n\t\t\t{\n\t\t\t\tcout << s.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<N; i++)\n\t\t\t{\n\t\t\t\tint f1 = (1<<s.p);\n\t\t\t\tint f2 = (1<<i);\n\n\t\t\t\tbool b1 = s.b & f1;\n\t\t\t\tbool b2 = s.b & f2;\n\n\n\t\t\t\tint tb=s.b;\n\n\t\t\t\tif(b1) tb|=f2; else tb&=(~f2);\n\t\t\t\tif(b2) tb|=f1; else tb&=(~f1);\n\n\t\t\t\tif(!v[i][s.b]) q.push(State(i,s.c+abs(s.p-i),s.b));\n\n\t\t\t\t\n\t\t\t\tif(b1==b2) continue;\n\n\t\t\t\tif(v[i][tb]) continue;\n\n\t\t\t\tq.push(State(i,s.c+abs(s.p-i),tb));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\n//int dp[2][16][1<<16];\n//typedef pair<int,int> pii;\n//typedef pair<int,pii> pipii;\n\ninline void setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nclass Sit{\npublic:\n    int cost;\n    int pos;\n    int mask;\n    Sit(int cost_,int pos_,int mask_){\n        cost=cost_;\n        pos=pos_;\n        mask=mask_;\n    }\n    bool operator<(const Sit &s)const {\n        return s.cost<this->cost;\n    }\n};\n\nint d[16][1<<16];\npriority_queue<Sit> que;\nint bfs(){\n    for(int j=0;j<n;j++)for(int k=0;k<(1<<n);k++)d[j][k]=INF;\n    for(int i=0;i<n;i++){\n        d[i][s]=0;\n        que.push(Sit(0,i,s));\n    }\n    while(!que.empty()){\n        Sit s=que.top();que.pop();\n        if(d[s.pos][s.mask]<s.cost)continue;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                //  éêÖÚ®µÄA»ÌêÆð·\n                int cost=abs(i-s.pos)+abs(j-i);\n                int nmask=s.mask;\n                int a=(nmask>>i)&1;\n                int b=(nmask>>j)&1;\n                if(b)nmask|=(1<<i);\n                else nmask&=~(1<<i);\n                if(a)nmask|=(1<<j);\n                else nmask&=~(1<<j);\n                //setBit(nmask,i,b);\n                //setBit(nmask,j,a);\n                if(d[j][nmask]>d[s.pos][s.mask]+cost){\n                    d[j][nmask]=d[s.pos][s.mask]+cost;\n                    que.push(Sit(d[j][nmask],j,nmask));\n                }\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,d[i][t]);\n    return res;\n}\n//int solve(){\n//    return bfs();\n//    //for(int tern=n;tern>=0;tern--){\n//    //    int nxt=tern%2;\n//    //    int cur=(tern+1)%2;\n//    //    for(int pos=0;pos<n;pos++){\n//    //        for(int sit=0;sit<(1<<n);sit++){\n//    //            int res=INF;\n//    //            if(tern==n){\n//    //                if(sit==t)res=0;\n//    //            }\n//    //            else{\n//    //                for(int to=0;to<n;to++){\n//    //                    // ®©·¾¯\n//    //                    res=min(res,dp[cur][to][sit]+abs(to-pos));\n//    //                    // trade\n//    //                    int cost=abs(to-pos);\n//    //                    int nsit=sit;\n//    //                    int a=(sit>>pos)&1;\n//    //                    int b=(sit>>to)&1;\n//    //                    setBit(nsit,pos,b);\n//    //                    setBit(nsit,to,a);\n//    //                    res=min(res,dp[cur][to][nsit]+cost);\n//    //                }\n//    //            }\n//    //            dp[nxt][pos][sit]=res;\n//    //        }\n//    //    }\n//    //}\n//    //int res=INF;\n//    //for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n//    //return res;\n//}\nint main(){\n\n    string ss,tt;\n    while(cin>>n&&n){\n        s=t=0;\n        cin>>ss>>tt;\n        for(int i=0;i<n;i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<n;i++)if(tt[i]=='B')t|=(1<<i);\n        printf(\"%d\\n\",bfs());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n    \n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tfor(int k=0;k<n;k++){\n\t  for(int j=0;j<n;j++){\n\t    if(s[j]==s[k])continue;\n\t    for(int S=0;S<(1<<n);S++){\n\t      if((S>>j&1) || (S>>k&1))continue;\n\t      int next=S;\n\t      next|=(1<<j);\n\t      next|=(1<<k);\n\t      dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct S{\n  int b,p,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nint main(){\n  for(int N;cin>>N,N;){\n    char p[2][17];\n    cin>>p[0]>>p[1];\n    int b=0;\n    for(int i=0;i<N;i++){\n      b|=(p[0][i]!=p[1][i])<<i;\n    }\n    priority_queue<S> que;\n    for(int i=0;i<N;i++){\n      que.push({b,i,0});\n    }\n    bool u[1<<16][16]={};\n    for(;;){\n      S cs=que.top();\n      if(cs.b==0)break;\n      que.pop();\n      if(u[cs.b][cs.p]++)continue;\n      for(int i=0;i<N;i++){\n\tif(cs.b>>i&1){\n\t  for(int j=0;j<N;j++){\n\t    if(cs.b>>j&1&&p[0][i]!=p[0][j]){\n\t      que.push({cs.b^1<<i^1<<j,j,cs.c+abs(cs.p-i)+abs(i-j)});\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.top().c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring A,B;\nint n,Ab,Bb;\n\nint Bit(int bit ,int i,int x){\n  while((bit>>i&1)!=x)bit ^= 1<<i;\n  return bit;\n}\n\nint mem[16][1<<16],used[16][1<<16];\nint dep = 0;\nint dfs(short pos,int bit){\n  cout<<  dep++ <<endl;\n  if(bit ==Bb) return 0;\n  if(used[pos][bit]++) return mem[pos][bit];\n  \n  int &res = mem[pos][bit] = 1e9;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int nbit = bit;\n      nbit = Bit(nbit,i,bit>>j&1);\n      nbit = Bit(nbit,j,bit>>i&1);\n      res = min(res,abs(pos-i)+abs(i-j)+dfs(j,nbit));\n    }\n  cout<<dep<<endl;\n  return mem[pos][bit];\n}\n\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint bfs(){\n  for(int j=0;j<16;j++) \n    for(int i=0;i<(1<<16);i++)mem[j][i] = 1e9;\n  \n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  for(int i=0;i<n;i++) Q.push(PP(0,P(i,Ab))),mem[i][Ab] = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int bit = t.second.second;\n    if(bit == Bb) return cost;\n    if(mem[pos][bit]<cost)continue;\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tint nbit = bit;\n\tnbit = Bit(nbit,i,bit>>j&1);\n\tnbit = Bit(nbit,j,bit>>i&1);\n\tint ncost = cost+abs(pos-i)+abs(i-j);\n\tif(ncost >= mem[j][nbit])continue;\n\tQ.push(PP(ncost,P(j,nbit)));\n\tmem[j][nbit] = ncost;\n      }\n  }\n  assert(0);  \n}\n\n\nint main(){\n \n  while(cin>>n,n){\n    cin>>A>>B;\n    \n    Ab = Bb = 0;\n    for(int i=0;i<n;i++)Ab|=(A[i]=='W')<<i, Bb|=(B[i]=='W')<<i;\n    \n    memset(used,0,sizeof(used));\n    int ans = 1e9;\n    //for(int i=0;i<n;i++) ans=min(ans,dfs(i,Ab));\n    //cout<<ans<<endl;\n    cout<<bfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 17;\nconst int INF = 1<<28;\nint N;\nint start, finish;\nint dp[1<<MAXN][MAXN];\n \nint rec(int b, int p, int d) {\n  int &res = dp[b][p];\n  if(res != -1) return res;\n  if(b == finish) return res = 0;\n  res = INF;\n  //if(d == MAXN*MAXN) return res;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(i == j) continue;\n      if(((b>>i)&1)^((b>>j)&1)) ; else continue;\n      int nb = b;\n      nb ^= (1<<i);\n      nb ^= (1<<j);\n      int addcost;\n      if(p == N) addcost = abs(j-i);\n      else addcost = abs(i-p) + abs(j-i);\n      res = min(res, rec(nb, j, d+1) + addcost);\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    string a, b;\n    cin >> a >> b;\n    start = finish = 0;\n    for(int i = 0; i < N; ++i) {\n      if(a[i] == 'W') start |= 1<<i;\n      if(b[i] == 'W') finish |= 1<<i;\n    }\n    fill(dp[0], dp[1<<MAXN], -1);\n    int res = rec(start, N, 0);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n;\nint s,t;\nconst int INF=1000000000;\n// tern,pos,sit\nint dp[2][16][1<<16];\n\nvoid setBit(int &s,int pos,int bit){\n    if(bit)s|=(1<<pos);\n    else s&=~(1<<pos);\n}\n\nint solve(){\n    for(int tern=n;tern>=0;tern--){\n        int nxt=tern%2;\n        int cur=(tern+1)%2;\n        for(int pos=0;pos<n;pos++){\n            for(int sit=0;sit<(1<<n);sit++){\n                int res=INF;\n                if(tern==n){\n                    if(sit==t)res=0;\n                }\n                else{\n                    for(int to=0;to<n;to++){\n                        // ツ督ョツつゥツつキツつセツつッ\n                        res=min(res,dp[cur][to][sit]+abs(to-pos));\n                        // trade\n                        int cost=abs(to-pos);\n                        int nsit=sit;\n                        int a=(sit>>pos)&1;\n                        int b=(sit>>to)&1;\n                        setBit(nsit,pos,b);\n                        setBit(nsit,to,a);\n                        res=min(res,dp[cur][to][nsit]+cost);\n                    }\n                }\n                dp[nxt][pos][sit]=res;\n            }\n        }\n    }\n    int res=INF;\n    for(int i=0;i<n;i++)res=min(res,dp[0][i][s]);\n    return res;\n}\n\nint main(){\n\n    while(cin>>n&&n){\n        s=t=0;\n        string ss,tt;\n        cin>>ss>>tt;\n        for(int i=0;i<ss.size();i++)if(ss[i]=='B')s|=(1<<i);\n        for(int i=0;i<tt.size();i++)if(tt[i]=='B')t|=(1<<i);\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\nint main()\n{\n\n\twhile (1)\n\t{\n\t\tint len; cin >> len;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tstring inp; cin >> inp;\n\t\tstring dest; cin >> dest;\n\t\tint cost = 0;\n\t\tbool* correct = new bool[len];\n\t\t\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tcorrect[i] = 0;\n\t\tint pos = -1;\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tif (inp[i] == dest[i])\n\t\t\t\tcorrect[i] = 1;\n\n\t\tfor (int i = 0; i < len; i++)\n\t\t{\n\t\t\tif (!correct[i])\n\t\t\t{\n\t\t\t\tif (pos != -1)\n\t\t\t\t\tcost = cost + abs(pos - i);\n\t\t\t\tpos = i;\n\t\t\t\tfor (int j = 0; j < len; j++)\n\t\t\t\t{\n\t\t\t\t\tif (i != j && !correct[j] && inp[i] != inp[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost = cost + abs(pos - j);\n\t\t\t\t\t\tcorrect[i] = 1;\n\t\t\t\t\t\tcorrect[j] = 1;\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\ttemp = inp[i];\n\t\t\t\t\t\tinp[i] = inp[j];\n\t\t\t\t\t\tinp[j] = temp;\n\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (inp == dest)\n\t\t\t\tbreak;\n\n\t\t}\n\t\tcout << cost << endl;\n\t\tdelete correct;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int panel;\n  int cost;\n  int machine_pos;\n  State(int panel,int cost,int machine_pos){\n    this->panel = panel;\n    this->cost = cost;\n    this->machine_pos = machine_pos;\n  }\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint dp[16][1<<16];\n\nint main(){\n  int num_of_panels;\n  while(~scanf(\"%d\",&num_of_panels)){\n    if(num_of_panels == 0) break;\n\n    int panels[2] = {};\n    for(int set_i = 0; set_i < 2; set_i++){\n      string panel;\n      cin >> panel;\n      for(int pos = 0; pos < num_of_panels; pos++){\n        if(panel[pos] == 'B'){\n          panels[set_i] |= (1<<pos);\n        }\n      }\n    }\n  \n    priority_queue<State,vector<State>,greater<State> > que;\n\n    memset(dp,0x3f,sizeof(dp));\n    for(int pos = 0; pos < num_of_panels; pos++){\n      dp[pos][panels[0]] = 0;\n      que.push(State(panels[0],0,pos));      \n    }\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      int from = s.machine_pos;\n      for(int to = 0; to < num_of_panels; to++){\n        if(to == from) continue;\n        int from_bit = (s.panel >> from) & 1;\n        int to_bit = (s.panel >> to) & 1;\n        \n        int next_panel = s.panel;\n        if(to_bit == 1){\n          next_panel = next_panel | (1 << from);\n        }\n        else {\n          next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << from));\n        }\n        if(from_bit == 1){\n          next_panel = next_panel | (1 << to);\n        }\n        else {\n          next_panel = next_panel & (((1<<num_of_panels) - 1) ^ (1 << to));\n        }\n        \n        if(dp[to][next_panel] <= s.cost + abs(to - from)) continue;\n        dp[to][next_panel] = s.cost + abs(to - from);\n        que.push(State(next_panel,s.cost + abs(to - from),to));\n      }\n    }\n\n    int res = INF;\n    for(int pos = 0; pos < num_of_panels; pos++){\n      res = min(res,dp[pos][panels[1]]);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int MAXN = 17;\nconst int INF = 1<<28;\nint N;\nint start, finish;\nint dp[1<<MAXN][MAXN];\n \nint rec(int b, int p, int d) {\n  int &res = dp[b][p];\n  if(res != -1) return res;\n  if(b == finish) return res = 0;\n  res = INF;\n  if(d == 100000) return res;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(i == j) continue;\n      if(((b>>i)&1)^((b>>j)&1)) ; else continue;\n      int nb = b;\n      nb ^= (1<<i);\n      nb ^= (1<<j);\n      int addcost;\n      if(p == N) addcost = abs(j-i);\n      else addcost = abs(i-p) + abs(j-i);\n      res = min(res, rec(nb, j, d+1) + addcost);\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    string a, b;\n    cin >> a >> b;\n    start = finish = 0;\n    for(int i = 0; i < N; ++i) {\n      if(a[i] == 'W') start |= 1<<i;\n      if(b[i] == 'W') finish |= 1<<i;\n    }\n    fill(dp[0], dp[1<<MAXN], -1);\n    int res = rec(start, N, 0);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[n],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n    \n    int ans=INF;\n    for(int r=0;r<4;r++){\n      for(int i=0;i<n;i++){\n\tif(!(tmp>>i&1)){\n\t  for(int k=0;k<n;k++){\n\t    for(int j=0;j<n;j++){\n\t      if(s[j]!=s[k]){\n\t\tfor(int S=0;S<(1<<n);S++){\n\t\t  if((S>>j&1) || (S>>k&1))continue;\n\t\t  int next=S;\n\t\t  next|=(1<<j)|(1<<k);\n\t\t  if(dp[k][next]>dp[i][S]+abs(j-i)+abs(k-j))\n\t\t    dp[k][next]=dp[i][S]+abs(j-i)+abs(k-j);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tans=min(ans,dp[i][(1<<n)-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[16][(1<<16)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n    \n    fill(dp[0],dp[16],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    int ans=INF;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=j+1;k<n;k++){\n\t  if(s[j]!=t[k] && s[k]!=t[j])continue;\n\t  for(int S=0;S<(1<<n);S++){\n\t    if((S>>j&1) || (S>>k&1))continue;\n\t    int next=S;\n\t    if(t[j]==s[k])next|=(1<<j);\n\t    if(t[k]==s[j])next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 16\n#define INF 1e9\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\n\nint N,S,G;\nint dp[1<<MAX][MAX];\nchar panels[MAX];\n\nvoid solve(int s){\n  priority_queue<piii,vector<piii>,greater<piii> > Q;\n  Q.push(piii(pii(0,s),S));\n  \n  while(!Q.empty()){\n    piii p = Q.top(); Q.pop();\n    int cost = p.first.first, v = p.first.second;\n    int bit = p.second;\n\n    if(dp[bit][v] < cost) continue;\n    for(int i = 0 ; i < N ; i++){\n      if(i == v) continue;\n      if(((bit >> v) & 1) == ((bit >> i) & 1)) continue;   \n      int c = abs(i-v), nS = bit;\n      if((nS >> v) & 1){\n        nS -= (1<<v);\n      }else{\n        nS |= (1<<v);\n      }\n      if((nS >> i) & 1){\n        nS -= (1<<i);\n      }else{\n        nS |= (1<<i);\n      }\n      if(dp[bit][v] + c < dp[nS][i]){\n        dp[nS][i] = dp[bit][v] + c;\n        Q.push(piii(pii(dp[nS][i],i),nS));\n      }\n    }\n    for(int i = 0 ; i < N ; i++){\n      if(i == v) continue;\n      int c = abs(i-v);\n      if(dp[bit][v] + c < dp[bit][i]){\n        dp[bit][i] = dp[bit][v] + c;\n        Q.push(piii(pii(dp[bit][i],i),bit));\n      }\n    }\n  }\n}\n\nint main(){\n  string in;\n  while(cin >> N && N){\n    S = G = 0;\n    for(int i = 0 ; i < (1<<MAX) ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> in;\n      for(int j = 0 ; j < N ; j++){\n        if(i == 0){\n          panels[j] = in[j];\n          if(panels[j] == 'W'){\n            S |= (1<<j);\n          }\n        }else{\n          if(in[j] == 'W'){\n            G |= (1<<j);\n          }\n        }\n      }\n    }\n   \n    for(int i = 0 ; i < N ; i++){\n      dp[S][i] = 0;\n      solve(i);\n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans,dp[G][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define INF (1<<29)\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\nint dp[17][(1<<17)];\n\nint main(void){\n\n  int n;\n  string s,t;\n\n  while(cin >> n,n){\n    cin >> s >> t;\n\n    fill(dp[0],dp[17],INF);\n    int tmp=0;\n    for(int i=0;i<n;i++){\n      if(s[i]==t[i])tmp|=(1<<i);\n    }\n    for(int i=0;i<n;i++)dp[i][tmp]=0;\n\n    for(int i=0;i<n;i++){\n      for(int S=0;S<(1<<n);S++){\n\tfor(int j=0;j<n;j++){\n\t  if(S>>j&1)continue;\n\t  for(int k=0;k<n;k++){\n\t    if(j==k || S>>k&1)continue;\n\t    if(s[j]==s[k])continue;\n\t    int next=S;\n\t    next|=(1<<j);\n\t    next|=(1<<k);\n\t    dp[k][next]=min(dp[k][next],dp[i][S]+abs(j-i)+abs(k-j));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<=n;i++){\n      ans=min(ans,dp[i][(1<<n)-1]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring A,B;\nint n,Ab,Bb;\n\n\n/*int dfs(int pos,int bit){\n  if(bit ==Bb) return 0;\n  if(used[pos][bit]++) return mem[pos][bit];\n  \n  int l,r;\n  for(int i=0;i<n;i++)   if(digit(Bb,i)!=digit(bit,i)) l = i,i=n;\n  for(int i=l+1;i<n;i++) if(digit(Bb,i)!=digit(bit,i) && digit(bit,l) != digit(bit,i)) r = i,i=n;\n  //cout<<pos<<\" \"<<l<<\" \"<<r<<endl;\n  int nbit = bit ^ (1<<l) ^ (1<<r);\n  int res = 1e9;\n  res = min(res,(r-l)+abs(r-pos)+dfs(l,nbit));\n  res = min(res,(r-l)+abs(l-pos)+dfs(r,nbit));\n  return mem[pos][bit]=res;\n}\n*/\n\n\nbool digit(int bit,int i){return bit>>i&1;}\nint Bit(int bit ,int i,int x){\n  while((bit>>i&1)!=x)bit ^= 1<<i;\n  return bit;\n}\n\nint mem[16][1<<16],used[16][1<<16];\nint dfs(int pos,int bit){\n  if(bit ==Bb) return 0;\n  if(used[pos][bit]++) return mem[pos][bit];\n  \n  int res = mem[pos][bit] = 1e9;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n\n      int nbit = bit;\n      nbit = Bit(nbit,i,bit>>j&1);\n      nbit = Bit(nbit,j,bit>>i&1);\n      res = min(res,abs(pos-i)+abs(i-j)+dfs(j,nbit));\n    }\n\n  return mem[pos][bit]=res;\n}\n\nint main(){\n \n  while(cin>>n,n){\n    cin>>A>>B;\n    \n    Ab = Bb = 0;\n    for(int i=0;i<n;i++)Ab|=(A[i]=='W')<<i, Bb|=(B[i]=='W')<<i;\n    \n    memset(used,0,sizeof(used));\n    int ans = 1e9;\n    for(int i=0;i<n;i++) ans=min(ans,dfs(i,Ab));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2040 Sort the Panels\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { int s; char p; char t; } QUE;\nQUE que[QMAX]; int qsize, qmax;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t, char p)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].p = p;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define ABS(a)  ((a)>=0?(a):-(a))\nchar dist[1<<16][16];\n\nint dijkstra(int n, int nb, int start, int goal)\n{\n\tint i, j, k, m, s, t, p, ns, nt, nw;\n\tint pi, ij;\n\n\tmemset(dist, 75, sizeof(dist));\n\tqsize = 0;\n\tt = -1, nw = n - nb;\n\tfor (p = 0; p < n; p++) dist[start][p] = 0, enq(start, 0, p);\n\twhile (qsize) {\n\t\ts = que[0].s, t = que[0].t, p = que[0].p, deq();\n\t\tif (s == goal) break;\n\n\t\tif (dist[s][p] < t) continue;\n\n\t\tfor (k = i = 0; k < nb; i++) if (s & (1<<i)) { k++, pi = ABS(p-i);\n\t\t\tfor (m = j = 0; m < nw; j++) if (!(s & (1<<j))) { m++;\n\t\t\t\tij = ABS(j-i);\n\t\t\t\tns = s ^ (1<<i) ^ (1<<j);\n\t\t\t\tnt = t + pi+ij;\n\t\t\t\tif (dist[ns][j] > nt) dist[ns][j] = nt, enq(ns, nt, j);\n\t\t\t\tnt = t + ABS(p-j)+ij;\n\t\t\t\tif (dist[ns][i] > nt) dist[ns][i] = nt, enq(ns, nt, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn t;\n}\n\nint calc(char *s) { int res=0; while (*s > ' ') res = (res<<1)|(*s++ == 'B'); return res; }\n\nint main()\n{\n\tint n, nb, start, goal;\n\tchar buf[20], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tfgets(p=buf, 20, stdin); nb = 0; while (*p > ' ') if (*p++ == 'B') nb++;\n\t\tstart = calc(buf);\n\t\tfgets(buf, 20, stdin), goal = calc(buf);\n\t\tif (nb > n-nb) {\n\t\t\tnb = n-nb;\n\t\t\tstart = ~start & ((1<<n)-1), goal = ~goal & ((1<<n)-1);\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(n, nb, start, goal));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint n;\n\tchar src[20];\n\tchar dest[20];\n\tchar temp;\n\tint i,j;\n\tint count,last_count;\n\twhile(1) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%s\",src);\n\t\tscanf(\"%s\",dest);\n\t\tcount=last_count=0;\n\t\tfor(i=0;i<n && src[i]==dest[i];i++);\n\t\tfor(j=0;i<n;i++) {\n\t\t\tif(src[i]!=dest[i]) {\n\t\t\t\tif(j>i)count+=j-i;\n\t\t\t\telse if(j>0 && i>j)count+=i-j;\n\t\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\t\tif(src[j]==dest[i])break;\n\t\t\t\t}\n\t\t\t\tcount+=j-i;\n\t\t\t\ttemp=src[i];\n\t\t\t\tsrc[i]=src[j];\n\t\t\t\tsrc[j]=temp;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2040 Sort the Panels\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { int s; char p; char t; } QUE;\nQUE que[QMAX]; int qsize, qmax;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t, char p)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\t//if (qsize > qmax) qmax = qsize;\n\tque[i].s = s, que[i].t = t, que[i].p = p;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define ABS(a)  ((a)>=0?(a):-(a))\nchar dist[1<<16][16];\n\nint dijkstra(int n, int nb, int start, int goal)\n{\n\tint i, j, k, m, s, t, p, ns, nt, nw;\n\tint pi, ij;\n\n\tmemset(dist, 75, sizeof(dist));\n\tqsize = 0;\n\tt = -1, nw = n - nb;\n\tfor (p = 0; p < n; p++) dist[start][p] = 0, enq(start, 0, p);\n\twhile (qsize) {\n\t\ts = que[0].s, t = que[0].t, p = que[0].p, deq();\n\t\tif (s == goal) break;\n\n\t\tif (dist[s][p] < t) continue;\n\n\t\tfor (k = i = 0; k < nb; i++) if (s & (1<<i)) { k++, pi = ABS(p-i);\n\t\t\tfor (m = j = 0; m < nw; j++) if (!(s & (1<<j))) { m++;\n\t\t\t\tij = ABS(j-i);\n\t\t\t\tns = s ^ (1<<i) ^ (1<<j);\n\t\t\t\tnt = t + pi+ij;\n\t\t\t\tif (dist[ns][j] > nt) dist[ns][j] = nt, enq(ns, nt, j);\n\t\t\t\tnt = t + ABS(p-j)+ij;\n\t\t\t\tif (dist[ns][i] > nt) dist[ns][i] = nt, enq(ns, nt, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn t;\n}\n\nint calc(char *s) { int res=0; while (*s > ' ') res = (res<<1)|(*s++ == 'B'); return res; }\n\nint main()\n{\n\tint n, nb, start, goal;\n\tchar buf[20], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tfgets(p=buf, 20, stdin); nb = 0; while (*p > ' ') if (*p++ == 'B') nb++;\n\t\tstart = calc(buf);\n\t\tfgets(buf, 20, stdin), goal = calc(buf);\n\t\tif (nb > n-nb) {\n\t\t\tnb = n-nb;\n\t\t\tstart = ~start & ((1<<n)-1), goal = ~goal & ((1<<n)-1);\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(n, nb, goal, start));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint n;\n\tchar src[20];\n\tchar dest[20];\n\tchar temp;\n\tint i,j;\n\tint count,count2;\n\twhile(1) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%s\",src);\n\t\tscanf(\"%s\",dest);\n\t\tcount=0;\n\t\tfor(i=0;i<n && src[i]==dest[i];i++);\n\t\tfor(j=0;i<n;i++) {\n\t\t\tif(src[i]!=dest[i]) {\n\t\t\t\tif(j>i)count+=j-i;\n\t\t\t\telse if(j>0 && i>j)count+=i-j;\n\t\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\t\tif(src[j]==dest[i])break;\n\t\t\t\t}\n\t\t\t\tcount+=j-i;\n\t\t\t\ttemp=src[i];\n\t\t\t\tsrc[i]=src[j];\n\t\t\t\tsrc[j]=temp;\n\t\t\t}\n\t\t}\n\t\tcount2=0;\n\t\tfor(i=n-1;i>=0 && src[i]==dest[i];i--);\n\t\tfor(j=n;i>=0;i--) {\n\t\t\tif(src[i]!=dest[i]) {\n\t\t\t\tif(j<i)count+=i-j;\n\t\t\t\telse if(j<n && i<j)count+=j-i;\n\t\t\t\tfor(j=i-1;j>=0;j--) {\n\t\t\t\t\tif(src[j]==dest[i])break;\n\t\t\t\t}\n\t\t\t\tcount+=i-j;\n\t\t\t\ttemp=src[i];\n\t\t\t\tsrc[i]=src[j];\n\t\t\t\tsrc[j]=temp;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count2<count?count2:count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2040 Sort the Panels\n// 2018.3.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { int s; char p; char t; } QUE;\nQUE que[QMAX]; int qsize, qmax;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t, char p)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].p = p;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define ABS(a)  ((a)>=0?(a):-(a))\nchar dist[1<<16][16];\n\nint dijkstra(int n, int nb, int start, int goal)\n{\n\tint i, j, k, m, s, t, p, ns, nt, nw;\n\tint pi, pj;\n\n\tmemset(dist, 75, sizeof(dist));\n\tqsize = 0;\n\tt = -1, nw = n - nb;\n\tfor (p = 0; p < n; p++) dist[start][p] = 0, enq(start, 0, p);\n\twhile (qsize) {\n\t\ts = que[0].s, t = que[0].t, p = que[0].p, deq();\n\t\tif (s == goal) break;\n\n\t\tif (dist[s][p] < t) continue;\n\n\t\tfor (k = i = 0; k < nb; i++) if (s & (1<<i)) { k++, pi = ABS(p-i);\n\t\t\tpi = ABS(p-i);\n\t\t\tfor (m = j = 0; m < nw; j++) if (!(s & (1<<j))) { m++;\n\t\t\t\tns = s ^ (1<<i) ^ (1<<j);\n\t\t\t\tif (pi < (pj=ABS(p-j))) {\n\t\t\t\t\tnt = t + pi + ABS(i-j);\n\t\t\t\t\tif (dist[ns][j] > nt) dist[ns][j] = nt, enq(ns, nt, j);\n\t\t\t\t} else {\n\t\t\t\t\tnt = t + pj + ABS(i-j);\n\t\t\t\t\tif (dist[ns][i] > nt) dist[ns][i] = nt, enq(ns, nt, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn t;\n}\n\nint calc(char *s) { int res=0; while (*s > ' ') res = (res<<1)|(*s++ == 'B'); return res; }\n\nint main()\n{\n\tint n, nb, start, goal;\n\tchar buf[20], *p;\n\n\twhile (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tfgets(p=buf, 20, stdin); nb = 0; while (*p > ' ') if (*p++ == 'B') nb++;\n\t\tstart = calc(buf);\n\t\tfgets(buf, 20, stdin), goal = calc(buf);\n\t\tif (nb > n-nb) {\n\t\t\tnb = n-nb;\n\t\t\tstart = ~start & ((1<<n)-1), goal = ~goal & ((1<<n)-1);\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(n, nb, start, goal));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tint c;\n\t\tint p;\n\n\t\tS(int ss, int cc, int pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, 0, sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean used[][] = new boolean[(1 << n)][n];\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tSystem.out.println(Integer.toBinaryString((1 << 10) + now.s)\n//\t\t\t\t\t\t+ \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println(now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = true;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (!used[ns][pos])\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, now.c + cost, pos));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (!used[ns][pos])\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, now.c + cost, pos));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tchar c;\n\t\tchar p;\n\n\t\tS(int ss, char cc, char pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tchar used[][] = new char[(1 << 16)][16];\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, (char) 0, (char) sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(used[i], (char) 200);\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p] < now.c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(Integer.toBinaryString((1 << 10) + now.s)\n\t\t\t\t// + \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println((int) now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = (char) now.c;\n\n\t\t\t\tint nn = Integer.bitCount(now.s ^ g) / 2;\n\n\t\t\t\t{\n\t\t\t\t\tint ii[] = new int[nn];\n\t\t\t\t\tint jj[][] = new int[nn][2];\n\n\t\t\t\t\tint ind = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\t\tii[ind] = i;\n\t\t\t\t\t\t\tjj[ind][0] = -1;\n\t\t\t\t\t\t\tjj[ind][1] = -1;\n\t\t\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\t\tjj[ind][0] = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\t\tjj[ind][1] = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tind++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int z = 0; z < nn; z++) {\n\t\t\t\t\t\tfor (int z2 = 0; z2 < 2; z2++) {\n\t\t\t\t\t\t\tint i = ii[z];\n\t\t\t\t\t\t\tint j = jj[z][z2];\n\t\t\t\t\t\t\tif (j == -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost),\n\t\t\t\t\t\t\t\t\t\t(char) pos));\n\n\t\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost),\n\t\t\t\t\t\t\t\t\t\t(char) pos));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tint ii[] = new int[nn];\n\t\t\t\t\tint jj[] = new int[nn];\n\t\t\t\t\tint ind = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\t\tii[ind++] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tind = 0;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\tjj[ind++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int z = 0; z < nn; z++) {\n\t\t\t\t\t\tint i = ii[z];\n\t\t\t\t\t\tint j = jj[z];\n\n\t\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost), (char) pos));\n\n\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost), (char) pos));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Sort the Panels\npublic class Main{\n\n\tint[][] dist;\n\tint n, M = 20, INF = 1<<29, S, G;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar[] t1 = sc.next().toCharArray(), t2 = sc.next().toCharArray();\n\t\t\tS = 0; G = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tS+=t1[i]=='W'?1<<i:0; G+=t2[i]=='W'?1<<i:0;\n\t\t\t}\n\t\t\tdist = new int[1<<n][n];\n\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn dist[o1/M][o1%M]-dist[o2/M][o2%M];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdist[S][i] = 0; q.add(S*M+i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint V = q.poll();\n\t\t\t\tint s = V/M, p = V%M;\n\t\t\t\tif(s==G){\n\t\t\t\t\tSystem.out.println(dist[s][p]); break;\n\t\t\t\t}\n\t\t\t\tfor(int a=0;a<n;a++){\n\t\t\t\t\tint pa = s&(1<<a);\n\t\t\t\t\tif(pa==(G&(1<<a)))continue;\n\t\t\t\t\tfor(int b=0;b<n;b++){\n\t\t\t\t\t\tif(a==b||(s&(1<<b))==(G&(1<<b)))continue;\n\t\t\t\t\t\tint w = dist[s][p]+Math.abs(p-a)+Math.abs(a-b);\n\t\t\t\t\t\tint pb = s&(1<<b), ns = s;\n\t\t\t\t\t\tif(pa>0)ns|=1<<b;\n\t\t\t\t\t\telse ns&=~(1<<b);\n\t\t\t\t\t\tif(pb>0)ns|=1<<a;\n\t\t\t\t\t\telse ns&=~(1<<a);\n\t\t\t\t\t\tif(w<dist[ns][b]){\n\t\t\t\t\t\t\tdist[ns][b] = w; q.add(ns*M+b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tchar c;\n\t\tchar p;\n\n\t\tS(int ss, char cc, char pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tchar used[][] = new char[(1 << 16)][16];\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, (char) 0, (char) sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(used[i], (char) 200);\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p] < now.c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(Integer.toBinaryString((1 << 10) + now.s)\n\t\t\t\t// + \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println((int) now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = (char) now.c;\n\n\t\t\t\tint nn = Integer.bitCount(now.s ^ g) / 2;\n\n\t\t\t\tint ii[] = new int[nn];\n\t\t\t\tint jj[] = new int[nn];\n\t\t\t\tint ind = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\tii[ind++] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tind = 0;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\tjj[ind++] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int z = 0; z < nn; z++) {\n\t\t\t\t\tint i = ii[z];\n\t\t\t\t\tint j = jj[z];\n\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\tint pos = j;\n\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost), (char) pos));\n\n\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\tpos = i;\n\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost), (char) pos));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "//package B_e;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tchar c;\n\t\tchar p;\n\n\t\tS(int ss, char cc, char pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tchar used[][] = new char[(1 << 16)][16];\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, (char) 0, (char) sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(used[i], (char) 200);\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p] < now.c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(Integer.toBinaryString((1 << 10) + now.s)\n\t\t\t\t// + \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println((int) now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = (char) now.c;\n\n\t\t\t\tint nn = Integer.bitCount(now.s ^ g) / 2;\n\n\t\t\t\tint ii[] = new int[nn];\n\t\t\t\tint jj[][] = new int[nn][2];\n\n\t\t\t\tint ind = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\tii[ind] = i;\n\t\t\t\t\t\tjj[ind][0] = -1;\n\t\t\t\t\t\tjj[ind][1] = -1;\n\t\t\t\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\tjj[ind][0] = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = i-1; j >= 0; j--) {\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\tjj[ind][1] = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tind++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int z = 0; z < nn; z++) {\n\t\t\t\t\tfor (int z2 = 0; z2 < 2; z2++) {\n\t\t\t\t\t\tint i = ii[z];\n\t\t\t\t\t\tint j = jj[z][z2];\n\t\t\t\t\t\tif(j==-1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost), (char) pos));\n\n\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\tq.add(new S(ns, (char) (now.c + cost), (char) pos));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Sort the Panels\npublic class Main{\n\n\tint[][] dist;\n\tint n, M = 20, INF = 1<<29, S, G;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar[] t1 = sc.next().toCharArray(), t2 = sc.next().toCharArray();\n\t\t\tS = 0; G = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tS+=t1[i]=='W'?1<<i:0; G+=t2[i]=='W'?1<<i:0;\n\t\t\t}\n\t\t\tdist = new int[1<<n][n];\n\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n//\t\t\t\t\tif(dist[o1/M][o1%M]==dist[o2/M][o2%M]){;\n//\t\t\t\t\tint c1 = 0, c2 = 0, v1 = o1/M, v2 = o2/M;\n//\t\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\t\tif((G&(1<<i))!=(v1&(1<<i)))c1++;\n//\t\t\t\t\t\tif((G&(1<<i))!=(v2&(1<<i)))c2++;\n//\t\t\t\t\t}\n//\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(c1+\" \"+c2);\n//\t\t\t\t\treturn c1-c2;\n//\t\t\t\t\t}\n\t\t\t\t\treturn dist[o1/M][o1%M]-dist[o2/M][o2%M];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdist[S][i] = 0; q.add(S*M+i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint V = q.poll();\n\t\t\t\tint s = V/M, p = V%M;\n//\t\t\t\tSystem.out.println(bi(s)+\" \"+bi(G));\n\t\t\t\tif(s==G){\n\t\t\t\t\tSystem.out.println(dist[s][p]); break;\n\t\t\t\t}\n\t\t\t\tfor(int a=0;a<n;a++){\n\t\t\t\t\tint pa = s&(1<<a);\n\t\t\t\t\tif(pa==(G&(1<<a)))continue;\n\t\t\t\t\tfor(int b=0;b<n;b++){\n\t\t\t\t\t\tif(a==b||(s&(1<<b))==(G&(1<<b)))continue;\n\t\t\t\t\t\tint w = dist[s][p]+Math.abs(p-a)+Math.abs(a-b);\n\t\t\t\t\t\tint pb = s&(1<<b), ns = s;\n\t\t\t\t\t\tif(pa>0)ns|=1<<b;\n\t\t\t\t\t\telse ns&=~(1<<b);\n\t\t\t\t\t\tif(pb>0)ns|=1<<a;\n\t\t\t\t\t\telse ns&=~(1<<a);\n\t\t\t\t\t\tif(w<dist[ns][b]){\n//\t\t\t\t\t\t\tq.remove(ns*M+b); \n\t\t\t\t\t\t\tdist[ns][b] = w; q.add(ns*M+b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"!!\");\n\t\t}\n\t}\n\n\tString bi(int s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(s>0){\n\t\t\tsb.append(s%2); s>>=1;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tchar c;\n\t\tchar p;\n\n\t\tS(int ss, char cc, char pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tchar used[][] = new char[(1 << 16)][16];\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, (char)0,(char) sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(used[i],(char)200);\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p] < now.c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(Integer.toBinaryString((1 << 10) + now.s)\n\t\t\t\t// + \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println((int)now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = (char)now.c;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\t\t\tq.add(new S(ns,  (char)( now.c + cost), (char)pos));\n\n\t\t\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, (char)(now.c + cost), (char)pos));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tint c;\n\t\tint p;\n\n\t\tS(int ss, int cc, int pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tchar used[][] = new char[(1 << 16)][16];\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, 0, sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(used[i],(char)200);\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p] < now.c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(Integer.toBinaryString((1 << 10) + now.s)\n\t\t\t\t// + \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println(now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = (char)now.c;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, now.c + cost, pos));\n\n\t\t\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (used[ns][pos] > now.c + cost)\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, now.c + cost, pos));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc;\n\n\tMain() {\n\t\tsc = new Scanner(System.in);\n\t}\n\n\tint encode(String a, int n) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret = ret << 1;\n\n\t\t\tif (a.charAt(i) == 'W') {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass S implements Comparable<S> {\n\t\tint s;\n\t\tint c;\n\t\tint p;\n\n\t\tS(int ss, int cc, int pp) {\n\t\t\ts = ss;\n\t\t\tc = cc;\n\t\t\tp = pp;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn c - tar.c;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tboolean used[][] = new boolean[(1 << 16)][16];\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString a = sc.next();\n\t\t\tString b = sc.next();\n\n\t\t\tint s = encode(a, n);\n\t\t\tint g = encode(b, n);\n\t\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\t\tfor (int sp = 0; sp < n; sp++) {\n\t\t\t\tif (((s ^ g) & (1 << sp)) != 0) {\n\t\t\t\t\tq.add(new S(s, 0, sp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(used[i],false);\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.err.println(\"err\");\n\t\t\t\t}\n\t\t\t\tS now = q.poll();\n\t\t\t\tif (used[now.s][now.p]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(Integer.toBinaryString((1 << 10) + now.s)\n\t\t\t\t// + \" \" + now.p + \" \" + now.c);\n\t\t\t\tif ((now.s) == g) {\n\t\t\t\t\tSystem.out.println(now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[now.s][now.p] = true;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\tif (((now.s & ~g) & shi) != 0) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tint shj = 1 << j;\n\t\t\t\t\t\t\tif (((~now.s & g) & shj) != 0) {\n\t\t\t\t\t\t\t\tint cost = Math.abs(i - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tint pos = j;\n\t\t\t\t\t\t\t\tint ns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (!used[ns][pos])\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, now.c + cost, pos));\n\n\t\t\t\t\t\t\t\tcost = Math.abs(j - now.p);\n\t\t\t\t\t\t\t\tcost += Math.abs(j - i);\n\t\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\t\tns = now.s - shi + shj;\n\t\t\t\t\t\t\t\tif (!used[ns][pos])\n\t\t\t\t\t\t\t\t\tq.add(new S(ns, now.c + cost, pos));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Python",
    "code": "while(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        before=[x for x in raw_input()]\n        after=[x for x in raw_input()]\n        location=-1\n        mark1=1\n        move=0\n        ii=0\n        i=0\n        while i<N:\n            if before[i]!=after[i]:\n                if mark1:\n                    mark1=0\n                    if location==-1:\n                        location=i\n                    else:\n                        move=abs(i-location)+move\n                        location=i\n                    ii=i\n                else:\n                    if before[i]!=before[ii]:\n                        mark1=1\n                        move=abs(i-location)+move\n                        location=i\n                        before[ii]=after[ii]\n                        before[i]=after[i]\n                        i=ii\n            i=i+1\n        print move"
  },
  {
    "language": "Python",
    "code": "while(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        before=[x for x in raw_input()]\n        after=[x for x in raw_input()]\n        location=-1\n        mark1=1\n        move=0\n        ii=0\n        i=0\n        while i<N:\n            if before[i]!=after[i]:\n                if mark1:\n                    mark1=0\n                    if location==-1:\n                        location=i\n                    else:\n                        move=abs(i-location)+move\n                        location=i\n                    ii=i\n                else:\n                    if before[i]!=before[ii]:\n                        mark1=1\n                        move=abs(i-location)+move\n                        location=i\n                        before[ii]=after[ii]\n                        before[i]=after[i]\n                        i=ii\n            i=i+1\n        print move"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};\nuse std::fmt::Display;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\n\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\nstruct BitSet {\n    mask: i32\n}\nimpl BitSet {\n    fn is_on(&self, value: i32) -> bool {\n        self.mask & (1 << value) != 0\n    }\n    fn set(&self, value: i32) -> BitSet {\n        BitSet{mask: self.mask | (1 << value)}\n    }\n    fn to_index(&self) -> usize {\n        self.mask as usize\n    }\n}\nfn abs(value: i32) -> i32 {\n    if value >= 0 {value}else {-value}\n}\nfn solve(current: usize, flag: BitSet, from: &Vec<char>, to: &Vec<char>, memo: &mut Vec<Vec<i32>>) -> i32 {\n    if memo[current][flag.to_index()] >= 0 {\n        memo[current][flag.to_index()]\n    }else {\n        let mut result = std::i32::MAX;\n        for i in 0 .. from.len() {\n            if !flag.is_on(i as i32) && from[i] != to[i] {\n                for j in 0 .. from.len() {\n                    if i != j && !flag.is_on(j as i32) && from[i] == to[j] && to[i] == from[j] {\n                        let temp = abs(i as i32 - current as i32) + abs(i as i32 - j as i32) + solve(j, flag.set(i as i32).set(j as i32), from, to, memo);\n                        if result > temp {\n                            result = temp;\n                        }\n                    }\n                }\n            }\n        }\n        memo[current][flag.to_index()] = result;\n        result\n    }\n}\nfn main() {\n    loop {\n        let_all!(n: usize);\n        if n == 0 {return;}\n        let from = read_line!().trim().chars().collect::<Vec<_>>();\n        let to = read_line!().trim().chars().collect::<Vec<_>>();\n        let mut flag = BitSet{mask: 0};\n        for i in 0 .. n {\n            if from[i] == to[i] {\n                flag = flag.set(i as i32);\n            }\n        }\n        let mut memo = vec![vec![-1; 1 << n]; n];\n        for i in 0 .. n {\n            memo[i][(1 << n) - 1] = 0;\n        }\n        let mut min_value = std::i32::MAX;\n        for i in 0 .. n {\n            if !flag.is_on(i as i32) {\n                let temp = solve(i, flag, &from, &to, &mut memo);\n                if min_value > temp {\n                    min_value = temp;\n                }\n            }\n        }\n        println!(\"{}\", min_value);\n    }\n}\n\n"
  }
]