[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn\n\nobject Main {\n\n  case class Point(x: Double = 0, y: Double = 0) {\n\n    def +(p: Point): Point = Point(this.x + p.x, this.y + p.y)\n\n    def -(p: Point): Point = Point(this.x - p.x, this.y - p.y)\n\n    def *(a: Double): Point = Point(this.x * a, this.y * a)\n\n    def /(a: Double): Point = {\n      assert(a != 0)\n      Point(this.x / a, this.y / a)\n    }\n\n    def norm(): Double = this.x * this.x + this.y * this.y\n\n    def abs(): Double = scala.math.sqrt(norm())\n\n    def <(p: Point): Boolean = this.x < p.x && this.y < p.y\n\n\n    def ==(p: Point): Boolean = scala.math.abs(this.x - p.x) < Cgl0A.EPS &&\n      scala.math.abs(this.y - p.y) < Cgl0A.EPS\n\n\n  }\n\n  case class Circle(center: Point, r: Int)\n\n  case class Segment(p1: Point, p2: Point)\n\n  case class Line(p1: Point, p2: Point)\n\n  type GeoVector = Point\n\n  object Cgl0A {\n    val EPS: Double = scala.math.pow(10, -10)\n\n    // 内積\n    def dot(a: Point, b: Point): Double = a.x * b.x + a.y * b.y\n\n    def isOrthogonal(a: GeoVector, b: GeoVector): Boolean = dot(a, b) == 0.0\n\n    def isOrthogonal(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isOrthogonal(a1 - a2, b1 - b2)\n    }\n\n    def isOrthogonal(s1: Segment, s2: Segment): Boolean = {\n      dot(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    // 外積\n    def cross(a: Point, b: Point): Double = a.x * b.y - a.y * b.x\n\n    def isParallel(a: GeoVector, b: GeoVector): Boolean = cross(a, b) == 0.0\n\n    def isParallel(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isParallel(a1 - a2, b1 - b2)\n    }\n\n    def isParallel(s1: Segment, s2: Segment): Boolean = {\n      cross(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    def project(s: Segment, p: Point): Point = {\n      val base: GeoVector = s.p2 - s.p1\n      val r: Double = Cgl0A.dot(p - s.p1, base) / base.norm()\n      s.p1 + base * r\n    }\n\n    def reflect(s: Segment, p: Point): Point = {\n      p + (project(s, p) - p) * 2.0\n    }\n\n    def getDistance(a: Point, b: Point): Double = (a - b).abs()\n\n    def getDistanceLP(l: Line, a: Point): Double = {\n      scala.math.abs(cross(l.p2 - l.p1, a - l.p1) / (l.p2 - l.p1).abs())\n    }\n\n    def getDistanceSP(s: Segment, a: Point): Double = {\n      if (dot(s.p2 - s.p1, a - s.p1) < 0.0) (a - s.p1).abs()\n      else if (dot(s.p1 - s.p2, a - s.p2) < 0.0) (a - s.p2).abs()\n      else getDistanceLP(Line(s.p1, s.p2), a)\n    }\n\n    def getDistance(s1: Segment, s2: Segment): Double = {\n      if (intersect(s1, s2)) {\n        0.0\n      }\n      else {\n        math.min(math.min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n          math.min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)))\n      }\n    }\n\n    val COUNTER_CLOCKWISE: Int = 1\n    val CLOCKWISE: Int = -1\n    val ONLINE_BACK: Int = 2\n    val ONLINE_FRONT: Int = -2\n    val ON_SEGMENT: Int = 0\n\n    def ccw(p0: Point, p1: Point, p2: Point): Int = {\n      val a: GeoVector = p1 - p0\n      val b: GeoVector = p2 - p0\n\n      if (cross(a, b) > EPS) COUNTER_CLOCKWISE\n      else if (cross(a, b) < -1 * EPS) CLOCKWISE\n      else if (dot(a, b) < -1 * EPS) ONLINE_BACK\n      else if (a.norm() < b.norm()) ONLINE_FRONT\n      else ON_SEGMENT\n\n    }\n\n    def intersect(p1: Point, p2: Point, p3: Point, p4: Point): Boolean = {\n      Cgl0A.ccw(p1, p2, p3) * Cgl0A.ccw(p1, p2, p4) <= 0 &&\n        Cgl0A.ccw(p3, p4, p1) * Cgl0A.ccw(p3, p4, p2) <= 0\n    }\n\n    def intersect(s1: Segment, s2: Segment): Boolean = {\n      Cgl0A.intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n    }\n\n    def getCrossPoint(s1: Segment, s2: Segment): Point = {\n      val base: GeoVector = s2.p2 - s2.p1\n      val d1 = scala.math.abs(cross(base, s1.p1 - s2.p2))\n      val d2 = scala.math.abs(cross(base, s1.p2 - s2.p1))\n      val t = d1 / (d1 + d2)\n      s1.p1 + (s1.p2 - s1.p1) * t\n    }\n\n    def getCrossPoint(c: Circle, l: Line): Array[Point] = {\n      val pr: GeoVector = project(Segment(l.p1, l.p2), c.center)\n      val e: GeoVector = (l.p2 - l.p1) / (l.p2 - l.p1).abs()\n      val base: Double = scala.math.sqrt(c.r * c.r - (pr - c.center).norm())\n      Array(pr + e * base, pr - e * base).sortBy(p => (p.x, p.y))\n    }\n\n    // arq tangent\n    def arg(p: GeoVector): Double = scala.math.atan2(p.y, p.x)\n\n    // \n    def polar(a: Double, r: Double): GeoVector = {\n      // x * 角度ラジアン\n      Point(scala.math.cos(r) * a, scala.math.sin(r) * a)\n    }\n\n    def getCrossPoint(c1: Circle, c2: Circle): Array[Point] = {\n      val d: Double = (c1.center - c2.center).abs()\n      val cos: Double = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d)\n      val a: Double = scala.math.acos(cos) // radian\n\n      val t: Double = arg(c2.center - c1.center) // radian\n      Array(c1.center + polar(c1.r, t + a),\n        c1.center + polar(c1.r, t - a)).sortBy(p => (p.x, p.y))\n\n    }\n\n    val IN: Int = 2\n    val ON: Int = 1\n    val OUT: Int = 0\n\n    def contains(g: IndexedSeq[Point], target: Point): Int = {\n      val n = g.size\n      var i = 0\n      var onJudge = false\n      var parity = false\n      while (!onJudge && i < n) {\n        var a: Point = g(i) - target\n        var b: Point = g((i + 1) % n) - target\n        if (cross(a, b).abs < EPS && dot(a, b) < EPS) {\n          onJudge = true\n        } else {\n          if (a.y > b.y) {\n            val temp = a\n            a = b\n            b = temp\n          }\n          parity = if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) !parity else parity\n        }\n        i += 1\n      }\n\n      if (onJudge) {\n        ON\n      } else {\n        if (parity) IN else OUT\n      }\n    }\n\n\n    def andrewScan(s: Array[Point]): Array[Point] = {\n      val u: ArrayBuffer[Point] = ArrayBuffer.empty[Point]\n      val l: ArrayBuffer[Point] = ArrayBuffer.empty[Point]\n\n      val sSize = s.length\n      if (sSize < 3) {\n        s\n      } else {\n        val temp = s.sortBy(p => (p.y, p.x))\n        u.append(temp(0))\n        u.append(temp(1))\n\n        l.append(temp(sSize - 1))\n        l.append(temp(sSize - 2))\n\n        (2 until sSize).foreach { i =>\n          var n = u.size\n          while (n >= 2 && ccw(u(n - 2), u(n - 1), temp(i)) == COUNTER_CLOCKWISE) {\n            u.remove(n - 1)\n            n -= 1\n          }\n          u.append(temp(i))\n        }\n\n        (sSize - 3 to 0 by -1).foreach { i =>\n          var n = l.size\n          while (n >= 2 && ccw(l(n - 2), l(n - 1), temp(i)) == COUNTER_CLOCKWISE) {\n            l.remove(n - 1)\n            n -= 1\n          }\n          l.append(temp(i))\n        }\n\n        //println(\"U: \" + u.toList)\n        //println(\"L: \" + l.toList)\n\n        val r: ArrayBuffer[Point] = l.reverse\n        u.reverse.slice(1, u.size - 1).foreach(e => r.append(e))\n\n        r.toArray\n      }\n\n    }\n\n    def manhattanIntersection(s: Array[Segment]): Int = {\n\n      val BOTTOM = 0\n      val LEFT = 1\n      val RIGHT = 2\n      val TOP = 3\n\n      case class EndPoint(p: Point, id: Int, place: Int)\n\n      var ep: ArrayBuffer[EndPoint] = ArrayBuffer.empty[EndPoint]\n\n      def swapJudge(p1: Point, p2: Point): Boolean = {\n        p1.y == p2.y && p1.x > p2.x || p1.y > p2.y\n      }\n\n\n      val n = s.length\n      (0 until n).foreach { i =>\n        s(i) = if (swapJudge(s(i).p1, s(i).p2)) {\n          Segment(s(i).p2, s(i).p1)\n        } else {\n          s(i)\n        }\n        \n        if (s(i).p1.y == s(i).p2.y) {\n          ep.append(EndPoint(s(i).p1, i, LEFT))\n          ep.append(EndPoint(s(i).p2, i, RIGHT))\n        } else {\n          ep.append(EndPoint(s(i).p1, i, BOTTOM))\n          ep.append(EndPoint(s(i).p2, i, TOP))\n        }\n      }\n\n      ep = ep.sortBy(e => (e.p.y, e.p.x))\n\n      val trset: mutable.TreeSet[Double] = mutable.TreeSet.empty[Double]\n\n      //println(ep.toList)\n\n      ep.foldLeft(0) { (acc, e) =>\n        //println(trset.toList)\n        if (e.place == TOP) {\n          trset.remove(e.p.x)\n          acc\n        } else if (e.place == BOTTOM) {\n          trset.add(e.p.x)\n          acc\n        } else if (e.place == LEFT) {\n          val r = trset.range(s(e.id).p1.x, s(e.id).p2.x)\n          //println(\"match:\" + r.toList)\n\n          acc + r.size\n        } else acc\n      }\n    }\n  }\n\n\n  def main(args: Array[String]): Unit = {\n    val n = StdIn.readLine().toInt\n    \n    val lines = (0 until n).map { _ =>\n      val points = StdIn.readLine().split(' ').map(_.toInt)\n      Segment(Point(points(0), points(1)), Point(points(2), points(3)))\n    }.toArray\n\n    val r = Cgl0A.manhattanIntersection(lines)\n    println(r)\n\n  }\n\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn\n\nobject Main {\n\n  case class Point(x: Double = 0, y: Double = 0) {\n\n    def +(p: Point): Point = Point(this.x + p.x, this.y + p.y)\n\n    def -(p: Point): Point = Point(this.x - p.x, this.y - p.y)\n\n    def *(a: Double): Point = Point(this.x * a, this.y * a)\n\n    def /(a: Double): Point = {\n      assert(a != 0)\n      Point(this.x / a, this.y / a)\n    }\n\n    def norm(): Double = this.x * this.x + this.y * this.y\n\n    def abs(): Double = scala.math.sqrt(norm())\n\n    def <(p: Point): Boolean = this.x < p.x && this.y < p.y\n\n\n    def ==(p: Point): Boolean = scala.math.abs(this.x - p.x) < Cgl0A.EPS &&\n      scala.math.abs(this.y - p.y) < Cgl0A.EPS\n\n\n  }\n\n  case class Circle(center: Point, r: Int)\n\n  case class Segment(p1: Point, p2: Point)\n\n  case class Line(p1: Point, p2: Point)\n\n  type GeoVector = Point\n\n  object Cgl0A {\n    val EPS: Double = scala.math.pow(10, -10)\n\n    // 内積\n    def dot(a: Point, b: Point): Double = a.x * b.x + a.y * b.y\n\n    def isOrthogonal(a: GeoVector, b: GeoVector): Boolean = dot(a, b) == 0.0\n\n    def isOrthogonal(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isOrthogonal(a1 - a2, b1 - b2)\n    }\n\n    def isOrthogonal(s1: Segment, s2: Segment): Boolean = {\n      dot(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    // 外積\n    def cross(a: Point, b: Point): Double = a.x * b.y - a.y * b.x\n\n    def isParallel(a: GeoVector, b: GeoVector): Boolean = cross(a, b) == 0.0\n\n    def isParallel(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isParallel(a1 - a2, b1 - b2)\n    }\n\n    def isParallel(s1: Segment, s2: Segment): Boolean = {\n      cross(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    def project(s: Segment, p: Point): Point = {\n      val base: GeoVector = s.p2 - s.p1\n      val r: Double = Cgl0A.dot(p - s.p1, base) / base.norm()\n      s.p1 + base * r\n    }\n\n    def reflect(s: Segment, p: Point): Point = {\n      p + (project(s, p) - p) * 2.0\n    }\n\n    def getDistance(a: Point, b: Point): Double = (a - b).abs()\n\n    def getDistanceLP(l: Line, a: Point): Double = {\n      scala.math.abs(cross(l.p2 - l.p1, a - l.p1) / (l.p2 - l.p1).abs())\n    }\n\n    def getDistanceSP(s: Segment, a: Point): Double = {\n      if (dot(s.p2 - s.p1, a - s.p1) < 0.0) (a - s.p1).abs()\n      else if (dot(s.p1 - s.p2, a - s.p2) < 0.0) (a - s.p2).abs()\n      else getDistanceLP(Line(s.p1, s.p2), a)\n    }\n\n    def getDistance(s1: Segment, s2: Segment): Double = {\n      if (intersect(s1, s2)) {\n        0.0\n      }\n      else {\n        math.min(math.min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n          math.min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)))\n      }\n    }\n\n    val COUNTER_CLOCKWISE: Int = 1\n    val CLOCKWISE: Int = -1\n    val ONLINE_BACK: Int = 2\n    val ONLINE_FRONT: Int = -2\n    val ON_SEGMENT: Int = 0\n\n    def ccw(p0: Point, p1: Point, p2: Point): Int = {\n      val a: GeoVector = p1 - p0\n      val b: GeoVector = p2 - p0\n\n      if (cross(a, b) > EPS) COUNTER_CLOCKWISE\n      else if (cross(a, b) < -1 * EPS) CLOCKWISE\n      else if (dot(a, b) < -1 * EPS) ONLINE_BACK\n      else if (a.norm() < b.norm()) ONLINE_FRONT\n      else ON_SEGMENT\n\n    }\n\n    def intersect(p1: Point, p2: Point, p3: Point, p4: Point): Boolean = {\n      Cgl0A.ccw(p1, p2, p3) * Cgl0A.ccw(p1, p2, p4) <= 0 &&\n        Cgl0A.ccw(p3, p4, p1) * Cgl0A.ccw(p3, p4, p2) <= 0\n    }\n\n    def intersect(s1: Segment, s2: Segment): Boolean = {\n      Cgl0A.intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n    }\n\n    def getCrossPoint(s1: Segment, s2: Segment): Point = {\n      val base: GeoVector = s2.p2 - s2.p1\n      val d1 = scala.math.abs(cross(base, s1.p1 - s2.p2))\n      val d2 = scala.math.abs(cross(base, s1.p2 - s2.p1))\n      val t = d1 / (d1 + d2)\n      s1.p1 + (s1.p2 - s1.p1) * t\n    }\n\n    def getCrossPoint(c: Circle, l: Line): Array[Point] = {\n      val pr: GeoVector = project(Segment(l.p1, l.p2), c.center)\n      val e: GeoVector = (l.p2 - l.p1) / (l.p2 - l.p1).abs()\n      val base: Double = scala.math.sqrt(c.r * c.r - (pr - c.center).norm())\n      Array(pr + e * base, pr - e * base).sortBy(p => (p.x, p.y))\n    }\n\n    // arq tangent\n    def arg(p: GeoVector): Double = scala.math.atan2(p.y, p.x)\n\n    // \n    def polar(a: Double, r: Double): GeoVector = {\n      // x * 角度ラジアン\n      Point(scala.math.cos(r) * a, scala.math.sin(r) * a)\n    }\n\n    def getCrossPoint(c1: Circle, c2: Circle): Array[Point] = {\n      val d: Double = (c1.center - c2.center).abs()\n      val cos: Double = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d)\n      val a: Double = scala.math.acos(cos) // radian\n\n      val t: Double = arg(c2.center - c1.center) // radian\n      Array(c1.center + polar(c1.r, t + a),\n        c1.center + polar(c1.r, t - a)).sortBy(p => (p.x, p.y))\n\n    }\n\n    val IN: Int = 2\n    val ON: Int = 1\n    val OUT: Int = 0\n\n    def contains(g: IndexedSeq[Point], target: Point): Int = {\n      val n = g.size\n      var i = 0\n      var onJudge = false\n      var parity = false\n      while (!onJudge && i < n) {\n        var a: Point = g(i) - target\n        var b: Point = g((i + 1) % n) - target\n        if (cross(a, b).abs < EPS && dot(a, b) < EPS) {\n          onJudge = true\n        } else {\n          if (a.y > b.y) {\n            val temp = a\n            a = b\n            b = temp\n          }\n          parity = if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) !parity else parity\n        }\n        i += 1\n      }\n\n      if (onJudge) {\n        ON\n      } else {\n        if (parity) IN else OUT\n      }\n    }\n\n\n    def andrewScan(s: Array[Point]): Array[Point] = {\n      val u: ArrayBuffer[Point] = ArrayBuffer.empty[Point]\n      val l: ArrayBuffer[Point] = ArrayBuffer.empty[Point]\n\n      val sSize = s.length\n      if (sSize < 3) {\n        s\n      } else {\n        val temp = s.sortBy(p => (p.y, p.x))\n        u.append(temp(0))\n        u.append(temp(1))\n\n        l.append(temp(sSize - 1))\n        l.append(temp(sSize - 2))\n\n        (2 until sSize).foreach { i =>\n          var n = u.size\n          while (n >= 2 && ccw(u(n - 2), u(n - 1), temp(i)) == COUNTER_CLOCKWISE) {\n            u.remove(n - 1)\n            n -= 1\n          }\n          u.append(temp(i))\n        }\n\n        (sSize - 3 to 0 by -1).foreach { i =>\n          var n = l.size\n          while (n >= 2 && ccw(l(n - 2), l(n - 1), temp(i)) == COUNTER_CLOCKWISE) {\n            l.remove(n - 1)\n            n -= 1\n          }\n          l.append(temp(i))\n        }\n\n        //println(\"U: \" + u.toList)\n        //println(\"L: \" + l.toList)\n\n        val r: ArrayBuffer[Point] = l.reverse\n        u.reverse.slice(1, u.size - 1).foreach(e => r.append(e))\n\n        r.toArray\n      }\n\n    }\n\n    def manhattanIntersection(s: Array[Segment]): Int = {\n\n      val BOTTOM = 0\n      val LEFT = 1\n      val RIGHT = 2\n      val TOP = 3\n\n      case class EndPoint(p: Point, id: Int, place: Int)\n\n      var ep: ArrayBuffer[EndPoint] = ArrayBuffer.empty[EndPoint]\n\n      def swapJudge(p1: Point, p2: Point): Boolean = {\n        p1.y == p2.y && p1.x > p2.x || p1.y > p2.y\n      }\n\n\n      val n = s.length\n      (0 until n).foreach { i =>\n        s(i) = if (swapJudge(s(i).p1, s(i).p2)) {\n          Segment(s(i).p2, s(i).p1)\n        } else {\n          s(i)\n        }\n        \n        if (s(i).p1.y == s(i).p2.y) {\n          ep.append(EndPoint(s(i).p1, i, LEFT))\n          ep.append(EndPoint(s(i).p2, i, RIGHT))\n        } else {\n          ep.append(EndPoint(s(i).p1, i, BOTTOM))\n          ep.append(EndPoint(s(i).p2, i, TOP))\n        }\n      }\n\n      ep = ep.sortBy(e => (e.p.y, e.place))\n\n      val trset: mutable.TreeSet[Double] = mutable.TreeSet.empty[Double]\n      \n      //println(ep.toList)\n\n      ep.foldLeft(0) { (acc, e) =>\n        //println(trset.toList)\n        if (e.place == TOP) {\n          trset.remove(e.p.x)\n          acc\n        } else if (e.place == BOTTOM) {\n          trset.add(e.p.x)\n          acc\n        } else if (e.place == LEFT) {\n          val r = trset.range(s(e.id).p1.x-0.1, s(e.id).p2.x+0.1)\n          //println(\"match:\" + r.toList)\n\n          acc + r.size\n        } else acc\n      }\n    }\n  }\n\n\n  def main(args: Array[String]): Unit = {\n    val n = StdIn.readLine().toInt\n    \n    val lines = (0 until n).map { _ =>\n      val points = StdIn.readLine().split(' ').map(_.toInt)\n      Segment(Point(points(0), points(1)), Point(points(2), points(3)))\n    }.toArray\n\n    val r = Cgl0A.manhattanIntersection(lines)\n    println(r)\n\n  }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\nconst int COUNTER_CLOCKWISE = 1, CLOCKWISE = -1, ONLINE_BACK = 2, ONLINE_FRONT = -2, ON_SEGMENT = 0;\nconst int IN = 2, ON = 1, OUT = 0;\nconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\nconst int MAXN = 1e5 + 7;\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point rhs) {\n\t\treturn Point(x + rhs.x, y + rhs.y);\n\t}\n\tPoint operator - (Point rhs) {\n\t\treturn Point(x - rhs.x, y - rhs.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tbool operator < (const Point& rhs) const {\n\t\treturn x != rhs.x ? x < rhs.x : y < rhs.y;\n\t}\n\tbool operator == (const Point& rhs) const {\n\t\treturn equals(x, rhs.x) && equals(y, rhs.y);\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\tbool operator < (const EndPoint& rhs) const {\n\t\tif (p.y == rhs.p.y) return st < rhs.st;\n\t\telse return p.y < rhs.p.y;\n\t}\n};\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0);\n}\nbool isOrthogonal(Segment a, Segment b) {\n\treturn isOrthogonal(Vector(a.p2.x - a.p1.x, a.p2.y - a.p1.y), Vector(b.p2.x - b.p1.x, b.p2.y - b.p1.y));\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0);\n}\nbool isParallel(Segment a, Segment b) {\n\treturn isParallel(Vector(a.p2.x - a.p1.x, a.p2.y - a.p1.y), Vector(b.p2.x - b.p1.x, b.p2.y - b.p1.y));\n}\nPoint project(Point p, Segment s) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + (base * r);\n}\nPoint reflect(Point p, Segment s) {\n\treturn p + (project(p, s) - p) * 2;\n}\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\telse if (cross(a, b) < -EPS) return CLOCKWISE;\n\telse if (dot(a, b) < -EPS) return ONLINE_BACK;\n\telse if (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn (ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0); \n}\ndouble getDistance(Point a, Point b) {\n\treturn (b - a).abs();\n}\ndouble getDistancePL(Point p, Line l) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\ndouble getDistancePS(Point p, Segment s) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n\telse if (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n\telse return getDistancePL(p, s);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0;\n\treturn min(min(getDistancePS(s2.p1, s1), getDistancePS(s2.p2, s1)), min(getDistancePS(s1.p1, s2), getDistancePS(s1.p2, s2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = fabs(cross(base, s1.p1 - s2.p1)), d2 = fabs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\npair<Point, Point> getCrossPoints(Line l, Circle c) {\n\tPoint pr = project(c.c, l);\n\tVector e = (l.p2 - l.p1) * (1 / (l.p2 - l.p1).abs());\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\tif (e.x > EPS || (fabs(e.x) < EPS && e.y > EPS)) return make_pair(pr - e * base, pr + e * base);\n\telse return make_pair(pr + e * base, pr - e * base);\n}\ndouble arg(Vector v) {\n\treturn atan2(v.y, v.x);\n}\nVector polar(double r, double theta) {\n\treturn Vector(r * cos(theta), r * sin(theta));\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs(), phi = acos((c1.r * c1.r + d * d - c2.r * c2.r) * (1 / (2 * c1.r * d)));\n\tdouble theta = arg(c2.c - c1.c);\n\tif (polar(c1.r, theta + phi).x > polar(c1.r, theta - phi).x || (equals(polar(c1.r, theta + phi).x, polar(c1.r, theta - phi).x) && polar(c1.r, theta + phi).y > polar(c1.r, theta - phi).y)) return make_pair(c1.c + polar(c1.r, theta - phi), c1.c + polar(c1.r, theta + phi));\n\telse return make_pair(c1.c + polar(c1.r, theta + phi), c1.c + polar(c1.r, theta - phi));\n}\nint contains(Point p, Polygon g) {\n\tint n = g.size();\n\tbool flag = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tVector a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && b.y > EPS && cross(a, b) > EPS) flag = !flag;\n\t}\n\treturn flag ? IN : OUT;\n}\nPolygon andrewScan(Polygon s) {\n\tint n = s.size();\n\tif (n < 3) return s;\n\tPolygon u, l;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[n - 1]);\n\tl.push_back(s[n - 2]);\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], s[i]) == COUNTER_CLOCKWISE; j--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = n - 3; i >= 0; i--) {\n\t\tfor (int j = l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], s[i]) == COUNTER_CLOCKWISE; j--) {\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) {\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\nEndPoint EP[2 * MAXN];\nint manhattanIntersection(vector<Segment> s) {\n\tint n = s.size();\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tif (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n\t\t}\n\t\telse if (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(s[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(s[i].p2, i, RIGHT);\n\t\t}\n\t\telse {\n\t\t\tEP[k++] = EndPoint(s[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(s[i].p2, i, TOP);\n\t\t}\n\t}\n\tsort(EP, EP + 2 * n);\n\tset<int> BT;\n\tBT.insert(1e9 + 7);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP) BT.erase(EP[i].p.x);\n\t\telse if (EP[i].st == BOTTOM) BT.insert(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int> :: iterator b = BT.lower_bound(s[EP[i].seg].p1.x), e = BT.upper_bound(s[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n    int n;\n    vector<Segment> s;\n    scanf(\"%d\", &n);\n    while (n--) {\n    \tint x, y;\n    \tPoint p1, p2;\n    \tscanf(\"%d%d\", &x, &y);\n    \tp1 = Point(x, y);\n    \tscanf(\"%d%d\", &x, &y);\n    \tp2 = Point(x, y);\n    \ts.push_back(Segment(p1, p2));\n\t}\n\tprintf(\"%d\\n\", manhattanIntersection(s));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n螺旋本 p371\n\ncircumcenter:\n    https://ja.wikipedia.org/wiki/%E5%A4%96%E6%8E%A5%E5%86%86#%E5%A4%96%E5%BF%83%E3%81%AE%E4%BD%8D%E7%BD%AE\n    https://mathtrain.jp/goshin\n\nassertを含む\n\nけんちょんさんのライブラリ\nhttps://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp\nei1333さんのライブラリ\nhttps://ei1333.github.io/luzhiled/snippets/geometry/template.html\n*/\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nconstexpr int MAX=1<<30;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\nusing DD=double;\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\nDD torad(DD deg){return deg*PI/180;}\nDD todeg(DD ang){return ang*180/PI;}\n\nstruct Point{\n    DD x,y;\n    Point(DD x=0.0,DD y=0.0): x(x),y(y){}\n\n    inline Point operator + (const Point &p){return Point(x+p.x,y+p.y);}\n    inline Point operator - (const Point &p){return Point(x-p.x,y-p.y);}\n    inline Point operator * (DD a){return Point(a*x,a*y);}\n    inline Point operator / (DD a){return Point(x/a,y/a);}\n\n    bool operator ==(const Point &p) const{\n        return abs(x-p.x)<EPS && abs(y-p.y)<EPS;\n    }\n\n    DD dis(){return sqrt(norm());} //ベクトルの長さ\n    DD norm(){return x*x+y*y;}\n\n};\ntypedef Point Vector;\n\n//線分\nstruct Segment{\n    Point p1,p2;\n    Segment(Point p1=Point(0.0,0.0),Point p2=Point(0.0,0.0)) : p1(p1),p2(p2){}\n    Segment(DD x1,DD y1,DD x2,DD y2) :p1(Point(x1,y1)),p2(Point(x2,y2)){}\n};\n//直線\ntypedef Segment Line;\n\n//多角形\ntypedef vector<Point> Polygon;\n//円\nstruct Circle{\n    Point c;\n    DD r;\n    Circle(Point c=0.0,DD r=0.0):c(c),r(r){}\n};\n\n/*++++++++基本計算++++++++++++++*/\n//内積\ninline DD dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\n//外積\ninline DD cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n//ベクトルpの傾きをラジアンで返す\ninline DD arg(Vector p){return atan2(p.y,p.x);}\n//長さa,角度r(ラジアン)\ninline Vector polar(DD a,DD r){return Vector(cos(r)*a,sin(r)*a);}\n//sortするときに必要\n//operatorに入れるのもアリ\ninline bool xy(const Point &a,const Point &b){\n    if(a.x+EPS<b.x) return true;\n    if(eq(a.x,b.x) && a.y+EPS<b.y) return true;\n    return false;\n}\ninline bool yx(const Point &a,const Point &b){\n    if(a.y+EPS<b.y) return true;\n    if(eq(a.y,b.y) && a.x+EPS<b.x) return true;\n    return false;\n}\ninline DD norm(Vector p){return p.x*p.x+p.y*p.y;}\n\n\n/*+++++++++++++++++++++射影++++++++++++++++++++*/\n//点pの射影\n//pからsに対して垂線を引いたときの交点\ninline Point project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    DD r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\n//線分sを対象軸としたときの、点pの線対称の点\ninline Point reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n\n\n/*++++++++++点との距離++++++++++++++++++*/\n//aとbの距離\n//点と点の距離\ninline DD dis(Point a,Point b){return (a-b).dis();}\n//点と直線の距離\ninline DD dis(Line l,Point p){return abs(cross(l.p2-l.p1,p-l.p1))/dis(l.p2,l.p1);}\n//線分と点の距離\ninline DD disSP(Segment s,Point p){\n    if( dot(s.p2-s.p1,p-s.p1)<0.0 ) return dis(p,s.p1);\n    if( dot(s.p1-s.p2,p-s.p2)<0.0 ) return dis(p,s.p2);\n    return dis(s,p); //点と直線の距離\n}\n\n/*++++++++++++++++関係(平行や直交)+++++++++++++++++*/\n//直交ならばtrue\n//内積が0ならcosθ=0を利用\ninline bool isOrthogonal(Vector a,Vector b){return eq(dot(a,b),0.0);}\n//4つの点　ベクトルa1-a2,ベクトルb1-b2が直交かどうか\ninline bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){return eq(dot(a1-a2,b1-b2),0.0);}\n//線分が直交かどうか\ninline bool isOrthogonal(Segment s1,Segment s2){return eq(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);}\n//平行ならばtrue\n//外積が0ならsinθ=0を利用\ninline bool isParallel(Vector a,Vector b){if(abs(cross(a,b))<EPS ) return true;else return false;}\n//4つの点　ベクトルa1-a2,ベクトルb1-b2が平行かどうか\ninline bool isParallel(Point a1,Point a2,Point b1,Point b2){return isParallel(a1-a2,b1-b2);}\n//線分が平行かどうか\ninline bool isParallel(Segment s1,Segment s2){return eq(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0 );}\n\n//線分p1-p2に対してp3がどこの位置にあるか？\n//反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(Point p1,Point p2,Point p3){\n    if(cross(p2-p1,p3-p1)>EPS) return 1;\n    if(cross(p2-p1,p3-p1)<-EPS) return -1;\n    else return 0;\n}\n\n//線分p1,p2に対してp3がどこの位置にあるか？\n//反時計回り:1　時計回り:-1 直線上(p1,p2,p3:-2 p1,p3,p2:0 p3,p1,p2:2) \ninline int ccwH(Point p1,Point p2,Point p3){\n    if(cross(p2-p1,p3-p1)>EPS) return 1;\n    if(cross(p2-p1,p3-p1)<-EPS) return -1;\n    if(dot(p2-p1,p3-p1)<0) return 2;\n    if((p2-p1).norm()<(p3-p1).norm()) return -2;\n    return 0;\n}\n\n/*+++++++++++線分と直線+++++++++++++++*/\n//線分p1-p2と線分p3-p4の交差判定\ninline bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccwH(p1,p2,p3)*ccwH(p1,p2,p4)<=0 && ccwH(p3,p4,p1)*ccwH(p3,p4,p2)<=0);\n}\n//線分s1,s2は交差するか？\ninline bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline Point crossPoint(Segment s1,Segment s2){\n    //assert(intersect(s1,s2)); \n    Vector base=s2.p2-s2.p1;\n    DD d1=abs(cross(base,s1.p1-s2.p1));\n    DD d2=abs(cross(base,s1.p2-s2.p1));\n    DD t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n//線分と線分の距離\ninline DD dis(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(disSP(s1,s2.p1),disSP(s1,s2.p2)),min(disSP(s2,s1.p1),disSP(s2,s1.p2)) );\n}\n//円cと直線lの交点\ninline pair<Point,Point> crossPoint(Circle c,Line l){\n    assert(dis(l,c.c)<c.r+EPS);\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(dis(l.p2,l.p1));\n    DD base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n//円と円の関係\n\n//共通接線の数\n//離れている:4 外接:3 交わる:2 内接:1 内包:0\ninline int intersect(Circle c1,Circle c2){\n    DD d=dis(c1.c,c2.c);\n    if(d>c1.r+c2.r+EPS) return 4;\n    if(eq(d,c1.r+c2.r)) return 3;\n    if(eq(d,abs(c1.r-c2.r))) return 1;\n    if(d<abs(c1.r-c2.r)-EPS) return 0;\n    return 2;\n}\n\n//円c1と円c2の交点\n//これを使う前に交点があるかどうかを判定する\ninline pair<Point,Point> crossPoint(Circle c1,Circle c2){\n    //assert(dis(c1.c,c2.c)<c1.r+c2.r+EPS);\n    DD d=dis(c1.c,c2.c);\n    DD a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    DD t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*+++++++++++++++++++三角形+++++++++++++++++*/\n//外心\n//isParallel()を使って判定を忘れずに\ninline Point circumcenter(Point A,Point B,Point C){\n    assert(!isParallel(A-B,A-C));\n    DD a=(B-C).norm();\n    DD b=(A-C).norm();\n    DD c=(A-B).norm();\n    return ( ( A*a*(b+c-a)+ B*b*(c+a-b)+ C*c*(a+b-c) )/  (a*(b+c-a)+ b*(c+a-b)+ c*(a+b-c) ) );\n}\n\n\n/*+++++++++++++++++++多角形+++++++++++++++++++*/\n//IN:2 ON:1 OUT:0\n//点がどのいちにあるか\nint contains(Polygon g,Point p){\n    int n=(int)g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Vector a=g[i]-p,b=g[(i+1)%n]-p;\n        if(eq(cross(a,b),0) && dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS && EPS<b.y && cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n//凸性判定\nbool isConvex(Polygon &g){\n    int n=(int)g.size();\n    int flag=0;\n    int t;\n    for(int i=0;i<n;i++){\n        Vector a(g[(i+1)%n]-g[i]),b(g[(i+2)%n]-g[i]);\n        if(cross(a,b)>EPS) t=1;\n        else if(cross(a,b)<-EPS) t=-1;\n        else continue;\n        if(flag==-t) return false;\n        flag=t;\n    }\n    return true;\n}\n\n//凸包　アンドリューのアルゴリズム\n//https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp←螺旋本より早そう\n//j=1:返上の点を含まない　j=-1:含む\n//反時計回りの多角形を返す\nPolygon ConvexHull(Polygon &s,int j){\n    int sz=(int)s.size();\n    if(sz<3) return s;\n    sort(s.begin(),s.end(),yx);\n\n    int n=0;\n    Polygon res(2*sz);\n    for(int i=0;i<sz;i++){\n        while(n>=2 && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    int t=n+1;\n    for(int i=sz-2;i>=0;i--){\n        while(n>=t && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    res.resize(n-1);\n    return res;\n}\n\n//符号付き面積\n//反時計回りの図形なら正\n//https://imagingsolution.net/math/calc_n_point_area/\nDD Area(const Polygon &g){\n    DD res=0.0;\n    int n=(int)g.size();\n    for(int i=0;i<n;i++){\n        res+=cross(g[i],g[(i+1)%n]);\n    }\n    return res/2.0L;\n}\n\n//反時計回り\n//理解が浅い←大体分かった（本当か？）\nDD Diameter(Polygon &g){\n    g=ConvexHull(g,1);\n    int gz=g.size();\n    int m=0,M=0;\n    for(int i=1;i<gz;i++){\n        if(g[i].x<g[m].x) m=i;\n        if(g[i].x>g[M].x) M=i;\n    }\n    DD ret=0;\n    int sm=m,sM=M;\n    while(m!=sM || M!=sm){\n        ret=max(ret,norm(g[m]-g[M]));\n        if(cross(g[(m+1)%gz]-g[m],g[(M+1)%gz]-g[M])<0) m=(m+1)%gz;\n        else M=(M+1)%gz;\n    }\n    return sqrt(ret);\n}\n\n//凸多角形gをlで切断\n//l.p1-l.p2の左側\n//gは反時計回り→反時計回りで返す\n//時計回り→時計回り\n//けんちょんさんのが長かった→読んでおきたい\nPolygon ConvexCut(const Polygon &g,Line l){\n    Polygon ret;\n    int gz=(int)g.size();\n    for(int i=0;i<gz;i++){\n        Point now=g[i],next=g[(i+1)%gz];\n        if(ccw(l.p1,l.p2,now)>=0) ret.push_back(now);\n        if(ccw(l.p1,l.p2,now)*ccw(l.p1,l.p2,next)<0){\n            ret.push_back(crossPoint(Line(now,next),l));\n        }\n    }\n    return ret;\n}\n\n//++++なんか凄いの+++++++++++++++\n\n//最近点対\nDD RecClosetPair(Polygon::iterator it,int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    DD x=it[m].x;\n    DD d=min(RecClosetPair(it,m),RecClosetPair(it+m,n-m));\n    inplace_merge(it,it+m,it+n,yx);\n    Polygon v;\n    for(int i=0;i<n;i++){\n        if(abs(it[i].x-x)>=d) continue;\n        for(int j=0;j<v.size();j++){\n            DD dy=it[i].y-v[v.size()-1-j].y;\n            if(dy>=d) break;\n            DD dx=it[i].x-v[v.size()-1-j].x;\n            d=min(d,sqrt(dx*dx+dy*dy));\n        }\n        v.push_back(it[i]);\n    }\n    return d;\n}\n\nDD ClosetPair(Polygon g){\n    sort(g.begin(),g.end(),xy);\n    return RecClosetPair(g.begin(),g.size());\n}\n\nstruct EndPoint{\n    Point p;\n    int seg,st; //入力線分の種類,単点の種類\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n        if(eq(p.y,ep.p.y)){\n            return st<ep.st; //yが同一の場合は、下端点→左単点→右単点→上単点の順に調べる\n        }else return p.y<ep.p.y;\n    }\n};\n\nEndPoint EP[2*100000];\n\n//誤差が少し不安\n//マンハッタン幾何　線分交差\nint manhattanIntersection(vector<Segment> S){\n    int sz=S.size();\n\n    for(int i=0,k=0;i<sz;i++){\n        //p1が左下を選ぶようにする\n        if(eq(S[i].p1.y,S[i].p2.y)){\n            if(S[i].p1.x>S[i].p2.x) swap(S[i].p1,S[i].p2);\n        }else if(S[i].p1.y>S[i].p2.y) swap(S[i].p1,S[i].p2);\n\n        if(eq(S[i].p1.y,S[i].p2.y)){\n            EP[k++]=EndPoint(S[i].p1,i,1);\n            EP[k++]=EndPoint(S[i].p2,i,2);\n        }else{\n            EP[k++]=EndPoint(S[i].p1,i,0);\n            EP[k++]=EndPoint(S[i].p2,i,3);\n        }\n    }\n\n    sort(EP,EP+2*sz);\n\n    set<DD> BT;\n    BT.insert(1000000001);\n    int cnt=0;\n\n    for(int i=0;i<2*sz;i++){\n        if(EP[i].st==3){\n            BT.erase(EP[i].p.x);\n        }else if(EP[i].st==0){\n            BT.insert(EP[i].p.x);\n        }else if(EP[i].st==1){\n            auto b=BT.lower_bound(S[EP[i].seg].p1.x);\n            auto e=BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt+=distance(b,e);\n        }\n    }\n    return cnt;\n}\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n\n    int n;\n    cin>>n;\n    Polygon g;\n    vector<Segment> vs;\n    for(int i=0;i<n;i++){\n        DD x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        vs.emplace_back(x1,y1,x2,y2);\n    }\n    cout<<manhattanIntersection(vs)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define INF 1e9\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int opt,l,r,x;}f[N*3];\nstruct seg{int ls,rs,su;}t[10000010];\nint nf,q,p1,p2,q1,q2,ansn,ro,num;\nbool comp(const Info &a,const Info &b){if (a.x==b.x) return a.opt<b.opt;return a.x<b.x;}\nint pa(int x){if (x>=0) return x/2;return (x-1)/2;}\nvoid add(int &nu,int l,int r,int we,int x){\n\tif (!nu) nu=++num;\n\tt[nu].su+=x;\n\tif (l!=r){\n\t\tint mid=pa(l+r);\n\t\tif (we<=(l+r)/2) add(t[nu].ls,l,mid,we,x);\n\t\telse add(t[nu].rs,mid+1,r,we,x);\n\t}\n}\nint que(int nu,int l,int r,int nl,int nr){\n\tif (!nu) return 0;\n\tif (l==nl&&r==nr) return t[nu].su;\n\tint mid=pa(l+r);\n\tif (nl>mid)return que(t[nu].rs,mid+1,r,nl,nr);\n\tif (nr<=mid) return que(t[nu].ls,l,mid,nl,nr);\n\treturn que(t[nu].ls,l,mid,nl,mid)+que(t[nu].rs,mid+1,r,mid+1,nr);\n}\nint main(){\n\tread(q);\n\tfor (int i=1;i<=q;i++){\n\t\tread(p1);read(q1);read(p2);read(q2);\n\t\tif (p1==p2){\n\t\t\tif (q1>q2) swap(q1,q2);\n\t\t\tf[++nf].opt=1;f[nf].l=p1;f[nf].x=q1;\n\t\t\tf[++nf].opt=-1;f[nf].l=p1;f[nf].x=q2+1;\n\t\t}else{\n\t\t\tif (p1>p2) swap(p1,p2);\n\t\t\tf[++nf].opt=2;f[nf].l=p1;f[nf].r=p2;f[nf].x=q1;\n\t\t}\n\t}\n\tsort(f+1,f+nf+1,comp);\n\tfor (int i=1;i<=nf;i++){\n\t\tif (f[i].opt==2)ansn+=que(ro,-INF,INF,f[i].l,f[i].r);\n\t\telse add(ro,-INF,INF,f[i].l,f[i].opt);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n// typedef tuple<int, int, int> T;\n#define FOR(i, s, x) for (int i = s; i < (int)(x); i++)\n#define REP(i, x) FOR(i, 0, x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP(x) cerr << #x << \" = \" << (x) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct RangeSumQuery {\n  int N;\n  std::vector<T> dat;\n\n  RangeSumQuery(int N) : N(N) {\n    assert(N > 0);\n    dat.resize(N, 0);\n  }\n\n  void add(int k, T val) {\n    assert(0 <= k && k < N);\n    for (int x = k; x < N; x |= x + 1) {\n      dat[x] += val;\n    }\n  }\n\n  // [0, k)\n  T sum(int k) {\n    assert(k >= 0);\n    T ret = 0;\n    for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) {\n      ret += dat[x];\n    }\n    return ret;\n  }\n  // [l, r)\n  T sum(int l, int r) {\n    assert(0 <= l && l <= r && r <= N);\n    return sum(r) - sum(l);\n  }\n\n  T index(int k) {\n    assert(0 <= k && k < N);\n    return sum(k + 1) - sum(k);\n  }\n};\n\nvoid compress(vector<int> &arr1, vector<int> &arr2) {\n  vector<int> tmp;\n  for (int x : arr1) tmp.emplace_back(x);\n  for (int x : arr2) tmp.emplace_back(x);\n  UNIQUE(tmp);\n  map<int, int> mp;\n  REP(i, tmp.size()) mp[tmp[i]] = i;\n  REP(i, arr1.size()) arr1[i] = mp[arr1[i]];\n  REP(i, arr2.size()) arr2[i] = mp[arr2[i]];\n}\n\nint main() {\n  int N;\n  cin >> N;\n  vector<int> X1(N), X2(N), Y1(N), Y2(N);\n  REP(i, N) cin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n  compress(Y1, Y2);\n\n  vector<tuple<int, int, int>> events;\n\n  REP(i, N) {\n    if (X1[i] > X2[i]) swap(X1[i], X2[i]);\n    if (Y1[i] > Y2[i]) swap(Y1[i], Y2[i]);\n\n    if (X1[i] == X2[i]) {\n      events.emplace_back(X1[i], 1, i);\n    } else {\n      events.emplace_back(X1[i], 0, i);\n      events.emplace_back(X2[i], 2, i);\n    }\n  }\n\n  sort(ALL(events));\n\n  ll ans = 0;\n  RangeSumQuery<ll> rsq(N);\n  for (auto event : events) {\n    int t, idx;\n    tie(ignore, t, idx) = event;\n    if (t == 0) {\n      rsq.add(Y1[idx], 1);\n    } else if (t == 1) {\n      ans += rsq.sum(Y1[idx], min(N, Y2[idx] + 1));\n    } else {\n      rsq.add(Y1[idx], -1);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nstruct EndPoint {\n    enum Kind {\n        BOTTOM = 0,\n        HORIZ  = 1,\n        TOP    = 2,\n    };\n\n    i64  y;\n    Kind kind;\n    i64  l, r;  // [l,r]\n\n    static vector<EndPoint> from_segs(const vector<tuple<i64,i64,i64,i64>>& segs) {\n        vector<EndPoint> res;\n        res.reserve(2*SIZE(segs));\n        for(const auto& seg : segs) {\n            i64 x1,y1,x2,y2; tie(x1,y1,x2,y2) = seg;\n            if(x1 == x2) {\n                res.emplace_back(min(y1,y2), BOTTOM, x1, x1);\n                res.emplace_back(max(y1,y2), TOP,    x1, x1);\n            }\n            else if(y1 == y2) {\n                res.emplace_back(y1, HORIZ, min(x1,x2), max(x1,x2));\n            }\n            else {\n                assert(false);\n            }\n        }\n        return res;\n    }\n\n    EndPoint(i64 yy, Kind kk, i64 ll, i64 rr) : y(yy), kind(kk), l(ll), r(rr) {}\n};\n\nbool operator<(const EndPoint& lhs, const EndPoint& rhs) {\n    return make_pair(lhs.y, lhs.kind) < make_pair(rhs.y, rhs.kind);\n}\n\nvoid solve() {\n    i64 N; RD(N);\n    vector<tuple<i64,i64,i64,i64>> segs;\n    segs.reserve(N);\n\n    REP(_, N) {\n        i64 x1,y1,x2,y2; RD(x1); RD(y1); RD(x2); RD(y2);\n        segs.emplace_back(x1,y1,x2,y2);\n    }\n\n    vector<EndPoint> ps = EndPoint::from_segs(segs);\n    ALL(sort, ps);\n\n    i64 ans = 0;\n    set<i64> scan;\n    for(const EndPoint& p : ps) {\n        switch(p.kind) {\n        case EndPoint::BOTTOM:\n            scan.emplace(p.l);\n            break;\n        case EndPoint::TOP:\n            scan.erase(p.l);\n            break;\n        case EndPoint::HORIZ:\n            auto l = scan.lower_bound(p.l);\n            auto r = scan.upper_bound(p.r);\n            ans += distance(l, r);\n            break;\n        }\n    }\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n// 2659723130\n// 《幽灵公主》是真的好看！\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << (x) << endl;\n#define o(x) cerr << #x << \" \" << (x) << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293*time(0));\t// さん\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#undef ld\n#define ld long double\nconst ld Eps = 1e-10;\nstruct Point{ ld x,y; };\nil Point operator+( const Point &a , const Point &b ){ return {a.x+b.x,a.y+b.y}; }\nil Point operator-( const Point &a , const Point &b ){ return {a.x-b.x,a.y-b.y}; }\nil auto operator^( const Point &a , const Point &b ){ return a.x*b.x + a.y*b.y; }\nil auto operator*( const Point &a , const Point &b ){ return a.x*b.y - b.x*a.y; }\nil Point operator*( const Point &a , const ld &b ){ return {a.x*b,a.y*b}; }\nil bool operator==( const Point &a , const Point &b ){ return a.x == b.x and a.y == b.y; }\nil ld Dis( const Point &a , const Point &b ){ return sqrt((ld)Sqr(a.x-b.x)+Sqr(a.y-b.y)); }\nil ld Dis2( const Point &a , const Point &b ){ return Sqr(a.x-b.x)+Sqr(a.y-b.y); }\nostream& operator<<( ostream &out , const Point &p ){\n\tout << p.x << \" \" << p.y << \"  \";\n\treturn out;\n}\nil bool OnSeg( const Point &a , const Point &b , const Point &c ){\n\tPoint ab = b-a, ac = c-a;\n\tif( fabs(ab*ac) > Eps ) return 0;\n\tif( (ab^ac) < -Eps ) return 0;\n\tif( fabs(ab.y*ab.y+ab.x*ab.x) > fabs(ac.y*ac.y+ac.x*ac.x) ) return 0;\n\t// cout << a.x << \" \" << a.y << \"  \" << b.x << \" \" << b.y << \"  \" << c.x << \" \" << c.y << endl;\n\treturn 1;\n}\nbool Ins( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif( p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 ) return 1;\n\tif( OnSeg(p1,p3,p2) or OnSeg(p1,p4,p2) or OnSeg(p3,p1,p4) or OnSeg(p3,p2,p4) ) return 1;\n\tif( ((p2-p1)*(p3-p1)<-Eps) == ((p2-p1)*(p4-p1)<-Eps) ) return 0;\n\tif( ((p4-p3)*(p1-p3)<-Eps) == ((p4-p3)*(p2-p3)<-Eps) ) return 0;\n\treturn 1;\n}\nPoint InsPoint( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tld d1 = (ld)abs((p2-p3)*(p3-p1)) / Dis(p1,p2);\n\tld d2 = (ld)abs((p2-p4)*(p4-p1)) / Dis(p1,p2);\n\tld ratio = d1 / (d1+d2);\n\treturn (p4-p3)*ratio + p3;\n}\nPoint H( Point a , Point b , Point p ){\n\tPoint ab = b-a;\n\tld dis2 = Dis2(a,b);\n\tPoint ret = a + ab * (((p-a)^ab)/dis2);\n\treturn ret;\n}\nld Distance( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif(Ins(p1,p2,p3,p4)) return 0;\n\tld ans = min({ Dis(p1,p3) , Dis(p1,p4) , Dis(p2,p3) , Dis(p2,p4) });\n\tauto Check = [&]( Point a , Point b , Point p ){\n\t\tPoint h = H(a,b,p);\n\t\tif(!OnSeg(a,h,b)) return;\n\t\tld tans = Dis(h,p);\n\t\tMymin(ans,tans);\n\t};\n\tCheck(p1,p2,p3);\n\tCheck(p1,p2,p4);\n\tCheck(p3,p4,p1);\n\tCheck(p3,p4,p2);\n\treturn ans;\n}\n\nconst int MAXN = 131072;\n\nint n;\n\nstruct Event{\n\tint type;\t// 0: query, else: add\n\tint x,yl,yr;\n};\nvc<Event> events;\n\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n){\n\t\tiRead4(x1,y1,x2,y2);\n\t\tif( y1 == y2 ){\n\t\t\tif( x1 > x2 ) swap(x1,x2);\n\t\t\tevents.Pb({1,x1,y1,y1});\n\t\t\tevents.Pb({-1,x2,y1,y1});\n\t\t}else{\n\t\t\tif( y1 > y2 ) swap(y1,y2);\n\t\t\tevents.Pb({0,x1,y1,y2});\n\t\t}\n\t}\n\n\tsort(All(events),[]( const Event &a , const Event &b ){\n\t\tif( a.x != b.x ) return a.x < b.x;\n\t\treturn a.type > b.type;\n\t});\n\n\tll ans = 0;\n\tstatic vc<int> having;\n\tfor( auto e : events ){\n\t\tint type = e.type, x = e.x, y1 = e.yl, y2 = e.yr;\n\t\tif( type == 1 ){\n\t\t\tauto po = lower_bound(All(having),y1);\n\t\t\thaving.insert(po,y1);\n\t\t}elif( type == -1 ){\n\t\t\tauto po = lower_bound(All(having),y1);\n\t\t\tassert( *po == y1 );\n\t\t\thaving.erase(po);\n\t\t}else{\n\t\t\tauto p1 = lower_bound(All(having),y1);\n\t\t\tauto p2 = upper_bound(All(having),y2);\n\t\t\tans += p2-p1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\tEND();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200002;\nint BIT[MAX_SIZE];\n\nvoid add(int i, int x)\n{\n\twhile (i <= MAX_SIZE)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntemplate <class Type>\nclass BIT {\nprivate:\n\tsize_t size_; std::vector<Type> v;\n\tType sum(size_t r) { Type ret = 0; while (r > 0) ret += v[r], r -= r & (-r); return ret; }\npublic:\n\tBIT() {};\n\tBIT(size_t size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(size_t i, Type x) { i++; while (i <= size_) v[i] += x, i += i & -i; }\n\tinline Type sum(size_t l, size_t r) { return sum(r) - sum(l); }\n\tbool operator[](size_t x) { return sum(x, x + 1); }\n};\n\nint n, xa[111111], ya[111111], xb[111111], yb[111111], xc[222222], yc[222222], cx, cy;\nvector<int> q1[222222], q2[222222], q3[222222], q4[222222];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xa[i] >> ya[i] >> xb[i] >> yb[i];\n\t\tif (xa[i] > xb[i]) swap(xa[i], xb[i]);\n\t\tif (ya[i] > yb[i]) swap(ya[i], yb[i]);\n\t\txc[cx++] = xa[i]; xc[cx++] = xb[i];\n\t\tyc[cy++] = ya[i]; yc[cy++] = yb[i];\n\t}\n\tsort(xc, xc + cx);\n\tcx = unique(xc, xc + cx) - xc;\n\tsort(yc, yc + cy);\n\tcy = unique(yc, yc + cy) - yc;\n\tfor (int i = 0; i < n; i++) {\n\t\txa[i] = lower_bound(xc, xc + cx, xa[i]) - xc;\n\t\tya[i] = lower_bound(yc, yc + cy, ya[i]) - yc;\n\t\txb[i] = lower_bound(xc, xc + cx, xb[i]) - xc;\n\t\tyb[i] = lower_bound(yc, yc + cy, yb[i]) - yc;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ya[i] == yb[i]) {\n\t\t\tq1[ya[i]].push_back(xa[i]); // yoko - left\n\t\t\tq2[yb[i]].push_back(xb[i]); // yoko - right\n\t\t}\n\t\telse {\n\t\t\tq3[ya[i]].push_back(xa[i]); // tate - in\n\t\t\tq4[yb[i]].push_back(xb[i]); // tate - out\n\t\t}\n\t}\n\tBIT<int> b(cx);\n\tlong long ret = 0;\n\tfor (int i = 0; i < cy; i++) {\n\t\tfor (int j = 0; j < q3[i].size(); j++) b.add(q3[i][j], 1);\n\t\tfor (int j = 0; j < q1[i].size(); j++) ret += b.sum(q1[i][j], q2[i][j]);\n\t\tfor (int j = 0; j < q4[i].size(); j++) b.add(q4[i][j], -1);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<unordered_map>\n\n#define MAX (200000 + 1)\n\nusing namespace std;\n\nint t[MAX], N;\n\nstruct segment\n{\n    bool vertical;\n    bool start;\n    int x, y1, y2;\n};\n\nvector<segment> space;\nset<int> appear;\nunordered_map<int, int> index;\n\nint sum(int n)\n{\n    int s = 0;\n    while(n > 0)\n    {\n        s += t[n];\n        n -= n & -n;\n    }\n    return s;\n}\n\nvoid add(int n, int d)\n{\n    while(n <= N)\n    {\n        t[n] += d;\n        n += n & -n;\n    }\n    return;\n}\n\nint query(int a, int b)\n{\n    return sum(b) - sum(a - 1);\n}\n\nbool cmp(const segment& a, const segment& b)\n{\n    if(a.x == b.x) // true if a goes first\n    {\n        if(a.vertical && !b.vertical && b.start) return false;\n        else if(a.vertical && !b.vertical && !b.start) return true;\n        else if(!a.vertical && a.start && b.vertical) return true;\n        else if(!a.vertical && a.start && !b.vertical && !b.start) return true;\n        else if(!a.vertical && !a.start && b.vertical) return false;\n        else if(!a.vertical && !a.start && !b.vertical && b.start) return false;\n    }\n    return a.x < b.x;\n}\n\nint main()\n{\n    int n;\n    int ans = 0;\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        int x1, x2, y1, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        appear.insert(y1);\n        appear.insert(y2);\n        if(y1 == y2)\n        {\n            segment tmp1, tmp2;\n            tmp1.vertical = false;\n            tmp2.vertical = false;\n            tmp1.start = true;\n            tmp2.start = false;\n            tmp1.y1 = tmp1.y2 = y1;\n            tmp2.y1 = tmp2.y2 = y1;\n            tmp1.x = min(x1, x2);\n            tmp2.x = max(x1, x2);\n            space.push_back(tmp1);\n            space.push_back(tmp2);\n        }\n        else\n        {\n            segment tmp;\n            tmp.vertical = true;\n            tmp.x = x1;\n            tmp.y1 = min(y1, y2);\n            tmp.y2 = max(y1, y2);\n            space.push_back(tmp);\n        }\n    }\n    set<int>::iterator it = appear.begin();\n    for(int i = 0; i < appear.size(); ++i)\n    {\n        index[*it] = i + 1;\n        it++;\n    }\n    N = appear.size();\n\n    sort(space.begin(), space.end(), cmp);\n    for(int i = 0; i < space.size(); ++i)\n    {\n        if(space[i].vertical) ans += query(index[space[i].y1], index[space[i].y2]);\n        else if(space[i].start) add(index[space[i].y1], 1);\n        else add(index[space[i].y1], -1);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class BIT {\nprivate:\n\tint n; vector<V> bit;\npublic:\n\tvoid add(int i,V x){ i++; while(i < n) bit[i] += x, i += i & -i;}\n\tV sum(int i){ i++; V s = 0; while(i>0) s += bit[i], i -= i & -i; return s;} //0_indexedでi以下の要素の和\n\tBIT(){} BIT(int sz){ n = sz + 1, bit.resize(n,0);} //初期値がすべて0の場合\n\tBIT(vector<V> v){ n = (int)v.size()+1; bit.resize(n); rep(i,n-1) add(i,v[i]);}\n\tvoid print(){ rep(i,n-1)cout<<sum(i)-sum(i-1)<< \" \";cout<<endl;}\n\tvoid print_sum(){ rep(i,n)cout<<sum(i-1)<<\" \";cout<<endl;}\t//-1スタート\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<int> X(2*n),Y(2*n);\n    vector<int> a(n),b(n),c(n),d(n);\n    rep(i,n){\n        cin >> a[i] >> b[i] >> c[i] >> d[i];\n        if(a[i] > c[i]) swap(a[i],c[i]);\n        if(b[i] > d[i]) swap(b[i],d[i]);\n        X[2*i] = a[i], X[2*i+1] = c[i];\n        Y[2*i] = b[i], Y[2*i+1] = d[i];\n    }\n    zip(X),zip(Y);\n    vector<vector<int> > st(len(Y)),ed(len(Y));\n    vector<vector<P> > ch(len(Y));\n    rep(i,n){\n        if(a[i] != c[i]){\n            //横線\n            ch[lower_bound(all(Y),b[i])-Y.begin()].pb(P(lower_bound(all(X),a[i])-X.begin(),lower_bound(all(X),c[i])-X.begin()));\n        }else{\n            //縦線\n            st[lower_bound(all(Y),b[i])-Y.begin()].pb(lower_bound(all(X),a[i])-X.begin());\n            ed[lower_bound(all(Y),d[i])-Y.begin()].pb(lower_bound(all(X),a[i])-X.begin());\n        }\n    }\n    int ans = 0;\n    BIT<int> bt(len(X));\n    rep(i,len(Y)){\n        each(j,st[i]){\n            bt.add(j,1);\n        }\n        each(j,ch[i]){\n            ans += bt.sum(j.se) - bt.sum(j.fi-1);\n        }\n        each(j,ed[i]){\n            bt.add(j,-1);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4146)\nusing namespace std;\ntemplate <class Type>\nclass BIT {\nprivate:\n\tsize_t size_; std::vector<Type> v;\n\tType sum(size_t r) { Type ret = 0; while (r > 0) ret += v[r], r -= r & (-r); return ret; }\npublic:\n\tBIT() {};\n\tBIT(size_t size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(size_t i, Type x) { i++; while (i <= size_) v[i] += x, i += i & -i; }\n\tinline Type sum(size_t l, size_t r) { return sum(r) - sum(l); }\n\tbool operator[](size_t x) { return sum(x, x + 1); }\n};\n\nint n, xa[111111], ya[111111], xb[111111], yb[111111], xc[222222], yc[222222], cx, cy;\nvector<int> q1[222222], q2[222222], q3[222222], q4[222222];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xa[i] >> ya[i] >> xb[i] >> yb[i];\n\t\tif (xa[i] > xb[i]) swap(xa[i], xb[i]);\n\t\tif (ya[i] > yb[i]) swap(ya[i], yb[i]);\n\t\txc[cx++] = xa[i]; xc[cx++] = xb[i];\n\t\tyc[cy++] = ya[i]; yc[cy++] = yb[i];\n\t}\n\tsort(xc, xc + cx);\n\tcx = unique(xc, xc + cx) - xc;\n\tsort(yc, yc + cy);\n\tcy = unique(yc, yc + cy) - yc;\n\tfor (int i = 0; i < n; i++) {\n\t\txa[i] = lower_bound(xc, xc + cx, xa[i]) - xc;\n\t\tya[i] = lower_bound(yc, yc + cy, ya[i]) - yc;\n\t\txb[i] = lower_bound(xc, xc + cx, xb[i]) - xc;\n\t\tyb[i] = lower_bound(yc, yc + cy, yb[i]) - yc;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ya[i] == yb[i]) {\n\t\t\tq1[ya[i]].push_back(xa[i]); // yoko - left\n\t\t\tq2[yb[i]].push_back(xb[i]); // yoko - right\n\t\t}\n\t\telse {\n\t\t\tq3[ya[i]].push_back(xa[i]); // tate - in\n\t\t\tq4[yb[i]].push_back(xb[i]); // tate - out\n\t\t}\n\t}\n\tBIT<int> b(cx);\n\tlong long ret = 0;\n\tfor (int i = 0; i < cy; i++) {\n\t\tfor (int j = 0; j < q3[i].size(); j++) b.add(q3[i][j], 1);\n\t\tfor (int j = 0; j < q1[i].size(); j++) ret += b.sum(q1[i][j], q2[i][j] + 1);\n\t\tfor (int j = 0; j < q4[i].size(); j++) b.add(q4[i][j], -1);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n \n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n \n/*????????????(???§??¨?)????????????*/\nclass Vector\n{\npublic:\n    double x,y;\n    Vector(double x=0,double y=0):x(x),y(y){}\n     \n    Vector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n    Vector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n    Vector operator * (double a){return Vector(x*a,y*a);}\n    Vector operator / (double a){return Vector(x/a,y/a);}\n     \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n     \n    bool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n    bool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n \n/*???´???????????????*/\nclass Line\n{\npublic:\n    Vector p,q;\n    Line(Vector p=Vector(),Vector q=Vector()):p(p),q(q){}\n};\n \n/*???????????????*/\nclass Circle\n{\npublic:\n    Vector c;\n    double r;\n    Circle(Vector c=Vector(),double r=0.0):c(c),r(r){}\n};\n \n/*?????§????????????*/\ntypedef vector<Vector> Polygon;\n \n/*?????????????????????¢?????????????§??????*/\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n \n/*???´???????????°????±*/\nVector project(Line l,Vector p)\n{\n    Vector base=l.q-l.p;\n    double r=dot(p-l.p,base)/base.norm();\n    return l.p+base*r;\n}\n \n/*?????????¨?????????????????????????????*/\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return 1;//????????¨???????\n    if(cross(a,b)<-EPS)return -1;//?????¨???????\n    if(dot(a,b)<-EPS)return 2;//p0?????????\n    if(a.norm()<b.norm())return -2;//p1????\\\\\n    return 0;//?????????\n}\n \n/*?????????????????????*/\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    return (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n \n/*???´??????¨???´????????????*/\nVector LLcross(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    double d1=cross(p3-p2,p0-p2);\n    double d2=cross(p3-p2,p1-p3);\n    return p0+(p1-p0)*(d1/(d1+d2));\n}\n \n/*??????¨???´????????????*/\npair<Vector,Vector> CLcross(Circle c,Line l)\n{\n    Vector pr=project(l,c.c);\n    Vector e=(l.q-l.p)/(l.q-l.p).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n \n/*??????¨????????????*/\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector pol(double a,double r){return Vector(cos(r)*a,sin(r)*a);}\npair<Vector,Vector> CCcross(Circle c1,Circle c2)\n{\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+pol(c1.r,t+a),c1.c+pol(c1.r,t-a));\n}\n \n/*?????§????????????????????????????????????*/\nint contain(Polygon g,Vector p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++)\n    {\n        Vector a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//??????\n        if(a.y>b.y)swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);//?????????2?????????0\n}\n \n/*??????(Andrew)*/\nPolygon AndrewScan(Polygon s)\n{\n    Polygon u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);l.push_back(s[s.size()-2]);\n    for(int i=2;i<s.size();i++)\n    {\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])>=0;n--)\n        {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--)\n    {\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])>=0;n--)\n        {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n \n \n//cout<<fixed<<setprecision(10);\n////////////////////////////////////////////////\n#define BOT 0\n#define LEF 1\n#define RIG 2\n#define TOP 3\n\nclass Endpoint\n{\npublic:\n\tVector p;\n\tint seg,st;\n\tEndpoint(){}\n\tEndpoint(Vector p,int seg,int st):p(p),seg(seg),st(st){}\n\t\n\tbool operator < (const Endpoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nEndpoint EP[2*100000];\n\nint manhattanIntersection(vector<Line> S)\n{\n\tint n=S.size();\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(S[i].p.y==S[i].q.y)\n\t\t{\n\t\t\tif(S[i].p.x>S[i].q.x)swap(S[i].p,S[i].q);\n\t\t}\n\t\telse if(S[i].p.y>S[i].q.y)swap(S[i].p,S[i].q);\n\t\t\n\t\tif(S[i].p.y==S[i].q.y)\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p,i,LEF);\n\t\t\tEP[k++]=Endpoint(S[i].q,i,RIG);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p,i,BOT);\n\t\t\tEP[k++]=Endpoint(S[i].q,i,TOP);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+(2*n));\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==TOP)\n\t\t{\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==BOT)\n\t\t{\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==LEF)\n\t\t{\n\t\t\tset<int>::iterator b=BT.lower_bound(S[EP[i].seg].p.x);\n\t\t\tset<int>::iterator e=BT.upper_bound(S[EP[i].seg].q.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;cin>>n;\n\tLine a;\n\tvector<Line> S;\n\tREP(i,n)\n\t{\n\t\tcin>>a.p.x>>a.p.y>>a.q.x>>a.q.y;\n\t\tS.PB(a);\n\t}\n\t\n\tcout<<manhattanIntersection(S)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\n \nint bit[1000000],bit_n;\nint sum(int i){\n  int s=0;\n  while(i){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=bit_n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\n \nstruct data{\n  int time,type,l,r;\n  bool operator < (const data &p)const{\n    return (time==p.time?type<p.type:time<p.time);\n  }\n};\n// 1 | add\n// 2 - check\n// 3 | delete\n \nint n;\nvector<data> t;\nvector<int> X;\nmap<int,int> mapx;\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n    X.push_back(a);\n    X.push_back(c);\n    if(a==c){\n      t.push_back((data){min(b,d),1,a,a});\n      t.push_back((data){max(b,d),3,a,a});\n    }else{\n      t.push_back((data){b,2,min(a,c),max(a,c)});\n    }\n  }\n  sort(t.begin(),t.end());\n  sort(X.begin(),X.end());\n  int c=2;\n  for(int i=0;i<(int)X.size();i++)\n    if(i==0||X[i]!=X[i-1])\n      mapx[X[i]]=c++;\n   \n  bit_n=n*2+1;\n  long long ans = 0;\n  for(int i=0;i<(int)t.size();i++){\n    data d=t[i];\n    d.l=mapx[d.l],d.r=mapx[d.r];\n    if(d.type==1){\n      add(d.l,1);\n    }else if(d.type==2){\n      long long A=sum(d.r)-sum(d.l-1);\n      ans+=A;\n    }else if(d.type==3){\n      add(d.l,-1);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n//BEGIN\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n#define Pi 3.141592653589793238\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const double& k) const { return Point(x * k, y * k); }\n\tPoint operator/(const double& k) const { return Point(x / k, y / k); }\n\n\tfriend istream& operator>>(istream& is, Point& p) {\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\tbool operator==(const Point& p) const { return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS); }\n\tbool operator<(const Point& p) const { return (x != p.x ? x < p.x : y < p.y); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\n\tfriend istream& operator>>(istream& is, Segment& s) {\n\t\tis >> s.p1 >> s.p2;\n\t\treturn is;\n\t}\n};\n\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectSS(Segment s1, Segment s2) {\n\treturn intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersectCS(Circle c, Segment s) {\n\tif (norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n\tdouble d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n\tif (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n\tif ((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS)) return 1;\n\tPoint h = project(s, c.c);\n\tif (dot(s.p1 - h, s.p2 - h) < 0) return 2;\n\treturn 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble r = c1.r + c2.r;\n\tif (equals(d, r)) return 3;\n\tif (d > r) return 4;\n\tif (equals(d + c2.r, c1.r)) return 1;\n\tif (d + c2.r < c1.r) return 0;\n\treturn 2;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n\t\t\t   getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n\tdouble a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n\tdouble b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n\tif (abs(a) < EPS && abs(b) < EPS) return l2.p1;\n\treturn l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\nvector<Point> getCrossPointCL(Circle c, Line l) {\n\tvector<Point> ps;\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tif (equals(getDistanceLP(l, c.c), c.r)) {\n\t\tps.push_back(pr);\n\t\treturn ps;\n\t}\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\tps.push_back(pr + e * base); ps.push_back(pr - e * base);\n\treturn ps;\n}\n\nvector<Point> getCrossPointCS(Circle c, Segment s) {\n\tLine l(s);\n\tvector<Point> ps = getCrossPointCL(c, l);\n\tif (intersectCS(c, s) == 2) return ps;\n\tif (dot(l.p1 - ps[0], l.p2 - ps[0]) < 0) ps[1] = ps[0];\n\telse ps[0] = ps[1];\n\treturn ps;\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nvector<Point> getCrossPointCC(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tvector<Point> ps;\n\tps.push_back(c1.c + polar(c1.r, t + a)); ps.push_back(c1.c + polar(c1.r, t - a));\n\treturn ps;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n\treturn getCrossPointCC(c, Circle(p, sqrt(norm(c.c - p) - c.r * c.r)));\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n\tvector<Line> ls;\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble g = norm(c1.c - c2.c);\n\tif (equals(g, 0)) return ls;\n\tPoint u = (c2.c - c1.c) / sqrt(g);\n\tPoint v = Point(-u.y, u.x);\n\tfor (int s = 1; s >= -1; s -= 2) {\n\t\tdouble h = (c1.r + s * c2.r) / sqrt(g);\n\t\tif (equals(1, h * h)) ls.push_back(Line(c1.c + u * c1.r, c1.c + (u + v) * c1.r));\n\t\telse if (1 - h * h > 0) {\n\t\t\tPoint uu = u * h, vv = v * sqrt(1 - h * h);\n\t\t\tls.push_back(Line(c1.c + (uu + vv) * c1.r, c2.c - (uu + vv) * c2.r * s));\n\t\t\tls.push_back(Line(c1.c + (uu - vv) * c1.r, c2.c - (uu - vv) * c2.r * s));\n\t\t}\n\t}\n\treturn ls;\n}\n\n// IN:2,ON:1,OUT:0\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tif (ccw(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]) == CLOCKWISE) return false;\n\treturn true;\n}\n\nPolygon convexHull(Polygon p) {\n\tint n = p.size();\n\tsort(p.begin(), p.end(),\n\t\t [](const Point& a, const Point& b) {return (a.y != b.y ? a.y < b.y : a.x < b.x); });\n\tPolygon a(2 * n);\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k > 1 && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; --i) {\n\t\twhile (k > t && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\ta.resize(k - 1);\n\treturn a;\n}\n\ndouble area(Polygon p) {\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\tres += cross(p[i], p[(i + 1) % p.size()]) / 2.0;\n\treturn res;\n}\n\ndouble area(Polygon p, Circle c) {\n\tif (p.size() < 3) return 0.0;\n\tfunction<double(Circle, Point, Point)> dfs = [&](Circle c, Point a, Point b) {\n\t\tVector va = c.c - a, vb = c.c - b;\n\t\tdouble f = cross(va, vb), res = 0;\n\t\tif (equals(f, 0.0)) return res;\n\t\tif (max(abs(va), abs(vb)) < c.r + EPS) return f;\n\t\tVector d(dot(va, vb), cross(va, vb));\n\t\tif (getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n\t\t\treturn c.r * c.r * atan2(d.y, d.x);\n\t\tauto u = getCrossPointCS(c, Segment(a, b));\n\t\tvector<Point> ps{ a,u[0],u[1],b };\n\t\tfor (int i = 1; i < ps.size(); ++i) res += dfs(c, ps[i - 1], ps[i]);\n\t\treturn res;\n\t};\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i) res += dfs(c, p[i], p[(i + 1) % p.size()]);\n\treturn res / 2;\n}\n\ndouble convexDiameter(Polygon p) {\n\tint n = p.size();\n\tif (n == 2) return abs(p[0] - p[1]);\n\tint i = 0, j = 0;\n\tfor (int k = 0; k < n; ++k) {\n\t\tif (p[i] < p[k]) i = k;\n\t\tif (!(p[j] < p[k])) j = k;\n\t}\n\tdouble res = 0;\n\tint ti = i, tj = j;\n\twhile (i != tj || j != ti) {\n\t\tres = max(res, abs(p[i] - p[j]));\n\t\tif (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0)\n\t\t\ti = (i + 1) % n;\n\t\telse j = (j + 1) % n;\n\t}\n\treturn res;\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\tfor (int i = 0; i < (int)p.size(); ++i) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE) q.push_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n\t\t\tq.push_back(getCrossPointLL(Line(a, b), l));\n\t}\n\treturn q;\n}\n\ndouble closestPair(vector<Point> ps) {\n\tsort(ps.begin(), ps.end());\n\tvector<Point> a(ps.size());\n\tfunction<double(int, int)> solve = [&](int l, int r) {\n\t\tif (r - l < 2) return 1e18;\n\t\tint mid = (l + r) >> 1;\n\t\tdouble x = ps[mid].x;\n\t\tdouble d = min(solve(l, mid), solve(mid, r));\n\t\tinplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r,\n\t\t\t\t\t  [](const Point& a, const Point& b) {return a.y < b.y; });\n\t\tint ptr = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tif (abs(ps[i].x - x) >= d) continue;\n\t\t\tfor (int j = 0; j < ptr; ++j) {\n\t\t\t\tPoint luz = ps[i] - a[ptr - j - 1];\n\t\t\t\tif (luz.y >= d) break;\n\t\t\t\td = min(d, abs(luz));\n\t\t\t}\n\t\t\ta[ptr++] = ps[i];\n\t\t}\n\t\treturn d;\n\t};\n\treturn solve(0, ps.size());\n}\n\nint manhattanIntersection(vector<Segment> ss) {\n\tconst int INF = numeric_limits<int>::max();\n\tconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\n\tint n = ss.size();\n\tvector<EndPoint> ep;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ss[i].p1.y == ss[i].p2.y) {\n\t\t\tif (ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, LEFT));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, RIGHT));\n\t\t} else {\n\t\t\tif (ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, BOTTOM));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, TOP));\n\t\t}\n\t}\n\tsort(ep.begin(), ep.end());\n\tset<int> st;\n\tst.insert(INF);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (ep[i].st == TOP) st.erase(ep[i].p.x);\n\t\telse if (ep[i].st == BOTTOM) st.insert(ep[i].p.x);\n\t\telse if (ep[i].st == LEFT) {\n\t\t\tauto b = st.lower_bound(ss[ep[i].seg].p1.x);\n\t\t\tauto e = st.upper_bound(ss[ep[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n//END\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CGL1A() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = project(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\n*/\nvoid CGL1B() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = reflect(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\n*/\nvoid CGL1C() {\n\tPoint p0, p1, p2; cin >> p0 >> p1;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tcin >> p2;\n\t\tint a = ccw(p0, p1, p2);\n\t\tif (a == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\";\n\t\telse if (a == CLOCKWISE) cout << \"CLOCKWISE\";\n\t\telse if (a == ONLINE_BACK) cout << \"ONLINE_BACK\";\n\t\telse if (a == ONLINE_FRONT) cout << \"ONLINE_FRONT\";\n\t\telse cout << \"ON_SEGMENT\";\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\n*/\nvoid CGL2A() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tVector p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tif (isParallel(p1 - p0, p3 - p2)) cout << 2;\n\t\telse if (isOrthogonal(p1 - p0, p3 - p2)) cout << 1;\n\t\telse cout << 0;\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\n*/\nvoid CGL2B() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << (intersectSS(s1, s2) ? 1 : 0) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\n*/\nvoid CGL2C() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tPoint a = getCrossPointLL(s1, s2);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\n*/\nvoid CGL2D() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tprintf(\"%.10f\\n\", getDistanceSS(s1, s2));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\n*/\nvoid CGL3A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.1f\\n\", area(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A\n*/\nvoid CGL3B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tcout << (isConvex(p) ? 1 : 0) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B\n*/\nvoid CGL3C() {\n\tint n; cin >> n;\n\tPolygon g(n);\n\tfor (auto& a : g) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tcout << contains(g, p) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C\n*/\nvoid CGL4A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tPolygon t = convexHull(p);\n\tcout << t.size() << endl;\n\tfor (auto a : t) cout << a.x << \" \" << a.y << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_A\n*/\nvoid CGL4B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", convexDiameter(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B\n*/\nvoid CGL4C() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tprintf(\"%.10f\\n\", area(convexCut(p, l)));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C\n*/\nvoid CGL5A() {\n\tint n; cin >> n;\n\tvector<Point> ps(n);\n\tfor (auto& a : ps) cin >> a;\n\tprintf(\"%.10f\\n\", closestPair(ps));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/5/CGL_5_A\n*/\nvoid CGL6A() {\n\tint n; cin >> n;\n\tvector<Segment> ss(n);\n\tfor (auto& a : ss) cin >> a;\n\tcout << manhattanIntersection(ss) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/6/CGL_6_A\n*/\nvoid CGL7A() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tcout << intersectCC(c1, c2) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\n*/\n\nvoid CGL7D() {\n\tCircle c; cin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\t\tauto a = getCrossPointCL(c, l);\n\t\tsort(a.begin(), a.end());\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D\n*/\nvoid CGL7E() {\n\tCircle c1; cin >> c1.c.x >> c1.c.y >> c1.r;\n\tCircle c2; cin >> c2.c.x >> c2.c.y >> c2.r;\n\tauto a = getCrossPointCC(c1, c2);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E\n*/\nvoid CGL7F() {\n\tPoint p; cin >> p;\n\tCircle c; cin >> c.c >> c.r;\n\tauto a = tangentCP(c, p);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f\\n%.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F\n*/\nvoid CGL7G() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = tangentCC(c1, c2);\n\tvector<Point> ps;\n\tfor (auto e : a) ps.push_back(getCrossPointCL(c1, e)[0]);\n\tsort(ps.begin(), ps.end());\n\tfor (auto e : ps) printf(\"%.10f %.10f\\n\", e.x, e.y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G\n*/\nvoid CGL7H() {\n\tint n; cin >> n;\n\tCircle c; c.c = Point(0, 0); cin >> c.r;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", area(p, c));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_H\n*/\n\nint main() {\n\t//CGL1A();\n\t//CGL1B();\n\t//CGL1C();\n\t//CGL2A();\n\t//CGL2B();\n\t//CGL2C();\n\t//CGL2D();\n\t//CGL3A();\n\t//CGL3B();\n\t//CGL3C();\n\t//CGL4A();\n\t//CGL4B();\n\t//CGL4C();\n\t//CGL5A();\n\tCGL6A();\n\t//CGL7A();\n\t//CGL7D();\n\t//CGL7E();\n\t//CGL7F();\n\t//CGL7G();\n\t//CGL7H();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nstruct Polygon\n{\n\tint n;\n\tPoint a[MAXN];\n\tPolygon() {}\n\tint Point_In(Point t)\n\t{\n\t\tint num = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t{\n\t\t\tif(PointOnSegment(t, a[i], a[i + 1]))\n\t\t\t\treturn 2;\n\t\t\tint k = cmp(det(a[i + 1] - a[i], t - a[i]));\n\t\t\tint d1 = cmp(a[i].y - t.y);\n\t\t\tint d2 = cmp(a[i + 1].y - t.y);\n\t\t\tif(k > 0 && d1 <= 0 && d2 > 0)\n\t\t\t\tnum++;\n\t\t\tif(k < 0 && d2 <= 0 && d1 > 0)\n\t\t\t\tnum--;\n\t\t}\n\t\treturn num != 0;\n\t}\n};\n\nstruct Polygon_convex\n{\n\tvector<Point> P;\n\tPolygon_convex(int Size = 0)\n\t{\n\t\tP.resize(Size);\n\t}\n} res(2*100000 + 50);\n\nbool comp_less(Point a, Point b)\n{\n\treturn cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nvoid convex_hull(vector<Point> a)\n{\n\tsort(a.begin(), a.end(), comp_less);\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tint m = 0;\n\tint len = a.size();\n\trep(i, 0, len - 1)\n\t{\n\t\twhile(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tint k = m;\n\tlen = a.size();\n\tdow(i, len - 2, 0)\n\t{\n\t\twhile(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif(a.size()>1)\n\t\tres.P.resize(m-1);\n}\n\nbool PointOnSegment(Point p, Point s, Point t)\n{\n\treturn cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\nPoint rotate(Point p, double cost, double sint)\n{\n\tdouble x = p.x, y = p.y;\n\treturn Point(x*cost - y*sint, x*sint + y*cost);\n}\n\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n\tdouble d = (ap - bp).norm();\n\tdouble cost = (ar*ar + d*d - br*br) / (2*ar*d);\n\tdouble sint = sqrt(1. - cost*cost);\n\tPoint v = (bp - ap) / (bp - ap).norm() * ar;\n\treturn make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\nstruct Pointt\n{\n\tint x, y;\n\tPointt(int xx = 0, int yy = 0):x(xx), y(yy){}\n};\n\nstruct Node\n{\n\tPointt p;\n\tPointt q;\n\tint id;\n\tNode(Pointt p_ = Pointt(0,0), Pointt q_ = Pointt(0, 0), int id_ = 4):p(p_), q(q_), id(id_){}\n\tfriend bool operator ==(Node a, Node b)\n\t{\n\t\treturn a.p.x == b.p.x && a.p.y == b.p.y;\n\t}\n\tfriend bool operator <(Node a, Node b)\n\t{\n\t\tif(a.p.y == b.p.y)\n\t\t\treturn a.id < b.id;\n\t\treturn a.p.y < b.p.y;\n\t}\n} node[MAX * 2];\n\nset<int> s;\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tsfi(n);\n\tint cnt = 0;\n\trep(i, 0, n - 1)\n\t{\n\t\tPointt a, b;\n\t\tscanf(\"%d%d%d%d\", &a.x, &a.y, &b.x, &b.y);\n\t\tif(cmp(a.x-b.x)==0)\n\t\t{\n\t\t\tif(a.y < b.y)\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Pointt(0, 0), 1);\n\t\t\t\tnode[cnt++] = Node(b, Pointt(0, 0), 3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Pointt(0, 0), 3);\n\t\t\t\tnode[cnt++] = Node(b, Pointt(0, 0), 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a.x < b.x)\n\t\t\t\tnode[cnt++] = Node(a, b, 2);\n\t\t\telse\n\t\t\t\tnode[cnt++] = Node(b, a, 2);\n\t\t}\n\t\t\n\t}\n\tsort(node, node + cnt);\n\t\n\tint ans = 0;\n\trep(i, 0, cnt - 1)\n\t{\n\t\tif(node[i].id == 3)\n\t\t{\n\t\t\tset<int>::iterator it = s.find(node[i].p.x);\n\t\t\ts.erase(*it);\n\t\t}\n\t\telse if(node[i].id == 1)\n\t\t{\n\t\t\ts.insert(node[i].p.x);\n\t\t}\n\t\telse if(node[i].id == 2)\n\t\t{\n\t\t\tset<int>::iterator it = s.lower_bound(node[i].p.x);\n\t\t\tset<int>::iterator iter = s.lower_bound(node[i].q.x);\n\t\t\tif(cmp((*iter)-node[i].q.x)==0)\n\t\t\t\titer++;\n\t\t\tfor(; it != iter; it++)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n \n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n \n/*????????????(???§??¨?)????????????*/\nclass Vector\n{\npublic:\n    double x,y;\n    Vector(double x=0,double y=0):x(x),y(y){}\n     \n    Vector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n    Vector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n    Vector operator * (double a){return Vector(x*a,y*a);}\n    Vector operator / (double a){return Vector(x/a,y/a);}\n     \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n     \n    bool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n    bool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n \n/*???´???????????????*/\nclass Line\n{\npublic:\n    Vector p,q;\n    Line(Vector p=Vector(),Vector q=Vector()):p(p),q(q){}\n};\n \n/*???????????????*/\nclass Circle\n{\npublic:\n    Vector c;\n    double r;\n    Circle(Vector c=Vector(),double r=0.0):c(c),r(r){}\n};\n \n/*?????§????????????*/\ntypedef vector<Vector> Polygon;\n \n/*?????????????????????¢?????????????§??????*/\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n \n/*???´???????????°????±*/\nVector project(Line l,Vector p)\n{\n    Vector base=l.q-l.p;\n    double r=dot(p-l.p,base)/base.norm();\n    return l.p+base*r;\n}\n \n/*?????????¨?????????????????????????????*/\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return 1;//????????¨???????\n    if(cross(a,b)<-EPS)return -1;//?????¨???????\n    if(dot(a,b)<-EPS)return 2;//p0?????????\n    if(a.norm()<b.norm())return -2;//p1????\\\\\n    return 0;//?????????\n}\n \n/*?????????????????????*/\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    return (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n \n/*???´??????¨???´????????????*/\nVector LLcross(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    double d1=cross(p3-p2,p0-p2);\n    double d2=cross(p3-p2,p1-p3);\n    return p0+(p1-p0)*(d1/(d1+d2));\n}\n \n/*??????¨???´????????????*/\npair<Vector,Vector> CLcross(Circle c,Line l)\n{\n    Vector pr=project(l,c.c);\n    Vector e=(l.q-l.p)/(l.q-l.p).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n \n/*??????¨????????????*/\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector pol(double a,double r){return Vector(cos(r)*a,sin(r)*a);}\npair<Vector,Vector> CCcross(Circle c1,Circle c2)\n{\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+pol(c1.r,t+a),c1.c+pol(c1.r,t-a));\n}\n \n/*?????§????????????????????????????????????*/\nint contain(Polygon g,Vector p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++)\n    {\n        Vector a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//??????\n        if(a.y>b.y)swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);//?????????2?????????0\n}\n \n/*??????(Andrew)*/\nPolygon AndrewScan(Polygon s)\n{\n    Polygon u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);l.push_back(s[s.size()-2]);\n    for(int i=2;i<s.size();i++)\n    {\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])>=0;n--)\n        {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--)\n    {\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])>=0;n--)\n        {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n \n \n//cout<<fixed<<setprecision(10);\n////////////////////////////////////////////////\n#define BOT 0\n#define LEF 1\n#define RIG 2\n#define TOP 3\n\nclass Endpoint\n{\npublic:\n\tVector p;\n\tint seg,st;\n\tEndpoint(){}\n\tEndpoint(Vector p,int seg,int st):p(p),seg(seg),st(st){}\n\t\n\tbool operator < (const Endpoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nEndpoint EP[2*100000];\n\nint manhattanIntersection(vector<Line> S)\n{\n\tint n=S.size();\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(S[i].p.y==S[i].q.y)\n\t\t{\n\t\t\tif(S[i].p.x>S[i].q.x)swap(S[i].p,S[i].q);\n\t\t}\n\t\telse if(S[i].p.y>S[i].q.y)swap(S[i].p,S[i].q);\n\t\t\n\t\tif(S[i].p.y==S[i].q.y)\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p,i,LEF);\n\t\t\tEP[k++]=Endpoint(S[i].q,i,RIG);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p,i,BOT);\n\t\t\tEP[k++]=Endpoint(S[i].q,i,TOP);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+(2*n));\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==TOP)\n\t\t{\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==BOT)\n\t\t{\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==LEF)\n\t\t{\n\t\t\tset<int>::iterator b=BT.lower_bound(S[EP[i].seg].p.x);\n\t\t\tset<int>::iterator e=BT.lower_bound(S[EP[i].seg].q.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;cin>>n;\n\tLine a;\n\tvector<Line> S;\n\tREP(i,n)\n\t{\n\t\tcin>>a.p.x>>a.p.y>>a.q.x>>a.q.y;\n\t\tS.PB(a);\n\t}\n\t\n\tcout<<manhattanIntersection(S)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<utility>\n#include<assert.h>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n    \n    Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n    Point operator * (double a) {return Point(a * x, a * y); }\n    Point operator / (double a) {return Point(x / a, y / a); }\n    \n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n    \n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a) {\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n    \n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect(Circle c, Line l) {\n    return (getDistanceLP(l, c.c) - c.r) < EPS;\n}\n\nbool intersect(Circle c1, Circle c2) {\n    return (getDistance(c1.c, c2.c) - c1.r - c2.r) < EPS;\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\n    public:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n    \n    bool operator < (const EndPoint &ep) const {\n        if ( p.y == ep.p.y ) {\n            return st < ep.st;\n        } else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n    \n    for ( int i = 0, k = 0; i < n; i++ ) {\n        if ( S[i].p1.y == S[i].p2.y ) {\n            if ( S[i].p1.x > S[i].p2.x ) swap(S[i].p1, S[i].p2);\n        } else if ( S[i].p1.y > S[i].p2.y ) swap(S[i].p1, S[i].p2);\n        \n        if ( S[i].p1.y == S[i].p2.y ) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n    \n    sort(EP, EP + (2 * n));\n    \n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    \n    for ( int i = 0; i < 2 * n; i++ ) {\n        if ( EP[i].st == TOP ) {\n            BT.erase(EP[i].p.x);\n        } else if ( EP[i].st == BOTTOM ) {\n            BT.insert(EP[i].p.x);\n        } else if ( EP[i].st == LEFT ) {\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    \n    return cnt;\n}\n\nint main() {\n    int n;\n    vector<Segment> S;\n    cin >> n;\n    for ( int i = 0; i < n; i++ ) {\n        Segment s;\n        cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n        S.push_back(s);\n    }\n    \n    cout << manhattanIntersection(S) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\nusing namespace std;\n#define INF 0x7fffffff\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a-b)<EPS)\nstatic const int CCW=1;//?????¶???\nstatic const int CW=-1;//?????¶???\nstatic const int BACK=-2;//?????¢\nstatic const int FRONT=2;//?????¢\nstatic const int ON=0;//?????????\n\nstruct Point//???\n{\n    double x, y;\n    Point(double x=0, double y=0):x(x), y(y) {}\n};\ntypedef Point Vector;//??????\n\nstruct Segment\n{\n    Point p1, p2;\n    Segment(Point p1=Point(), Point p2=Point()):p1(p1), p2(p2) {}\n};//??????\ntypedef Segment Line;//??´???\n\nclass Circle//???\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0):c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;//????????¢\n\nPoint operator + (Point a, Point b)\n{\n    return Point(a.x+b.x, a.y+b.y);\n}\nPoint operator - (Point a, Point b)\n{\n    return Point(a.x-b.x, a.y-b.y);\n}\nPoint operator * (Point a, double p)\n{\n    return  Point(a.x*p, a.y*p);\n}\nPoint operator / (Point a, double p)\n{\n    return Point(a.x/p, a.y/p);\n}\nbool operator < (const Point &a,const Point &b)\n{\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ndouble norm(Vector a)\n{\n    return a.x*a.x+a.y*a.y;   //?????°????¨?????????????\n}\ndouble abs(Vector a)\n{\n    return sqrt(norm(a));   //?¨?\n}\ndouble dot(Vector a, Vector b)\n{\n    return a.x*b.x+a.y*b.y;   //??????\n}\ndouble cross(Vector a, Vector b)\n{\n    return a.x*b.y-a.y*b.x;   //??????\n}\nbool isOrthgonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);   //???????????´????????????\n}\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return isOrthgonal(a1-a2, b1-b2);   //???????????´???4?????????\n}\nbool isOrthgonal(Segment s1, Segment s2)\n{\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);   //???????????´????????????\n}\nbool isParallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);   //????????????????????????\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return isParallel(a1-a2, b1-b2);   //???????????????4?????????\n}\nbool isParallel(Segment s1, Segment s2)\n{\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);   //????????????????????????\n}\n\nPoint project(Segment s, Point p)//?±?????¶?\n{\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1, base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p)//?±??????°??´??????????§°???\n{\n    return p+(project(s, p)-p)*2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2)//??????P0,P1,P2??????????????????\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if( cross(a, b)>EPS ) return CCW;\n    if( cross(a, b)<-EPS ) return CW;\n    if( dot(a, b)<-EPS ) return BACK;\n    if( norm(a)<norm(b) ) return FRONT;\n    return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0 &&ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0);    //???????????????4?????????\n}\nbool intersect(Segment s1, Segment s2)\n{\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);    //???????????????????????????\n}\n\ndouble getDistance(Point a, Point b)\n{\n    return abs(a-b);    //????????´?????????\n}\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));    //?????°??´????????????\n}\ndouble getDistanceSP(Segment s, Point p)//?????°???????????????\n{\n    if(dot(s.p2-s.p1, p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2)//???????????´?????????\n{\n    if(intersect(s1, s2)) return 0.0;\n    return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2)),\n                min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)) );\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)//??????????????????\n{\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base, s1.p1-s2.p1));\n    double d2=abs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n/*\n???????????¨????????¢?????¨\nIN 2\nON 1\nOUT 0\n*/\nint contains(Polygon g, Point p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0; i<n; i++)\n    {\n        Point a=g[i]-p;\n        Point b=g[(i+1)%n]-p;\n        if(abs(cross(a, b))<EPS && dot(a, b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS && EPS<b.y && cross(a,b)>EPS) x=!x;\n    }\n    return (x? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s)//??????(CCW/CW)\n{\n    Polygon u, l;\n    if(s.size()<3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2; i<s.size(); i++)\n    {\n        for(int n=u.size(); n>=2 && ccw(u[n-2], u[n-1], s[i])!=CW; n--)\n            u.pop_back();\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3; i>=0; i--)\n    {\n        for(int n=l.size(); n>=2 && ccw(l[n-2], l[n-1], s[i])!=CW; n--)\n            l.pop_back();\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for(int i=u.size()-2; i>=1; i--) l.push_back(u[i]);\n    return l;\n}\n\ndouble TriArea(Vector a, Vector b)\n{\n    return 0.5*abs(cross(a,b));    //?±?????§???¢??¢?§?\n}\n\ndouble RotatingCalipers(const Polygon& s)//?±??????¢???????????????????????§??????\n{\n    Polygon l;\n    double dis, maxn=0.0;\n    int len, i, k;\n    l=andrewScan(s);\n    len=l.size();\n    if(len>=3)\n    {\n        for(i=0, k=2; i<len; i++)\n        {\n            while(cross(l[(k+1)%len]-l[i], l[(k+1)%len]-l[(i+1)%len])>=cross(l[k%len]-l[i], l[k%len]-l[(i+1)%len]))\n                k++;\n            dis=max(norm(l[k%len]-l[i]), norm(l[k%len]-l[(i+1)%len]));\n            if(dis>maxn) maxn=dis;\n        }\n    }\n    else maxn=norm(l[1]-l[0]);\n    return maxn;\n}\n\nPoint intersectL(Segment a, Segment b)//??´?????????\n{\n    double x1=a.p1.x,y1=a.p1.y,x2=a.p2.x,y2=a.p2.y;\n    double x3=b.p1.x,y3=b.p1.y,x4=b.p2.x,y4=b.p2.y;\n    double k1=(x4-x3)*(y2-y1),k2=(x2-x1)*(y4-y3);\n    double ans_x=(k1*x1-k2*x3+(y3-y1)*(x2-x1)*(x4-x3))/(k1-k2);\n    double ans_y=(k2*y1-k1*y3+(x3-x1)*(y2-y1)*(y4-y3))/(k2-k1);\n    return Point(ans_x,ans_y);\n}\n\nCircle CircumscribedCircle(Point a, Point b, Point c)//?????\\???\n{\n    double x=0.5*(norm(b)*c.y+norm(c)*a.y+norm(a)*b.y-norm(b)*a.y-norm(c)*b.y-norm(a)*c.y)\n             /(b.x*c.y+c.x*a.y+a.x*b.y-b.x*a.y-c.x*b.y-a.x*c.y);\n    double y=0.5*(norm(b)*a.x+norm(c)*b.x+norm(a)*c.x-norm(b)*c.x-norm(c)*a.x-norm(a)*b.x)\n             /(b.x*c.y+c.x*a.y+a.x*b.y-b.x*a.y-c.x*b.y-a.x*c.y);\n    Point O(x, y);\n    double r=abs(O-a);\n    Circle m(O, r);\n    return m;\n}\n\nCircle InscribedCircle(Point a, Point b, Point c)//?????????\n{\n    double A=abs(b-c), B=abs(a-c), C=abs(a-b);\n    double x=(A*a.x+B*b.x+C*c.x)/(A+B+C);\n    double y=(A*a.y+B*b.y+C*c.y)/(A+B+C);\n    Point O(x, y);\n    Line l(a, b);\n    double r=getDistanceLP(l, O);\n    Circle m(O, r);\n    return m;\n}\n\nSegment TangentLineThroughPoint(Circle m, Point p)\n{\n    Point c=m.c;\n    double l=abs(c-p);\n    double r=m.r;\n    double k=(2*r*r-l*l+norm(p)-norm(c)-2*p.y*c.y+2*c.y*c.y)/(2*(p.y-c.y));\n    double A=1+(p.x-c.x)*(p.x-c.x)/((p.y-c.y)*(p.y-c.y));\n    double B=-(2*k*(p.x-c.x)/(p.y-c.y)+2*c.x);\n    double C=c.x*c.x+k*k-r*r;\n    double x1, x2, y1, y2;\n\n    x1=(-B-sqrt(B*B-4*A*C))/(2*A);\n    x2=(-B+sqrt(B*B-4*A*C))/(2*A);\n    y1=(2*r*r-l*l+norm(p)-norm(c)-2*(p.x-c.x)*x1)/(2*(p.y-c.y));\n    y2=(2*r*r-l*l+norm(p)-norm(c)-2*(p.x-c.x)*x2)/(2*(p.y-c.y));\n    Point p1(x1, y1), p2(x2, y2);\n    Segment L(p1, p2);\n    return L;\n}\n\ndouble Angle(Vector a)\n{\n    Point p0(0.0, 0.0);\n    Point p1(1.0, 0.0);\n    Point p2(a.x, a.y);\n    Vector b=p1;\n    double ans=0;\n    if(ccw(p0, p1, p2)==CW) ans=180-acos(dot(a, b)/(abs(a)*abs(b)))*180/acos(-1);\n    else if(ccw(p0, p1, p2)==CCW) ans=acos(dot(a, b)/(abs(a)*abs(b)))*180/acos(-1);\n    else ans=0;\n    if(ans>=180) ans-=180;\n    if(ans<0) ans+=180;\n    return ans;\n}\n\nint CircleContain(Circle m, Point p)\n{\n    double r=m.r;\n    double l=abs(p-m.c);\n    if(r>l) return 2;\n    if(r==l) return 1;\n    if(r<l) return 0;\n}\n\nvoid CircleThroughAPointAndTangentToALineWithRadius(Point p, Line l, double r)\n{\n    Point m=project(l, p);\n    if(abs(p-m)>2*r)\n    {\n        printf(\"[]\\n\");\n    }\n    else if(abs(p-m)==2*r)\n    {\n        Circle c((p+m)/2, r);\n        printf(\"[(%.6lf,%.6lf)]\\n\", c.c.x, c.c.y);\n    }\n    else if(abs(p-m)<EPS)\n    {\n        Point m0(m.x+1, m.y);\n        if(abs(m0-project(l, m0))<EPS) m0.y+=2;\n        Point m1=project(l, m0);\n        Circle c1(m-(m0-m1)/abs(m0-m1)*r, r);\n        Circle c2(m+(m0-m1)/abs(m0-m1)*r, r);\n        printf(\"[(%.6lf,%.6lf),(%.6lf,%.6lf)]\\n\", c1.c.x, c1.c.y, c2.c.x, c2.c.y);\n    }\n    else if(abs(p-m)<2*r)\n    {\n        double s=abs(p-m);\n        double d=sqrt(r*r-(r-s)*(r-s));\n        Point m1, m2;\n        m1=(m+(l.p1-l.p2)/abs(l.p1-l.p2)*d);\n        m2=(m-(l.p1-l.p2)/abs(l.p1-l.p2)*d);\n        Circle c1(m1+(p-m)/abs(p-m)*r, r);\n        Circle c2(m2+(p-m)/abs(p-m)*r, r);\n        printf(\"[(%.6lf,%.6lf),(%.6lf,%.6lf)]\\n\", c1.c.x, c1.c.y, c2.c.x, c2.c.y);\n    }\n    return ;\n}\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint\n{\npublic:\n    Point p;\n    int seg, st;\n    EndPoint(){}\n    EndPoint(Point p, int seg, int st):p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const\n    {\n        if(p.y==ep.p.y) return st < ep.st;\n        else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2*100000];\n\nint manhattanIntersection(vector<Segment> S)\n{\n    int n=S.size();\n\n    for(int i=0, k=0; i<n; i++)\n    {\n        if(S[i].p1.y==S[i].p2.y)\n        {\n            if(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n            else if(S[i].p1.y>S[i].p2.y) swap(S[i].p1, S[i].p2);\n        }\n\n        if(S[i].p1.y==S[i].p2.y)\n        {\n            EP[k++]=EndPoint(S[i].p1, i, LEFT);\n            EP[k++]=EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            EP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++]=EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP+(2*n));\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt=0;\n\n    for(int i=0; i<2*n; i++)\n    {\n        if(EP[i].st==TOP) BT.erase(EP[i].p.x);\n        else if(EP[i].st==BOTTOM) BT.insert(EP[i].p.x);\n        else if(EP[i].st==LEFT)\n        {\n            set<int>::iterator b=BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e=BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt+=distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    vector<Segment> S;\n    while(T--)\n    {\n        Segment L;\n        scanf(\"%lf%lf%lf%lf\", &L.p1.x, &L.p1.y, &L.p2.x, &L.p2.y);\n        S.push_back(L);\n    }\n    printf(\"%d\\n\", manhattanIntersection(S));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nenum PointType {\n    BOTTOM,\n    LEFT,\n    RIGHT,\n    TOP,\n};\n\nstruct EndPoint {\n    Point p;\n    size_t seg;\n    PointType type;\n    EndPoint() {}\n    EndPoint(Point p, size_t s, PointType t): p(p), seg(s), type(t) {}\n\n    bool operator<(const EndPoint &rhs) const {\n        return imag(p)!=imag(rhs.p)? imag(p)<imag(rhs.p) : seg<rhs.seg;\n    }\n};\n\nsize_t num_mintersect(vector<LineSeg> g) {\n    size_t V=g.size();\n\n    vector<EndPoint> h(V<<1);\n    for (size_t i=0, k=0; i<V; ++i) {\n        if (imag(g[i].first) == imag(g[i].second)) {\n            if (real(g[i].first) > real(g[i].second))\n                swap(g[i].first, g[i].second);\n        } else if (imag(g[i].first) > imag(g[i].second)) {\n            swap(g[i].first, g[i].second);\n        }\n\n        if (imag(g[i].first) == imag(g[i].second)) {\n            h[k++] = EndPoint(g[i].first, i, LEFT);\n            h[k++] = EndPoint(g[i].second, i, RIGHT);\n        } else {\n            h[k++] = EndPoint(g[i].first, i, BOTTOM);\n            h[k++] = EndPoint(g[i].second, i, TOP);\n        }\n    }\n    sort(h.begin(), h.end());\n\n    set<double> vlines;\n    vlines.insert(INF);\n\n    size_t count=0;\n    for (size_t i=0; i<(V<<1); ++i) {\n        if (h[i].type == TOP) {\n            vlines.erase(real(h[i].p));\n        } else if (h[i].type == BOTTOM) {\n            vlines.insert(real(h[i].p));\n        } else if (h[i].type == LEFT) {\n            set<double>::iterator lb=lower_bound(\n                vlines.begin(), vlines.end(), real(g[h[i].seg].first)\n            );\n            set<double>::iterator ub=upper_bound(\n                vlines.begin(), vlines.end(), real(g[h[i].seg].second)\n            );\n            count += distance(lb, ub);\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    vector<LineSeg> g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        g[i] = LineSeg(p1, p2);\n    }\n\n    printf(\"%zu\\n\", num_mintersect(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\nusing namespace std;\n#define INF 0x7fffffff\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a-b)<EPS)\nstatic const int CCW=1;//?????¶???\nstatic const int CW=-1;//?????¶???\nstatic const int BACK=-2;//?????¢\nstatic const int FRONT=2;//?????¢\nstatic const int ON=0;//?????????\n\nstruct Point//???\n{\n    double x, y;\n    Point(double x=0, double y=0):x(x), y(y) {}\n};\ntypedef Point Vector;//??????\n\nstruct Segment\n{\n    Point p1, p2;\n    Segment(Point p1=Point(), Point p2=Point()):p1(p1), p2(p2) {}\n};//??????\ntypedef Segment Line;//??´???\n\nclass Circle//???\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0):c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;//????????¢\n\nPoint operator + (Point a, Point b)\n{\n    return Point(a.x+b.x, a.y+b.y);\n}\nPoint operator - (Point a, Point b)\n{\n    return Point(a.x-b.x, a.y-b.y);\n}\nPoint operator * (Point a, double p)\n{\n    return  Point(a.x*p, a.y*p);\n}\nPoint operator / (Point a, double p)\n{\n    return Point(a.x/p, a.y/p);\n}\nbool operator < (const Point &a,const Point &b)\n{\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ndouble norm(Vector a)\n{\n    return a.x*a.x+a.y*a.y;   //?????°????¨?????????????\n}\ndouble abs(Vector a)\n{\n    return sqrt(norm(a));   //?¨?\n}\ndouble dot(Vector a, Vector b)\n{\n    return a.x*b.x+a.y*b.y;   //??????\n}\ndouble cross(Vector a, Vector b)\n{\n    return a.x*b.y-a.y*b.x;   //??????\n}\nbool isOrthgonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);   //???????????´????????????\n}\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return isOrthgonal(a1-a2, b1-b2);   //???????????´???4?????????\n}\nbool isOrthgonal(Segment s1, Segment s2)\n{\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);   //???????????´????????????\n}\nbool isParallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);   //????????????????????????\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return isParallel(a1-a2, b1-b2);   //???????????????4?????????\n}\nbool isParallel(Segment s1, Segment s2)\n{\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);   //????????????????????????\n}\n\nPoint project(Segment s, Point p)//?±?????¶?\n{\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1, base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p)//?±??????°??´??????????§°???\n{\n    return p+(project(s, p)-p)*2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2)//??????P0,P1,P2??????????????????\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if( cross(a, b)>EPS ) return CCW;\n    if( cross(a, b)<-EPS ) return CW;\n    if( dot(a, b)<-EPS ) return BACK;\n    if( norm(a)<norm(b) ) return FRONT;\n    return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0 &&ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0);    //???????????????4?????????\n}\nbool intersect(Segment s1, Segment s2)\n{\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);    //???????????????????????????\n}\n\ndouble getDistance(Point a, Point b)\n{\n    return abs(a-b);    //????????´?????????\n}\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));    //?????°??´????????????\n}\ndouble getDistanceSP(Segment s, Point p)//?????°???????????????\n{\n    if(dot(s.p2-s.p1, p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2)//???????????´?????????\n{\n    if(intersect(s1, s2)) return 0.0;\n    return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2)),\n                min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)) );\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)//??????????????????\n{\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base, s1.p1-s2.p1));\n    double d2=abs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n/*\n???????????¨????????¢?????¨\nIN 2\nON 1\nOUT 0\n*/\nint contains(Polygon g, Point p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0; i<n; i++)\n    {\n        Point a=g[i]-p;\n        Point b=g[(i+1)%n]-p;\n        if(abs(cross(a, b))<EPS && dot(a, b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS && EPS<b.y && cross(a,b)>EPS) x=!x;\n    }\n    return (x? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s)//??????(CCW/CW)\n{\n    Polygon u, l;\n    if(s.size()<3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2; i<s.size(); i++)\n    {\n        for(int n=u.size(); n>=2 && ccw(u[n-2], u[n-1], s[i])!=CW; n--)\n            u.pop_back();\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3; i>=0; i--)\n    {\n        for(int n=l.size(); n>=2 && ccw(l[n-2], l[n-1], s[i])!=CW; n--)\n            l.pop_back();\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for(int i=u.size()-2; i>=1; i--) l.push_back(u[i]);\n    return l;\n}\n\ndouble TriArea(Vector a, Vector b)\n{\n    return 0.5*abs(cross(a,b));    //?±?????§???¢??¢?§?\n}\n\ndouble RotatingCalipers(const Polygon& s)//?±??????¢???????????????????????§??????\n{\n    Polygon l;\n    double dis, maxn=0.0;\n    int len, i, k;\n    l=andrewScan(s);\n    len=l.size();\n    if(len>=3)\n    {\n        for(i=0, k=2; i<len; i++)\n        {\n            while(cross(l[(k+1)%len]-l[i], l[(k+1)%len]-l[(i+1)%len])>=cross(l[k%len]-l[i], l[k%len]-l[(i+1)%len]))\n                k++;\n            dis=max(norm(l[k%len]-l[i]), norm(l[k%len]-l[(i+1)%len]));\n            if(dis>maxn) maxn=dis;\n        }\n    }\n    else maxn=norm(l[1]-l[0]);\n    return maxn;\n}\n\nPoint intersectL(Segment a, Segment b)//??´?????????\n{\n    double x1=a.p1.x,y1=a.p1.y,x2=a.p2.x,y2=a.p2.y;\n    double x3=b.p1.x,y3=b.p1.y,x4=b.p2.x,y4=b.p2.y;\n    double k1=(x4-x3)*(y2-y1),k2=(x2-x1)*(y4-y3);\n    double ans_x=(k1*x1-k2*x3+(y3-y1)*(x2-x1)*(x4-x3))/(k1-k2);\n    double ans_y=(k2*y1-k1*y3+(x3-x1)*(y2-y1)*(y4-y3))/(k2-k1);\n    return Point(ans_x,ans_y);\n}\n\nCircle CircumscribedCircle(Point a, Point b, Point c)//?????\\???\n{\n    double x=0.5*(norm(b)*c.y+norm(c)*a.y+norm(a)*b.y-norm(b)*a.y-norm(c)*b.y-norm(a)*c.y)\n             /(b.x*c.y+c.x*a.y+a.x*b.y-b.x*a.y-c.x*b.y-a.x*c.y);\n    double y=0.5*(norm(b)*a.x+norm(c)*b.x+norm(a)*c.x-norm(b)*c.x-norm(c)*a.x-norm(a)*b.x)\n             /(b.x*c.y+c.x*a.y+a.x*b.y-b.x*a.y-c.x*b.y-a.x*c.y);\n    Point O(x, y);\n    double r=abs(O-a);\n    Circle m(O, r);\n    return m;\n}\n\nCircle InscribedCircle(Point a, Point b, Point c)//?????????\n{\n    double A=abs(b-c), B=abs(a-c), C=abs(a-b);\n    double x=(A*a.x+B*b.x+C*c.x)/(A+B+C);\n    double y=(A*a.y+B*b.y+C*c.y)/(A+B+C);\n    Point O(x, y);\n    Line l(a, b);\n    double r=getDistanceLP(l, O);\n    Circle m(O, r);\n    return m;\n}\n\nSegment TangentLineThroughPoint(Circle m, Point p)\n{\n    Point c=m.c;\n    double l=abs(c-p);\n    double r=m.r;\n    double k=(2*r*r-l*l+norm(p)-norm(c)-2*p.y*c.y+2*c.y*c.y)/(2*(p.y-c.y));\n    double A=1+(p.x-c.x)*(p.x-c.x)/((p.y-c.y)*(p.y-c.y));\n    double B=-(2*k*(p.x-c.x)/(p.y-c.y)+2*c.x);\n    double C=c.x*c.x+k*k-r*r;\n    double x1, x2, y1, y2;\n\n    x1=(-B-sqrt(B*B-4*A*C))/(2*A);\n    x2=(-B+sqrt(B*B-4*A*C))/(2*A);\n    y1=(2*r*r-l*l+norm(p)-norm(c)-2*(p.x-c.x)*x1)/(2*(p.y-c.y));\n    y2=(2*r*r-l*l+norm(p)-norm(c)-2*(p.x-c.x)*x2)/(2*(p.y-c.y));\n    Point p1(x1, y1), p2(x2, y2);\n    Segment L(p1, p2);\n    return L;\n}\n\ndouble Angle(Vector a)\n{\n    Point p0(0.0, 0.0);\n    Point p1(1.0, 0.0);\n    Point p2(a.x, a.y);\n    Vector b=p1;\n    double ans=0;\n    if(ccw(p0, p1, p2)==CW) ans=180-acos(dot(a, b)/(abs(a)*abs(b)))*180/acos(-1);\n    else if(ccw(p0, p1, p2)==CCW) ans=acos(dot(a, b)/(abs(a)*abs(b)))*180/acos(-1);\n    else ans=0;\n    if(ans>=180) ans-=180;\n    if(ans<0) ans+=180;\n    return ans;\n}\n\nint CircleContain(Circle m, Point p)\n{\n    double r=m.r;\n    double l=abs(p-m.c);\n    if(r>l) return 2;\n    if(r==l) return 1;\n    if(r<l) return 0;\n}\n\nvoid CircleThroughAPointAndTangentToALineWithRadius(Point p, Line l, double r)\n{\n    Point m=project(l, p);\n    if(abs(p-m)>2*r)\n    {\n        printf(\"[]\\n\");\n    }\n    else if(abs(p-m)==2*r)\n    {\n        Circle c((p+m)/2, r);\n        printf(\"[(%.6lf,%.6lf)]\\n\", c.c.x, c.c.y);\n    }\n    else if(abs(p-m)<EPS)\n    {\n        Point m0(m.x+1, m.y);\n        if(abs(m0-project(l, m0))<EPS) m0.y+=2;\n        Point m1=project(l, m0);\n        Circle c1(m-(m0-m1)/abs(m0-m1)*r, r);\n        Circle c2(m+(m0-m1)/abs(m0-m1)*r, r);\n        printf(\"[(%.6lf,%.6lf),(%.6lf,%.6lf)]\\n\", c1.c.x, c1.c.y, c2.c.x, c2.c.y);\n    }\n    else if(abs(p-m)<2*r)\n    {\n        double s=abs(p-m);\n        double d=sqrt(r*r-(r-s)*(r-s));\n        Point m1, m2;\n        m1=(m+(l.p1-l.p2)/abs(l.p1-l.p2)*d);\n        m2=(m-(l.p1-l.p2)/abs(l.p1-l.p2)*d);\n        Circle c1(m1+(p-m)/abs(p-m)*r, r);\n        Circle c2(m2+(p-m)/abs(p-m)*r, r);\n        printf(\"[(%.6lf,%.6lf),(%.6lf,%.6lf)]\\n\", c1.c.x, c1.c.y, c2.c.x, c2.c.y);\n    }\n    return ;\n}\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint\n{\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st):p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const\n    {\n        if(p.y==ep.p.y) return st < ep.st;\n        else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2*1000000];\n\nint manhattanIntersection(vector<Segment> S)\n{\n    int n=S.size();\n\n    for(int i=0, k=0; i<n; i++)\n    {\n        if(S[i].p1.y==S[i].p2.y)\n        {\n            if(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n            else if(S[i].p1.y>S[i].p2.y) swap(S[i].p1, S[i].p2);\n        }\n\n        if(S[i].p1.y==S[i].p2.y)\n        {\n            EP[k++]=EndPoint(S[i].p1, i, LEFT);\n            EP[k++]=EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            EP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++]=EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP+2*n);\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt=0;\n\n    for(int i=0; i<2*n; i++)\n    {\n        if(EP[i].st==TOP) BT.erase(EP[i].p.x);\n        else if(EP[i].st==BOTTOM) BT.insert(EP[i].p.x);\n        else if(EP[i].st==LEFT)\n        {\n            set<int>::iterator b=BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e=BT.lower_bound(S[EP[i].seg].p2.x);\n            cnt+=distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    vector<Segment> S;\n    while(T--)\n    {\n\n        Segment L;\n        scanf(\"%lf%lf%lf%lf\", &L.p1.x, &L.p1.y, &L.p2.x, &L.p2.y);\n        S.push_back(L);\n    }\n    printf(\"%d\\n\", manhattanIntersection(S));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point() {};\n  Point(double x, double y): x(x), y(y) {}\n\n  Point operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n  Point operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double d) { return Point(d * x, d * y); }\n  Point operator / (double d) { return Point(x / d, y / d); }\n\n  bool operator < (const Point &p) const {\n    return (x != p.x ? x < p.x : y < p.y);\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend ostream& operator << (ostream &os, Point &p) {\n    return os << \"Point(\" << p.x << \", \" << p.y << \")\";\n  }\n};\n\nclass Segment {\npublic:\n  Point p1, p2;\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n  friend ostream& operator << (ostream &os, Segment &seg) {\n    return os << \"<\" << seg.p1 << \", \" << seg.p2 << \">\";\n  }\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EP {\npublic:\n  Point p;\n  int id, st;\n  EP() {}\n  EP(Point p, int id, int st): p(p), id(id), st(st) {}\n  bool operator < (const EP &ep) const {\n    return (p.y == ep.p.y ? p.x < ep.p.x : p.y < ep.p.y);\n  }\n};\n\nint manhattan_geo(vector<Segment> s) {\n  vector<EP> EPs(s.size() * 2);\n\n  for (int i = 0, k = 0; i < s.size(); i++) {\n    if (s[i].p1.y == s[i].p2.y) {\n      if (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n    } else if (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\n    if (s[i].p1.y == s[i].p2.y) {\n      EPs[k++] = EP(s[i].p1, i, LEFT);\n      EPs[k++] = EP(s[i].p2, i, RIGHT);\n    } else {\n      EPs[k++] = EP(s[i].p1, i, BOTTOM);\n      EPs[k++] = EP(s[i].p2, i, TOP);\n    }\n  }\n\n  sort(EPs.begin(), EPs.end());\n\n  set<int> bin_tree;\n  int cnt = 0;\n\n  for (int i = 0; i < EPs.size(); i++) {\n    if (EPs[i].st == TOP) {\n      bin_tree.erase(EPs[i].p.x);\n    } else if (EPs[i].st == BOTTOM) {\n      bin_tree.insert(EPs[i].p.x);\n    } else if (EPs[i].st == LEFT) {\n      set<int>::iterator b = bin_tree.lower_bound(s[EPs[i].id].p1.x);\n      set<int>::iterator e = bin_tree.upper_bound(s[EPs[i].id].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  int n; cin >> n;\n  vector<Segment> s;\n\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    s.push_back(Segment(Point(x1, y1), Point(x2, y2)));\n  }\n\n  cout << manhattan_geo(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn=1e5+5;\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){\n        return point(x+p.x,y+p.y);\n    }\n    point operator - (point &p){\n        return point(x-p.x,y-p.y);\n    }\n    point operator * (double k){\n        return point(x*k,y*k);\n    }\n    point operator / (double k){\n        return point(x/k,y/k);\n    }\n};\n\nstruct segment{\n    point p1,p2;\n};\n\nstruct endpoint{\n    point p;\n    int seg,st;\n    endpoint(){}\n    endpoint(point p,int seg,int st):p(p),seg(seg),st(st){}\n    bool operator < (const endpoint &ep)const{\n        if(p.y==ep.p.y){\n            return st<ep.st;//y相同时，按照下断点，左端点，右端点，上端点的顺序排列\n        }else{\n            return p.y<ep.p.y;\n        }\n    }\n};\nendpoint ep[2*maxn];\n\nint manhattanIntersection(vector<segment>s)\n{\n    int n=s.size();\n    for(int i=0,k=0;i<n;i++){\n        if(s[i].p1.y==s[i].p2.y){\n            if(s[i].p1.x>s[i].p2.x){\n                swap(s[i].p1,s[i].p2);\n            }\n        }else if(s[i].p1.y>s[i].p2.y){\n            swap(s[i].p1,s[i].p2);\n        }\n        if(s[i].p1.y==s[i].p2.y){\n            ep[k++]=endpoint(s[i].p1,i,LEFT);\n            ep[k++]=endpoint(s[i].p2,i,RIGHT);\n        }else{\n            ep[k++]=endpoint(s[i].p1,i,BOTTOM);\n            ep[k++]=endpoint(s[i].p2,i,TOP);\n        }\n    }\n    sort(ep,ep+(2*n));\n//    for(int i=0;i<2*n;i++){\n//        cout<<ep[i].p.x<<\" \"<<ep[i].p.y<<endl;\n//    }\n//    cout<<endl;\n    set<int>bt;\n    bt.insert(1000000001);\n    int cnt=0;\n    for(int i=0;i<2*n;i++){\n        if(ep[i].st==TOP){\n            bt.erase(ep[i].p.x);\n        }else if(ep[i].st==BOTTOM){\n            bt.insert(ep[i].p.x);\n        }else if(ep[i].st==LEFT){\n            set<int>::iterator b=bt.lower_bound(s[ep[i].seg].p1.x);\n            set<int>::iterator e=bt.upper_bound(s[ep[i].seg].p2.x);\n            cnt+=distance(b,e);\n        }\n    }\n    return cnt;\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    vector<segment>s;\n    segment temp;\n    for(int i=0;i<n;i++){\n        cin>>temp.p1.x>>temp.p1.y>>temp.p2.x>>temp.p2.y;\n        s.push_back(temp);\n    }\n    int res=manhattanIntersection(s);\n    cout<<res<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\n// 点类\nclass Point {\npublic :\n\tdouble x, y;\n\tPoint() {};\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n// 线段类\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {};\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {};\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic :\n\tPoint p;\n\tint seg, st; // 线段的ID，端点的种类\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\t// 按y坐标升序排序\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}else {\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n\n};\nEndPoint EP[2 * 1000010];\n\n// 线段相交问题，曼哈顿几何\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t//调整端点p1、p2，保证左小右大\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tif(S[i].p1.x > S[i].p2.x)\n\t\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\t// 将水平线段添加到端点列表\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t}else { // 将垂直线段添加到端点列表\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\t//按照端点的y坐标升序排序\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\t\t\t// 二叉搜索树\n\tBT.insert(10000000001); // 设置标记\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP)\n\t\t\tBT.erase(EP[i].p.x); //删除上端点\n\t\telse if (EP[i].st == BOTTOM)\n\t\t\tBT.insert(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\n\t\t\t// 加上b到e距离\n\t\t\tcnt += distance(b, e);\n\t\t}\n\n\t}\n\treturn cnt;\n}\nint main() {\n\tvector<Segment> S;\n\tSegment seg;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf %lf %lf %lf\", &seg.p1.x, &seg.p1.y, &seg.p2.x, &seg.p2.y);\n\t\tS.push_back(seg);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection(S));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n \n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n \n/*????????????(???§??¨?)????????????*/\nclass Vector\n{\npublic:\n    double x,y;\n    Vector(double x=0,double y=0):x(x),y(y){}\n     \n    Vector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n    Vector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n    Vector operator * (double a){return Vector(x*a,y*a);}\n    Vector operator / (double a){return Vector(x/a,y/a);}\n     \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n     \n    bool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n    bool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n \n/*???´???????????????*/\nclass Line\n{\npublic:\n    Vector p,q;\n    Line(Vector p=Vector(),Vector q=Vector()):p(p),q(q){}\n};\n \n/*???????????????*/\nclass Circle\n{\npublic:\n    Vector c;\n    double r;\n    Circle(Vector c=Vector(),double r=0.0):c(c),r(r){}\n};\n \n/*?????§????????????*/\ntypedef vector<Vector> Polygon;\n \n/*?????????????????????¢?????????????§??????*/\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n \n/*???´???????????°????±*/\nVector project(Line l,Vector p)\n{\n    Vector base=l.q-l.p;\n    double r=dot(p-l.p,base)/base.norm();\n    return l.p+base*r;\n}\n \n/*?????????¨?????????????????????????????*/\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return 1;//????????¨???????\n    if(cross(a,b)<-EPS)return -1;//?????¨???????\n    if(dot(a,b)<-EPS)return 2;//p0?????????\n    if(a.norm()<b.norm())return -2;//p1????\\\\\n    return 0;//?????????\n}\n \n/*?????????????????????*/\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    return (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n \n/*???´??????¨???´????????????*/\nVector LLcross(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    double d1=cross(p3-p2,p0-p2);\n    double d2=cross(p3-p2,p1-p3);\n    return p0+(p1-p0)*(d1/(d1+d2));\n}\n \n/*??????¨???´????????????*/\npair<Vector,Vector> CLcross(Circle c,Line l)\n{\n    Vector pr=project(l,c.c);\n    Vector e=(l.q-l.p)/(l.q-l.p).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n \n/*??????¨????????????*/\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector pol(double a,double r){return Vector(cos(r)*a,sin(r)*a);}\npair<Vector,Vector> CCcross(Circle c1,Circle c2)\n{\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+pol(c1.r,t+a),c1.c+pol(c1.r,t-a));\n}\n \n/*?????§????????????????????????????????????*/\nint contain(Polygon g,Vector p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++)\n    {\n        Vector a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//??????\n        if(a.y>b.y)swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);//?????????2?????????0\n}\n \n/*??????(Andrew)*/\nPolygon AndrewScan(Polygon s)\n{\n    Polygon u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);l.push_back(s[s.size()-2]);\n    for(int i=2;i<s.size();i++)\n    {\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])>=0;n--)\n        {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--)\n    {\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])>=0;n--)\n        {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n \n \n//cout<<fixed<<setprecision(10);\n////////////////////////////////////////////////\n#define BOT 0\n#define LEF 1\n#define RIG 2\n#define TOP 3\n\nclass Endpoint\n{\npublic:\n\tVector p;\n\tint seg,st;\n\tEndpoint(){}\n\tEndpoint(Vector p,int seg,int st):p(p),seg(seg),st(st){}\n\t\n\tbool operator < (const Endpoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nEndpoint EP[2*100000];\n\nint manhattanIntersection(vector<Line> S)\n{\n\tint n=S.size;\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(S[i].p1.y==S[i].p2.y)\n\t\t{\n\t\t\tif(S[i].p1.x>S[i].p2.x)swap(S[i].p1,S[i].p2);\n\t\t}\n\t\telse if(S[i].p1.y>S[i].p2.y)swap(S[i].p1,S[i].p2);\n\t\t\n\t\tif(S[i].p1.y==S[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p1,i,LEF);\n\t\t\tEP[k++]=Endpoint(S[i].p2,i,RIG);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p1,i,BOT);\n\t\t\tEP[k++]=Endpoint(S[i].p2,i,TOP);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+(2*n));\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==TOP)\n\t\t{\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==BOT)\n\t\t{\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==LEF)\n\t\t{\n\t\t\tset<int>::iterator b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=BT.lower_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;cin>>n;\n\tLine a;\n\tvector<Line> S;\n\tREP(i,n)\n\t{\n\t\tcin>>a.p.x>>a.p.y>>a.q.x>>a.q.y;\n\t\tS.PB(a);\n\t}\n\t\n\tcout<<manhattanIntersection(S)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n    public:\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x * x + y * y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nbool isParallel(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross((s1.p2 - s1.p1), (s2.p2 - s2.p1)), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot((s1.p2 - s1.p1), (s2.p2 - s2.p1)), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    Point projection = project(s, p);\n    Vector toReflection = (projection - p) * 2.0;\n    return p + toReflection; \n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n\n    // 反時計\n    if (cross(v1, v2) > 0.0) return 1;\n    // 時計\n    if (cross(v1, v2) < 0.0) return -1;\n\n    // p1, p2 が逆方向\n    if (dot(v1, v2) < 0.0) return 2;\n\n    // p1, p2 が同方向\n    if (v1.abs() < v2.abs()) return -2;\n    return 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return (ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0\n            && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n    if (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n\n    return getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) {\n        return 0.0;\n    }\n\n    return min(\n        min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n        min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n    );\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n\n    Vector hypo = s1.p2 - s1.p1;\n    return s1.p1 + hypo * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCircleSegmentCrossPoint(Circle c, Segment s) {\n    Point projection = project(s, c.c);\n    double dist = sqrt(c.r * c.r - (c.c - projection).norm());\n    Vector base = s.p2 - s.p1;\n    base = base / base.abs();\n    Point a = projection + (base * dist);\n    return make_pair(projection + (base * dist), projection - (base * dist));\n}\n\npair<Point, Point> getCircleCrossPoint(Circle c1, Circle c2) {\n    double d = (c2.c - c1.c).abs();\n    double a = acos((d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d * c1.r));\n    double t = atan2((c2.c - c1.c).y, (c2.c - c1.c).x);\n    Point crossPoint1 = {c1.c.x + c1.r * cos(a + t), c1.c.y + c1.r * sin(a + t)};\n    Point crossPoint2 = {c1.c.x + c1.r * cos(t - a), c1.c.y + c1.r * sin(t - a)};\n    return make_pair(crossPoint1, crossPoint2);\n}\n\nint isContainedInPolygon(Polygon polygon, Point target) {\n    int n = polygon.size();\n    bool contained = false;\n    for (int i = 0; i < n; i++) {\n        Point p1 = polygon.at(i);\n        Point p2 = polygon.at((i + 1) % n);\n        Vector a = p1 - target;\n        Vector b = p2 - target;\n\n        if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\n        if (a.y > b.y) swap(a, b);\n\n        if (a.y < EPS && b.y > EPS && cross(a, b) > 0) contained = !contained;\n    }\n\n    return contained ? 2 : 0;\n}\n\nPolygon getConvexHull(vector<Point> points) {\n    vector<Point> upper, lower;\n    sort(points.begin(), points.end());\n\n    upper.push_back(points[0]);\n    upper.push_back(points[1]);\n    lower.push_back(points[points.size() - 1]);\n    lower.push_back(points[points.size() - 2]);\n    \n    for (int i = 2; i < points.size(); i++) {\n        Point a, b;\n        int j = upper.size() - 1;\n        while (j > 0) {\n            Point a = upper[j];\n            Point b = upper[j - 1];\n            if (ccw(b, a, points[i]) != 1) {\n                break;\n            }\n            upper.pop_back();\n            j--;\n        }\n        upper.push_back(points[i]);\n    }\n\n    for (int i = points.size() - 3; i >= 0; i--) {\n        Point a, b;\n        int j = lower.size() - 1;\n        while (j > 0) {\n            Point a = lower[j];\n            Point b = lower[j - 1];\n            if (ccw(b, a, points[i]) != 1) {\n                break;\n            }\n            lower.pop_back();\n            j--;\n        }\n        lower.push_back(points[i]);\n    }\n\n    reverse(lower.begin(), lower.end());\n    for (int i = upper.size() - 2; i >= 1; i--) lower.push_back(upper[i]);\n\n    return lower;\n}\n\nstruct EndPoint {\n    Point p;\n    int id, type;\n    EndPoint() {}\n    EndPoint(Point p, int id, int type): p(p), id(id), type(type) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return type < ep.type;\n        } else return p.y < ep.p.y;\n    }\n};\n\nint manhattanIntersection(vector<Segment> segments) {\n    int n = segments.size();\n    vector<EndPoint> eps;\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (segments[i].p1.y == segments[i].p2.y) {\n            if (segments[i].p1.x > segments[i].p2.x) swap(segments[i].p1, segments[i].p2);\n        } else if (segments[i].p1.y > segments[i].p2.y) {\n            swap(segments[i].p1, segments[i].p2);\n        }\n\n        if (segments[i].p1.y == segments[i].p2.y) {\n            // left = 1\n            eps.push_back(EndPoint(segments[i].p1, i, 1));\n            // right = 2\n            eps.push_back(EndPoint(segments[i].p2, i, 2));\n        } else {\n            // bottom = 0\n            eps.push_back(EndPoint(segments[i].p1, i, 0));\n            // top = 3\n            eps.push_back(EndPoint(segments[i].p2, i, 3));\n        }\n    }\n\n    sort(eps.begin(), eps.end());\n\n    set<int> BT;\n    int count = 0;\n    for (EndPoint ep : eps) {\n        if (ep.type == 0) {\n            BT.insert(ep.p.x);\n        } else if (ep.type == 3) {\n            BT.erase(ep.p.x);\n        } else if (ep.type == 1) {\n            set<int>::iterator left = lower_bound(BT.begin(), BT.end(), segments[ep.id].p1.x);\n            set<int>::iterator right = upper_bound(BT.begin(), BT.end(), segments[ep.id].p2.x);\n            count += distance(left, right);\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    // cout << fixed << setprecision(11);\n\n    int n;\n    cin >> n;\n\n    vector<Segment> segments;\n    double x1, y1, x2, y2;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Point p1 = {x1, y1};\n        Point p2 = {x2, y2};\n\n        Segment s = {p1, p2};\n        segments.push_back(s);\n    }\n\n    cout << manhattanIntersection(segments) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof(a))\n#define pb(a)    push_back(a)\n#define il       inline\n#define reg      register\ntypedef long long ll;\ntypedef double db;\nconst int maxn=10000;\nconst int minn=200000+5;\nstruct Point\n{\n    db x,y;\n    Point(){}\n    Point(db x,db y):x(x),y(y){}\n};\nstruct Seg\n{\n    Point a,b;\n    int c;\n    Seg(Point a,Point b,int c):a(a),b(b),c(c){}\n    friend bool operator<(Seg p,Seg q){\n        if(p.a.y!=q.a.y) return p.a.y<q.a.y;\n    \treturn p.c!=q.c?p.c<q.c:p.a.x<q.a.x;\n    }\n};\ndb  x[minn<<2];\nint q,lenx,ans,tree[minn<<2];\nvector<Seg> ve;\nvoid init()\n{\n    clr(tree,0);\n    ve.clear();\n    lenx=0;\n    ans=0;\n    return ;\n}\nvoid  pushpu(int k,int c)\n{\n    while(k)\n    {\n        tree[k]+=c;\n        k>>=1;\n    }\n}\nvoid update(int l,int r,int nu,int c,int k)\n{\n    if(nu==l&&r==nu)\n    {\n        pushpu(k,c);\n        return ;\n    }\n    int mind=(l+r)/2;\n    if(nu<=mind){update(l,mind,nu,c,k<<1);}\n    if(nu>mind) {update(mind+1,r,nu,c,k<<1|1);}\n    return ;\n}\nvoid query(int l,int r,int L,int R,int k)\n{\n    if(L<=l&&r<=R)\n    {\n        ans+=tree[k];\n        return ;\n    }\n    int mind=(l+r)/2;\n    if(L<=mind){query(l,mind,L,R,k<<1);}\n    if(R>mind) {query(mind+1,r,L,R,k<<1|1);}\n    return ;\n}\nint slove()\n{\n    sort(ve.begin(),ve.end());\n    sort(x,x+lenx);\n    int res=0;\n    for(reg int i=0;i<ve.size();i++)\n    {\n        if(ve[i].a.x==ve[i].b.x){\n            int nu=lower_bound(x,x+lenx,ve[i].a.x)-x+1;\n            int c=ve[i].c>2?-1:ve[i].c;\n            update(1,lenx,nu,c,1);\n        }\n        else\n        {\n            ans=0;\n            int l=lower_bound(x,x+lenx,ve[i].a.x)-x+1;\n            int r=lower_bound(x,x+lenx,ve[i].b.x)-x+1;\n            query(1,lenx,l,r,1);\n            res+=ans;\n        }\n    }\nreturn res;\n}\nint main()\n{\n//    freopen(\"data.txt\",\"r\",stdin);\n    init();\n    scanf(\"%d\",&q);\n    Point a,b;\n    while(q--)\n    {\n        scanf(\"%lf%lf\",&a.x,&a.y);\n        scanf(\"%lf%lf\",&b.x,&b.y);\n        if(a.x>b.x||a.y>b.y){swap(a,b);}\n        if(a.x!=b.x)\n        {\n            x[lenx++]=a.x;x[lenx++]=b.x;\n            ve.pb(Seg(a,b,2));\n        }\n        else\n        {\n            x[lenx++]=a.x;\n            ve.pb(Seg(a,a,1));\n            ve.pb(Seg(b,b,3));\n        }\n    }\n    printf(\"%d\\n\",slove());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\n// 点类\nclass Point {\npublic :\n\tdouble x, y;\n\tPoint() {};\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n// 线段类\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {};\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {};\n};\n// 圆类\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle() {};\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n// 定义向量\ntypedef Point Vector;\n// 定义直线\ntypedef Segment Line;\n// 定义多边形\ntypedef vector<Point> Polygon;\n\n/***************************点、向量****************************/\n\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\n\n// 向量的内积\ndouble dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 向量的外积\ndouble cross(Point a, Point b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 向量a，b是否正交 <==> 内积为0\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n// 向量a，b是否平行 <==> 外积为0\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n// 点p在线段s上的投影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r ;\n}\n\n//以线段s为对称轴与点p成线对称的点\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n// 点a到点b的距离\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n// 线段l和点p的距离\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1) );\n}\n\n// 线段s与点p的距离\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n\n\n/*************************线段********************************/\n// 线段s1，s2是否正交 <==> 内积为0\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 线段s1，s2是否平行 <==> 外积为0\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 逆时针方向ccw（Counter-Clockwise）\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// 判断线段p1p2和线段p3p4是否相交\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//判断线段s1和s2是否相交\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 线段s1和线段s2的距离\ndouble getDistance(Segment s1, Segment s2) {\n\t// 相交\n\tif (intersect(s1, s2))\n\t\treturn 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 线段s1与线段s2的交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/***************************圆****************************/\n\n// 圆c和直线l的交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n// 圆c1和圆c2的交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n/***************************多边形****************************/\n// 点的内包\n/*\n\tIN 2\n\tON 1\n\tOUT 0\n*/\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)\n\t\t\tx = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nint cmp(Point A, Point B)                     //竖直排序  \n{\n\treturn (A.y<B.y || (A.y == B.y&&A.x<B.x));\n}\n// 凸包\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tint len = s.size();\n\tif (len < 3) return s;\n\n\n\t// 以x，y为基准升序排序\n\tsort(s.begin(), s.end());\n\t// 将x值最小的两个点添加到u\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\n\t// 将x值最大的两个点添加到l\n\tl.push_back(s[len - 1]);\n\tl.push_back(s[len - 2]);\n\n\t// 构建凸包上部\n\tfor (int i = 2; i < len; i++) {\n\t\tfor (int j = u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], s[i]) >= 0; j--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t// 构建凸包下部\n\tfor (int i = len - 3; i >= 0; i--) {\n\t\tfor (int j = l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], s[i]) >= 0; j--) {\n\t\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)\n\t\tl.push_back(u[i]);\n\t\n\treturn l;\n}\n\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic :\n\tPoint p;\n\tint seg, st; // 线段的ID，端点的种类\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\t// 按y坐标升序排序\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}else {\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n\n};\nEndPoint EP[2 * 1000010];\n\n// 线段相交问题，曼哈顿几何\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t//调整端点p1、p2，保证左小右大\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tif(S[i].p1.x > S[i].p2.x)\n\t\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\t// 将水平线段添加到端点列表\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t}else { // 将垂直线段添加到端点列表\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\t//按照端点的y坐标升序排序\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\t\t\t// 二叉搜索树\n\tBT.insert(10000000001); // 设置标记\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP)\n\t\t\tBT.erase(EP[i].p.x); //删除上端点\n\t\telse if (EP[i].st == BOTTOM)\n\t\t\tBT.insert(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.lower_bound(S[EP[i].seg].p2.x);\n\n\t\t\t// 加上b到e距离\n\t\t\tcnt += distance(b, e);\n\t\t}\n\n\t}\n\treturn cnt;\n}\nint main() {\n\tvector<Segment> S;\n\tSegment seg;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf %lf %lf %lf\", &seg.p1.x, &seg.p1.y, &seg.p2.x, &seg.p2.y);\n\t\tS.push_back(seg);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection(S));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nclass Segment {\npublic:\n  int t;\n  int y;\n  int x1,x2;\n  Segment(){}\n  Segment(int t, int y, int x1, int x2) : t(t), y(y), x1(x1), x2(x2) {}\n  bool operator < ( const Segment &s ) const\n  {\n    if ( t == 0 )\n      return y <= s.y;\n    else if ( t == 1 )\n      return y < s.y;\n    else\n      if ( s.t == 0 )\n        return y < s.y;\n      else if ( s.t == 1 )\n        return y <= s.y;\n      else\n        return y < s.y;\n  }\n};\n\nclass SegmentIntersections\n{\npublic:\n  vector<Segment> seg;\n  SegmentIntersections(){}\n  int solve();\n};\n\nint SegmentIntersections::solve()\n{\n  sort( seg.begin(), seg.end() );\n\n  set<int> s;\n  int cnt = 0;\n\n  for ( auto it = seg.begin(); it != seg.end(); ++it )\n    {\n      if ( (*it).t == 0 )\n        s.insert( (*it).x1 );\n      else if ( (*it).t == 1 )\n        s.erase( (*it).x1 );\n      else\n        {\n          auto st = lower_bound( s.begin(), s.end(), (*it).x1 );\n          auto tt = upper_bound( s.begin(), s.end(), (*it).x2 );\n\n          cnt += distance( st, tt );\n        }\n    }\n\n  cout << cnt << endl;\n  \n  return 0;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  SegmentIntersections si;\n\n  int x1, y1, x2, y2;\n\n  for ( auto i = 0; i < n; ++i )\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      if ( x1 == x2 )\n        if ( y1 < y2 )\n          {\n            si.seg.push_back( Segment( 0, y1, x1, 0 ) );\n            si.seg.push_back( Segment( 1, y2, x2, 0 ) );\n          }\n        else\n          {\n            si.seg.push_back( Segment( 1, y1, x1, 0 ) );\n            si.seg.push_back( Segment( 0, y2, x2, 0 ) );\n          }\n      else\n        if ( x1 < x2 )\n          si.seg.push_back( Segment( 2, y1, x1, x2 ) );\n        else\n          si.seg.push_back( Segment( 2, y1, x2, x1 ) );\n    }\n\n  si.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        /*\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n        */\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の点の集合 ( 開始点と終了点で集合を分割する )\nvector<Point> v_parallel_x_start;\nvector<Point> v_parallel_x_end;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x_start.push_back(start);\n            v_parallel_x_end.push_back(end);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n    sort(v_parallel_x_start.begin(), v_parallel_x_start.end());\n    sort(v_parallel_x_end.begin(), v_parallel_x_end.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].y == v_parallel_y[j].p1.y )\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x_start.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x_start[p].x\n                && v_EP[i].y == v_parallel_x_start[p].y )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x_start[p].x; k <= v_parallel_x_end[p].x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n                //　線分は重ならないので, 1つ見つかれば処理終了\n                break;\n            }\n        }\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n            }\n        }\n\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() {return x * x + y * y; }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\n public:\n  Point p;\n  int seg, st;\n  EndPoint() {}\n  EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n  bool operator < (const EndPoint &ep) const {\n    if (p.y == ep.p.y) {\n      return st < ep.st;\n    } else return p.y < ep.p.y;\n  }\n};\n\nEndPoint EP[2 * 100000];\n\nvoid swap(Point& a, Point& b) {\n  Point tmp = a;\n  a.x = b.x;\n  a.y = b.y;\n  b.x = tmp.x;\n  b.y = tmp.y;\n}\n\nint manhattanIntersection(vector<Segment> S) {\n  int n = S.size();\n\n  for (int i = 0, k = 0; i < n; i++) {\n    if (S[i].p1.y == S[i].p2.y) {\n      if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n    } else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n    if (S[i].p1.y == S[i].p2.y) {\n      EP[k++] = EndPoint(S[i].p1, i, LEFT);\n      EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n    } else {\n      EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n      EP[k++] = EndPoint(S[i].p2, i, TOP);\n    }\n  }\n\n  sort(EP, EP + (2 * n));\n\n  set<int> BT;\n  BT.insert(1000000001);\n  int cnt = 0;\n\n  for (int i = 0; i < 2*n; i++) {\n    if (EP[i].st == TOP) {\n      BT.erase(EP[i].p.x);\n    } else if (EP[i].st == BOTTOM) {\n      BT.insert(EP[i].p.x);\n    } else if (EP[i].st == LEFT) {\n      set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n      set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  vector<Segment> S;\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    Segment s;\n    cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n    S.push_back(s);\n  }\n  cout << manhattanIntersection(S) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 2000000001;\nclock_t START, END;\n\nint ans;\n\nstruct Point {\n\tint x, y, t, l;\n\tPoint(int x = 0, int y = 0) :x(x), y(y) {}\n\tbool operator < (const Point& rhs) const {\n\t\tif (y == rhs.y)\n\t\t\treturn t > rhs.t;\n\t\treturn y < rhs.y;\n\t}\n};\nstruct Node {\n\tNode* ch[2];\n\tint r, v;\n\tint cmp(int x) const {\n\t\tif (x == v) return -1;\n\t\treturn x < v ? 0 : 1;\n\t}\n};\nstruct Treap {\n\tvoid rotate(Node*& o, int d) {\n\t\tNode* k = o->ch[d ^ 1];\n\t\to->ch[d ^ 1] = k->ch[d];\n\t\tk->ch[d] = o;\n\t\to = k;\n\t}\n\tvoid insert(Node*& o, int x) {\n\t\tif (o == NULL) {\n\t\t\to = new Node();\n\t\t\to->ch[0] = o->ch[1] = NULL;\n\t\t\to->v = x;\n\t\t\to->r = rand();\n\t\t}\n\t\telse {\n\t\t\tint d = o->cmp(x);\n\t\t\tinsert(o->ch[d], x);\n\t\t\tif (o->ch[d]->r > o->r)\n\t\t\t\trotate(o, d ^ 1);\n\t\t}\n\t}\n\tvoid remove(Node*& o, int x) {\n\t\tint d = o->cmp(x);\n\t\tif (d == -1) {\n\t\t\tif (o->ch[0] == NULL)\n\t\t\t\to = o->ch[1];\n\t\t\telse if (o->ch[1] == NULL)\n\t\t\t\to = o->ch[0];\n\t\t\telse {\n\t\t\t\tint d2 = (o->ch[0]->r > o->ch[1]->r ? 1 : 0);\n\t\t\t\trotate(o, d2);\n\t\t\t\tremove(o->ch[d2], x);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tremove(o->ch[d], x);\n\t}\n\tvoid find(Node* o, int l, int r) {\n\t\tif (o) {\n\t\t\tint L = o->cmp(l);\n\t\t\tint R = o->cmp(r);\n\t\t\tif ((L == -1 || L == 0) && (R == -1 || R == 1)) {\n\t\t\t\tans++;\n\t\t\t\tfind(o->ch[0], l, r);\n\t\t\t\tfind(o->ch[1], l, r);\n\t\t\t}\n\t\t\telse if (L == 1)\n\t\t\t\tfind(o->ch[1], l, r);\n\t\t\telse\n\t\t\t\tfind(o->ch[0], l, r);\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t};\n\tint n;\n\tPoint a, b;\n\tvector<Point> points;\n\tTreap Set;\n\tNode* root = NULL;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d\", &a.x, &a.y, &b.x, &b.y);\n\t\tif (a.y == b.y) {\n\t\t\tif (a.x > b.x)\n\t\t\t\tswap(a.x, b.x);\n\t\t\ta.t = 0;\n\t\t\ta.l = b.x;\n\t\t\tpoints.push_back(a);\n\t\t}\n\t\telse {\n\t\t\tif (a.y > b.y)\n\t\t\t\tswap(a.y, b.y);\n\t\t\ta.t = 1;\n\t\t\tb.t = -1;\n\t\t\tpoints.push_back(a);\n\t\t\tpoints.push_back(b);\n\t\t}\n\t}\n\tsort(points.begin(), points.end());\n\tfor (vector<Point>::iterator it = points.begin(); it != points.end(); it++) {\n\t\tif (it->t == 0) {\n\t\t\tif (root)\n\t\t\t\tSet.find(root, it->x, it->l);\n\t\t}\n\t\telse if (it->t == 1) {\n\t\t\tSet.insert(root, it->x);\n\t\t}\n\t\telse\n\t\t\tSet.remove(root, it->x);\n\t}\n\tcout << ans << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include  <cassert>\n\nusing namespace std;\nusing ll = long long int;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define int ll\n//const int INF = 100100100;\nconst int INF = (1LL << 32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\n\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n#define XYSORT\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator<(const Point& p) const {\n#ifdef XYSORT\n\t\treturn x != p.x ? x < p.x : y < p.y;\n#endif \n#ifdef YXSORT\n\t\treturn y != p.y ? y < p.y : x < p.x;\n#endif \n\t}\n\n\tbool operator==(const Point & p) const {\n\t\treturn fabs(x - p.x) < EPS and fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x* b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x* b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n//直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//平行判定\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//線分sに対する点pの射影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n//線分ｓに対する点ｐの反射\nPoint refrect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n//2点間の距離\ndouble getDistance(Point a, Point b) {\n\tPoint res = a - b;\n\treturn res.abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / Vector(l.p2 - l.p1).abs());\n}\n\n//線分ｓと点ｐの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) {\n\t\tPoint r = p - s.p1;\n\t\treturn r.abs();\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) {\n\t\tPoint r = p - s.p2;\n\t\treturn r.abs();\n\t}\n\treturn getDistanceLP(s, p);\n}\n\n//counter clock wise\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分と線分の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//線分と線分の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(\n\t\tmin(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\t);\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//円ｃと線分ｌの交差判定\nbool intersect(Circle c, Line l) {\n\treturn getDistanceSP(l, c.c) <= c.r;\n}\n\n//円ｃと線分ｌの交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / Vector(l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - Vector(pr - c.c).norm());\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = Vector(c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//点の内包判定\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\trep(i, n) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS and dot(a, b) < EPS) return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS and EPS < b.y and cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\n//凸包\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n//マンハッタン幾何 平面走査\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\n//端点\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st; \n\tEndPoint(){}\n\tEndPoint(Point p, int seg, int st) : p(p),seg(seg),st(st){}\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}\n\t\telse return p.y < ep.p.y;\n\t}\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> s) {\n\tint n = s.size();\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tif (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n\t\t}\n\t\telse if (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(s[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(s[i].p2, i, RIGHT);\n\t\t}\n\t\telse {\n\t\t\tEP[k++] = EndPoint(s[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(s[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP) {\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tauto b = BT.lower_bound(s[EP[i].seg].p1.x);\n\t\t\tauto e = BT.upper_bound(s[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tvector<Segment> s;\n\tint n;\n\tcin >> n;\n\trep(i, n) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\ts.pb(Segment(Point(x1, y1), Point(x2, y2)));\n\t}\n\tcout << manhattanIntersection(s) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n*/\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\ttemplate<typename T> class dvector : public std::vector<T> {\n\tpublic:\n\t\tdvector() : std::vector<T>() {}\n\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\tT& operator[](size_t n) {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t\tconst T& operator[](size_t n) const {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t};\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define uniq(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\n\n/*-----8<-----template-----8<-----*/\n\n//点、ベクトル\nclass Point {\npublic:\n\tdouble x,y;\n\tPoint(double x=0., double y=0.) : x(x), y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x, y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x, y-p.y);}\n\tPoint operator * (Point p) {return Point(x*p.x, y*p.y);}\n\tPoint operator / (Point p) {return Point(x/p.x, y/p.y);}\n\tPoint operator + (double n) {return Point(x+n, y+n);}\n\tPoint operator - (double n) {return Point(x-n, y-n);}\n\tPoint operator * (double n) {return Point(x*n, y*n);}\n\tPoint operator / (double n) {return Point(x/n, y/n);}\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x!=p.x ? x<p.x : y<p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n\t\n};\nusing Vector = Point;\nstd::ostream& operator<<(std::ostream& s, const Point& p) {\n\treturn s << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n//線分、直線\nclass Segment {\npublic:\n\tPoint p1,p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\nusing Line = Segment;\nstd::ostream& operator<<(std::ostream& s, const Segment& se) {\n\treturn s << \"(\" << se.p1 << \", \" << se.p2 << \")\";\n}\n\n//ベクトルの内積\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\ninline double equals(double a,double b){ return fabs(a-b)<EPS; }\n//直交判定\nbool isOrthogonal(Vector a,Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n\treturn isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n\treturn equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//平行判定\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n\treturn isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n\treturn equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//射影\nPoint project(Segment s,Point p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/base.norm();\n\treturn base*r + s.p1;\n}\n//反射\nPoint reflect(Segment s,Point p){\n\treturn p + (project(s,p)-p)*2;\n}\n\n//p0,p1,p2が反時計回りになる\nstatic const int COUNTER_CLOCKWISE = 1;\n//p0,p1,p2が時計回りになる\nstatic const int CLOCKWISE = -1;\n//p2,p0,p1がこの順で同一直線状にある\nstatic const int ONLINE_BACK = 2;\n//p0,p1,p2がこの順で同一直線状にある\nstatic const int ONLINE_FRONT = -2;\n//p2が線分p0p1上にある\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b)<-EPS)return CLOCKWISE;\n\tif(dot(a,b)<-EPS)return ONLINE_BACK;\n\tif(a.norm()<b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\n//端点が他方の線分上にある場合、線分二つが平行に重なる場合も交差しているとみなす\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//二点間の距離\ndouble getDistance(Point a,Point b){\n\treturn (a-b).abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(l.p2-l.p1, p-l.p1)) / (l.p2-l.p1).abs();\n}\n//点と線分の距離\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2-s.p1, p-s.p1)<0.)return (p-s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2)<0.)return (p-s.p2).abs();\n\treturn getDistanceLP(s,p);\n}\n//線分と線分の距離\ndouble getDistance(Segment s1,Segment s2){\n\tif(intersect(s1,s2))return 0.;\n\treturn min({getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2), getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)});\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2-s2.p1;\n\tdouble d1=fabs(cross(base, s1.p1-s2.p1));\n\tdouble d2=fabs(cross(base, s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n}\n\n//円\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\t//c:中心の点、r=半径\n\tCircle(Point c=Point(), double r=0.) : c(c), r(r) {}\n};\n//円cと線分lの交点の数を返す\nint hasCrossPoints(Circle c, Line l){\n\tdouble dis = getDistanceLP(l,c.c);\n\tif(equals(dis,c.r))return 1;\n\tif(dis < c.r)return 2;\n\treturn 0;\n}\n//円cと線分lの交点を返す\npair<Point,Point> getCrossPoints(Circle c, Line l){\n\tassert(getDistanceLP(l,c.c) < c.r+EPS);\n\tVector pr=project(l, c.c);\n\tVector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn {pr+e*base, pr-e*base};\n}\n\n\n//ベクトルpとx軸との角度を返す 返却値の範囲[-π, π]\ninline double arg(Vector p){ return atan2(p.y, p.x); }\n//大きさa, x軸との角度rのベクトルを返す\ninline Vector polar(double a, double r){ return Point(cos(r)*a, sin(r)*a); }\n//円c1と円c2の交点を返す\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n\tassert(getDistance(c1.c,c2.c) < c1.r+c2.r+EPS);\n\tdouble d = (c1.c-c2.c).abs();\n\tdouble a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(c1.r*d*2.));\n\tdouble t = arg(c2.c-c1.c);\n\treturn {c1.c+polar(c1.r,t+a), c1.c+polar(c1.r,t-a)};\n}\n\nusing Polygon = vector<Point>;\n//多角形gと点pの内包関係を返す\nstatic const int INSIDE = 2;\nstatic const int ONLINE = 1;\nstatic const int OUTSIDE = 0;\nll contains(Polygon &g, Point p){\n\tll n=g.size();\n\tbool x=false;\n\tfor(ll i=0; i<n; i++){\n\t\tPoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return ONLINE;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x=!x;\n\t}\n\treturn (x ? INSIDE : OUTSIDE);\n}\n\n//点の集合sに対する凸包を返す\nPolygon andrewScan(Polygon &s){\n\tPolygon u,l;\n\tif(s.size()<3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(ll i=2; i<(ll)s.size(); i++){\n\t\tfor(ll n=u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor(ll i=s.size()-3; i>=0; i--){\n\t\tfor(ll n=l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor(ll i=u.size()-2; i>=1; i--)l.push_back(u[i]);\n\treturn l;\n}\n\n//線分の集合sの交点の数を返す\nclass EndPoint {\npublic:\n\tPoint p;\n\tll seg,st; //入力線分のID, 端点の種類\n\tEndPoint() {}\n\tEndPoint(Point p, ll seg, ll st) : p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\nvector<Point> manhattanIntersection(vector<Segment> &S){\n\tstatic const int BOTTOM = 0;\n\tstatic const int LEFT = 1;\n\tstatic const int RIGHT = 2;\n\tstatic const int TOP = 3;\n\tll n=S.size();\n\tvector<EndPoint> EP(2*n);\n\tfor(ll i=0,k=0; i<n; i++){\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tif(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, RIGHT);\n\t\t}else{\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP.begin(), EP.end());\n\n\tset<ll> BT;\n\tBT.insert(INF);\n\tvector<Point> ans;\n\tfor(ll i=0; i<2*n; i++){\n\t\tif(EP[i].st==TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}else if(EP[i].st==BOTTOM){\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}else if(EP[i].st==LEFT){\n\t\t\tdebug(S[EP[i].seg].p1.x,S[EP[i].seg].p2.x);\n\t\t\tdebug(BT);\n\t\t\tauto b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tauto e=BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tfor(; b!=e; advance(b,1)){\n\t\t\t\tans.push_back(Point(*b,EP[i].p.y));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn ans;\n}\n\n\n/*-----8<-----library-----8<-----*/\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\nvoid CGL_2_A(){\n\tll N;\n\tcin>>N;\n\tvector<ll> ans(N,0);\n\trep(i,N){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tll t=0;\n\t\tif(isOrthogonal(p0,p1,p2,p3)){\n\t\t\tt=1;\n\t\t}else if(isParallel(p0,p1,p2,p3)){\n\t\t\tt=2;\n\t\t}\n\t\tans[i]=t;\n\t}\n\trep(i,N)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\nvoid CGL_1_A(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=project(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\nvoid CGL_1_B(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=reflect(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\nvoid CGL_2_D(){\n\tll Q;\n\tcin>>Q;\n\tvector<double> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tSegment s0(Point(x0,y0),Point(x1,y1)), s1(Point(x2,y2),Point(x3,y3));\n\t\tdouble t=getDistance(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\nvoid CGL_1_C(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tPoint p0(x0,y0),p1(x1,y1);\n\tll Q;\n\tcin>>Q;\n\tvector<string> ans(Q,\"\");\n\tmap<ll,string> m;\n\tm[1]=\"COUNTER_CLOCKWISE\";\n\tm[-1]=\"CLOCKWISE\";\n\tm[2]=\"ONLINE_BACK\";\n\tm[-2]=\"ONLINE_FRONT\";\n\tm[0]=\"ON_SEGMENT\";\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint pq(xq,yq);\n\t\tll t=ccw(p0,p1,pq);\n\t\tans[i]=m[t];\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\nvoid CGL_2_B(){\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tbool t=intersect(p0,p1,p2,p3);\n\t\tans[i]=t ? 1 : 0;\n\t}\n\trep(i,Q)p(ans[i]);\t\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\nvoid CGL_2_C(){\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tSegment s0(p0,p1),s1(p2,p3);\n\t\tPoint t=getCrossPoint(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].x,ans[i].y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=ja\nvoid CGL_7_D(){\n\tll cx,cy,r,Q;\n\tcin>>cx>>cy>>r>>Q;\n\tCircle c(Point(cx,cy),r);\n\tvector<pair<Point,Point>> ans(Q);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1;\n\t\tcin>>x0>>y0>>x1>>y1;\n\t\tPoint p0(x0,y0),p1(x1,y1);\n\t\tLine l(p0,p1);\n\t\tll count=hasCrossPoints(c,l);\n\t\tif(count==0)exit(1);\n\t\tpair<Point,Point> t=getCrossPoints(c,l);\n\t\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].first.x, ans[i].first.y, ans[i].second.x, ans[i].second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=ja\nvoid CGL_7_E(){\n\tdouble c0x,c0y,r0,c1x,c1y,r1;\n\tcin>>c0x>>c0y>>r0>>c1x>>c1y>>r1;\n\tCircle c0(Point(c0x,c0y), r0), c1(Point(c1x,c1y), r1);\n\tpair<Point,Point> t=getCrossPoints(c0, c1);\n\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(t.first.x, t.first.y, t.second.x, t.second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\nvoid CGL_3_C(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tll t=contains(g,Point(x,y));\n\t\tans[i]=t;\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\nvoid CGL_4_A(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tvector<Point> ch=andrewScan(g);\n\tprintf(\"%lld\\n\",(ll)ch.size());\n\tll f=0;\n\trepeq(i,ch.size()-1){\n\t\tif(ch[f].y>ch[i].y || (ch[f].y==ch[i].y && ch[f].x>ch[i].x)){\n\t\t\tf=i;\n\t\t}\n\t}\n\trep(i,ch.size()){\n\t\tprintf(\"%lld %lld\\n\",(ll)ch[(i+f)%ch.size()].x, (ll)ch[(i+f)%ch.size()].y);\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=ja\nvoid CGL_6_A(){\n\tll N;\n\tcin>>N;\n\tvector<Segment> a(N);\n\trep(i,N)cin>>a[i].p1.x>>a[i].p1.y>>a[i].p2.x>>a[i].p2.y;\n\tvector<Point> ans=manhattanIntersection(a);\n\tp(ans.size());\n}\n\nsigned main() {\n\t//CGL_2_A();\n\t//CGL_1_A();\n\t//CGL_1_B();\n\t//CGL_2_D();\n\t//CGL_1_C();\n\t//CGL_2_B();\n\t//CGL_2_C();\n\t//CGL_7_D();\n\t//CGL_7_E();\n\t//CGL_3_C();\n\t//CGL_4_A();\n\tCGL_6_A();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#define lson(x) (x << 1)\n#define rson(x) (x << 1 | 1)\nusing namespace std;\nconst int MAXN = 1e6 + 10;\ntypedef long long ll;\n\nint n, cnt = 0;\n\nstruct point { //点的基本数据结构\n    int x, y;\n    friend istream& operator>>(istream& in, point& a)\n    {\n        in >> a.x >> a.y;\n        return in;\n    }\n};\nstruct Line {\n    point a, b;\n    int mark;\n    Line() {}\n    Line(point _a, point _b, int _mark)\n    {\n        a = _a, b = _b, mark = _mark;\n    }\n    bool operator<(const Line& p)\n    {\n        if (a.y != p.a.y)\n            return a.y < p.a.y;\n        return mark != p.mark ? mark < p.mark : a.x < p.a.x;\n    }\n};\n\nstruct SegTree {\n    int l, r;\n    ll len;\n    //  sum: 被完全覆盖的次数；\n    //  len: 区间内被截的长度。\n} tree[MAXN << 2];\n\nvoid build_tree(int x, int l, int r)\n{\n    tree[x].l = l, tree[x].r = r;\n    tree[x].len = 0;\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1;\n    build_tree(lson(x), l, mid);\n    build_tree(rson(x), mid + 1, r);\n    return;\n}\n\nvoid pushup(int x)\n{\n    tree[x].len = tree[x << 1].len + tree[x << 1 | 1].len;\n    //      合并儿子信息\n}\n\nvoid edit_tree(int x, ll id, int c)\n{\n    int l = tree[x].l, r = tree[x].r;\n    if (l == id && id == r) {\n        tree[x].len += c;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    if (id <= mid)\n        edit_tree(lson(x), id, c);\n    else\n        edit_tree(rson(x), id, c);\n    pushup(x);\n}\n\nint query(int x, int L, int R)\n{\n    int l = tree[x].l, r = tree[x].r;\n    if (L <= l && r <= R)\n        return tree[x].len;\n    int mid = (l + r) >> 1;\n    int res = 0;\n    if (L <= mid)\n        res += query(lson(x), L, R);\n    if (R > mid)\n        res += query(rson(x), L, R);\n    return res;\n}\nvector<Line> l;\nvector<int> X;\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        point a, b;\n        cin >> a >> b;\n        if (a.x != b.x) {\n            if (a.x > b.x)\n                swap(a, b);\n            X.push_back(a.x), X.push_back(b.x);\n            l.push_back(Line(a, b, 2));\n        } else {\n            if (a.y > b.y)\n                swap(a, b);\n            X.push_back(a.x);\n            l.push_back(Line(a, a, 1));\n            l.push_back(Line(b, b, 3));\n        }\n    }\n    \n    sort(l.begin(), l.end());\n    sort(X.begin(), X.end());\n\n    n = unique(X.begin(), X.end()) - X.begin(); //去重\n    X.erase(X.begin() + n, X.end());\n    if(n==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    build_tree(1, 1, n); //根据X[]的坐标建立线段树\n\n    int ans = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i].mark!=2) {\n            int id = lower_bound(X.begin(), X.end(), l[i].a.x) - X.begin();\n            int c = l[i].mark == 3 ? -1 : 1;\n            edit_tree(1, id+1, c);\n        } else {\n            int id1 = lower_bound(X.begin(), X.end(), l[i].a.x) - X.begin();\n            int id2 = lower_bound(X.begin(), X.end(), l[i].b.x) - X.begin();\n            ans += query(1, id1+1, id2+1);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\n#include <cstdio>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repc(i, s, n) for (int i = (s); i <= (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define rrepc(i, s, n) for (int i = (s); i >= (n); i--)\n#define swap(a, b, type) { type _tmp = a; a = b; b = _tmp; }\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n/*================================================\n\tGeometry\n================================================*/\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment { Point p1, p2; };\ntypedef Segment Line;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n\ndouble Distance_PP(Point a, Point b) { return (a - b).abs(); }\ndouble Distance_PL(Point p, Line l) { return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs(); }\ndouble Distance_PS(Point p, Segment s) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn Distance_PL(p, s);\n}\ndouble Distance_SS(Segment s1, Segment s2) {\n\tdouble op1, op2, op3, op4, distance;\n\n\tif (intersect(s1, s2)) return 0.0;\n\n\top1 = Distance_PS(s1.p1, s2);\n\top2 = Distance_PS(s1.p2, s2);\n\top3 = Distance_PS(s2.p1, s1);\n\top4 = Distance_PS(s2.p2, s1);\n\n\tdistance = min(op1, op2);\n\tdistance = min(distance, op3);\n\tdistance = min(distance, op4);\n\n\treturn distance;\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\nPoint CrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\npair<Point, Point> CrossPoint(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e * base, pr - e * base);\n}\npair<Point, Point> CrossPoint(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint contains(Polygon g, Point p) {\n\t/* IN: 2, ON: 1, OUT: 0 */\n\tint n = g.size();\n\tbool x = false;\n\trep(i, n) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b, Point);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) {\n\t/* 凸包の辺上の点を含めない場合、\"== COUNTER_CLOCKWISE\" を \"!= CLOCKWISE\" に置き換える。 */\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\trepc(i, 2, s.size() - 1) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\trrepc(i, s.size() - 3, 0) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\trrepc(i, u.size() - 2, 1) l.push_back(u[i]);\n\n\treturn l;\n}\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st;\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}\n\t\telse return p.y < ep.p.y;\n\t}\n};\nEndPoint EP[2 * 100000];\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tif (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2, Point);\n\t\t}\n\t\telse if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2, Point);\n\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t}\n\t\telse {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP) {\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;\n\tSegment S;\n\tvector<Segment> VS;\n\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> S.p1.x >> S.p1.y >> S.p2.x >> S.p2.y;\n\t\tVS.push_back(S);\n\t}\n\n\tcout << manhattanIntersection(VS) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass point {\npublic:\n\tint x, y;\n\tint id, kind;\n\tpoint() {}\n\tpoint( int a, int b, int c, int d ) { x = a; y = b; id = c; kind = d; }\n\tbool operator <( point p ) { if( y == p.y ) return kind < p.kind; else return y < p.y; }\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<point> S( n * 2 );\n\tvector<int> rx( n );\n\tfor( int i = 0, k = 0; i < n; i++ ) {\n\t\tint sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tif( sy == ey ) {\n\t\t\tif( sx > ex ) {\n\t\t\t\tswap( sx, ex );\n\t\t\t\tswap( sy, ey );\n\t\t\t}\n\t\t\tS[k] = point( sx, sy, i,  LEFT );\n\t\t\tk++;\n\t\t\tS[k] = point( ex, ey, i, RIGHT );\n\t\t\tk++;\n\t\t\trx[i] = ex;\n\t\t}\n\t\telse {\n\t\t\tif( sy > ey ) {\n\t\t\t\tswap( sx, ex );\n\t\t\t\tswap( sy, ey );\n\t\t\t}\n\t\t\tS[k] = point( sx, sy, i, BOTTOM );\n\t\t\tk++;\n\t\t\tS[k] = point( ex, ey, i, TOP );\n\t\t\tk++;\n\t\t}\n\t}\n\n\tsort( S.begin(), S.end() );\n\tset<int> B;\n\tint ans = 0;\n\tfor( int i = 0; i < n * 2; i++ ) {\n\t\tpoint ep = S[i];\n\t\tif( ep.kind == BOTTOM ) {\n\t\t\tB.insert( ep.x );\n\t\t}\n\t\telse if( ep.kind == TOP ) {\n\t\t\tB.erase( ep.x );\n\t\t}\n\t\telse if( ep.kind == LEFT ) {\n\t\t\tauto it1 = upper_bound( B.begin(), B.end(), rx[ep.id] );\n\t\t\tauto it2 = lower_bound( B.begin(), B.end(), ep.x );\n\t\t\tans += distance( it2, it1 );\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n//#include <chrono>\nusing namespace std;\n\nbool myComp(vector<int> a, vector<int> b) { \n    return ( a[0] < b[0] ) || ( a[0]==b[0] && a[1]<b[1] );\n}\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n\n    int xmin = pow(10,9);\n    int xmax = - pow(10,9);\n\n    vector<vector<int> > vviSegments;\n    for (int i=0; i<n; i++){\n        int x0, y0, x1, y1;\n        cin >> x0 >> y0 >> x1 >> y1;\n        if ( x0 > x1 ) swap(x0, x1);\n        if ( y0 > y1 ) swap(y0, y1);\n\n        if ( x0 < xmin ) xmin = x0;\n        if ( xmax < x1 ) xmax = x1;\n\n        vector<int> viSegment(4);\n        viSegment[0] = y0;\n        viSegment[1] = 0; //Left\n        viSegment[2] = x0;\n        viSegment[3] = x1;\n        if (y0 == y1){\n            vviSegments.push_back(viSegment);\n        }\n        else {\n            viSegment[0] = y0;\n            viSegment[1] = -1; //Bottom\n            vviSegments.push_back(viSegment);\n            viSegment[0] = y1;\n            viSegment[1] = 1; //Top\n            vviSegments.push_back(viSegment);\n        }\n    }\n\n    // std::chrono::system_clock::time_point start,end;\n    // start = std::chrono::system_clock::now();\n\n    // sort\n    sort(vviSegments.begin(), vviSegments.end(), *myComp);\n\n    // divide\n    int N = xmax - xmin + 1;\n    int L = int( sqrt(N) );\n    int M = int(N / L) + 1;\n\n    //cout << N << \" \" << L << \" \" << M << endl;\n\n    // step function\n    map<int, int> LSM;\n    map<int, set<int> > BST;\n\n    // Number of Cross\n    long int numCross = 0;\n\n    for (int i=0; i < vviSegments.size(); ++i){\n        vector<int> viSegment = vviSegments[i];\n        int y = viSegment[0];\n        int whichEdge = viSegment[1];\n        int x0 = viSegment[2] - xmin;\n        int x1 = viSegment[3] - xmin;\n\n        if ( whichEdge == -1 ){\n            int m = int(x0 / L);\n            int b = x0 % L;\n            LSM[m+1] += 1;\n            BST[m].insert(b);\n            //cout << \"+\" << x0 << \" \" << \"m:\" << m << \" b:\" << b << endl;\n        }\n        if ( whichEdge == 0 ){\n            int m0 = int(x0 / L);\n            int m1 = int(x1 / L);\n            int b0 = x0 % L;\n            int b1 = x1 % L;\n\n            //cout << x0 << \" \" << x1 << \" \";\n\n            int step0 = distance( BST[m0].lower_bound(0), BST[m0].upper_bound(b0) );\n            int step1 = distance( BST[m1].lower_bound(0), BST[m1].upper_bound(b1) );\n            int extra = ( BST[m0].find(b0) != BST[m0].end() )? 1 : 0;\n            numCross += step1 - step0 + extra;\n\n            //cout << \" : \" << step0 << \" \" << step1 << \" \" << extra << \":\";\n\n            for(map<int,int>::iterator it = LSM.begin(); it != LSM.end(); ++it) {\n                if(it->first > m1) break;\n                if(it->first > m0) {\n                    numCross += it->second;\n                    //cout << \" key:\" << it->first << \" value:\" << it->second;\n                }\n            }\n            //cout << \" : \" << numCross << endl;\n        }\n        if ( whichEdge == 1 ){\n            int m = int(x0 / L);\n            int b = x0 % L;\n            LSM[m+1] -= 1;\n            BST[m].erase(b);\n            //cout << \"-\" << x0 << \" \" << \"m:\" << m << \" b:\" << b << endl;\n        }\n    }\n\n    // end = std::chrono::system_clock::now();\n\n    // auto elapsed = std::chrono::duration_cast< std::chrono::milliseconds >(end - start).count();\n    // std::cout << elapsed <<\"ms\"<< std::endl;\n\n    cout << numCross << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif(y1 == y2) lines.push_back(PP(P(y1, 2), P(x1, x2)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tlines.push_back(PP(P(y1, 0), P(x1, x2)));\n\t\t\t\tlines.push_back(PP(P(y2, 1), P(x1, x2)));\n\t\t\t}\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, option = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\tif (option == 0) add(x1, 1);\n\t\t\tif (option == 1) add(x1, -1);\n\t\t\tif (option == 2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x, y;\n};\n\nstruct Segment {\n\tPoint p1, p2; \n};\n\n#define BOTTOM 0\n#define LEFT  1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st; \n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint & ep) const {\n\t\tif ( p.y == ep.p.y ) {\n\t\t\treturn st < ep.st; \n\t\t} else return p.y < ep.p.y;\n\t}\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\n\tfor ( int i = 0, k = 0; i < n; i++ ) {\n\t\tif ( S[i].p1.y == S[i].p2.y ) {\n\t\t\tif ( S[i].p1.x > S[i].p2.x ) swap(S[i].p1, S[i].p2);\n\t\t} else if ( S[i].p1.y > S[i].p2.y ) swap(S[i].p1, S[i].p2);\n\n\t\tif ( S[i].p1.y == S[i].p2.y ) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + (2 * n));\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt = 0;\n\n\tfor ( int i = 0; i < 2 * n; i++ ) {\n\t\tif ( EP[i].st == TOP ) {\n\t\t\tBT.erase(EP[i].p.x);\n\t\t} else if ( EP[i].st == BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t} else if( EP[i].st == LEFT ) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;\n\tvector<Segment> s;\n\n\tscanf(\"%d\", &n);\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tSegment x;\n\t\tscanf(\"%lf %lf %lf %lf\", &x.p1.x, &x.p1.y, &x.p2.x, &x.p2.y);\n\t\ts.push_back(x);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection(s));\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        /*\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n        */\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の集合\nvector<Segment> v_parallel_x;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x.push_back(seg);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n            }\n\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].y == v_parallel_y[j].p1.y )\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x[p].p1.x )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x[p].p1.x; k <= v_parallel_x[p].p2.x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n            }\n        }\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x, y;\n};\n\nstruct Segment {\n\tPoint p1, p2; \n};\n\n#define BOTTOM 0\n#define LEFT  1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st; \n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint & ep) const {\n\t\tif ( p.y == ep.p.y ) {\n\t\t\treturn st < ep.st; \n\t\t} else return p.y < ep.p.y;\n\t}\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\n\tfor ( int i = 0, k = 0; i < n; i++ ) {\n\t\tif ( S[i].p1.y == S[i].p2.y ) {\n\t\t\tif ( S[i].p1.y > S[i].p2.x ) swap(S[i].p1, S[i].p2);\n\t\t} else if ( S[i].p1.y > S[i].p2.y ) swap(S[i].p1, S[i].p2);\n\n\t\tif ( S[i].p1.y == S[i].p2.y ) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt = 0;\n\n\tfor ( int i = 0; i < 2 * n; i++ ) {\n\t\tif ( EP[i].st == TOP ) {\n\t\t\tBT.erase(EP[i].p.x);\n\t\t} else if ( EP[i].st == BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t} else if( EP[i].st == LEFT ) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;\n\tvector<Segment> s;\n\n\tscanf(\"%d\", &n);\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tSegment x;\n\t\tscanf(\"%lf %lf %lf %lf\", &x.p1.x, &x.p1.y, &x.p2.x, &x.p2.y);\n\t\ts.push_back(x);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection(s));\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n  ????????????????????????????????????????????????\n  ??????????????????????????????????????????????????????????????????????????????????????¨??????????????°????±???????\n  ??¢?????´?????????????????¢??°?????? O(n log n)\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n    Point() {}\n};\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0].x >> l[0].y >> l[1].x >> l[1].y;\n}\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\nenum SegmentType {\n    BOTTOM, LEFT, RIGHT, TOP,\n};\nstruct EndPoint {\n    Point p;\n    int id;\n    SegmentType type;\n    EndPoint(Point p, int id, SegmentType type) : p(p), id(id), type(type) {}\n    EndPoint() {}\n\n    bool operator<(const EndPoint &ep) const {\n        if (p.y == ep.p.y)\n            return type < ep.type;\n        return p.y < ep.p.y;\n    }\n};\n\n\nint SegmentIntersectionManhattan(vector<Segment> &segs) {\n    const int n = segs.size();\n    int MAX_X = 0;\n    vector<EndPoint> event(2 * n);\n\n    for (int i = 0, k = 0; i < n; ++i) {\n        if (segs[i][0].y > segs[i][1].y ||\n            (segs[i][0].y == segs[i][1].y && segs[i][0].x > segs[i][1].x))\n            swap(segs[i][0], segs[i][1]);\n\n\n        if (segs[i][0].y == segs[i][1].y) { // horizontal segment\n            event[k++] = EndPoint(segs[i][0], i, LEFT);\n            event[k++] = EndPoint(segs[i][1], i, RIGHT);\n        }\n        else { // vertical setment\n            event[k++] = EndPoint(segs[i][0], i, BOTTOM);\n            event[k++] = EndPoint(segs[i][1], i, TOP);\n        }\n\n        MAX_X = max({MAX_X, segs[i][0].x, segs[i][1].x});\n    }\n\n    sort(event.begin(), event.end());\n\n    set<int> bt; // binary search tree\n    bt.insert(MAX_X + 1); // sentinel\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * n; ++i) {\n        if (event[i].type == TOP)\n            bt.erase(event[i].p.x);\n        else if (event[i].type == BOTTOM)\n            bt.insert(event[i].p.x);\n        else if (event[i].type == LEFT) {\n            auto lb = lower_bound(bt.begin(), bt.end(), segs[event[i].id][0].x);\n            auto ub = upper_bound(bt.begin(), bt.end(), segs[event[i].id][1].x);\n\n            cnt += distance(lb, ub);\n        }\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    cin >> n;\n    vector<Segment> segs(n);\n    for (int i = 0; i < n; ++i)\n        cin >> segs[i];\n\n    cout << SegmentIntersectionManhattan(segs) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<complex>\n#include<algorithm>\nusing namespace std;\ntypedef complex<int> xy_t;\nint firstx,firsty,secondx,secondy,cnt,n;\nset<int> BT;\nconst int BOTTOM=0,LEFT=1,RIGHT=2,TOP=3;\n\n\nclass EndPoint{\n    public:\n        xy_t p;\n        int id,type;\n        EndPoint(){}\n        EndPoint(xy_t p,int id,int type):p(p),id(id),type(type){}        \n};\n\nbool operator<(const EndPoint& ep1,const EndPoint ep2){\n    if(ep1.p.imag()==ep2.p.imag()){\n        return ep1.p.real()<ep2.p.real();\n    }\n    else return ep1.p.imag()<ep2.p.imag();\n}\n\nEndPoint EP[2*100100];\n\nint main(){\n    cin>>n;\n    for(int i=0;i<n;++i){\n        cin>>firstx>>firsty>>secondx>>secondy;\n        if(firstx==secondx){\n            if(firsty>secondy) swap(firsty,secondy);\n            \n            EP[2*i]=EndPoint(xy_t(firstx,firsty),2*i,BOTTOM);\n            EP[2*i+1]=EndPoint(xy_t(secondx,secondy),2*i+1,TOP);\n        }\n        else{\n            if(firstx>secondx) swap(firstx,secondx);\n            EP[2*i]=EndPoint(xy_t(firstx,firsty),2*i,LEFT);\n            EP[2*i+1]=EndPoint(xy_t(secondx,secondy),2*i+1,RIGHT);\n        }\n    }\n    sort(EP,EP+(2*n));\n\n    BT.insert(1001001001);\n\n    for(int i=0;i<2*n;++i){\n        if(EP[i].type==BOTTOM){\n            BT.insert(EP[i].p.real());\n        }\n        else if(EP[i].type==TOP){\n            BT.erase(EP[i].p.real());\n        }\n        else if(EP[i].type==LEFT){\n            set<int>::iterator left=BT.lower_bound(EP[i].p.real());\n            set<int>::iterator right=BT.upper_bound(EP[i+1].p.real());\n            cnt+=distance(left,right);\n        }\n    }\n    \n    cout<<cnt<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 2点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\n// 端点の種類\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint\n{\n    public :\n        Point p;\n        // 入力線分のID, 端点の種類\n        int seg, st;\n\n        EndPoint() {}\n        EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n        bool operator < (const EndPoint &ep) const\n        {\n            // y座標が小さい順に整列\n            if( p.y == ep.p.y )\n            {\n                // yが同一の場合は, 下端点, 左端点, 右端点, 上端点の順に並べる\n                return st < ep.st;\n            }\n            else\n            {\n                return p.y < ep.p.y;\n            }\n        }\n};\n\n// 端点のリスト\n//EndPoint EP[2 * 100000];\nEndPoint EP[2 * 100];\n\n// 線分交差問題　：　マンハッタン幾何\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n\n    for(int i = 0, k = 0; i < n; i++)\n    {\n        // 端点 p1, p2 が左下を基準に並ぶように調整\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            if( S[i].p1.x > S[i].p2.x )\n            {\n                swap(S[i].p1, S[i].p2);\n            }\n        }\n        else if( S[i].p1.y > S[i].p2.y )\n        {\n            swap(S[i].p1, S[i].p2);\n        }\n\n        // 水平成分を端点リストに追加\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            // 垂直成分を端点リストに追加\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    // 端点の y 座標に関して昇順に整列\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;            // 二分探索木\n    BT.insert(1000000001);  // 番兵を設置\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++)\n    {\n        if( EP[i].st == TOP )\n        {\n            // 上端点を削除\n            BT.erase(EP[i].p.x);\n        }\n        else if( EP[i].st == BOTTOM )\n        {\n            // 下端点を追加\n            BT.insert(EP[i].p.x);\n        }\n        else if( EP[i].st == LEFT )\n        {\n            // O(log n)\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            // O(log n)\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            // b と e の距離(点の数)を加算, O(k)\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void)\n{\n\n    int n, count;\n    Point start, end;\n    vector<Segment> v_segment;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        v_segment.push_back(seg);\n    }\n\n    // 結果の表示\n    count = manhattanIntersection(v_segment);\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<unordered_map>\n\n#define MAX (200000 + 1)\n\nusing namespace std;\n\nint t[MAX], N;\n\nstruct segment\n{\n    bool vertical;\n    bool start;\n    int x, y1, y2;\n};\n\nvector<segment> space;\nset<int> appear;\nunordered_map<int, int> index;\n\nint sum(int n)\n{\n    int s = 0;\n    while(n > 0)\n    {\n        s += t[n];\n        n -= n & -n;\n    }\n    return s;\n}\n\nvoid add(int n, int d)\n{\n    while(n <= N)\n    {\n        t[n] += d;\n        n += n & -n;\n    }\n    return;\n}\n\nint query(int a, int b)\n{\n    return sum(b) - sum(a - 1);\n}\n\nbool cmp(const segment& a, const segment& b)\n{\n    if(a.x == b.x) // true if a goes first\n    {\n        if(a.vertical && !b.vertical && b.start) return false;\n        else if(a.vertical && !b.vertical && !b.start) return true;\n        else if(!a.vertical && a.start && b.vertical) return true;\n        else if(!a.vertical && a.start && !b.vertical && !b.start) return false;\n        else if(!a.vertical && !a.start && b.vertical) return false;\n        else if(!a.vertical && !a.start && !b.vertical && b.start) return true;\n    }\n    return a.x < b.x;\n}\n\nint main()\n{\n    int n;\n    int ans = 0;\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        int x1, x2, y1, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        appear.insert(y1);\n        appear.insert(y2);\n        if(y1 == y2)\n        {\n            segment tmp1, tmp2;\n            tmp1.vertical = false;\n            tmp2.vertical = false;\n            tmp1.start = true;\n            tmp2.start = false;\n            tmp1.y1 = tmp1.y2 = y1;\n            tmp2.y1 = tmp2.y2 = y1;\n            tmp1.x = min(x1, x2);\n            tmp2.x = max(x1, x2);\n            space.push_back(tmp1);\n            space.push_back(tmp2);\n        }\n        else\n        {\n            segment tmp;\n            tmp.vertical = true;\n            tmp.x = x1;\n            tmp.y1 = min(y1, y2);\n            tmp.y2 = max(y1, y2);\n            space.push_back(tmp);\n        }\n    }\n    set<int>::iterator it = appear.begin();\n    for(int i = 0; i < appear.size(); ++i)\n    {\n        index[*it] = i + 1;\n        it++;\n    }\n    N = appear.size();\n\n    sort(space.begin(), space.end(), cmp);\n    for(int i = 0; i < space.size(); ++i)\n    {\n        if(space[i].vertical) ans += query(index[space[i].y1], index[space[i].y2]);\n        else if(space[i].start) add(index[space[i].y1], 1);\n        else add(index[space[i].y1], -1);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator + (Point p){return Point(x + p.x, y + p.y);}\n  Point operator - (Point p){return Point(x - p.x, y - p.y);}\n  Point operator * (double a){return Point(x * a, y * a);}\n  Point operator / (double a){return Point(x / a, y / a);}\n\n  double abs(){return sqrt(norm());}\n  double norm(){return x * x + y * y;}\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n};\n\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(){}\n  Segment(Point p1, Point p2): p1(p1), p2(p2){}\n};\n\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\nPoint reflect(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p0.x - p1.x, p0.y - p1.y);\n  Vector v21 = Vector(p2.x - p1.x, p2.y - p1.y);\n  double t = -1 * ((p2.x - p1.x) * (p1.x - p0.x) + (p2.y - p1.y) * (p1.y - p0.y)) / (pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\n  return (v21 * t - v01) * 2 + p0;\n}\n\nPoint project(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p0.x - p1.x, p0.y - p1.y);\n  Vector v21 = Vector(p2.x - p1.x, p2.y - p1.y);\n  double t = -1 * ((p2.x - p1.x) * (p1.x - p0.x) + (p2.y - p1.y) * (p1.y - p0.y)) / (pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\n  return v21 * t + p1;\n}\n\ndouble dis(Point p1, Point p2){\n  return (p1 - p2).abs();\n}\n\ndouble getdis(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0) return dis(s.p1, p);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0) return dis(s.p2, p);\n  return dis(project(p, s.p1, s.p2), p);\n}\n\nstring ccw(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p1.x - p0.x, p1.y - p0.y);\n  Vector v02 = Vector(p2.x - p0.x, p2.y - p0.y);\n  if(equals(cross(v01, v02), 0)){\n    if(dot(v01, v02) < 0) return \"ONLINE_BACK\";\n    else if(equals(v01.abs(), v02.abs()) == true || v01.abs() > v02.abs()) return \"ON_SEGMENT\";\n    else return \"ONLINE_FRONT\";\n  }\n  else if(cross(v01, v02) > 0) return \"COUNTER_CLOCKWISE\";\n  else return \"CLOCKWISE\";\n}\n\nbool intersect(Segment s1, Segment s2){\n  if(ccw(s1.p1, s1.p2, s2.p2) == \"ON_SEGMENT\" || ccw(s1.p1, s1.p2, s2.p1) == \"ON_SEGMENT\") return true;\n  if(ccw(s2.p1, s2.p2, s1.p2) == \"ON_SEGMENT\" || ccw(s2.p1, s2.p2, s1.p1) == \"ON_SEGMENT\") return true;\n  if(ccw(s1.p1, s1.p2, s2.p1) != ccw(s1.p1, s1.p2, s2.p2)){\n    if(ccw(s1.p1, s2.p1, s2.p2) != ccw(s1.p2, s2.p1, s2.p2)) return true;\n  }\n  return false;\n}\n\nPoint getcrosspoint(Segment s1, Segment s2){\n  Vector base = s2.p2 - s2.p1;\n  Vector hypo1 = s1.p1 - s2.p1;\n  Vector hypo2 = s1.p2 - s2.p2;\n  double d1, d2;\n  d1 = abs(cross(base, hypo1)) / base.abs();\n  d2 = abs(cross(base, hypo2)) / base.abs();\n  return s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getcrosspointcl(Circle c, Line l){\n  Point p = project(c.c, l.p1, l.p2), s;\n  if(p == l.p1) s = l.p2;\n  else s = l.p1;\n  Vector v1 = Vector(p - s);\n  Vector v2 = Vector(c.c - p);\n  double k1, k2, a, b, d;\n  a = v1.abs() * v1.abs();\n  b = -2 * pow(v1.abs(), 2) -2 * dot(v1, v2);\n  d = pow(v1.abs(), 2) + 2 * dot(v1, v2) + pow(v2.abs(), 2) - pow(c.r, 2);\n  k1 = (-1 * b + pow(b * b - 4 * a * d, 0.5)) / (2 * a);\n  k2 = (-1 * b - pow(b * b - 4 * a * d, 0.5)) / (2 * a);\n  return make_pair(s + v1 * k1, s + v1 * k2);\n}\n\ndouble arg(Vector p){\n  return atan2(p.y, p.x);\n}\nVector polar(double a, double r){\n  return Point(cos(r) * a, sin(r) * a);\n}\n\npair<Point, Point> getcrosspointcc(Circle c1, Circle c2){\n  Vector cc = Vector(c1.c - c2.c);\n  double a = acos((c1.r * c1.r + cc.abs() * cc.abs() - c2.r * c2.r) / (2 * c1.r * cc.abs()));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nvoid printans(double a, double b, double c, double d){\n  cout << fixed << setprecision(10) << a << \" \" << b << \" \" << c << \" \" << d << endl;\n}\n\nint contains(Polygon g, Point p){\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++){\n    Point a = g[i] - p, b = g[(i + 1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nvoid scan(Polygon p){\n  int n = p.size();\n  sort(p.begin(), p.end());\n  stack<Point> s, s2;\n  s.push(p[0]);\n  s.push(p[1]);\n  for(int i = 2; i < n; i++){\n    Point p1 = p[i];\n    Point p0 = s.top(); s.pop();\n    Point p2 = s.top();\n    while(ccw(p0, p1, p2) == \"COUNTER_CLOCKWISE\"){\n      p0 = p2;\n      s.pop();\n      if(s.size() == 0) break;\n      p2 = s.top();\n    }\n    s.push(p0);\n    s.push(p1);\n  }\n  s2.push(p[n - 1]);\n  s2.push(p[n - 2]);\n  for(int i = n - 3; i >= 0; i--){\n    Point p1 = p[i];\n    Point p0 = s2.top(); s2.pop();\n    Point p2 = s2.top();\n    while(ccw(p0, p1, p2) == \"COUNTER_CLOCKWISE\"){\n      p0 = p2;\n      s2.pop();\n      if(s2.size() == 0) break;\n      p2 = s2.top();\n    }\n    s2.push(p0);\n    s2.push(p1);\n  }\n  vector<Point> ans;\n  while(s2.size() > 0){\n    ans.push_back(s2.top());\n    //cout << s2.top().x << \" \" << s2.top().y << endl;\n    s2.pop();\n  }\n  s.pop();\n  while(s.size() > 1){\n    ans.push_back(s.top());\n    //cout << s.top().x << \" \" << s.top().y << endl;\n    s.pop();\n  }\n  int m = ans.size();\n  int mini = 0;\n  for(int i = 1; i < m; i++){\n    if(ans[i].y < ans[mini].y){\n      mini = i;\n    }\n  }\n  cout << m << endl;\n  for(int i = 0; i < m; i++){\n    Point p = ans[(i + mini) % m];\n    cout << p.x << \" \" << p.y << endl;\n  }\n}\n\nbool compy(const Segment& s1, const Segment& s2){\n  if(s1.p1.y == s2.p1.y) return s1.p2.y > s2.p2.y;\n  return s1.p1.y < s2.p1.y;\n}\n\nint sgimg(vector<Segment>& s){\n  int n = s.size();\n  sort(s.begin(), s.end(), compy);\n  /*for(int i = 0; i < n; i++){\n    cout << s[i].p1.x << \" \" << s[i].p1.y << \" \" << s[i].p2.x << \" \" << s[i].p2.y << endl;\n  }*/\n  vector<Segment> st;\n  int cnt = 0;\n  //cout << endl << endl;\n  for(int i = 0; i < n; i++){\n    //cout << s[i].p1.x << \" \" << s[i].p1.y << \" \" << s[i].p2.x << \" \" << s[i].p2.y << \" : \";\n    //cout << st.size() << \" : \";\n    if(s[i].p1.x == s[i].p2.x) st.push_back(s[i]);\n    if(s[i].p1.y == s[i].p2.y){\n      int y = s[i].p1.y;\n      int a = s[i].p1.x, b = s[i].p2.x;\n      if(a > b){\n        int t = a;\n        a = b;\n        b = t;\n      }\n\n      for(auto it = st.begin(); it != st.end();){\n        if(it->p2.y < y) st.erase(it);\n        else it++;\n      }\n      /*for(auto it = st.begin(); it != st.end();it++){\n        cout << it->p1.x << \" \" << it->p1.y << \" \" << it->p2.x << \" \" << it->p2.y << \"->\";\n      }\n      cout << \"a : \" << a << \"b : \" << b << \" \";*/\n      for(auto it = st.begin(); it != st.end(); it++){\n        if(a <= it->p1.x && it->p1.x <= b) cnt++;\n      }\n    }\n    //cout << cnt << endl;\n  }\n  return cnt;\n}\n\nvoid solve(){\n  int n; cin >> n;\n  vector<Segment> s(n);\n  for(int i = 0; i < n; i++){\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    Point p1 = Point(x1, y1);\n    Point p2 = Point(x2, y2);\n    if(p1.y <= p2.y) s[i] = Segment(Point(x1, y1), Point(x2, y2));\n    else s[i] = Segment(Point(x2, y2), Point(x1, y1));\n  }\n  cout << sgimg(s) << endl;\n  return;\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\n//bool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n    Point operator*(double a) { return Point(a * x, a * y); }\n\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n\n    double norm() { return x * x + y * y; }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\n\ndouble norm(Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPolygon f(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble abs(Point a) {\n    return sqrt(norm(a));\n}\n\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\n\ndouble convexDiameter(Polygon g) {\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++) {\n        if (g[i].y > g[is].y) is = i;\n        if (g[i].y < g[js].y) js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do {\n        if (cross(g[(i + 1) % n] - g[i], g[(j + 1) % n] - g[j]) >= 0.0) j = (j + 1) % n;\n        else i = (i + 1) % n;\n        if (getDistance(g[i], g[j]) > d) {\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    } while (i != is || j != js);\n\n    return d;\n}\n\nstruct Segment {\n    Point p1, p2;\n\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\nPolygon andrewScan(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) != CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) != CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble area(Polygon g) {\n    if (g.size() < 3) return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for (int i = 0; i < n; i++) s += cross(g[i] - o, g[(i + 1) % n] - o);\n    return abs(s) / 2.0;\n}\n\nconst double INF = 1e10;\n\ntypedef pair<double, double> p;\np v[100000];\n\nbool comp_y(p a, p b) {\n    return a.second < b.second;\n}\n\ndouble closest_pair(p *a, int n) {\n    if (n <= 1) return INF;\n\n    int m = n / 2;\n    double x = a[m].first;\n    double d = min(closest_pair(a, m), closest_pair(a + m, n - m)); // x軸で区切られた範囲内での頂点対のみ考慮\n    inplace_merge(a, a + m, a + n, comp_y); // ソート済みの[a, a+m)と[a+m, a+n)をy座標基準でマージ\n\n    vector<p> b; // 直線 x = a[m].firstから距離d未満の点を入れる\n    for (int i = 0; i < n; i++) {\n        if (fabs(a[i].first - x) >= d) continue; // そもそもx座標の差がd以上の点は論外\n\n        // bに入っている頂点を末尾から、y座標の差がd以上になるまで見ていく\n        // y座標降順で見ていき、d以上離れた時点で打ち切り\n        for (int j = 0; j < b.size(); j++) {\n            double dx = a[i].first - b[b.size() - 1 - j].first;\n            double dy = a[i].second - b[b.size() - 1 - j].second;\n            if (dy >= d) break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n\nstruct STsum{\nprivate:\n    int n;\n    vector<int> dat;\npublic:\n    STsum(int siz){\n        n = 1;\n        while(n < siz)   n *= 2;\n        dat.resize(2*n-1, 0);\n    }\n\n    void update(int x, int val){\n        x += (n-1);\n        dat[x] += val;\n        while(x > 0){\n            x = (x-1)/2;\n            dat[x] = dat[2*x+1]+dat[2*x+2];\n        }\n    }\n\n    // focus on k-th node, who controls [l, r)\n    int query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0)   r = n;\n        if(r <= a || b <= l)    return 0;\n        if(a <= l && r <= b)    return dat[k];\n\n        int lx = query(a, b, 2*k+1, l, (l+r)/2);\n        int rx = query(a, b, 2*k+2, (l+r)/2, r);\n        return lx+rx;\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<int> xax, ax(n), ay(n), bx(n), by(n);\n    for(int i = 0; i < n; i++){\n        cin >> ax[i] >> ay[i] >> bx[i] >> by[i];\n        xax.push_back(ax[i]);  xax.push_back(bx[i]);\n    }\n    sort(xax.begin(), xax.end());\n    xax.erase(unique(xax.begin(),xax.end()),xax.end());\n    auto f = [&](int val)->int{\n        return lower_bound(xax.begin(),xax.end(),val)-xax.begin();\n    };\n\n    STsum seg(xax.size()+1);\n    vector<pair<pair<int,int>, int>> vp;\n    for(int i = 0; i < n; i++){\n        if(ax[i] == bx[i]){\n            vp.push_back({{min(ay[i],by[i]), 0}, i});\n            vp.push_back({{max(ay[i],by[i]), 2}, i});\n        }else if(ay[i] == by[i]){\n            vp.push_back({{ay[i], 1}, i});\n        }\n    }\n    sort(vp.begin(), vp.end());\n    int ans = 0;\n    for(auto p : vp){\n        if(p.first.second == 0){\n            seg.update(f(ax[p.second]), 1);\n        }else if(p.first.second == 2){\n            seg.update(f(ax[p.second]), -1);\n        }else if(p.first.second == 1){\n            ans += seg.query(f(min(ax[p.second],bx[p.second])), f(max(ax[p.second],bx[p.second]))+1);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nnamespace {\n\tstruct EndPoint\n\t{\n\t\tEndPoint(int _x, pair<int, int> _y) : x(_x), y(_y) {}\n\t\tbool operator<(const EndPoint& rhs) const { return x < rhs.x; }\n\n\t\tint x;\n\t\tpair<int, int> y;\n\t};\n}\n\ntemplate<size_t N>\nstruct FenwickTree\n{\n\tFenwickTree() : a(N, 0) {}\n\n\tint sum(int x)\n\t{\n\t\tint s = 0;\n\t\tfor (; x>0; x -= x&-x) {\n\t\t\ts = (s + a[x]);\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int x, int i)\n\t{\n\t\tfor (; x<N; x += x&-x) {\n\t\t\ta[x] = (a[x] + i);\n\t\t}\n\t}\n\n\tvector<int> a;\n};\n\nstatic int countIntersection(const vector<EndPoint>& X)\n{\n\tint num_int = 0;\n\tFenwickTree<500000> bit;\n\tfor (size_t i = 0; i < X.size(); i++) {\n\t\tif (X[i].y.second < -500000) {\n\t\t\tbit.add(X[i].y.first + 1, 1);\n\t\t}\n\t\telse if (X[i].y.second > 500000) {\n\t\t\tbit.add(X[i].y.first + 1, -1);\n\t\t}\n\t\telse {\n\t\t\tnum_int += bit.sum(X[i].y.second + 1) - bit.sum(X[i].y.first + 1);\n\t\t}\n\t}\n\n\treturn num_int;\n}\n\nint main()\n{\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> x, y;\n\tvector<pair<int, int> > c;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx.push_back(x1);\n\t\tx.push_back(x2);\n\t\ty.push_back(y1);\n\t\ty.push_back(y2);\n\t\tc.push_back(make_pair(x1, y1));\n\t\tc.push_back(make_pair(x2, y2));\n\t}\n\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tunordered_map<int, int> mx, my;\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tmx[x[i]] = i;\n\t}\n\tfor (int i = 0; i < y.size(); i++) {\n\t\tmy[y[i]] = i;\n\t}\n\n\tvector<EndPoint> X;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x1 = mx[c[i * 2].first], y1 = my[c[i * 2].second], x2 = mx[c[i * 2 + 1].first], y2 = my[c[i * 2 + 1].second];\n\t\tif (y1 == y2) {\n\t\t\tX.push_back(EndPoint(min(x1, x2) * 4 - 1, make_pair(y1 * 4, -1000000)));\n\t\t\tX.push_back(EndPoint(max(x1, x2) * 4 + 1, make_pair(y1 * 4, 1000000)));\n\t\t}\n\t\telse {\n\t\t\tX.push_back(EndPoint(x1 * 4, make_pair(min(y1, y2) * 4 - 1, max(y1, y2) * 4 + 1)));\n\t\t}\n\t}\n\n\tsort(X.begin(), X.end());\n\tcout << countIntersection(X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<set>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; };\n\n\tbool operator < (const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator ==(const Point& p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\n\ntypedef Point Vector;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\ntypedef Segment  Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = fabs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = fabs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\t//assert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point>getCrossPoints(Circle c1, Circle c2) {\n\t//assert(intersect(c1,c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n\n\n\n}\n\ntypedef vector<Point> Polygon;\n\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (fabs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS && EPS<b.y && cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n\n\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3)return s;\n\tsort(s.begin(), s.end());\n\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\n\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\n\tfor (int i = u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n\n\treturn l;\n\n}\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st;\n\tEndPoint(){}\n\tEndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}\n\t\telse return p.y < ep.p.y;\n\t}\n};\n\nEndPoint EP[2 * 100000];\n\n//manhattan\n\nint manhattanIntersection(vector<Segment>S) {\n\tint n = S.size();\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tif (S[i].p1.x > S[i].p2.x) {\n\t\t\t\tswap(S[i].p1, S[i].p2);\n\t\t\t}\n\t\t}\n\t\telse if (S[i].p1.y > S[i].p2.y)swap(S[i].p1, S[i].p2);\n\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t}\n\t\telse {\n\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + (2 * n));\n\n\tset<int>BT;\n\tBT.insert(1000000001);\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP) {\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == LEFT) {\n\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\n\t\t}\n\t}\n\treturn cnt;\n\n}\n\nint main() {\n\tint n,x1,x2,y1,y2;\n\tvector<Segment> S;\n\tcin >> n;\n\tSegment s1, s2;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tS.push_back(Segment(Point(x1, y1), Point(x2, y2)));\n\n\t}\n\tint cnt = manhattanIntersection(S);\n\n\tcout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF = 1000000001;\n\nint main(){\n  int n;\n  vector<pair<int,pii> > event;\n  set<int> list;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    int x1,y1,x2,y2;\n    scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n    if(y1==y2){\n      event.push_back(make_pair(min(x1,x2),pii(INF,y1)));\n      event.push_back(make_pair(max(x1,x2),pii(INF+1,y1)));\n    }else if(x1==x2){\n      event.push_back(make_pair(x1,pii(min(y1,y2),max(y1,y2))));\n    }\n  }\n  sort(event.begin(),event.end());\n  int ans = 0;\n  for(int i=0;i<event.size();i++){\n    int y1 = event[i].second.first, y2 = event[i].second.second;\n    if(y1>=INF){\n      if(y1==INF) list.insert(y2);\n      else list.erase(y2);\n    }else{\n      ans += distance(list.lower_bound(y1),list.upper_bound(y2));\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<PP> va;\n\tvector<int> x1(n), y1(n), x2(n), y2(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\t\tif(y1[i] == y2[i]){\n\t\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\t\tva.push_back(PP(x1[i], P(-1, y1[i])));\n\t\t\tva.push_back(PP(x2[i], P(1, y1[i])));\n\t\t}else if(x1[i] == x2[i]){\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\tva.push_back(PP(x1[i], P(0, i)));\n\t\t}\n\t}\n\tsort(va.begin(), va.end());\n\tint res = 0;\n\tset<int> seta;\n\tset<int>::iterator itr, last;\n\tfor(int i = 0; i < va.size(); i++){\n\t\tif(va[i].second.first == -1){\n\t\t\tseta.insert(va[i].second.second);\n\t\t}else if(va[i].second.first == 1){\n\t\t\tseta.erase(va[i].second.second);\n\t\t}else if(va[i].second.first == 0){\n\t\t\titr = seta.lower_bound(y1[va[i].second.second]);\n\t\t\tlast = seta.upper_bound(y2[va[i].second.second]);\n\t\t\twhile(itr != last){\n\t\t\t\titr++;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<unordered_map>\n\n#define MAX (200000 + 1)\n\nusing namespace std;\n\nint t[MAX], N;\n\nstruct segment\n{\n    bool vertical;\n    bool start;\n    int x, y1, y2;\n};\n\nvector<segment> space;\nset<int> appear;\nunordered_map<int, int> index;\n\nint sum(int n)\n{\n    int s = 0;\n    while(n > 0)\n    {\n        s += t[n];\n        n -= n & -n;\n    }\n    return s;\n}\n\nvoid add(int n, int d)\n{\n    while(n <= N)\n    {\n        t[n] += d;\n        n += n & -n;\n    }\n    return;\n}\n\nint query(int a, int b)\n{\n    return sum(b) - sum(a - 1);\n}\n\nbool cmp(const segment& a, const segment& b)\n{\n    return a.x < b.x;\n}\n\nint main()\n{\n    int n;\n    int ans = 0;\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        int x1, x2, y1, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        appear.insert(y1);\n        appear.insert(y2);\n        if(y1 == y2)\n        {\n            segment tmp1, tmp2;\n            tmp1.vertical = false;\n            tmp2.vertical = false;\n            tmp1.start = true;\n            tmp2.start = false;\n            tmp1.y1 = tmp1.y2 = y1;\n            tmp2.y1 = tmp2.y2 = y1;\n            tmp1.x = min(x1, x2);\n            tmp2.x = max(x1, x2);\n            space.push_back(tmp1);\n            space.push_back(tmp2);\n        }\n        else\n        {\n            segment tmp;\n            tmp.vertical = true;\n            tmp.x = x1;\n            tmp.y1 = min(y1, y2);\n            tmp.y2 = max(y1, y2);\n            space.push_back(tmp);\n        }\n    }\n    set<int>::iterator it = appear.begin();\n    for(int i = 0; i < appear.size(); ++i)\n    {\n        index[*it] = i + 1;\n        it++;\n    }\n    N = appear.size();\n\n    sort(space.begin(), space.end(), cmp);\n    for(int i = 0; i < space.size(); ++i)\n    {\n        if(space[i].vertical) ans += query(index[space[i].y1], index[space[i].y2]);\n        else if(space[i].start) add(index[space[i].y1], 1);\n        else add(index[space[i].y1], -1);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 22点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint main(void)\n{\n\n    int n, count = 0;\n    Point start, end;\n    vector<Segment> v_H_seg, v_V_seg;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の定義\n        Segment s(start, end);\n\n        if( start.x == end.x )\n        {\n            // y軸に平行な直線\n            v_H_seg.push_back(s);\n        }\n        else\n        {\n            // x軸に平行な直線\n            v_V_seg.push_back(s);\n        }\n    }\n\n    // 線分の交点を検索する\n    for( int i = 0; i < v_V_seg.size(); i++)\n    {\n        for(int j = 0; j < v_H_seg.size(); j++)\n        {\n            // x, y軸方向について, 線分が交差する条件を調べる\n            if( v_V_seg[i].p1.x <= v_H_seg[j].p1.x && v_H_seg[j].p1.x <= v_V_seg[i].p2.x )\n            {\n                if( v_H_seg[j].p1.y <= v_V_seg[i].p1.y && v_V_seg[i].p1.y <= v_H_seg[j].p2.y )\n                {\n                    // 線分が交差する\n                    count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (y1 > y2) swap(y1, y2);\n\t\t\tif(y1 == y2) lines.push_back(PP(P(y1, 1), P(x1, x2)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tlines.push_back(PP(P(y1, 0), P(x1, x2)));\n\t\t\t\tlines.push_back(PP(P(y2, 2), P(x1, x2)));\n\t\t\t}\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, option = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\tif (option == 0) add(x1, 1);\n\t\t\tif (option == 2) add(x1, -1);\n\t\t\tif (option == 1) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nstruct query {\n\tint type;\n\tint lx;\n\tint len;\n};\nint main() {\n\tint N; cin >> N;\n\tmultimap<int, query>mp;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 *= 3; x2 *= 3; y1 *= 3; y2 *= 3;\n\t\tif (x1 == x2) {\n\t\t\t\n\t\t\tif (y1 > y2)swap(y1, y2);\n\t\t\tassert(y1 <= y2);\n\t\t\ty1--;\n\t\t\tmp.insert(make_pair(y1,query{ 0,x1,y2 - y1 }));\n\t\t\tmp.insert(make_pair(y2, query{ 2,x1,y2 - y1 }));\n\t\t}\n\t\telse {\n\t\t\tif (x1 > x2)swap(x1, x2);\n\t\t\tassert(x1 <= x2);\n\t\t\tmp.insert(make_pair(y1, query{1,x1,x2 - x1 }));\n\t\t}\n\t}\n\tvector<int>lines;\n\tint ans = 0;\n\tfor (auto m : mp) {\n\t\tquery q(m.second);\n\t\tif (q.type==1) {\n\t\t\tauto lt = lower_bound(lines.begin(), lines.end(), q.lx);\n\t\t\tauto rt = upper_bound(lines.begin(), lines.end(), q.lx + q.len);\n\t\t\tans += rt - lt;\n\t\t}\n\t\telse if(q.type==0){\n\t\t\tlines.insert(lower_bound(lines.begin(), lines.end(), q.lx),q.lx);\n\t\t}\n\t\telse {\n\t\t\tlines.erase(lower_bound(lines.begin(), lines.end(), q.lx));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nstruct Polygon\n{\n\tint n;\n\tPoint a[MAXN];\n\tPolygon() {}\n\tint Point_In(Point t)\n\t{\n\t\tint num = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t{\n\t\t\tif(PointOnSegment(t, a[i], a[i + 1]))\n\t\t\t\treturn 2;\n\t\t\tint k = cmp(det(a[i + 1] - a[i], t - a[i]));\n\t\t\tint d1 = cmp(a[i].y - t.y);\n\t\t\tint d2 = cmp(a[i + 1].y - t.y);\n\t\t\tif(k > 0 && d1 <= 0 && d2 > 0)\n\t\t\t\tnum++;\n\t\t\tif(k < 0 && d2 <= 0 && d1 > 0)\n\t\t\t\tnum--;\n\t\t}\n\t\treturn num != 0;\n\t}\n};\n\nstruct Polygon_convex\n{\n\tvector<Point> P;\n\tPolygon_convex(int Size = 0)\n\t{\n\t\tP.resize(Size);\n\t}\n} res(2*100000 + 50);\n\nbool comp_less(Point a, Point b)\n{\n\treturn cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nvoid convex_hull(vector<Point> a)\n{\n\tsort(a.begin(), a.end(), comp_less);\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tint m = 0;\n\tint len = a.size();\n\trep(i, 0, len - 1)\n\t{\n\t\twhile(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tint k = m;\n\tlen = a.size();\n\tdow(i, len - 2, 0)\n\t{\n\t\twhile(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif(a.size()>1)\n\t\tres.P.resize(m-1);\n}\n\nbool PointOnSegment(Point p, Point s, Point t)\n{\n\treturn cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\nPoint rotate(Point p, double cost, double sint)\n{\n\tdouble x = p.x, y = p.y;\n\treturn Point(x*cost - y*sint, x*sint + y*cost);\n}\n\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n\tdouble d = (ap - bp).norm();\n\tdouble cost = (ar*ar + d*d - br*br) / (2*ar*d);\n\tdouble sint = sqrt(1. - cost*cost);\n\tPoint v = (bp - ap) / (bp - ap).norm() * ar;\n\treturn make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\nstruct Pointt\n{\n\tint x, y;\n\tPointt(int xx = 0, int yy = 0):x(xx), y(yy){}\n};\n\nstruct Node\n{\n\tPointt p;\n\tPointt q;\n\tint id;\n\tNode(Pointt p_ = Pointt(0,0), Pointt q_ = Pointt(0, 0), int id_ = 4):p(p_), q(q_), id(id_){}\n\tfriend bool operator ==(Node a, Node b)\n\t{\n\t\treturn a.p.x == b.p.x && a.p.y == b.p.y;\n\t}\n\tfriend bool operator <(Node a, Node b)\n\t{\n\t\tif(a.p.y == b.p.y)\n\t\t\treturn a.id < b.id;\n\t\treturn a.p.y < b.p.y;\n\t}\n} node[MAX * 2];\n\nset<int> s;\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tsfi(n);\n\tint cnt = 0;\n\trep(i, 0, n - 1)\n\t{\n\t\tPointt a, b;\n\t\tscanf(\"%d%d%d%d\", &a.x, &a.y, &b.x, &b.y);\n\t\tif(cmp(a.x-b.x)==0)\n\t\t{\n\t\t\tif(a.y < b.y)\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Pointt(0, 0), 1);\n\t\t\t\tnode[cnt++] = Node(b, Pointt(0, 0), 3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Pointt(0, 0), 3);\n\t\t\t\tnode[cnt++] = Node(b, Pointt(0, 0), 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a.x < b.x)\n\t\t\t\tnode[cnt++] = Node(a, b, 2);\n\t\t\telse\n\t\t\t\tnode[cnt++] = Node(b, a, 2);\n\t\t}\n\t\t\n\t}\n\tsort(node, node + cnt);\n\t\n\tint ans = 0;\n\trep(i, 0, cnt - 1)\n\t{\n\t\tif(node[i].id == 3)\n\t\t{\n\t\t\tset<int>::iterator it = s.find(node[i].p.x);\n\t\t\ts.erase(*it);\n\t\t}\n\t\telse if(node[i].id == 1)\n\t\t{\n\t\t\ts.insert(node[i].p.x);\n\t\t}\n\t\telse if(node[i].id == 2)\n\t\t{\n\t\t\tset<int>::iterator it = s.lower_bound(node[i].p.x);\n\t\t\tfor(; (*it) <= node[i].q.x && it != s.end(); it++)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define EPS (numeric_limits<double>::epsilon())\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(const Point &p) const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator-(const Point &p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    Point operator*(const double &a) const\n    {\n        return Point(a * x, a * y);\n    }\n\n    Point operator/(const double &a) const\n    {\n        return Point(x / a, y / a);\n    }\n\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n    double norm()\n    {\n        return x * x + y * y;\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const\n    {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg_id;\n    int type;\n\n    EndPoint() {}\n\n    EndPoint(Point p, int seg_id, int type) : p(p), seg_id(seg_id), type(type) {}\n\n    bool operator<(const EndPoint &ep) const\n    {\n        return p.y == ep.p.y ? type < ep.type : p.y < ep.p.y;\n    }\n};\n\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n    vector<EndPoint> EP;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (S[i].p1.y == S[i].p2.y)\n        {\n            if (S[i].p1.x > S[i].p2.x)\n                swap(S[i].p1, S[i].p2);\n        } else\n        {\n            if (S[i].p1.y > S[i].p2.y)\n                swap(S[i].p1, S[i].p2);\n        }\n\n        if(S[i].p1.y == S[i].p2.y)\n        {\n            EP.emplace_back(S[i].p1, i, LEFT);\n            EP.emplace_back(S[i].p2, i, RIGHT);\n        } else\n        {\n            EP.emplace_back(S[i].p1, i, BOTTOM);\n            EP.emplace_back(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP.begin(), EP.end());\n\n    set<int> BinaryTree;\n    int count = 0;\n\n    for(EndPoint endPoint : EP)\n    {\n        if(endPoint.type == TOP)\n            BinaryTree.erase(endPoint.p.x);\n        else if(endPoint.type == BOTTOM)\n            BinaryTree.insert(endPoint.p.x);\n        else if(endPoint.type == LEFT)\n        {\n            auto begin = BinaryTree.lower_bound(S[endPoint.seg_id].p1.x);\n            auto end = BinaryTree.upper_bound(S[endPoint.seg_id].p2.x);\n            count += distance(begin, end);\n        }\n    }\n    return count;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<Segment> S;\n    S.reserve(n);\n    int x1, y1, x2, y2;\n    for(int i = 0; i < n; i++)\n    {\n        cin >> x1 >> y1 >> x2 >> y2;\n        S.push_back(Segment{Point(x1, y1), Point(x2, y2)});\n    }\n\n    cout << manhattanIntersection(S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//曼哈顿几何问题:有n条平行坐标轴(x或y)的直线，求所有的交点个数\n//使用平面扫描可以高效求解 \n#include <iostream>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n//端点类型，下、左、右、上 \nenum {\n\tBOTTOM,LEFT,RIGHT,TOP\n};\n\nclass EndPoint {\n\tpublic:\n\tlong x,y;\n\tint type;\n\tint r_x; //如果是左端点，则需要知道它的右端点x坐标 \n\tvoid set(long x,long y) {\n\t\tthis->x = x;\n\t\tthis->y = y; \n\t}\n\tvoid setType(int type) {\n\t\tthis->type = type;\n\t}\n\tbool operator<(EndPoint & p) {\n\t\t//按y排序，如果y相同，按左右端点排序 \n\t\tif (y == p.y) {\n\t\t\treturn type < p.type;\n\t\t} else {\n\t\t\treturn y < p.y;\n\t\t}\n\t}\n};\n\n\nint n;\nint EP_L;\nEndPoint *EP; //端点数组\n\nint solve() {\n\tsort(EP,EP+EP_L);//先对点排序，以满足从下往上的扫描顺序 \n\tint cnt = 0;\n\t//使用二叉树储存垂直于x轴的线段的下端点 \n\tset<long> BT;\n\t//从下往上扫描 \n\tfor (int i=0;i<EP_L;i++) {\n\t\t//遇到上端点，则将下端点删除，表明这条垂直线段已经扫描结束 \n\t\tif (EP[i].type == TOP) {\n\t\t\tBT.erase(EP[i].x);\n\t\t} else if (EP[i].type == BOTTOM) {\n\t\t\tBT.insert(EP[i].x);\n\t\t} else if (EP[i].type == LEFT) {\n\t\t\tset<long>::iterator a = BT.lower_bound(EP[i].x);\n\t\t\tset<long>::iterator b = BT.upper_bound(EP[i].r_x);\n\t\t\tcnt += distance(a,b);\n\t\t}\n\t}\n\treturn cnt;\n} \n\nint main() {\n\tcin >> n;\n\tEP_L = 2*n;\n\tEP = new EndPoint[EP_L];\n\tfor (int i=0,k=0;i<n;i++) {\n\t\tint x1,y1,x2,y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tEP[k++].set(x1,y1);\n\t\tEP[k++].set(x2,y2);\n\t\t//因为是平行于坐标轴的线段，所有只有y相等或x相等 \n\t\tif (y1 == y2) {\n\t\t\tif (x1 < x2) {\n\t\t\t\tEP[k-2].setType(LEFT);\n\t\t\t\tEP[k-2].r_x = x2;\n\t\t\t\tEP[k-1].setType(RIGHT);\n\t\t\t} else {\n\t\t\t\tEP[k-1].setType(LEFT);\n\t\t\t\tEP[k-1].r_x = x1;\n\t\t\t\tEP[k-2].setType(RIGHT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 < y2) {\n\t\t\t\tEP[k-2].setType(BOTTOM);\n\t\t\t\tEP[k-1].setType(TOP);\n\t\t\t} else {\n\t\t\t\tEP[k-1].setType(BOTTOM);\n\t\t\t\tEP[k-2].setType(TOP);\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve() << endl;\n\tdelete[] EP;\n\treturn 0;\n} \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct POINT{    \n    int x;\n    int y1;\n    int y2;    //y軸方向の線分の上端のみに使う\n    char iEvent;    //0:追加(線分左端)  1:交差(交点)  2:削除(線分右端)\n\n};\n\nbool operator<(const POINT &a, const POINT &b){    //イベントが起きる順番\n    if (a.x == b.x && a.iEvent == b.iEvent){\n        return a.y1 < b.y1;\n    }\n    if (a.x == b.x){\n        return a.iEvent < b.iEvent;\n    }\n    return a.x < b.x;\n} \n\n/*bool operator<(const xSEGMENT &zSeg1, const xSEGMENT &zSeg2){    //線分を並べる順\n    if(zSeg1.y == zSeg2.y){    //問題の条件から起こらないはず\n        return zSeg1.x1 < zSeg2.x1;\n    }\n    return zSeg1.y < zSeg2.y;\n}*/\n\n\n\nvoid INTERSECT(const set<int> &siSegment, const POINT &zPoint, int &nCount){\n    std::set<int>::iterator it = siSegment.lower_bound(zPoint.y1);\n    if((*it) < zPoint.y1){\n        return;\n    }\n    while((*it) <= zPoint.y2 && it != siSegment.end()){\n        it++;\n        nCount++;\n    }\n//    printf(\"%d/n\",nCount);\n    return;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<POINT> vzEventPoint;\n\n    for(int i = 0; i < n; i++){\n        int x1,x2,y1,y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        if(y1 == y2){\n            if(x1 > x2){\n                swap(x1, x2);\n            }\n            POINT zPointLeft,zPointRight;\n            zPointLeft.x = x1;\n            zPointLeft.y1 = y1;\n            zPointLeft.y2 = y1;\n            zPointLeft.iEvent = 0;\n            zPointRight.x = x2;\n            zPointRight.y1 = y1;\n            zPointRight.y2 = y1;\n            zPointRight.iEvent = 2;\n            \n            vzEventPoint.push_back(zPointLeft);\n            vzEventPoint.push_back(zPointRight);\n        }\n        if(x1 == x2){\n            if(y1 > y2){\n                swap(y1, y2);\n            }\n            POINT zPoint;\n            zPoint.x = x1;\n            zPoint.y1 = y1;\n            zPoint.y2 = y2;\n            zPoint.iEvent = 1;\n            vzEventPoint.push_back(zPoint);\n        }\n        \n        \n    }\n    sort(vzEventPoint.begin(), vzEventPoint.end());\n    \n    set<int> siSegment;    //y座標だけ入れる\n    int nCount = 0;\n    for (int i = 0; i < vzEventPoint.size(); i++) {\n        if (vzEventPoint[i].iEvent == 0) {    \n            siSegment.insert(vzEventPoint[i].y1);\n        } else if(vzEventPoint[i].iEvent == 2) {\n            siSegment.erase(vzEventPoint[i].y1);\n        } else {\n            INTERSECT(siSegment, vzEventPoint[i], nCount);\n        }\n    }\n    \n    printf(\"%d\\n\",nCount);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\n// 点类\nclass Point {\npublic :\n\tdouble x, y;\n\tPoint() {};\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n// 线段类\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {};\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {};\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic :\n\tPoint p;\n\tint seg, st; // 线段的ID，端点的种类\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\t// 按y坐标升序排序\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}else {\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n\n};\nEndPoint EP[2 * 1000010];\n\n// 线段相交问题，曼哈顿几何\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\t//按照端点的y坐标升序排序\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\t\t\t// 二叉搜索树\n\tBT.insert(10000000001); // 设置标记\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP)\n\t\t\tBT.erase(EP[i].p.x); //删除上端点\n\t\telse if (EP[i].st == BOTTOM)\n\t\t\tBT.insert(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\n\t\t\t// 加上b到e距离\n\t\t\tcnt += distance(b, e);\n\t\t}\n\n\t}\n\treturn cnt;\n}\nint main() {\n\tvector<Segment> S;\n\tSegment seg;\n\tint n , k = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf %lf %lf %lf\", &seg.p1.x, &seg.p1.y, &seg.p2.x, &seg.p2.y);\n\t\t//调整端点p1、p2，保证左小右大\n\t\tif (seg.p1.y == seg.p2.y) {\n\t\t\tif (seg.p1.x > seg.p2.x)\n\t\t\t\tswap(seg.p1, seg.p2);\n\t\t}\n\t\telse if (seg.p1.y > seg.p2.y) {\n\t\t\tswap(seg.p1, seg.p2);\n\t\t}\n\n\t\t// 将水平线段添加到端点列表\n\t\tif (seg.p1.y == seg.p2.y) {\n\t\t\tEP[k++] = EndPoint(seg.p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(seg.p2, i, RIGHT);\n\t\t}\n\t\telse { // 将垂直线段添加到端点列表\n\t\t\tEP[k++] = EndPoint(seg.p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(seg.p2, i, TOP);\n\t\t}\n\t\tS.push_back(seg);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection(S));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tif (y1 > y2) swap(y1, y2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (x1 == 0 || x2 == 0) while (true)\n\t\t\t{\n\n\t\t\t}\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n// セグメントツリーのライブラリ\ntemplate<typename T>\nclass SegmentTree {\npublic:\n    // _n:必要サイズ, _def:初期値かつ単位元, _operation:クエリ関数,\n    // _update:更新関数\n    SegmentTree(size_t _n, T _def, std::function<T(T, T)> _operation,\n        std::function<T(T, T)> _update)\n        : def(_def), operation(_operation), update(_update) {\n        n = 1;\n        while (n < _n) {\n            n *= 2;\n        }\n        node = std::vector<T>(2 * n - 1, def);\n    }\n\n    // 場所i(0-indexed)の値をxで更新\n    void change(int i, T x) {\n        i += n - 1;\n        node[i] = update(node[i], x);\n        while (i > 0) {\n            i = (i - 1) / 2;\n            node[i] = operation(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    // [a, b)の区間クエリを実行\n    T query(int a, int b) {\n        return _query(a, b, 0, 0, n);\n    }\n\n    // 添字でアクセス\n    T operator[](int i) {\n        return node[i + n - 1];\n    }\n\n    int n;                       // 葉の数\n    std::vector<T> node;              // データを格納するvector\nprivate:\n    T def;                       // 初期値かつ単位元\n    std::function<T(T, T)> operation; // 区間クエリで使う処理\n    std::function<T(T, T)> update;    // 点更新で使う処理\n\n    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n    T _query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return def; // 交差しない\n        if (a <= l && r <= b)\n            return node[k]; // a,l,r,bの順で完全に含まれる\n        else {\n            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n            return operation(c1, c2);\n        }\n    }\n};\n\nint main() {\n\n    int n;\n    cin >> n;\n\n    // x座標，イベント, y座標(min), y座標(max)\n    vector<tuple<int, int, int, int>>  events;\n\n    vector<int> vy;\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 == x2) { // 縦\n            events.emplace_back(x1, 0, min(y1, y2), max(y1, y2));\n            vy.emplace_back(y1);\n            vy.emplace_back(y2);\n        }\n        else { // 横\n            events.emplace_back(min(x1, x2), -1, y1, 0);\n            events.emplace_back(max(x1, x2), 1, y1, 0);\n            vy.emplace_back(y1);\n        }\n    }\n\n    sort(events.begin(), events.end());\n\n    // y座標の圧縮を行う\n    sort(vy.begin(), vy.end());\n    vy.erase(unique(vy.begin(), vy.end()), vy.end());\n\n    map<int, int> mp;\n    for (int i = 0, n = vy.size(); i < n; ++i) {\n        mp[vy[i]] = i;\n    }\n\n    long long ans = 0LL;\n\n    auto update = [](int a, int b) {return a + b; };\n    auto operation = [](int a, int b) {return a + b; };\n    SegmentTree<int> seg(n, 0, operation, update);\n\n    //for (auto& [x, e, y1, y2] : events) {\n    for (auto& event : events) {\n        int e = get<1>(event);\n        int y1 = get <2>(event);\n        int y2 = get<3>(event);\n        if (e == -1)seg.change(mp[y1], +1); // 追加\n        else if (e == 1) seg.change(mp[y1], -1); // 削除\n        else { // チェック\n            ans += seg.query(mp[y1], mp[y2] + 1);\n        }\n    }\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        /*\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n        */\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の集合\nvector<Segment> v_parallel_x;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x.push_back(seg);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n            }\n\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].y == v_parallel_y[j].p1.y )\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x[p].p1.x )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x[p].p1.x; k <= v_parallel_x[p].p2.x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n            }\n        }\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS=1e-10;\n\nbool equals(double a,double b)\n{\n\treturn a>b?a-b<EPS:b-a<EPS;\n}\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double inx=0.0,double iny=0.0):x(inx),y(iny){}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tbool operator<(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator==(const Point &p)const{return equals(x,p.x)&&equals(y,p.y);}\n\tdouble norm()\n\t{\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs()\n\t{\n\t\treturn sqrt(norm());\n\t}\n};\n\ntypedef Point Vector;\n\nclass Segment\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tVector getvector()\n\t{\n\t\treturn p2-p1;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point inc=Point(),double inr=0.0):c(inc),r(inr){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\nconst int counter_clockwise=1;\nconst int clockwise=-1;\nconst int on_segment=0;\nconst int online_back=2;\nconst int online_front=-2;\n\ndouble norm(Vector a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\nbool isorthogonal(Vector a,Vector b)\n{\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isorthogonal(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isorthogonal(a1-a2,b1-b2);\n}\n\nbool isorthogonal(Segment s1,Segment s2)\n{\n\treturn equals(dot(s1.getvector(),s2.getvector()),0.0);\n}\n\nbool isparallel(Vector a,Vector b)\n{\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isparallel(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isparallel(a1-a2,b1-b2);\n}\n\nbool isparallel(Segment s1,Segment s2)\n{\n\treturn equals(cross(s1.getvector(),s2.getvector()),0.0);\n}\n\nPoint project(Segment s,Point p)\n{\n\tVector base=s.getvector();\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p)\n{\n\treturn project(s,p)*2.0-p;//p+(project(s,p)-p)*2.0\n}\n\ndouble getdistance(Point a,Point b)\n{\n\treturn abs(a-b);\n}\n\ndouble getdistancelp(Line l,Point p)//Line,Point\n{\n\tdouble s=abs(cross(l.p2-l.p1,p-l.p1));\n\treturn s/abs(l.getvector());\n}\n\ndouble getdistancesp(Segment s,Point p)\n{\n\tif(dot(s.getvector(),p-s.p1)<0.0)return abs(p-s.p1);\n\telse if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\telse return getdistancelp(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return counter_clockwise;\n\telse if(cross(a,b)<-EPS)return clockwise;\n\telse if(dot(a,b)<-EPS)return online_back;\n\telse if(a.norm()<b.norm())return online_front;\n\telse return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2)\n{\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getdistance(Segment s1,Segment s2)\n{\n\tif(intersect(s1,s2))return 0.0;\n\telse return min(min(getdistancesp(s1,s2.p1),getdistancesp(s1,s2.p2)),\n\t\t\tmin(getdistancesp(s2,s1.p1),getdistancesp(s2,s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n\tVector base=s2.getvector();\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+s1.getvector()*t;\n}\n\npair<Point,Point> getcrosspoint(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=l.getvector()/abs(l.getvector());\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p)\n{\n\treturn atan2(p.y,p.x);\n}\n\nPoint polar(double r,double theta)\n{\n\treturn Point(r*cos(theta),r*sin(theta));\n}\n\npair<Point,Point> getcrosspoint(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0*c1.r*d));\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\nconst int Bottom=0;\nconst int Left=1;\nconst int Right=2;\nconst int Top=3;\n\nclass endPoint\n{\npublic:\n\tPoint p;\n\tint seg;//id of Point\n\tint st;//kind of Point\n\tendPoint(){}\n\tendPoint(Point inp,int inseg,int inst):p(inp),seg(inseg),st(inst){}\n\tbool operator<(const endPoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;//Bottom->Left->Right->Top\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nendPoint EP[200000];\n\nint manhattanintersection(vector<Segment> s)\n{\n\tint n=s.size();\n\tdouble sto;\n\t\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tif(s[i].p1.x>s[i].p2.x)\n\t\t\t{\n\t\t\t\tsto=s[i].p1.x;\n\t\t\t\ts[i].p1.x=s[i].p2.x;\n\t\t\t\ts[i].p2.x=sto;\n\t\t\t}\n\t\t}\n\t\telse if(s[i].p1.y>s[i].p2.y)\n\t\t{\n\t\t\tsto=s[i].p1.y;\n\t\t\ts[i].p1.y=s[i].p2.y;\n\t\t\ts[i].p2.y=sto;\n\t\t}\n\t\t\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Left);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Bottom);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Top);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+2*n);\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==Top)BT.erase(EP[i].p.x);\n\t\telse if(EP[i].st==Bottom)BT.insert(EP[i].p.x);\n\t\telse if(EP[i].st==Left)\n\t\t{\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),s[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),s[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\t\n\treturn cnt;\n}\nPolygon andrewscan(Polygon s)\n{\n\tPolygon u,l;\n\tif(s.size()<=2)return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\t\n\tfor(int i=2;i<s.size();i++)\n\t{\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i=s.size()-3;i>=0;i--)\n\t{\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\nconst int in=2;\nconst int on=1;\nconst int out=0;\n\nint contain(Polygon g,Point p)\n{\n\tint n=g.size();\n\tbool x=false;\n\tPoint a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta=g[i]-p;\n\t\tb=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return on;\n\t\tif(a.y>b.y)\n\t\t{\n\t\t\tPoint sto=a;\n\t\t\ta=b;\n\t\t\tb=sto;\n\t\t}\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n\t}\n\treturn x?in:out;\n}\nint main()\n{\n\tint q;cin>>q;\n\tSegment s1;\n\tvector<Segment> s;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>s1.p1.x>>s1.p1.y>>s1.p2.x>>s1.p2.y;\n\t\ts.push_back(s1);\n\t}\n\tcout<<manhattanintersection(s)<<endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2018/12/12.\n//\n/*\n * 关键：1.定义EndPoint类：Point，point type，belong to which segment\n *      2.求一条水平线段与垂直线段的交点时，直接使用stl中set.lower_bound和set.upper_bound方法，\n *      再计算这两个方法返回的迭代器之间的距离即可知道这条水平线段与几条垂直线段有交点\n */\n\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <vector>\n\n#define EPSLON 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPSLON)\n\nusing namespace std;\n\n// 点\nclass Point {\npublic:\n    int x;\n    int y;\n\n    Point() {}\n\n    Point(int x, int y) : x(x), y(y) {}\n\n    Point operator+(Point a) {\n        return Point(x + a.x, y + a.y);\n    }\n\n    Point operator-(Point a) {\n        return Point(x - a.x, y - a.y);\n    }\n\n    Point operator*(int a) {\n        return Point(x * a, y * a);\n    }\n\n    Point operator/(int a) {\n        return Point(x / a, y / a);\n    }\n\n    int norm() {\n        return x * x + y * y;\n    }\n\n    int absVector() {\n        return sqrt(norm());\n    }\n\n    bool operator==(Point a) const {\n        return equals(x, a.x) && equals(y, a.y);\n    }\n};\n\ntypedef Point Vector;\n\n// 线段\nclass Segment {\npublic:\n    Point a, b;\n\n    Segment(Point a, Point b) : a(a), b(b) {}\n};\n\nint dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nint cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg;\n    int tp; //点类型\n    EndPoint() {}\n\n    EndPoint(Point p, int s, int tp) : p(p), seg(s), tp(tp) {}\n\n    bool operator<(EndPoint ep) const {\n        if (p.y == ep.p.y) {\n            return tp < ep.tp;\n        } else {\n            return p.y < ep.p.y;\n        }\n    }\n};\n\n#define DOWN 0\n#define LEFT 1\n#define RIGHT 2\n#define UP 3\nvector<Segment> s;\nint n;\n\nint manhattanIntersection(vector<Segment> s) {\n    int n = s.size();\n    for (int i = 0; i < n; ++i) {\n        if (s[i].a.y == s[i].b.y) {\n            if (s[i].a.x > s[i].b.x) swap(s[i].a, s[i].b);\n        } else if (s[i].a.y > s[i].b.y) swap(s[i].a, s[i].b);\n    }\n\n    EndPoint ep[2 * n];  //构建endpoint\n    for (int i = 0; i < n; ++i) {\n        if (s[i].a.y == s[i].b.y) {\n            ep[2 * i] = EndPoint(s[i].a, i, LEFT);\n            ep[2 * i + 1] = EndPoint(s[i].b, i, RIGHT);\n        } else if (s[i].a.x == s[i].b.x) {\n            ep[2 * i] = EndPoint(s[i].a, i, DOWN);\n            ep[2 * i + 1] = EndPoint(s[i].b, i, UP);\n        }\n    }\n    sort(ep, ep + 2 * n);\n//    for (int i = 0; i < 2 * n; ++i) {\n//        printf(\"%d %d %d\\n\", ep[i].p.x, ep[i].p.y, ep[i].tp);\n//    }\n\n    set<int> bst;\n    int count = 0;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (ep[i].tp == DOWN) {\n            bst.insert(ep[i].p.x);\n        } else if (ep[i].tp == UP) {\n            bst.erase(ep[i].p.x);\n        } else if (ep[i].tp == LEFT) {\n            set<int>::iterator l = bst.lower_bound(s[ep[i].seg].a.x);\n            set<int>::iterator u = bst.upper_bound(s[ep[i].seg].b.x);\n            count += distance(l, u);\n        }\n    }\n    return count;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int x1, y1, x2, y2;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        Segment s1 = Segment(Point(x1, y1), Point(x2, y2));\n        s.push_back(s1);\n    }\n    printf(\"%d\\n\", manhattanIntersection(s));\n}\n/*\n6\n2 2 2 5\n1 3 5 3\n4 1 4 4\n5 2 7 2\n6 1 6 3\n6 5 6 7\n\n */\n"
  },
  {
    "language": "C++",
    "code": "/*\n  ????????????????????????????????????????????????\n  ??????????????????????????????????????????????????????????????????????????????????????¨??????????????°????±???????\n  ??¢?????´?????????????????¢??°?????? O(n log n)\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n    Point() {}\n};\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {\n        if (p1.y > p2.y || p1.x > p2.x)\n            swap(p1, p2);\n    }\n    Segment() {}\n};\nistream& operator>>(istream &is, Segment &s) {\n    return is >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n}\n\nenum SegmentType {\n    BOTTOM, LEFT, RIGHT, TOP,\n};\nstruct EndPoint {\n    Point p;\n    int id;\n    SegmentType type;\n    EndPoint(Point p, int id, SegmentType type) : p(p), id(id), type(type) {}\n    EndPoint() {}\n\n    bool operator<(const EndPoint &ep) const {\n        if (p.y == ep.p.y)\n            return type < ep.type;\n        return p.y < ep.p.y;\n    }\n};\n\n\nint SegmentIntersectionManhattan(const vector<Segment> &segs) {\n    const int n = segs.size();\n    int MAX_X = 0;\n    vector<EndPoint> event(2 * n);\n\n    for (int i = 0, k = 0; i < n; ++i) {\n        if (segs[i].p1.y == segs[i].p2.y) { // horizontal segment\n            event[k++] = EndPoint(segs[i].p1, i, LEFT);\n            event[k++] = EndPoint(segs[i].p2, i, RIGHT);\n        }\n        else { // vertical setment\n            event[k++] = EndPoint(segs[i].p1, i, BOTTOM);\n            event[k++] = EndPoint(segs[i].p2, i, TOP);\n        }\n\n        MAX_X = max({MAX_X, segs[i].p1.x, segs[i].p2.x});\n    }\n\n    sort(event.begin(), event.end());\n\n    set<int> bt; // binary search tree\n    bt.insert(MAX_X + 1); // sentinel\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * n; ++i) {\n        if (event[i].type == TOP)\n            bt.erase(event[i].p.x);\n        else if (event[i].type == BOTTOM)\n            bt.insert(event[i].p.x);\n        else if (event[i].type == LEFT) {\n            auto lb = lower_bound(bt.begin(), bt.end(), segs[event[i].id].p1.x);\n            auto ub = upper_bound(bt.begin(), bt.end(), segs[event[i].id].p2.x);\n\n            cnt += distance(lb, ub);\n        }\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    cin >> n;\n    vector<Segment> segs(n);\n    for (int i = 0; i < n; ++i)\n        cin >> segs[i];\n\n    cout << SegmentIntersectionManhattan(segs) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の点の集合 ( 開始点と終了点で集合を分割する )\nvector<Point> v_parallel_x_start;\nvector<Point> v_parallel_x_end;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( start.y == end.y )\n        {\n            if( start.x > end.x )\n            {\n                swap(start, end);\n            }\n        }else if( end.y < start.y )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x_start.push_back(start);\n            v_parallel_x_end.push_back(end);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n    sort(v_parallel_x_start.begin(), v_parallel_x_start.end());\n    sort(v_parallel_x_end.begin(), v_parallel_x_end.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].x == v_parallel_y[j].p1.x\n                && v_EP[i].y == v_parallel_y[j].p1.y)\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n                break;\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x_start.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x_start[p].x\n                && v_EP[i].y == v_parallel_x_start[p].y )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x_start[p].x; k <= v_parallel_x_end[p].x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n                //　線分は重ならないので, 1つ見つかれば処理終了\n                break;\n            }\n        }\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].x == v_parallel_y[j].p2.x\n                && v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n                break;\n            }\n        }\n\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1>x2)swap(x1,x2);\n\t\tif(y1>y2)swap(y1,y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\t//sort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(-2000000000,-2000000000)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(-2000000000,-2000000000)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"inspect.hpp\"\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1>x2)swap(x1,x2);\n\t\tif(y1>y2)swap(y1,y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\t//sort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(-1000000000,-1000000000)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(0,0)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\tvoid make(){ cin>>x>>y;}\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n\tvoid make(){ s.make(); e.make();}\n\tbool samex(){ return s.x == e.x;}\n\tbool samey(){ return s.y == e.y;}\n\tvoid swap(){\n\t\tpoint tmp = s;\n\t\ts = e;\n\t\te = tmp;\n\t}\n\tvoid lr(){\n\t\tif(s.x>e.x){\n\t\t\tswap();\n\t\t}\n\t\tif(s.x==e.x && s.y > e.y){\n\t\t\tswap();\n\t\t}\n\t}\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\ntypedef struct event{\n\tline l;\n\tdouble x;\n\tint type;\n\tbool operator < (const event &e){\n\t\treturn x!=e.x ? x<e.x : type < e.type ;\n\t}\n\tbool operator == (const event &e){\n\t\treturn x==e.x;\n\t}\n}event;\nint solve(vector<line> &l){\n\tint res = 0;\n\tvector<line> ax,ay;\n\tint n = l.size();\n\tvector<event> ev;\n\tfor(int i=0;i<n;i++){\n\t\tif(l[i].samex()){\n\t\t\tax.push_back(l[i]);\n\t\t\tevent tmp ;\n\t\t\ttmp.l = l[i];\n\t\t\ttmp.x = l[i].s.x;\n\t\t\ttmp.type = 2;\n\t\t\tev.push_back(tmp);\n\t\t}\n\t\tif(l[i].samey()){\n\t\t\tay.push_back(l[i]);\n\t\t\tevent tmp;\n\t\t\ttmp.l = l[i];\n\t\t\ttmp.x = l[i].s.x;\n\t\t\ttmp.type = 1;\n\t\t\tev.push_back(tmp);\n\t\t\ttmp.x = l[i].e.x;\n\t\t\ttmp.type = 3;\n\t\t\tev.push_back(tmp);\n\t\t}\n\t}\n\tsort(ev.begin(),ev.end());\n\tset<double> S;\n\tfor(int i=0;i<ev.size();i++){\n\t\tif(ev[i].type == 1){\n\t\t\tS.insert(ev[i].l.s.y);\n\t\t}\n\t\tif(ev[i].type == 3){\n\t\t\tS.erase(ev[i].l.s.y);\n\t\t}\n\t\tif(ev[i].type == 2){\n\t\t\tint d = min(ev[i].l.s.y,ev[i].l.e.y);\n\t\t\tint u = max(ev[i].l.s.y,ev[i].l.e.y);\n\t\t\tauto it = S.lower_bound(d);\n\t\t\twhile(d<=*it&&*it<=u && it!=S.end()){\n\t\t\t\tres++;\n\t\t\t\tit++;\n\t\t\t//\tcout<<ev[i].x<<' '<<*it<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<line> l(n);\n\tfor(int i=0;i<n;i++){\n\t\tl[i].make();\n\t\tl[i].lr();\n\t}\n\tcout<<solve(l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define EPS (1e-10)\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\n\nconstexpr int MOD = 1000000007;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point(const Point& p) : x(p.x), y(p.y) {}\n\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n\n    bool operator<(const Point& p) const { return x != p.x ? x < p.x : y < p.y; }\n    bool operator==(const Point& p) const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n    static double norm(const Point& p) { return sqrt(p.x * p.x + p.y * p.y); }\n    static double dot(const Point& p1, const Point& p2) { return p1.x * p2.x + p1.y * p2.y; }\n    static double cross(const Point& p1, const Point& p2) { return p1.x * p2.y - p1.y * p2.x; }\n};\n\nstruct Segment {\n    Point s, t;\n    Segment(const Point& s, const Point& t) : s(s), t(t) {}\n    Segment(const Segment& seg) : s(seg.s), t(seg.t) {}\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nstruct EndPoint {\n    int id;\n    Point p;\n    int type;\n\n    EndPoint(int id, const Point p, int type) : id(id), p(p), type(type) {}\n    EndPoint(const EndPoint& ep) : id(ep.id), p(ep.p), type(ep.type) {}\n};\n\nbool less_y(const EndPoint& ep1, const EndPoint& ep2) {\n    return ep1.p.y != ep2.p.y ? ep1.p.y < ep2.p.y : ep1.type < ep2.type;\n}\n\nint sweep(vector<EndPoint> EPs, const vector<Segment>& segs) {\n    // Sort EPs.\n    sort(EPs.begin(), EPs.end(), less_y);\n\n    // Initialize binary tree.\n    set<int> tree;\n    tree.insert(INT_MAX);\n\n    int sum = 0;\n    for (EndPoint ep : EPs) {\n        if (ep.type == TOP) {\n            // Upper point of vertical line.\n            tree.erase(ep.p.x);\n        } else if (ep.type == BOTTOM) {\n            // Lower point of vertical line.\n            tree.insert(ep.p.x);\n        } else if (ep.type == LEFT) {\n            // Left point of horizontal line.\n            int s = segs[ep.id].s.x;\n            int t = segs[ep.id].t.x;\n            auto s_itr = tree.lower_bound(s);\n            auto t_itr = tree.upper_bound(t);\n            sum += distance(s_itr, t_itr);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    vector<EndPoint> EPs;\n    vector<Segment> segs;\n\n    rep(i, 0, n) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        if (x1 == x2) {\n            Point s(x1, min(y1, y2));\n            Point t(x2, max(y1, y2));\n            EPs.emplace_back(i, s, BOTTOM);\n            EPs.emplace_back(i, t, TOP);\n            segs.emplace_back(s, t);\n        } else {\n            Point s(min(x1, x2), y1);\n            Point t(max(x1, x2), y2);\n            EPs.emplace_back(i, s, LEFT);\n            EPs.emplace_back(i, t, RIGHT);\n            segs.emplace_back(s, t);\n        }\n    }\n\n    cout << sweep(EPs, segs) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define all(c) (c).begin(),(c).end()\n#define x second\n#define y first\n#define a first\n#define b second\n#define Bottom 0\n#define Left 1\n#define Right 2\n#define Top 3\n#define PUSH 0\n#define SUM 1\n#define POP 2\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int>piii;\ntypedef pair<pii,pii> segment;\n\nconst int MAX_N = 1<<17;\nint n,dat[2*MAX_N];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  fill(dat,dat+2*MAX_N,0);\n}\n\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n  }\n}\n\nint sum(int a,int b,int k=0,int l=0,int r=n){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return dat[k];\n  \n  int m=(l+r)/2;\n  int vl=sum(a,b,k*2+1,l,m);\n  int vr=sum(a,b,k*2+2,m,r);\n  return vl+vr;\n}\n\nmap<int,int> xmp,ymp;\n\nstruct Q{\n  int y,x1,x2,q;\n  Q(){}\n  Q(int y,int x1,int x2,int q):y(y),x1(x1),x2(x2),q(q){}\n};\n\nbool cmp(Q p,Q q){\n  if(p.y!=q.y)return p.y<q.y;\n  return p.q<q.q;\n}\n\nint main(void){\n\n  int m;\n  cin >> m;\n  \n  vector<int>xv,yv;\n  vector<segment>v(m);\n  vector<Q>query;\n  \n  for(int i=0;i<m;i++){\n    cin >> v[i].a.x >> v[i].a.y >> v[i].b.x >> v[i].b.y;\n\n    if(v[i].a.x>v[i].b.x)swap(v[i].a.x,v[i].b.x);\n    if(v[i].a.y>v[i].b.y)swap(v[i].a.y,v[i].b.y);\n\n    xv.push_back(v[i].a.x);\n    xv.push_back(v[i].b.x);\n  }\n  \n  sort(all(xv));\n\n  for(int i=0;i<m;i++){\n    if(v[i].a.x==v[i].b.x){\n      query.push_back(Q(v[i].a.y,v[i].a.x,-1,PUSH));\n      query.push_back(Q(v[i].b.y,v[i].b.x,-1,POP));\n    }\n    if(v[i].a.y==v[i].b.y){\n      query.push_back(Q(v[i].a.y,v[i].a.x,v[i].b.x,SUM));\n    } \n  }\n  \n  sort(all(query),cmp);\n\n  xv.erase(unique(all(xv)),xv.end());\n\n  for(int i=0;i<xv.size();i++)xmp[xv[i]]=i;\n\n  init(xv.size());\n  \n  int cnt=0;\n  for(int i=0;i<query.size();i++){\n    if(query[i].q==PUSH)update(xmp[query[i].x1],1);\n    if(query[i].q==POP)update(xmp[query[i].x1],0);\n    if(query[i].q==SUM)cnt+=sum(xmp[query[i].x1],xmp[query[i].x2]+1);\n  }\n  cout << cnt << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\nusing namespace std;\n\nenum Eptype{\n    BOTTOM, LEFT, RIGHT, TOP,\n};\n\nclass EndPoint {\npublic:\n  int x, y;\n  Eptype t;\n  EndPoint() {}\n  EndPoint(int x, int y, Eptype t) : x(x), y(y), t(t) {}\n  bool operator<(const EndPoint ep) {\n    if (y == ep.y)\n      return t < ep.t;\n    return y < ep.y;\n  }\n};\n\nint manhattan_scan(vector<EndPoint> &epts) {\n  sort(epts.begin(), epts.end());\n\n  set<int> xs;\n  int count = 0;\n  set<int>::iterator lb, ub;\n  for (auto ept : epts) {\n    if (ept.t == BOTTOM) {\n      xs.insert(ept.x);\n    }else if (ept.t == LEFT) {\n      lb = lower_bound(xs.begin(), xs.end(), ept.x);\n      // Definitely the next ept is the RIGHT endpoint of this segment\n      // because epts is sorted.\n    }else if (ept.t == RIGHT) {\n      ub = upper_bound(xs.begin(), xs.end(), ept.x);\n      count += distance(lb, ub);\n    }else if (ept.t == TOP) {\n      xs.erase(ept.x);\n    }\n  }\n  return count;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<EndPoint> epts;\n  for (int i = 0; i < n; i++) {\n    Eptype t1, t2;\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    if (x1 == x2) {\n      t1 = BOTTOM;\n      t2 = TOP;\n      if(y1 > y2)\n        swap(t1, t2);\n    } else {\n      t1 = LEFT;\n      t2 = RIGHT;\n      if(x1 > x2)\n        swap(t1, t2);\n    }\n    epts.push_back(EndPoint(x1, y1, t1));\n    epts.push_back(EndPoint(x2, y2, t2));\n  }\n  cout << manhattan_scan(epts) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,cnt,ans,HASH[200001],tr[200001];\nstruct point{int x,y;}a[200001];\nstruct seg{int k,x,y,r;}s[2000001];\ninline bool cmp3(seg a,seg b){\n    if(a.y==b.y)return a.k>b.k;\n    return a.y<b.y;\n}\nint find(int x)\n{\n    int l=0,r=m+1;\n    while(l+1<r)\n    {\n        int mid=(l+r)>>1;\n        if(HASH[mid]>=x)r=mid;\n        else l=mid;\n    }\n    return r;\n}\nvoid insert(int k,int l,int r,int t)//0横线,1竖线\n{\n    if(!k){s[++cnt].x=find(l);s[cnt].r=find(r);s[cnt].y=t;s[cnt].k=0;}\n    else{\n        s[++cnt].x=find(t);s[cnt].y=l;s[cnt].k=1;\n        s[++cnt].x=find(t);s[cnt].y=r;s[cnt].k=-1;\n    }\n}\nvoid update(int x,int y)\n{\n    while(x<2e5)\n    {\n        tr[x]+=y;\n        x+=x&(-x);\n    }\n}\nint ask(int x)\n{\n    int s=0;\n    while(x){\n        s+=tr[x];\n        x-=x&(-x);\n    }\n    return s;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=2*n;i++){\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n        HASH[i]=a[i].x;\n    }\n    sort(HASH+1,HASH+2*n+1);\n    m=unique(HASH+1,HASH+2*n+1)-(HASH+1);\n    for(int i=1;i<2*n;i+=2){\n        if(a[i].x==a[i+1].x){\n            if(a[i].y>a[i+1].y)swap(a[i],a[i+1]);\n            insert(1,a[i].y,a[i+1].y,a[i].x);\n        }else{\n            if(a[i].x>a[i+1].x)swap(a[i],a[i+1]);\n            insert(0,a[i].x,a[i+1].x,a[i].y);\n        }\n    }\n    sort(s+1,s+cnt+1,cmp3);\n    for(int i=1;i<=cnt;i++){\n//        if(!s[i].k)cout<<s[i].x<<\" \"<<s[i].r<<endl;\n//        else cout<<s[i].x<<\" \"<<s[i].y<<\" \"<<s[i].k<<endl;\n        if(!s[i].k)ans+=ask(s[i].r)-ask(s[i].x-1);\n        else update(s[i].x,s[i].k);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\nusing namespace std;\n\nclass P{\npublic:\n\tint x,y;\n\tP(int xx=0,int yy=0){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n};\n\nclass Segment{\npublic:\n\tP p1,p2;\n\tSegment(P pp1=P(),P pp2=P()){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\nclass EndPoint{\npublic:\n\tP p;\n\tint seg,st;\n\tEndPoint(){}\n\tEndPoint(P pp,int segg,int stt){\n\t\tp=pp;\n\t\tseg=segg;\n\t\tst=stt;\n\t}\n\n\tbool operator <(const EndPoint &ep)const{\n\t\tif(p.y==ep.p.y){\n\t\t\treturn st<ep.st;\n\t\t}\n\t\treturn p.y<ep.p.y;\n\t}\n};\n\nEndPoint EP[2000000];\n\nint manhattanIntersection(vector<Segment> S){\n\tint n=S.size();\n\tfor(int i=0,k=0;i<n;i++){\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tif(S[i].p1.x>S[i].p2.x)swap(S[i].p1,S[i].p2);\n\t\t}else if(S[i].p1.y>S[i].p2.y)swap(S[i].p1,S[i].p2);\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tEP[k++]=EndPoint(S[i].p1,i,LEFT);\n\t\t\tEP[k++]=EndPoint(S[i].p2,i,RIGHT);\n\t\t}else{\n\t\t\tEP[k++]=EndPoint(S[i].p1,i,BOTTOM);\n\t\t\tEP[k++]=EndPoint(S[i].p2,i,TOP);\n\t\t}\n\t}\n\tsort(EP,EP+(2*n));\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\tfor(int i=0;i<2*n;i++){\n\t\tif(EP[i].st==TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}else if(EP[i].st==BOTTOM){\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}else if(EP[i].st==LEFT){\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tint n;\n\tvector<Segment> ss;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tSegment s;\n\t\tscanf(\"%d %d\",&s.p1.x,&s.p1.y);\n\t\tscanf(\"%d %d\",&s.p2.x,&s.p2.y);\n\t\tss.push_back(s);\n\t}\n\tprintf(\"%d\\n\",manhattanIntersection(ss));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<set>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nenum\n{\n\tBOTTOM,\n\tLEFT,\n\tRIGHT,\n\tTOP\n};\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nstruct Segment\n{\n\tP p1, p2;\n\tSegment(P p1,P p2):p1(p1),p2(p2){}\n\tSegment():Segment(P(0,0),P(0,0)){}\n};\n\nstruct EndPoint\n{\n\tP p;\n\tint idx, type;\n\tEndPoint(P p,int idx,int type):p(p),idx(idx),type(type){}\n\tEndPoint() :EndPoint(P(0, 0), -1, -1){}\n\n\tbool operator<(const EndPoint& ep)const\n\t{\n\t\tif (p.y == ep.p.y)\n\t\t{\n\t\t\treturn type < ep.type;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n};\n\nSegment segments[100000];\nEndPoint eps[200000];\n\nint CalcIntersection(int n)\n{\n\tfor (int i = 0, k = 0; i < n; i++)\n\t{\n\t\tif (segments[i].p1.x == segments[i].p2.x)\n\t\t{\n\t\t\tif (segments[i].p1.y>segments[i].p2.y)\n\t\t\t{\n\t\t\t\tswap(segments[i].p1, segments[i].p2);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (segments[i].p1.x>segments[i].p2.x)\n\t\t\t{\n\t\t\t\tswap(segments[i].p1, segments[i].p2);\n\t\t\t}\n\t\t}\n\n\t\tif (segments[i].p1.x == segments[i].p2.x)\n\t\t{\n\t\t\teps[k++] = EndPoint(segments[i].p1, i, BOTTOM);\n\t\t\teps[k++] = EndPoint(segments[i].p2, i, TOP);\n\t\t}\n\t\telse\n\t\t{\n\t\t\teps[k++] = EndPoint(segments[i].p1, i, LEFT);\n\t\t\teps[k++] = EndPoint(segments[i].p2, i, RIGHT);\n\t\t}\n\t}\n\n\tsort(eps, eps + (2 * n));\n\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint count = 0;\n\n\tfor (int i = 0; i < (2 * n); i++)\n\t{\n\t\tif (eps[i].type == TOP)\n\t\t{\n\t\t\tBT.erase(eps[i].p.x);\n\t\t}\n\t\telse if (eps[i].type == BOTTOM)\n\t\t{\n\t\t\tBT.insert(eps[i].p.x);\n\t\t}\n\t\telse if (eps[i].type == LEFT)\n\t\t{\n\t\t\tauto l = BT.lower_bound(segments[eps[i].idx].p1.x);\n\t\t\tauto u = BT.upper_bound(segments[eps[i].idx].p2.x);\n\t\t\tcount += distance(l, u);\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tsegments[i] = Segment(P(x1, y1), P(x2, y2));\n\t}\n\n\tprintf(\"%d\\n\", CalcIntersection(n));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n\nstruct Line{\n    int start,end,pos;\n    bool operator<(const Line& b) const{\n        return pos < b.pos;\n    }\n};\n\nint main(){\n    vector<Line> vx,vy;\n    int n,cnt=0;\n    cin>>n;\n    rep(i,n){\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        if(x1!=x2)vx.push_back({min(x1,x2),max(x1,x2),y1}); \n        else      vy.push_back({min(y1,y2),max(y1,y2),x1});      \n    }\n    sort(all(vy));\n    for(auto _:vx){\n        Line s = {0,0,_.start};\n        Line e = {0,0,_.end+1};\n        int l = lb(vy,s);\n        int r = lb(vy,e);\n        for(int i=l;i<r;++i){\n            if(vy[i].start<=_.pos && _.pos<=vy[i].end)cnt++;\n        }\n    }\n    cout<<cnt<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(0,0)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(0,0)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nconst double EPS =  1e-10;\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nconst static int BOTTOM = 0;\nconst static int LEFT = 1;\nconst static int RIGHT = 2;\nconst static int TOP = 3;\n\n\nclass Point{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y){}\n\n    Point operator + (Point p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator - (Point p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (Point p){\n        return Point(x * p.x, y * p.y);\n    }\n    Point operator * (double r){\n        return Point(x * r, y * r);\n    }\n    Point operator / (Point p){\n        return Point(x / p.x, y / p.y);\n    }\n    Point operator / (double d){\n        return Point(x / d, y / d);\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n    double norm(){\n        return x * x + y * y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n    \n    \n};\n\ntypedef Point Vector;\n\nclass Segment : public Point{\n    public:\n    Point p1, p2;\n    Segment(){}\n    Segment(Point p1_, Point p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n    Segment(double a, double b, double c, double d){\n        p1 = Point(a, b);\n        p2 = Point(c, d);\n    }\n    \n};\n\ntypedef Segment Line;\n\ntypedef std::vector<Point> Polygon;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c_, double r_){\n        c = c_;\n        r = r_;\n    }\n};\n\ndouble dot(Point a, Point b){\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(Point a, Point b){\n    return a.x * b.y - a.y * b.x;\n}\nbool isOrthogonal(Point a, Point b){\n    return equals(dot(a, b), 0.0);\n}\nbool isParallel(Point a, Point b){\n    return equals(cross(a, b), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s1.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s1.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    //Vector tmp = s.p1 + base * r;\n    Vector tmp = base * r;\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2;\n}\n\nint ccw(Point p1, Point p2, Point p3){\n    Vector a = p2 - p1;\n    Vector b = p3 - p1;\n    if( cross(a, b) > EPS ) return 1;\n    else if( cross(a, b) < -EPS ) return -1;\n    else if( dot(a, b) < -EPS ) return 2;\n    else if( a.norm() < b.norm() ) return -2;\n    //std::cout << std::fixed << std::setprecision(10) << ans.x << \" \" << ans.y << std::endl;\n    else return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\n\ndouble getDistance(Point a, Point b){\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p){    \n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if( intersect(s1, s2) ) return 0.0;\n    return std::min(std::min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), std::min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::pair<Point, Point> getCrossPoints(Circle c, Line l){\n    //assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return std::make_pair(pr + e * base, pr - e * base);\n\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(cos(r) * a, sin(r) * a);\n}\n\nstd::pair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = (c1.c - c2.c).abs();\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return std::make_pair(c1.c + polar(c1.r, t+ a), c1.c + polar(c1.r, t-a));\n     \n}\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1) % n] - p;\n        if( abs(cross(a, b) ) < EPS && dot(a, b) < EPS ) return 1;\n        if( a.y > b.y ) std::swap(a, b);\n        if( a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return( x ? 2 : 0);\n\n}\n\nPolygon andrewScan( Polygon s){\n    Polygon u, l;\n    \n    std::sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[ s.size() - 2 ]);\n\n    for ( int i = 2; i < s.size(); i++ ) {\n        for ( int n = u.size(); n >=2 && ccw(u[n-2], u[n-1], s[i]) > 0; n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    \n\n    for ( int i = s.size() - 3; i >= 0; i-- ) {\n        for ( int n = l.size(); n >=2 && ccw(l[n-2], l[n-1], s[i]) > 0; n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    std::reverse(l.begin(), l.end());\n\n    for ( int i = u.size() - 2; i >= 1; i-- ){\n        l.push_back( u[i] );\n    }\n\n    return l;\n\n\n}\n\nclass EndPoint{\npublic:\n    Point p;\n    int seg, st;\n    EndPoint(){}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n        if(p.y == ep.p.y){\n            return st < ep.st;\n        }else{\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(std::vector<Segment> S){\n    int n = S.size();\n\n    for(int i = 0, k = 0; i < n; i++){\n        if(S[i].p1.y == S[i].p2.y){\n            if(S[i].p1.x > S[i].p2.x){\n                std::swap(S[i].p1, S[i].p2);\n            }\n        }else if(S[i].p1.y > S[i].p2.y){\n            std::swap(S[i].p1, S[i].p2);\n        }\n\n        if ( S[i].p1.y == S[i].p2.y ) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    // std::cout << \"EP iterator:\" << EP.begin() << \":\" << EP << std::endl;\n    // std::cout << \"EP iterator:\" << EP.end() << \":\" << EP << std::endl;\n\n    std::sort( EP, EP + (2 * n) );\n\n    std::set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++){\n        if(EP[i].st == TOP){\n            BT.erase(EP[i].p.x);\n        }else if(EP[i].st == BOTTOM){\n            BT.insert(EP[i].p.x);\n        }else if(EP[i].st == LEFT){\n            std::set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            std::set<int>::iterator d = BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt += std::distance(b, d);\n        }\n    }\n\n    return cnt;\n} \n\nint main(void){\n    int n;\n    std::cin >> n;\n    std::vector<Segment> S(n);\n    double x1, y1, x2, y2;\n    for(int i = 0; i < n; i++){\n        std::cin >> x1 >> y1 >> x2 >> y2;\n        \n        S[i] = Segment(x1, y1, x2, y2);\n        \n    }\n    \n    std::cout << manhattanIntersection(S) << std::endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\nstruct RSQ{\n  int n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 0 index\n  void add(int i,int v){\n    i++;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  int sum(int i){\n    int res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) \n  int sum(int x,int y){\n    return sum(y)-sum(x);\n  }\n};\n\nstruct Sweap{\n    int n;\n    vector<int>ye,ys,xs,xe;\n    vector<P2>vx,vy;\n    Sweap(vector<int>X1,vector<int>X2,vector<int>Y1,vector<int>Y2,int sz,int flag_zaatsu){\n        n=sz;xs=X1;xe=X2;ys=Y1;ye=Y2;\n        if(flag_zaatsu!=0)zaatsu();\n        for(int i=0;i<n;i++){\n            if(ys[i]>ye[i])swap(ys[i],ye[i]);\n            if(xs[i]>xe[i])swap(xs[i],xe[i]);\n            if(xs[i]==xe[i]){\n                vx.push_back(P2(P(xs[i], 2), i));\n                vy.push_back(P2(P(ys[i], 1), i));\n                vy.push_back(P2(P(ye[i], 3), i));\n            }\n            else{\n                vx.push_back(P2(P(xs[i], 1), i));\n                vx.push_back(P2(P(xe[i], 3), i));\n                vy.push_back(P2(P(ys[i], 2), i));\n            }\n        }\n        sort(vx.begin(),vx.end());\n        sort(vy.begin(),vy.end());\n    }\n    void zaatsu(){\n        map<int,int>Mx,My;\n        vector<int>tvx,tvy;\n        for(int i=0;i<n;i++){\n            tvx.push_back(xs[i]);\n            tvx.push_back(xe[i]);\n            tvy.push_back(ys[i]);\n            tvy.push_back(ye[i]);\n        }\n        sort(tvx.begin(),tvx.end());\n        sort(tvy.begin(),tvy.end());\n        tvx.erase(unique(tvx.begin(),tvx.end()),tvx.end());\n        tvy.erase(unique(tvy.begin(),tvy.end()),tvy.end());\n        for(int i=0;i<tvx.size();i++)Mx[tvx[i]]=i;\n        for(int i=0;i<tvy.size();i++)My[tvy[i]]=i;\n        for(int i=0;i<n;i++){\n            xs[i]=Mx[xs[i]];\n            xe[i]=Mx[xe[i]];\n            ys[i]=My[ys[i]];\n            ye[i]=My[ye[i]];\n        }\n    }\n    int build(){\n        RSQ rsq;\n        int sum=0;\n        for(int i=0;i<vx.size();i++){\n            int id=vx[i].second;\n            int seed=vx[i].first.second;\n            if(seed==1){\n                rsq.add(ys[id],1);\n            }\n            else if(seed==3){\n                rsq.add(ye[id],-1);\n            }\n            else{\n                sum+=rsq.sum(ys[id],ye[id]+1);\n            }\n            //cout<<id<<' '<<seed<<' '<<sum<<\"    \"<<vx[i].first.first<<endl;\n        }\n        return sum;\n    }\n};\n \n \nint main(){\n    int n;\n    scanf(\" %d\", &n);\n    vector<int>X1(n),X2(n),Y1(n),Y2(n);\n    for(int i = 0; i < n; i++)cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    Sweap s(X1,X2,Y1,Y2,n,1);\n    cout<<s.build()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n       \nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst double EPS = 1e-10;\nconst double PI = acos(-1);\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nclass Point {\n  double add(double a, double b) const {\n    if (fabs(a + b) < EPS * (fabs(a) + fabs(b))) return 0;\n    return a + b;\n  }\n\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator+(const Point &p) const {\n    return Point(add(x, p.x), add(y, p.y));\n  }\n  Point operator-(const Point &p) const {\n    return Point(add(x, -p.x), add(y, -p.y));\n  }\n  Point operator*(const double a) { return Point(a * x, a * y); }\n  Point operator/(const double a) { return Point(x / a, y / a); }\n\n  double abs() const { return sqrt(norm()); }\n  double norm() const { return x * x + y * y; }\n\n  Point rotate(double theta) const {\n    return Point(cos(theta) * x - sin(theta) * y,\n                 sin(theta) * x + cos(theta) * y);\n  }\n\n  Point normalize() const { return Point(*this) / abs(); }\n\n  bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\n  bool operator==(const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }\n};\n\ndouble abs(const Point &p) { return p.abs(); }\ndouble norm(const Point &p) { return p.norm(); }\n\ntypedef Point Vector;\n\nclass Segment {\n public:\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n  friend istream &operator>>(istream &is, Segment &s) {\n    return is >> s.p1 >> s.p2;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n\n  int contains(const Point &p) const {\n    double d = abs(c - p);\n    if (equals(d, r)) return 1;\n    if (d < r + EPS) return 2;\n    return 0;\n  }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\ndouble distance(Point a, Point b) { return (a - b).abs(); }\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble distanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < -EPS) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < -EPS) return (p - s.p2).abs();\n  return distanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min({distanceSP(s1, s2.p1), distanceSP(s1, s2.p2),\n              distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)});\n}\n\nenum CCW {\n  COUNTER_CLOCKWISE = 1,\n  CLOCKWISE = -1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\nCCW ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool onLine(Line l, Point p) {\n  int c = ccw(l.p1, l.p2, p);\n  return c != CLOCKWISE && c != COUNTER_CLOCKWISE;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint crossPoint(Line s1, Line s2) {\n  assert(!isParallel(s1, s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = cross(base, s2.p1 - s1.p1);\n  double d2 = cross(base, s1.p2 - s1.p1);\n  double t = d1 / d2;\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l) { return distanceLP(l, c.c) < c.r; }\n\npair<Point, Point> crossPoint(Circle c, Line l) {\n  assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nbool intersect(Circle c1, Circle c2) {\n  return (c1.c - c2.c).abs() < c1.r + c2.r;\n}\n\npair<Point, Point> crossPoint(Circle c1, Circle c2) {\n  assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint contains(const Polygon &g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; ++i) {\n    Point a = g[i] - p, b = g[(i + 1) % n] - p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS & EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nPolygon convexHull(Polygon s, bool includeOnSegment = false) {\n  Polygon u, l;\n\n  if (s.size() < 3) return s;\n  sort(s.begin(), s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size() - 1]);\n  l.push_back(s[s.size() - 2]);\n\n  auto bad = [&](Point p1, Point p2, Point p3) {\n    if (includeOnSegment) {\n      return ccw(p1, p2, p3) == COUNTER_CLOCKWISE;\n    } else {\n      return ccw(p1, p2, p3) != CLOCKWISE;\n    }\n  };\n\n  for (int i = 2; i < s.size(); ++i) {\n    for (int n = u.size(); n >= 2 && bad(u[n - 2], u[n - 1], s[i]); --n) {\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  for (int i = s.size() - 3; i >= 0; i--) {\n    for (int n = l.size(); n >= 2 && bad(l[n - 2], l[n - 1], s[i]); --n) {\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(), l.end());\n  for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\n  return l;\n}\n\nCircle circumscribedCircle(const Point &a, const Point &b, const Point &c) {\n  double a1, a2, b1, b2, c1, c2;\n  a1 = 2 * (b.x - a.x);\n  b1 = 2 * (b.y - a.y);\n  c1 = a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y;\n  a2 = 2 * (c.x - a.x);\n  b2 = 2 * (c.y - a.y);\n  c2 = a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y;\n  Point p;\n  p.x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n  p.y = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n  return Circle(p, abs(p - a));\n}\ndouble area(const Polygon &p) {\n  double ans = 0;\n  const int N = p.size();\n  for (int i = 0; i < N; ++i) {\n    Point q = p[(i + 1) % N];\n    ans += (p[i].y + q.y) * (q.x - p[i].x);\n  }\n  ans /= 2.0;\n  return fabs(ans);\n}\nbool isConvex(const Polygon &p) {\n  const int N = p.size();\n\n  for (int i = 0; i < N; ++i) {\n    Point pn = p[(i + 1) % N], pnn = p[(i + 2) % N];\n    int d = ccw(p[i], pn, pnn);\n    if (d == CLOCKWISE) return false;\n  }\n  return true;\n}\npair<Point, Point> farthestPoints(const Polygon &p) {\n  Polygon ch = convexHull(p);\n\n  int n = ch.size();\n  if (n == 2) return make_pair(ch[0], ch[1]);\n  int i = 0, j = 0;\n  for (int k = 0; k < n; ++k) {\n    if (!(ch[i] < ch[k])) i = k;\n    if (ch[j] < ch[k]) j = k;\n  }\n\n  pair<Point, Point> res;\n  double d = 0;\n  int si = i, sj = j;\n  while (i != sj || j != si) {\n    double cd = abs(ch[i] - ch[j]);\n    if (cd > d) {\n      d = cd;\n      res = make_pair(ch[i], ch[j]);\n    }\n\n    if (cross(ch[(i + 1) % n] - ch[i], ch[(j + 1) % n] - ch[j]) < 0) {\n      i = (i + 1) % n;\n    } else {\n      j = (j + 1) % n;\n    }\n  }\n  return res;\n}\n\ndouble diameter(const Polygon &p) {\n  pair<Point, Point> pts = farthestPoints(p);\n  return abs(pts.first - pts.second);\n}\n\nPolygon convexCut(const Polygon &p, const Line &l) {\n  const int n = p.size();\n  Polygon res;\n\n  for (int i = 0; i < n; ++i) {\n    int j = (i + 1) % n;\n    Segment s = Segment(p[i], p[j]);\n\n    if (isParallel(s, l)) continue;\n    Point q = crossPoint(s, l);\n    if (ccw(p[i], p[j], q) != ON_SEGMENT) continue;\n    if (cross(l.p2 - l.p1, s.p2 - s.p1) < EPS) continue;\n    res.push_back(q);\n\n    for (;; j = (j + 1) % n) {\n      res.push_back(p[j]);\n      Segment s = Segment(p[j], p[(j + 1) % n]);\n      if (isParallel(s, l)) continue;\n\n      Point q = crossPoint(Segment(p[j], p[(j + 1) % n]), l);\n      if (ccw(p[j], p[(j + 1) % n], q) != ON_SEGMENT) continue;\n      if (cross(l.p2 - l.p1, s.p2 - s.p1) > -EPS) continue;\n      res.push_back(q);\n      return res;\n    }\n  }\n  if (ccw(l.p1, l.p2, p[0]) == COUNTER_CLOCKWISE) return p;\n  return res;\n}\n\npair<Point, Point> closestPair(vector<Point> &p) {}\n\nenum EventKind {\n  IN = 0,\n  QUERY = 1,\n  OUT = 2,\n};\n\nstruct Event {\n  EventKind kind;\n  double x;\n  Segment s;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Event> events;\n  for (int i = 0; i < (int)(n); ++i) {\n    Point p1, p2;\n    cin >> p1 >> p2;\n    if (p1.x > p2.x) swap(p1, p2);\n    if (p1.y > p2.y) swap(p1, p2);\n    if (p1.x == p2.x) {\n      events.push_back(Event{QUERY, p1.x, Segment(p1, p2)});\n    } else {\n      events.push_back(Event{IN, p1.x, Segment(p1, p2)});\n      events.push_back(Event{OUT, p2.x, Segment(p1, p2)});\n    }\n  }\n\n  sort((events).begin(), (events).end(), [](const Event& a, const Event& b) {\n    return a.x == b.x ? a.kind < b.kind : a.x < b.x;\n  });\n\n  set<int> ys;\n\n  ll ans = 0;\n  for (Event& e : events) {\n    if (e.kind == QUERY) {\n      ans += distance(ys.lower_bound(e.s.p1.y), ys.lower_bound(e.s.p2.y + 1));\n    } else if (e.kind == IN) {\n      ys.insert(e.s.p1.y);\n    } else if (e.kind == OUT) {\n      ys.erase(e.s.p1.y);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n#define x1 _____x1\n#define x2 _____x2\n#define y1 _____y1\n#define y2 _____y2\nInt n;\n\nclass Compressor{\npublic:\n  vector<Int> dict;\n  Compressor(){}\n  void add(Int x){\n    dict.push_back(x);\n  }\n  void compress(){\n    sort(dict.begin(), dict.end());\n    dict.erase(unique(dict.begin(), dict.end()), dict.end());\n  }\n  int convert(Int x){\n    return lower_bound(dict.begin(), dict.end(), x) - dict.begin();\n  }\n  Int& operator[](int index)\n  {\n    return dict[index];\n  }\n};\n\nvoid add(vector<int> &bit, int ind, int val){\n  ind++;\n  while(ind < bit.size()){\n    bit[ind] += val;\n    ind += ind & -ind;\n  }\n}\n\nInt sum(vector<int> &bit, int ind){\n  ind++;\n  Int res = 0;\n  while(ind){\n    res += bit[ind];\n    ind -= ind & -ind;\n  }\n  return res;\n}\n\nCompressor comp;\nvector<P> cnt[324000], query[324000];\nInt x1[108000], x2[108000], y1[108000], y2[108000];\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    comp.add(x1[i]);\n    comp.add(y1[i]);\n    comp.add(x2[i]);\n    comp.add(y2[i]);\n  }\n  comp.add(-INF);\n  comp.compress();\n  for(int i = 0;i < n;i++){\n    x1[i] = comp.convert(x1[i]);\n    x2[i] = comp.convert(x2[i]);\n    y1[i] = comp.convert(y1[i]);\n    y2[i] = comp.convert(y2[i]);\n    if(x1[i] == x2[i]){\n      if(y1[i] > y2[i])swap(y1[i], y2[i]);\n      query[y1[i]].push_back(P(x1[i], 1));\n      query[y2[i]].push_back(P(x1[i], -1));\n    }\n    if(y1[i] == y2[i]){\n      if(x1[i] > x2[i])swap(x1[i], x2[i]);\n      cnt[y1[i]].push_back(P(x1[i], x2[i]));\n    }\n  }\n  vector<int> bit(n*3, 0);\n  Int res = 0;\n  for(int i = 0;i < n*3;i++){\n    for(auto q:query[i]){\n      if(q.second == 1)add(bit, q.first, 1);\n    }\n    for(auto q:cnt[i]){\n      res += sum(bit, q.second) - sum(bit, q.first - 1);\n    }\n    for(auto q:query[i]){\n      if(q.second == -1)add(bit, q.first, -1);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int INF = 1111111111;\n\nclass Point {\npublic:\n    int x, y;\n\n    Point(int x = 0, int y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return x == p.x && y == p.y;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        } else {\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * MAX_N];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (S[i].p1.x == S[i].p2.x) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p2.y) {\n            swap(S[i].p1, S[i].p2);\n        }\n\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + 2*n);\n    set<int> BT;\n    BT.insert(INF);\n    int cnt = 0;\n\n    for (int i = 0; i < 2*n; i++) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        } else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        } else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void) {\n    int n; cin >> n;\n\n    int x1, y1, x2, y2;\n    vector<Segment> S;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n\n    cout << manhattanIntersection(S) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct M {\n  using T = int;\n  static T op(const T& a, const T& b) { return a + b; }\n  static constexpr T e() { return 0; }\n};\n\ntemplate<class M> struct ST {\n  using T = typename M::T;\n  int n;\n  V<T> t;\n\n  ST(int n) : n(n) {\n    t.assign(2 * n, M::e());\n  }\n\n  void build() {\n    for (int i = n - 1; i; i--) t[i] = M::op(t[2 * i], t[2 * i + 1]);\n  }\n\n  T get(int l, int r) {\n    T resl = M::e(), resr = M::e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) { \n      if (l & 1) resl = M::op(resl, t[l++]); \n      if (r & 1) resr = M::op(t[--r], resr);\n    }\n    return M::op(resl, resr);\n  }\n\n  void set(int i, const T& a) {\n    for (t[i += n] = a; i >>= 1;) t[i] = M::op(t[2 * i], t[2 * i + 1]);\n  }\n};\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  struct seg { int id, x1, y1, x2, y2; };\n  V<seg> a(n);\n  V<> x, y;\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    x.push_back(x1), y.push_back(y1);\n    x.push_back(x2), y.push_back(y2);\n    a[i] = seg{i, x1, y1, x2, y2};\n  }\n  sort(x.begin(), x.end()), sort(y.begin(), y.end());\n  x.erase(unique(x.begin(), x.end()), x.end());\n  y.erase(unique(y.begin(), y.end()), y.end());\n  for (int i = 0; i < n; i++) {\n    a[i].x1 = lower_bound(x.begin(), x.end(), a[i].x1) - x.begin();\n    a[i].y1 = lower_bound(y.begin(), y.end(), a[i].y1) - y.begin();\n    a[i].x2 = lower_bound(x.begin(), x.end(), a[i].x2) - x.begin();\n    a[i].y2 = lower_bound(y.begin(), y.end(), a[i].y2) - y.begin();\n  }\n\n  struct event { int type, x1, x2; };\n  VV<event> y2e(y.size());\n  for (int i = 0; i < n; i++) {\n    if (a[i].x1 == a[i].x2) {\n      y2e[min(a[i].y1, a[i].y2)].push_back(event{0, a[i].x1, -1});\n      y2e[max(a[i].y1, a[i].y2)].push_back(event{2, a[i].x1, -1});\n    } else {\n      y2e[a[i].y1].push_back(event{1, min(a[i].x1, a[i].x2), max(a[i].x1, a[i].x2)});\n    }\n  }\n  auto comp = [](const event& a, const event& b) { return a.type < b.type; };\n  for (auto&& v : y2e) sort(v.begin(), v.end(), comp);\n  ST<M> st(x.size());\n  int res = 0;\n  for (int j = 0; j < y.size(); j++) {\n    for (auto&& e : y2e[j]) {\n      if (e.type == 0) st.set(e.x1, st.t[e.x1 + x.size()] + 1);\n      else if (e.type == 1) res += st.get(e.x1, e.x2 + 1);\n      else st.set(e.x1, st.t[e.x1 + x.size()] - 1);\n    }\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ndouble abs(Point p) { return sqrt(p.x * p.x + p.y * p.y); }\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nenum TTN { BOTTOM = 0, LEFT, RIGHT, TOP };\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\tEndPoint(Point p1 = Point(0.0, 0.0), int seg = 0, int st = 0):\n\t\tseg(seg), st(st) { p = p1;}\n\tbool operator < (const EndPoint &ep) const {\n\t\treturn (p.y == ep.p.y) ? (st < ep.st) : (p.y < ep.p.y);\n\t}\n};\nEndPoint EP[2 * 100000];\nint manhattanIntersection(vector<Segment> S) {\n\tint n = len(S);\n\tint k = -1;\n\trep(i, 0, n) {\n\t\tif((S[i].p1.y == S[i].p2.y && S[i].p1.x > S[i].p2.x) || (S[i].p1.y > S[i].p2.y))\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\tif(S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[++k] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[++k] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else{\n\t\t\tEP[++k] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[++k] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\tsort(EP, EP + (2 * n));\n\tset<int> BT;\n\tBT.emplace(1000000001);\n\tint cnt = 0;\n\trep(i, 0, 2 * n) {\n\t\tif (EP[i].st == TOP) BT.erase(EP[i].p.x);\n\t\telse if (EP[i].st == BOTTOM) BT.emplace(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = lower_bound(all(BT), S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = lower_bound(all(BT), S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn mp(pr + e * base, pr - e * base);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2.0 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn mp(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint contains(Polygon g, Point p) {\n\tint n = len(g);\n\tbool x = false;\n\tPoint a, b;\n\trep(i, 0, n) {\n\t\ta = g[i] - p;\n\t\tb = g[(i + 1) % n] - p;\n\t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) {\n\tif(len(s) < 3) return s;\n\tPolygon u, l;\n\tsort(all(s), [](const Point& a, const Point& b){return a.y == b.y ? a.x < b.x : a.y < b.y;});\n\tu.eb(s[0]);\n\tu.eb(s[1]);\n\tl.eb(s[len(s) - 1]);\n\tl.eb(s[len(s) - 2]);\n\tint _ccw;\n\trep(i, 2, len(s)) {\n\t\trrep(n, len(u), 1) {\n\t\t\t_ccw = ccw(u[n - 2], u[n - 1], s[i]);\n\t\t\tif(!(_ccw != CLOCKWISE && _ccw != ONLINE_FRONT)) break;\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.eb(s[i]);\n\t}\n\trrep(i, len(s) - 3, -1) {\n\t\trrep(n, len(l), 1) {\n\t\t\t_ccw = ccw(l[n - 2], l[n - 1], s[i]);\n\t\t\tif(!(_ccw != CLOCKWISE && _ccw != ONLINE_FRONT)) break;\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.eb(s[i]);\n\t}\n\treverse(all(l));\n\trrep(i, len(u) - 2, 0) l.eb(u[i]);\n\treturn l;\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tint n; cin >> n;\n\tvector<Segment> vse(n);\n\trep(i, 0, n) {\n\t\tcin >> vse[i].p1.x >> vse[i].p1.y >> vse[i].p2.x >> vse[i].p2.y;\n\t}\n\tP(manhattanIntersection(vse));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        /*\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n        */\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の集合\nvector<Segment> v_parallel_x;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x.push_back(seg);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n            }\n\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].y == v_parallel_y[j].p1.y )\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x[p].p1.x )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x[p].p1.x; k <= v_parallel_x[p].p2.x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n            }\n        }\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a - b > -EPS; }\ninline bool Grt(ld a, ld b){ return a - b > EPS; }\ninline bool Leq(ld a, ld b){ return a - b < EPS; }\ninline bool Lss(ld a, ld b){ return a - b < -EPS; }\ninline bool Equ(ld a, ld b){ return abs(a-b) < EPS; }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nbool byX(const PT &a, const PT &b){\n\tif (Equ(a.X, b.X))\n\t\treturn Lss(a.Y, b.Y);\n\treturn Lss(a.X, b.X);\n}\n\n\nstruct cmpXY{\n\tbool operator ()(const PT &a, const PT &b){\n\t\treturn byX(a, b);\n\t}\n};\n\nstruct cmpYX{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.Y, b.Y))\n\t\t\treturn Lss(a.X, b.X);\n\t\treturn Lss(a.Y, b.Y);\n\t}\n};\n\n\n\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}\n\nint main(){\t\n\tvector <PT> adds, rems;\n\tvector <LS> query;\n\tfor (int i = in(); i; i--){\n\t\tPT p, q;\n\t\tcin >> p >> q;\n\t\tif (Equ(p.Y, q.Y)){\n\t\t\t//\t\t\tcout << \"Here!\\n\";\n\t\t\tif (Lss(q.X, p.X))\n\t\t\t\tswap(p, q);\n\t\t\tadds.pb(p);\n\t\t\trems.pb(q);\n\t\t}\n\t\telse{\n\t\t\tif (Lss(q.Y, p.Y))\n\t\t\t\tswap(p, q);\n\t\t\tquery.pb({p, q});\n\t\t}\n\t}\n\tsort(adds.begin(), adds.end(), cmpXY());\n\tsort(rems.begin(), rems.end(), cmpXY());\n\tsort(query.begin(), query.end(), [](LS a, LS b){ return byX(a.F, b.F); });\n\tmultiset <ld> ys;\n\tint iadd = 0, irem = 0;\n\tint ans = 0;\n\tfor (auto p : query){\n\t\t//\t\tcout << p.F << ' ' << p.S << endl;\n\t\twhile (iadd < adds.size() && Leq(adds[iadd].X, p.F.X))\n\t\t\tys.insert(adds[iadd++].Y);\n\t\twhile (irem < rems.size() && Lss(rems[irem].X, p.F.X) && ys.find(rems[irem].Y) != ys.end())\n\t\t\tys.erase(ys.find(rems[irem++].Y));\n\t\tint cur = distance(ys.lower_bound(p.F.Y), ys.upper_bound(p.S.Y));\n\t\tans += cur;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\nconst double EPS = 1e-9;\nusing namespace std;\nclass point {\npublic:\n\tdouble x, y;\n\tpoint(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tpoint operator - (point v) {\n\t\treturn point(x - v.x, y - v.y);\n\t}\n\tpoint operator + (point v) {\n\t\treturn point(x + v.x, y + v.y);\n\t}\n};\nclass segment {\npublic:\n\tpoint p1, p2;\n\tsegment(point p1, point p2) :p1(p1), p2(p2) {};\n};\nclass Vector {\npublic:\n\n\tdouble x, y;\n\tVector(double a, double  b) {\n\t\tx = a;\n\t\ty = b;\n\t};\n\tVector operator * (const Vector &v)const {\n\t\treturn Vector(x*v.x, y* v.y);\n\t}\n\tVector operator * (double a) {\n\t\treturn Vector(x * a, y * a);\n\t}\n\tVector operator - (Vector v) {\n\t\treturn Vector(x - v.x, y - v.y);\n\t}\n\tVector operator + (Vector v) {\n\t\treturn Vector(x + v.x, y + v.y);\n\t}\n};\ntypedef vector<Vector> polygon;\nclass circle {\npublic:\n\tpoint p;\n\tdouble r;\n\tcircle(point a, double b) : p(a), r(b) {};\n\n};\ninline double dot(Vector v1, Vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\ninline double squ(Vector v) {\n\treturn v.x*v.x + v.y*v.y;\n}\ninline double norm(Vector v) {\n\treturn sqrt(squ(v));\n}\ninline void printv(Vector v) {\n\tprintf(\"%.10f %.10f\\n\", v.x, v.y);\n}\ninline void printpp(pair<point, point> p) {\n\tprintf(\"%.7f %.7f %.7f %.7f\", p.first.x, p.first.y, p.second.x, p.second.y);\n}\ninline void printc(Vector v1, Vector v2) {\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", v1.x, v1.y, v2.x, v2.y);\n}\ninline void printpg(polygon pg, int min) {\n\tcout << pg.size() << endl;\n\tfor (int i = min; i < pg.size(); i++)\n\t\t//printf(\"%d %d\\n\", pg[i].x, pg[i].y);\n\t\tcout << pg[i].x << \" \" << pg[i].y << endl;\n\tfor(int i = 0; i < min; i++) cout << pg[i].x << \" \" << pg[i].y << endl;\n}\ninline Vector pro(Vector base, Vector v, Vector be) {\n\tdouble a = dot(base, v) / squ(base);\n\tVector v1 = base * a;\n\treturn v1 + be;\n}\ninline Vector ref(Vector v, Vector be) {\n\treturn (v - be)*2 + be;\n}\ninline double cross(Vector v1, Vector v2) {\n\treturn v1.x*v2.y - v1.y*v2.x;\n}\ninline int ccw(Vector v1, Vector v2, Vector v3) {\n\tVector a = v2 - v1;\n\tVector b = v3 - v1;\n\tif (cross(a, b) < 0.0) return -1;\n\telse if (cross(a, b) > 0.0) return 1;\n\telse if (dot(a, b) < 0.0) return -2;\n\telse if (dot(a, b) > squ(a)) return 2;\n\telse return 0;\n}\ninline int inter(Vector v1, Vector v2, Vector v3, Vector v4) {\n\treturn (ccw(v1, v2, v3) * ccw(v1, v2, v4) <= 0) && (ccw(v3, v4, v1) * ccw(v3, v4, v2) <= 0);\n}\ninline double disPP(Vector v1, Vector v2) {\n\treturn norm(v2 - v1);\n}\ninline double disLP(Vector v1, Vector v2, Vector v3) {\n\tVector a = v2 - v1;\n\tVector b = v3 - v1;\n\treturn fabs(cross(a, b) / norm(a));\n}\ninline double disSP(Vector v1, Vector v2, Vector v3) {\n\tVector a = v2 - v1;\n\tVector b = v3 - v1;\n\tVector c = v1 - v2;\n\tVector d = v3 - v2;\n\tif (dot(a, b) < 0.0) return disPP(v1, v3);\n\telse if (dot(c, d) < 0.0) return disPP(v2, v3);\n\telse return disLP(v1, v2, v3);\n}\ninline double disSS(Vector v1, Vector v2, Vector v3, Vector v4) {\n\tif (inter(v1, v2, v3, v4)) return 0;\n\tdouble a = disSP(v1, v2, v3);\n\tdouble b = disSP(v1, v2, v4);\n\tdouble c = disSP(v3, v4, v1);\n\tdouble d = disSP(v3, v4, v2);\n\treturn min(min(a, b), min(c, d));\n}\ninline Vector getcross(Vector v1, Vector v2, Vector v3, Vector v4) {\n\tVector v5 = pro(v2 - v1, v3 - v1, v1);\n\tVector v6 = pro(v2 - v1, v4 - v1, v1);\n\tdouble a = disPP(v3, v5);\n\tdouble b = disPP(v4, v6);\n\tVector vans = (v6 - v5)*a*(1 / (a + b)) + v5;\n\treturn vans;\n\n}\ninline pair<Vector, Vector> getccl(double r, Vector o, Vector v1, Vector v2) {\n\tVector ev = (v2 - v1)*(1 / norm(v2 - v1));\n\tVector pr = pro(v2 - v1, o - v1, v1);\n\tdouble l = sqrt(r *r - squ(o - pr));\n\tVector ans1 = ev * l + pr;\n\tVector ans2 = pr - ev * l;\n\tif (ans1.x > ans2.x) swap(ans1, ans2);\n\telse if (ans1.x == ans2.x)\n\t\tif (ans1.y > ans2.y) swap(ans1, ans2);\n\treturn make_pair(ans1, ans2);\n}\ninline pair<point, point> getccc(circle c1, circle c2) {\n\tVector v1(c2.p.x - c1.p.x, c2.p.y - c1.p.y);\n\tdouble dis = norm(v1);\n\tdouble a = acos((dis*dis + c1.r*c1.r - c2.r*c2.r) / (2 * c1.r*dis));\n\tdouble b = atan2(c2.p.y - c1.p.y, c2.p.x - c1.p.x);\n\tpoint pa(c1.r*cos(a + b), c1.r*sin(a + b));\n\tpoint pb(c1.r*cos(b - a), c1.r*sin(b -a));\n\tpoint ans1(c1.p + pa);\n\tpoint ans2(c1.p + pb);\n\tif (ans1.x > ans2.x || ((ans1.x == ans2.x) && (ans1.y > ans2.y))) swap(ans1, ans2);\n\treturn make_pair(ans1, ans2);\n}\nconst int num = 100000;\ninline bool lessX(const Vector &p1, const Vector &p2) {\n\treturn (p1.x < p2.x) || ((p1.x == p2.x) && (p1.y < p2.y));\n}\ninline polygon getpg(polygon o) {\n\tsort(o.begin(), o.end(), lessX);\n\tpolygon t, u;\n\tt.push_back(o[0]);\n\tt.push_back(o[1]);\n\tu.push_back(o[0]);\n\tu.push_back(o[1]);\n\tfor (int i = 2; i < o.size(); i++) {\n\t\tfor (int j = t.size(); (t.size() > 1) && (ccw(t[t.size() - 2], t[t.size() - 1], o[i]) == 1); j--)\n\t\t\tt.pop_back();\n\t\tt.push_back(o[i]);\n\t}\n\tfor (int i = 2; i < o.size(); i++) {\n\t\tfor (int j = u.size(); (u.size() > 1) && (ccw(u[u.size() - 2], u[u.size() - 1], o[i]) == -1); j--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(o[i]);\n\t}\n\treverse(t.begin(), t.end());\n\tfor (int i = 1; i < t.size() - 1; i++)\n\t\tu.push_back(t[i]);\n\treturn u;\n}\ninline int cont(polygon pg, Vector p) {\n\tint x = 0;\n\tVector v3(1, 1), v4(1, 1);\n\tfor (int i = 0; i < pg.size(); i++) {\n\t\tVector v1 = pg[i] - p;\n\t\tVector v2 = pg[(i + 1)%pg.size()] - p;\n\t\tif (((cross(v1, v2) == 0) && (dot(v1, v2) < 0.0)) || norm(v1) == 0 || norm(v2) == 0) return 1;\n\t\tif (v1.y > v2.y) swap(v1, v2);\n\t\tif ((cross(v1, v2) > 0.0) && v1.y < EPS && v2.y > EPS) x++;\n\t\tif (v3.y = 0 && v4.y == 0 && (v1.y == 0 || v2.y == 0)) x--;\n\t\tv3 = v1;\n\t\tv4 = v2;\n\t}\n\treturn (x % 2 == 0) ? 0 : 2;\n}\nconst int B = 0, L = 1, R = 2, T = 3;\nclass endpoint {\npublic:\n\tint so, id;\n\tpoint p;\n\tendpoint(point p, int a, int b) :p(p), so(a), id(b) {};\n\tbool operator < (const endpoint &ep) const {\n\t\tif (p.y == ep.p.y) return so < ep.so;\n\t\telse return p.y < ep.p.y;\n\t}\n};\nvector<endpoint> ep;\ninline int solve(vector<segment> s) {\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\t\telse if (s[i].p1.y == s[i].p2.y && s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tep.push_back(endpoint(s[i].p1, L, i));\n\t\t\tep.push_back(endpoint(s[i].p2, R, i));\n\t\t}\n\t\telse {\n\t\t\tep.push_back(endpoint(s[i].p1, B, i));\n\t\t\tep.push_back(endpoint(s[i].p2, T, i));\n\t\t}\n\t}\n\tsort(ep.begin(),ep.end());\n\tset<double> st;\n\tint cnt = 0;\n\tst.insert(1000000001);\n\tfor (int i = 0; i < ep.size(); i++) {\n\t\tif (ep[i].so == B) st.insert(ep[i].p.x);\n\t\telse if (ep[i].so == T) st.erase(ep[i].p.x);\n\t\telse if (ep[i].so == L) {\n\t\t\tset<double>::iterator b = lower_bound(st.begin(), st.end(), s[ep[i].id].p1.x);\n\t\t\tset<double>::iterator e = upper_bound(st.begin(), st.end(), s[ep[i].id].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n;\n\tvector<segment> s;\n\tdouble x0, y0, x1, y1;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf%lf%lf\", &x0, &y0, &x1, &y1);\n\t\ts.push_back(segment(point(x0, y0), point(x1, y1)));\n\t}\n\tcout << solve(s) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nstruct Seg{\n    int x1, x2, y1, y2;\n    Seg(int x1, int y1, int x2, int y2) :x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nbool yparaAsc( const Seg& left, const Seg& right ) {\n    return left.x1 != right.x1 ? left.x1 < right.x1 : left.y1 < right.y1;\n};\n\nstruct Time{\n    int x; //x??§?¨?\n    int y; //y??§?¨?\n    int act; //?????????????????????0 ??§?????????1 ??§?????????\n    Time(int x, int y, int act) : x(x), y(y), act(act) {}\n\n    bool operator<( const Time& right ) const {\n        return x != right.x ? x < right.x : act < right.act;\n    }\n};\n\nint segmentIntersection(vector<Seg> &input){\n    int n = input.size();\n    vector<Seg> xpara, ypara;\n    for (int i=0;i<n;i++){\n        Seg s = input[i];\n        if(s.x1 == s.x2) ypara.push_back(s);\n        if(s.y1 == s.y2) xpara.push_back(s);\n    }\n\n    sort(ypara.begin(), ypara.end(), yparaAsc);\n\n    /*\n    for (int i=0;i<ypara.size();i++){\n        cout << ypara[i].x1 << \" \" << ypara[i].y1 << \" \" << ypara[i].y2 << \" \" <<endl;\n    }\n    cout << endl;\n    */\n\n    vector<Time> Timeline;\n    for (int i=0;i<xpara.size();i++){\n        Seg s = xpara[i];\n        Time t1(s.x1, s.y1, 0), t2(s.x2, s.y1, 1);\n        Timeline.push_back(t1);\n        Timeline.push_back(t2);\n    }\n    sort(Timeline.begin(), Timeline.end());\n\n    /*\n    for (int i=0;i<Timeline.size();i++){\n        cout << Timeline[i].x << \" \" << Timeline[i].y << \" \"  << Timeline[i].act << \" \" <<endl;\n    }\n    cout << endl;\n    */\n    set<int> st;\n    int i=0;\n    int j=0;\n    int S=0;\n    while(1){\n        if(i >= ypara.size() && j >= Timeline.size()) break;\n\n        if(i >= ypara.size()){\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n            continue;\n        }\n\n        if(j >= Timeline.size()){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            cout << i << \" \" << j <<endl;\n            i++;\n            continue;\n        }\n\n        if((ypara[i].x1 < Timeline[j].x) || (ypara[i].x1 == Timeline[j].x && Timeline[j].act == 1)){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            /*\n            cout << i << \" \" << j <<endl;\n\n            set<int>::iterator it = st.begin();\n            while( it != st.end() )\n            {\n                cout << *it << \" \";\n                ++it;\n            }\n            cout << endl;\n            */\n            i++;\n        }else{\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n        }\n    }\n    return S;\n}\n\nint main(){\n    int n, x1, x2, y1, y2;\n    cin >> n;\n    vector<Seg> input;\n    for (int i=0;i<n;i++){\n        cin >> x1 >> y1 >> x2 >> y2;\n        Seg s(x1, y1, x2, y2);\n        input.push_back(s);\n    }\n\n    cout << segmentIntersection(input) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<complex>\n#include<algorithm>\nusing namespace std;\ntypedef complex<int> xy_t;\nint firstx,firsty,secondx,secondy,cnt,n;\nset<int> BT;\nconst int BOTTOM=0,LEFT=1,RIGHT=2,TOP=3;\n\n\nclass EndPoint{\n    public:\n        xy_t p;\n        int id,type;\n        EndPoint(){}\n        EndPoint(xy_t p,int id,int type):p(p),id(id),type(type){}        \n};\n\nbool operator<(const EndPoint& ep1,const EndPoint ep2){\n    if(ep1.p.imag()==ep2.p.imag()){\n        return ep1.type<ep2.type;\n    }\n    else return ep1.p.imag()<ep2.p.imag();\n}\n\nEndPoint EP[2*100100];\n\nint main(){\n    cin>>n;\n    for(int i=0;i<n;++i){\n        cin>>firstx>>firsty>>secondx>>secondy;\n        if(firstx==secondx){\n            if(firsty>secondy) swap(firsty,secondy);\n            \n            EP[2*i]=EndPoint(xy_t(firstx,firsty),2*i,BOTTOM);\n            EP[2*i+1]=EndPoint(xy_t(secondx,secondy),2*i+1,TOP);\n        }\n        else{\n            if(firstx>secondx) swap(firstx,secondx);\n            EP[2*i]=EndPoint(xy_t(firstx,firsty),2*i,LEFT);\n            EP[2*i+1]=EndPoint(xy_t(secondx,secondy),2*i+1,RIGHT);\n        }\n    }\n    sort(EP,EP+(2*n));\n\n    BT.insert(1001001001);\n\n    for(int i=0;i<2*n;++i){\n        if(EP[i].type==BOTTOM){\n            BT.insert(EP[i].p.real());\n        }\n        else if(EP[i].type==TOP){\n            BT.erase(EP[i].p.real());\n        }\n        else if(EP[i].type==LEFT){\n            set<int>::iterator left=BT.lower_bound(EP[i].p.real());\n            set<int>::iterator right=BT.upper_bound(EP[i+1].p.real());\n            cnt+=distance(left,right);\n        }\n    }\n    \n    cout<<cnt<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/20\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#include <iostream>\n#include <set>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    elem_t r = dot(hypo, base) / norm(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief  絶対許容誤差(absolute tolerance)を比較します\n *\n * @note   2つの浮動小数点数値が等しいかどうか比較するためのイプシロン許容誤差の利用は、\n *         イプシロンの値が固定されているので、絶対許容誤差(absolute tolerance)と呼ばれている\n *         絶対許容誤差の欠点は適切なイプシロンの値を見つけるのが困難なことである\n *         イプシロンの値は入力データの値の範囲、および使用している浮動小数点の形式に依存する\n *         浮動小数点数の範囲全体に対するイプシロンの値を1つだけ選ぶことは不可能である\n *         xおよびyの値が非常に小さな(互いに等しくない)値の場合は、その差は常にイプシロンよりも小さくなる可能性があり、\n *         逆に大きな値の場合は、その差はイプシロンよりも常に大きくなるかもしれない. 別の見方として、\n *         判定している数が大きくなればなるほど、絶対値による判定が成立するために必要な桁数はどんどん大きくなっていく\n *\n * @note   固定されているイプシロンよりも数値が十分大きくなったとき、数値が正確に等しくない限り判定は常に失敗する\n *         これは通常、意図したことではない. 絶対許容誤差は数値の桁数の大きさが予めわかっており、\n *         許容誤差の値をそれに応じて設定することができる場合にのみ利用するべきである\n */\nstatic inline bool absolute_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps;\n}\n\n\n/**\n * @brief  相対許容誤差(relatice tolerance)を比較します\n *\n * @note   基本的な考え方はある数を別の数によって除算し、その結果がどのくらい1に近づいているかを見るというものである\n *\n *\n * @note   |x| <= |y|を仮定すると、判定は以下のようになる\n *           if (Abs(x/y - 1.0) <= epsilon)...\n *         これは以下のように書き直せる\n *           if (Abs((x - y) / y) <= epsilon)...\n *         コストのかかる除算を避け、ゼロによる除算のエラーから守るために、後者の式の両辺にAbs(y)を乗算して、以下のように単純化する\n *           if (Abs(x - y) <= epsilon * Abs(y))...\n *         仮定|x| <= |y|を取り除くと、式は最終的に以下のようになる\n *           if (Abs(x - y) <= epsilon * Max(Abs(x), Abs(y)))...  // 相対許容誤差の比較\n *\n *\n * @note   比較において相対的な判定は「より小さいか等しい」であり、「より小さい」ではないことは重要である\n *         もしそうでなければ、両方の数が正確にゼロだった場合、判定は失敗する。相対的な判定も問題がないわけではない\n *         判定の式はAbs(x)およびAbs(y)が1よりも大きいときには、望み通りの働きをするが、それらの数値が1よりも小さいときは、\n *         イプシロンはより小さくないと効力がなくなってしまい、それらの数値が小さくなるほど式を成立させるのに必要な桁数はより多く必要になる         \n */\nstatic inline bool relative_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * std::max(std::fabs(x), std::fabs(y));\n}\n\n\n/**\n * @brief  上記2つの判定を1つに結合させる\n * @note   数値の絶対値が1よりも大きい場合には、相対的な判定を用い、1よりも小さい場合には、絶対的な判定を用いる\n * @attention  この式はMax()が機械語による命令によって利用できない場合には高価な計算になる可能性がある\n */\nstatic inline bool combined_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * std::max({ std::fabs(x), std::fabs(y), static_cast<elem_t>(1.0) });\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(elem_t x, elem_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline orient orientation(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return orient::cw;    }  // クロス積(p1-p0)x(p2-p0)が正の場合、cw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return orient::ccw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、ccw ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return orient::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(norm(p1), norm(p2)))       { return orient::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return orient::on;\n}\n\n\n/**\n * @brief 2点(p1, p2)を原点p0に関する偏角に従って、比較を行う\n */\nstatic inline int polar_angle_cmp(const point& p1, const point& p2)\n{\n    const point p0(0, 0);\n    switch(orientation(p0, p1, p2)) {\n      case orient::cw    : return 1;\n      case orient::ccw   : return -1;\n      case orient::back  : return 1;\n      case orient::front : return -1;\n      case orient::on    : return 1;\n    }\n    return 0;\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nenum struct event_type {\n    // ソートを行ったとき、leftが先に来るようにする\n    left   = 0,\n    right  = 1,\n};\n\n\nstruct event_point {\n    point p;        /**< 座標 */\n    index_t seg;      /**< 線分のインデックス */\n    event_type e;     /**< イベント点の種類 */\n\n    event_point() = default;\n    event_point(const point& p, index_t seg, event_type type)\n        : p(p), seg(seg), e(type) { }\n\n    bool operator < (const event_point& ep) const {\n        // 端点を(x, e, y)上の辞書式順序で比較する\n        \n        // p1.x == p2.xのとき...(*1)、\n        if (eq(p.x, ep.p.x)) {\n            \n            // (*1)かつ、p1.e == p2.eのとき、\n            if (e == ep.e) {\n                // p1.y < p2.yを返す\n                return p.y < ep.p.y;\n            }\n            // (*1)かつ、p1.e != p2.eのとき、\n            else {  // p1.e < p2.eを返す\n                return static_cast<int>(e) < static_cast<int>(ep.e);\n            }\n        }\n        // p1.x != p2.xのとき、\n        else {  // p1.x < p2.x返す\n            return p.x < ep.p.x;\n        }\n    }\n};\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing event_points = std::vector<event_point>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\nelem_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{\n    elem_t xi = pi.x, xj = pj.x, xk = pk.x;\n    elem_t yi = pi.y, yj = pj.y, yk = pk.y;\n    \n    return std::min(xi, xj) <= xk && xk <= std::max(xi, xj)\n        && std::min(yi, yj) <= yk && yk <= std::max(yi, yj);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    elem_t d1 = direction(p3, p4, p1);\n    elem_t d2 = direction(p3, p4, p2);\n    elem_t d3 = direction(p1, p2, p3);\n    elem_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n/**\n * @brief  線分交差検出を行う\n * \n * @note   n本の線分の集合をSとし、Sの中に交差する線分対が1つでもあれば\n *         ブール値TRUEを返し、そうでなければFALSEを返す\n */\nint any_segments_intersect(segments_t& S)\n{\n    // struct cmp { bool operator () (const segment& s1, const segment& s2) {\n    //     return (s1.ps.x - s2.ps.x) * (s2.pd.y - s2.ps.y)\n    //         <  (s1.ps.y - s2.ps.y) * (s2.pd.x - s2.ps.x);\n    // } };\n    \n    std::set<index_t> T;  // 全擬順序Tを空に初期化する\n    \n    int n = S.size();\n    event_points Q;      // イベントキューQを空に初期化する\n    \n    for (index_t i = 0; i < n; i++) {\n        // 端点ps, pdが左下を基準に並ぶように調整する\n        if (eq(S[i].ps.y, S[i].pd.y)) {\n            if (S[i].ps.x> S[i].pd.x)   { std::swap(S[i].ps, S[i].pd); }\n        }\n        else if (S[i].ps.y > S[i].pd.y) { std::swap(S[i].ps, S[i].pd); }\n\n        Q.emplace_back(S[i].ps, i, event_type::left);\n        Q.emplace_back(S[i].pd, i, event_type::right);\n    }\n\n    // Sの線分の端点を左から右にソートする\n    std::sort(Q.begin(), Q.end());\n\n    int count = 0;\n    for (index_t i = 0; i < 2 * n; i++) {   // イベント点の個数は2nだからループの繰り返しは2n\n\n        if (Q[i].e == event_type::left)  {  // pが線分sの左端点\n\n            for (index_t s : T) {\n                if (segment_intersect(S[Q[i].seg].ps, S[Q[i].seg].pd,\n                                      S[s].ps, S[s].pd)) {\n                    count = count + 1;\n                }\n            }         \n            T.insert(Q[i].seg);\n        }\n        if (Q[i].e == event_type::right) {  // pが線分sの右端点\n            T.erase(Q[i].seg);\n        }\n    }\n\n    return count;\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int s;\n    cin >> s;\n\n    segments_t S(s);\n    for (int i = 0; i < s; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        S[i].ps = point(x1, y1);\n        S[i].pd = point(x2, y2);\n    }\n    cout << any_segments_intersect(S) << endl;\n\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rep1(i,n) for(int i = 1; i <= n; ++i)\n#define F first\n#define S second\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nusing ll = long long;\nusing pi = pair<int,int>;\nusing pii = pair<pi,pi>;\nint main()\n{\n  int n; cin >> n;\n  vector<pii> p;\n  while(n-- > 0) {\n    int a,b,c,d; cin >> a >> b >> c >> d;\n    if(a == c) {\n      if(b > d) swap(b, d);\n      p.push_back({{a, 1}, {b, d}});\n    }\n    else {\n      if(a > c) swap(a, c);\n      p.push_back({{a, 0},{b, 0}});\n      p.push_back({{c, 2},{b, 0}});      \n    }\n  }\n\n  sort(p.begin(), p.end());\n  multiset<int> st;\n  int res = 0;\n  rep(i,(int)p.size()) {\n    pii q = p[i];\n    if(q.F.S == 0) st.insert(q.S.F);\n    else if(q.F.S == 1) {\n      auto it = st.lower_bound(q.S.F);\n      int cnt = 0;\n      while(it != st.end() && *it <= q.S.S) {\n\tit++;\n\tcnt++;\n      }\n      res += cnt;\n    }\n    else if(q.F.S == 2) {\n      auto it = st.find(q.S.F); \n      st.erase(it);\n    }\n  }\n  cout << res << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define x1 x_1\n#define x2 x_2\n#define y1 y_1\n#define y2 y_2\nusing namespace std;\ntypedef long long ll;\nvector<int> vx,vy;\nint ix(int x){\n    return lower_bound(vx.begin(),vx.end(),x) - vx.begin() + 1;\n}\nint iy(int x){\n    return lower_bound(vy.begin(),vy.end(),x) - vy.begin() + 1;\n}\nconst int N = 100000 + 10;\nint bit[N],x1[N],x2[N],y1[N],y2[N];\nvector<int> b[N],c[N];\nvector<pair<int,int> > a[N];\nint lowbit(int x){return x&-x;};\nvoid add(int x,int v){while(x<N)bit[x]+=v,x+=lowbit(x);}\nint sum(int x){int r=0;while(x)r+=bit[x],x-=lowbit(x);return r;}\nint main(){\n    int n; scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        vx.push_back(x1[i]), vx.push_back(x2[i]);\n        vy.push_back(y1[i]), vy.push_back(y2[i]);\n    }\n    sort(vx.begin(),vx.end());\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    sort(vy.begin(),vy.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    for(int i=1;i<=n;i++){\n        if(x1[i]>x2[i]) swap(x1[i],x2[i]);\n        if(y1[i]>y2[i]) swap(y1[i],y2[i]);\n        if(x1[i]==x2[i]) a[ix(x1[i])].push_back({iy(y1[i]),iy(y2[i])});\n        else b[ix(x1[i])].push_back(iy(y1[i])), c[ix(x2[i])].push_back(iy(y1[i]));\n    }\n    ll ans = 0;\n    for(int i=1;i<N;i++){\n        for(int j:b[i]) add(j,1);\n        for(auto j:a[i]) ans += sum(j.second)-sum(j.first-1);\n        for(int j:c[i]) add(j,-1);\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct F {\n\tlong long a, b;\n\tF() {}\n\tF(long long _a, long long _b) : a(_a), b(_b) {}\n\tF operator + (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a + a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator - (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a - a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator * (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator / (const F &f) {\n\t\tlong long x = a * f.b, y = b * f.a;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n};\nconst double pi = acos(-1);\nconst double eps = 1e-8;\ninline int sign(double a) {\n\treturn a < -eps ? -1 : a > eps;\n}\ninline int cmp(double a, double b) {\n\treturn sign(a - b);\n}\ndouble add(double a, double b) {\n\tif (abs(a + b) < eps * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\ntypedef int data;\nstruct P {\n\tdata x, y;\n\tP() {}\n\tP(data x, data y) : x(x), y(y) {}\n\tP operator + (const P &p) { return P(x + p.x, y + p.y); }\n\tP operator - (const P &p) { return P(x - p.x, y - p.y); }\n\tP operator * (data d) { return P(x * d, y * d); }\n\tP operator / (data d) { return P(x / d, y / d); }\n\tdata dot(const P &p) { return x * p.x + y * p.y; }\n\tdata det(const P &p) { return x * p.y - y * p.x; }\n\tdouble disto(const P &p) { return (*this - p).abs(); }\n\tdouble alpha() { return atan2(y, x); }\n\tdouble abs() { return sqrt(abs2()); }\n\tdata abs2() { return x * x + y * y; }\n\tP rot90() { P(-y, x); }\n\tP unit() { return *this / abs(); }\n\tbool operator < (P p) const {\n\t\tint c = cmp(x, p.x);\n\t\tif (c) return c == -1;\n\t\treturn cmp(y, p.y) == -1;\n\t}\n\tfriend istream& operator>>(istream &in, P &p) {\n\t\tin >> p.x >> p.y;\n\t\treturn in;\n\t}\n\tfriend ostream& operator<<(ostream& out, P &p) {\n\t\tout << p.x << ' ' << p.y;\n\t\treturn out;\n\t}\n};\nP projection(P p1, P p2, P q) {\n\tP dir = p2 - p1;\n\treturn p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\nP reflection(P p1, P p2, P q) {\n\treturn projection(p1, p2, q) * 2 - q;\n}\nbool is_midddle(data a, data m, data b) {\n\treturn sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\nbool is_midddle(P a, P m, P b) {\n\treturn is_midddle(a.x, m.x, b.x) && is_midddle(a.y, m.y, b.y);\n}\nbool on_seg(P p1, P p2, P q) {\n\treturn sign((p1 - q).det(p2 - q)) == 0 && (p1 - q).dot(p2 - q) <= 0;\n\t// return (p1 - q).det(p2 - q) == 0 && is_middle(p1, q, p2);\n}\nbool intersect(data l1, data r1, data l2, data r2) {\n\tif (l1 > r1) swap(l1, r1);\n\tif (l2 > r2) swap(l2, r2);\n\treturn cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nbool intersect(P p1, P p2, P q1, P q2) {\n\treturn intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y)\n\t       && sign((p2 - p1).det(q1 - p1)) * sign((p2 - p1).det(q2 - p1)) <= 0\n\t       && sign((q2 - q1).det(p1 - q1)) * sign((q2 - q1).det(q2 - q1)) <= 0;\n}\nP seg_intersection(P p1, P p2, P q1, P q2) {\n\tdata a1 = (q2 - q1).det(p1 - q1), a2 = -(q2 - p1).det(p2 - q1);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\nP line_intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\ndata nearest(P p1, P p2, P q) {\n\tP h = projection(p1, p2, q);\n\tif (is_midddle(p1, h, p2)) return q.disto(h);\n\treturn min(p1.disto(q), p2.disto(q));\n}\ndata seg_dist(P p1, P p2, P q1, P q2) {\n\tif (intersect(p1, p2, q1, q2)) return 0;\n\treturn min(min(nearest(p1, p2, q1), nearest(p1, p2, q2)), min(nearest(q1, q2, p1), nearest(q1, q2, p2)));\n}\ndata area(vector<P> &ps) {\n\tdata res = 0;\n\tint n = ps.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tres += ps[i].det(ps[(i + 1) % n]);\n\t}\n\treturn abs(res / 2);\n}\nbool is_convex(vector<P> &ps) {\n\tint n = ps.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdata a1 = (ps[(i + 1) % n] - ps[i]).det(ps[(i + 2) % n] - ps[(i + 1) % n]);\n\t\tdata a2 = (ps[(i + 2) % n] - ps[(i + 1) % n]).det(ps[(i + 3) % n] - ps[(i + 2) % n]);\n\t\tif (a1 * a2 < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint contain(vector<P> &ps, P p) {\n\tint n = ps.size(), res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tP u = ps[i], v = ps[(i + 1) % n];\n\t\tif (on_seg(u, v, p)) return 1;\n\t\tif (cmp(u.y, v.y) <= 0) swap(u, v);\n\t\tif (cmp(p.y, u.y) > 0 || cmp(p.y, v.y) <= 0) continue;\n\t\tres ^= (u - p).det(v - p) > 0;\n\t}\n\treturn res * 2;\n\t//2:inside 1:on_seg 0:outside\n}\nvector<P> convex_hull(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\nvector<P> convex_hull_nonstrict(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\ndata convex_diameter(vector<P> &ps) {\n\tint n = ps.size();\n\tif (n <= 1) return 0;\n\tint is = 0, js = 0;\n\tfor (int k = 1; k < n; k++) {\n\t\tis = ps[k] < ps[is] ? k : is;\n\t\tjs = ps[js] < ps[k] ? k : js;\n\t}\n\tint i = is, j = js;\n\tdouble res = ps[i].disto(ps[j]);\n\tdo {\n\t\tif ((ps[(i + 1) % n] - ps[i]).det(ps[(j + 1) % n] - ps[j]) >= 0) {\n\t\t\t(++j) %= n;\n\t\t} else {\n\t\t\t(++i) %= n;\n\t\t}\n\t\tres = max(res, ps[i].disto(ps[j]));\n\t} while (i != is || j != js);\n\treturn res;\n}\nvector<P> convex_cut(vector<P> &ps, P q1, P q2) {\n\tvector<P> qs;\n\tint n = ps.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP p1 = ps[i], p2 = ps[(i + 1) % n];\n\t\tint d1 = sign((q2 - q1).det(p1 - q1)), d2 = sign((q2 - q1).det(p2 - q1));\n\t\tif (d1 >= 0) qs.push_back(p1); // left-half\n\t\tif (d1 * d2 < 0) qs.push_back(line_intersection(p1, p2, q1, q2));\n\t}\n\treturn qs;\n}\ndata closest_pair(vector<P> &ps, int l, int r) {\n\t// ps should be sorted before this\n\tif (r - l <= 5) {\n\t\tdouble res = 1e100;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tfor (int j = l; j < i; j++) {\n\t\t\t\tres = min(res, ps[i].disto(ps[j]));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint m = (l + r) >> 1;\n\tdouble res = min(closest_pair(ps, l, m), closest_pair(ps, m, r));\n\tvector<P> qs;\n\tfor (int i = l; i < r; i++) {\n\t\tif (abs(ps[i].x - ps[m].x) <= res) {\n\t\t\tqs.push_back(ps[i]);\n\t\t}\n\t}\n\tsort(qs.begin(), qs.end(), [](const P & a, const P & b) { return a.y < b.y; });\n\tfor (int i = 1, sz = qs.size(); i < sz; i++) {\n\t\tfor (int j = i - 1; j >= 0 && qs[j].y >= qs[i].y - res; j--) {\n\t\t\tres = min(res, qs[i].disto(qs[j]));\n\t\t}\n\t}\n\treturn res;\n}\nP circum_center(P p0, P p1, P p2) {\n\tdouble a1 = p1.x - p0.x, b1 = p1.y - p0.y, c1 = (a1 * a1 + b1 * b1) / 2;\n\tdouble a2 = p2.x - p0.x, b2 = p2.y - p0.y, c2 = (a2 * a2 + b2 * b2) / 2;\n\tdouble d = a1 * b2 - a2 * b1;\n\treturn P(p0.x + (c1 * b2 - c2 * b1) / d, p0.y + (a1 * c2 - a2 * c1) / d);\n}\n\nint main() {\n#ifdef LOCAL_DEFINE\n\t//freopen(\"data.in\", \"rt\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tauto _start = chrono::high_resolution_clock::now();\n#endif\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tint n;\n\tcin >> n;\n\tvector<pair<P, P>> seg(n);\n\tvector<pair<int, pair<int, int>>> events;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> seg[i].first >> seg[i].second;\n\t\tif (seg[i].first.y == seg[i].second.y) {\n\t\t\tif (seg[i].first.x > seg[i].second.x) swap(seg[i].first.x, seg[i].second.x);\n\t\t\tevents.emplace_back(seg[i].first.x, make_pair(0, i));\n\t\t\tevents.emplace_back(seg[i].second.x, make_pair(2, i));\n\t\t} else {\n\t\t\tevents.emplace_back(seg[i].first.x, make_pair(1, i));\n\t\t}\n\t}\n\tsort(events.begin(), events.end());\n\tint ans = 0;\n\tset<int> se;\n\tfor (int i = 0, sz = events.size(); i < sz; i++) {\n\t\tauto p = events[i];\n\t\tint id = p.second.second;\n\t\tif (p.second.first == 0) {\n\t\t\tse.insert(seg[id].first.y);\n\t\t} else if (p.second.first == 2) {\n\t\t\tse.erase(seg[id].first.y);\n\t\t} else {\n\t\t\tint y0 = seg[id].first.y, y1 = seg[id].second.y;\n\t\t\tif (y0 > y1) swap(y0, y1);\n\t\t\tauto it0 = se.lower_bound(y0), it1 = se.upper_bound(y1);\n\t\t\tans += distance(it0, it1);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n\tauto _end = chrono::high_resolution_clock::now();\n\tcerr << \"elapsed time: \" << chrono::duration<double, milli>(_end - _start).count() << \" ms\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n    bool same(const P& a, const P& b) {\n      P p = a - b;\n      if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n        return true;\n      }\n      return false;\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n  int convex_point(const G &g,const P &p){\n    P q = p-P(-INF,imag(p));\n    double x = real(p),y = imag(p);\n    L l1(p,q);\n    ll cn = 0;\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      L l2 = L(a,b);\n      int k = ccw(a,b,p);\n      if(k == 0){\n        return 1; // p on g\n      }\n    }\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      double y1 = imag(a),y2 = imag(b);\n      if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n        L l2 = L(a,b);\n        P c = crosspoint(l1,l2);\n        if(x < real(c))\n          ++cn;\n      }\n    }\n    if(cn % 2) return 2; // p in g\n    return 0; // p out g\n  }\n  vector<P> convex_hull(vector<P> &ps){\n    sort(all(ps));\n    int k = 0;\n    int n = ps.size();\n    vector<P> qs(ps.size() * 2);\n    rep(i,ps.size()){\n      while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n        k--;\n      }\n      qs[k++] = ps[i];\n    }\n    for(int i = n-2,t = k; i >= 0; i--){\n      while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n        k--;\n      }\n      qs[k++] = ps[i] ;\n    }\n    qs.resize(k-1);\n    return qs;\n  }\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n  double convex_diameter(vector<P> &ps){\n    const int n = ps.size();\n    int is = 0,js = 0;\n    REP(i,1,n){\n      if(imag(ps[i]) > imag(ps[is])) is = i;\n      if(imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double d = norm(ps[is]-ps[js]);\n    int im,jm,i,j;\n    i = im = is;\n    j = jm = js;\n    do {\n      if(cross(diff(ps,i),diff(ps,j)) >= 0) j = (j+1) % n;\n      else i = (i+1) % n;\n      if(norm(ps[i]-ps[j]) > d){\n        d = norm(ps[i]-ps[j]);\n        im = i,jm = j;\n      }\n    } while (i != is || j != js);\n    return sqrt(d);\n  }\n  G convex_cut(G &g, L &l) {\n    G h;\n    rep(i, (int)g.size()) {\n      P p = curr(g, i), q = next(g, i);\n      if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n        if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n        else return G{};                        // p -- l.b -- l.a -- q\n      }\n      if (ccw(l[0], l[1], p) != -1) h.emplace_back(p);\n      if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0)\n        h.emplace_back(crosspoint(L(p, q), l));\n    }\n    return h;\n  }\n  double closestPair_calc(P *p,int n){\n    if(n < 2) return inf;\n    int m = n/2;\n    double x=real(p[m]);\n    double d = min(closestPair_calc(p,m),closestPair_calc(p+m,n-m));\n    inplace_merge(p,p+m,p+n,sorty);\n    vector<P> q;\n    double dx,dy;\n    rep(i,n) {\n      if(abs(real(p[i])-x)>=d)continue;\n\n      for(int j=q.size()-1;j>=0;j--)\n      {\n        dx=real(p[i])-real(q[j]);\n        dy=imag(p[i])-imag(q[j]);\n        if(dy>=d)break;\n        d=min(d,sqrt(dx*dx+dy*dy));\n      }\n      q.push_back(p[i]);\n    }\n    return d;\n  }\n  double closestPair(vector<P> &p,int n) {\n    if(n < 2) return 0.0;\n    sort(all(p));\n    double ans = closestPair_calc(&p[0],n);\n    return ans == inf ? 0.0 : ans;\n  }\n  P unit(const L &l){\n    P p = l[1] - l[0];\n    return p/abs(p);\n  }\n  P unit(const P &a,const P &b){\n    P p = b - a;\n    return p/abs(p);\n  }\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  vector<L> lx,ly;\n  double x,y;\n  L xp = L(P(0,0),P(1,0));\n  L yp = L(P(0,0),P(0,1));\n  rep(i,n){\n    cin >> x >> y;\n    P a(x,y);\n    cin >> x >> y;\n    P b(x,y);\n    L l(a,b);\n    if(linejudge(l,xp) == 2){\n      lx.emplace_back(l);\n    }\n    else{\n      ly.emplace_back(l);\n    }\n  }\n  ll cnt = 0;\n  rep(i,lx.size()){\n    rep(j,ly.size()){\n      if(intersectSS(lx[i],ly[j])){\n        ++cnt;\n      }\n    }\n  }\n  cout << cnt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 22点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint main(void)\n{\n\n    int n, count = 0;\n    Point start, end;\n    vector<Segment> v_H_seg, v_V_seg;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        Segment s(start, end);\n\n        if( start.x == end.x )\n        {\n            // y軸に平行な直線\n            v_H_seg.push_back(s);\n        }\n        else\n        {\n            // x軸に平行な直線\n            v_V_seg.push_back(s);\n        }\n    }\n\n    // 線分の交点を検索する\n    for( int i = 0; i < v_V_seg.size(); i++)\n    {\n        for(int j = 0; j < v_H_seg.size(); j++)\n        {\n            if( v_V_seg[i].p1.x <= v_H_seg[j].p1.x && v_H_seg[j].p1.x <= v_V_seg[i].p2.x )\n            {\n                if( v_H_seg[j].p1.y <= v_V_seg[i].p1.y && v_V_seg[i].p1.y <= v_H_seg[j].p2.y )\n                {\n                    count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nstruct query {\n\tint type;\n\tlong long int lx;\n\tlong long int len;\n};\nint main() {\n\tint N; cin >> N;\n\tmultimap<long long int, query>mp;\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 *= 3; x2 *= 3; y1 *= 3; y2 *= 3;\n\t\tif (x1 == x2) {\n\t\t\t\n\t\t\tif (y1 > y2)swap(y1, y2);\n\t\t\tassert(y1 <= y2);\n\t\t\ty1--;\n\t\t\ty2++;\n\t\t\tmp.insert(make_pair(y1,query{ 0,x1,y2 - y1 }));\n\t\t\tmp.insert(make_pair(y2, query{ 2,x1,y2 - y1 }));\n\t\t}\n\t\telse {\n\t\t\tif (x1 > x2)swap(x1, x2);\n\t\t\tassert(x1 <= x2);\n\t\t\tx1--;\n\t\t\tx2++;\n\t\t\tmp.insert(make_pair(y1, query{1,x1,x2 - x1 }));\n\t\t}\n\t}\n\tvector<long long int>lines;\n\tint ans = 0;\n\tfor (auto m : mp) {\n\t\tquery q(m.second);\n\t\tif (q.type==1) {\n\t\t\tauto lt = lower_bound(lines.begin(), lines.end(), q.lx);\n\t\t\tauto rt = upper_bound(lines.begin(), lines.end(), q.lx + q.len);\n\t\t\tans += rt - lt;\n\t\t}\n\t\telse if(q.type==0){\n\t\t\tlines.insert(lower_bound(lines.begin(), lines.end(), q.lx),q.lx);\n\t\t}\n\t\telse {\n\t\t\tlines.erase(lower_bound(lines.begin(), lines.end(), q.lx));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a + EPS > b; }\ninline bool Grt(ld a, ld b){ return a > b + EPS; }\ninline bool Leq(ld a, ld b){ return a < b + EPS; }\ninline bool Lss(ld a, ld b){ return a + EPS < b; }\ninline bool Equ(ld a, ld b){ return Geq(a, b) && Geq(b, a); }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nbool byX(const PT &a, const PT &b){\n\tif (Equ(a.X, b.X))\n\t\t\treturn Lss(a.Y, b.Y);\n\t\treturn Lss(a.X, b.X);\n}\n\n\nstruct cmpXY{\n\tbool operator ()(const PT &a, const PT &b){\n\t\treturn byX(a, b);\n\t}\n};\n\nstruct cmpYX{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.Y, b.Y))\n\t\t\treturn Lss(a.X, b.X);\n\t\treturn Lss(a.Y, b.Y);\n\t}\n};\n\n\n\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}\n\nint main(){\t\n\tvector <PT> adds, rems;\n\tvector <LS> query;\n\tfor (int i = in(); i; i--){\n\t\tPT p, q;\n\t\tcin >> p >> q;\n\t\tif (Equ(p.Y, q.Y)){\n\t\t\tadds.pb(p);\n\t\t\trems.pb(q);\n\t\t}\n\t\telse\n\t\t\tquery.pb({p, q});\n\t}\n\tsort(adds.begin(), adds.end(), cmpXY());\n\tsort(query.begin(), query.end(), [](LS a, LS b){ return byX(a.F, b.F); });\n\tmultiset <ld> ys;\n\tint iadd = 0, irem = 0;\n\tint ans = 0;\n\tfor (auto p : query){\n\t\twhile (irem < rems.size() && Lss(rems[irem].X, p.F.X) && ys.find(rems[irem].Y) != ys.end()) ys.erase(ys.find(rems[irem++].Y));\n\t\twhile (iadd < adds.size() && Leq(adds[iadd].X, p.F.X)) ys.insert(adds[iadd++].Y);\n\t\tans += distance(ys.lower_bound(p.F.Y), ys.upper_bound(p.S.Y));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nstruct Polygon\n{\n\tint n;\n\tPoint a[MAXN];\n\tPolygon() {}\n\tint Point_In(Point t)\n\t{\n\t\tint num = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t{\n\t\t\tif(PointOnSegment(t, a[i], a[i + 1]))\n\t\t\t\treturn 2;\n\t\t\tint k = cmp(det(a[i + 1] - a[i], t - a[i]));\n\t\t\tint d1 = cmp(a[i].y - t.y);\n\t\t\tint d2 = cmp(a[i + 1].y - t.y);\n\t\t\tif(k > 0 && d1 <= 0 && d2 > 0)\n\t\t\t\tnum++;\n\t\t\tif(k < 0 && d2 <= 0 && d1 > 0)\n\t\t\t\tnum--;\n\t\t}\n\t\treturn num != 0;\n\t}\n};\n\nstruct Polygon_convex\n{\n\tvector<Point> P;\n\tPolygon_convex(int Size = 0)\n\t{\n\t\tP.resize(Size);\n\t}\n} res(2*100000 + 50);\n\nbool comp_less(Point a, Point b)\n{\n\treturn cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nvoid convex_hull(vector<Point> a)\n{\n\tsort(a.begin(), a.end(), comp_less);\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tint m = 0;\n\tint len = a.size();\n\trep(i, 0, len - 1)\n\t{\n\t\twhile(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tint k = m;\n\tlen = a.size();\n\tdow(i, len - 2, 0)\n\t{\n\t\twhile(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif(a.size()>1)\n\t\tres.P.resize(m-1);\n}\n\nbool PointOnSegment(Point p, Point s, Point t)\n{\n\treturn cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\nPoint rotate(Point p, double cost, double sint)\n{\n\tdouble x = p.x, y = p.y;\n\treturn Point(x*cost - y*sint, x*sint + y*cost);\n}\n\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n\tdouble d = (ap - bp).norm();\n\tdouble cost = (ar*ar + d*d - br*br) / (2*ar*d);\n\tdouble sint = sqrt(1. - cost*cost);\n\tPoint v = (bp - ap) / (bp - ap).norm() * ar;\n\treturn make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\nstruct Node\n{\n\tPoint p;\n\tPoint q;\n\tint id;\n\tNode(Point p_ = Point(0.,0.), Point q_ = Point(0., 0.), int id_ = 4):p(p_), q(q_), id(id_){}\n\tfriend bool operator ==(Node a, Node b)\n\t{\n\t\treturn cmp(a.p.x-b.p.x)==0 && cmp(a.p.y-b.p.y)==0;\n\t}\n\tfriend bool operator <(Node a, Node b)\n\t{\n\t\tif(cmp(a.p.y-b.p.y)==0)\n\t\t\treturn a.id < b.id;\n\t\treturn a.p.y < b.p.y;\n\t}\n} node[MAX * 2];\n\nset<double> s;\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tsfi(n);\n\tint cnt = 0;\n\trep(i, 0, n - 1)\n\t{\n\t\tPoint a, b;\n\t\tscanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n\t\tif(cmp(a.x-b.x)==0)\n\t\t{\n\t\t\tif(a.y < b.y)\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Point(0., 0.), 1);\n\t\t\t\tnode[cnt++] = Node(b, Point(0., 0.), 3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Point(0., 0.), 3);\n\t\t\t\tnode[cnt++] = Node(b, Point(0., 0.), 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a.x < b.x)\n\t\t\t\tnode[cnt++] = Node(a, b, 2);\n\t\t\telse\n\t\t\t\tnode[cnt++] = Node(b, a, 2);\n\t\t}\n\t\t\n\t}\n\tsort(node, node + cnt);\n\t\n\tint ans = 0;\n\trep(i, 0, cnt - 1)\n\t{\n\t\tif(node[i].id == 3)\n\t\t{\n\t\t\tset<double>::iterator it = s.find(node[i].p.x);\n\t\t\ts.erase(*it);\n\t\t}\n\t\telse if(node[i].id == 1)\n\t\t{\n\t\t\ts.insert(node[i].p.x);\n\t\t}\n\t\telse if(node[i].id == 2)\n\t\t{\n\t\t\tset<double>::iterator it = s.lower_bound(node[i].p.x);\n\t\t\tset<double>::iterator iter = s.lower_bound(node[i].q.x);\n\t\t\tif(cmp((*iter)-node[i].q.x)==0)\n\t\t\t\titer++;\n\t\t\tfor(; it != iter; it++)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n \n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n \nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n \ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n \nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double a, double b): x(a), y(b) {}\n \n    friend Point operator -(Point a, Point b)\n    {\n        return Point(a.x-b.x,a.y-b.y);\n    }\n    friend Point operator +(Point a, Point b)\n    {\n        return Point(a.x+b.x,a.y+b.y);\n    }\n    friend bool operator ==(Point a, Point b)\n    {\n        return cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n    }\n    friend Point operator *(Point a, double b)\n    {\n        return Point(a.x*b,a.y*b);\n    }\n    friend Point operator *(double a, Point b)\n    {\n        return Point(a*b.x,a*b.y);\n    }\n    friend Point operator /(Point a, double b)\n    {\n        return Point(a.x/b,a.y/b);\n    }\n    double norm()\n    {\n        return sqrt(sqr(x)+sqr(y));\n    }\n};\n \nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point x, Point y): a(x), b(y) {}\n};\n \nstruct Polygon\n{\n    int n;\n    Point a[MAXN];\n    Polygon() {}\n    int Point_In(Point t)\n    {\n        int num = 0;\n        a[n] = a[0];\n        rep(i, 0, n - 1)\n        {\n            if(PointOnSegment(t, a[i], a[i + 1]))\n                return 2;\n            int k = cmp(det(a[i + 1] - a[i], t - a[i]));\n            int d1 = cmp(a[i].y - t.y);\n            int d2 = cmp(a[i + 1].y - t.y);\n            if(k > 0 && d1 <= 0 && d2 > 0)\n                num++;\n            if(k < 0 && d2 <= 0 && d1 > 0)\n                num--;\n        }\n        return num != 0;\n    }\n};\n \nstruct Polygon_convex\n{\n    vector<Point> P;\n    Polygon_convex(int Size = 0)\n    {\n        P.resize(Size);\n    }\n} res(2*100000 + 50);\n \nbool comp_less(Point a, Point b)\n{\n    return cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n \nvoid convex_hull(vector<Point> a)\n{\n    sort(a.begin(), a.end(), comp_less);\n    a.erase(unique(a.begin(), a.end()), a.end());\n    int m = 0;\n    int len = a.size();\n    rep(i, 0, len - 1)\n    {\n        while(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    int k = m;\n    len = a.size();\n    dow(i, len - 2, 0)\n    {\n        while(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    res.P.resize(m);\n    if(a.size()>1)\n        res.P.resize(m-1);\n}\n \nbool PointOnSegment(Point p, Point s, Point t)\n{\n    return cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n \nbool parallel(Line a, Line b)\n{\n    return !cmp(det(a.a-a.b,b.a-b.b));\n}\n     \nbool orthogonal(Line a, Line b)\n{\n    return !cmp(dot(a.a - a.b, b.a - b.b));\n}\n \nPoint PointProjLine(Point p, Line l)\n{\n    Point ans;\n    double r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n    ans = l.a + r*(l.b-l.a);\n    return ans;\n}\n \nint cmp(double x)\n{\n    if(abs(x) < EPS)\n        return 0;\n    if(x > 0)\n        return 1;\n    return -1;\n}\n \ndouble dis_point_segment(Point p, Line l)\n{\n    if(cmp(dot(p-l.a,l.b-l.a))<0)\n        return (p-l.a).norm();\n    if(cmp(dot(p-l.b,l.a-l.b))<0)\n        return (p-l.b).norm();\n    return abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n \nbool line_make_point(Line a, Line b, Point &res)\n{\n    if(parallel(a,b))\n        return false;\n    double s1 = det(a.a-b.a,b.b-b.a);\n    double s2 = det(a.b-b.a,b.b-b.a);\n    res = (s1*a.b-s2*a.a)/(s1-s2);\n    return true;\n}\n \ndouble dis_segment_segment(Line a, Line b)\n{\n    Point res;\n    if(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n        return 0.;\n    return min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n \ndouble sqr(double x)\n{\n    return x * x;\n}\n \ndouble det(Point a, Point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n \ndouble dot(Point a, Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n    return (a-b).norm();\n}\n \nPoint rotate_point(Point p, double A)\n{\n    double tx = p.x, ty = p.y;\n    return Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n \nPoint reflect(Line l, Point p)\n{\n    return p + ((PointProjLine(p, l) - p) * 2.0);\n}\n \nbool in_segment(Line l, Point p)\n{\n    bool fa = false, fb = false;\n    if((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n        fa = true;\n    if((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n        fb = true;\n    return fa && fb;\n}\n \nint dcmp(double k)\n{\n    return k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n \ndouble mysqrt(double n)\n{\n    return sqrt(max(0.0, n));\n}\n \nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n    double x0 = o.x, y0 = o.y;\n    double x1 = a.x, y1 = a.y;\n    double x2 = b.x, y2 = b.y;\n    double dx = x2 - x1, dy = y2 - y1;\n    double A = dx*dx+dy*dy;\n    double B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n    double C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n    double delta = B*B-4*A*C;\n    num = 0;\n    if(dcmp(delta) >= 0)\n    {\n        double t1 = (-B - mysqrt(delta)) / (2*A);\n        double t2 = (-B + mysqrt(delta)) / (2*A);\n        ret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n        ret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n    }\n     \n}\n \nPoint rotate(Point p, double cost, double sint)\n{\n    double x = p.x, y = p.y;\n    return Point(x*cost - y*sint, x*sint + y*cost);\n}\n \npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n    double d = (ap - bp).norm();\n    double cost = (ar*ar + d*d - br*br) / (2*ar*d);\n    double sint = sqrt(1. - cost*cost);\n    Point v = (bp - ap) / (bp - ap).norm() * ar;\n    return make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n \nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n \nstruct Node\n{\n    Point p;\n    Point q;\n    int id;\n    Node(Point p_ = Point(0.,0.), Point q_ = Point(0., 0.), int id_ = 4):p(p_), q(q_), id(id_){}\n    friend bool operator ==(Node a, Node b)\n    {\n        return cmp(a.p.x-b.p.x)==0 && cmp(a.p.y-b.p.y)==0;\n    }\n    friend bool operator <(Node a, Node b)\n    {\n        if(cmp(a.p.y-b.p.y)==0)\n            return a.id < b.id;\n        return a.p.y < b.p.y;\n    }\n} node[MAX * 2];\n \nset<double> s;\n \nint main()\n{   \n#ifdef LOCAL\n    //~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n \n    int n;\n    sfi(n);\n    int cnt = 0;\n    rep(i, 0, n - 1)\n    {\n        Point a, b;\n        scanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n        if(cmp(a.x-b.x)==0)\n        {\n            if(a.y < b.y)\n            {\n                node[cnt++] = Node(a, Point(0., 0.), 1);\n                node[cnt++] = Node(b, Point(0., 0.), 3);\n            }\n            else\n            {\n                node[cnt++] = Node(a, Point(0., 0.), 3);\n                node[cnt++] = Node(b, Point(0., 0.), 1);\n            }\n        }\n        else\n        {\n            if(a.x < b.x)\n                node[cnt++] = Node(a, b, 2);\n            else\n                node[cnt++] = Node(b, a, 2);\n        }\n         \n    }\n    sort(node, node + cnt);\n     \n    int ans = 0;\n    rep(i, 0, cnt - 1)\n    {\n        if(node[i].id == 3)\n        {\n            set<double>::iterator it = s.find(node[i].p.x);\n            s.erase(*it);\n        }\n        else if(node[i].id == 1)\n        {\n            s.insert(node[i].p.x);\n        }\n        else if(node[i].id == 2)\n        {\n            set<double>::iterator it = s.lower_bound(node[i].p.x);\n            for(; it != s.end() && (*it) <= node[i].q.x; it++)\n                ans++;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 2点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\n// 端点の種類\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint\n{\n    public :\n        Point p;\n        // 入力線分のID, 端点の種類\n        int seg, st;\n\n        EndPoint() {}\n        EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n        bool operator < (const EndPoint &ep) const\n        {\n            // y座標が小さい順に整列\n            if( p.y == ep.p.y )\n            {\n                // yが同一の場合は, 下端点, 左端点, 右端点, 上端点の順に並べる\n                return st < ep.st;\n            }\n            else\n            {\n                return p.y < ep.p.y;\n            }\n        }\n};\n\n// 端点のリスト\n//EndPoint EP[2 * 100000];\nEndPoint EP[2 * 100];\n\n// 線分交差問題　：　マンハッタン幾何\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n\n    for(int i = 0, k = 0; i < n; i++)\n    {\n        // 端点 p1, p2 が左下を基準に並ぶように調整\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            if( S[i].p1.x > S[i].p2.x )\n            {\n                swap(S[i].p1, S[i].p2);\n            }\n        }\n        else if( S[i].p1.y > S[i].p2.y )\n        {\n            swap(S[i].p1, S[i].p2);\n        }\n\n        // 水平成分を端点リストに追加\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            // 垂直成分を端点リストに追加\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    // 端点の y 座標に関して昇順に整列\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;            // 二分探索木\n    BT.insert(1000000001);  // 番兵を設置\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++)\n    {\n        if( EP[i].st == TOP )\n        {\n            // 上端点を削除\n            BT.erase(EP[i].p.x);\n        }\n        else if( EP[i].st == BOTTOM )\n        {\n            // 下端点を追加\n            BT.insert(EP[i].p.x);\n        }\n        else if( EP[i].st == LEFT )\n        {\n            // O(log n)\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            // O(log n)\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p1.x);\n            // b と e の距離(点の数)を加算, O(k)\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void)\n{\n\n    int n, count;\n    Point start, end;\n    vector<Segment> v_segment;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        v_segment.push_back(seg);\n    }\n\n    // 結果の表示\n    count = manhattanIntersection(v_segment);\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tputs(\"a\");\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(0,0)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(0,0)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif(y1 == y2) lines.push_back(PP(P(y1, 0), P(x1, x2)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tlines.push_back(PP(P(y1, 1), P(x1, x2)));\n\t\t\t\tlines.push_back(PP(P(y2, 2), P(x1, x2)));\n\t\t\t}\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, option = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\tif (option == 1) add(x1, 1);\n\t\t\tif (option == 2) add(x1, -1);\n\t\t\tif (option == 0) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <string>\n\n#define ll long long\n#define Int ll\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (*(x.end()-1))\n\nusing namespace std;\n\n#define EPS 0.00000001\n#define fequals(a,b) (fabs((a) - (b)) < EPS)\n\nclass Vector2 {\npublic:\n  double x, y;\n  \n  Vector2(double x = 0, double y = 0): x(x), y(y) {}\n  \n  Vector2 operator + (const Vector2 v) const { return Vector2(x + v.x, y + v.y); }\n  Vector2 operator - (const Vector2 v) const { return Vector2(x - v.x, y - v.y); }\n  Vector2 operator * (const double k) const { return Vector2(x * k, y * k); }\n  Vector2 operator / (const double k) const { return Vector2(x / k, y / k); }\n  \n  double length() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n  double dot (Vector2 const v) { return x * v.x + y * v.y; }\n  double cross (Vector2 const v) { return x * v.y - y * v.x; }\n  \n  bool parallel(Vector2 &other) {\n    return fequals(fabs(dot(other)), length() * other.length());\n  }\n  \n  bool orthogonal(Vector2 &other) {\n    return fequals(0, dot(other));\n  }\n  \n  bool operator < (const Vector2 &v) {\n    return y != v.y ? y < v.y : x < v.x;\n  }\n  \n  bool operator == (const Vector2 &v) {\n    return fabs(x - v.x) < EPS && fabs(y - v.y) < EPS;\n  }\n};\n\nostream & operator << (ostream & out, Vector2 const & v) { \n  out<< \"Vector2(\" << v.x << \", \" << v.y << ')';\n  return out;\n}\n\nistream & operator >> (istream & in, Vector2 & v) { \n  double x, y;\n  in >> x;\n  in >> y;\n  v.x = x;\n  v.y = y;\n  return in;\n}\n\nenum PointType {\n  DOWN, LEFT, UP, RIGHT\n};\n\nostream & operator << (ostream & out, PointType const & t) { \n  switch (t) {\n    case 0:\n    out << \"DOWN\";\n    break;\n    case 1:\n    out << \"LEFT\";\n    break;\n    case 2:\n    out << \"UP\";\n    break;\n    case 3:\n    out << \"RIGHT\";\n    break;\n  }\n  return out;\n}\n\nclass Point {\npublic:\n  Vector2 coord;\n  PointType type;\n  Int length;\n  \n  bool operator < (const Point &p) {\n    return (p.coord.y == coord.y) ? type < p.type : coord < p.coord;\n  }\n  \n  bool operator == (const Point &p) {\n    return coord == p.coord && type == p.type;\n  }\n};\n\nostream & operator << (ostream & out, Point const & p) { \n  out<< \"Point(\" << p.coord.x << \", \" << p.coord.y << \") TYPE=\" << p.type;\n  return out;\n}\n\n#define MAX_N 100001\n\nInt N;\nvector<Point> points;\nPoint p1, p2;\nset<Int> BT;\n\nvoid solve() {\n  Int count = 0;\n  sort(span_all(points));\n  \n  // for (auto p: points) {\n  //   cout << p << endl;\n  // }\n  // return;\n  \n  for (auto p: points) {\n    switch (p.type) {\n      case DOWN:\n        BT.insert(p.coord.x);\n        break;\n      case UP:\n        BT.erase(p.coord.x);\n        break;\n      case LEFT:\n        count += distance(\n          lower_bound(span_all(BT), p.coord.x),\n          upper_bound(span_all(BT), p.coord.x + p.length)\n        );\n        break;\n      case RIGHT:\n        // do nothing\n        break;\n    }\n  }\n  cout << count << endl;\n}\n\nvoid input() {\n  cin >> N;\n  loop(n,0,N) {\n    cin >> p1.coord >> p2.coord;\n    if (p1.coord.y == p2.coord.y) {\n      if (p1.coord.x < p2.coord.x) p1.type = LEFT,p2.type = RIGHT;\n      else p1.type = RIGHT,p2.type = LEFT;\n      p1.length = p2.length = fabs(p1.coord.x - p2.coord.x);\n    } else {\n      if (p1.coord.y < p2.coord.y) p1.type = DOWN,p2.type = UP;\n      else p1.type = UP,p2.type = DOWN;\n      p1.length = p2.length = fabs(p1.coord.y - p2.coord.y);\n    }\n    points.push_back(p1), points.push_back(p2);\n  }\n}\n\nint main() {\n  input();\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\nusing namespace std;\n#define INF 0x7fffffff\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a-b)<EPS)\nstatic const int CCW=1;//?????¶???\nstatic const int CW=-1;//?????¶???\nstatic const int BACK=-2;//?????¢\nstatic const int FRONT=2;//?????¢\nstatic const int ON=0;//?????????\n\nstruct Point//???\n{\n    double x, y;\n    Point(double x=0, double y=0):x(x), y(y) {}\n};\ntypedef Point Vector;//??????\n\nstruct Segment\n{\n    Point p1, p2;\n    Segment(Point p1=Point(), Point p2=Point()):p1(p1), p2(p2) {}\n};//??????\ntypedef Segment Line;//??´???\n\nclass Circle//???\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0):c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;//????????¢\n\nPoint operator + (Point a, Point b)\n{\n    return Point(a.x+b.x, a.y+b.y);\n}\nPoint operator - (Point a, Point b)\n{\n    return Point(a.x-b.x, a.y-b.y);\n}\nPoint operator * (Point a, double p)\n{\n    return  Point(a.x*p, a.y*p);\n}\nPoint operator / (Point a, double p)\n{\n    return Point(a.x/p, a.y/p);\n}\nbool operator < (const Point &a,const Point &b)\n{\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\ndouble norm(Vector a)\n{\n    return a.x*a.x+a.y*a.y;   //?????°????¨?????????????\n}\ndouble abs(Vector a)\n{\n    return sqrt(norm(a));   //?¨?\n}\ndouble dot(Vector a, Vector b)\n{\n    return a.x*b.x+a.y*b.y;   //??????\n}\ndouble cross(Vector a, Vector b)\n{\n    return a.x*b.y-a.y*b.x;   //??????\n}\nbool isOrthgonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);   //???????????´????????????\n}\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return isOrthgonal(a1-a2, b1-b2);   //???????????´???4?????????\n}\nbool isOrthgonal(Segment s1, Segment s2)\n{\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);   //???????????´????????????\n}\nbool isParallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);   //????????????????????????\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return isParallel(a1-a2, b1-b2);   //???????????????4?????????\n}\nbool isParallel(Segment s1, Segment s2)\n{\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);   //????????????????????????\n}\n\nPoint project(Segment s, Point p)//?±?????¶?\n{\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1, base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p)//?±??????°??´??????????§°???\n{\n    return p+(project(s, p)-p)*2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2)//??????P0,P1,P2??????????????????\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if( cross(a, b)>EPS ) return CCW;\n    if( cross(a, b)<-EPS ) return CW;\n    if( dot(a, b)<-EPS ) return BACK;\n    if( norm(a)<norm(b) ) return FRONT;\n    return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0 &&ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0);    //???????????????4?????????\n}\nbool intersect(Segment s1, Segment s2)\n{\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);    //???????????????????????????\n}\n\ndouble getDistance(Point a, Point b)\n{\n    return abs(a-b);    //????????´?????????\n}\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));    //?????°??´????????????\n}\ndouble getDistanceSP(Segment s, Point p)//?????°???????????????\n{\n    if(dot(s.p2-s.p1, p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2)//???????????´?????????\n{\n    if(intersect(s1, s2)) return 0.0;\n    return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2)),\n                min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)) );\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)//??????????????????\n{\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base, s1.p1-s2.p1));\n    double d2=abs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n/*\n???????????¨????????¢?????¨\nIN 2\nON 1\nOUT 0\n*/\nint contains(Polygon g, Point p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0; i<n; i++)\n    {\n        Point a=g[i]-p;\n        Point b=g[(i+1)%n]-p;\n        if(abs(cross(a, b))<EPS && dot(a, b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS && EPS<b.y && cross(a,b)>EPS) x=!x;\n    }\n    return (x? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s)//??????(CCW/CW)\n{\n    Polygon u, l;\n    if(s.size()<3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2; i<s.size(); i++)\n    {\n        for(int n=u.size(); n>=2 && ccw(u[n-2], u[n-1], s[i])!=CW; n--)\n            u.pop_back();\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3; i>=0; i--)\n    {\n        for(int n=l.size(); n>=2 && ccw(l[n-2], l[n-1], s[i])!=CW; n--)\n            l.pop_back();\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for(int i=u.size()-2; i>=1; i--) l.push_back(u[i]);\n    return l;\n}\n\ndouble TriArea(Vector a, Vector b)\n{\n    return 0.5*abs(cross(a,b));    //?±?????§???¢??¢?§?\n}\n\ndouble RotatingCalipers(const Polygon& s)//?±??????¢???????????????????????§??????\n{\n    Polygon l;\n    double dis, maxn=0.0;\n    int len, i, k;\n    l=andrewScan(s);\n    len=l.size();\n    if(len>=3)\n    {\n        for(i=0, k=2; i<len; i++)\n        {\n            while(cross(l[(k+1)%len]-l[i], l[(k+1)%len]-l[(i+1)%len])>=cross(l[k%len]-l[i], l[k%len]-l[(i+1)%len]))\n                k++;\n            dis=max(norm(l[k%len]-l[i]), norm(l[k%len]-l[(i+1)%len]));\n            if(dis>maxn) maxn=dis;\n        }\n    }\n    else maxn=norm(l[1]-l[0]);\n    return maxn;\n}\n\nPoint intersectL(Segment a, Segment b)//??´?????????\n{\n    double x1=a.p1.x,y1=a.p1.y,x2=a.p2.x,y2=a.p2.y;\n    double x3=b.p1.x,y3=b.p1.y,x4=b.p2.x,y4=b.p2.y;\n    double k1=(x4-x3)*(y2-y1),k2=(x2-x1)*(y4-y3);\n    double ans_x=(k1*x1-k2*x3+(y3-y1)*(x2-x1)*(x4-x3))/(k1-k2);\n    double ans_y=(k2*y1-k1*y3+(x3-x1)*(y2-y1)*(y4-y3))/(k2-k1);\n    return Point(ans_x,ans_y);\n}\n\nCircle CircumscribedCircle(Point a, Point b, Point c)//?????\\???\n{\n    double x=0.5*(norm(b)*c.y+norm(c)*a.y+norm(a)*b.y-norm(b)*a.y-norm(c)*b.y-norm(a)*c.y)\n             /(b.x*c.y+c.x*a.y+a.x*b.y-b.x*a.y-c.x*b.y-a.x*c.y);\n    double y=0.5*(norm(b)*a.x+norm(c)*b.x+norm(a)*c.x-norm(b)*c.x-norm(c)*a.x-norm(a)*b.x)\n             /(b.x*c.y+c.x*a.y+a.x*b.y-b.x*a.y-c.x*b.y-a.x*c.y);\n    Point O(x, y);\n    double r=abs(O-a);\n    Circle m(O, r);\n    return m;\n}\n\nCircle InscribedCircle(Point a, Point b, Point c)//?????????\n{\n    double A=abs(b-c), B=abs(a-c), C=abs(a-b);\n    double x=(A*a.x+B*b.x+C*c.x)/(A+B+C);\n    double y=(A*a.y+B*b.y+C*c.y)/(A+B+C);\n    Point O(x, y);\n    Line l(a, b);\n    double r=getDistanceLP(l, O);\n    Circle m(O, r);\n    return m;\n}\n\nSegment TangentLineThroughPoint(Circle m, Point p)\n{\n    Point c=m.c;\n    double l=abs(c-p);\n    double r=m.r;\n    double k=(2*r*r-l*l+norm(p)-norm(c)-2*p.y*c.y+2*c.y*c.y)/(2*(p.y-c.y));\n    double A=1+(p.x-c.x)*(p.x-c.x)/((p.y-c.y)*(p.y-c.y));\n    double B=-(2*k*(p.x-c.x)/(p.y-c.y)+2*c.x);\n    double C=c.x*c.x+k*k-r*r;\n    double x1, x2, y1, y2;\n\n    x1=(-B-sqrt(B*B-4*A*C))/(2*A);\n    x2=(-B+sqrt(B*B-4*A*C))/(2*A);\n    y1=(2*r*r-l*l+norm(p)-norm(c)-2*(p.x-c.x)*x1)/(2*(p.y-c.y));\n    y2=(2*r*r-l*l+norm(p)-norm(c)-2*(p.x-c.x)*x2)/(2*(p.y-c.y));\n    Point p1(x1, y1), p2(x2, y2);\n    Segment L(p1, p2);\n    return L;\n}\n\ndouble Angle(Vector a)\n{\n    Point p0(0.0, 0.0);\n    Point p1(1.0, 0.0);\n    Point p2(a.x, a.y);\n    Vector b=p1;\n    double ans=0;\n    if(ccw(p0, p1, p2)==CW) ans=180-acos(dot(a, b)/(abs(a)*abs(b)))*180/acos(-1);\n    else if(ccw(p0, p1, p2)==CCW) ans=acos(dot(a, b)/(abs(a)*abs(b)))*180/acos(-1);\n    else ans=0;\n    if(ans>=180) ans-=180;\n    if(ans<0) ans+=180;\n    return ans;\n}\n\nint CircleContain(Circle m, Point p)\n{\n    double r=m.r;\n    double l=abs(p-m.c);\n    if(r>l) return 2;\n    if(r==l) return 1;\n    if(r<l) return 0;\n}\n\nvoid CircleThroughAPointAndTangentToALineWithRadius(Point p, Line l, double r)\n{\n    Point m=project(l, p);\n    if(abs(p-m)>2*r)\n    {\n        printf(\"[]\\n\");\n    }\n    else if(abs(p-m)==2*r)\n    {\n        Circle c((p+m)/2, r);\n        printf(\"[(%.6lf,%.6lf)]\\n\", c.c.x, c.c.y);\n    }\n    else if(abs(p-m)<EPS)\n    {\n        Point m0(m.x+1, m.y);\n        if(abs(m0-project(l, m0))<EPS) m0.y+=2;\n        Point m1=project(l, m0);\n        Circle c1(m-(m0-m1)/abs(m0-m1)*r, r);\n        Circle c2(m+(m0-m1)/abs(m0-m1)*r, r);\n        printf(\"[(%.6lf,%.6lf),(%.6lf,%.6lf)]\\n\", c1.c.x, c1.c.y, c2.c.x, c2.c.y);\n    }\n    else if(abs(p-m)<2*r)\n    {\n        double s=abs(p-m);\n        double d=sqrt(r*r-(r-s)*(r-s));\n        Point m1, m2;\n        m1=(m+(l.p1-l.p2)/abs(l.p1-l.p2)*d);\n        m2=(m-(l.p1-l.p2)/abs(l.p1-l.p2)*d);\n        Circle c1(m1+(p-m)/abs(p-m)*r, r);\n        Circle c2(m2+(p-m)/abs(p-m)*r, r);\n        printf(\"[(%.6lf,%.6lf),(%.6lf,%.6lf)]\\n\", c1.c.x, c1.c.y, c2.c.x, c2.c.y);\n    }\n    return ;\n}\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nstruct EndPoint\n{\n    Point p;\n    int seg, st;\n    EndPoint(Point p = Point(0.0, 0.0), int seg = 0, int st = 0):\n        p{p}, seg(seg), st(st) {}\n    bool operator < (const EndPoint &ep) const\n    {\n        return (p.y == ep.p.y) ? (st < ep.st) : (p.y < ep.p.y);\n    }\n};\nEndPoint EP[2 * 100000];\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n    int k = -1;\n    for(int i=0; i<n; i++)\n    {\n        if((S[i].p1.y == S[i].p2.y && S[i].p1.x > S[i].p2.x) || (S[i].p1.y > S[i].p2.y))\n            swap(S[i].p1, S[i].p2);\n        if(S[i].p1.y == S[i].p2.y)\n        {\n            EP[++k] = EndPoint(S[i].p1, i, LEFT);\n            EP[++k] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            EP[++k] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[++k] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n    sort(EP, EP + (2 * n));\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i=0; i<2*n; i++)\n    {\n        if (EP[i].st == TOP) BT.erase(EP[i].p.x);\n        else if (EP[i].st == BOTTOM) BT.insert(EP[i].p.x);\n        else if (EP[i].st == LEFT)\n        {\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    vector<Segment> S;\n    while(T--)\n    {\n        Segment L;\n        scanf(\"%lf%lf%lf%lf\", &L.p1.x, &L.p1.y, &L.p2.x, &L.p2.y);\n        S.push_back(L);\n    }\n    printf(\"%d\\n\", manhattanIntersection(S));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long long              lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MAXE = 2*MAXN;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\n\nenum{ OPEN, LINE, CLOSE };\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\nstruct Event {\n  int t;\n  pt p, q;\n  Event() {}\n  Event( int t, pt p, pt q ) : t(t), p(p), q(q) {}\n};\n\nbool cmp_Event( const Event &A, const Event &B ) {\n  if( A.p.x != B.p.x ) return A.p.x < B.p.x;\n  return A.t < B.t;\n}\n\nint n;\npt P[ 2 ][ MAXN ];\nll zip[ 2 ][ 2*MAXN ];\nint bit[ MAXN ];\nEvent events[ MAXE ];\n\nvoid add( int i ) {\n  for( ; i < MAXN; i += ( i&-i ) ) {\n    ++bit[ i ];\n  }\n}\n\nvoid erase( int i ) {\n  for( ; i < MAXN; i += ( i&-i ) ) {\n    --bit[ i ];\n  }\n}\n\nint query( int i ) {\n  int sum = 0;\n  for( ; i > 0; i -= (i&-i) ) {\n    sum += bit[ i ];\n  }\n  return sum;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[ 0 ][ i ] >> P[ 1 ][ i ];\n    if( P[0][i].y > P[1][i].y ) swap( P[0][i], P[1][i] );\n    if( P[0][i].x > P[1][i].x ) swap( P[0][i], P[1][i] );\n\n    zip[ 0 ][ i ] = P[0][i].x; zip[ 0 ][ i+n ] = P[1][i].x;\n    zip[ 1 ][ i ] = P[0][i].y; zip[ 1 ][ i+n ] = P[1][i].y;\n  }\n  sort( zip[0], zip[0]+2*n ); sort( zip[1], zip[1]+2*n );\n  int sz1 = distance( zip[0], unique( zip[0], zip[0]+2*n ) );\n  int sz2 = distance( zip[1], unique( zip[1], zip[1]+2*n ) );\n\n  for( int i = 0; i < 2; ++i ) {\n    for( int j = 0; j < n; ++j ) {\n      P[i][j].x = lower_bound( zip[0], zip[0]+sz1, P[i][j].x ) - zip[0] +1;\n      P[i][j].y = lower_bound( zip[1], zip[1]+sz2, P[i][j].y ) - zip[1] +1;\n\n    }\n  }\n  int t = 0;\n  for( int i = 0; i < n; ++i ) {\n      if( P[0][i].x == P[1][i].x ) {\n        events[ t++ ] = Event( LINE, P[0][i], P[1][i] );\n      }\n      else {\n        events[ t++ ] = Event( OPEN,  P[0][i], P[0][i] );\n        events[ t++ ] = Event( CLOSE, P[1][i], P[1][i] );\n      }\n  }\n  int ans = 0;\n  sort( events, events+t, cmp_Event );\n\n  for( int i = 0; i < t; ++i ) {\n    Event &e = events[i];\n    if( e.t == OPEN ) {\n      add( e.p.y );\n    }\n    else if( e.t == CLOSE ) {\n      erase( e.p.y );\n    }\n    else if( e.t == LINE ) {\n      ans += query( e.q.y ) - query( e.p.y-1 );\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\ntypedef pair<long long int, long long int> P;\ntypedef pair<long long int, P> P2;\n\nint N = 300000 - 1; // 必要な数よりも大きい2^nよりも大きい数を入れるとよい\nlong long int BIT[300000];\n\nvoid add(int a, long long int w){\n\t\n\t// a番目の要素にwを足す O(log N)\n\t\n\tfor(int x = a; x <= N; x += x & -x){\n\t\tBIT[x] += w;\n\t}\n}\n\nlong long int sum(int a){\n\t\n\t// 1からaまでの要素の合計を返す O(log N)\n\t\n\tlong long int ret = 0;\n\tfor(int x = a; x > 0; x -= x & -x){\n\t\tret += BIT[x];\n\t}\n\treturn ret;\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tBIT[i] = 0;\n\t}\n}\n\nint main(){\n\t\n\tint N;\n\tcin >> N;\n\t\n\tvector<P2> v;\n\tmap<long long int, int> mx;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tlong long int x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1 > x2){\n\t\t\tswap(x1, x2);\n\t\t}\n\t\tif(y1 > y2){\n\t\t\tswap(y1, y2);\n\t\t}\n\t\tmx[x1] = mx[x2] = 1;\n\t\tif(x1 == x2){\n\t\t\tP2 p2;\n\t\t\tp2.first = y1;\n\t\t\tp2.second = make_pair(-INF, x1);\n\t\t\tv.push_back(p2);\n\t\t\tp2.first = y2;\n\t\t\tp2.second = make_pair(INF, x1);\n\t\t\tv.push_back(p2);\n\t\t}else{\n\t\t\tP2 p2;\n\t\t\tp2.first = y1;\n\t\t\tp2.second = make_pair(x1, x2);\n\t\t\tv.push_back(p2);\n\t\t}\n\t}\n\t\n\tmap<long long int, int>::iterator ite;\n\t\n\tint cnt = 1;\n\tfor(ite = mx.begin(); ite != mx.end(); ite++){\n\t\tite -> second = cnt;\n\t\tcnt++;\n\t}\n\t\n\tsort(v.begin(), v.end());\n\tinit();\n\tlong long int ans = 0;\n\t\n\tfor(int i = 0; i < v.size(); i++){\n\t\t\n\t\tint x = mx[v[i].second.second];\n\t\t\n\t\tif(v[i].second.first == -INF){\n\t\t\tans -= sum(x);\n\t\t}else if(v[i].second.first == INF){\n\t\t\tans += sum(x);\n\t\t}else{\n\t\t\tadd(x + 1, -1);\n\t\t\tint x2 = mx[v[i].second.first];\n\t\t\tadd(x2, 1);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1>x2)swap(x1,x2);\n\t\tif(y1>y2)swap(y1,y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\t//sort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(-2000000000,-2000000000)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(-2000000000,-2000000000)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif(y1 == y2) lines.push_back(PP(P(y1, 1), P(x1, x2)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tlines.push_back(PP(P(y1, 0), P(x1, x2)));\n\t\t\t\tlines.push_back(PP(P(y2, 2), P(x1, x2)));\n\t\t\t}\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, option = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\tif (option == 0) add(x1, 1);\n\t\t\tif (option == 2) add(x1, -1);\n\t\t\tif (option == 1) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\nusing namespace std;\n \nclass P{\npublic:\n    int x,y;\n    P(int xx=0,int yy=0){\n        x=xx;\n        y=yy;\n    }\n};\n \nclass Segment{\npublic:\n    P p1,p2;\n    Segment(P pp1=P(),P pp2=P()){\n        p1=pp1;\n        p2=pp2;\n    }\n};\n \nclass EndPoint{\npublic:\n    P p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(P pp,int segg,int stt){\n        p=pp;\n        seg=segg;\n        st=stt;\n    }\n \n    bool operator <(const EndPoint &ep)const{\n        if(p.y==ep.p.y){\n            return st<ep.st;\n        }\n        return p.y<ep.p.y;\n    }\n};\n \nEndPoint EP[2000000];\n \nint manhattanIntersection(vector<Segment> S){\n    int n=S.size();\n    for(int i=0,k=0;i<n;i++){\n        if(S[i].p1.y==S[i].p2.y){\n            if(S[i].p1.x>S[i].p2.x)swap(S[i].p1,S[i].p2);\n        }else if(S[i].p1.y>S[i].p2.y)swap(S[i].p1,S[i].p2);\n        if(S[i].p1.y==S[i].p2.y){\n            EP[k++]=EndPoint(S[i].p1,i,LEFT);\n            EP[k++]=EndPoint(S[i].p2,i,RIGHT);\n        }else{\n            EP[k++]=EndPoint(S[i].p1,i,BOTTOM);\n            EP[k++]=EndPoint(S[i].p2,i,TOP);\n        }\n    }\n    sort(EP,EP+(2*n));\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt=0;\n    for(int i=0;i<2*n;i++){\n        if(EP[i].st==TOP){\n            BT.erase(EP[i].p.x);\n        }else if(EP[i].st==BOTTOM){\n            BT.insert(EP[i].p.x);\n        }else if(EP[i].st==LEFT){\n            set<int>::iterator b=lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n            set<int>::iterator e=upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n            cnt+=distance(b,e);\n        }\n    }\n    return cnt;\n}\n \nint main(void){\n    int n;\n    vector<Segment> ss;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        Segment s;\n        scanf(\"%d %d\",&s.p1.x,&s.p1.y);\n        scanf(\"%d %d\",&s.p2.x,&s.p2.y);\n        ss.push_back(s);\n    }\n    printf(\"%d\\n\",manhattanIntersection(ss));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstruct event{\n    int type;//1:Y????????????????????? 0:X????????????????????????????§? 2:??????\n    int x1,y1,x2,y2;\n    event(int type, int x1, int y1, int x2, int y2){\n        this->type=type, this->x1=x1, this->y1=y1, this->x2=x2, this->y2=y2;\n    }\n    bool operator<(const event&b) const{\n        if(type!=b.type){\n            return type<b.type;\n        }else{\n            return y1==b.y1?y2<b.y2:y1<b.y1;\n        }\n    }\n    bool operator>(const event&b) const{\n        if(type!=b.type){\n            return type>b.type;\n        }else{\n            return y1==b.y1?y2>b.y2:y1>b.y1;\n        }\n    }\n};\n\nint main(){\n    int n,x1,x2,y1,y2;\n    cin >> n;\n    vector<pair<int,event>> E;//<x??§?¨?,event>\n    while(n--){\n        cin >> x1 >> y1 >> x2 >> y2;\n        if(y1==y2){//x????????????\n            if(x1<x2){\n                E.push_back(pair<int,event>(x1,event(0,x1,y1,x2,y2)));\n                E.push_back(pair<int,event>(x2,event(2,x1,y1,x2,y2)));\n            }else{\n                E.push_back(pair<int,event>(x2,event(0,x1,y1,x2,y2)));\n                E.push_back(pair<int,event>(x1,event(2,x1,y1,x2,y2)));\n            }\n        }else{//y????????????\n            if(y1<y2){\n                E.push_back(pair<int,event>(x1,event(1,x1,y1,x2,y2)));\n            }else{\n                E.push_back(pair<int,event>(x1,event(1,x2,y2,x1,y1)));\n            }\n        }\n    }\n    sort(E.begin(),E.end());\n    map<int,int> M;\n    int c=0;\n    for(auto i : E){\n        switch(i.second.type){\n            case 1:\n                for(auto ite=M.lower_bound(i.second.y1);ite!=M.upper_bound(i.second.y2);++ite) c++; \n                break;\n            case 0:\n                M[i.second.y1]=1;\n                break;\n            case 2:\n                M.erase(i.second.y1);\n                break;\n        }\n    }\n    cout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point() {};\n  Point(double x, double y): x(x), y(y) {}\n\n  Point operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n  Point operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double d) { return Point(d * x, d * y); }\n  Point operator / (double d) { return Point(x / d, y / d); }\n\n  bool operator < (const Point &p) const {\n    return (x != p.x ? x < p.x : y < p.y);\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend ostream& operator << (ostream &os, Point &p) {\n    return os << \"Point(\" << p.x << \", \" << p.y << \")\";\n  }\n};\n\nclass Segment {\npublic:\n  Point p1, p2;\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n  friend ostream& operator << (ostream &os, Segment &seg) {\n    return os << \"<\" << seg.p1 << \", \" << seg.p2 << \">\";\n  }\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EP {\npublic:\n  Point p;\n  int id, st;\n  EP() {}\n  EP(Point p, int id, int st): p(p), id(id), st(st) {}\n  bool operator < (const EP &ep) const {\n    return (p.y == ep.p.y ? st < ep.st : p.y < ep.p.y);\n  }\n};\n\nint manhattan_geo(vector<Segment> s) {\n  vector<EP> EPs(s.size() * 2);\n\n  for (int i = 0, k = 0; i < s.size(); i++) {\n    if (s[i].p1.y == s[i].p2.y) {\n      if (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n    } else if (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\n    if (s[i].p1.y == s[i].p2.y) {\n      EPs[k++] = EP(s[i].p1, i, LEFT);\n      EPs[k++] = EP(s[i].p2, i, RIGHT);\n    } else {\n      EPs[k++] = EP(s[i].p1, i, BOTTOM);\n      EPs[k++] = EP(s[i].p2, i, TOP);\n    }\n  }\n\n  sort(EPs.begin(), EPs.end());\n\n  set<int> bin_tree;\n  int cnt = 0;\n\n  for (int i = 0; i < EPs.size(); i++) {\n    if (EPs[i].st == TOP) {\n      bin_tree.erase(EPs[i].p.x);\n    } else if (EPs[i].st == BOTTOM) {\n      bin_tree.insert(EPs[i].p.x);\n    } else if (EPs[i].st == LEFT) {\n      set<int>::iterator b = bin_tree.lower_bound(s[EPs[i].id].p1.x);\n      set<int>::iterator e = bin_tree.upper_bound(s[EPs[i].id].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  int n; cin >> n;\n  vector<Segment> s;\n\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    s.push_back(Segment(Point(x1, y1), Point(x2, y2)));\n  }\n\n  cout << manhattan_geo(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n\tbool operator < (const Point& p)const {\n\t\treturn y < p.y;\n\t}\n};\n\nstruct Line {\n\tPoint b, e;\n\tbool operator < (const Line& l)const {\n\t\treturn b.y < l.b.y;\n\t}\n};\n\nint main() {\n\tint n;\n\tvector<Line> lines;\n\tvector<Point> points;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint pb, pe;\n\t\tcin >> pb.x >> pb.y >> pe.x >> pe.y;\n\t\t\n\t\tif (pb.y == pe.y) {\n\t\t\tLine l;\n\t\t\tl.b = pb.x < pe.x ? pb : pe;\n\t\t\tl.e = pb.x < pe.x ? pe : pb;\n\t\t\tlines.push_back(l);\n\t\t}\n\t\telse {\n\t\t\tif (pb.y < pe.y) {\n\t\t\t\tpb.y--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpe.y--;\n\t\t\t}\n\t\t\tpoints.push_back(pb);\n\t\t\tpoints.push_back(pe);\n\t\t}\n\t}\n\n\tsort(lines.begin(), lines.end());\n\tsort(points.begin(), points.end());\n\n\tint cnt = 0;\n\tint i = 0;\n\tint j = 0;\n\tset<int> s;\n\n\twhile (i < points.size()) {\n\t\twhile ( j < lines.size() && points[i].y >= lines[j].b.y) {\n\t\t\tset<int>::iterator lb = lower_bound(s.begin(), s.end(), lines[j].b.x);\n\t\t\tset<int>::iterator ub = upper_bound(s.begin(), s.end(), lines[j].e.x);\n\t\t\tcnt += distance(lb, ub);\n\t\t\tj++;\n\t\t}\n\t\tif (s.find(points[i].x) == s.end()) {\n\t\t\ts.insert(points[i].x);\n\t\t}\n\t\telse {\n\t\t\ts.erase(points[i].x);\n\t\t}\n\t\ti++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\ntypedef pair<int,int> pii;\nvector<pair<int,pii> > vv;\nset<int> ls;\nint n;\nint xx1,yy1,xx2,yy2;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 0;i < n;++i ){\n        scanf(\"%d%d%d%d\",&xx1,&yy1,&xx2,&yy2);\n        if(yy1 == yy2){\n            vv.push_back(make_pair(min(xx1,xx2),pii(-inf,yy1)));\n            vv.push_back(make_pair(max(xx1,xx2),pii(inf,yy2)));\n        }else if(xx1 == xx2){\n            vv.push_back(make_pair(xx1,pii(min(yy1,yy2),max(yy1,yy2))));\n        }\n    }\n    sort(vv.begin(),vv.end());\n    int ans = 0;\n    for(int i = 0;i < vv.size();++i ){\n        int tmp2 = vv[i].second.first;\n        int tmp3 = vv[i].second.second;\n        if(tmp2 == -inf){\n            ls.insert(tmp3);\n        }else if(tmp2 == inf){\n            ls.erase(tmp3);\n        }else{\n            ans += distance(ls.lower_bound(tmp2),ls.upper_bound(tmp3));\n        }\n    }\n    printf(\"%d\\n\",ans);\n //   system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nenum Status {Start, Line, End};\n\nclass Event {\npublic:\n    int x;\n    Status st;\n    int ymin, ymax;\n    Event(int _x, Status _st, int _ymin, int _ymax) : x(_x), st(_st), ymin(_ymin), ymax(_ymax) {}\n    inline bool operator<(const Event& rhs) const\n    {\n        return x < rhs.x || (x == rhs.x && st < rhs.st) || (x == rhs.x && st == rhs.st && ymin < rhs.ymin);\n    }\n};\n\nint main()\n{\n    set<Event> zSetE;\n\n    int n;\n    cin >> n;\n    int x1, y1, x2, y2;\n    for (int i = 0; i < n; ++i) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 == x2) {\n            if (y1 > y2) {\n                swap(y1, y2);\n            }\n            zSetE.insert(Event(x1, Line, y1, y2));\n        } else if (y1 == y2) {\n            if (x1 > x2) {\n                swap(x1, x2);\n            }\n            zSetE.insert(Event(x1, Start, y1, y2));\n            zSetE.insert(Event(x2, End, y1, y2));\n        }\n    }\n\n    set<int> zCur;\n    int Res = 0;\n\n    for (auto it = zSetE.begin(); it != zSetE.end(); ++it) {\n        Event E = (*it);\n        switch (E.st) {\n        case Start:\n            zCur.insert(E.ymin);\n            break;\n        case Line:\n            Res += distance(zCur.lower_bound(E.ymin), zCur.upper_bound(E.ymax));\n            break;\n        case End:\n            zCur.erase(E.ymin);\n            break;\n        }\n    }\n\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 2点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\n// 端点の種類\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint\n{\n    public :\n        Point p;\n        // 入力線分のID, 端点の種類\n        int seg, st;\n\n        EndPoint() {}\n        EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n        bool operator < (const EndPoint &ep) const\n        {\n            // y座標が小さい順に整列\n            if( p.y == ep.p.y )\n            {\n                // yが同一の場合は, 下端点, 左端点, 右端点, 上端点の順に並べる\n                return st < ep.st;\n            }\n            else\n            {\n                return p.y < ep.p.y;\n            }\n        }\n};\n\n// 端点のリスト\nEndPoint EP[2 * 100000];\n//EndPoint EP[2 * 100];\n\n// 線分交差問題　：　マンハッタン幾何\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n\n    for(int i = 0, k = 0; i < n; i++)\n    {\n        // 端点 p1, p2 が左下を基準に並ぶように調整\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            if( S[i].p1.x > S[i].p2.x )\n            {\n                swap(S[i].p1, S[i].p2);\n            }\n        }\n        else if( S[i].p1.y > S[i].p2.y )\n        {\n            swap(S[i].p1, S[i].p2);\n        }\n\n        // 水平成分を端点リストに追加\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            // 垂直成分を端点リストに追加\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    // 端点の y 座標に関して昇順に整列\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;            // 二分探索木\n    BT.insert(1000000001);  // 番兵を設置\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++)\n    {\n        if( EP[i].st == TOP )\n        {\n            // 上端点を削除\n            BT.erase(EP[i].p.x);\n        }\n        else if( EP[i].st == BOTTOM )\n        {\n            // 下端点を追加\n            BT.insert(EP[i].p.x);\n        }\n        else if( EP[i].st == LEFT )\n        {\n            // O(log n)\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            // O(log n)\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            // b と e の距離(点の数)を加算, O(k)\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void)\n{\n\n    int n, count;\n    Point start, end;\n    vector<Segment> v_segment;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        v_segment.push_back(seg);\n    }\n\n    // 結果の表示\n    count = manhattanIntersection(v_segment);\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// geo\n//--------------------------------------------\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n    Point operator*(double a) { return Point(x * a, y * a); }\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\n\ndouble abs(Vector a) { return sqrt(norm(a)); }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\nenum Position {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ON_SEGMENT = 0,\n    ONLINE_FRONT = -2\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    enum Position p;\n    if (cross(a, b) > EPS)\n        p = COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -EPS)\n        p = CLOCKWISE;\n    else if (dot(a, b) < -EPS)\n        p = ONLINE_BACK;\n    else if (a.norm() < b.norm())\n        p = ONLINE_FRONT;\n    else\n        p = ON_SEGMENT;\n    return p;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Point a, Point b) {\n    Vector v = a - b;\n    return v.abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    double c = cross(l.p2 - l.p1, p - l.p1);\n    Vector v = l.p2 - l.p1;\n    return abs(c) / v.abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n    bool operator<(const EndPoint &ep) const {\n        if (p.y == ep.p.y)\n            return st < ep.st;\n        else\n            return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> s) {\n    int n = s.size();\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (s[i].p1.y == s[i].p2.y) {\n            if (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n        } else if (s[i].p1.y > s[i].p2.y)\n            swap(s[i].p1, s[i].p2);\n        if (s[i].p1.y == s[i].p2.y) {\n            EP[k++] = EndPoint(s[i].p1, i, LEFT);\n            EP[k++] = EndPoint(s[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(s[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(s[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(INF_INT);\n    int cnt = 0;\n    REP(i, 2 * n) {\n        if (EP[i].st == TOP)\n            BT.erase(EP[i].p.x);\n        else if (EP[i].st == BOTTOM)\n            BT.insert(EP[i].p.x);\n        else if (EP[i].st == LEFT) {\n            set<int>::iterator b =\n                lower_bound(BT.begin(), BT.end(), s[EP[i].seg].p1.x);\n            set<int>::iterator e =\n                upper_bound(BT.begin(), BT.end(), s[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    vector<Segment> v;\n    REP(i, n) {\n        Segment s;\n        cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n        v.PB(s);\n    }\n    cout << manhattanIntersection(v) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Geometry Template (Plane)\n//-------------------------------------------------\n\nusing lf = double;\nconst lf EPS = 1e-9;\nconst lf PI = acos(-1);\n\n#define sgn(x) (((x)<-EPS)?-1:((x)>EPS)?1:0)\n#define EQ(x,y) (sgn((y)-(x))==0)\n\nstruct V {\n    lf x,y;\n    V(){}\n    V(lf x, lf y):x(x),y(y){}\n    V(const V &v):x(v.x),y(v.y){}\n    V& operator+=(const V &v){x+=v.x; y+=v.y; return *this;}\n    V& operator-=(const V &v){x-=v.x; y-=v.y; return *this;}\n    V& operator*=(lf k){x*=k; y*=k; return *this;}\n    V& operator/=(lf k){x/=k; y/=k; return *this;}\n    V operator+(const V &v){return V(*this)+=v;}\n    V operator-(const V &v){return V(*this)-=v;}\n    V operator*(lf k){return V(*this)*=k;}\n    V operator/(lf k){return V(*this)/=k;}\n    V operator-(){return V(-x,-y);}\n    lf sq(){return x*x+y*y;}\n    lf norm(){return sqrt(sq());}\n    V unit(){return V(*this)/=norm();}\n    lf arg(){return atan2(y,x);}\n    V rot(lf c, lf s){return V(x*c-y*s,x*s+y*c);}\n    V rot(lf a){return rot(sin(a),cos(a));}\n    V rot90(){return V(-y,x);}\n    bool operator<(const V &v){\n        if (sgn(x-v.x)) return sgn(x-v.x)<0;\n        return sgn(y-v.y)<0;\n    }\n    friend ostream& operator<<(ostream &os, const V &v){return os<<'('<<v.x<<\", \"<<v.y<<')';}\n};\n\nlf dot(const V &a, const V &b){return a.x*b.x+a.y*b.y;}\nlf det(const V &a, const V &b){return a.x*b.y-a.y*b.x;}\n\nint ccw(V a, V b, V c){\n    b-=a; c-=a;\n    if (sgn(det(b,c))>0) return 1;\n    else if(sgn(det(b,c))<0) return -1;\n    else if(sgn(dot(b,c))<0) return 2;\n    else if(sgn(b.norm()-c.norm())<0) return -2;\n    return 0;\n}\n\nstruct Line {\n    V p,q;\n    Line(){}\n    Line(const V &p, const V &q):p(p),q(q){}\n    Line(const Line &l):Line(l.p,l.q){}\n    V unit(){return (q-p).unit();}\n    lf arg(){return (q-p).arg();}\n    Line rot(lf c, lf s){return Line(p.rot(c,s),q.rot(c,s));}\n    Line rot(lf a){return Line(p.rot(a),q.rot(a));}\n    Line rot90(){return Line(p.rot90(),q.rot90());}\n};\n\nstruct Segment : Line {\n    Segment(){}\n    Segment(const V &p, const V &q):Line(p,q){}\n    Segment(const Segment &s):Line(s){}\n    lf sq(){return (Line::q-Line::p).sq();}\n    lf norm(){return (Line::q-Line::p).norm();}\n};\n\n// functions about lines\nbool parallel(const V &a, const V &b){return EQ(det(a,b),0.0);}\nbool parallel(Line &a, Line &b){return EQ(det(a.q-a.p,b.q-b.p),0.0);}\nbool orthogonal(const V &a, const V &b){return EQ(dot(a,b),0.0);}\nbool orthogonal(Line &a, Line &b){return EQ(dot(a.q-a.p,b.q-b.p),0.0);}\n\nbool samel(Line &a, Line &b){return parallel(a,b)&&EQ(det(a.q-a.p,b.p-a.p),0.0);}\nbool insec(Line &a, Line &b){return !parallel(a,b);}\nbool insec(Segment &a, Segment &b){\n    int c1 = ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q);\n    int c2 = ccw(b.p,b.q,a.p)*ccw(b.p,b.q,a.q);\n    return (c1<=0 && c2<=0);\n}\nbool insec(Line &a, Segment &b){return ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q)<=0;}\n\n// use only if lines have intersection\nV cpoint(Line &a, Line &b){\n    V r(a.q-a.p);\n    r *= det(b.p-a.p,b.q-b.p)/det(a.q-a.p,b.q-b.p);\n    return a.p+r;\n}\n\nlf distance(V &a, V &b){return (b-a).norm();}\nlf distance(Line &l, V &v){return abs(det((l.q-l.p).unit(),v-l.p));}\nlf distance(Line &a, Line &b){return (parallel(a,b))?distance(a,b.p):0.0;}\nlf distance(Segment &s, V &v){\n    if (sgn(dot(s.q-s.p,v-s.p))<0) return distance(s.p,v);\n    else if(sgn(dot(s.p-s.q,v-s.q))<0) return distance(s.q,v);\n    return distance((Line&)s,v);\n}\nlf distance(Segment &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    lf A=min(distance(a,b.p),distance(a,b.q));\n    lf B=min(distance(b,a.p),distance(b,a.q));\n    return min(A,B);\n}\nlf distance(Line &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    return min(distance(a,b.p),distance(a,b.q));\n}\n\nV subdiv(V &a, V &b, lf m, lf n){return (a*n+b*m)/(m+n);}\nV outside(V &a, V &b, lf m, lf n){return (-a*n+b*m)/(m-n);}\nV ppfoot(Line &l, V &v){\n    V u = (l.q-l.p).unit();\n    return l.p+u*dot(u,v-l.p);\n}\nV reflect(Line &l, V &v){\n    V f = ppfoot(l,v);\n    return f+(f-v);\n}\n\nLine vbsector(V &a, V &b){\n    V m = (a+b)/2;\n    return Line(m, m+(b-a).rot90());\n}\nLine absector(V &c, V &a, V &b){\n    lf m=(a-c).norm(), n=(b-c).norm();\n    return Line(c,subdiv(a,b,m,n));\n}\nLine perpend(V &c, V &a, V &b){return Line(c,c+(b-a).rot90());}\n\n//-------------------------------------------------\n//--Polygon (depends on Geometry Template)\n//-------------------------------------------------\n\n//anti-clockwise\nstruct Polygon {\n    vector<V> ps; int n;\n    Polygon():n(0){}\n    Polygon(int n):n(n),ps(n){}\n    void push(const V &v){ps.push_back(v), n++;}\n    void pop(){ps.pop_back(), n--;}\n    V& operator[](int k){return ps[k%n];}\n};\n\nlf area(Polygon &p){\n    lf ret=0.0;\n    for(int i=0; i<p.n; i++)\n        ret+=det(p[i],p[i+1])/2;\n    return ret;\n}\n\nV gravity(Polygon &p){\n    V ret(0,0); lf wsum=0.0;\n    for(int i=0; i<p.n; i++){\n        lf w = det(p[i],p[i+1]);\n        ret+=(p[i]+p[i+1])*w;\n        wsum+=w;\n    }\n    return ret/wsum/3;\n}\n\nbool convex(Polygon &p){\n    for(int i=0; i<p.n; i++)\n        if (sgn(det(p[i]-p[i+1],p[i+1]-p[i+2]))<0) return false;\n    return true;\n}\n\nPolygon convex_full(vector<V> &ps){\n    Polygon ret;\n    sort(ps.begin(), ps.end());\n    for(int i=0; i<ps.size(); i++){\n        while(ret.n>1 && sgn(det(ret[ret.n-1]-ret[ret.n-2],ps[i]-ret[ret.n-1]))<=0) ret.pop();\n        ret.push(ps[i]);\n    }\n    for(int i=ps.size()-2, t=ret.n; i>=0; i--){\n        while(ret.n>t && sgn(det(ret[ret.n-1]-ret[ret.n-2],ps[i]-ret[ret.n-1]))<=0) ret.pop();\n        ret.push(ps[i]);\n    }\n    ret.pop();\n    return ret;\n}\n\nlf diameter(Polygon &p){\n    if (p.n==2) return distance(p[0],p[1]);\n    lf ret=0;\n    int s=0,t=0;\n    for(int i=0; i<p.n; i++)\n        if (p[t]<p[i]) t = i;\n    int ed=t;\n    while(s!=ed || t!=p.n){\n        chmax(ret, distance(p[s],p[t]));\n        (sgn(det(p[s+1]-p[s], p[t]-p[t+1]))>0)? s++ : t++;\n    }\n    return ret;\n}\n\nPolygon convex_cut(Polygon &p, Line &l){\n    Polygon ret;\n    for(int i=0; i<p.n; i++){\n        if (ccw(l.p,l.q,p[i])!=-1) ret.push(p[i]);\n        if (ccw(l.p,l.q,p[i])*ccw(l.p,l.q,p[i+1])==-1){\n            Segment s(p[i+1],p[i]);\n            ret.push(cpoint(l,s));\n        }\n    }\n    return ret;\n}\n\n// OUT=0, ON=1, IN=2\nint contain(Polygon &p, const V &v){\n    int ret=0;\n    for(int i=0; i<p.n; i++){\n        V a=p[i]-v, b=p[i+1]-v;\n        if (a.y>b.y) swap(a,b);\n        if (sgn(a.y)<0 && sgn(b.y)>=0 && sgn(det(a,b))<0) ret=2-ret;\n        if (EQ(det(a,b),0.0) && sgn(dot(a,b))<=0) return 1;\n    }\n    return ret;\n}\n\n// OUT=0, ON=1, IN=2\nint convex_contain(Polygon &p, V &v){\n    V g = (p[0]+p[p.n/3]+p[p.n*2/3])/3;\n    int lo=0, hi=p.n;\n    while(hi-lo>1){\n        int c=(lo+hi)/2;\n        if (sgn(det(p[lo]-g,p[c]-g))>0){\n            (sgn(det(p[lo]-g,v-g))>0 && sgn(det(p[c]-g,v-g))<0)? hi=c: lo=c;\n        }else{\n            (sgn(det(p[lo]-g,v-g))<0 && sgn(det(p[c]-g,v-g))>0)? lo=c: hi=c;\n        }\n    }\n    return sgn(det(p[lo]-v,p[hi]-v))+1;\n}\n\n//-------------------------------------------------\n//--Circle (depends on Geometry Template)\n//-------------------------------------------------\n\nstruct Circle {\n    V p; lf r;\n    Circle(){}\n    Circle(const V &v, lf r):p(v),r(r){}\n    Circle(const Circle &c):p(c.p),r(c.r){}\n    lf area(){return r*r*PI;}\n    lf area(lf t){return r*r*t/2;}\n};\n\n// functons about circles\nbool contain(Circle &c, V &v){return sgn(distance(v,c.p)-c.r)<=0;}\nbool contain(Circle &c, Segment &s){\n    return sgn(max(distance(s.p,c.p),distance(s.q,c.p))-c.r)<=0;\n}\nbool insec(Circle &c, Line &l){return sgn(distance(l,c.p)-c.r)<=0;}\nbool insec(Circle &c, Segment &s){\n    return sgn(distance(s,c.p)-c.r)<=0 && sgn(max(distance(s.p,c.p),distance(s.q,c.p))-c.r)>=0;\n}\n\nvector<V> cpoint(Circle &a, Circle &b){\n    vector<V> ret;\n    V ab(b.p-a.p);\n    lf d = ab.norm(), dd = ab.sq();\n    lf c = (a.r*a.r+dd-b.r*b.r)/(2.0*a.r*d);\n    if (sgn(abs(c)-1.0)>0) return ret;\n    if (EQ(abs(c),1.0)){\n        c = (c>0)?1:-1;\n        ret.push_back(a.p+ab.unit().rot(c,0)*a.r);\n    }else{\n        lf s = sqrt(1.0-c*c);\n        ret.push_back(a.p+ab.unit().rot(c,s)*a.r);\n        ret.push_back(a.p+ab.unit().rot(c,-s)*a.r);\n    }\n    return ret;\n}\n\nvector<V> cpoint(Circle &c, Line &l){\n    vector<V> ret;\n    lf d = distance(l,c.p);\n    if (sgn(d-c.r)>0) return ret;\n    V h = ppfoot(l,c.p);\n    if (EQ(d,c.r)){\n        ret.push_back(h);\n    }else{\n        V r = (l.q-l.p).unit()*sqrt(c.r*c.r-d*d);\n        ret.push_back(h+r);\n        ret.push_back(h-r);\n    }\n    return ret;\n}\n\nvector<V> cpoint(Circle &c, Segment &s){\n    vector<V> ret,cand;\n    cand = cpoint(c,(Line&)s);\n    for(auto p:cand)if(sgn(dot(s.p-p,s.q-p))<=0)\n        ret.push_back(p);\n    return ret;\n}\n\nvector<V> tangent(Circle &c, const V &v){\n    lf rr=(c.p-v).sq()-c.r*c.r;\n    if (sgn(rr)<0) return vector<V>();\n    Circle c2(v,sqrt(rr));\n    return cpoint(c,c2);\n}\n\nvector<V> tangent(Circle &a, Circle &b){\n    vector<V> ret, t;\n    ret = tangent(a, subdiv(a.p,b.p,a.r,b.r));\n    if (!EQ(a.r,b.r)){\n        t = tangent(a, outside(a.p,b.p,a.r,b.r));\n    }else{\n        V r = (b.p-a.p).unit().rot90()*a.r;\n        t.push_back(a.p+r);\n        t.push_back(a.p-r);\n    }\n    for(auto p:t) ret.push_back(p);\n    return ret;\n}\n\nvector<Line> tangent_line(Circle &c, const V &v){\n    vector<Line> ret;\n    auto t = tangent(c,v);\n    for(auto p:t) ret.push_back(Line(v,p));\n    return ret;\n}\n\nvector<Line> tangent_line(Circle &a, Circle &b){\n    vector<Line> ret,t;\n    ret = tangent_line(a, subdiv(a.p,b.p,a.r,b.r));\n    if (!EQ(a.r,b.r)){\n        t = tangent_line(a, outside(a.p,b.p,a.r,b.r));\n    }else{\n        V r = (b.p-a.p).unit().rot90()*a.r;\n        t.push_back(Line(a.p+r, b.p+r));\n        t.push_back(Line(a.p-r, b.p-r));\n    }\n    for(auto l:t) ret.push_back(l);\n    return ret;\n}\n\nlf carea(Circle &a, Circle &b){\n    lf d = distance(a.p,b.p);\n    if (sgn(d+a.r-b.r)<=0) return a.area();\n    if (sgn(d+b.r-a.r)<=0) return b.area();\n    auto cps = cpoint(a,b);\n    if (cps.size()<2) return 0.0;\n    lf t1 = acos(dot((cps[1]-a.p).unit(),(cps[0]-a.p).unit()));\n    if (sgn(det(cps[1]-a.p,cps[0]-a.p))<0) t1=2*PI-t1;\n    lf t2 = acos(dot((cps[0]-b.p).unit(),(cps[1]-b.p).unit()));\n    if (sgn(det(cps[0]-b.p,cps[1]-b.p))<0) t2=2*PI-t2;\n    return a.area(t1)+b.area(t2)-d*(cps[1]-cps[0]).norm()/2;\n}\n\nlf carea(Polygon &p, Circle &c){\n    lf ret=0;\n    for(int i=0; i<p.n; i++){\n        lf da = distance(p[i],c.p);\n        lf db = distance(p[i+1],c.p);\n        Segment s(p[i],p[i+1]);\n        auto cps = cpoint(c,s);\n        if (sgn(max(da,db)-c.r)<=0){\n            ret+=det(p[i]-c.p,p[i+1]-c.p)/2;\n        }else if(cps.empty()){\n            lf t = acos(dot((p[i]-c.p).unit(),(p[i+1]-c.p).unit()));\n            t *= sgn(det(p[i]-c.p,p[i+1]-c.p));\n            ret+=c.area(t);\n        }else{\n            if (cps.size()==1) cps.push_back(cps[0]);\n            ret+=det(cps[1]-c.p,cps[0]-c.p)/2;\n            if (sgn(da-c.r)<=0) ret+=det(s.p-c.p,cps[1]-c.p)/2;\n            else{\n                lf t = acos(dot((s.p-c.p).unit(),(cps[1]-c.p).unit()));\n                t *= sgn(det(s.p-c.p,cps[1]-c.p));\n                ret+=c.area(t);\n            }\n            if (sgn(db-c.r)<=0) ret+=det(cps[0]-c.p,s.q-c.p)/2;\n            else{\n                lf t = acos(dot((cps[0]-c.p).unit(),(s.q-c.p).unit()));\n                t *= sgn(det(cps[0]-c.p,s.q-c.p));\n                ret+=c.area(t);\n            }\n        }\n    }\n    return ret;\n}\n\n//-------------------------------------------------\n\nstruct Event{\n    lf x,d1,d2; int id;\n    Event(lf x, int id, lf d1, lf d2):x(x),id(id),d1(d1),d2(d2){}\n};\nbool operator<(const Event &a, const Event &b){\n    if (a.x!=b.x) return a.x<b.x;\n    return a.id<b.id;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout<<setp(12);\n    int n; cin>>n;\n    vector<Event> event;\n    rep(i,n){\n        int a,b,c,d; cin>>a>>b>>c>>d;\n        V p = V(a,b), q = V(c,d);\n        if (q<p) swap(p,q);\n        if (p.x==q.x){\n            event.pb(Event(p.x,1,p.y,q.y));\n        }else{\n            event.pb(Event(p.x,0,p.y,p.y));\n            event.pb(Event(q.x,2,p.y,p.y));\n        }\n    }\n    sort(all(event));\n    int ans=0;\n    set<lf> hori;\n    for(auto e:event){\n        if (e.id==0) hori.ins(e.d1);\n        if (e.id==1){\n            auto itr = hori.lower_bound(e.d1);\n            auto ed = hori.upper_bound(e.d2);\n            while(itr!=ed) ans++, itr++;\n        }\n        if (e.id==2) hori.erase(e.d1);\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) fabs((a)-(b))<DBL_EPSILON*fmax(1,fmax(fabs(a),fabs(b)))\n//点\nclass Point{\n    public:\n        double x,y;\n        Point(double x=0,double y=0):x(x),y(y){}\n\n        Point operator + (Point p){return Point(x+p.x,y+p.y);}\n        Point operator - (Point p){return Point(x-p.x,y-p.y);}\n        Point operator * (double a){return Point(a*x,a*y);}\n        Point operator / (double a){return Point(x/a,y/a);}\n\n        double norm(Point p){return p.x*p.x+p.y*p.y;}\n        double abs(Point p){return sqrt(norm(p));}    \n        bool operator < (const Point &p)const{\n            return x!=p.x?x<p.x:y<p.y;\n        }\n        bool operator == (const Point &p)const{\n            return equals(x,p.x)&&equals(y,p.y);\n        }\n};\ntypedef Point Vector;\nstruct Segment{ Point p1,p2; };\ntypedef Segment Line;\ndouble norm(Vector v){return v.x*v.x+v.y*v.y;} \ndouble abs(Vector v){return sqrt(norm(v));}    \n//円\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\n//外戚\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n//直交\nbool isOrthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){ return isOrthogonal(a1-a2,b1-b2); }\nbool isOrthogonal(Segment s1,Segment s2){ return equals(dot(s1.p1-s1.p2,s2.p1-s2.p2),0.0); }\n//平行\nbool isParallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\nbool isParallel(Point a1,Point a2,Point b1,Point b2){ return isParallel(a1-a2,b1-b2); }\nbool isParallel(Segment s1,Segment s2){ return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); }\n//射影\nPoint project(Segment s,Point p){ //射影　p377\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n//反射　p379\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//ベクトルa,bの位置関係\nstatic const int COUNTER_CLOCKWISE=1;//反時計回り\nstatic const int CLOCKWISE=-1;//時計回り\nstatic const int ONLINE_BACK=2;//p2,p0,p1の順で一直線上\nstatic const int ONLINE_FRONT=-2;//p0,p1,p2の順で一直線上\nstatic const int ON_SEGMENT=0;//p0,p2,p1の順で一直線上\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(norm(a)<norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n//交差判定　p389\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);//p1,p2,p3,p4の順で一直線になるのを除く\n}\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//交点の座標　p392\nPoint getCrossPoint(Segment s1,Segment s2){ \n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n//距離p380\ndouble getDistance(Point a,Point b){ return abs(a-b);} //点aと点b\ndouble getDistanceLP(Line l,Point p){//直線lと点p\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\ndouble getDistanceSP(Segment s,Point p){//線分sと点p\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\ndouble getDistance(Segment s1,Segment s2){ //線分s1と線分s2\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n            min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//円　交点\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    //asert(intersect(c,l));   交点を持つことの確認\n    Vector pr =project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n//２つの円の交点\ndouble arg(Vector p){ return atan2(p.y,p.x); }\nVector polar(double a,double r){ return Point(cos(r)*a,sin(r)*a);}\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n//点の内包p398\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p;\n        Point b=g[(i+1)%n]-p;\n        if( abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;\n        if(a.y>b.y)swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);\n}  \n//凸包　アンドリューのアルゴリズム\nPolygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    //凸包の上部を生成\n    for(int i=2;i<s.size();i++){\n        //        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--) //辺上を含まない\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n            u.pop_back();\n        u.push_back(s[i]);   \n    }\n    //凸包の下部を生成\n    for(int i=s.size()-3;i>=0;i--){\n        //        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)//辺上を含まない\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--) \n            l.pop_back();\n        l.push_back(s[i]);    \n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n//平面走査p408\nstatic const int BOTTOM=0;\nstatic const int LEFT=1;\nstatic const int RIGHT=2;\nstatic const int TOP=3;\nclass EndPoint{\n    public:\n        Point p;\n        int seg,st;\n        EndPoint(){}\n        EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n        bool operator < (const EndPoint &ep) const{\n            if(p.y==ep.p.y)\n                return st<ep.st;//BOTTOM,LEFT,RIGHT,TOP\n            else\n                return p.y<ep.p.y;\n        }\n};\nEndPoint EP[2*100000];\nint manhattanIntersection(vector<Segment> S){\n    int n=S.size();\n    for(int i=0,k=0;i<n;i++){\n        if(S[i].p1.y==S[i].p2.y){\n            if(S[i].p1.x>S[i].p2.x)\n                swap(S[i].p1,S[i].p2);\n        }else if(S[i].p1.y>S[i].p2.y)\n            swap(S[i].p1,S[i].p2);\n\n        if(S[i].p1.y==S[i].p2.y){\n            EP[k++]=EndPoint(S[i].p1,i,LEFT);\n            EP[k++]=EndPoint(S[i].p2,i,RIGHT);\n        }else{\n            EP[k++]=EndPoint(S[i].p1,i,BOTTOM);\n            EP[k++]=EndPoint(S[i].p2,i,TOP);\n        }\n    }\n    sort(EP,EP+(2*n));\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt=0;\n    for(int i=0;i<2*n;i++){\n        if(EP[i].st==TOP)\n            BT.erase(EP[i].p.x);\n        else if(EP[i].st==BOTTOM)\n            BT.insert(EP[i].p.x);\n        else if(EP[i].st==LEFT){\n            set<int>::iterator b=BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e=BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt+=distance(b,e);//bからeまでの数\n        }    \n    }\n    return cnt;\n}\nint main(){\n    int n,cnt;\n    cin>>n;\n    Segment s;\n    vector<Segment> S;\n    for(int i=0;i<n;i++){\n        Point p1,p2;\n        cin>>p1.x>>p1.y>>p2.x>>p2.y;\n        s.p1=p1;\n        s.p2=p2;\n        S.push_back(s);\n    }\n    cnt =manhattanIntersection(S);\n    cout<<cnt<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cctype>           // isdigit()\n#include <set>\n#include <iterator>         // distance()\n#include <algorithm>        // swap(), sort(), lower_bound(), upper_bound()\n\nusing namespace std;\nstatic const int MAX_N = 100000;\nenum { BOTTOM = 0, LEFT, RIGHT, TOP };\n\nstruct Point\n{\n\tint x;\n\tint y;\n};\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\n\nclass EndPoint\n{\npublic:\n\tPoint p;\n\tint seg; // ??\\????????????ID\n\tint st;  // ??????????¨????\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\tbool operator < (const EndPoint &ep) const\n\t{\n\t\t// y ??§?¨?????°???????????????´???\n\t\tif (p.y != ep.p.y)\n\t\t\treturn p.y < ep.p.y;\n\t\telse\n\t\t\treturn st < ep.st; // y ??????????????´????????????????????????????????????????????????????????????????????????\n\t}\n};\n\nSegment S[MAX_N];\nEndPoint EP[2 * MAX_N]; // ??????????????????\nint n;\n\n// ??????????????????: ????????????????????????\nint\nmanhattanIntersection()\n{\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\t// ?????? p1,p2 ??????????????????????????¶??????????????´\n\t\tif (S[i].p1.y == S[i].p2.y)\n\t\t{\n\t\t\tif (S[i].p1.x > S[i].p2.x)\n\t\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\telse if (S[i].p1.y > S[i].p2.y)\n\t\t\tswap(S[i].p1, S[i].p2);\n\n\t\tif (S[i].p1.y == S[i].p2.y) // ?°´????????????????????????????????????\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\n\t\telse // ?????´?????????????????????????????????\n\t\t{\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + k); // ????????? y ??§?¨??????¢?????????????????´???\n\n\tset<int> BT; // ????????¢?????¨\n\tBT.insert(1000000001); // ??????????¨????\n\n\tint cnt = 0;\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tif (EP[i].st == TOP)\n\t\t\tBT.erase(EP[i].p.x); // ??????????????????\n\t\telse if (EP[i].st == BOTTOM)\n\t\t\tBT.insert(EP[i].p.x); // ??????????????????\n\t\telse if (EP[i].st == LEFT)\n\t\t{\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x); // O(log n)\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x); // O(log n)\n\t\t\tcnt += distance(b, e); // b ??¨ e ????????¢(????????°)????????????O(k)\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint\nget_int(int* bc)\n{\n\tint n;\n\tint s;\n\tint c = *bc;\n\n\twhile (c == ' ' || c == '\\n')\n\t\tc = getchar();\n\n\tif (c == '-')\n\t{\n\t\ts = -1;\n\t\tc = getchar();\n\t}\n\telse\n\t\ts = 1;\n\n\tn = 0;\n\twhile (isdigit(c))\n\t{\n\t\tn = n * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\n\t*bc = c;\n\tn *= s;\n\treturn n;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint c;\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\t// scanf(\"%d %d %d %d\", &S[i].p1.x, &S[i].p1.y, &S[i].p2.x, &S[i].p2.y);\n\t\tc = getchar();\n\t\tS[i].p1.x = get_int(&c);\n\t\tS[i].p1.y = get_int(&c);\n\t\tS[i].p2.x = get_int(&c);\n\t\tS[i].p2.y = get_int(&c);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define INF 1e9\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int opt,l,r,x;}f[N*3];\nstruct seg{int ls,rs,su;}t[10000010];\nint nf,q,p1,p2,q1,q2,ansn,ro,num;\nbool comp(const Info &a,const Info &b){if (a.x==b.x) return a.opt<b.opt;return a.x<b.x;}\nvoid add(int &nu,int l,int r,int we,int x){\n\tif (!nu) nu=++num;\n\tt[nu].su+=x;\n\tif (l!=r){\n\t\tif (we<=(l+r)/2) add(t[nu].ls,l,(l+r)/2,we,x);\n\t\telse add(t[nu].rs,(l+r)/2+1,r,we,x);\n\t}\n}\nint que(int nu,int l,int r,int nl,int nr){\n\tif (!nu) return 0;\n\tif (l==nl&&r==nr) return t[nu].su;\n\tint mid=(l+r)/2;\n\tif (nl>mid)return que(t[nu].rs,mid+1,r,nl,nr);\n\tif (nr<=mid) return que(t[nu].ls,l,mid,nl,nr);\n\treturn que(t[nu].ls,l,mid,nl,mid)+que(t[nu].rs,mid+1,r,mid+1,nr);\n}\nint main(){\n\tread(q);\n\tfor (int i=1;i<=q;i++){\n\t\tread(p1);read(q1);read(p2);read(q2);\n\t\tif (p1==p2){\n\t\t\tf[++nf].opt=1;f[nf].l=p1;f[nf].x=q1;\n\t\t\tf[++nf].opt=-1;f[nf].l=p1;f[nf].x=q2+1;\n\t\t}else{\n\t\t\tf[++nf].opt=2;f[nf].l=p1;f[nf].r=p2;f[nf].x=q1;\n\t\t}\n\t}\n\tsort(f+1,f+nf+1,comp);\n\tfor (int i=1;i<=nf;i++){\n\t\tif (f[i].opt==2)ansn+=que(ro,-INF,INF,f[i].l,f[i].r);\n\t\telse add(ro,-INF,INF,f[i].l,f[i].opt);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*<<head>> {{{*/\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n//INF = 1 061 109 567 ; INF + INF = 2 122 219 134 ;\n//LINF = 4 557 430 888 798 830 399 ; LINF + LINF = 9 114 861 777 597 660 798 ;\nconst int INF = 0x3f3f3f3f;     // -INF: 0xc0   abs(-INF) = INF + 1\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n/*}}}*/                         // zr, zm\nconst int MOD = (int)1e9+7;     // when MOD = 1e9+7, inv2 = 500000004\nconst int N = (int)1e6+7;\n\n// ------- 变量 ------- //\n\nstruct node {\n    int x1, x2, y, ty;\n    node () {} node (int x1, int x2, int y, int ty) : x1(x1), x2(x2), y(y), ty(ty) {}\n    bool operator < (const node &rhs) const {\n        return y != rhs.y ? y < rhs.y : ty > rhs.ty;\n    }\n};\n\nint n;\nvector <node> endp;\nvi dis;\n\n// ------- 函数 ------- //\n\nint rk(int x) { return lower_bound(all(dis), x) - dis.begin() + 1; }\n\nint t[N];\nint sum(int x) { int res = 0; for (; x > 0; x -= x&-x) res += t[x]; return res; }\nvoid upd(int x, int d) { for (; x <= N; x += x&-x) t[x] += d; }\n\nvoid Init() {\n    endp.clear(); dis.clear();\n    rep(i, 0, n) {\n        int x1, y1, x2, y2;\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        if (x1 == x2) {\n            if (y1 > y2) swap(y1, y2);\n            endp.pb(node(x1, 0, y1, 1));\n            endp.pb(node(x1, 0, y2, -1));\n        } else {\n            if (x1 > x2) swap(x1, x2);\n            endp.pb(node(x1, x2, y1, 0));\n        }\n        dis.pb(x1); dis.pb(x2);\n    }\n    sort(all(dis));\n    dis.erase(unique(all(dis)), dis.end());\n    sort(all(endp));\n}\n\nint Solve() {\n    int ans = 0;\n    for (auto o : endp) {\n        if (o.ty == 0) {\n            ans += sum(rk(o.x2)) - sum(rk(o.x1)-1);\n        } else {\n            upd(rk(o.x1), o.ty);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n// ------- main ------- //\n\nint main ()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    //Pre();\n    //int t; scanf(\"%d\", &t); while (t--) {\n    while (~scanf(\"%d\", &n)) {\n    //while(fgets(s, N, stdin)) {   // 注意 fgets 会读入换行符\n        //if (n == 0) break;\n        //static int kase = 0; printf(\"Case %d: \", ++kase);\n        Init();\n        Solve();\n        //if (t) puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\n//定義系\n\ndouble EPS = 1e-10;\n\n//誤差を考慮して足し算を行う\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\n\n//Point\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {\n\t}\n\tPoint operator + (Point p) {\n\t\treturn Point(add(x, p.x), add(y, p.y));\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(add(x, -p.x), add(y, -p.y));\n\t}\n\tPoint operator * (double d) {\n\t\treturn Point(x*d, y*d);\n\t}\n\tPoint operator / (double d) {\n\t\treturn Point(x / d, y / d);\n\t}\n\t//内積\n\tdouble dot(Point p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\t//外積\n\tdouble det(Point p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\t//点の大小比較\n\tbool operator <(const Point &p)const {\n\t\tif (fabs(add(x, -p.x)) < EPS)return y < p.y;\n\t\treturn x < p.x;\n\t}\n\tbool operator ==(const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\n//ベクトル。使い分けるといいかも\ntypedef Point Vector;\n\n//ベクトルの大きさの2乗\ndouble norm(Vector p) {\n\treturn p.x*p.x + p.y*p.y;\n}\n\n//ベクトルの大きさ\ndouble abs(Vector p) {\n\treturn sqrt(norm(p));\n}\n\n//線分\nstruct Segment {\n\tPoint p1, p2;\n};\n\n//直線\ntypedef Segment Line;\n\n//中心c,半径rの円\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n//頂点集合\ntypedef vector<Point> Points;\n\n\n\n\n//計算・アルゴリズム系\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (a.det(b) > EPS)return COUNTER_CLOCKWISE;\n\tif (a.det(b) < -EPS)return CLOCKWISE;\n\tif (a.dot(b) < -EPS)return ONLINE_BACK;\n\tif (norm(a) < norm(b))return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルa,bの直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn a.dot(b) == 0.0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).dot(s2.p2 - s2.p1) == 0.0;\n}\n\n//ベクトルa,bの並行判定\nbool isParallel(Vector a, Vector b) {\n\treturn a.det(b) == 0.0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).det(s2.p2 - s2.p1) == 0.0;\n}\n\n//射影(点p1と点p2を通る直線に点pから垂線を引いた交点xを求める)\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = (p - s.p1).dot(base) / norm(base);\n\treturn s.p1 + base*r;\n}\n\n//反射(点p1と点p2を通る直線を対象軸として点pと線対称の位置にある点xを求める)\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\n//点aと点bの距離\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n//直線lと点pの距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs((l.p2 - l.p1).det(p - l.p1) / abs(l.p2 - l.p1));\n}\n\n//線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif ((s.p2 - s.p1).dot(p - s.p1) < 0.0)return abs(p - s.p1);\n\tif ((s.p1 - s.p2).dot(p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n//線分s1と線分s2の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment l, Segment m) {\n\tdouble d1 = (l.p2 - l.p1).det( m.p2 - m.p1);\n\tdouble d2 = (l.p2 - l.p1).det( l.p2 - m.p1);\n\tif (abs(d1) < EPS && abs(d2) < EPS) return m.p1;\n\treturn m.p1 + (m.p2 - m.p1) * d2 / d1;\n}\n\n//円cと線分lの交点\npair<Point, Point>getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r)*a, sin(r)*a); }\npair<Point, Point>getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//点の内包 0:in,1:on,2:out\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(a.det(b)) < EPS&&a.dot(b) < EPS) return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS < b.y&&EPS < a.det(b))x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n//凸包を求める\nPolygon convex_hull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() <= 2)return s;\n\tsort(s.begin(), s.end(), [](const Point &p1, const Point &p2) {return p1.y == p2.y ? p1.x<p2.x : p1.y<p2.y; });\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i<s.size(); i++){\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE&&ccw(u[n - 2], u[n - 1], s[i]) != ONLINE_FRONT; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE&&ccw(l[n - 2], l[n - 1], s[i]) != ONLINE_FRONT; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n\n\treturn l;\n}\n\n//y座標の昇順でマージするための比較関数\nbool compare_y(Point a, Point b) {\n\treturn a.y < b.y;\n}\n\n//最近点対\ndouble closest_pair(Point *a, int n) {\n\tif (n <= 1)return INF<double>();\n\tsort(a, a + n);\n\tint m = n / 2;\n\tdouble x = a[m].x;\n\tdouble d = min({ closest_pair(a,m),closest_pair(a + m,n - m) });//p,qが違う区間にある\n\tinplace_merge(a, a + m, a + n, compare_y);//2つのソートされた列をマージ\n\n\t\t\t\t\t\t\t\t\t\t\t  //p,qが同じ区間にある\n\tPoints b;//直線から距離d未満の頂点を入れていく\n\tfor (int i = 0; i < n; i++) {\n\t\tif (add(fabs(add(a[i].x, -x)), -d) >= 0.0)continue;\n\n\t\t//bに入っている頂点を、末尾からy座標の差がd以上になるまで見ていく\n\t\tfor (int j = 0; j < b.size(); j++) {\n\t\t\tPoint dd;\n\t\t\tdd.x = add(a[i].x, -b[b.size() - j - 1].x);\n\t\t\tdd.y = add(a[i].y, -b[b.size() - j - 1].y);\n\t\t\tif (add(dd.y, -d) >= 0.0)break;\n\t\t\td = min(d, abs(dd));\n\t\t}\n\t\tb.emplace_back(a[i]);\n\t}\n\treturn d;\n}\n\n//多角形の面積\ndouble area(Polygon p) {\n\tint n = p.size();\n\tdouble sum = 0.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum = add(sum,0.5*p[i].det(p[(i + 1) % n]));\n\t}\n\treturn sum < 0.0 ? -sum : sum;\n}\n\n//凸性判定\nbool is_convex(Polygon p) {\n\tfor (int i = 0; i < p.size(); i++) {\n\t\tif (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) == -1)return false;\n\t}\n\treturn true;\n}\n\n//切断\nPolygon convex_cut(Polygon p, Line l) {\n\tPolygon ret;\n\tfor (int i = 0; i < p.size(); i++) {\n\t\tPoint cur = p[i], nxt = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, cur) != -1)ret.emplace_back(cur);\n\t\tif (ccw(l.p1, l.p2, cur)*ccw(l.p1, l.p2, nxt) < 0) {\n\t\t\tSegment seg;\n\t\t\tseg.p1 = cur;\n\t\t\tseg.p2 = nxt;\n\t\t\tret.emplace_back(getCrossPoint(seg, l));\n\t\t}\n\t}\n\treturn ret;\n}\n\n//端点の種類\n# define BOTTOM 0\n# define LEFT 1\n# define RIGHT 2\n# define TOP 3\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st;//入力線分のID,端点の種類\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator <(const EndPoint &ep)const {\n\t\t//y座標が小さい順に整列\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;//yが同一の場合は、下端点、左端点、右端点、上端点の順に調べる\n\t\t}\n\t\telse {\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n};\n\nEndPoint EP[202020];//端点のリスト\n\n//線分交差問題（マンハッタン幾何）\n\nint ManhattanIntersection(vector<Segment> s) {\n\tint n = s.size();\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t//端点p1,p2が左下を基準に並ぶように調整\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tif(s[i].p1.x>s[i].p2.x)swap(s[i].p1, s[i].p2);\n\t\t}\n\t\telse if (s[i].p1.y > s[i].p2.y)swap(s[i].p1, s[i].p2);\n\n\t\tif (s[i].p1.y == s[i].p2.y) {//水平線分を端点リストに追加\n\t\t\tEP[k++] = EndPoint(s[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(s[i].p2, i, RIGHT);\n\t\t}\n\t\telse {//垂直線分を端点リストに追加\n\t\t\tEP[k++] = EndPoint(s[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(s[i].p2, i, TOP);\n\t\t}\n\t}\n\tsort(EP, EP + 2 * n);//端点のy座標に関して昇順に整列\n\n\tset<LL> bt;//二分探索木\n\tbt.insert(1010101010);\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP) {\n\t\t\tbt.erase(EP[i].p.x);//上端点を削除\n\t\t}\n\t\telse if (EP[i].st == BOTTOM) {\n\t\t\tbt.insert(EP[i].p.x);\n\t\t}\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<LL>::iterator b = bt.lower_bound(s[EP[i].seg].p1.x);\n\t\t\tset<LL>::iterator e = bt.upper_bound(s[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);//bとeの距離（点の数）を加算\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<Segment>v;\n\tREP(i, n) {\n\t\tSegment s;\n\t\tcin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n\t\tv.emplace_back(s);\n\t}\n\tcout << ManhattanIntersection(v) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <set>\n#define maxn 400005\nusing namespace std;\ntypedef long long ll;\ntypedef set<int>:: iterator Ite;\nconst int DOWN = 0;\nconst int LEFT = 1;\nconst int UP = 2;\nint n,m,rig[100005];\nstruct Point{\n\tint type,x,y,seg;\n\tPoint(int a = 0,int b = 0,int c = 0,int d = 0): type(a),x(b),y(c),seg(d) {}\n}ps[maxn];\nbool cmp(const Point &a,const Point &b){\n\tif(a.y == b.y){\n\t\tif(a.type == b.type) return a.x < b.x;\n\t\treturn a.type < b.type;\n\t}\n\treturn a.y < b.y;\n}\nint work(){\n\tsort(ps+1,ps+m+1,cmp);\n\tint ans = 0;\n\tset <int> st;\n\tst.clear();\n\tfor(int i=1;i<=m;i++){\n\t\tif(ps[i].type == 0) st.insert(ps[i].x);\n\t\telse if(ps[i].type == 2) st.erase(ps[i].x);\n\t\telse{\n\t\t\tint l = ps[i].x,r = rig[ps[i].seg];\n\t\t\tIte itl = st.lower_bound(l),itr = st.upper_bound(r);\n\t\t\tans += distance(itl,itr);\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tm = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint x1,y1,x2,y2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1 == x2){\n\t\t\tif(y1 > y2) swap(y1,y2);\n\t\t\tps[++m] = Point(0,x1,y1,0);\n\t\t\tps[++m] = Point(2,x1,y2,0);\n\t\t}else{\n\t\t\tif(x1 > x2) swap(x1,x2);\n\t\t\tps[++m] = Point(1,x1,y1,i);\n\t\t\trig[i] = x2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",work());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int inf = 1e9+10;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    while(cin>>n)\n    {\n        vector<pair<int,pii> > ex;\n        for(int i=0;i<n;i++)\n        {\n            int x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            if(y1==y2)\n            {\n                ex.push_back(make_pair(min(x1,x2),pii(-inf,y1)));\n                ex.push_back(make_pair(max(x1,x2),pii(inf,y2)));\n            }else\n            {\n                ex.push_back(make_pair(x1,pii(min(y1,y2),max(y1,y2))));\n            }\n        }\n\n        sort(ex.begin(),ex.end());\n\n        set<int> se;\n        int ans = 0;\n        for(int i=0;i<ex.size();i++)\n        {\n            int y1=ex[i].second.first,y2=ex[i].second.second;\n            if(y1==-inf)\n            {\n                se.insert(y2);\n            }else if(y1==inf)\n            {\n                se.erase(y2);\n            }else\n            {\n                ans += distance(se.lower_bound(y1),se.upper_bound(y2));\n            }\n        }\n\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = (1LL<<30);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nstruct Point{\n  double x, y;\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b){\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nPoint project(Segment s, Point p){\n  Vector a = s.p2 - s.p1;\n  Vector b = p - s.p1;\n  return s.p1 + a * (dot(a, b)/a.norm());\n}\n\nPoint reflect(Segment s, Point p){\n  return p + (project(s, p) - p)*2;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  else if(cross(a, b) < -EPS) return CLOCKWISE;\n  else if(dot(a, b) < -EPS) return ONLINE_BACK;\n  else if(a.norm() < b.norm()) return ONLINE_FRONT;\n  else return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\ndouble getDistance(Point a, Point b){\n  Point tmp = a-b;\n  return tmp.abs();\n}\n\ndouble getDistanceLP(Line l, Point p){\n  Vector a = l.p2 - l.p1;\n  Vector b = p - l.p1;\n  return abs(cross(a, b) / a.abs());\n}\n\ndouble getDistanceSP(Segment s, Point p){\n  Vector a = s.p2 - s.p1;\n  Vector b = p - s.p1;\n  double n = dot(a, b) / a.norm();\n  if(0.0 <= n && n <= 1.0) return getDistanceLP(s, p);\n  else return min(getDistance(s.p1, p), getDistance(s.p2, p));\n}\n\ndouble getDistanceSS(Segment s1, Segment s2){\n  if(intersect(s1.p1, s1.p2, s2.p1, s2.p2)) return 0.0;\n  double res = INF;\n  chmin(res, getDistanceSP(s1, s2.p1));\n  chmin(res, getDistanceSP(s1, s2.p2));\n  chmin(res, getDistanceSP(s2, s1.p1));\n  chmin(res, getDistanceSP(s2, s1.p2));\n  return res;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n  double d1 = getDistanceLP(s1, s2.p1);\n  double d2 = getDistanceLP(s1, s2.p2);\n  double t = d1/(d1+d2);\n  return s2.p1 + (s2.p2 - s2.p1)*t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l){\n  assert(getDistanceLP(l, c.c) <= c.r);\n  Point pr = project(l, c.c);\n  Vector a = l.p2 - l.p1;\n  Vector e = a / a.abs();\n  Vector vcpr = pr - c.c;\n  double d = sqrt(c.r*c.r - vcpr.norm());\n  return make_pair(pr+e*d, pr-e*d);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double r, double w) { return Point(cos(w)*r, sin(w)*r); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n  assert(getDistance(c1.c, c2.c) <= c1.r+c2.r);\n  double d = getDistance(c1.c, c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double b = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, b+a), c1.c + polar(c1.r, b-a));\n}\n\nint contains(Polygon g, Point p){\n  int n = g.size();\n  bool x = false;\n  rep(i, n){\n    Vector a = g[i] - p;\n    Vector b = g[(i+1)%n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && b.y > EPS && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s){\n  stack<Point> u, l;\n  int n = s.size();\n  if(n < 3) return s;\n  sort(all(s));\n  u.push(s[0]);\n  u.push(s[1]);\n  l.push(s[n-1]);\n  l.push(s[n-2]);\n  \n  REP(i, 2, n-1){\n    Point b, bb;\n    do{\n      b = u.top(); u.pop();\n      if(u.empty()) break;\n      bb = u.top();\n    }while(ccw(b, bb, s[i]) == CLOCKWISE);\n    u.push(b);\n    u.push(s[i]);\n  }\n\n  REPR(i, n-3, 0){\n    Point b, bb;\n    do{\n      b = l.top(); l.pop();\n      if(l.empty()) break;\n      bb = l.top();\n    }while(ccw(b, bb, s[i]) == CLOCKWISE);\n    l.push(b);\n    l.push(s[i]);\n  }\n\n  Polygon res;\n  while(!l.empty()){\n    res.push_back(l.top());\n    l.pop();\n  }\n  u.pop();\n  while(u.size() != 1){\n    res.push_back(u.top());\n    u.pop();\n  }\n\n  return res;\n}\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nstruct EndPoint{\n  Point p;\n  int seg, st;\n  EndPoint(){}\n  EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n  bool operator < (const EndPoint &ep) const {\n    if(p.y == ep.p.y) return st < ep.st;\n    else return p.y < ep.p.y;\n  }\n};\n\nEndPoint EP[2*100000];\n\nint manhattanIntersection(vector<Segment> S){\n  int n = S.size();\n  int k = 0;\n  rep(i, n){\n    if(S[i].p1.y == S[i].p2.y){\n      if(S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n      EP[k++] = EndPoint(S[i].p1, i, LEFT);\n      EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n    }\n    else{\n      if(S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n      EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n      EP[k++] = EndPoint(S[i].p2, i, TOP);\n    }\n  }\n  sort(EP, EP+(2*n));\n\n  set<int> BT;\n  BT.insert(1001001001);\n  int cnt = 0;\n  rep(i, 2*n){\n    if(EP[i].st == BOTTOM) BT.insert(EP[i].p.x);\n    else if(EP[i].st == TOP) BT.erase(EP[i].p.x);\n    else if(EP[i].st == LEFT){\n      set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n      set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<Segment> S(n);\n  rep(i, n){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    Point p1 = Point(x1, y1);\n    Point p2 = Point(x2, y2);\n    S[i] = Segment(p1, p2);\n  }\n\n  cout << manhattanIntersection(S) << endl;\n\n  return 0;\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Segment Intersections: Manhattan Geometry\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble arg(Vector p) {\n    return atan2(p.y, p.x);\n}\n\nVector polar(double r, double theta) {\n    return Point(cos(theta) * r, sin(theta) * r);\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m + base * t, m - base * t);\n}\n\npair<Point, Point> getCrossPoint(Circle c1, Circle c2) {\n    double d = (c1.c - c2.c).abs();\n    double a = acos((pow(d, 2.0) + pow(c1.r, 2.0) - pow(c2.r, 2.0)) / (2 * d * c1.r));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nint contains(Polygon g, Point p) {\n    int n = int(g.size());\n    bool x = false;\n    for(int i = 0; i < n; i++) {\n        Vector a = g[i] - p;\n        Vector b = g[(i + 1) % n] - p;\n        if(fabs(cross(a, b)) < ESP && dot(a, b) < ESP) return 1;\n        if(a.y > b.y) swap(a, b);\n        if(cross(a, b) > ESP && a.y < ESP && b.y > ESP) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\nPolygon getConvexHull(vector<Point> s) {\n    if(s.size() < 3) return s;\n    Polygon u, l;\n    sort(s.begin(), s.end());\n\n    u.emplace_back(s[0]);\n    u.emplace_back(s[1]);\n    l.emplace_back(s[s.size() - 1]);\n    l.emplace_back(s[s.size() - 2]);\n\n    for(int i = 2; i < s.size(); i++) {\n        for(int n = int(u.size()); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = int(s.size()) - 3; i >= 0; i--) {\n        for(int n = int(l.size()); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.emplace_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = int(u.size()) - 2; i > 0; i--) l.emplace_back(u[i]);\n    return l;\n}\n\nenum {\n    BOTTOM = 0,\n    LEFT = 1,\n    RIGHT = 2,\n    TOP = 3\n};\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if(p.y == ep.p.y) {\n            return st < ep.st;\n        } else return p.y < ep.p.y;\n    }\n};\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = int(S.size());\n    EndPoint EP[100000 * 2];\n\n    for(int i = 0, k = 0; i < n; i++) {\n        if(fabs(S[i].p1.y - S[i].p2.y) < ESP) {\n            if(S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if(S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n        if(fabs(S[i].p1.y - S[i].p2.y) < ESP) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(INT_MAX);\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++) {\n        EndPoint ep = EP[i];\n        if(ep.st == BOTTOM) BT.insert(ep.p.x);\n        if(ep.st == TOP) BT.erase(ep.p.x);\n        if(ep.st == LEFT) {\n            auto b = BT.lower_bound(S[ep.seg].p1.x);\n            auto e = BT.upper_bound(S[ep.seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    int n, x0, y0, x1, y1;\n    cin >> n;\n    vector<Segment> S;\n    for(int i = 0; i < n; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        S.emplace_back(Segment(Point(x0, y0), Point(x1, y1)));\n    }\n\n    cout << manhattanIntersection(S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nnamespace geom {\n  constexpr double eps = 1e-8;\n\n  /* point */\n  struct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(this->x + p.x, this->y + p.y); }\n    Point operator-(const Point& p) const { return Point(this->x - p.x, this->y - p.y); }\n    Point operator-() const { return Point(-this->x, -this->y); }\n    Point& operator+=(const Point& p) { return *this = *this + p; }\n    Point& operator-=(const Point& p) { return *this = *this - p; }\n    bool operator==(const Point& p) const { return x == p.x && y == p.y; }\n    bool operator!=(const Point& p) const { return !(*this == p); }\n    bool operator<(const Point& p) const { return x == p.x ? y < p.y : x < p.x; }\n    bool operator<=(const Point& p) const { return *this == p || *this < p; }\n    bool operator>(const Point& p) const { return !(*this <= p); }\n    bool operator>=(const Point& p) const { return !(*this < p); }\n    double length() const { return std::sqrt(x * x + y * y); }\n    double length2() const { return x * x + y * y; }\n    double distance(const Point& p) const { return sqrt(pow(x - p.x, 2.0) + pow(y - p.y, 2.0)); }\n    friend std::ostream& operator<<(std::ostream& o, const Point& p) {\n      o << '(' << p.x << ',' << p.y << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Point& p) {\n      i >> p.x >> p.y;\n      return i;\n    }\n  };\n  \n  /* vector */\n  using Vector = Point;\n  double cross_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n  }\n  double inner_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  enum struct ccw_t {\n    COUNTER_CLOCKWISE,\n    CLOCKWISE,\n    ONLINE_BACK,\n    ONLINE_FRONT,\n    ON_SEGMENT\n  };\n  ccw_t ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if (cross_product(v1, v2) > eps) return ccw_t::COUNTER_CLOCKWISE;\n    if (cross_product(v1, v2) < -eps) return ccw_t::CLOCKWISE;\n    if (inner_product(v1, v2) < -eps) return ccw_t::ONLINE_BACK;\n    if (v1.length2() < v2.length2()) return ccw_t::ONLINE_FRONT;\n    return ccw_t::ON_SEGMENT;\n  }\n\n  /* line */\n  struct Line {\n    Point p1, p2;\n    Line() {}\n    Line(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n    Line(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n    Vector to_vector() const { return p2 - p1; }\n    Point projection(const Point& p) const {\n      Vector v12(p2 - p1);\n      double det = v12.length2();\n      double a = v12.y * p1.x - v12.x * p1.y, b = v12.y * p.y + v12.x * p.x;\n      double x = v12.y * a + v12.x * b, y = v12.y * b - v12.x * a;\n      return Point(x / det, y / det);\n    }\n    Point reflection(const Point& p) const {\n      Point proj = projection(p);\n      return proj + proj - p;\n    }\n    double distance(const Point& p) const {\n      return projection(p).distance(p);\n    }\n    bool is_parallel(const Line& l) const {\n      return abs(cross_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    bool is_orthogonal(const Line& l) const {\n      return abs(inner_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    Point intersection(const Line& l) const {\n      Point p0(this->p1), p1(this->p2), p2(l.p1), p3(l.p2);\n      Vector v01(p1 - p0), v23(p3 - p2);\n      double det = cross_product(v01, v23);\n      double a = v01.y * p0.x - v01.x * p0.y, b = v23.y * p2.x - v23.x * p2.y;\n      double x = v01.x * b - v23.x * a;\n      double y = v01.y * b - v23.y * a;\n      return Point(x / det, y / det);\n    }\n    friend std::ostream& operator<<(std::ostream& o, const Line& l) {\n      o << '(' << l.p1 << ',' << l.p2 << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Line& l) {\n      i >> l.p1 >> l.p2;\n      return i;\n    }\n  };\n\n  /* segment */\n  using Segment = Line;\n  bool is_intersect_segments(const Segment& s1, const Segment& s2) {\n    Vector v2 = s2.to_vector(), p1(s1.p1 - s2.p1), p2(s1.p2 - s2.p1);\n    if (cross_product(v2, p1) * cross_product(v2, p2) > eps) return false;\n    Vector v1 = s1.to_vector(), p3(s2.p1 - s1.p1), p4(s2.p2 - s1.p1);\n    if (cross_product(v1, p3) * cross_product(v1, p4) > eps) return false;\n    if (inner_product(s2.p1 - s1.p1, s2.p2 - s1.p1) < eps) return true;\n    if (inner_product(s2.p1 - s1.p2, s2.p2 - s1.p2) < eps) return true;\n    if (inner_product(s1.p1 - s2.p1, s1.p2 - s2.p1) < eps) return true;\n    if (inner_product(s1.p1 - s2.p2, s1.p2 - s2.p2) < eps) return true;\n    return false;\n  }\n  bool is_intersect_segment_line(const Segment s, const Line& l) {\n    if (l.is_parallel(s)) return false;\n    Vector vst = l.to_vector();\n    Point ps = l.p1;\n    return cross_product(vst, s.p1 - ps) * cross_product(vst, s.p2 - ps) < eps;\n  }\n  double segment_distance(const Segment& s, const Point& p) {\n    Point proj = s.projection(p);\n    if (ccw(s.p1, proj, s.p2) == ccw_t::ONLINE_FRONT) return p.distance(proj);\n    return min(p.distance(s.p1), p.distance(s.p2));\n  }\n  double segment_distance(const Segment& s1, const Segment& s2) {\n    if (is_intersect_segments(s1, s2)) return 0.0;\n    return min({\n      segment_distance(s1, s2.p1), segment_distance(s1, s2.p2),\n      segment_distance(s2, s1.p1), segment_distance(s2, s1.p2)\n      });\n  }\n\n  /* polygon */\n  using Polygon = std::vector<Point>;\n  double area(const Polygon& poly) {\n    if (poly.size() <= 2) return 0;\n    Point b(DBL_MAX, DBL_MAX);\n    for (const Point& p : poly) {\n      b.x = min(b.x, p.x); b.y = min(b.y, p.y);\n    }\n    b.x -= 1.0; b.y -= 1.0;\n    int n = (int)poly.size();\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n      area += cross_product(poly[i] - b, poly[(i + 1) % n] - b) * 0.5;\n    }\n    return area;\n  }\n  bool is_convex(const Polygon& poly) {\n    if (poly.size() <= 2) return false;\n    int n = (int)poly.size();\n    for (int i = 0; i < n; i++) {\n      if (ccw(poly[i], poly[(i + 1) % n], poly[(i + 2) % n]) == ccw_t::CLOCKWISE) {\n        return false;\n      }\n    }\n    return true;\n  }\n  enum struct poly_t {\n    EXTERNAL = 0,\n    ON_SEGMENT = 1,\n    INTERNAL = 2\n  };\n  poly_t is_inside(const Point& p, const Polygon& poly) {\n    int n = (int)poly.size();\n    double rad = 0.0;\n    for (int i = 0; i < n; i++) {\n      const Point& p1 = poly[i];\n      const Point& p2 = poly[(i + 1) % n];\n      double d1 = p.distance(p1), d2 = p.distance(p2);\n      if (segment_distance(Segment(p1, p2), p) < eps) return poly_t::ON_SEGMENT;\n      Vector v1(p1 - p), v2(p2 - p);\n      double r = atan2(cross_product(v1, v2), inner_product(v1, v2));\n      rad += r;\n    }\n    return rad < eps ? poly_t::EXTERNAL : poly_t::INTERNAL;\n  }\n\n  /* convex hull */\n  using Hull = Polygon;\n  Hull convex_hull(std::vector<Point> points, bool strict = true) {\n    double e = strict ? eps : -eps;\n    std::sort(points.begin(), points.end());\n    int n = (int)points.size(), k = 0;\n    Hull hull(2 * n);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    hull.resize(k - 1);\n    return hull;\n  }\n  double convex_diameter(const Hull& hull) {\n    int n = (int)hull.size();\n    if (n == 2) return hull.front().distance(hull.back());\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n      if (hull[k] < hull[i]) i = k;\n      if (hull[j] < hull[k]) j = k;\n    }\n    double d = 0.0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n      d = max(d, hull[i].distance(hull[j]));\n      if (cross_product(hull[(i + 1) % n] - hull[i], hull[(j + 1) % n] - hull[j]) < 0.0) {\n        i = (i + 1) % n;\n      }\n      else {\n        j = (j + 1) % n;\n      }\n    }\n    return d;\n  }\n  std::pair<Hull, Hull> convex_cut(const Hull& hull, const Line& l) {\n    int n = (int)hull.size(), i = -1, j = -1;\n    Point pi, pj;\n    for (int k = 0; k < n; k++) {\n      Segment s(hull[k], hull[(k + 1) % n]);\n      if (is_intersect_segment_line(s, l)) {\n        if (cross_product(l.to_vector(), s.to_vector()) < 0) {\n          i = k;\n          pi = l.intersection(s);\n        }\n        else {\n          j = k;\n          pj = l.intersection(s);\n        }\n      }\n    }\n    if (i < 0) {\n      // no cut: 左か右か判定\n      if (cross_product(l.to_vector(), hull.front() - l.p1) > 0) {\n        // left\n        return std::make_pair(hull, Hull());\n      }\n      else {\n        return std::make_pair(Hull(), hull);\n      }\n    }\n    Hull left({ pi, pj }), right({ pj, pi });\n    for (int k = (j + 1) % n, e = (i + 1) % n; k != e; k = (k + 1) % n) {\n      if(left.back().distance(hull[k]) > eps) left.push_back(hull[k]);\n    }\n    for (int k = (i + 1) % n, e = (j + 1) % n; k != e; k = (k + 1) % n) {\n      if(right.back().distance(hull[k]) > eps) right.push_back(hull[k]);\n    }\n    if (left.front().distance(left.back()) < eps) left.pop_back();\n    if (right.front().distance(right.back()) < eps) right.pop_back();\n    return std::make_pair(left, right);\n  }\n\n  /* closest pair : 逐次構成法 */\n  double closest_pair_incremental(std::vector<Point> ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // shuffle\n    int n = (int)ps.size();\n    for (int i = n - 1; i >= 1; i--) {\n      int j = (int)rnd(i);\n      std::swap(ps[i], ps[j]);\n    }\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x);\n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid generator\n    double delta = ps[0].distance(ps[1]);\n    auto generate_grid = [&](int sz, double delta) {\n      ll h = (int)ceil((y_max - y_min) / delta);\n      ll w = (int)ceil((x_max - x_min) / delta);\n      Grid grid;\n      for (int i = 0; i < sz; i++) {\n        double x = ps[i].x, y = ps[i].y;\n        ll ix = (ll)floor((x - x_min) / delta);\n        ll iy = (ll)floor((y - y_min) / delta);\n        grid[iy * w + ix].push_back(ps[i]);\n      }\n      return std::make_tuple(h, w, std::move(grid)); \n    };\n    // 幅 delta のグリッド構築\n    ll h, w;\n    Grid grid;\n    tie(h, w, grid) = generate_grid(2, delta);\n    for (int k = 2; k < n; k++) {\n      // d_i = d(p_i, S_i) を計算\n      double x = ps[k].x, y = ps[k].y;\n      ll ix = (ll)floor((x - x_min) / delta);\n      ll iy = (ll)floor((y - y_min) / delta);\n      // 近傍のみ調べればいい\n      double ndelta = delta;\n      for (ll i = max(iy - 1, 0LL); i <= min(iy + 1, h - 1); i++) {\n        for (ll j = max(ix - 1, 0LL); j <= min(ix + 1, w - 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            ndelta = std::min(ndelta, ps[k].distance(p));\n          }\n        }\n      }\n      if (ndelta < delta) {\n        // update grid\n        delta = ndelta;\n        tie(h, w, grid) = generate_grid(k + 1, delta);\n      }\n      else {\n        // insert point\n        grid[iy * w + ix].push_back(ps[k]);\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair : 篩法 */\n  double closest_pair_sieve(const std::vector<Point>& ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // init grid\n    Grid grid;\n    for (const Point& p : ps) grid[0].push_back(p);\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x); \n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid updator\n    auto update_grid = [&](const Grid& grid, double delta, bool erase_mode = true) {\n      int erased = 0;\n      ll h = (ll)ceil((y_max - y_min) / delta);\n      ll w = (ll)ceil((x_max - x_min) / delta);\n      Grid ngrid;\n      for (auto it = grid.begin(); it != grid.end(); ++it) {\n        for (const Point& p : it->second) {\n          ll ix = (ll)floor((p.x - x_min) / delta);\n          ll iy = (ll)floor((p.y - y_min) / delta);\n          ngrid[iy * w + ix].push_back(p);\n        }\n      }\n      if (erase_mode) {\n        // 孤立点の除去\n        auto it = ngrid.begin();\n        while (it != ngrid.end()) {\n          if (it->second.size() >= 2) { ++it; continue; }\n          ll pos = it->first, iy = pos / w, ix = pos % w;\n          // 8 近傍に点がなければ、削除する\n          bool found = [&]() {\n            for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n              for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n                if (i == iy && j == ix) continue;\n                if (ngrid.count(i * w + j)) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          } ();\n          if (!found) {\n            it = ngrid.erase(ngrid.find(pos));\n            erased++;\n          }\n          else ++it;\n        }\n      }\n      return make_tuple(erased, h, w, std::move(ngrid));\n    };\n    // elimination phase\n    int n = (int)ps.size(), erased;\n    ll h = 1, w = 1;\n    double delta = DBL_MAX;\n    while (n) {\n      // ランダムに点を選ぶ\n      auto it = std::next(grid.begin(), rnd((int)grid.size()));\n      ll pos = it->first;\n      auto& cands = it->second;\n      int i = rnd((int)cands.size());\n      Point selected = cands[i];\n      // 一旦消す\n      cands.erase(cands.begin() + i);\n      // pos 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            delta = min(delta, selected.distance(p));\n          }\n        }\n      }\n      // 元に戻す\n      cands.push_back(selected);\n      // 幅 delta / 8 で grid を作成\n      delta /= 8;\n      tie(erased, h, w, grid) = update_grid(grid, delta);\n      n -= erased;\n    }\n    delta *= 8;\n    // 最終的な delta で最近点対探索\n    // reset grid\n    for (const Point& p : ps) grid[0].push_back(p);\n    tie(erased, h, w, grid) = update_grid(grid, delta, false);\n    // find closest points\n    delta = DBL_MAX;\n    for (auto it = grid.begin(); it != grid.end(); ++it) {\n      ll pos = it->first;\n      auto& cands = it->second;\n      // 自身の近傍\n      for (int i = 0; i < (int)cands.size() - 1; i++) {\n        for (int j = i + 1; j < cands.size(); j++) {\n          delta = min(delta, cands[i].distance(cands[j]));\n        }\n      }\n      // 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (i == iy && j == ix) continue;\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p1 : cands) {\n            for (const auto& p2 : grid[i * w + j]) {\n              delta = min(delta, p1.distance(p2));\n            }\n          }\n        }\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair: 分割統治法 */\n  double closest_pair_impl(std::vector<Point>& ps, int l, int r) {\n    static const auto cmp_y = [](const Point& a, const Point& b) { return a.y < b.y; };\n    int n = r - l, m = (l + r) >> 1;\n    if (n <= 1) return DBL_MAX;\n    double x = ps[m].x;\n    double d = min(closest_pair_impl(ps, l, m), closest_pair_impl(ps, m, r));\n    std::inplace_merge(ps.begin() + l, ps.begin() + m, ps.begin() + r, cmp_y);\n    std::vector<Point> b;\n    for (int i = 0; i < n; i++) {\n      if (abs(ps[i + l].x - x) >= d) continue;\n      for (int j = (int)b.size() - 1; j >= 0; j--) {\n        double dx = ps[i + l].x - b[j].x, dy = ps[i + l].y - b[j].y;\n        if (dy >= d) break;\n        d = min(d, sqrt(dx * dx + dy * dy));\n      }\n      b.push_back(ps[i + l]);\n    }\n    return d;\n  }\n  double closest_pair(std::vector<Point> ps) {\n    std::sort(ps.begin(), ps.end());\n    return closest_pair_impl(ps, 0, (int)ps.size());\n  }\n}\n\n// T have +-*/ and 0\ntemplate<class T> class BIT {\npublic:\n  vector<T> dat;\n  int N;\n\n  BIT() {}\n  BIT(int N) : N(N) { dat.assign(N, 0); }\n  // sum [0,c)\n  T sum(int i) {\n    T ret = 0;\n    for (--i; i >= 0; i = (i & (i + 1)) - 1) ret += dat[i];\n    return ret;\n  }\n  // sum [c,j1)\n  T sum(int i1, int i2) { return sum(i2) - sum(i1); }\n  T at(int i) { return sum(i, i + 1); }\n  // add x to c\n  void add(int i, T x) { for (; i < N; i |= i + 1) dat[i] += x; }\n};\n\nconstexpr int RIGHT = 0;\nconstexpr int DOWN = 1;\nconstexpr int LEFT = 2;\nstruct L {\n  int x, y, len, dir;\n  L() {}\n  L(int x, int y, int len, int dir) : x(x), y(y), len(len), dir(dir) {}\n  bool operator<(const L& l) const {\n    if (x == l.x) return dir < l.dir;\n    return x < l.x;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using namespace geom;\n\n  int n;\n  cin >> n;\n  vector<int> x1(n), y1(n), x2(n), y2(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    if (x1[i] > x2[i]) swap(x1[i], x2[i]);\n    if (y1[i] > y2[i]) swap(y1[i], y2[i]);\n  }\n\n  map<int, int> cmp_x, cmp_y;\n  for (int x : x1) cmp_x[x] = -1;\n  for (int x : x2) cmp_x[x] = -1;\n  for (int y : y1) cmp_y[y] = -1;\n  for (int y : y2) cmp_y[y] = -1;\n  int c = 0;\n  for (auto& e : cmp_x) e.second = c++;\n  c = 0;\n  for (auto& e : cmp_y) e.second = c++;\n\n  for (int i = 0; i < n; i++) {\n    x1[i] = cmp_x[x1[i]];\n    x2[i] = cmp_x[x2[i]];\n    y1[i] = cmp_y[y1[i]];\n    y2[i] = cmp_y[y2[i]];\n  }\n\n  vector<L> ls;\n  for (int i = 0; i < n; i++) {\n    if (x1[i] == x2[i]) {\n      ls.emplace_back(x1[i], y1[i], y2[i] - y1[i], DOWN);\n    }\n    else {\n      ls.emplace_back(x1[i], y1[i], x2[i] - x1[i], RIGHT);\n      ls.emplace_back(x2[i], y2[i], x2[i] - x1[i], LEFT);\n    }\n  }\n\n  sort(ls.begin(), ls.end());\n\n  int ans = 0;\n  BIT<int> bit(cmp_y.size() + 2);\n  for (const L& l : ls) {\n    switch (l.dir) {\n    case RIGHT:\n      bit.add(l.y, 1);\n      break;\n    case DOWN:\n      ans += bit.sum(l.y, l.y + l.len + 1);\n      break;\n    case LEFT:\n      bit.add(l.y, -1);\n      break;\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n \n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n*/\n \n#define EPS 0.0000000001\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n \nclass Point {\n    public:\n    double x,y;\n \n    Point(double x=0, double y=0): x(x), y(y) {}\n \n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n \n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n \n    bool operator < (const Point &p) const {\n        return x != p.x? x<p.x : y<p.y;\n    }\n \n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n \ntypedef Point Vector;\n\n// 円\nclass Circle {\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 多角形\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n \n// 内積\ndouble dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n \n// 外積\ndouble cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n}\n \n// ベクトルの直交判定\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\n \n// ベクトルの平行判定\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a,b), 0.0);\n}\n \n// 射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2-s.p1;\n    Vector hypo = p-s.p1;\n    double t = dot(hypo, base)/base.norm();\n    return s.p1 + base*t;\n}\n\n// 反射\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p)-p)*2;\n}\n\n// 反時計回りCCW\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1-p0;\n    Vector b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4 ,p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2点間の距離\ndouble getDistance(Point a, Point b){\n    Vector v = b-a;\n    return v.abs();\n}\n\n// 点と直線の距離\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\n// 点と線分の距離\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0) return (p-s.p2).abs();\n    return getDistanceLP(s, p); \n}\n\n// 線分と線分の距離\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 線分と線分の交点\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n// 円と直線の交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    //必要に応じて交点を持つかチェックして\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r*c.r - (pr - c.c).norm());\n    return make_pair(pr + e*base, pr - e*base);\n}\n\n// 円と円の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r)*a, sin(r)*a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    //必要に応じて交点を持つかチェックして\n    double d = (c1.c - c2.c).abs();\n    double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\n// 多角形gに点pが含まれるか\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i=0; i<n; i++){\n        Point a = g[i]-p, b = g[(i+1)%n]-p;\n        if(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1; // 辺上\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n    }\n\n    if(x) return 2; // 2はcontain 0はnot contain\n    else return 0;\n}\n\n// アンドリューのアルゴリズム\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n    // xが小さいものから2つuに追加\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    // xが大きいものから2つlに追加\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    // 凸包の上部を生成\n    for( int i=2; i<s.size(); i++ ){\n        for( int n=u.size(); n>=2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n-- ){ // 辺上の点を含めない場合は　!= CLOCKWIZE に置き換える\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    // 凸包の下部を生成\n    for( int i=s.size()-3; i>=0; i--){\n        for( int n=l.size(); n>=2 && ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; n-- ){ // 辺上の点を含めない場合は　!= CLOCKWIZE に置き換える\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    // 時計回りになるように凸包の点の列を生成\n    reverse(l.begin(), l.end());\n    for( int i=u.size()-2; i>=1; i-- ) l.push_back(u[i]);\n\n    return l;\n}\n\n// 平面捜査で線分の交差を検出するプログラム\n// 端点の種類\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\n    public:\n    Point p;\n    int seg, st; // 入力線分のID、端点の種類\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        // y座標が小さい順に整列\n        if(p.y == ep.p.y){\n            return st < ep.st; // yが同一の場合は、下端点、左端点、右端点、上端点の順に並べる\n        } else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2*100000]; // 端点のリスト\n\n// 線分交差問題：マンハッタン幾何\nint manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n\n    for(int i=0, k=0; i<n; i++){\n        // 端点p1, p2が左下を基準に並ぶように調整\n        if(S[i].p1.y == S[i].p2.y){\n            if(S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if(S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n        if(S[i].p1.y == S[i].p2.y){\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2*n));\n\n    set<int> BT;           // 二分探索木\n    BT.insert(1000000001); // 番兵\n    int cnt = 0;\n\n    for(int i=0; i<2*n; i++){\n        if(EP[i].st == TOP){\n            BT.erase(EP[i].p.x);\n        }\n        else if(EP[i].st == BOTTOM){\n            BT.insert(EP[i].p.x);\n        }\n        else if( EP[i].st == LEFT){\n            auto b = BT.lower_bound(S[EP[i].seg].p1.x);\n            auto e = BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(){\n    int n; cin >> n;\n    vector<Segment> S;\n    for(int i=0; i<n; i++){\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n        Point p1(x1, y1), p2(x2, y2);\n        Segment s;\n        s.p1 = p1, s.p2 = p2;\n        S.push_back(s);\n    }\n\n    cout << manhattanIntersection(S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point() {};\n  Point(double x, double y): x(x), y(y) {}\n\n  Point operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n  Point operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double d) { return Point(d * x, d * y); }\n  Point operator / (double d) { return Point(x / d, y / d); }\n\n  bool operator < (const Point &p) const {\n    return (x != p.x ? x < p.x : y < p.y);\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend ostream& operator << (ostream &os, Point &p) {\n    return os << \"Point(\" << p.x << \", \" << p.y << \")\";\n  }\n};\n\nclass Segment {\npublic:\n  Point p1, p2;\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n  friend ostream& operator << (ostream &os, Segment &seg) {\n    return os << \"<\" << seg.p1 << \", \" << seg.p2 << \">\";\n  }\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EP {\npublic:\n  Point p;\n  int id, st;\n  EP() {}\n  EP(Point p, int id, int st): p(p), id(id), st(st) {}\n  bool operator < (const EP &ep) const {\n    return (p.y == ep.p.y ? p.x < ep.p.x : p.y < ep.p.y);\n  }\n};\n\nint manhattan_geo(vector<Segment> s) {\n  vector<EP> EPs(s.size() * 2);\n\n  for (int i = 0, k = 0; i < s.size(); i++) {\n    if (s[i].p1.y == s[i].p2.y) {\n      if (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n    } else if (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\n    if (s[i].p1.y == s[i].p2.y) {\n      EPs[k++] = EP(s[i].p1, i, LEFT);\n      EPs[k++] = EP(s[i].p2, i, RIGHT);\n    } else {\n      EPs[k++] = EP(s[i].p1, i, BOTTOM);\n      EPs[k++] = EP(s[i].p2, i, TOP);\n    }\n  }\n\n  sort(EPs.begin(), EPs.end());\n\n  set<int> bin_tree;\n  int cnt = 0;\n\n  for (int i = 0; i < EPs.size(); i++) {\n    if (EPs[i].st == TOP) {\n      bin_tree.erase(EPs[i].p.x);\n    } else if (EPs[i].st == BOTTOM) {\n      bin_tree.insert(EPs[i].p.x);\n    } else if (EPs[i].st == LEFT) {\n      set<int>::iterator b = bin_tree.lower_bound(s[EPs[i].id].p1.x);\n      set<int>::iterator e = bin_tree.lower_bound(s[EPs[i].id].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  int n; cin >> n;\n  vector<Segment> s;\n\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    s.push_back(Segment(Point(x1, y1), Point(x2, y2)));\n  }\n\n  cout << manhattan_geo(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals( A, B ) (fabs((A) - (B)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n    Point( double x = 0, double y = 0 ): x(x), y(y) {}\n    \n    Point operator + ( Point p ) { return Point( x + p.x, y + p.y ); }\n    Point operator - ( Point p ) { return Point( x - p.x, y - p.y ); }\n    Point operator * ( double a ) { return Point( a * x, a * y ); }\n    Point operator / ( double a ) { return Point( x / a, y / a ); }\n\n    double abs() { return sqrt( norm() ); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn ( x != p.x ) ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn equals( x, p.x ) && equals( y, p.y ); \n    }\n\n    double dot( Point a ) { return x * a.x + y * a.y; }\n    double cross( Point a ) { return x * a.y - y * a.x; }\n    double distance( Point a ) {\n\treturn (*this - a).abs();\n    }\n    double arg() {\n\treturn atan2( y, x );\n    }\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\nint contains( Polygon poly, Point p ) {\n    int n = poly.size();\n    int count = 0;\n    for ( int i = 0; i < n; i++ ) {\n\tVector a = poly[i] - p;\n\tVector b = poly[ ( i + 1 ) % n ] - p;\n\n\t// ???????????????\n\tif ( abs( a.cross( b ) ) < EPS && a.dot( b ) < EPS ) {\n\t    return 1;\n\t}\n\t// a.y???b.y??\\?????????????????????\n\tif ( a.y > b.y ) {\n\t    Vector tmp = a; a = b; b = tmp;\n\t}\n\t// ??£?????????????????´????????????????????´???\n\tif ( a.y < EPS && b.y > EPS && a.cross( b ) > EPS ) {\n\t    count++;\n\t}\n    }\n\n    return ( count % 2 ) ? 2 : 0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Line {\npublic:\n    Point p1, p2;\n    Line( Point p1 = Point(), Point p2 = Point() ): p1(p1), p2(p2){}\n    // ?????´????????????( cos = 0 )\n    bool isOrthogonal( Line a ) {\n\treturn equals( 0.0, (p1 - p2).dot( a.p1 - a.p2 ) );\n    }\n    // ??????????????????( sin = 0 )\n    bool isParallel( Line a ) {\n\treturn equals( 0.0, (p1 - p2).cross( a.p1 - a.p2 ) );\n    }\n\n    Point projection( Point p ) {\n\tVector v12 = p2 - p1;\n\tdouble r = v12.dot( p - p1 ) / v12.norm();\n\treturn p1 + v12 * r;\n    }\n\n    Point reflection( Point p ) {\n\treturn p + ( projection( p ) - p ) * 2.0;\n    }\n\n    double distance( Point p ) {\n\tVector v12 = this->p2 -this->p1;\n\tVector v10 = p - this->p1;\n\t\n\treturn abs( v12.cross( v10 ) / v12.abs() );\n    }\n\n    double distanceSP( Point p ) {\n\tif ( (p - this->p1).dot( this->p2 - this->p1 ) < 0.0 ) {\n\t    return this->p1.distance( p );\n\t} else if ( (p - this->p2).dot( this->p1 - this->p2 ) < 0.0 ) {\n\t    return this->p2.distance( p );\n\t}\n\telse {\n\t    return distance( p );\n\t}\n    }\n\n    int ccw( Point p ) {\n\tVector a = p2 - p1;\n\tVector b = p - p1;\n\tif ( a.cross( b ) > EPS ) return COUNTER_CLOCKWISE;\n\telse if ( a.cross( b ) < -EPS ) return CLOCKWISE;\n\telse if ( a.dot( b ) < -EPS ) return ONLINE_BACK;\n\telse if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\telse return ON_SEGMENT;\n    }\n\n    bool intersect( Line l ) {\n\treturn ( ( ccw( l.p1 ) * ccw( l.p2 ) <= 0 && l.ccw( p1 ) * l.ccw( p2 ) <= 0 ) );\n    }\n\n    Point crossPoint( Line l ) {\n\tVector base = p2 - p1;\n\tVector v1 = l.p1 - p1;\n\tVector v2 = l.p2 - p1;\n\tdouble d1 = base.cross( v1 );\n\tdouble d2 = base.cross( v2 );\t\n\tdouble t = d1 / ( d1 + d2 );\n\n\treturn l.p1 + ( l.p2 - l.p1 ) * t;\n    }\n};\n\ntypedef Line Segment;\n\ntypedef enum {\n    EP_BOTTOM,\n    EP_LEFT,\n    EP_RIGHT,\n    EP_TOP,\n} PointType;\n\nclass EndPoint {\npublic:\n    Point p;\n    int id;\n    PointType type;\n    EndPoint() {}\n    EndPoint( Point p, int id, PointType type ): p(p), id(id), type(type) {}\n\n    bool operator < ( const EndPoint &ep ) const {\n\tif ( p.y != ep.p.y ) return ( p.y < ep.p.y );\n\telse return ( type < ep.type );\n    }\n};\n\n#define MAX_N (100010)\n\nSegment S[MAX_N];\n\nEndPoint EP[MAX_N << 1];\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    \n    for ( int i = 0; i < n; i++ ) {\n\tPoint p1, p2;\n\tscanf(\"%lf %lf %lf %lf\", &p1.x, &p1.y, &p2.x, &p2.y);\n\tS[i] = ( p1 < p2 ) ? Segment( p1, p2 ) : Segment( p2, p1 );\n\tif ( p1.y == p2.y ) {\t// ?°´???\n\t    EndPoint ep0 = EndPoint( p1, i, EP_LEFT );\n\t    EndPoint ep1 = EndPoint( p2, i, EP_RIGHT );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n\telse {\t\t\t// ?????´\n\t    EndPoint ep0 = EndPoint( p1, i, EP_BOTTOM );\n\t    EndPoint ep1 = EndPoint( p2, i, EP_TOP );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n    }\n    \n    sort(EP, EP + (n << 1));\n\n    set<int> T;\t\t// ????????¢?´¢??¨\n    int ans = 0;\n    for ( int i = 0; i < (n<<1); i++ ) {\n\tEndPoint ep = EP[i];\n\tif ( ep.type == EP_BOTTOM ) {\n\t    T.insert( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_TOP ) {\n\t    T.erase( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_LEFT ) {\n\t    Segment s = S[ep.id];\n\t    set<int>::iterator l = lower_bound( T.begin(), T.end(), (int)s.p1.x );\n\t    set<int>::iterator u = upper_bound( T.begin(), T.end(), (int)s.p2.x );\n\t    ans += distance( l, u );\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint N_BIT;\n\nvoid add(int i, int x)\n{\n\twhile (i <= N_BIT)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tN_BIT = table.size();\n\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nstruct Seg{\n    int x1, x2, y1, y2;\n    Seg(int x1, int y1, int x2, int y2) :x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nbool yparaAsc( const Seg& left, const Seg& right ) {\n    return left.x1 != right.x1 ? left.x1 < right.x1 : left.y1 < right.y1;\n};\n\nstruct Time{\n    int x; //x??§?¨?\n    int y; //y??§?¨?\n    int act; //?????????????????????0 ??§?????????1 ??§?????????\n    Time(int x, int y, int act) : x(x), y(y), act(act) {}\n\n    bool operator<( const Time& right ) const {\n        return x != right.x ? x < right.x : act < right.act;\n    }\n};\n\nint segmentIntersection(vector<Seg> &input){\n    int n = input.size();\n    vector<Seg> xpara, ypara;\n    for (int i=0;i<n;i++){\n        Seg s = input[i];\n        if(s.x1 == s.x2) ypara.push_back(s);\n        if(s.y1 == s.y2) xpara.push_back(s);\n    }\n\n    sort(ypara.begin(), ypara.end(), yparaAsc);\n\n    /*\n    for (int i=0;i<ypara.size();i++){\n        cout << ypara[i].x1 << \" \" << ypara[i].y1 << \" \" << ypara[i].y2 << \" \" <<endl;\n    }\n    cout << endl;\n    */\n\n    vector<Time> Timeline;\n    for (int i=0;i<xpara.size();i++){\n        Seg s = xpara[i];\n        Time t1(s.x1, s.y1, 0), t2(s.x2, s.y1, 1);\n        Timeline.push_back(t1);\n        Timeline.push_back(t2);\n    }\n    sort(Timeline.begin(), Timeline.end());\n\n    /*\n    for (int i=0;i<Timeline.size();i++){\n        cout << Timeline[i].x << \" \" << Timeline[i].y << \" \"  << Timeline[i].act << \" \" <<endl;\n    }\n    cout << endl;\n    */\n    set<int> st;\n    int i=0;\n    int j=0;\n    int S=0;\n    while(1){\n        if(i >= ypara.size() && j >= Timeline.size()) break;\n\n        if(i >= ypara.size()){\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n            continue;\n        }\n\n        if(j >= Timeline.size()){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            cout << i << \" \" << j <<endl;\n            i++;\n            continue;\n        }\n\n        if((ypara[i].x1 < Timeline[j].x) || (ypara[i].x1 == Timeline[j].x && Timeline[j].act == 1)){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            /*\n            cout << i << \" \" << j <<endl;\n\n            set<int>::iterator it = st.begin();\n            while( it != st.end() )\n            {\n                cout << *it << \" \";\n                ++it;\n            }\n            cout << endl;\n            */\n            i++;\n        }else{\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n        }\n    }\n    return S;\n}\n\nint main(){\n    int n, x1, x2, y1, y2;\n    cin >> n;\n    vector<Seg> input;\n    for (int i=0;i<n;i++){\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n        Seg s(x1, y1, x2, y2);\n        input.push_back(s);\n    }\n\n    cout << segmentIntersection(input) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nnamespace {\n\ttypedef long long ll;\n\n\tstruct EndPoint\n\t{\n\t\tEndPoint(ll _x, pair<ll, ll> _y) : x(_x), y(_y) {}\n\t\tbool operator<(const EndPoint& rhs) const {\treturn x < rhs.x; }\n\n\t\tll x;\n\t\tpair<ll,ll> y;\n\t};\n}\n\nstatic int countIntersection(const vector<EndPoint>& X)\n{\n\tint num_int = 0;\n\tset<ll> Y;\n\tfor (size_t i = 0; i < X.size(); i++) {\n\t\tif (X[i].y.first == X[i].y.second) {\n\t\t\tauto r = Y.insert(X[i].y.first);\n\t\t\tif (!r.second) {\n\t\t\t\tY.erase(r.first);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnum_int += distance(Y.lower_bound(X[i].y.first), Y.lower_bound(X[i].y.second));\n\t\t}\n\t}\n\n\treturn num_int;\n}\n\nint main()\n{\n\tint n = 0;\n\tcin >> n;\n\n\tvector<EndPoint> X;\n\tfor (int i = 0; i < n; i++) {\n\t\tll x1, y1, x2, y2;\n\t\tscanf(\"%lld%lld%lld%lld\", &x1, &y1, &x2, &y2);\n\t\tif (y1 == y2) {\n\t\t\tX.push_back(EndPoint(min(x1, x2) * 4 - 1, make_pair(y1 * 4, y1 * 4)));\n\t\t\tX.push_back(EndPoint(max(x1, x2) * 4 + 1, make_pair(y1 * 4, y1 * 4)));\n\t\t}\n\t\telse {\n\t\t\tX.push_back(EndPoint(x1 * 4, make_pair(min(y1, y2) * 4 - 1, max(y1, y2) * 4 + 1)));\n\t\t}\n\t}\n\n\tsort(X.begin(), X.end());\n\tcout << countIntersection(X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\ntypedef complex<double> Point, Vector;\ntypedef pair<Point, Point> Segment, Line;\ntypedef vector<Point> Polygon;\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n// 平面走査による線分交差\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nstruct EndPoint{\n    Point p;\n    int seg, st; // 入力線分のID, 端点の種類\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const{\n        // y 座標が小さい順に整列\n        if(p.Y == ep.p.Y){\n            // y が同一の場合は、下端点、左端点、右端点、上端点の順に並べる\n            return st < ep.st;\n        }\n        else{\n            return p.Y < ep.p.Y;\n        }\n    }\n};\n\n// 端点のリスト\nEndPoint EP[2 * 100000];\n\n// 線分交差問題: マンハッタン幾何\nint manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n\n    for(int i=0, k=0; i<n; i++){\n        // 端点 p1, p2 が左下を基準に並ぶように調整\n        if(S[i].first.Y == S[i].second.Y){\n            if(S[i].first.X > S[i].second.X){\n                swap(S[i].first, S[i].second);\n            }\n        }\n        else if(S[i].first.Y > S[i].second.Y){\n            swap(S[i].first, S[i].second);\n        }\n\n        if(S[i].first.Y == S[i].second.Y){\n            // 水平線分を端点リストに追加\n            EP[k++] = EndPoint(S[i].first, i, LEFT);\n            EP[k++] = EndPoint(S[i].second, i, RIGHT);\n        }\n        else{\n            EP[k++] = EndPoint(S[i].first, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].second, i, TOP);\n        }\n    }\n\n    // 端点の y 座標に関して昇順に整列\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n\n    for(int i=0; i<2*n; i++){\n        if(EP[i].st == TOP){\n            // 上端点を削除\n            BT.erase(EP[i].p.X);\n        }\n        else if(EP[i].st == BOTTOM){\n            // 下端点を追加\n            BT.insert(EP[i].p.X);\n        }\n        else if(EP[i].st == LEFT){\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].first.X);\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].second.X);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(){\n    int n; cin>>n;\n    vector<Segment> seg;\n    while(n--){\n        double x1, y1, x2, y2; cin>>x1>>y1>>x2>>y2;\n        seg.emplace_back(Point(x1, y1), Point(x2, y2));\n    }\n\n    cout << manhattanIntersection(seg) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\t//if (y1 < y2) add(x1, 1);\n\t\t\t//if (y1 > y2) add(x1, -1);\n\t\t\t//if (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\n\t\t\tif (y1 < y2)\n\t\t\t{\n\t\t\t\ttate[x1]++;\n\t\t\t}\n\t\t\tif (y1 > y2)\n\t\t\t{\n\t\t\t\ttate[x1]--;\n\t\t\t}\n\n\t\t\tif (y1 == y2)\n\t\t\t{\n\t\t\t\tfor (int i = x1; i <= x2; i++)\n\t\t\t\t{\n\t\t\t\t\tans += tate[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nstruct IntL {\n    long long pos;\n    long long s;\n    long long t;\n};\n\nbool comp_intl(const IntL &a, const IntL &b) {\n    return a.pos < b.pos;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    vector<IntL> vx;\n    vector<IntL> vy;\n\n    for (int i = 0; i < N; i++) {\n        long long x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 == x2) {\n            IntL intL = {x1, min(y1, y2), max(y1, y2)};\n            vy.push_back(intL);\n        }\n        if (y1 == y2) {\n            IntL intL = {y1, min(x1, x2), max(x1, x2)};\n            vx.push_back(intL);\n        }\n    }\n\n    sort(vy.begin(), vy.end(), comp_intl);\n\n    long long ans = 0;\n    for (auto li: vx) {\n        long long left = li.s;\n        long long right = li.t;\n        long long posY = li.pos;\n        auto s1 = lower_bound(vy.begin(), vy.end(), (IntL) {left, LONG_LONG_MIN, LONG_LONG_MIN}, comp_intl);\n        auto s2 = upper_bound(vy.begin(), vy.end(), (IntL) {right, LONG_LONG_MIN, LONG_LONG_MIN}, comp_intl);\n        for (auto i = s1; i != s2; i++) {\n            if (i->s <= posY && posY <= i->t) ans++;\n        }\n    }\n\n    cout << ans << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\nstruct RSQ{\n  int n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 0 index\n  void add(int i,int v){\n    i++;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  int sum(int i){\n    int res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b)\n  int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }\n};\n\nstruct Sweap{\n    int n;\n    vector<int>ye,ys,xs,xe;\n    vector<P2>vx,vy;\n    Sweap(vector<int>X1,vector<int>X2,vector<int>Y1,vector<int>Y2,int sz){\n        n=sz;xs=X1;xe=X2;ys=Y1;ye=Y2;\n        for(int i=0;i<n;i++){\n            if(ys[i]>ye[i])swap(ys[i],ye[i]);\n            if(xs[i]>xe[i])swap(xs[i],xe[i]);\n            if(xs[i]==xe[i]){\n                vx.push_back(P2(P(xs[i], 2), i));\n                vy.push_back(P2(P(ys[i], 1), i));\n                vy.push_back(P2(P(ye[i], 3), i));\n            }\n            else{\n                vx.push_back(P2(P(xs[i], 1), i));\n                vx.push_back(P2(P(xe[i], 3), i));\n                vy.push_back(P2(P(ys[i], 2), i));\n            }\n        }\n        sort(vx.begin(),vx.end());\n        sort(vy.begin(),vy.end());\n    }\n    void zaatsu(){\n        map<int,int>Mx,My;\n        vector<int>tvx,tvy;\n        for(int i=0;i<n;i++){\n            tvx.push_back(xs[i]);\n            tvx.push_back(xe[i]);\n            tvy.push_back(ys[i]);\n            tvy.push_back(ye[i]);\n        }\n        sort(tvx.begin(),tvx.end());\n        sort(tvy.begin(),tvy.end());\n        tvx.erase(unique(tvx.begin(),tvx.end()),tvx.end());\n        tvy.erase(unique(tvy.begin(),tvy.end()),tvy.end());\n        for(int i=0;i<tvx.size();i++)Mx[tvx[i]]=i;\n        for(int i=0;i<tvy.size();i++)My[tvy[i]]=i;\n        for(int i=0;i<n;i++){\n            xs[i]=Mx[xs[i]];\n            xe[i]=Mx[xe[i]];\n            ys[i]=My[ys[i]];\n            ye[i]=My[ye[i]];\n        }\n    }\n    int build(){\n        RSQ rsq;\n        int ans=0;\n        for(int i=0;i<vx.size();i++){\n            int id=vx[i].second;\n            int seed=vx[i].first.second;\n            if(seed==1){\n                rsq.add(vx[i].first.first,1);\n            }\n            else if(seed==3){\n                rsq.add(vx[i].first.first,-1);\n            }\n            else{\n                ans+=rsq.sum(ys[id],ye[id]+1);\n            }\n        }\n        return ans;\n    }\n};\n \n \nint main(){\n    int n;\n    scanf(\" %d\", &n);\n    vector<int>X1(n),X2(n),Y1(n),Y2(n);\n    for(int i = 0; i < n; i++)cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    Sweap s(X1,X2,Y1,Y2,n);\n    s.zaatsu();\n    cout<<s.build()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n//using P = pair<int, int>;\nusing namespace std;\n\nconst double eps = 1e-10;\n#define equals(a, b) (fabs((a)-(b)) < eps)\n\n// 点\nstruct Point\n{\n    double x, y;\n    Point(double x=0, double y=0): x(x), y(y) {}\n    double norm()\n    {\n        return x*x+y*y;\n    }\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n    Point operator+(const Point& p)const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator-(const Point& p)const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator*(const double k)const\n    {\n        return Point(x * k, y * k);\n    }\n    Point operator/(const double k)const\n    {\n        return Point(x / k, y / k);\n    }\n    bool operator<(const Point& p)const\n    {\n        if (x != p.x)\n        {\n            return x < p.x;\n        }\n        return y < p.y;\n    }\n    bool operator==(const Point& p)const\n    {\n        return fabs(x - p.x) < eps and fabs(y - p.y) < eps;\n    }\n};\n\nusing Vector = Point;\n\n// 内積\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n// 外積\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n// 線分\nstruct Segment\n{\n    Segment(Point a=Point(), Point b=Point()):p1(a), p2(b) {}\n    Point p1, p2;\n};\nusing Line = Segment;\n\n// 円\nclass Circle\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 多角形\nusing Polygon = vector<Point>;\n\n\n// ベクトルaとbの直行判定\n// Verify\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// ベクトルaとbの平行判定\n// Verify\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// 射影\n// verify\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\n// 反射\n// verify\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\n// ２点間の距離\ndouble getDistance(Point a, Point b) {\n    return (a-b).abs();\n}\n\n// 直線Lと、点Pの距離\n// verify\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2 - l.p1, p - l.p1) / Point(l.p2 - l.p1).abs());\n}\n\n// 線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n    if (dot(s.p1 - s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP((Line)s, p);\n}\n\n\n// 反時計回り\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// verify\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > eps) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -eps) return CLOCKWISE;\n    if (dot(a, b) < -eps) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// 線分の交差判定\n// verify\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n// verify\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 線分s1と線分s2の距離\n//verify\ndouble getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 線分の交点\n// verify\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\n// 円cと線分lの交点\n//verify\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    //assert(intersect(c, l)); ?\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n// 円と円の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\n// verify\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    // assert(intersect(c1, c2));\n    double d = (c1.c - c2.c).abs();\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2  * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t-a));\n}\n\n// 点の内包\n// IN 2, ON 1, OUT 0\n// verify\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if (abs(cross(a, b)) < eps and dot(a, b) < eps) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y < eps and eps < b.y and cross(a, b) > eps) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\n// 凸包\n// verify\nPolygon andrewScan(Polygon s) {\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for (int i = 2; i < s.size(); ++i) {\n        for (int n = u.size(); n >= 2 and ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; --n) {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for (int i = s.size()-3; i>=0; --i) {\n        for (int n = l.size(); n>=2 and ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; --n) {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n    return l;\n}\n\n// 平面走査\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n    bool operator<(const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        }else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; ++i) {\n        if (S[i].p1.y == S[i].p2.y) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001); // 番兵\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * n; ++i) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        }\n        else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        }\n        else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Segment> S;\n    rep(i, n) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n    cout << manhattanIntersection(S) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\n#define INF \n\nusing namespace std;\n\nenum Status {Start, Line, End};\n\nclass Event {\npublic:\n    int x;\n    Status st;\n    int ymin, ymax;\n    Event(int _x, Status _st, int _ymin, int _ymax) : x(_x), st(_st), ymin(_ymin), ymax(_ymax) {}\n    inline bool operator<(const Event& rhs) const\n    {\n        return x < rhs.x || (x == rhs.x && st < rhs.st) || (x == rhs.x && st == rhs.st && ymin < rhs.ymin);\n    }\n};\n\nint main()\n{\n    set<Event> zSet;\n\n    int n;\n    cin >> n;\n    int x1, y1, x2, y2;\n    for (int i = 0; i < n; ++i) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 == x2) {\n            if (y1 > y2) {\n                swap(y1, y2);\n            }\n            zSet.insert(Event(x1, Line, y1, y2));\n        } else if (y1 == y2) {\n            if (x1 > x2) {\n                swap(x1, x2);\n            }\n            zSet.insert(Event(x1, Start, y1, y2));\n            zSet.insert(Event(x2, End, y1, y2));\n        }\n    }\n\n    set<int> zCur;\n    int Res = 0;\n\n    for (auto it = zSet.begin(); it != zSet.end(); ++it) {\n        Event E = (*it);\n        switch (E.st) {\n        case Start:\n            zCur.insert(E.ymin);\n            break;\n        case Line:\n            Res += distance(zCur.lower_bound(E.ymin), zCur.upper_bound(E.ymax));\n            break;\n        case End:\n            zCur.erase(E.ymin);\n            break;\n        }\n    }\n\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int INF = 1111111111;\n\nclass Point {\npublic:\n    int x, y;\n\n    Point(int x = 0, int y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    int norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return x == p.x && y == p.y;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        } else {\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * MAX_N];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (S[i].p1.y == S[i].p2.y) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p2.y) {\n            swap(S[i].p1, S[i].p2);\n        }\n\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + 2*n);\n    set<int> BT;\n    BT.insert(INF);\n    int cnt = 0;\n\n    for (int i = 0; i < 2*n; i++) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        } else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        } else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void) {\n    int n; cin >> n;\n\n    int x1, y1, x2, y2;\n    vector<Segment> S;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n\n    cout << manhattanIntersection(S) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals( A, B ) (fabs((A) - (B)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n    Point( double x = 0, double y = 0 ): x(x), y(y) {}\n    \n    Point operator + ( Point p ) { return Point( x + p.x, y + p.y ); }\n    Point operator - ( Point p ) { return Point( x - p.x, y - p.y ); }\n    Point operator * ( double a ) { return Point( a * x, a * y ); }\n    Point operator / ( double a ) { return Point( x / a, y / a ); }\n\n    double abs() { return sqrt( norm() ); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn ( x != p.x ) ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn equals( x, p.x ) && equals( y, p.y ); \n    }\n\n    double dot( Point a ) { return x * a.x + y * a.y; }\n    double cross( Point a ) { return x * a.y - y * a.x; }\n    double distance( Point a ) {\n\treturn (*this - a).abs();\n    }\n    double arg() {\n\treturn atan2( y, x );\n    }\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\nint contains( Polygon poly, Point p ) {\n    int n = poly.size();\n    int count = 0;\n    for ( int i = 0; i < n; i++ ) {\n\tVector a = poly[i] - p;\n\tVector b = poly[ ( i + 1 ) % n ] - p;\n\n\t// ???????????????\n\tif ( abs( a.cross( b ) ) < EPS && a.dot( b ) < EPS ) {\n\t    return 1;\n\t}\n\t// a.y???b.y??\\?????????????????????\n\tif ( a.y > b.y ) {\n\t    Vector tmp = a; a = b; b = tmp;\n\t}\n\t// ??£?????????????????´????????????????????´???\n\tif ( a.y < EPS && b.y > EPS && a.cross( b ) > EPS ) {\n\t    count++;\n\t}\n    }\n\n    return ( count % 2 ) ? 2 : 0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Line {\npublic:\n    Point p1, p2;\n    Line( Point p1 = Point(), Point p2 = Point() ): p1(p1), p2(p2){}\n    // ?????´????????????( cos = 0 )\n    bool isOrthogonal( Line a ) {\n\treturn equals( 0.0, (p1 - p2).dot( a.p1 - a.p2 ) );\n    }\n    // ??????????????????( sin = 0 )\n    bool isParallel( Line a ) {\n\treturn equals( 0.0, (p1 - p2).cross( a.p1 - a.p2 ) );\n    }\n\n    Point projection( Point p ) {\n\tVector v12 = p2 - p1;\n\tdouble r = v12.dot( p - p1 ) / v12.norm();\n\treturn p1 + v12 * r;\n    }\n\n    Point reflection( Point p ) {\n\treturn p + ( projection( p ) - p ) * 2.0;\n    }\n\n    double distance( Point p ) {\n\tVector v12 = this->p2 -this->p1;\n\tVector v10 = p - this->p1;\n\t\n\treturn abs( v12.cross( v10 ) / v12.abs() );\n    }\n\n    double distanceSP( Point p ) {\n\tif ( (p - this->p1).dot( this->p2 - this->p1 ) < 0.0 ) {\n\t    return this->p1.distance( p );\n\t} else if ( (p - this->p2).dot( this->p1 - this->p2 ) < 0.0 ) {\n\t    return this->p2.distance( p );\n\t}\n\telse {\n\t    return distance( p );\n\t}\n    }\n\n    int ccw( Point p ) {\n\tVector a = p2 - p1;\n\tVector b = p - p1;\n\tif ( a.cross( b ) > EPS ) return COUNTER_CLOCKWISE;\n\telse if ( a.cross( b ) < -EPS ) return CLOCKWISE;\n\telse if ( a.dot( b ) < -EPS ) return ONLINE_BACK;\n\telse if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\telse return ON_SEGMENT;\n    }\n\n    bool intersect( Line l ) {\n\treturn ( ( ccw( l.p1 ) * ccw( l.p2 ) <= 0 && l.ccw( p1 ) * l.ccw( p2 ) <= 0 ) );\n    }\n\n    Point crossPoint( Line l ) {\n\tVector base = p2 - p1;\n\tVector v1 = l.p1 - p1;\n\tVector v2 = l.p2 - p1;\n\tdouble d1 = base.cross( v1 );\n\tdouble d2 = base.cross( v2 );\t\n\tdouble t = d1 / ( d1 + d2 );\n\n\treturn l.p1 + ( l.p2 - l.p1 ) * t;\n    }\n};\n\ntypedef Line Segment;\n\ntypedef enum {\n    EP_BOTTOM,\n    EP_LEFT,\n    EP_RIGHT,\n    EP_TOP,\n} PointType;\n\nclass EndPoint {\npublic:\n    Point p;\n    int id;\n    PointType type;\n    EndPoint() {}\n    EndPoint( Point p, int id, PointType type ): p(p), id(id), type(type) {}\n\n    bool operator < ( const EndPoint &ep ) const {\n\tif ( p.y != ep.p.y ) return ( p.y < ep.p.y );\n\telse return ( type < ep.type );\n    }\n};\n\n#define MAX_N (100010)\n\nSegment S[MAX_N];\n\nEndPoint EP[MAX_N << 1];\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    \n    for ( int i = 0; i < n; i++ ) {\n\tPoint p1, p2;\n\tscanf(\"%lf %lf %lf %lf\", &p1.x, &p1.y, &p2.x, &p2.y);\n\tS[i] = ( p1 < p2 ) ? Segment( p1, p2 ) : Segment( p2, p1 );\n\tif ( p1.y == p2.y ) {\t// ?°´???\n\t    EndPoint ep0 = EndPoint( S[i].p1, i, EP_LEFT );\n\t    EndPoint ep1 = EndPoint( S[i].p2, i, EP_RIGHT );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n\telse {\t\t\t// ?????´\n\t    EndPoint ep0 = EndPoint( S[i].p1, i, EP_BOTTOM );\n\t    EndPoint ep1 = EndPoint( S[i].p2, i, EP_TOP );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n    }\n    \n    sort(EP, EP + (n << 1));\n\n    set<int> T;\t\t// ????????¢?´¢??¨\n    T.insert( 1000000001 );\n    int ans = 0;\n    for ( int i = 0; i < (n<<1); i++ ) {\n\tEndPoint ep = EP[i];\n\tif ( ep.type == EP_BOTTOM ) {\n\t    T.insert( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_TOP ) {\n\t    T.erase( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_LEFT ) {\n\t    Segment s = S[ep.id];\n\t    set<int>::iterator l = lower_bound( T.begin(), T.end(), (int)s.p1.x );\n\t    set<int>::iterator u = upper_bound( T.begin(), T.end(), (int)s.p2.x );\n\t    ans += distance( l, u );\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF = 1000000001;\n\nint main(){\n  int n;\n  vector<pair<int,pii> > event;\n  set<int> list;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    int x1,y1,x2,y2;\n    scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n    if(y1==y2){\n      event.push_back(make_pair(min(x1,x2),pii(INF,y1)));\n      event.push_back(make_pair(max(x1,x2),pii(INF+1,y1)));\n    }else if(x1==x2){\n      event.push_back(make_pair(x1,pii(min(y1,y2),max(y1,y2))));\n    }\n  }\n  sort(event.begin(),event.end());\n  int ans = 0;\n  for(int i=0;i<event.size();i++){\n    int y1 = event[i].second.first, y2 = event[i].second.second;\n    if(y1>=INF){\n      if(y1==INF) list.insert(y2);\n      else list.erase(y2);\n    }else{\n      ans += distance(list.lower_bound(y1),list.lower_bound(y2));\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\n \nint bit[1000000],bit_n;\nint sum(int i){\n  int s=0;\n  while(i){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=bit_n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\n \nstruct data{\n  int time,type,l,r;\n  bool operator < (const data &p)const{\n    return (time==p.time?type<p.type:time<p.time);\n  }\n};\n// 1 | add\n// 2 - check\n// 3 | delete\n \nint n;\nvector<data> t;\nvector<int> X;\nmap<int,int> mapx;\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n    X.push_back(a);\n    X.push_back(c);\n    if(a==c){\n      t.push_back((data){min(b,d),1,a,a});\n      t.push_back((data){max(b,d),3,a,a});\n    }else{\n      t.push_back((data){b,2,min(a,c),max(a,c)});\n    }\n  }\n  sort(t.begin(),t.end());\n  sort(X.begin(),X.end());\n  int c=2;\n  for(int i=0;i<(int)X.size();i++)\n    if(i==0||X[i]!=X[i-1])\n      mapx[X[i]]=c++;\n   \n  bit_n=n*2+1;\n  long long ans = 0;\n  for(int i=0;i<(int)t.size();i++){\n    data d=t[i];\n    d.l=mapx[d.l],d.r=mapx[d.r];\n    if(d.type==1){\n      add(d.l,1);\n    }else if(d.type==2){\n      long long A=sum(d.r)-sum(d.l-1);\n      ans+=A;\n    }else if(d.type==3){\n      add(d.l,-1);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Segment Intersections: Manhattan Geometry\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    explicit Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble arg(Vector p) {\n    return atan2(p.y, p.x);\n}\n\nVector polar(double r, double theta) {\n    return Point(cos(theta) * r, sin(theta) * r);\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) {\n        return getDistancePP(s.p1, p);\n    } else if(dot(s.p1 - s.p2, p - s.p2) < 0) {\n        return getDistancePP(s.p2, p);\n    } else {\n        return getDistanceLP(s, p);\n    }\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if(intersect(s1, s2)) return 0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s1.p2 - s1.p1;\n    double d1 = fabs(cross(base, s2.p1 - s1.p1));\n    double d2 = fabs(cross(base, s2.p2 - s1.p1));\n    return s2.p1 + (s2.p2 - s2.p1) * (d1 / (d1 + d2));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l) {\n    Vector base = l.p2 - l.p1;\n    double d = getDistanceLP(l, c.c);\n    Point m = project(l, c.c);\n    double t = sqrt(pow(c.r, 2.0) - pow(d, 2.0)) / base.abs();\n    return make_pair(m + base * t, m - base * t);\n}\n\npair<Point, Point> getCrossPoint(Circle c1, Circle c2) {\n    double d = (c1.c - c2.c).abs();\n    double a = acos((pow(d, 2.0) + pow(c1.r, 2.0) - pow(c2.r, 2.0)) / (2 * d * c1.r));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nint contains(Polygon g, Point p) {\n    int n = int(g.size());\n    bool x = false;\n    for(int i = 0; i < n; i++) {\n        Vector a = g[i] - p;\n        Vector b = g[(i + 1) % n] - p;\n        if(fabs(cross(a, b)) < ESP && dot(a, b) < ESP) return 1;\n        if(a.y > b.y) swap(a, b);\n        if(cross(a, b) > ESP && a.y < ESP && b.y > ESP) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\nPolygon getConvexHull(vector<Point> s) {\n    if(s.size() < 3) return s;\n    Polygon u, l;\n    sort(s.begin(), s.end());\n\n    u.emplace_back(s[0]);\n    u.emplace_back(s[1]);\n    l.emplace_back(s[s.size() - 1]);\n    l.emplace_back(s[s.size() - 2]);\n\n    for(int i = 2; i < s.size(); i++) {\n        for(int n = int(u.size()); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = int(s.size()) - 3; i >= 0; i--) {\n        for(int n = int(l.size()); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.emplace_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = int(u.size()) - 2; i > 0; i--) l.emplace_back(u[i]);\n    return l;\n}\n\nenum {\n    BOTTOM = 0,\n    LEFT = 1,\n    RIGHT = 2,\n    TOP = 3\n};\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if(p.y == ep.p.y) {\n            return st < ep.st;\n        } else return p.y < ep.p.y;\n    }\n};\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = int(S.size());\n    EndPoint EP[100000 * 2];\n\n    for(int i = 0, k = 0; i < n; i++) {\n        if(fabs(S[i].p1.y - S[i].p2.y) < ESP) {\n            if(S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if(S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n        if(fabs(S[i].p1.y - S[i].p2.y) < ESP) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(INT_MAX);\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++) {\n        EndPoint ep = EP[i];\n        if(ep.st == BOTTOM) BT.insert(ep.p.x);\n        if(ep.st == TOP) BT.erase(ep.p.x);\n        if(ep.st == LEFT) {\n            auto b = BT.lower_bound(S[ep.seg].p1.x);\n            auto e = BT.upper_bound(S[ep.seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    int n, x0, y0, x1, y1;\n    cin >> n;\n    vector<Segment> S;\n    for(int i = 0; i < n; i++) {\n        cin >> x0 >> y0 >> x1 >> y1;\n        S.emplace_back(Segment(Point(x0, y0), Point(x1, y1)));\n    }\n\n    cout << manhattanIntersection(S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n \nenum {\n  VTop,\n  HLeft,\n  VBottom\n};\n \nstruct P {\n  int x, y;\n  int type;\n  int oppo_x;\n  bool operator < (P const& p) const {\n    if(y != p.y) return y < p.y;\n    if(type != p.type) { return type < p.type; }\n    return x < p.x;\n  }\n};\n \nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n \nvoid print(vector<P> const& pts) {\n  int F[10][10] = {};\n  rep(i, pts.size()) {\n    if(pts[i].type != HLeft) {\n      if(pts[i].type == VTop) {\n        REP(j, pts[i].y, 10) { F[j][pts[i].x] = 1; }\n      }\n      else {\n        REP(j, pts[i].y+1, 10) { F[j][pts[i].x] = 0; }\n      }\n    }\n  }\n  rep(i, pts.size()) {\n    if(pts[i].type == HLeft) {\n      REP(j, pts[i].x, pts[i].oppo_x+1) { F[pts[i].y][j] = 1; }\n    }\n  }\n  rep(i, 10) {\n    rep(j, 10) {\n      cout << (F[i][j] ? \"#\" : \"_\");\n    }\n    cout << endl;\n  }\n}\n \nint main() {\n   \n  int N; cin >> N;\n  vector<P> pts;\n  rep(i, N) {\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    if(x1 > x2) swap(x1, x2);\n    if(y1 > y2) swap(y1, y2);\n    int type1, type2;\n    if(x1 == x2) {\n      type1 = VTop, type2 = VBottom;\n      pts.push_back((P){x1, y1, type1, -1});\n      pts.push_back((P){x2, y2, type2, -1});\n    }\n    else {\n      type1 = HLeft;\n      pts.push_back((P){x1, y1, type1, x2});\n    }\n  }\n   \n  sort(pts.begin(), pts.end());\n\n  int ret = 0;\n  set<int> xtree;\n  for(auto p: pts) {\n    if(p.type == VTop) {\n      xtree.insert(p.x);\n    }\n    if(p.type == VBottom) {\n      xtree.erase(p.x);\n    }\n    if(p.type == HLeft) {\n      int const x1 = p.x, x2 = p.oppo_x;\n      auto iter1 = xtree.lower_bound(x1);\n      auto iter2 = xtree.upper_bound(x2);\n\n      int cnt = 0;\n      while(iter1 != iter2) {\n        iter1++; cnt++;\n      }\n      ret += cnt;\n    }\n  }\n   \n  cout << ret << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 2点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\n// 端点の種類\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint\n{\n    public :\n        Point p;\n        // 入力線分のID, 端点の種類\n        int seg, st;\n\n        EndPoint() {}\n        EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n        bool operator < (const EndPoint &ep) const\n        {\n            // y座標が小さい順に整列\n            if( p.y == ep.p.y )\n            {\n                // yが同一の場合は, 下端点(BOTTOM), 左端点(LEFT), 右端点(RIGHT), 上端点(TOP)の順に並べる\n                return st < ep.st;\n            }\n            else\n            {\n                return p.y < ep.p.y;\n            }\n        }\n};\n\n// 端点のリスト\nEndPoint EP[2 * 100000];\n//EndPoint EP[2 * 100];\n\n// 線分交差問題　：　マンハッタン幾何\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n\n    for(int i = 0, k = 0; i < n; i++)\n    {\n        // ---▼▼▼ 端点 p1, p2 が左下を基準に並ぶように調整 ▼▼▼---\n\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            // X軸に平行な線分の時\n            if( S[i].p1.x > S[i].p2.x )\n            {\n                swap(S[i].p1, S[i].p2);\n            }\n        }\n        else if( S[i].p1.y > S[i].p2.y )\n        {\n            swap(S[i].p1, S[i].p2);\n        }\n\n        // ---▲▲▲ 端点 p1, p2 が左下を基準に並ぶように調整 ▲▲▲---\n\n        if( S[i].p1.y == S[i].p2.y )\n        {\n            // 水平成分を端点リストに追加 (X軸に平行)\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            // 垂直成分を端点リストに追加 (Y軸に平行)\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    // 端点の y 座標に関して昇順に整列\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;            // 二分探索木\n    BT.insert(1000000001);  // 番兵を設置\n    int cnt = 0;\n\n    for(int i = 0; i < 2 * n; i++)\n    {\n        if( EP[i].st == TOP )\n        {\n            // 上端点を削除\n            BT.erase(EP[i].p.x);\n        }\n        else if( EP[i].st == BOTTOM )\n        {\n            // 下端点を追加\n            BT.insert(EP[i].p.x);\n        }\n        else if( EP[i].st == LEFT )\n        {\n            // 走査線とX軸に平行な線分が重なった時\n\n            // O(log n) - X軸の左端の範囲の検索\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            // O(log n) - X軸の右端の範囲の検索\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            // b と e の距離(点の数)を加算, O(k)\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void)\n{\n\n    int n, count;\n    Point start, end;\n    vector<Segment> v_segment;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        v_segment.push_back(seg);\n    }\n\n    // 結果の表示\n    count = manhattanIntersection(v_segment);\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // 二要素間の距離\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\nclass Point {\n  public:\n  int x, y;\n\n  Point(int x = 0, int y = 0): x(x), y(y) {}\n};\n\nstruct Segment {\n  Point p1, p2;\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\n  public:\n    Point p;\n    int seg, st; // 入力線分のID, 端点の種類\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n      // y 座標が小さい順に整列\n      if (p.y == ep.p.y) {\n        return st < ep.st; // y同一の場合下、左、右、上端点の順に調べる\n      } else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000]; // 端点(EP)のリスト\n\nint manhattanIntersection(vector<Segment> S) {\n  int n = S.size();\n\n  for (int i = 0, k = 0; i < n; i++) {\n    // 端点p1, p2が左下を基準に並ぶように調整\n    if (S[i].p1.y == S[i].p2.y) { // 平行線\n      if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n    } else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2); // 垂直線\n\n    if (S[i].p1.y == S[i].p2.y) { // 水平線分を端点リストに追加\n      EP[k++] = EndPoint(S[i].p1, i, LEFT);\n      EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n    } else {\n      EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n      EP[k++] = EndPoint(S[i].p2, i, TOP);\n    }\n  }\n\n  sort(EP, EP + (2*n));\n\n  set<int> BT; // 二分探索木\n  BT.insert(1000000001); // 番兵追加 (1)参照\n  int cnt = 0;\n\n  rep(i, 0, 2 * n) {\n    if (EP[i].st == TOP) {\n      BT.erase(EP[i].p.x);\n    } else if (EP[i].st == BOTTOM) {\n      BT.insert(EP[i].p.x);\n    } else if (EP[i].st == LEFT) {\n      auto b = BT.lower_bound(S[EP[i].seg].p1.x); // O(log n)\n      auto e = BT.upper_bound(S[EP[i].seg].p2.x); // O(log n) - (1)このために番兵を追加している\n      cnt += distance(b, e); // bとeの距離（点の数）を加算, O(k)\n    }\n  }\n\n  return cnt;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  int x1, y1, x2, y2;\n  vector<Segment> S(n);\n  rep(i, 0, n) {\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    Point p1 = Point(x1, y1);\n    Point p2 = Point(x2, y2);\n    Segment seg = { p1, p2 };\n    S[i] = seg;\n  }\n\n  int ans = manhattanIntersection(S);\n\n  cout << ans << endl;\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X) << endl\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y;\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y;\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r;\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // cassert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  int ccl(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return 1;\n    return -1;\n  }\n\n  Polygon andrewScan(Polygon &s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccl(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccl(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Line a;\n  cin >> n;\n  vector<Segment> vec;\n  rep(i,0,n){\n    cin >> a;\n    vec.pb(a);\n  }\n  print(manhattanIntersection(vec));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nclass Segment {\npublic:\n  int t;\n  int y;\n  int x1,x2;\n  Segment(){}\n  Segment(int t, int y, int x1, int x2) : t(t), y(y), x1(x1), x2(x2) {}\n  bool operator < ( const Segment &s ) const\n  {\n    if ( t == 0 )\n      return y <= s.y;\n    else if ( t == 1 )\n      return y < s.y;\n    else\n      if ( s.t == 0 )\n        return y < s.y;\n      else if ( s.t == 1 )\n        return y <= s.y;\n      else\n        return y < s.y;\n  }\n};\n\nclass SegmentIntersections\n{\npublic:\n  vector<Segment> seg;\n  SegmentIntersections(){}\n  int solve();\n};\n\nint SegmentIntersections::solve()\n{\n  sort( seg.begin(), seg.end() );\n\n  set<int> s;\n  int cnt = 0;\n\n  for ( auto it = seg.begin(); it != seg.end(); ++it )\n    {\n      if ( (*it).t == 0 )\n        s.insert( (*it).x1 );\n      else if ( (*it).t == 1 )\n        s.erase( (*it).x1 );\n      else\n        {\n          auto st = s.lower_bound( (*it).x1 );\n          auto tt = s.upper_bound( (*it).x2 );\n\n          int c = 0;\n          \n          for( auto tit = st; tit != tt; ++tit ) ++c;\n\n          cnt += c;\n        }\n    }\n\n  cout << cnt << endl;\n  \n  return 0;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  SegmentIntersections si;\n\n  int x1, y1, x2, y2;\n\n  for ( auto i = 0; i < n; ++i )\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      if ( x1 == x2 )\n        if ( y1 < y2 )\n          {\n            si.seg.push_back( Segment( 0, y1, x1, 0 ) );\n            si.seg.push_back( Segment( 1, y2, x2, 0 ) );\n          }\n        else\n          {\n            si.seg.push_back( Segment( 1, y1, x1, 0 ) );\n            si.seg.push_back( Segment( 0, y2, x2, 0 ) );\n          }\n      else\n        if ( x1 < x2 )\n          si.seg.push_back( Segment( 2, y1, x1, x2 ) );\n        else\n          si.seg.push_back( Segment( 2, y1, x2, x1 ) );\n    }\n\n  si.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long bit[1000000], _size, n, cnt, __X1[200000], __Y1[200000], __X2[200000], __Y2[200000];\nvector<long long>XX, YY, _XX, _YY; vector<tuple<long long, long long, long long>>vec;\nvoid add(long long p, long long x) { while (p <= _size) { bit[p] += x; p += p&-p; } }\nlong long sum(long long p) { int _sum = 0; while (p >= 1) { _sum += bit[p]; p -= p&-p; }return _sum; }\nlong long __sum(long long l, long long r) { return sum(r) - sum(l - 1); }\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++)cin >> __X1[i] >> __Y1[i] >> __X2[i] >> __Y2[i];\n\tfor (int i = 0; i < n; i++) { XX.push_back(__X1[i]); XX.push_back(__X2[i]); YY.push_back(__Y1[i]); YY.push_back(__Y2[i]); }\n\tsort(XX.begin(), XX.end()); sort(YY.begin(), YY.end());\n\tfor (int i = 0; i < XX.size(); i++) { if (i == 0 || XX[i - 1] != XX[i])_XX.push_back(XX[i]); if (i == 0 || YY[i - 1] != YY[i])_YY.push_back(YY[i]); }\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos1 = lower_bound(_XX.begin(), _XX.end(), __X1[i]) - _XX.begin(), pos2 = lower_bound(_YY.begin(), _YY.end(), __Y1[i]) - _YY.begin();\n\t\tint pos3 = lower_bound(_XX.begin(), _XX.end(), __X2[i]) - _XX.begin(), pos4 = lower_bound(_YY.begin(), _YY.end(), __Y2[i]) - _YY.begin();\n\t\tpos1++; pos2++; pos3++; pos4++; __X1[i] = pos1; __Y1[i] = pos2; __X2[i] = pos3; __Y2[i] = pos4; if (__X1[i] > __X2[i])swap(__X1[i], __X2[i]); if (__Y1[i] > __Y2[i])swap(__Y1[i], __Y2[i]);\n\t\tif (__X1[i] == __X2[i]) { vec.push_back(make_tuple(__Y1[i], -1LL << 60, __X1[i])); vec.push_back(make_tuple(__Y2[i], 1LL << 60, __X1[i])); }\n\t\telse { vec.push_back(make_tuple(__Y1[i], __X1[i], __X2[i])); }\n\t}sort(vec.begin(), vec.end()); _size = XX.size() + 10;\n\tfor (int i = 0; i < vec.size(); i++) { if (abs(get<1>(vec[i])) >= 1LL << 50)add(get<2>(vec[i]), get<1>(vec[i]) / (-1LL << 60)); else { cnt += __sum(get<1>(vec[i]), get<2>(vec[i])); } }\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ndouble abs(Point p) { return sqrt(p.x * p.x + p.y * p.y); }\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nenum TTN { BOTTOM = 0, LEFT, RIGHT, TOP };\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\tEndPoint(Point p = Point(0.0, 0.0), int seg = 0, int st = 0):\n\t\tp{p}, seg(seg), st(st) {}\n\tbool operator < (const EndPoint &ep) const {\n\t\treturn (p.y == ep.p.y) ? (st < ep.st) : (p.y < ep.p.y);\n\t}\n};\nEndPoint EP[2 * 100000];\nint manhattanIntersection(vector<Segment> S) {\n\tint n = len(S);\n\tint k = -1;\n\trep(i, 0, n) {\n\t\tif((S[i].p1.y == S[i].p2.y && S[i].p1.x > S[i].p2.x) || (S[i].p1.y > S[i].p2.y))\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\tif(S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[++k] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[++k] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else{\n\t\t\tEP[++k] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[++k] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\tsort(EP, EP + (2 * n));\n\tset<int> BT;\n\tBT.emplace(1000000001);\n\tint cnt = 0;\n\trep(i, 0, 2 * n) {\n\t\tif (EP[i].st == TOP) BT.erase(EP[i].p.x);\n\t\telse if (EP[i].st == BOTTOM) BT.emplace(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = lower_bound(all(BT), S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = upper_bound(all(BT), S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn mp(pr + e * base, pr - e * base);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2.0 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn mp(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint contains(Polygon g, Point p) {\n\tint n = len(g);\n\tbool x = false;\n\tPoint a, b;\n\trep(i, 0, n) {\n\t\ta = g[i] - p;\n\t\tb = g[(i + 1) % n] - p;\n\t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) {\n\tif(len(s) < 3) return s;\n\tPolygon u, l;\n\tsort(all(s), [](const Point& a, const Point& b){return a.y == b.y ? a.x < b.x : a.y < b.y;});\n\tu.eb(s[0]);\n\tu.eb(s[1]);\n\tl.eb(s[len(s) - 1]);\n\tl.eb(s[len(s) - 2]);\n\tint _ccw;\n\trep(i, 2, len(s)) {\n\t\trrep(n, len(u), 1) {\n\t\t\t_ccw = ccw(u[n - 2], u[n - 1], s[i]);\n\t\t\tif(!(_ccw != CLOCKWISE && _ccw != ONLINE_FRONT)) break;\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.eb(s[i]);\n\t}\n\trrep(i, len(s) - 3, -1) {\n\t\trrep(n, len(l), 1) {\n\t\t\t_ccw = ccw(l[n - 2], l[n - 1], s[i]);\n\t\t\tif(!(_ccw != CLOCKWISE && _ccw != ONLINE_FRONT)) break;\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.eb(s[i]);\n\t}\n\treverse(all(l));\n\trrep(i, len(u) - 2, 0) l.eb(u[i]);\n\treturn l;\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tint n; cin >> n;\n\tvector<Segment> vse(n);\n\trep(i, 0, n) {\n\t\tcin >> vse[i].p1.x >> vse[i].p1.y >> vse[i].p2.x >> vse[i].p2.y;\n\t}\n\tP(manhattanIntersection(vse));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 1000000000000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 200005\n\n\nenum Type{\n\tTATE,\n\tYOKO,\n};\n\nstruct Line{\n\n\tType type;\n\tint x1,y1,x2,y2;\n};\n\nstruct Info{\n\tInfo(int arg_x,int arg_index,Type arg_type){\n\t\tx = arg_x;\n\t\tindex = arg_index;\n\t\ttype = arg_type;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\tif(x != arg.x){\n\n\t\t\treturn x < arg.x;\n\t\t}else{\n\n\t\t\treturn type < arg.type; //右から左に見た場合、縦棒が後に出るようにする\n\t\t}\n\t}\n\tType type;\n\tint x,index;\n};\n\nint N;\nvector<int> X,Y;\nmap<int,int> map_Y;\nll BIT[SIZE];\nLine line[SIZE];\n\n\n\nvoid add(int loc,ll value){\n\n\tBIT[loc] += value;\n\n\tloc += loc & -loc; //最後の1ビットを足した場所が次の★更新★場所\n\n\twhile(loc <= N){\n\t\tBIT[loc] += value;\n\t\tloc += loc & -loc;\n\t}\n}\n\nll getSum(int loc){\n\n\tll sum = BIT[loc];\n\n\tloc -= loc & -loc; //最後の1ビットを引いた場所が次の★加算★場所\n\n\twhile(loc > 0){\n\t\tsum += BIT[loc];\n\t\tloc -= loc & -loc;\n\t}\n\treturn sum;\n}\n\nll calc(int left,int right){ //left～rightの区間の総和を、sum(1～right)-sum(1～left-1)で求める\n\treturn getSum(right)-getSum(left-1);\n}\n\nint main(){\n\n\tint num_line;\n\tscanf(\"%d\",&num_line);\n\n\tfor(int i = 0; i < num_line; i++){\n\n\t\tscanf(\"%d %d %d %d\",&line[i].x1,&line[i].y1,&line[i].x2,&line[i].y2);\n\n\t\tY.push_back(line[i].y1);\n\t\tY.push_back(line[i].y2);\n\n\t\tif(line[i].x1 == line[i].x2){ //縦棒\n\n\t\t\tline[i].type = TATE;\n\n\t\t}else{ //横棒\n\n\t\t\tline[i].type = YOKO;\n\t\t}\n\t}\n\n\t//座標圧縮\n\tsort(Y.begin(),Y.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\tN = (int)Y.size();\n\n\tfor(int i = 0; i <= N; i++){\n\n\t\tBIT[i] = 0;\n\t}\n\n\tfor(int i = 0; i < Y.size(); i++){\n\n\t\tmap_Y[Y[i]] = i+1;\n\t}\n\n\tvector<Info> info;\n\n\tfor(int i = 0; i < num_line; i++){\n\n\t\tif(line[i].type == TATE){\n\n\t\t\tinfo.push_back(Info(line[i].x1,i,TATE));\n\t\t}else{\n\n\t\t\tinfo.push_back(Info(max(line[i].x1,line[i].x2),i,YOKO)); //BIT加算用\n\t\t\tinfo.push_back(Info(min(line[i].x1,line[i].x2)-1,i,YOKO)); //BIT削除用\n\t\t}\n\t}\n\n\tsort(info.begin(),info.end());\n\n\tll ans = 0;\n\n\tfor(int i = info.size()-1; i >= 0; i--){\n\n\t\tif(info[i].type == TATE){\n\n\t\t\tint left = map_Y[min(line[info[i].index].y1,line[info[i].index].y2)];\n\t\t\tint right = map_Y[max(line[info[i].index].y1,line[info[i].index].y2)];\n\n\t\t\tans += calc(left,right);\n\n\t\t}else{ //横棒\n\n\t\t\tif(info[i].x == max(line[info[i].index].x1,line[info[i].index].x2)){ //横線の右側\n\n\t\t\t\tadd(map_Y[line[info[i].index].y1],1);\n\n\t\t\t}else{ //横線の左側-1\n\n\t\t\t\tadd(map_Y[line[info[i].index].y1],-1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\nusing namespace std;\nclass Point\n{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n    Point operator * (double a) {return Point(x * a, y * a);}\n    Point operator / (double a) {return Point(x / a, y / a);}\n\n    double abs() {return sqrt(norm());}\n    double norm() {return x * x + y * y;}\n    \n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};typedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2):p1(p1), p2(p2){}\n};typedef Segment Line;\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint(){}\n    EndPoint(Point p, int seg, int st):p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y){\n            return st < ep.st;\n        }else return p.y < ep.p.y;\n    }\n};\nEndPoint EP[2*100000];\nint manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; i++){\n        if (S[i].p1.y == S[i].p2.y){\n            if (S[i].p1.x > S[i].p2.x)\n                swap(S[i].p1, S[i].p2);\n        }else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else{\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n    sort(EP, EP + (2*n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n\n    for (int i = 0; i < 2*n; i++)\n    {\n        if (EP[i].st == TOP){\n            BT.erase(EP[i].p.x);\n        }else if (EP[i].st == BOTTOM){\n            BT.insert(EP[i].p.x);\n        }else if (EP[i].st == LEFT){\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\nint main(){\n    int n; cin >> n;\n    vector<Segment> S;\n    for (int i = 0; i < n; i++){\n        int x1, x2, y1, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s = Segment(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n    cout << manhattanIntersection(S) << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tif (y1 > y2) swap(y1, y2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int INF = 1111111111;\n\nclass Point {\npublic:\n    int x, y;\n\n    Point(int x = 0, int y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return x == p.x && y == p.y;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        } else {\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * MAX_N];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (S[i].p1.x == S[i].p2.x) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p1.y) {\n            swap(S[i].p1, S[i].p2);\n        }\n\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + 2*n);\n    set<int> BT;\n    BT.insert(INF);\n    int cnt = 0;\n\n    for (int i = 0; i < 2*n; i++) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        } else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        } else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void) {\n    int n; cin >> n;\n\n    int x1, y1, x2, y2;\n    vector<Segment> S;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n\n    cout << manhattanIntersection(S) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long bit[1000000], _size, n, cnt, __x1[200000], __y1[200000], __x2[200000], __y2[200000];\nvector<long long>XX, YY, _XX, _YY; vector<tuple<long long, long long, long long>>vec;\nvoid add(long long p, long long x) { while (p <= _size) { bit[p] += x; p += p&-p; } }\nlong long sum(long long p) { int _sum = 0; while (p >= 1) { _sum += bit[p]; p -= p&-p; }return _sum; }\nlong long __sum(long long l, long long r) { return sum(r) - sum(l - 1); }\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++)cin >> __x1[i] >> __y1[i] >> __x2[i] >> __y2[i];\n\tfor (int i = 0; i < n; i++) { XX.push_back(__x1[i]); XX.push_back(__x2[i]); YY.push_back(__y1[i]); YY.push_back(__y2[i]); }\n\tsort(XX.begin(), XX.end()); sort(YY.begin(), YY.end());\n\tfor (int i = 0; i < XX.size(); i++) { if (i == 0 || XX[i - 1] != XX[i])_XX.push_back(XX[i]); if (i == 0 || YY[i - 1] != YY[i])_YY.push_back(YY[i]); }\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos1 = lower_bound(_XX.begin(), _XX.end(), __x1[i]) - _XX.begin(), pos2 = lower_bound(_YY.begin(), _YY.end(), __y1[i]) - _YY.begin();\n\t\tint pos3 = lower_bound(_XX.begin(), _XX.end(), __x2[i]) - _XX.begin(), pos4 = lower_bound(_YY.begin(), _YY.end(), __y2[i]) - _YY.begin();\n\t\t__x1[i] = pos1; __y1[i] = pos2; __x2[i] = pos3; __y2[i] = pos4; if (__x1[i] > __x2[i])swap(__x1[i], __x2[i]); if (__y1[i] > __y2[i])swap(__y1[i], __y2[i]);\n\t\tif (__x1[i] == __x2[i]) { vec.push_back(make_tuple(__y1[i], 1LL << 60, __x1[i])); vec.push_back(make_tuple(__y2[i], -1LL << 60, __x1[i])); }\n\t\telse { vec.push_back(make_tuple(__y1[i], __x1[i], __x2[i])); }\n\t}sort(vec.begin(), vec.end()); _size = XX.size() + 10;\n\tfor (int i = 0; i < vec.size(); i++) { if (abs(get<1>(vec[i])) >= 1LL << 50)add(get<2>(vec[i]), get<1>(vec[i]) / (1LL << 60)); else { cnt += __sum(get<1>(vec[i]), get<2>(vec[i])); } }\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\t\t\t\t\t\t       \n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n//closest pair:\nsigned AOJ_CGL5A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<fixed<<setprecision(12)<<closest_pair(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=jp\n*/\n\n//manhattanIntersection:\nsigned AOJ_CGL6A(){\n  int n;\n  cin>>n;\n  vector<Segment> ss(n);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  //for(int i=0;i<n;i++) cout<<ss[i].p1<<\":\"<<ss[i].p2<<endl;\n  cout<<manhattanIntersection(ss,1e9+10)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/06/18\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp.size()==1u) pp.emplace_back(pp[0]);\n    if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7E(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto pp=getCrossPointCC(c1,c2);\n  if(pp.size()==1u) pp.emplace_back(pp[0]);\n  if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n  cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=jp\n*/\n\n//tangent to a Circle\nsigned AOJ_CGL7F(){\n  Point p;\n  Circle c;\n  cin>>p>>c;\n  auto pp=tangent(c,p);\n  for(auto p:pp) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//area of 2 circles' intersection\nsigned AOJ_2572(){\n  double uw,uh,a,b,ab;\n  while(cin>>uw>>uh>>a>>b>>ab,uw!=0){\n    Circle c1(Point(0,0),sqrt(a/PI));\n    Circle c2(Point(0,0),sqrt(b/PI));\n    bool f=0;\n    if(c1.r<=c2.r) swap(c1,c2),f=1;\n    double l=max(0.0,c1.r-c2.r),r=c1.r+c2.r+EPS;\n    for(int k=0;k<100;k++){\n      double m=(l+r)/2;\n      c2.c.x=m;\n      //cout<<area(c1,c2)<<endl;\n      if(area(c1,c2)<=ab) r=m;\n      else l=m;\n    }\n    c2.c.x=l;\n    \n    double EPS3=1e-4;\n    assert(abs(area(c1,c2)-ab)<=EPS3);\n\n    l=0,r=PI/2;\n    for(int k=0;k<200;k++){\n      double m=(l+r)/2;\n      Circle t=c2;\n      t.c=translate(c2.c,m);\n      if(c1.r+max(c1.r,t.c.x+t.r)<=uw) r=m;\n      else l=m;\n    }\n    c2.c=translate(c2.c,r);\n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n    \n    Vector v(c1.r,c1.r);\n    c1.c=c1.c+v;\n    c2.c=c2.c+v;\n    \n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n\n    if(f) swap(c1,c2);\n    f=1;\n    f&=(c1.c.x-c1.r>=-EPS3);\n    f&=(c1.c.x+c1.r<=uw+EPS3);\n    f&=(c1.c.y-c1.r>=-EPS3);\n    f&=(c1.c.y+c1.r<=uh+EPS3);\n    f&=(c2.c.x-c2.r>=-EPS3);\n    f&=(c2.c.x+c2.r<=uw+EPS3);\n    f&=(c2.c.y-c2.r>=-EPS3);\n    f&=(c2.c.y+c2.r<=uh+EPS3);\n    if(f) cout<<c1.c<<\" \"<<c1.r<<\" \"<<c2.c<<\" \"<<c2.r<<endl;\n    else cout<<\"impossible\"<<endl;\n    //else cout<<c1.c<<\" \"<<c1.r<<\"/\"<<c2.c<<\" \"<<c2.r<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/12/31\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2572\n*/\n\n//Segment Arrangement\nsigned AOJ_2454(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  \n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<fixed<<setprecision(12)<<ans-tmp<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/27\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2454\n*/\n\n\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  //AOJ_CGL5A();\n\n  AOJ_CGL6A();\n  \n  //AOJ_CGL7A();\n  //AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7F();\n  //AOJ_CGL7G();\n\n  //AOJ_2572();\n  //AOJ_2454();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=400100,Mx=200000;\nint n,m,c[N],o1[N],o2[N],tot1,tot2;\nstruct line{int x1,y1,x2,y2;}Line[N];\nstruct node{int x,y,opt;}p[N];\nstruct hx{int x1,x2,y;}h[N];\nbool operator<(const node a,const node b){return a.y<b.y;}\nbool operator<(const hx a,const hx b){return a.y<b.y;}\nint lowbit(int x){return x&(-x);}\nvoid Add(int x,int d){while(x<=Mx){c[x]+=d;x+=lowbit(x);}}\nint query(int x){int ret=0;while(x){ret+=c[x];x-=lowbit(x);}return ret;}\nint query(int l,int r){return query(r)-query(l-1);}\nint main(){\n\tint all=gi();\n\tfor(int i=1;i<=all;i++){\n\t\tint x1=gi(),y1=gi(),x2=gi(),y2=gi();\n\t\tLine[i]=(line){x1,y1,x2,y2};\n\t\to1[++tot1]=x1;o1[++tot1]=x2;\n\t\to2[++tot2]=y1;o2[++tot2]=y2;\n\t}\n\tsort(o1+1,o1+tot1+1);tot1=unique(o1+1,o1+tot1+1)-o1-1;\n\tsort(o2+1,o2+tot2+1);tot2=unique(o2+1,o2+tot2+1)-o2-1;\n\tfor(int i=1;i<=all;i++){\n\t\tLine[i].x1=lower_bound(o1+1,o1+tot1+1,Line[i].x1)-o1;\n\t\tLine[i].x2=lower_bound(o1+1,o1+tot1+1,Line[i].x2)-o1;\n\t\tLine[i].y1=lower_bound(o2+1,o2+tot2+1,Line[i].y1)-o2;\n\t\tLine[i].y2=lower_bound(o2+1,o2+tot2+1,Line[i].y2)-o2;\n\t}\n\tfor(int i=1;i<=all;i++){\n\t\tint x1=Line[i].x1,y1=Line[i].y1,x2=Line[i].x2,y2=Line[i].y2;\n\t\tif(x1==x2){\n\t\t\tif(y1>y2)swap(y1,y2);\n\t\t\tp[++m]=(node){x1,y1,1};p[++m]=(node){x1,y2+1,-1};\n\t\t}\n\t\telse{\n\t\t\tif(x1>x2)swap(x1,x2);\n\t\t\th[++n]=(hx){x1,x2,y1};\n\t\t}\n\t}\n\tsort(h+1,h+n+1);sort(p+1,p+m+1);int pos=1,ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(pos<=m && p[pos].y<=h[i].y){Add(p[pos].x,p[pos].opt);pos++;}\n\t\tans+=query(h[i].x1,h[i].x2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = long double;\nconst T EPS = 1e-10;\nconst T PI = acos(-1.0);\nT torad(int deg) {return (T)(deg) * PI / 180;}\nT todeg(T ang) {return ang * 180 / PI;}\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (0.0 < x) - (x < 0.0); }\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(T(1), a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\nistream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\nP linearTransform(P p, P q, P fp, P fq, P r) {\n    return fp + (r - p) * (fq - fp) / (q - p);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS) return +1;      // counter clockwise\n    if (cross(b, c) < -EPS) return -1;      // clockwise\n    if (dot(b, c) < -EPS) return +2;        // c--a--b on line\n    if (norm(b) < norm(c) - EPS) return -2;    // a--b--c on line or a==b\n    return 0;                            // a--c--b on line or a==c or b==c\n}\n\nT angle(P v, P w) {\n    T cosTheta = dot(v, w) / abs(v) / abs(w);\n    return acos(max(T(-1.0), min(T(1.0), cosTheta)));\n}\nT orientedAngle(P a, P b, P c) {\n    if (orient(a, b, c) >= 0) return angle(b - a, c - a);\n    return 2 * PI - angle(b - a, c - a);\n}\nbool inAngle(P a, P b, P c, P p) {\n    assert(abs(orient(a, b, c)) != 0);\n    if (orient(a, b, c) < 0) swap(b, c);\n    return orient(a, b, p) >= 0 && orient(a, c, p) <= 0;\n}\n\n// polar sort\nbool half(P p) {\n    assert(p.x != 0 || p.y != 0);\n    return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nvoid polarSort(vector<P>& v, P o = P(0.0, 0.0)) {\n    sort(v.begin(), v.end(), [&](P v, P w) {\n        return make_tuple(half(v - o), 0, norm(v - o)) <\n            make_tuple(half(w - o), cross(v - o, w - o), norm(w - o));\n    });\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L(P a = P(0.0, 0.0), P b = P(0.0, 0.0)) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    friend istream& operator>>(istream& is, L& l) { P p, q; is >> p >> q; l = L(p, q); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\nstruct EndPoint {\n    P p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(P p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n    bool operator<(const EndPoint& ep) const {\n        return (p.y == ep.p.y ? st < ep.st : p.y < ep.p.y);\n    }\n};\nint manhattanIntersection(vector<L> s, const T INF = numeric_limits<T>::max()) {\n    const int BTM = 0;\n    const int LFT = 1;\n    const int RGH = 2;\n    const int TOP = 3;\n\n    int n = s.size();\n    vector<EndPoint> ep;\n    for (int i = 0; i < n; ++i) {\n        if (s[i][0].y == s[i][1].y) {\n            if (s[i][0].x > s[i][1].x) {\n                swap(s[i][0], s[i][1]);\n            }\n        } else if (s[i][0].y > s[i][1].y) {\n            swap(s[i][0], s[i][1]);\n        }\n\n        if (s[i][0].y == s[i][1].y) {\n            ep.emplace_back(s[i][0], i, LFT);\n            ep.emplace_back(s[i][1], i, RGH);\n        } else {\n            ep.emplace_back(s[i][0], i, BTM);\n            ep.emplace_back(s[i][1], i, TOP);\n        }\n    }\n    sort(ep.begin(), ep.end());\n    set<T> bt;\n    bt.insert(INF);\n    int res = 0;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (ep[i].st == TOP) {\n            bt.erase(ep[i].p.x);\n        } else if (ep[i].st == BTM) {\n            bt.insert(ep[i].p.x);\n        } else if (ep[i].st == LFT) {\n            auto b = bt.lower_bound(s[ep[i].seg][0].x);\n            auto e = bt.upper_bound(s[ep[i].seg][1].x);\n            res += distance(b, e);\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int n;\n    cin >> n;\n    vector<L> ls(n);\n    REP (i, n) cin >> ls[i];\n    cout << manhattanIntersection(ls) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y =0.0):x(x),y(y){}\n\tPoint operator + (const Point& p){ return Point(x+p.x,y+p.y);\t}\n\tPoint operator - (const Point& p){ return Point(x-p.x,y-p.y); }\n\tPoint operator * (double k){ return Point(x*k,y*k);\t}\n\tPoint operator / (double k){ return Point(x/k,y/k); }\n\n\tdouble norm(){return x*x+y*y;}\n\tdouble abs(){return sqrt(norm());}\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\n\n\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){}\n\tSegment(double a,double b,double c,double d):p1(Point(a,b)),p2(Point(c,d)){}\n};\n\ntypedef Segment Line;\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c),r(r){}\n\tCircle(double x,double y, double r = 0.0): c(Point(x,y)),r(r){}\n};\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon g){\n\tdouble ans = 0.0;\n\tint n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tans+=cross(Vector(g[i]), Vector(g[(i+1)%n]));\n\t}\n\treturn fabs(ans)/2;\n}\n\n\nbool isOrthgonal(Vector a, Vector b){\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthgonal(a1-a2,b1-b2);\n}\n\nbool isOrthgonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p-s.p1,base)/base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s,p) - p) * 2.0;\n}\n\n\n\n//????¨???¨????????§??????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Vector a, Vector b){\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n//??????????????????\nbool intersect(Point p1, Point p2, Point p3,Point p4){\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2, s2.p1,s2.p2);\n}\n\n//??????\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base,s1.p1 - s2.p1));//?´??????§?¶????\n\tdouble d2 = abs(cross(base,s1.p2 - s2.p1));\n\tdouble t = d1 / (d1+d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//{???,??´???,??????}^2????????¢\ndouble getDistance(Point a,Point b){\n\treturn abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p-l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2 - s.p1, p-s.p1) < 0.0) return abs(p-s.p1);\n\tif(dot(s.p1 - s.p2, p-s.p2) < 0.0) return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1,s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\t\t\t min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\t//assert(intersect(c,l));\n\tVector pr = project(l,c.c);\n\tVector e = (l.p2 - l.p1)/abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n// x?????¨????§?????????????\ndouble arg(Vector p){return atan2(p.y,p.x);}\n\n// ?§????0?????´??????r????????¢\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\n// ???????£???????????????????\npair<Point, Point> getCrossPoint(Circle c1, Circle c2){\n\t//assert(intersect(c1,c2))\n\tdouble d = abs(c1.c-c2.c);//???????£?????????¢\n\tdouble a = acos((c1.r * c1.r + d*d - c2.r*c2.r)/(2*d*c1.r));//??????????????§????????¨?????????????????????????§?????±???????\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r,t+a),c1.c + polar(c1.r,t-a));\n}\n\n/*\n * ?????§??????\n * ?????§???180?????\\???????????¶????????§?????´???????????¨????¨±?????????\n */\nbool isConvex(Polygon g){\n\tint n = g.size();\n\tREP(i,n){\n\t\tint tmpccw = ccw(g[i],g[(i+1)%n],g[(i+2)%n]);\n\t\tif(tmpccw == CLOCKWISE)return false;\n\t}\n\treturn true;\n}\n\n/*\n * ????????????\n * IN 2, ON 1, OUT 0\n */\nint contains(Polygon& g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\tREP(i,n){\n\t\tPoint a = g[i] - p, b = g[(i+1)%n] - p;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n\t}\n\treturn x ? 2 : 0;\n}\n\n/*\n * y???????????????\n */\nbool compare(const Point& a,const Point& b){\n\tif(a.y == b.y)return a.x < b.x;\n\treturn a.y < b.y;\n}\n/*\n * ??????????±???????(??¢???????????\\????????¢?????´?????????)\n */\nPolygon andrewScan(Polygon g){\n\tPolygon u,l;\n\tif(g.size() < 3) return g;\n\tsort(g.begin(),g.end(),compare);//compare????????§x???????????????\n\tu.push_back(g[0]);\n\tu.push_back(g[1]);\n\tl.push_back(g[g.size() - 1]);\n\tl.push_back(g[g.size() - 2]);\n\t// ??????????????¨?????????\n\tfor(int i =2;i < g.size();i++){\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],g[i]) == COUNTER_CLOCKWISE;n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(g[i]);\n\t}\n\t// ??????????????¨?????????\n\tfor(int i = g.size() - 3;i >= 0;i--){\n\t\tfor(int n = l.size();n>=2&&ccw(l[n-2],l[n-1],g[i])==COUNTER_CLOCKWISE;n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(g[i]);\n\t}\n\t\treverse(l.begin(),l.end());\n\tfor(int i = u.size() - 2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n\n\n// ??????????¨????\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint{\npublic:\n\tPoint p;\n\tint seg, st;\n\tEndPoint(){}\n\tEndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n\n\tbool operator < (const EndPoint &ep) const{\n\t\t// y??§?¨?????°???????????????´???\n\t\tif(p.y == ep.p.y){\n\t\t\treturn st < ep.st;\n\t\t}else return p.y < ep.p.y;\n\t}\n};\n\nEndPoint EP[2 * 1000000]; //??????????????????\n\n//?????????????????????????????????????????????\nint manhattanIntersection(vector<Segment> S){\n\tint n = S.size();\n\n\tfor(int i = 0,k = 0;i < n;i++){\n\t\t// ?????????p1,p2??????????????????????????¶??????????????´\n\t\tif(S[i].p1.y == S[i].p2.y){\n\t\t\tif(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y)swap(S[i].p1,S[i].p2);\n\n\t\tif(S[i].p1.y == S[i].p2.y){\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t}else{\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP,EP + 2*n); // ?????????y??§?¨??????¢?????????????????´???\n\n\tset<int> BT; // ????????¢?´¢??¨\n\tBT.insert((int)1e9 + 1); //??????????¨????\n\tint cnt = 0;\n\n\tfor(int i = 0;i < 2*n;i++){\n\t\tif(EP[i].st == TOP) BT.erase(EP[i].p.x); // ??????????????????\n\t\telse if(EP[i].st == BOTTOM)BT.insert(EP[i].p.x); // ??????????????????\n\t\telse if(EP[i].st == LEFT){\n\t\t\tset<int>::iterator b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x); // O(log n)\n\t\t\tset<int>::iterator e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x); // O(log n)\n\t\t\tcnt += distance(b,e); //b??¨e????????¢???????????°????????????,O(k)\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tvector<Segment> S;\n\twhile(n--){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tS.push_back(Segment(a,b,c,d));\n\t}\n\tcout << manhattanIntersection(S) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int, int> i_i;\n\n#define rep(i, n) for(i = 0;i < n;++i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define X first\n#define Y second\n\nstruct rsqsegtree{\n  vector<int> t;\n  int re;\n  int n;\n  void use(int N){\n    re = 0; n = N;\n    int i, j;\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0] = 1 << i;\n    for(i = 1;i < t[0];++i)t[i] = re;\n    t[0] >>= 1;\n    return;\n  }\n  void update(int at, int data){\n    t[t[0] + at] += data;\n    int tmp;\n    for(int x = t[0] + at;x >= 2;x >>= 1)\n    t[x >> 1] = (t[(x >> 1) << 1] + t[((x >> 1) << 1) + 1]);\n    return;\n  }\n  int query(int l, int r, int k, int kl, int kr){\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    return query(l, r, k * 2, kl, (kl + kr) >> 1) + query(l, r, k * 2 + 1, (kl + kr) >> 1, kr);\n  }\n  int getsum(int l, int r){ return query(l, r, 1, 0, t[0]); }\n  void deb(void){\n    int x = 1;\n    t[0] *= 2;\n    printf(\"t[0] : %d\\n\", t[0]);\n    for(int i = 1;i < t[0];++i){\n      printf(\"%11d\", t[i]);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    t[0] /= 2;\n    return;\n  }\n};\n\nstruct query{\n  int q, y, l, r;\n};\nbool ysort(query qwe, query rty){\n  if(qwe.y != rty.y)return qwe.y < rty.y;\n  return qwe.q > rty.q;\n}\n\nrsqsegtree ST;\nquery Q[300000];\nvector<int> x;\nint qh = 0;\n\nint inv(int d){\n  int l = 0, r = x.size(), m;\n  for(;l + 1 < r;){\n    m = l + (r - l) / 2;\n    if(d == x[m])return m;\n    if(d > x[m])l = m;\n    else r = m;\n  }\n  return l;\n}\n\nsigned main(void){\n  int i, j;\n  int(n);\n  rep(i, n){\n    int4(x1, y1, x2, y2);\n    if(x1 == x2){\n      Q[qh++] = (query){1, min(y1, y2), x1, 0};\n      Q[qh++] = (query){-1, max(y1, y2), x1, 0};\n      x.pb(x1);\n    }else{\n      Q[qh++] = (query){0, y1, min(x1, x2), max(x1, x2)};\n      x.pb(x1);\n      x.pb(x2);\n    }\n  }\n  sort(Q, Q + qh, ysort);\n  sort(all(x));\n  x.erase(unique(all(x)), x.end());\n\n  ST.use(x.size());\n  int res = 0;\n  rep(i, qh){\n    if(Q[i].q == 0){\n      //printf(\"%d : %d : %d %d\\n\", i, Q[i].y, Q[i].l, inv(Q[i].l));\n      //printf(\"%d : %d : %d %d\\n\", i, Q[i].y, Q[i].r, inv(Q[i].r));\n      res += ST.getsum(inv(Q[i].l), inv(Q[i].r) + 1);\n    }else{\n      ST.update(inv(Q[i].l), Q[i].q);\n    }\n  }\n  printf(\"%d\\n\", res);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<set>\nusing namespace std;\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\n\nconst double EPS = 1e-10;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(Point p1, Point p2): x((p2 - p1).x), y((p2 - p1).y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tPoint operator / (double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n\tPoint orth() {\n\t\treturn Point(-y, x) / abs();\n\t}\n};\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint id, type;\n\tEndPoint(Point p, int id, int type): p(p), id(id), type(type) {}\n\n\tbool operator < (const EndPoint &e) const {\n\t\treturn p.y != e.p.y ? p.y < e.p.y : type < e.type;\n\t}\n};\n\nint Intersections(vector<EndPoint> EP) { //????????????????????????\n\tset<int> T;\n\tint tmp, cnt = 0;\n\tfor (int i = 0; i < EP.size(); i++) {\n\t\tswitch (EP[i].type) {\n\t\t\tcase BOTTOM:\n\t\t\t\tT.insert(EP[i].p.x);\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\ttmp = EP[i].p.x;\n\t\t\t\tbreak;\n\t\t\tcase RIGHT: { //?????°??????????????¨??????????????????\n\t\t\t\tset<int>::iterator a = lower_bound(T.begin(), T.end(), tmp); //??¨???find???????????????????????§?????£???????????????\n\t\t\t\tset<int>::iterator b = upper_bound(T.begin(), T.end(), EP[i].p.x);\n\t\t\t\tcnt += distance(a, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase TOP:\n\t\t\t\tT.erase(EP[i].p.x);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn cnt;\n} \n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<EndPoint> EP;\n\tint x0, y0, x1, y1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1;\n\t\tif (x0 == x1) {\n\t\t\tif (y0 < y1) {\n\t\t\t\tEP.push_back(EndPoint(Point(x0, y0), i, BOTTOM)); //swap??????????????´??????\n\t\t\t\tEP.push_back(EndPoint(Point(x1, y1), i, TOP));\n\t\t\t} else {\n\t\t\t\tEP.push_back(EndPoint(Point(x0, y0), i, TOP));\n\t\t\t\tEP.push_back(EndPoint(Point(x1, y1), i, BOTTOM));\n\t\t\t}\n\t\t} else {\n\t\t\tif (x0 < x1) {\n\t\t\t\tEP.push_back(EndPoint(Point(x0, y0), i, LEFT));\n\t\t\t\tEP.push_back(EndPoint(Point(x1, y1), i, RIGHT));\n\t\t\t} else {\n\t\t\t\tEP.push_back(EndPoint(Point(x0, y0), i, RIGHT));\n\t\t\t\tEP.push_back(EndPoint(Point(x1, y1), i, LEFT));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tsort(EP.begin(), EP.end());\n\tcout << Intersections(EP) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\n// 点类\nclass Point {\npublic :\n\tdouble x, y;\n\tPoint() {};\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n// 线段类\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {};\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {};\n};\n// 圆类\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle() {};\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n// 定义向量\ntypedef Point Vector;\n// 定义直线\ntypedef Segment Line;\n// 定义多边形\ntypedef vector<Point> Polygon;\n\n/***************************点、向量****************************/\n\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\n\n// 向量的内积\ndouble dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 向量的外积\ndouble cross(Point a, Point b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 向量a，b是否正交 <==> 内积为0\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n// 向量a，b是否平行 <==> 外积为0\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n// 点p在线段s上的投影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r ;\n}\n\n//以线段s为对称轴与点p成线对称的点\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n// 点a到点b的距离\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n// 线段l和点p的距离\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1) );\n}\n\n// 线段s与点p的距离\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n\n\n/*************************线段********************************/\n// 线段s1，s2是否正交 <==> 内积为0\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 线段s1，s2是否平行 <==> 外积为0\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 逆时针方向ccw（Counter-Clockwise）\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// 判断线段p1p2和线段p3p4是否相交\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//判断线段s1和s2是否相交\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 线段s1和线段s2的距离\ndouble getDistance(Segment s1, Segment s2) {\n\t// 相交\n\tif (intersect(s1, s2))\n\t\treturn 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 线段s1与线段s2的交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/***************************圆****************************/\n\n// 圆c和直线l的交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n// 圆c1和圆c2的交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n/***************************多边形****************************/\n// 点的内包\n/*\n\tIN 2\n\tON 1\n\tOUT 0\n*/\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)\n\t\t\tx = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nint cmp(Point A, Point B)                     //竖直排序  \n{\n\treturn (A.y<B.y || (A.y == B.y&&A.x<B.x));\n}\n// 凸包\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tint len = s.size();\n\tif (len < 3) return s;\n\n\n\t// 以x，y为基准升序排序\n\tsort(s.begin(), s.end());\n\t// 将x值最小的两个点添加到u\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\n\t// 将x值最大的两个点添加到l\n\tl.push_back(s[len - 1]);\n\tl.push_back(s[len - 2]);\n\n\t// 构建凸包上部\n\tfor (int i = 2; i < len; i++) {\n\t\tfor (int j = u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], s[i]) >= 0; j--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t// 构建凸包下部\n\tfor (int i = len - 3; i >= 0; i--) {\n\t\tfor (int j = l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], s[i]) >= 0; j--) {\n\t\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)\n\t\tl.push_back(u[i]);\n\t\n\treturn l;\n}\n\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic :\n\tPoint p;\n\tint seg, st; // 线段的ID，端点的种类\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\t// 按y坐标升序排序\n\t\tif (p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t}else {\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n\n};\nEndPoint EP[2 * 1000010];\n\n// 线段相交问题，曼哈顿几何\nint manhattanIntersection(vector<Segment> S) {\n\tint n = S.size();\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t//调整端点p1、p2，保证左小右大\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tif(S[i].p1.x > S[i].p2.x)\n\t\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\t// 将水平线段添加到端点列表\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t}else { // 将垂直线段添加到端点列表\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\t//按照端点的y坐标升序排序\n\tsort(EP, EP + (2 * n));\n\n\tset<int> BT;\t\t\t// 二叉搜索树\n\tBT.insert(10000000001); // 设置标记\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (EP[i].st == TOP)\n\t\t\tBT.erase(EP[i].p.x); //删除上端点\n\t\telse if (EP[i].st == BOTTOM)\n\t\t\tBT.insert(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\n\t\t\t// 加上b到e距离\n\t\t\tcnt += distance(b, e);\n\t\t}\n\n\t}\n\treturn cnt;\n}\nint main() {\n\tvector<Segment> S;\n\tSegment seg;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf %lf %lf %lf\", &seg.p1.x, &seg.p1.y, &seg.p2.x, &seg.p2.y);\n\t\tS.push_back(seg);\n\t}\n\n\tprintf(\"%d\\n\", manhattanIntersection(S));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (y1 < y2) swap(y1, y2);\n\t\t\tif(y1 == y2) lines.push_back(PP(P(y1, 1), P(x1, x2)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tlines.push_back(PP(P(y1, 0), P(x1, x2)));\n\t\t\t\tlines.push_back(PP(P(y2, 2), P(x1, x2)));\n\t\t\t}\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, option = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\tif (option == 0) add(x1, 1);\n\t\t\tif (option == 2) add(x1, -1);\n\t\t\tif (option == 1) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; }; struct Segment { Point p1, p2; };\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double norm(const Point& a) { return a.px*a.px + a.py*a.py; }\nint ccw(Point p0, Point p1, Point p2) { Point a, b; a.px = p1.px - p0.px; a.py = p1.py - p0.py; b.px = p2.px - p0.px; b.py = p2.py - p0.py; if (crs(a, b) > 1e-10) return 1; if (crs(a, b) < -1e-10) return -1; if (dot(a, b) < -1e-10) return 2; if (norm(a) < norm(b)) return -2; return 0; }\nbool its(Point p1, Point p2, Point p3, Point p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nbool its(Segment S1, Segment S2) { return its(S1.p1, S1.p2, S2.p1, S2.p2); }int N; Segment X[200000];\nint main() { long long sum = 0; cin >> N; for (int i = 0; i < N; i++) { cin >> X[i].p1.px >> X[i].p1.py >> X[i].p2.px >> X[i].p2.py; }for (int i = 0; i < N; i++) { for (int j = i + 1; j < N; j++) { if (its(X[i], X[j]) == true) { sum++; } } }cout << sum << endl; return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int, int> i_i;\n\n#define rep(i, n) for(i = 0;i < n;++i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n\nstruct rsqsegtree{\n  vector<int> t;\n  int re;\n  int n;\n  void use(int N){\n    re = 0; n = N;\n    int i, j;\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0] = 1 << i;\n    for(i = 1;i < t[0];++i)t[i] = re;\n    t[0] >>= 1;\n    return;\n  }\n  void update(int at, int data){\n    t[t[0] + at] += data;\n    int tmp;\n    for(int x = t[0] + at;x >= 2;x >>= 1)\n    t[x >> 1] = (t[(x >> 1) << 1] + t[((x >> 1) << 1) + 1]);\n    return;\n  }\n  int query(int l, int r, int k, int kl, int kr){\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    return query(l, r, k * 2, kl, (kl + kr) >> 1) + query(l, r, k * 2 + 1, (kl + kr) >> 1, kr);\n  }\n  int getsum(int l, int r){ return query(l, r, 1, 0, t[0]); }\n  void deb(void){\n    int x = 1;\n    t[0] *= 2;\n    printf(\"t[0] : %d\\n\", t[0]);\n    for(int i = 1;i < t[0];++i){\n      printf(\"%11d\", t[i]);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    t[0] /= 2;\n    return;\n  }\n};\n\nstruct query{\n  int q, y, l, r;\n};\nbool ysort(query qwe, query rty){\n  if(qwe.y != rty.y)return qwe.y < rty.y;\n  return qwe.q > rty.q;\n}\n\nrsqsegtree ST;\nquery Q[300000];\nvector<int> x;\nint qh = 0;\n\nint inv(int d){\n  int l = 0, r = x.size(), m;\n  for(;l + 1 < r;){\n    m = l + (r - l) / 2;\n    if(d == x[m])return m;\n    if(d > x[m])l = m;\n    else r = m;\n  }\n  return l;\n}\n\nsigned main(void){\n  int i, j;\n  int(n);\n  rep(i, n){\n    int4(x1, y1, x2, y2);\n    if(x1 == x2){\n      Q[qh++] = (query){1, min(y1, y2), x1, 0};\n      Q[qh++] = (query){-1, max(y1, y2), x1, 0};\n      x.pb(x1);\n    }else{\n      Q[qh++] = (query){0, y1, min(x1, x2), max(x1, x2)};\n      x.pb(x1);\n      x.pb(x2);\n    }\n  }\n  sort(Q, Q + qh, ysort);\n  sort(all(x));\n  x.erase(unique(all(x)), x.end());\n\n  ST.use(x.size());\n  int res = 0;\n  rep(i, qh){\n    if(Q[i].q == 0)res += ST.getsum(inv(Q[i].l), inv(Q[i].r) + 1);\n    else ST.update(inv(Q[i].l), Q[i].q);\n  }\n  printf(\"%d\\n\", res);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\nconst double EPS = 1e-9;\nusing namespace std;\nclass point {\npublic:\n\tdouble x, y;\n\tpoint(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tpoint operator - (point v) {\n\t\treturn point(x - v.x, y - v.y);\n\t}\n\tpoint operator + (point v) {\n\t\treturn point(x + v.x, y + v.y);\n\t}\n};\nclass segment {\npublic:\n\tpoint p1, p2;\n\tsegment(point p1, point p2) :p1(p1), p2(p2) {};\n};\nclass Vector {\npublic:\n\n\tdouble x, y;\n\tVector(double a, double  b) {\n\t\tx = a;\n\t\ty = b;\n\t};\n\tVector operator * (const Vector &v)const {\n\t\treturn Vector(x*v.x, y* v.y);\n\t}\n\tVector operator * (double a) {\n\t\treturn Vector(x * a, y * a);\n\t}\n\tVector operator - (Vector v) {\n\t\treturn Vector(x - v.x, y - v.y);\n\t}\n\tVector operator + (Vector v) {\n\t\treturn Vector(x + v.x, y + v.y);\n\t}\n};\ntypedef vector<Vector> polygon;\nclass circle {\npublic:\n\tpoint p;\n\tdouble r;\n\tcircle(point a, double b) : p(a), r(b) {};\n\n};\ninline double dot(Vector v1, Vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\ninline double squ(Vector v) {\n\treturn v.x*v.x + v.y*v.y;\n}\ninline double norm(Vector v) {\n\treturn sqrt(squ(v));\n}\ninline void printv(Vector v) {\n\tprintf(\"%.10f %.10f\\n\", v.x, v.y);\n}\ninline void printpp(pair<point, point> p) {\n\tprintf(\"%.7f %.7f %.7f %.7f\", p.first.x, p.first.y, p.second.x, p.second.y);\n}\ninline void printc(Vector v1, Vector v2) {\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", v1.x, v1.y, v2.x, v2.y);\n}\ninline void printpg(polygon pg, int min) {\n\tcout << pg.size() << endl;\n\tfor (int i = min; i < pg.size(); i++)\n\t\t//printf(\"%d %d\\n\", pg[i].x, pg[i].y);\n\t\tcout << pg[i].x << \" \" << pg[i].y << endl;\n\tfor(int i = 0; i < min; i++) cout << pg[i].x << \" \" << pg[i].y << endl;\n}\ninline Vector pro(Vector base, Vector v, Vector be) {\n\tdouble a = dot(base, v) / squ(base);\n\tVector v1 = base * a;\n\treturn v1 + be;\n}\ninline Vector ref(Vector v, Vector be) {\n\treturn (v - be)*2 + be;\n}\ninline double cross(Vector v1, Vector v2) {\n\treturn v1.x*v2.y - v1.y*v2.x;\n}\ninline int ccw(Vector v1, Vector v2, Vector v3) {\n\tVector a = v2 - v1;\n\tVector b = v3 - v1;\n\tif (cross(a, b) < 0.0) return -1;\n\telse if (cross(a, b) > 0.0) return 1;\n\telse if (dot(a, b) < 0.0) return -2;\n\telse if (dot(a, b) > squ(a)) return 2;\n\telse return 0;\n}\ninline int inter(Vector v1, Vector v2, Vector v3, Vector v4) {\n\treturn (ccw(v1, v2, v3) * ccw(v1, v2, v4) <= 0) && (ccw(v3, v4, v1) * ccw(v3, v4, v2) <= 0);\n}\ninline double disPP(Vector v1, Vector v2) {\n\treturn norm(v2 - v1);\n}\ninline double disLP(Vector v1, Vector v2, Vector v3) {\n\tVector a = v2 - v1;\n\tVector b = v3 - v1;\n\treturn fabs(cross(a, b) / norm(a));\n}\ninline double disSP(Vector v1, Vector v2, Vector v3) {\n\tVector a = v2 - v1;\n\tVector b = v3 - v1;\n\tVector c = v1 - v2;\n\tVector d = v3 - v2;\n\tif (dot(a, b) < 0.0) return disPP(v1, v3);\n\telse if (dot(c, d) < 0.0) return disPP(v2, v3);\n\telse return disLP(v1, v2, v3);\n}\ninline double disSS(Vector v1, Vector v2, Vector v3, Vector v4) {\n\tif (inter(v1, v2, v3, v4)) return 0;\n\tdouble a = disSP(v1, v2, v3);\n\tdouble b = disSP(v1, v2, v4);\n\tdouble c = disSP(v3, v4, v1);\n\tdouble d = disSP(v3, v4, v2);\n\treturn min(min(a, b), min(c, d));\n}\ninline Vector getcross(Vector v1, Vector v2, Vector v3, Vector v4) {\n\tVector v5 = pro(v2 - v1, v3 - v1, v1);\n\tVector v6 = pro(v2 - v1, v4 - v1, v1);\n\tdouble a = disPP(v3, v5);\n\tdouble b = disPP(v4, v6);\n\tVector vans = (v6 - v5)*a*(1 / (a + b)) + v5;\n\treturn vans;\n\n}\ninline pair<Vector, Vector> getccl(double r, Vector o, Vector v1, Vector v2) {\n\tVector ev = (v2 - v1)*(1 / norm(v2 - v1));\n\tVector pr = pro(v2 - v1, o - v1, v1);\n\tdouble l = sqrt(r *r - squ(o - pr));\n\tVector ans1 = ev * l + pr;\n\tVector ans2 = pr - ev * l;\n\tif (ans1.x > ans2.x) swap(ans1, ans2);\n\telse if (ans1.x == ans2.x)\n\t\tif (ans1.y > ans2.y) swap(ans1, ans2);\n\treturn make_pair(ans1, ans2);\n}\ninline pair<point, point> getccc(circle c1, circle c2) {\n\tVector v1(c2.p.x - c1.p.x, c2.p.y - c1.p.y);\n\tdouble dis = norm(v1);\n\tdouble a = acos((dis*dis + c1.r*c1.r - c2.r*c2.r) / (2 * c1.r*dis));\n\tdouble b = atan2(c2.p.y - c1.p.y, c2.p.x - c1.p.x);\n\tpoint pa(c1.r*cos(a + b), c1.r*sin(a + b));\n\tpoint pb(c1.r*cos(b - a), c1.r*sin(b -a));\n\tpoint ans1(c1.p + pa);\n\tpoint ans2(c1.p + pb);\n\tif (ans1.x > ans2.x || ((ans1.x == ans2.x) && (ans1.y > ans2.y))) swap(ans1, ans2);\n\treturn make_pair(ans1, ans2);\n}\nconst int num = 100000;\ninline bool lessX(const Vector &p1, const Vector &p2) {\n\treturn (p1.x < p2.x) || ((p1.x == p2.x) && (p1.y < p2.y));\n}\ninline polygon getpg(polygon o) {\n\tsort(o.begin(), o.end(), lessX);\n\tpolygon t, u;\n\tt.push_back(o[0]);\n\tt.push_back(o[1]);\n\tu.push_back(o[0]);\n\tu.push_back(o[1]);\n\tfor (int i = 2; i < o.size(); i++) {\n\t\tfor (int j = t.size(); (t.size() > 1) && (ccw(t[t.size() - 2], t[t.size() - 1], o[i]) == 1); j--)\n\t\t\tt.pop_back();\n\t\tt.push_back(o[i]);\n\t}\n\tfor (int i = 2; i < o.size(); i++) {\n\t\tfor (int j = u.size(); (u.size() > 1) && (ccw(u[u.size() - 2], u[u.size() - 1], o[i]) == -1); j--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(o[i]);\n\t}\n\treverse(t.begin(), t.end());\n\tfor (int i = 1; i < t.size() - 1; i++)\n\t\tu.push_back(t[i]);\n\treturn u;\n}\ninline int cont(polygon pg, Vector p) {\n\tint x = 0;\n\tVector v3(1, 1), v4(1, 1);\n\tfor (int i = 0; i < pg.size(); i++) {\n\t\tVector v1 = pg[i] - p;\n\t\tVector v2 = pg[(i + 1)%pg.size()] - p;\n\t\tif (((cross(v1, v2) == 0) && (dot(v1, v2) < 0.0)) || norm(v1) == 0 || norm(v2) == 0) return 1;\n\t\tif (v1.y > v2.y) swap(v1, v2);\n\t\tif ((cross(v1, v2) > 0.0) && v1.y < EPS && v2.y > EPS) x++;\n\t\tif (v3.y = 0 && v4.y == 0 && (v1.y == 0 || v2.y == 0)) x--;\n\t\tv3 = v1;\n\t\tv4 = v2;\n\t}\n\treturn (x % 2 == 0) ? 0 : 2;\n}\nconst int B = 0, L = 1, R = 2, T = 3;\nclass endpoint {\npublic:\n\tint so, id;\n\tpoint p;\n\tendpoint(point p, int a, int b) :p(p), so(a), id(b) {};\n\tbool operator < (const endpoint &ep) const {\n\t\tif (p.y == ep.p.y) return so < ep.so;\n\t\telse return p.y < ep.p.y;\n\t}\n};\nvector<endpoint> ep;\ninline int solve(vector<segment> s) {\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i].p1.y > s[i].p2.y) swap(s[i].p1, s[i].p2);\n\t\telse if (s[i].p1.y == s[i].p2.y && s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i].p1.y == s[i].p2.y) {\n\t\t\tep.push_back(endpoint(s[i].p1, L, i));\n\t\t\tep.push_back(endpoint(s[i].p2, R, i));\n\t\t}\n\t\telse {\n\t\t\tep.push_back(endpoint(s[i].p1, B, i));\n\t\t\tep.push_back(endpoint(s[i].p2, T, i));\n\t\t}\n\t}\n\tsort(ep.begin(),ep.end());\n\tset<double> st;\n\tint cnt = 0;\n\tst.insert(100000001);\n\tfor (int i = 0; i < ep.size(); i++) {\n\t\tif (ep[i].so == B) st.insert(ep[i].p.x);\n\t\telse if (ep[i].so == T) st.erase(ep[i].p.x);\n\t\telse if (ep[i].so == L) {\n\t\t\tset<double>::iterator b = lower_bound(st.begin(), st.end(), s[ep[i].id].p1.x);\n\t\t\tset<double>::iterator e = upper_bound(st.begin(), st.end(), s[ep[i].id].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n;\n\tvector<segment> s;\n\tdouble x0, y0, x1, y1;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf%lf%lf\", &x0, &y0, &x1, &y1);\n\t\ts.push_back(segment(point(x0, y0), point(x1, y1)));\n\t}\n\tcout << solve(s) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ld> pld;\ntypedef pair<pii, int> ppiii;\ntypedef pair<pii, ll> ppiil;\ntypedef pair<pll, ll> pplll;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<int>> vvi;\n#define rep(i, a, b) for (ll i=(a); i<(b); i++)\n#define rrep(i, a, b) for (ll i=(a); i>(b); i--)\n#define btoe(obj) (obj).begin(), (obj).end()\n#define pb push_back\n#define str to_string\n#define mkp make_pair\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n// void chmax(ll &a, ll b) { a = max(a, b); }\n// void chmin(ll &a, ll b) { a = min(a, b); }\ntemplate<typename T> inline bool chmax(T &x, T y) {return (y > x) ? x = y, true : false;}\ntemplate<typename T> inline bool chmin(T &x, T y) {return (y < x) ? x = y, true : false;}\n\ntemplate<typename T>\nvoid print(T out) {\n    cout << out << '\\n';\n}\n\nvoid print(ld out) {\n    cout << fixed << setprecision(12) << out << '\\n';\n}\n\ntemplate<typename T1, typename T2>\nvoid print(pair<T1, T2> out) {\n    cout << out.first << ' ' << out.second << '\\n';\n}\n\ntemplate<typename T>\nvoid print(vector<T> A) {\n    rep(i, 0, A.size()) {\n        cout << A[i];\n        cout << (i == A.size()-1 ? '\\n' : ' ');\n    }\n}\n\ntemplate<typename T>\nvoid print(set<T> S) {\n    vector<T> A(btoe(S));\n    print(A);\n}\n\nll sum(vector<ll> A) {\n    ll res = 0;\n    for (ll a: A) res += a;\n    return res;\n}\n\nll max(vector<ll> A) {\n    ll res = -INF;\n    for (ll a: A) chmax(res, a);\n    return res;\n}\n\nll min(vector<ll> A) {\n    ll res = INF;\n    for (ll a: A) chmin(res, a);\n    return res;\n}\n\nll sum(ll A[], int len) {\n    ll res = 0;\n    rep(i, 0, len) res += A[i];\n    return res;\n}\n\nll max(ll A[], int len) {\n    ll res = -INF;\n    rep(i, 0, len) chmax(res, A[i]);\n    return res;\n}\n\nll min(ll A[], int len) {\n    ll res = INF;\n    rep(i, 0, len) chmin(res, A[i]);\n    return res;\n}\n\nll toint(string s) {\n    ll res = 0;\n    for (char c : s) {\n        res *= 10;\n        res += (c - '0');\n    }\n    return res;\n}\n\nint toint(char c) {\n    return c - '0';\n}\n\nll pow(ll x, ll n, int mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res = (res * x) % mod;\n        }\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nll N, ax, ay, bx, by, ans;\nset<ll> S;\nvector<pair<pll, pll>> events;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N;\n    rep(i, 0, N) {\n        cin >> ax >> ay >> bx >> by;\n        if (ax == bx) {\n            // 向き補正\n            if (by < ay) swap(ay, by);\n            // 挿入：(y座標(始点), フラグ), (x座標(どっちでもいい), x座標(どっちでもいい)))\n            events.pb(mkp(mkp(ay, 1), mkp(ax, bx)));\n            // 削除：(y座標(終点), フラグ), (x座標(どっちでもいい), x座標(どっちでもいい)))\n            events.pb(mkp(mkp(by, 3), mkp(ax, bx)));\n\n        } else {\n            // 向き補正\n            if (bx < ax) swap(ax, bx);\n            // カウント：(y座標(どっちでもいい), フラグ), (x座標(始点), x座標(終点)))\n            events.pb(mkp(mkp(ay, 2), mkp(ax, bx)));\n        }\n    }\n    // Y座標順、同値は、挿入→カウント→削除、の順でソート\n    sort(btoe(events), [](const pair<pll, pll> &e1, const pair<pll, pll> &e2) { \n        if (e1.first.first == e2.first.first) {\n            return e1.first.second < e2.first.second;\n        } else {\n            return e1.first.first < e2.first.first;\n        }\n    });\n\n    S.insert(INF);\n    ans = 0;\n    for (auto event : events) {\n        // 挿入\n        if (event.first.second == 1) {\n            S.insert(event.second.first);\n        // カウント\n        } else if (event.first.second == 2) {\n            auto itr1 = S.lower_bound(event.second.first);\n            auto itr2 = S.upper_bound(event.second.second);\n            ans += distance(itr1, itr2);\n        // 削除\n        } else {\n            S.erase(event.second.first);\n        }\n    }\n    print(ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing P = pair<int,int>;\nconst int flag = 1e9;\n\ntemplate <typename T, typename F>\nclass SegTree{\n  int n; T uni; F f;\n  vector<T> dat;\npublic:\n  SegTree(int _n, F f, T uni) : f(f), uni(uni) {\n    n = 1;\n    while(n < _n) n *= 2;\n    dat = vector<T>(2*n,uni);\n  }\n  void set(int k, const T x) {\n    dat[k+n] = x;\n  }\n  void build() {\n    for(int i = n-1; i >= 0; i--) {\n      dat[i] = f(dat[2*i],dat[2*i+1]);\n    }\n  }\n  void update(int k, T x) {\n    k += n;\n    dat[k] += x;\n    while(k >>= 1){\n      dat[k] = f(dat[2*k],dat[2*k+1]);\n    }\n  }\n  T query(int a, int b) {\n    T l = uni, r = uni;\n    for(a += n, b += n; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) l = f(l,dat[a++]);\n      if(b & 1) r = f(dat[--b],r);\n    }\n    return f(l,r);\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  auto f = [](int a, int b){return a + b;};\n  SegTree<int,decltype(f)> st(2*n,f,0);\n  vector<int> px;\n  vector<P> qx;\n  vector<int> qy;\n  vector<P> event;\n  int k = 0, l = 0;\n  rep(i,n) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    px.push_back(x1); px.push_back(x2);\n    if(y1 == y2) {\n      event.push_back(P(y1,k++));\n      if(x1 > x2) swap(x1,x2);\n      qx.push_back(P(x1,x2));\n    } else {\n      if(y1 > y2) swap(y1,y2);\n      event.push_back(P(y1,-flag-l));\n      qy.push_back(x1);\n      l++;\n      event.push_back(P(y2,flag+l));\n      qy.push_back(x1);\n      l++;\n    }\n  }\n  sort(px.begin(),px.end());\n  map<int,int> m;\n  rep(i,2*n) m[px[i]] = i;\n  sort(event.begin(),event.end());\n  int ans = 0;\n  for(auto e : event) {\n    if(e.second >= flag) {\n      int a = e.second - flag;\n      st.update(m[qy[a]],-1);\n    } else if(e.second <= -flag) {\n      int a = -e.second - flag;\n      st.update(m[qy[a]],1);\n    } else {\n      int a = e.second;\n      ans += st.query(m[qx[a].first],m[qx[a].second]+1);\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\n \nint bit[1000000],bit_n;\nint sum(int i){\n  int s=0;\n  while(i){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=bit_n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\n \nstruct data{\n  int time,type,l,r;\n  bool operator < (const data &p)const{\n    return (time==p.time?type<p.type:time<p.time);\n  }\n};\n// 1 | add\n// 2 - check\n// 3 | delete\n \nint n;\nvector<data> t;\nvector<int> X;\nmap<int,int> mapx;\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n    X.push_back(a);\n    X.push_back(c);\n    if(a==c){\n      t.push_back((data){min(b,d),1,a,a});\n      t.push_back((data){max(b,d),3,a,a});\n    }else{\n      t.push_back((data){b,2,min(a,c),max(a,c)});\n    }\n  }\n  sort(t.begin(),t.end());\n  sort(X.begin(),X.end());\n  int c=2;\n  for(int i=0;i<(int)X.size();i++)\n    if(i==0||X[i]!=X[i-1])\n      mapx[X[i]]=c++;\n   \n  bit_n=n*2+1;\n  long long ans = 0;\n  for(int i=0;i<(int)t.size();i++){\n    data d=t[i];\n    d.l=mapx[d.l],d.r=mapx[d.r];\n    if(d.type==1){\n      add(d.l,1);\n    }else if(d.type==2){\n      long long A=sum(d.r)-sum(d.l-1);\n      ans+=A;\n    }else if(d.type==3){\n      add(d.l,-1);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals( A, B ) (fabs((A) - (B)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n    Point( double x = 0, double y = 0 ): x(x), y(y) {}\n    \n    Point operator + ( Point p ) { return Point( x + p.x, y + p.y ); }\n    Point operator - ( Point p ) { return Point( x - p.x, y - p.y ); }\n    Point operator * ( double a ) { return Point( a * x, a * y ); }\n    Point operator / ( double a ) { return Point( x / a, y / a ); }\n\n    double abs() { return sqrt( norm() ); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn ( x != p.x ) ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn equals( x, p.x ) && equals( y, p.y ); \n    }\n\n    double dot( Point a ) { return x * a.x + y * a.y; }\n    double cross( Point a ) { return x * a.y - y * a.x; }\n    double distance( Point a ) {\n\treturn (*this - a).abs();\n    }\n    double arg() {\n\treturn atan2( y, x );\n    }\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\nint contains( Polygon poly, Point p ) {\n    int n = poly.size();\n    int count = 0;\n    for ( int i = 0; i < n; i++ ) {\n\tVector a = poly[i] - p;\n\tVector b = poly[ ( i + 1 ) % n ] - p;\n\n\t// ???????????????\n\tif ( abs( a.cross( b ) ) < EPS && a.dot( b ) < EPS ) {\n\t    return 1;\n\t}\n\t// a.y???b.y??\\?????????????????????\n\tif ( a.y > b.y ) {\n\t    Vector tmp = a; a = b; b = tmp;\n\t}\n\t// ??£?????????????????´????????????????????´???\n\tif ( a.y < EPS && b.y > EPS && a.cross( b ) > EPS ) {\n\t    count++;\n\t}\n    }\n\n    return ( count % 2 ) ? 2 : 0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Line {\npublic:\n    Point p1, p2;\n    Line( Point p1 = Point(), Point p2 = Point() ): p1(p1), p2(p2){}\n    // ?????´????????????( cos = 0 )\n    bool isOrthogonal( Line a ) {\n\treturn equals( 0.0, (p1 - p2).dot( a.p1 - a.p2 ) );\n    }\n    // ??????????????????( sin = 0 )\n    bool isParallel( Line a ) {\n\treturn equals( 0.0, (p1 - p2).cross( a.p1 - a.p2 ) );\n    }\n\n    Point projection( Point p ) {\n\tVector v12 = p2 - p1;\n\tdouble r = v12.dot( p - p1 ) / v12.norm();\n\treturn p1 + v12 * r;\n    }\n\n    Point reflection( Point p ) {\n\treturn p + ( projection( p ) - p ) * 2.0;\n    }\n\n    double distance( Point p ) {\n\tVector v12 = this->p2 -this->p1;\n\tVector v10 = p - this->p1;\n\t\n\treturn abs( v12.cross( v10 ) / v12.abs() );\n    }\n\n    double distanceSP( Point p ) {\n\tif ( (p - this->p1).dot( this->p2 - this->p1 ) < 0.0 ) {\n\t    return this->p1.distance( p );\n\t} else if ( (p - this->p2).dot( this->p1 - this->p2 ) < 0.0 ) {\n\t    return this->p2.distance( p );\n\t}\n\telse {\n\t    return distance( p );\n\t}\n    }\n\n    int ccw( Point p ) {\n\tVector a = p2 - p1;\n\tVector b = p - p1;\n\tif ( a.cross( b ) > EPS ) return COUNTER_CLOCKWISE;\n\telse if ( a.cross( b ) < -EPS ) return CLOCKWISE;\n\telse if ( a.dot( b ) < -EPS ) return ONLINE_BACK;\n\telse if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\telse return ON_SEGMENT;\n    }\n\n    bool intersect( Line l ) {\n\treturn ( ( ccw( l.p1 ) * ccw( l.p2 ) <= 0 && l.ccw( p1 ) * l.ccw( p2 ) <= 0 ) );\n    }\n\n    Point crossPoint( Line l ) {\n\tVector base = p2 - p1;\n\tVector v1 = l.p1 - p1;\n\tVector v2 = l.p2 - p1;\n\tdouble d1 = base.cross( v1 );\n\tdouble d2 = base.cross( v2 );\t\n\tdouble t = d1 / ( d1 + d2 );\n\n\treturn l.p1 + ( l.p2 - l.p1 ) * t;\n    }\n};\n\ntypedef Line Segment;\n\ntypedef enum {\n    EP_BOTTOM,\n    EP_LEFT,\n    EP_RIGHT,\n    EP_TOP,\n} PointType;\n\nclass EndPoint {\npublic:\n    Point p;\n    int id;\n    PointType type;\n    EndPoint() {}\n    EndPoint( Point p, int id, PointType type ): p(p), id(id), type(type) {}\n\n    bool operator < ( const EndPoint &ep ) const {\n\tif ( p.y != ep.p.y ) return ( p.y < ep.p.y );\n\telse return ( type < ep.type );\n    }\n};\n\n#define MAX_N (100010)\n\nSegment S[MAX_N];\n\nEndPoint EP[MAX_N << 1];\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    \n    for ( int i = 0; i < n; i++ ) {\n\tPoint p1, p2;\n\tscanf(\"%lf %lf %lf %lf\", &p1.x, &p1.y, &p2.x, &p2.y);\n\tS[i] = ( p1 < p2 ) ? Segment( p1, p2 ) : Segment( p2, p1 );\n\tif ( p1.y == p2.y ) {\t// ?°´???\n\t    EndPoint ep0 = EndPoint( S[i].p1, i, EP_LEFT );\n\t    EndPoint ep1 = EndPoint( S[i].p2, i, EP_RIGHT );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n\telse {\t\t\t// ?????´\n\t    EndPoint ep0 = EndPoint( S[i].p1, i, EP_BOTTOM );\n\t    EndPoint ep1 = EndPoint( S[i].p2, i, EP_TOP );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n    }\n    \n    sort(EP, EP + (n << 1));\n\n    set<int> T;\t\t// ????????¢?´¢??¨\n    //T.insert( 1000000001 );\n    int ans = 0;\n    for ( int i = 0; i < (n<<1); i++ ) {\n\tEndPoint ep = EP[i];\n\tif ( ep.type == EP_BOTTOM ) {\n\t    T.insert( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_TOP ) {\n\t    T.erase( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_LEFT ) {\n\t    Segment s = S[ep.id];\n\t    set<int>::iterator l = lower_bound( T.begin(), T.end(), (int)s.p1.x );\n\t    set<int>::iterator u = upper_bound( T.begin(), T.end(), (int)s.p2.x );\n\t    ans += distance( l, u );\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define lson l, mid, rt << 1\n#define rson mid + 1, r, rt << 1 | 1\nusing namespace std;\nconst ll N = 5e5 + 100;\nll num[N << 2], sum[N << 2], s[N];\nstruct poll {\n    ll flag;\n    ll x, y;\n    poll (){}\n    poll (ll _x, ll _y, ll _flag) {\n        x = _x, y = _y, flag = _flag;\n    }\n    void input () {\n        scanf (\"%lld %lld\", &x, &y);\n    }\n    bool operator < (const poll &b) const {\n        return x < b.x || (x == b.x && y < b.y);\n    }\n} ;\nstruct line {\n    ll y, flag;\n    poll s, e;\n    void input () {\n        s.input (), e.input ();\n    }\n} ps[N << 2];\nll cmp (line a, line b) {\n    return a.y < b.y || (a.y == b.y && a.flag < b.flag);\n}\ninline void F (ll rt) {\n    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];\n}\nvoid update (ll pos, ll k, ll l, ll r, ll rt) {\n    if (l == r) {\n        sum[rt] += k;\n        return;\n    }\n    ll mid = l + r >> 1;\n    if (pos <= mid) update (pos, k, lson);\n    else update (pos, k, rson);\n    F (rt);\n}\nll query (ll L, ll R, ll l, ll r, ll rt) {\n    if (L <= l && r <= R) return sum[rt];\n    ll mid = l + r >> 1, ans = 0;\n    if (L <= mid) ans += query (L, R, lson);\n    if (R > mid) ans += query (L, R, rson);\n    return ans;\n}\nint main () {\n//    freopen (\"in.txt\", \"r\", stdin);\n    ll n, v = 0, ans = 0;\n    cin >> n;\n    ll temp = n;\n    for (ll i = 0; i < n; i++) ps[i].input (), s[v++] = ps[i].s.x, s[v++] = ps[i].s.y, s[v++] = ps[i].e.x, s[v++] = ps[i].e.y;\n    sort (s, s + v);\n//    cout << endl;\n    ll len = unique (s, s + v) - s;\n    for (ll i = 0, flag; i < n; i++) {\n        if (ps[i].e < ps[i].s) swap (ps[i].s, ps[i].e);\n//        cout << ps[i].s.x << ' ' << ps[i].s.y << ' ' << ps[i].e.x << ' ' << ps[i].e.y << endl;\n        if (ps[i].e.x == ps[i].s.x) {\n            ps[i].flag = -1;\n            ps[i].y = ps[i].s.y;\n\n            ps[temp].flag = 1;\n            ps[temp].s.x = ps[i].s.x;\n            ps[temp].y = ps[i].e.y;\n            temp++;\n        } else {\n            ps[i].flag = 0;\n            ps[i].y = ps[i].s.y;\n        }\n    }\n    sort (ps, ps + temp, cmp);\n    for (ll i = 0; i < temp; i++) {\n        if (ps[i].flag) {\n            ll u = lower_bound(s, s + len, ps[i].s.x) - s + 1;\n//            cout << \"****\" << ps[i].s.x << ' ' << ps[i].y << ' ' << u << ' ' << ps[i].flag << endl;\n            if (ps[i].flag > 0) update (u, -1, 1, len, 1);\n            else update (u, 1, 1, len, 1);\n        } else {\n//            cout << ps[i].s.x << ' ' << ps[i].e.x << endl;\n            ll a = lower_bound(s, s + len, ps[i].s.x) - s + 1;\n            ll b = lower_bound(s, s + len, ps[i].e.x) - s + 1;\n            ans += query (a, b, 1, len, 1);\n//        cout << ans << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\n  \nint bit[1000000],bit_n;\nint sum(int i){\n  int s=0;\n  while(i){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=bit_n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\n  \nstruct data{\n  int time,type,l,r;\n  bool operator < (const data &p)const{\n    return (time==p.time?type<p.type:time<p.time);\n  }\n};\n// 1 | add\n// 2 - check\n// 3 | delete\n  \nint n;\nvector<data> t;\nvector<int> X;\nmap<int,int> mapx;\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n    X.push_back(a);\n    X.push_back(c);\n    if(a==c){\n      t.push_back((data){min(b,d),1,a,a});\n      t.push_back((data){max(b,d),3,a,a});\n    }else{\n      t.push_back((data){b,2,min(a,c),max(a,c)});\n    }\n  }\n  sort(t.begin(),t.end());\n  sort(X.begin(),X.end());\n  int c=2;\n  for(int i=0;i<(int)X.size();i++)\n    if(i==0||X[i]!=X[i-1])\n      mapx[X[i]]=c++;\n    \n  bit_n=n*2+1;\n  long long ans = 0;\n  for(int i=0;i<(int)t.size();i++){\n    data d=t[i];\n    d.l=mapx[d.l],d.r=mapx[d.r];\n    if(d.type==1){\n      add(d.l,1);\n    }else if(d.type==2){\n      long long A=sum(d.r)-sum(d.l-1);\n      ans+=A;\n    }else if(d.type==3){\n      add(d.l,-1);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long bit[1000000], _size, n, cnt, __X1[200000], __Y1[200000], __X2[200000], __Y2[200000];\nvector<long long>XX, YY, _XX, _YY; vector<tuple<long long, long long, long long>>vec;\nvoid add(long long p, long long x) { while (p <= _size) { bit[p] += x; p += p&-p; } }\nlong long sum(long long p) { int _sum = 0; while (p >= 1) { _sum += bit[p]; p -= p&-p; }return _sum; }\nlong long __sum(long long l, long long r) { return sum(r) - sum(l - 1); }\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++)cin >> __X1[i] >> __Y1[i] >> __X2[i] >> __Y2[i];\n\tfor (int i = 0; i < n; i++) { XX.push_back(__X1[i]); XX.push_back(__X2[i]); YY.push_back(__Y1[i]); YY.push_back(__Y2[i]); }\n\tsort(XX.begin(), XX.end()); sort(YY.begin(), YY.end());\n\tfor (int i = 0; i < XX.size(); i++) { if (i == 0 || XX[i - 1] != XX[i])_XX.push_back(XX[i]); if (i == 0 || YY[i - 1] != YY[i])_YY.push_back(YY[i]); }\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos1 = lower_bound(_XX.begin(), _XX.end(), __X1[i]) - _XX.begin(), pos2 = lower_bound(_YY.begin(), _YY.end(), __Y1[i]) - _YY.begin();\n\t\tint pos3 = lower_bound(_XX.begin(), _XX.end(), __X2[i]) - _XX.begin(), pos4 = lower_bound(_YY.begin(), _YY.end(), __Y2[i]) - _YY.begin();\n\t\t__X1[i] = pos1; __Y1[i] = pos2; __X2[i] = pos3; __Y2[i] = pos4; if (__X1[i] > __X2[i])swap(__X1[i], __X2[i]); if (__Y1[i] > __Y2[i])swap(__Y1[i], __Y2[i]);\n\t\tif (__X1[i] == __X2[i]) { vec.push_back(make_tuple(__Y1[i], 1LL << 60, __X1[i])); vec.push_back(make_tuple(__Y2[i], -1LL << 60, __X1[i])); }\n\t\telse { vec.push_back(make_tuple(__Y1[i], __X1[i], __X2[i])); }\n\t}sort(vec.begin(), vec.end()); _size = XX.size() + 10;\n\tfor (int i = 0; i < vec.size(); i++) { if (abs(get<1>(vec[i])) >= 1LL << 50)add(get<2>(vec[i]), get<1>(vec[i]) / (1LL << 60)); else { cnt += __sum(get<1>(vec[i]), get<2>(vec[i])); } }\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct event{\n    int type;//0:Y????????????????????? 1:X????????????????????????????§? 2:??????\n    int x1,y1,x2,y2;\n    event(int type, int x1, int y1, int x2, int y2){\n        this->type=type, this->x1=x1, this->y1=y1, this->x2=x2, this->y2=y2;\n    }\n    bool operator<(const event&b) const{\n        if(type!=b.type){\n            return type<b.type;\n        }else{\n            return y1==b.y1?y2<b.y2:y1<b.y1;\n        }\n    }\n    bool operator>(const event&b) const{\n        if(type!=b.type){\n            return type>b.type;\n        }else{\n            return y1==b.y1?y2>b.y2:y1>b.y1;\n        }\n    }\n};\n\nint main(){\n    int n,x1,x2,y1,y2;\n    cin >> n;\n    vector<pair<int,event>> E;//<x??§?¨?,event>\n    while(n--){\n        cin >> x1 >> y1 >> x2 >> y2;\n        if(y1==y2){//x????????????\n            if(x1<x2){\n                E.push_back(pair<int,event>(x1,event(1,x1,y1,x2,y2)));\n                E.push_back(pair<int,event>(x2,event(2,x1,y1,x2,y2)));\n            }else{\n                E.push_back(pair<int,event>(x2,event(1,x2,y2,x1,y1)));\n                E.push_back(pair<int,event>(x1,event(2,x2,y2,x1,y1)));\n            }\n        }else{//y????????????\n            if(y1<y2){\n                E.push_back(pair<int,event>(x1,event(0,x1,y1,x2,y2)));\n            }else{\n                E.push_back(pair<int,event>(x1,event(0,x2,y2,x1,y1)));\n            }\n        }\n    }\n    sort(E.begin(),E.end());\n    map<int,int> M;\n    int c=0;\n    for(auto i : E){\n        switch(i.second.type){\n            case 0:\n                for(auto ite=M.lower_bound(i.second.y1);ite!=M.upper_bound(i.second.y2);++ite) c++; \n                break;\n            case 1:\n                M[i.second.y1]=1;\n                break;\n            case 2:\n                M.erase(i.second.y1);\n                break;\n        }\n    }\n    cout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n \ntypedef pair<int,int> pii;\n \nconst int INF = 1000000001;\n \nint main(){\n  int n;\n  vector<pair<int,pii> > event;\n  set<int> list;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    int x1,y1,x2,y2;\n    scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n    if(y1==y2){\n      event.push_back(make_pair(min(x1,x2),pii(-INF,y1)));\n      event.push_back(make_pair(max(x1,x2),pii(INF,y1)));\n    }else if(x1==x2){\n      event.push_back(make_pair(x1,pii(min(y1,y2),max(y1,y2))));\n    }\n  }\n  sort(event.begin(),event.end());\n  int ans = 0;\n  for(int i=0;i<event.size();i++){\n    int y1 = event[i].second.first, y2 = event[i].second.second;\n    if(y1==-INF) list.insert(y2);\n    else if(y1==INF) list.erase(y2);\n    else ans += distance(list.lower_bound(y1),list.upper_bound(y2));\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<iterator>\n\nstruct evp\n{\n\tint y, x_l, x_r;\n\tint kind;\n\tbool operator < (const evp &E) const\n\t{\n\t\tif(y != E.y) return y < E.y;\n\t\treturn kind < E.kind;\n\t}\n};\n\nevp init(int co_y, int co_x_l, int co_x_r, int kd)\n{\n\tevp E;\n\tE.y = co_y, E.x_l = co_x_l, E.x_r = co_x_r, E.kind = kd;\n\treturn E;\n}\n\nint main()\n{\n\tint i, n;\n\tint x1, y1, x2, y2;\n\tscanf(\"%d\", &n);\n\tevp *MG;\n\tMG = new evp [2 * n];\n\tint ev_n = 0;\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\tif(y1 != y2){\n\t\t\tif(y1 > y2) swap(y1, y2);\n\t\t\tMG[ev_n] = init(y1, x1, -1, 0);\n\t\t\tMG[ev_n + 1] = init(y2, x2, -1, 2);\n\t\t\tev_n += 2;\n\t\t}else{\n\t\t\tif(x1 > x2) swap(x1, x2);\n\t\t\tMG[ev_n] = init(y1, x1, x2, 1);\n\t\t\tev_n++;\n\t\t}\n\t}\n\tsort(MG, MG + ev_n);\n\n\tset<int> A;\n\tint count = 0;\n\n\tfor(i = 0; i < ev_n; i++){\n\t\tswitch(MG[i].kind){\n\t\t\tcase 0:\n\t\t\t\tA.insert(MG[i].x_l);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tA.erase(MG[i].x_l);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcount += distance(A.lower_bound(MG[i].x_l), A.upper_bound(MG[i].x_r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", count);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ntemplate<typename T, typename E, typename F, typename G>\nstruct SegTree{\n    int sz = 1, seq_sz;\n    T et;\n    F f;\n    G g;\n    vector<T> node;\n\n    SegTree(int sz_, T et, F f, G g): seq_sz(sz_), et(et), f(f), g(g){\n        while(sz<sz_) sz <<= 1;\n        node.resize(sz<<1, et);\n    }\n\n    void build(vector<T> &a){\n        rep(i, a.size()) node[i+sz] = a[i];\n        rFor(i, sz, 1) node[i] = f(node[i<<1], node[(i<<1)+1]);\n    }\n\n    void build(T x){\n        rep(i, seq_sz) node[i+sz] = x;\n        rFor(i, sz, 1) node[i] = f(node[i<<1], node[(i<<1)+1]);\n    }\n\n    void update(int i, E x){\n        i += sz;\n        node[i] = g(node[i], x);\n        i >>= 1;\n        while(i){\n            node[i] = f(node[i<<1], node[(i<<1)+1]);\n            i >>= 1;\n        }\n    }\n\n    T query(int l, int r){\n        T vl = et, vr = et;\n        for(l+=sz, r+=sz; l<r; l>>=1, r>>=1){\n            if(l&1) vl = f(vl, node[l++]);\n            if(r&1) vr = f(node[--r], vr);\n        }\n        return f(vl, vr);\n    }\n\n    int search_left(int l, const T val, function<bool(T, T)> cmp, function<bool(T, T)> check){\n        T sum = et;\n        for(l+=sz; ; l>>=1){\n            if(check(f(sum, node[l]), val)){\n                while(l < sz){\n                    if(check(f(sum, node[l<<1]), val)) l <<= 1;\n                    else{\n                        sum = f(sum, node[l<<1]);\n                        l = (l<<1) + 1;\n                    }\n                }\n                return l-sz;\n            }\n            if(__builtin_popcount(l+1) == 1) return seq_sz;\n            if(l&1) sum = f(sum, node[l++]);\n        }\n    }\n\n    int search_right(int r, const T val, function<bool(T, T)> cmp, function<bool(T, T)> check){\n        T sum = et;\n        for(r+=sz; ; r>>=1){\n            if(check(f(sum, node[r]), val)){\n                while(r < sz){\n                    if(check(f(node[(r<<1)+1], sum), val)) r = (r<<1) + 1;\n                    else{\n                        sum = f(node[(r<<1)+1], sum);\n                        r<<=1;\n                    }\n                }\n                return r-sz;\n            }\n            if(__builtin_popcount(r) == 1) return -1;\n            if(!(r&1)) sum = f(node[r--], sum);\n        }\n    }\n\n    int lower_bound_left(int l, const T val, function<bool(T, T)> cmp=less<>()){\n        auto check = [&cmp](auto a, auto b){return !cmp(a, b);};\n        return search_left(l, val, cmp, check);\n    }\n\n    int upper_bound_left(int l, const T val, function<bool(T, T)> cmp=less<>()){\n        auto check = [&cmp](auto a, auto b){return cmp(b, a);};\n        return search_left(l, val, cmp, check);\n    }\n\n    int lower_bound_right(int l, const T val, function<bool(T, T)> cmp=greater<>()){\n        auto check = [&cmp](auto a, auto b){return !cmp(b, a);};\n        return search_right(l, val, cmp, check);\n    }\n\n    int upper_bound_right(int l, const T val, function<bool(T, T)> cmp=greater<>()){\n        auto check = [&cmp](auto a, auto b){return cmp(a, b);};\n        return search_right(l, val, cmp, check);\n    }\n};\n\nstruct seg_v{\n    int x, sy, ty;\n    seg_v(int x, int s, int t): x(x), sy(s), ty(t){}\n};\n\nstruct seg_h{\n    int y, sx, tx;\n    seg_h(int y, int s, int t): y(y), sx(s), tx(t){}\n};\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<seg_v> segv;\n    vector<int> vy;\n    auto cmp1 = [](const seg_h &a, const seg_h &b){return a.sx > b.sx;};\n    auto cmp2 = [](const seg_h &a, const seg_h &b){return a.tx > b.tx;};\n    priority_queue<seg_h, vector<seg_h>, decltype(cmp1)> que1(cmp1);\n    priority_queue<seg_h, vector<seg_h>, decltype(cmp2)> que2(cmp2);\n    rep(_, n){\n        int sx, sy, tx, ty;\n        scanf(\"%d%d%d%d\", &sx, &sy, &tx, &ty);\n        vy.push_back(sy); vy.push_back(ty);\n        if(sx == tx){\n            segv.push_back({sx, min(sy, ty), max(sy, ty)});\n        }\n        else{\n            que1.push({ty, min(sx, tx), max(sx, tx)});\n        }\n    }\n    sort(vy.begin(), vy.end());\n    vy.erase(unique(vy.begin(), vy.end()), vy.end());\n    SegTree<lint, lint, decltype(plus<>()), decltype(plus<>())> st(vy.size(), 0, plus<>(), plus<>());\n    sort(segv.begin(), segv.end(), [](const seg_v &a, const seg_v &b){return a.x < b.x;});\n\n    lint ans = 0;\n    for(auto sv: segv){\n        while(!que1.empty() && que1.top().sx <= sv.x){\n            auto tmp = que1.top();\n            que1.pop();\n            int idx = lower_bound(vy.begin(), vy.end(), tmp.y) - vy.begin();\n            st.update(idx, 1);\n            que2.push(tmp);\n        }\n        while(!que2.empty() && que2.top().tx < sv.x){\n            auto tmp = que2.top();\n            que2.pop();\n            int idx = lower_bound(vy.begin(), vy.end(), tmp.y) - vy.begin();\n            st.update(idx, -1);\n        }\n\n        int l = lower_bound(vy.begin(), vy.end(), sv.sy) - vy.begin();\n        int r = lower_bound(vy.begin(), vy.end(), sv.ty) - vy.begin();\n        ans += st.query(l, r+1);\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int INF = 1111111111;\n\n#define equals(a, b) (fabs((a)-(b)) < EPS)\nconst double EPS = (1e-10);\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        } else {\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * MAX_N];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (S[i].p1.y == S[i].p2.y) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p1.y) {\n            swap(S[i].p1, S[i].p2);\n        }\n\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + 2*n);\n    set<int> BT;\n    BT.insert(INF);\n    int cnt = 0;\n\n    for (int i = 0; i < 2*n; i++) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        } else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        } else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void) {\n    int n; cin >> n;\n\n    double x1, y1, x2, y2;\n    vector<Segment> S;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n\n    cout << manhattanIntersection(S) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define all(c) (c).begin(),(c).end()\n#define x second\n#define y first\n#define a first\n#define b second\n#define PUSH 0\n#define SUM 1\n#define POP 2\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int>piii;\ntypedef pair<pii,pii> segment;\n\nconst int MAX_N = 1<<17;\nint n,dat[2*MAX_N];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  fill(dat,dat+2*MAX_N,0);\n}\n\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n  }\n}\n\nint sum(int a,int b,int k=0,int l=0,int r=n){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return dat[k];\n  \n  int m=(l+r)/2;\n  int vl=sum(a,b,k*2+1,l,m);\n  int vr=sum(a,b,k*2+2,m,r);\n  return vl+vr;\n}\n\nmap<int,int> xmp;\n\nstruct Q{\n  int y,x1,x2,q;\n  Q(){}\n  Q(int y,int x1,int x2,int q):y(y),x1(x1),x2(x2),q(q){}\n};\n\nbool cmp(Q p,Q q){\n  if(p.y!=q.y)return p.y<q.y;\n  return p.q<q.q;\n}\n\nint main(void){\n\n  int m;\n  cin >> m;\n  \n  vector<int>xv;\n  vector<segment>v(m);\n  vector<Q>query;\n  \n  for(int i=0;i<m;i++){\n    cin >> v[i].a.x >> v[i].a.y >> v[i].b.x >> v[i].b.y;\n\n    if(v[i].a.x>v[i].b.x)swap(v[i].a.x,v[i].b.x);\n    if(v[i].a.y>v[i].b.y)swap(v[i].a.y,v[i].b.y);\n\n    xv.push_back(v[i].a.x);\n    xv.push_back(v[i].b.x);\n  }\n  \n  sort(all(xv));\n\n  for(int i=0;i<m;i++){\n    if(v[i].a.x==v[i].b.x){\n      query.push_back(Q(v[i].a.y,v[i].a.x,-1,PUSH));\n      query.push_back(Q(v[i].b.y,v[i].b.x,-1,POP));\n    }\n    if(v[i].a.y==v[i].b.y){\n      query.push_back(Q(v[i].a.y,v[i].a.x,v[i].b.x,SUM));\n    } \n  }\n  \n  sort(all(query),cmp);\n\n  xv.erase(unique(all(xv)),xv.end());\n\n  for(int i=0;i<xv.size();i++)xmp[xv[i]]=i;\n\n  init(xv.size());\n  \n  int cnt=0;\n  for(int i=0;i<query.size();i++){\n    if(query[i].q==PUSH)update(xmp[query[i].x1],1);\n    if(query[i].q==POP)update(xmp[query[i].x1],0);\n    if(query[i].q==SUM)cnt+=sum(xmp[query[i].x1],xmp[query[i].x2]+1);\n  }\n  cout << cnt << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct STsum{\nprivate:\n    int n;\n    vector<int> dat;\npublic:\n    STsum(int siz){\n        n = 1;\n        while(n < siz)   n *= 2;\n        dat.resize(2*n-1, 0);\n    }\n\n    void update(int x, int val){\n        x += (n-1);\n        dat[x] += val;\n        while(x > 0){\n            x = (x-1)/2;\n            dat[x] = dat[2*x+1]+dat[2*x+2];\n        }\n    }\n    \n    // focus on k-th node, who controls [l, r)\n    int query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0)   r = n;\n        if(r <= a || b <= l)    return 0;\n        if(a <= l && r <= b)    return dat[k];\n\n        int lx = query(a, b, 2*k+1, l, (l+r)/2);\n        int rx = query(a, b, 2*k+2, (l+r)/2, r);\n        return lx+rx;\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<int> xax, ax(n), ay(n), bx(n), by(n);\n    for(int i = 0; i < n; i++){\n        cin >> ax[i] >> ay[i] >> bx[i] >> by[i];\n        xax.push_back(ax[i]);  xax.push_back(bx[i]);\n    }\n    sort(xax.begin(), xax.end());\n    xax.erase(unique(xax.begin(),xax.end()),xax.end());\n    auto f = [&](int val)->int{\n        return lower_bound(xax.begin(),xax.end(),val)-xax.begin();\n    };\n\n    STsum seg(xax.size()+1);\n    vector<pair<pair<int,int>, int>> vp;\n    for(int i = 0; i < n; i++){\n        if(ax[i] == bx[i]){\n            vp.push_back({{min(ay[i],by[i]), 0}, i});\n            vp.push_back({{max(ay[i],by[i]), 2}, i});\n        }else if(ay[i] == by[i]){\n            vp.push_back({{ay[i], 1}, i});\n        }\n    }\n    sort(vp.begin(), vp.end());\n    int ans = 0;\n    for(auto p : vp){\n        if(p.first.second == 0){\n            seg.update(f(ax[p.second]), 1);\n        }else if(p.first.second == 2){\n            seg.update(f(ax[p.second]), -1);\n        }else if(p.first.second == 1){\n            ans += seg.query(f(min(ax[p.second],bx[p.second])), f(max(ax[p.second],bx[p.second]))+1);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\n#define MIN (1e-10)\n#define equal(a,b) (abs((a)-(b))<MIN)\n#define v2 ten\n#define chokusen senbun\n#define tenten senbun\n#define takaku vec<ten>\nusing namespace std;\nvoid solve();\n\nstruct pea {\n\tll f, s;\n\tbool operator<(const pea &p)const {\n\t\treturn f != p.f ? f < p.f : s < p.s;\n\t};\n};\nstruct tri {\n\tll f, s, t;\n\tbool operator<(const tri &p)const {\n\t\tif (f != p.f)return f < p.f;\n\t\tif (s != p.s)return s < p.s;\n\t\treturn t < p.t;\n\t};\n};\nclass ten {\npublic:\n\tld x, y;\n\n\tten operator+(ten p) { return { x + p.x,y + p.y }; }\n\tten operator-(ten p) { return { x - p.x,y - p.y }; }\n\tten operator*(ld k) { return { k*x,k*y }; }\n\tten operator/(ld k) { return { x / k,y / k }; }\n\n\tld abs() { return sqrt(abs2()); }\n\tld abs2() { return x * x + y * y; };\n\n\tbool operator<(const ten &p)const { return x != p.x ? x < p.x : y < p.y; };\n\tbool operator==(const ten &p)const {\n\t\treturn (-MIN < x - p.x) && (x - p.x < MIN) && (-MIN < y - p.y) && (y - p.y < MIN);\n\t};\n\n\tld naiseki(v2 b) { return x*b.x + y*b.y; }\n\tld gaiseki(v2 b) { return x*b.y - y*b.x; }\n};\nstruct senbun { ten p1, p2; };\nstruct en { ten o; ld r; };\n\n//互いに素な集合\nclass ufset {\npublic:\n\tvll rank, p;\n\tufset(ll n) {\n\t\trank.resize(n, 0);\n\t\tp.resize(n, 0);\n\t\trep(i, 0, n)make(i);\n\t}\n\tvoid reset(ll n) {\n\t\trank.resize(n, 0);\n\t\tp.resize(n, 0);\n\t\trep(i, 0, n)make(i);\n\t}\n\tvoid make(ll i) {\n\t\tp[i] = i;\n\t\trank[i] = 0;\n\t}\n\tbool same(ll i, ll j) { return find(i) == find(j); }\n\tvoid unite(ll i, ll j) { link(find(i), find(j)); }\n\tvoid link(ll i, ll j) {\n\t\tif (rank[i] > rank[j])p[j] = i;\n\t\telse {\n\t\t\tp[i] = j;\n\t\t\tif (rank[i] == rank[j])rank[j]++;\n\t\t}\n\t}\n\tll find(ll i) {\n\t\tif (p[i] != i)p[i] = find(p[i]);\n\t\treturn p[i];\n\t}\n};\n\n//nCk(mod p)\nclass nck {\npublic:\n\tll NUM, p;\n\tvll fac, finv, inv;\n\tnck(ll maxn, ll mod = MOD) {\n\t\tNUM = maxn + 1;\n\t\tp = mod;\n\t\tfac.resize(NUM);\n\t\tfinv.resize(NUM);\n\t\tinv.resize(NUM);\n\t\tfac[0] = fac[1] = 1;\n\t\tfinv[0] = finv[1] = 1;\n\t\tinv[1] = 1;\n\t\trep(i, 2, NUM) {\n\t\t\tfac[i] = fac[i - 1] * i%p;\n\t\t\tinv[i] = p - inv[p%i] * (p / i) % p;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % p;\n\t\t}\n\t}\n\tll c(ll n, ll k) { return fac[n] * (finv[k] * finv[n - k] % p) % p; }\n};\n\n//最大公約数\nll gcd(ll n, ll m) {\n\tll k = n % m;\n\twhile (k != 0) { n = m; m = k; k = n % m; }\n\treturn m;\n}\nll gcd(vector<ll> a) {\n\trep(i, 1, a.size()) {\n\t\tll k = a[i - 1] % a[i];\n\t\twhile (k != 0) {\n\t\t\ta[i - 1] = a[i];\n\t\t\ta[i] = k;\n\t\t\tk = a[i - 1] % a[i];\n\t\t}\n\t}\n\treturn a.back();\n}\n\n//最小公倍数\nll lcm(ll n, ll m) {\n\tll t = n * m, k = n % m;\n\twhile (k != 0) { n = m; m = k; k = n % m; }\n\treturn t / m;\n}\nll lcm(vector<ll> a) {\n\tll n;\n\trep(i, 1, a.size()) {\n\t\tn = a[i - 1] * a[i];\n\t\tll k = a[i - 1] % a[i];\n\t\twhile (k != 0) {\n\t\t\ta[i - 1] = a[i];\n\t\t\ta[i] = k;\n\t\t\tk = a[i - 1] % a[i];\n\t\t}\n\t\tn /= a[i];\n\t\ta[i] = n;\n\t}\n\treturn n;\n}\n\n//a^b(mod p)\nll pow2(ll a, ll b, ll p = MOD) {\n\tif (b == -1)return pow2(a, p - 2);\n\tll res = 1;\n\tif (b > 0) {\n\t\tres = pow2(a, b / 2);\n\t\tif (b % 2 == 0)res = res * res%p;\n\t\telse res = res * res%p*a%p;\n\t}\n\treturn res;\n}\n\n//トポロジカルソート\nvoid tsort(const vec<vll> &c, vll &a) {\n\tll n = c.size();\n\tvll p(n, 0);\n\trep(i, 0, n)rep(j, 0, c[i].size())p[c[i][j]]++;\n\trep(i, 0, n)if (p[i] == 0) {\n\t\tdeque<ll> d; d.pub(i);\n\t\twhile (!d.empty()) {\n\t\t\tll j = d.front(); d.pof();\n\t\t\ta.pub(j);\n\t\t\trep(k, 0, c[j].size()) {\n\t\t\t\tll l = c[j][k];\n\t\t\t\tp[l]--;\n\t\t\t\tif (p[l] == 0) {\n\t\t\t\t\tp[l] = -1;\n\t\t\t\t\td.pub(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//深さ優先探索\nvec<bool> seen;\nvoid dfs(const vec<vll> &c, ll i = 0) {\n\tseen[i] = true;\n\trep(j, 0, c[i].size()) {\n\t\tif (!seen[c[i][j]])dfs(c, c[i][j]);\n\t}\n}\n\n//最小全域木\nll kruskal(ll v, vec<tri> &e) {\n\tll sum = 0;\n\tsort(ALL(e));\n\tufset s(v);\n\trep(i, 0, e.size()) {\n\t\tif (!s.same(e[i].s, e[i].t)) {\n\t\t\ts.unite(e[i].s, e[i].t);\n\t\t\tsum += e[i].f;\n\t\t}\n\t}\n\treturn sum;\n}\n\n//単一始点最短経路\nvoid dijkstra(const vec<vec<pea>> &c, ll v, vll &d) {\n\td[v] = 0;\n\tll n = c.size();\n\tll count = 1;\n\tvec<bool> seen(n, false);\n\tseen[v] = true;\n\tyuque<pea> hen;\n\trep(i, 0, c[v].size())hen.push({ -c[v][i].f,c[v][i].s });\n\twhile (count != n) {\n\t\tif (hen.empty())break;\n\t\tpea k = hen.top(); hen.pop();\n\t\twhile (seen[k.s]) {\n\t\t\tif (hen.empty()) {\n\t\t\t\tcount = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk = hen.top();\n\t\t\then.pop();\n\t\t}\n\t\tif (count == -1)break;\n\t\td[k.s] = -k.f;\n\t\tcount++;\n\t\tseen[k.s] = true;\n\t\trep(i, 0, c[k.s].size())hen.push({ k.f - c[k.s][i].f,c[k.s][i].s });\n\t}\n}\n\n//全点対間最短経路\nbool floyd(vec<vll> &d) {\n\tll n = d.size();\n\trep(i, 0, n)d[i][i] = 0;\n\trep(k, 0, n) {\n\t\trep(i, 0, n) {\n\t\t\tif (d[i][k] != MOD) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\tif (d[k][j] != MOD) {\n\t\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool b = true;\n\trep(i, 0, n)if (d[i][i] < 0)b = false;\n\treturn b;\n}\n\n//計算幾何学\nv2 beku(ld r,ld t){\n\treturn { r*cos(t),r*sin(t) };\n}\nld kakudo(v2 a) {\n\treturn atan2(a.y, a.x);\n}\nten shaei(ten p, chokusen l) {\n\tv2 a = l.p2 - l.p1;\n\treturn l.p1 + a * a.naiseki(p - l.p1) / a.abs2();\n}\nten hansha(ten p, chokusen l) {\n\treturn shaei(p, l) * 2 - p;\n}\nld tenchoku(ten p, chokusen l) {\n\tv2 a = l.p2 - l.p1;\n\treturn abs(a.gaiseki(p - l.p1)) / a.abs();\n}\nld tensen(ten p, senbun s) {\n\tif ((p - s.p1).naiseki(s.p2 - s.p1) < 0)return (p - s.p1).abs();\n\tif ((p - s.p2).naiseki(s.p1 - s.p2) < 0)return (p - s.p2).abs();\n\treturn tenchoku(p, s);\n}\nll ccw(ten p0, ten p1, ten p2) {\n\tv2 a = p1 - p0, b = p2 - p0;\n\tif (a.gaiseki(b) > MIN)return -1;//012反時計回り\n\tif (a.gaiseki(b) < -MIN)return 1;//012時計回り\n\tif (a.naiseki(b) < -MIN)return -2;//102\n\tif (a.abs2() < b.abs2())return 2;//012\n\treturn 0;//021\n}\nbool majiwaru(senbun s, senbun t) { \n\treturn ccw(s.p1, s.p2, t.p1)*ccw(s.p1, s.p2, t.p2) <= 0 \n\t\t&& ccw(t.p1, t.p2, s.p1)*ccw(t.p1, t.p2, s.p2) <= 0; \n}\nld sensen(senbun s, senbun t) {\n\tif (majiwaru(s, t))return 0;\n\treturn min({ tensen(s.p1,t),tensen(s.p2,t),tensen(t.p1,s),tensen(t.p2,s) });\n}\nten koten(senbun s, senbun t) {\n\tv2 a = t.p2 - t.p1;\n\tld d1 = abs(a.gaiseki(s.p1 - t.p1));\n\tld d2 = abs(a.gaiseki(s.p2 - t.p1));\n\treturn s.p1 + (s.p2 - s.p1)*d1 / (d1 + d2);\n}\ntenten koten(en c, chokusen l) {\n\tten h = shaei(c.o, l);\n\tld k = sqrt(c.r*c.r - (h - c.o).abs2());\n\tv2 a = (l.p1 - l.p2) / (l.p1 - l.p2).abs();\n\treturn { h + a * k,h - a * k };\n}\ntenten koten(en c1, en c2) {\n\tld d = (c2.o - c1.o).abs();\n\tld s = acos((c1.r*c1.r + d * d - c2.r*c2.r) / (2 * c1.r*d));\n\tld t = kakudo(c2.o - c1.o);\n\treturn { c1.o + beku(c1.r,t + s),c1.o + beku(c1.r,t - s) };\n}\nll uchi(ten p, takaku &g) {\n\t//2:IN,1:ON,0:OUT\n\tll n = g.size();\n\tv2 a, b;\n\tbool x = false;\n\trep(i, 0, n) {\n\t\ta = g[i] - p; b = g[(i + 1) % n] - p;\n\t\tif (abs(a.gaiseki(b)) < MIN&&a.naiseki(b) < MIN)return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < MIN&&MIN<b.y&&a.gaiseki(b)>MIN)x = !x;\n\t}\n\treturn x ? 2 : 0;\n}\n\n//凸包\ntakaku andrew(takaku g) {\n\ttakaku u, b;\n\tif (g.size() < 3)return g;\n\tsort(ALL(g));\n\tu.pub(g[0]); u.pub(g[1]);\n\tb.pub(g.back()); b.pub(g[g.size() - 2]);\n\trep(i, 2, g.size()) {\n\t\trrep(j, u.size(), 2) {\n\t\t\tif (ccw(u[j - 2], u[j - 1], g[i]) == 1)break;\n\t\t\tu.pob();\n\t\t}\n\t\tu.pub(g[i]);\n\t}\n\trrep(i, g.size() - 3, 0) {\n\t\trrep(j, b.size(), 2) {\n\t\t\tif (ccw(b[j - 2], b[j - 1], g[i]) == 1)break;\n\t\t\tb.pob();\n\t\t}\n\t\tb.pub(g[i]);\n\t}\n\trep(i, 1, b.size() - 1)u.pub(b[i]);\n\treturn u;\n}\n\n//線分交差問題\nll kotensu(vec<senbun> s) {\n\tll n = s.size();\n\tstruct endp {\n\t\tten p; ll id, kind;//kind => 0:BOTTOM,1:LEFT,2:RIGHT,3:TOP\n\t\tbool operator<(const endp &e)const {\n\t\t\treturn p.y != e.p.y ? p.y < e.p.y : kind < e.kind;\n\t\t};\n\t};\n\t\n\tvec<endp> ep(2 * n);\n\trep(i, 0, n) {\n\t\tif (equal(s[i].p1.y, s[i].p2.y)) {\n\t\t\tif (s[i].p1.x > s[i].p2.x)swap(s[i].p1, s[i].p2);\n\t\t\tep[2 * i] = { s[i].p1,i,1 };\n\t\t\tep[2 * i + 1] = { s[i].p2,i,2 };\n\t\t}\n\t\telse {\n\t\t\tif (s[i].p1.y > s[i].p2.y)swap(s[i].p1, s[i].p2);\n\t\t\tep[2 * i] = { s[i].p1,i,0 };\n\t\t\tep[2 * i + 1] = { s[i].p2,i,3 };\n\t\t}\n\t}\n\n\tsort(ALL(ep));\n\n\tset<ll> bt;\n\tll cnt = 0;\n\trep(i, 0, 2 * n) {\n\t\tif (ep[i].kind == 3)bt.erase(ep[i].p.x);\n\t\telse if (ep[i].kind == 0)bt.insert(ep[i].p.x);\n\t\telse if (ep[i].kind == 1)cnt += distance(bt.lob(s[ep[i].id].p1.x), bt.upb(s[ep[i].id].p2.x));\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed;\n\tsolve();\n}\nvoid solve() {\n\tll n; cin >> n;\n\tvec<senbun> s(n);\n\trep(i, 0, n)cin >> s[i].p1.x >> s[i].p1.y >> s[i].p2.x >> s[i].p2.y;\n\tcout << kotensu(s) << kai;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int N = 200000 + 10;\nint n, bit[N];\nvector<int> v;\nint id(int x) {\n    return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;\n}\nvoid add(int pos, int x) {\n    while (pos < N) {\n        bit[pos] += x;\n        pos += (pos&(-pos));\n    }\n}\nint sum(int pos) {\n    int ans = 0;\n    while(pos) {\n        ans = ans + bit[pos];\n        pos -= pos & -pos;\n    }\n    return ans;\n}\nmap<int, vector< pair<int,int> > > items;\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i ++) {\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        if (x1 == x2) {\n            if (y1 > y2) swap(y1, y2);\n            v.push_back(y1-1); v.push_back(y2);\n            items[x1].push_back( make_pair(-2, y1-1) );\n            items[x1].push_back( make_pair(+2, y2) );\n        } else {\n            if (x1 > x2) swap(x1, x2);\n            v.push_back(y1);\n            items[x1].push_back( make_pair(+1, y1) );\n            items[x2+1].push_back( make_pair(-1, y1) );\n            v.push_back(x1);\n            v.push_back(x2+1);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    long long ans = 0;\n    for (auto it: items) {\n        vector< pair<int,int> > vec = it.second;\n        for (auto p: vec) {\n            if (p.first == +1)\n                add(id(p.second), +1);\n            if (p.first == -1)\n                add(id(p.second), -1);\n        }\n\n        for (auto p: vec) {\n            if (p.first == +2)\n                ans = ans + sum(id(p.second));\n            if (p.first == -2)\n                ans = ans - sum(id(p.second));\n        }\n    }\n    cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int SHIFT = 1000000003;\nconst int LIMIT = 2000000010;\nmap< int, int > data;\n\nvoid add(long long k, int x)\n{\n  for(k += SHIFT; k < LIMIT; k += k & -k) {\n    data[k] += x;\n  }\n}\n\nint sum(long long k)\n{\n  int sum = 0;\n  for(k += SHIFT; k > 0; k -= k & -k) {\n    if(data.count(k)) sum += data[k];\n  }\n  return (sum);\n}\n\nvoid solve()\n{\n  int N;\n  cin >> N;\n  map< int, vector< tuple< int, int, int > > > query;\n  for(int i = 0; i < N; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if(a == c) {\n      if(b > d) swap(b, d);\n      query[b].emplace_back(0, a, i);\n      query[d].emplace_back(2, a, i);\n    } else {\n      if(a > c) swap(a, c);\n      query[b].emplace_back(1, a, 1);\n      query[b].emplace_back(1, c + 1, -1);\n    }\n  }\n\n  bool update[100000] = {};\n  int dp[100000] = {};\n\n  for(auto p : query) {\n    sort(begin(p.second), end(p.second));\n    for(auto &q : p.second) {\n      int a, b, c;\n      tie(a, b, c) = q;\n      if(a == 1) add(b, c);\n      else if(update[c]++) dp[c] += sum(b);\n      else dp[c] -= sum(b);\n    }\n  }\n  cout << accumulate(dp, dp + N, 0) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ll> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-15;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\n/*inline bool Geq(ld a, ld b){ return a - b > -EPS; }\ninline bool Grt(ld a, ld b){ return a - b > EPS; }\ninline bool Leq(ld a, ld b){ return a - b < EPS; }\ninline bool Lss(ld a, ld b){ return a - b < -EPS; }\ninline bool Equ(ld a, ld b){ return abs(a-b) < EPS; }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nbool byX(const PT &a, const PT &b){\n\tif (Equ(a.X, b.X))\n\t\t\treturn Lss(a.Y, b.Y);\n\t\treturn Lss(a.X, b.X);\n}\n\n\nstruct cmpXY{\n\tbool operator ()(const PT &a, const PT &b){\n\t\treturn byX(a, b);\n\t}\n};\n\nstruct cmpYX{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.Y, b.Y))\n\t\t\treturn Lss(a.X, b.X);\n\t\treturn Lss(a.Y, b.Y);\n\t}\n};\n\n\n\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}*/\n\nint main(){\t\n\tvector <PT> adds, rems;\n\tvector <LS> query;\n\tfor (int i = in(); i; i--){\n\t\tll px, py, qx, qy;\n\t\tcin >> px >> py >> qx >> qy;\n\t\tPT p(px, py), q(qx, qy);\n\t\tif (p.Y == q.Y){\n//\t\t\tcout << \"Here!\\n\";\n\t\t\tif (q.X < p.X)\n\t\t\t\tswap(p, q);\n\t\t\tadds.pb(p);\n\t\t\trems.pb(q);\n\t\t}\n\t\telse{\n\t\t\tif (q.Y < p.Y)\n\t\t\t\tswap(p, q);\n\t\t\tquery.pb({p, q});\n\t\t}\n\t}\n\tsort(adds.begin(), adds.end(), [](PT a, PT b){ return a.X < b.X; });\n\tsort(rems.begin(), rems.end(), [](PT a, PT b){ return a.X < b.X; });\n\tsort(query.begin(), query.end(), [](LS a, LS b){ return a.F.X < b.F.X; });\n\tmultiset <ll> ys;\n\tint iadd = 0, irem = 0;\n\tint ans = 0;\n\tfor (auto p : query){\n//\t\tcout << p.F << ' ' << p.S << endl;\n\t\twhile (iadd < adds.size() && adds[iadd].X <= p.F.X){\n//\t\t\tcout << \"add \" << adds[iadd].Y << endl;\n\t\t\tys.insert(adds[iadd++].Y);\n\t\t}\n\t\twhile (irem < rems.size() && rems[irem].X < p.F.X){\n//\t\t\tcout << \"remove \" << rems[irem].Y << endl;\n\t\t\tys.erase(ys.find(rems[irem++].Y));\n\t\t}\n\t\tint cur = distance(ys.lower_bound(p.F.Y), ys.upper_bound(p.S.Y));\n//\t\tcout << cur << endl;\n\t\tans += cur;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 22点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint main(void)\n{\n\n    int n, count = 0;\n    Point start, end;\n    vector<Segment> v_H_seg, v_V_seg;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の定義\n        Segment s(start, end);\n\n        if( start.x == end.x )\n        {\n            // y軸に平行な直線\n            v_H_seg.push_back(s);\n        }\n        else\n        {\n            // x軸に平行な直線\n            v_V_seg.push_back(s);\n        }\n    }\n\n    // 線分の交点を検索する\n    for( int i = 0; i < v_V_seg.size(); i++)\n    {\n        for(int j = 0; j < v_H_seg.size(); j++)\n        {\n            if( v_V_seg[i].p1.x <= v_H_seg[j].p1.x && v_H_seg[j].p1.x <= v_V_seg[i].p2.x )\n            {\n                if( v_H_seg[j].p1.y <= v_V_seg[i].p1.y && v_V_seg[i].p1.y <= v_H_seg[j].p2.y )\n                {\n                    count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 100005\n#define maxpoints 200005\n#define maxlen 200005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int DOWN = 0;\nconst int LEFT = 1;\nconst int UP = 2;\nint n,rig[maxn],x1[maxn],x2[maxn],y1_[maxn],y2[maxn];\nint compress(int* t1,int* t2){\n\tvector <int> xs;\n\txs.clear();\n\tfor(int i=1;i<=n;i++){\n\t\txs.push_back(t1[i]);\n\t\txs.push_back(t2[i]);\n\t}\n\tsort(xs.begin(),xs.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tfor(int i=1;i<=n;i++){\n\t\tt1[i] = lower_bound(xs.begin(),xs.end(),t1[i]) - xs.begin() + 1;\n\t\tt2[i] = lower_bound(xs.begin(),xs.end(),t2[i]) - xs.begin() + 1;\n\t}\n\treturn xs.size();\n}\nstruct Point{\n\tint x,y,type,id;//id: belong to which segment.\n\tPoint(int x = 0,int y = 0,int type = 0,int id = 0): x(x),y(y),type(type),id(id) {}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(y == p.y){\n\t\t\tif(type == p.type) return x < p.x;\n\t\t\treturn type < p.type;\n\t\t}\n\t\treturn y < p.y;\n\t}\n}ps[maxpoints]; int m;\nint bit[maxlen],len;\nvoid add(int pos,int x){\n\tfor(int i=pos;i<=len;i += i & -i) bit[i] += x;\n}\nint query(int pos){\n\tint res = 0;\n\tfor(int i=pos;i>0;i -= i & -i) res += bit[i];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d%d%d\",&x1[i],&y1_[i],&x2[i],&y2[i]);\n\tlen = compress(x1,x2);\n\tfor(int i=1;i<=n;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tif(y1_[i] > y2[i]) swap(y1_[i],y2[i]);\n\t\t\tps[++m] = Point(x1[i],y1_[i],DOWN,i);\n\t\t\tps[++m] = Point(x2[i],y2[i],UP,i);\n\t\t}else{\n\t\t\tif(x1[i] > x2[i]) swap(x1[i],x2[i]);\n\t\t\tps[++m] = Point(x1[i],y1_[i],LEFT,i);\n\t\t\trig[i] = x2[i];\n\t\t}\n\t}\n\tsort(ps + 1,ps + m + 1);\n\tmemset(bit,0,sizeof(bit));\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tPoint p = ps[i];\n\t\tif(p.type == DOWN) add(p.x,1);\n\t\telse if(p.type == UP) add(p.x,-1);\n\t\telse ans += query(rig[p.id]) - query(p.x - 1);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tvector<int> tate(table.size() + 1);\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\n\t\t\t//if (y1 < y2) add(x1, 1);\n\t\t\t//if (y1 > y2) add(x1, -1);\n\t\t\t//if (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\n\t\t\tif (y1 < y2)\n\t\t\t{\n\t\t\t\ttate[x1]++;\n\t\t\t\tif (tate.at(x1) == 0){ y1 = 2; }\n\t\t\t}\n\t\t\tif (y1 > y2)\n\t\t\t{\n\t\t\t\ttate[x1]--;\n\t\t\t\tif (tate.at(x1) == 0){ y1 = 3; };\n\t\t\t}\n\n\t\t\tif (y1 == y2)\n\t\t\t{\n\t\t\t\tfor (int i = x1; i <= x2; i++)\n\t\t\t\t{\n\t\t\t\t\tans += tate.at(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nstruct Polygon\n{\n\tint n;\n\tPoint a[MAXN];\n\tPolygon() {}\n\tint Point_In(Point t)\n\t{\n\t\tint num = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t{\n\t\t\tif(PointOnSegment(t, a[i], a[i + 1]))\n\t\t\t\treturn 2;\n\t\t\tint k = cmp(det(a[i + 1] - a[i], t - a[i]));\n\t\t\tint d1 = cmp(a[i].y - t.y);\n\t\t\tint d2 = cmp(a[i + 1].y - t.y);\n\t\t\tif(k > 0 && d1 <= 0 && d2 > 0)\n\t\t\t\tnum++;\n\t\t\tif(k < 0 && d2 <= 0 && d1 > 0)\n\t\t\t\tnum--;\n\t\t}\n\t\treturn num != 0;\n\t}\n};\n\nstruct Polygon_convex\n{\n\tvector<Point> P;\n\tPolygon_convex(int Size = 0)\n\t{\n\t\tP.resize(Size);\n\t}\n} res(2*100000 + 50);\n\nbool comp_less(Point a, Point b)\n{\n\treturn cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nvoid convex_hull(vector<Point> a)\n{\n\tsort(a.begin(), a.end(), comp_less);\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tint m = 0;\n\tint len = a.size();\n\trep(i, 0, len - 1)\n\t{\n\t\twhile(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tint k = m;\n\tlen = a.size();\n\tdow(i, len - 2, 0)\n\t{\n\t\twhile(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif(a.size()>1)\n\t\tres.P.resize(m-1);\n}\n\nbool PointOnSegment(Point p, Point s, Point t)\n{\n\treturn cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\nPoint rotate(Point p, double cost, double sint)\n{\n\tdouble x = p.x, y = p.y;\n\treturn Point(x*cost - y*sint, x*sint + y*cost);\n}\n\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n\tdouble d = (ap - bp).norm();\n\tdouble cost = (ar*ar + d*d - br*br) / (2*ar*d);\n\tdouble sint = sqrt(1. - cost*cost);\n\tPoint v = (bp - ap) / (bp - ap).norm() * ar;\n\treturn make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\nstruct Node\n{\n\tPoint p;\n\tPoint q;\n\tint id;\n\tNode(Point p_ = Point(0.,0.), Point q_ = Point(0., 0.), int id_ = 4):p(p_), q(q_), id(id_){}\n\tfriend bool operator ==(Node a, Node b)\n\t{\n\t\treturn cmp(a.p.x-b.p.x)==0 && cmp(a.p.y-b.p.y)==0;\n\t}\n\tfriend bool operator <(Node a, Node b)\n\t{\n\t\tif(cmp(a.p.y-b.p.y)==0)\n\t\t\treturn a.id < b.id;\n\t\treturn a.p.y < b.p.y;\n\t}\n} node[MAX * 2];\n\nset<double> s;\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tsfi(n);\n\tint cnt = 0;\n\trep(i, 0, n - 1)\n\t{\n\t\tPoint a, b;\n\t\tscanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n\t\tif(cmp(a.x-b.x)==0)\n\t\t{\n\t\t\tif(a.y < b.y)\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Point(0., 0.), 1);\n\t\t\t\tnode[cnt++] = Node(b, Point(0., 0.), 3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode[cnt++] = Node(a, Point(0., 0.), 3);\n\t\t\t\tnode[cnt++] = Node(b, Point(0., 0.), 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a.x < b.x)\n\t\t\t\tnode[cnt++] = Node(a, b, 2);\n\t\t\telse\n\t\t\t\tnode[cnt++] = Node(b, a, 2);\n\t\t}\n\t\t\n\t}\n\tsort(node, node + cnt);\n\t\n\tint ans = 0;\n\trep(i, 0, cnt - 1)\n\t{\n\t\tif(node[i].id == 3)\n\t\t{\n\t\t\tset<double>::iterator it = s.find(node[i].p.x);\n\t\t\ts.erase(*it);\n\t\t}\n\t\telse if(node[i].id == 1)\n\t\t{\n\t\t\ts.insert(node[i].p.x);\n\t\t}\n\t\telse if(node[i].id == 2)\n\t\t{\n\t\t\tset<double>::iterator it = s.lower_bound(node[i].p.x);\n\t\t\tset<double>::iterator iter = s.lower_bound(node[i].q.x);\n\t\t\tif(cmp((*iter)-node[i].q.x)==0)\n\t\t\t\titer++;\n\t\t\tfor(; it != iter; it++)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0.0, double y = 0.0) :\n\t\t\tx(x), y(y) {\n\t}\n\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(double k) {\n\t\treturn Point(x * k, y * k);\n\t}\n\tPoint operator /(double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator <(Point p) {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(Point p) {\n\t\treturn equals(x, p.x) && equals(y, p.y);\n\t}\n};\ntypedef Point Vector;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\ntypedef Segment Line;\n\ndouble dot(Vector v1, Vector v2) {\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\ndouble cross(Vector v1, Vector v2) {\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\nVector unitVector(Vector v) {\n\treturn v / v.abs();\n}\nVector polar(double r, double a) {\n\treturn Vector(r * cos(a), r * sin(a));\n}\ndouble arg(Vector v) {\n\treturn atan2(v.y, v.x);\n}\nbool isOrthogonal(Vector v1, Vector v2) {\n\treturn equals(dot(v1, v2), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isOrthogonal(Point l1, Point l2, Point m1, Point m2) {\n\treturn isOrthogonal(l2 - l1, m2 - m1);\n}\nbool isParallel(Vector v1, Vector v2) {\n\treturn equals(cross(v1, v2), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Point l1, Point l2, Point m1, Point m2) {\n\treturn isParallel(l1 - l2, m1 - m2);\n}\n\nenum PositionSP {\n\tCOUNTER_CLOCKWISE = -1,\n\tCLOCKWISE = 1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nPositionSP ccw(Point p1, Point p2, Point p) {\n\tVector a = p2 - p1, b = p - p1;\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\telse if (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\telse if (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\telse if (a.norm() < b.norm())\n\t\treturn ONLINE_FRONT;\n\telse\n\t\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint intersection(Segment s1, Segment s2) {\n\tdouble d1 = abs(cross(s2.p2 - s2.p1, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(s2.p1 - s2.p2, s1.p2 - s2.p2));\n\treturn s1.p1 + (s1.p2 - s1.p1) * d1 / (d1 + d2);\n}\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\ndouble distancePP(Point p1, Point p2) {\n\treturn (p1 - p2).abs();\n}\ndouble distanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / distancePP(l.p2, l.p1));\n}\ndouble distanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn distancePP(s.p1, p);\n\telse if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn distancePP(s.p2, p);\n\telse\n\t\treturn distanceLP(s, p);\n}\ndouble distanceSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))\n\t\treturn 0.0;\n\telse {\n\t\treturn min(min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)));\n\t}\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :\n\t\t\tc(c), r(r) {\n\t}\n};\npair<Point, Point> intersection(Circle c, Line l) {\n\tPoint pr = projection(l, c.c);\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\tVector e = unitVector(l.p2 - l.p1);\n\treturn make_pair(pr + e * base, pr - e * base);\n}\npair<Point, Point> intersection(Circle c1, Circle c2) {\n\tdouble d = (c2.c - c1.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\nenum ContainGP {\n\tOUTSIDE = 0, ON_EDGE = 1, INSIDE = 2\n};\nContainGP contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tVector a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS)\n\t\t\treturn ON_EDGE;\n\t\tif (a.y > b.y)\n\t\t\tswap(a, b);\n\t\tif (cross(a, b) > EPS && a.y < EPS && b.y > EPS)\n\t\t\tx = !x;\n\t}\n\treturn x ? INSIDE : OUTSIDE;\n}\n\nPolygon andrewScan(Polygon P) {\n\tPolygon U, L;\n\tint n = P.size();\n\tif (n < 3)\n\t\treturn P;\n\tsort(P.begin(), P.end());\n\tU.push_back(P[0]);\n\tU.push_back(P[1]);\n\tfor (int i = 2; i < n; i++) {\n\t\twhile (U.size() >= 2\n\t\t\t\t&& ccw(U[U.size() - 2], U[U.size() - 1], P[i])\n\t\t\t\t\t\t== COUNTER_CLOCKWISE) {\n\t\t\tU.pop_back();\n\t\t}\n\t\tU.push_back(P[i]);\n\t}\n\tL.push_back(P[n - 1]);\n\tL.push_back(P[n - 2]);\n\tfor (int i = n - 3; i >= 0; i--) {\n\t\twhile (L.size() >= 2\n\t\t\t\t&& ccw(L[L.size() - 2], L[L.size() - 1], P[i])\n\t\t\t\t\t\t== COUNTER_CLOCKWISE) {\n\t\t\tL.pop_back();\n\t\t}\n\t\tL.push_back(P[i]);\n\t}\n\tfor (int i = 1; i < L.size() - 1; i++)\n\t\tU.push_back(L[i]);\n\treturn U;\n}\n\nenum EndPointType {\n\tBOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3\n};\nclass EndPoint {\npublic:\n\tPoint P;\n\tint seg;\n\tEndPointType t;\n\tEndPoint() {\n\t}\n\tEndPoint(Point P, int seg, EndPointType t) :\n\t\t\tP(P), seg(seg), t(t) {\n\t}\n\tbool operator <(const EndPoint &ep) const {\n\t\treturn P.y == ep.P.y ? t < ep.t : P.y < ep.P.y;\n\t}\n};\nint manhattanIntersection(vector<Segment> S) {\n\tvector<EndPoint> EP;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i].p1.y == S[i].p2.y) {\n\t\t\tif (S[i].p1.x < S[i].p2.x) {\n\t\t\t\tEP.push_back(EndPoint(S[i].p1, i, LEFT));\n\t\t\t\tEP.push_back(EndPoint(S[i].p2, i, RIGHT));\n\t\t\t} else {\n\t\t\t\tEP.push_back(EndPoint(S[i].p1, i, RIGHT));\n\t\t\t\tEP.push_back(EndPoint(S[i].p2, i, LEFT));\n\t\t\t}\n\t\t} else {\n\t\t\tif (S[i].p1.y < S[i].p2.y) {\n\t\t\t\tEP.push_back(EndPoint(S[i].p1, i, BOTTOM));\n\t\t\t\tEP.push_back(EndPoint(S[i].p2, i, TOP));\n\t\t\t} else {\n\t\t\t\tEP.push_back(EndPoint(S[i].p1, i, TOP));\n\t\t\t\tEP.push_back(EndPoint(S[i].p2, i, BOTTOM));\n\t\t\t}\n\t\t}\n\t}\n\tsort(EP.begin(), EP.end());\n\tint cnt = 0;\n\tset<int> BT;\n\tfor (int i = 0; i < S.size() * 2; i++) {\n\t\tswitch (EP[i].t) {\n\t\tcase BOTTOM:\n\t\t\tBT.insert(EP[i].P.x);\n\t\t\tbreak;\n\t\tcase TOP:\n\t\t\tBT.erase(EP[i].P.x);\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tif (S[EP[i].seg].p1.x > S[EP[i].seg].p2.x)\n\t\t\t\tswap(S[EP[i].seg].p1, S[EP[i].seg].p2);\n\t\t\tset<int>::iterator l = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator r = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(l, r);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N;\n\tvector<Segment> S;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tSegment s;\n\t\tcin >> s.p1.x >> s.p1.y;\n\t\tcin >> s.p2.x >> s.p2.y;\n\t\tS.push_back(s);\n\t}\n\tcout << manhattanIntersection(S) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n; cin >> n;\n    \n    int x1[100000], y1[100000], x2[100000], y2[100000]; bool tate[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        \n        if(x1[i] == x2[i])\n        {\n            tate[i] = true;\n        }\n        else\n        {\n            tate[i] = false;\n        }\n    }\n    \n    int Ans = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            if(tate[i] == true && tate[j] == false)\n            {\n                if(y1[i] < y1[j] && y1[j] < y2[i])\n                {\n                    Ans++;\n                }\n            }\n            \n            if(tate[i] == false && tate[j] == true)\n            {\n                if(x1[i] < x1[j] && x1[j] < x2[i])\n                {\n                    Ans++;\n                }\n            }\n        }\n    }\n    \n    cout << Ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200002;\nint BIT[MAX_SIZE];\n\nvoid add(int i, int x)\n{\n\twhile (i <= MAX_SIZE - 1)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n\tbool operator < (const Point& p)const {\n\t\treturn y < p.y;\n\t}\n};\n\nstruct Line {\n\tPoint b, e;\n\tbool operator < (const Line& l)const {\n\t\treturn b.y < l.b.y;\n\t}\n};\n\nint main() {\n\tint n;\n\tvector<Line> lines;\n\tvector<Point> points;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint pb, pe;\n\t\tcin >> pb.x >> pb.y >> pe.x >> pe.y;\n\t\t\n\t\tif (pb.y == pe.y) {\n\t\t\tLine l;\n\t\t\tl.b = pb.x < pe.x ? pb : pe;\n\t\t\tl.e = pb.x < pe.x ? pe : pb;\n\t\t\tlines.push_back(l);\n\t\t}\n\t\telse {\n\t\t\tpoints.push_back(pb);\n\t\t\tpoints.push_back(pe);\n\t\t}\n\t}\n\n\tsort(lines.begin(), lines.end());\n\tsort(points.begin(), points.end());\n\n\tint cnt = 0;\n\tint i = 0;\n\tint j = 0;\n\tset<int> s;\n\n\twhile (i < points.size()) {\n\t\twhile ( j < lines.size() && points[i].y >= lines[j].b.y) {\n\t\t\tset<int>::iterator lb = lower_bound(s.begin(), s.end(), lines[j].b.x);\n\t\t\tset<int>::iterator ub = upper_bound(s.begin(), s.end(), lines[j].e.x);\n\t\t\tcnt += distance(lb, ub);\n\t\t\tj++;\n\t\t}\n\t\tif (s.find(points[i].x) == s.end()) {\n\t\t\ts.insert(points[i].x);\n\t\t}\n\t\telse {\n\t\t\ts.erase(points[i].x);\n\t\t}\n\t\ti++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstruct event{\n    int type;//0:Y????????????????????? 1:X????????????????????????????§? 2:??????\n    int x1,y1,x2,y2;\n    event(int type, int x1, int y1, int x2, int y2){\n        this->type=type, this->x1=x1, this->y1=y1, this->x2=x2, this->y2=y2;\n    }\n    bool operator<(const event&b) const{\n        if(type!=b.type){\n            return type<b.type;\n        }else{\n            return y1==b.y1?y2<b.y2:y1<b.y1;\n        }\n    }\n    bool operator>(const event&b) const{\n        if(type!=b.type){\n            return type>b.type;\n        }else{\n            return y1==b.y1?y2>b.y2:y1>b.y1;\n        }\n    }\n};\n\nint main(){\n    int n,x1,x2,y1,y2;\n    string str;\n    cin >> str;\n    if(str==\"In\"){\n        cout << \"In preparation.\\n\";\n        return 0;\n    }\n    stringstream ss(str);\n    ss >> n;\n    vector<pair<int,event>> E;//<x??§?¨?,event>\n    while(n--){\n        cin >> x1 >> y1 >> x2 >> y2;\n        if(y1==y2){//x????????????\n            if(x1<x2){\n                E.push_back(pair<int,event>(x1,event(1,x1,y1,x2,y2)));\n                E.push_back(pair<int,event>(x2,event(2,x1,y1,x2,y2)));\n            }else{\n                E.push_back(pair<int,event>(x2,event(1,x2,y2,x1,y1)));\n                E.push_back(pair<int,event>(x1,event(2,x2,y2,x1,y1)));\n            }\n        }else{//y????????????\n            if(y1<y2){\n                E.push_back(pair<int,event>(x1,event(0,x1,y1,x2,y2)));\n            }else{\n                E.push_back(pair<int,event>(x1,event(0,x2,y2,x1,y1)));\n            }\n        }\n    }\n    sort(E.begin(),E.end());\n    map<int,int> M;\n    int c=0;\n    for(auto i : E){\n        switch(i.second.type){\n            case 0:\n                for(auto ite=M.lower_bound(i.second.y1);ite!=M.upper_bound(i.second.y2);++ite) c++; \n                break;\n            case 1:\n                M[i.second.y1]=1;\n                break;\n            case 2:\n                M.erase(i.second.y1);\n                break;\n        }\n    }\n    cout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ndouble abs(Point p) { return sqrt(p.x * p.x + p.y * p.y); }\ntypedef Point Vector;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nenum TTN { BOTTOM = 0, LEFT, RIGHT, TOP };\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\tEndPoint(Point p = Point(0.0, 0.0), int seg = 0, int st = 0):\n\t\tp{p}, seg(seg), st(st) {}\n\tbool operator < (const EndPoint &ep) const {\n\t\treturn (p.y == ep.p.y) ? (st < ep.st) : (p.y < ep.p.y);\n\t}\n};\nEndPoint EP[2 * 100000];\nint manhattanIntersection(vector<Segment> S) {\n\tint n = len(S);\n\tint k = -1;\n\trep(i, 0, n) {\n\t\tif((S[i].p1.y == S[i].p2.y && S[i].p1.x > S[i].p2.x) || (S[i].p1.y > S[i].p2.y))\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\tif(S[i].p1.y == S[i].p2.y) {\n\t\t\tEP[++k] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[++k] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else{\n\t\t\tEP[++k] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[++k] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\tsort(EP, EP + (2 * n));\n\tset<int> BT;\n\tBT.emplace(1000000001);\n\tint cnt = 0;\n\trep(i, 0, 2 * n) {\n\t\tif (EP[i].st == TOP) BT.erase(EP[i].p.x);\n\t\telse if (EP[i].st == BOTTOM) BT.emplace(EP[i].p.x);\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = lower_bound(all(BT), S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = upper_bound(all(BT), S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn mp(pr + e * base, pr - e * base);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2.0 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn mp(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint contains(Polygon g, Point p) {\n\tint n = len(g);\n\tbool x = false;\n\tPoint a, b;\n\trep(i, 0, n) {\n\t\ta = g[i] - p;\n\t\tb = g[(i + 1) % n] - p;\n\t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) {\n\tif(len(s) < 3) return s;\n\tPolygon u, l;\n\tsort(all(s), [](const Point& a, const Point& b){return a.y == b.y ? a.x < b.x : a.y < b.y;});\n\tu.eb(s[0]);\n\tu.eb(s[1]);\n\tl.eb(s[len(s) - 1]);\n\tl.eb(s[len(s) - 2]);\n\tint _ccw;\n\trep(i, 2, len(s)) {\n\t\trrep(n, len(u), 1) {\n\t\t\t_ccw = ccw(u[n - 2], u[n - 1], s[i]);\n\t\t\tif(!(_ccw != CLOCKWISE && _ccw != ONLINE_FRONT)) break;\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.eb(s[i]);\n\t}\n\trrep(i, len(s) - 3, -1) {\n\t\trrep(n, len(l), 1) {\n\t\t\t_ccw = ccw(l[n - 2], l[n - 1], s[i]);\n\t\t\tif(!(_ccw != CLOCKWISE && _ccw != ONLINE_FRONT)) break;\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.eb(s[i]);\n\t}\n\treverse(all(l));\n\trrep(i, len(u) - 2, 0) l.eb(u[i]);\n\treturn l;\n}\nconst constexpr ll INF = 1000000001;\nstruct mhi {\n\tint x, a, y;\n\tmhi(int x = 0, int a = 0, int y = 0): x(x), a(a), y(y) {};\n};\nint main() {\n\tint n; cin >> n;\n\tvector<mhi> v;\n\tint x1,y1,x2,y2;\n\trep(i, 0, n) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(y1 == y2){\n\t\t\tv.eb(min(x1, x2), -INF, y1);\n\t\t\tv.eb(max(x1, x2), INF, y1);\n\t\t} else if(x1 == x2){\n\t\t\tv.eb(x1, min(y1, y2), max(y1, y2));\n\t\t}\n\t}\n\tsort(all(v), [](mhi& a, mhi& b){return a.x == b.x ? a.a < b.a : a.x < b.x;});\n\tint ans = 0;\n\tset<int> list;\n\trep(i, 0, len(v)) {\n\t\ty1 = v[i].a, y2 = v[i].y;\n\t\tif(y1 == -INF) list.emplace(y2);\n\t\telse if(y1 == INF) list.erase(y2);\n\t\telse {\n\t\t\tans += distance(list.lower_bound(y1),list.upper_bound(y2));\n\t\t}\n\t}\n\tP(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nstruct Polygon\n{\n\tint n;\n\tPoint a[MAXN];\n\tPolygon() {}\n\tint Point_In(Point t)\n\t{\n\t\tint num = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t{\n\t\t\tif(PointOnSegment(t, a[i], a[i + 1]))\n\t\t\t\treturn 2;\n\t\t\tint k = cmp(det(a[i + 1] - a[i], t - a[i]));\n\t\t\tint d1 = cmp(a[i].y - t.y);\n\t\t\tint d2 = cmp(a[i + 1].y - t.y);\n\t\t\tif(k > 0 && d1 <= 0 && d2 > 0)\n\t\t\t\tnum++;\n\t\t\tif(k < 0 && d2 <= 0 && d1 > 0)\n\t\t\t\tnum--;\n\t\t}\n\t\treturn num != 0;\n\t}\n};\n\nstruct Polygon_convex\n{\n\tvector<Point> P;\n\tPolygon_convex(int Size = 0)\n\t{\n\t\tP.resize(Size);\n\t}\n} res(2*100000 + 50);\n\nbool comp_less(Point a, Point b)\n{\n\treturn cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nvoid convex_hull(vector<Point> a)\n{\n\tsort(a.begin(), a.end(), comp_less);\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tint m = 0;\n\tint len = a.size();\n\trep(i, 0, len - 1)\n\t{\n\t\twhile(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tint k = m;\n\tlen = a.size();\n\tdow(i, len - 2, 0)\n\t{\n\t\twhile(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n\t\t\t--m;\n\t\tres.P[m++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif(a.size()>1)\n\t\tres.P.resize(m-1);\n}\n\nbool PointOnSegment(Point p, Point s, Point t)\n{\n\treturn cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0, n));\n}\n\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n\tdouble x0 = o.x, y0 = o.y;\n\tdouble x1 = a.x, y1 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n\tdouble C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta)) / (2*A);\n\t\tdouble t2 = (-B + mysqrt(delta)) / (2*A);\n\t\tret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n\t\tret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n\t}\n\t\n}\n\nPoint rotate(Point p, double cost, double sint)\n{\n\tdouble x = p.x, y = p.y;\n\treturn Point(x*cost - y*sint, x*sint + y*cost);\n}\n\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n\tdouble d = (ap - bp).norm();\n\tdouble cost = (ar*ar + d*d - br*br) / (2*ar*d);\n\tdouble sint = sqrt(1. - cost*cost);\n\tPoint v = (bp - ap) / (bp - ap).norm() * ar;\n\treturn make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\nstruct Node\n{\n\tPoint p;\n\tPoint q;\n\tint id;\n\tNode(Point p_ = Point(0.,0.), Point q_ = Point(0., 0.), int id_ = 4):p(p_), q(q_), id(id_){}\n\tfriend bool operator ==(Node a, Node b)\n\t{\n\t\treturn cmp(a.p.x-b.p.x)==0 && cmp(a.p.y-b.p.y)==0;\n\t}\n\tfriend bool operator <(Node a, Node b)\n\t{\n\t\tif(cmp(a.p.y-b.p.y)==0)\n\t\t\treturn a.id < b.id;\n\t\treturn a.p.y < b.p.y;\n\t}\n} node[MAX * 2];\n\nset<double> s;\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tsfi(n);\n\trep(i, 0, n - 1)\n\t{\n\t\tPoint a, b;\n\t\tscanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n\t\tif(cmp(a.x-b.x)==0)\n\t\t{\n\t\t\tif(a.y < b.y)\n\t\t\t{\n\t\t\t\tnode[i*2] = Node(a, Point(0., 0.), 1);\n\t\t\t\tnode[i*2+1] = Node(b, Point(0., 0.), 3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode[i*2] = Node(a, Point(0., 0.), 3);\n\t\t\t\tnode[i*2+1] = Node(b, Point(0., 0.), 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a.x < b.x)\n\t\t\t\tnode[i*2] = Node(a, b, 2);\n\t\t\telse\n\t\t\t\tnode[i*2+1] = Node(a, b, 2);\n\t\t}\n\t\t\n\t}\n\tsort(node, node + 2 * n);\n\t\n\tint ans = 0;\n\tint lmt = 2 * n - 1;\n\trep(i, 0, lmt)\n\t{\n\t\tif(node[i].id == 3)\n\t\t{\n\t\t\tset<double>::iterator it = s.find(node[i].p.x);\n\t\t\ts.erase(*it);\n\t\t}\n\t\telse if(node[i].id == 1)\n\t\t{\n\t\t\ts.insert(node[i].p.x);\n\t\t}\n\t\telse if(node[i].id == 2)\n\t\t{\n\t\t\tset<double>::iterator it = s.lower_bound(node[i].p.x);\n\t\t\tset<double>::iterator iter = s.lower_bound(node[i].q.x);\n\t\t\tif(cmp((*iter)-node[i].q.x)==0)\n\t\t\t\titer++;\n\t\t\tfor(; it != iter; it++)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\nstruct RSQ{\n  int n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 0 index\n  void add(int i,int v){\n    i++;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  int sum(int i){\n    int res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) \n  int sum(int x,int y){\n    return sum(y)-sum(x);\n  }\n};\n\nstruct Sweap{\n    int n;\n    vector<int>ye,ys,xs,xe;\n    vector<P2>vx,vy;\n    Sweap(vector<int>X1,vector<int>X2,vector<int>Y1,vector<int>Y2,int sz,int flag_zaatsu){\n        n=sz;xs=X1;xe=X2;ys=Y1;ye=Y2;\n        if(flag_zaatsu!=0)zaatsu();\n        for(int i=0;i<n;i++){\n            if(ys[i]>ye[i])swap(ys[i],ye[i]);\n            if(xs[i]>xe[i])swap(xs[i],xe[i]);\n            if(xs[i]==xe[i]){\n                vx.push_back(P2(P(xs[i], 2), i));\n                vy.push_back(P2(P(ys[i], 1), i));\n                vy.push_back(P2(P(ye[i], 3), i));\n            }\n            else{\n                vx.push_back(P2(P(xs[i], 1), i));\n                vx.push_back(P2(P(xe[i], 3), i));\n                vy.push_back(P2(P(ys[i], 2), i));\n            }\n        }\n        sort(vx.begin(),vx.end());\n        sort(vy.begin(),vy.end());\n    }\n    void zaatsu(){\n        map<int,int>Mx,My;\n        vector<int>tvx,tvy;\n        for(int i=0;i<n;i++){\n            tvx.push_back(xs[i]);\n            tvx.push_back(xe[i]);\n            tvy.push_back(ys[i]);\n            tvy.push_back(ye[i]);\n        }\n        sort(tvx.begin(),tvx.end());\n        sort(tvy.begin(),tvy.end());\n        tvx.erase(unique(tvx.begin(),tvx.end()),tvx.end());\n        tvy.erase(unique(tvy.begin(),tvy.end()),tvy.end());\n        for(int i=0;i<tvx.size();i++)Mx[tvx[i]]=i;\n        for(int i=0;i<tvy.size();i++)My[tvy[i]]=i;\n        for(int i=0;i<n;i++){\n            xs[i]=Mx[xs[i]];\n            xe[i]=Mx[xe[i]];\n            ys[i]=My[ys[i]];\n            ye[i]=My[ye[i]];\n        }\n    }\n    int build(){\n        RSQ rsq;\n        int sum=0;\n        for(int i=0;i<vx.size();i++){\n            int id=vx[i].second;\n            int seed=vx[i].first.second;\n            if(seed==1){\n                rsq.add(ys[id],1);\n            }\n            else if(seed==3){\n                rsq.add(ye[id],-1);\n            }\n            else{\n                sum+=rsq.sum(ys[id],ye[id]+1);\n            }\n        }\n        return sum;\n    }\n};\n \n \nint main(){\n    int n;\n    scanf(\" %d\", &n);\n    vector<int>X1(n),X2(n),Y1(n),Y2(n);\n    for(int i = 0; i < n; i++)scanf(\"%d%d%d%d\",&X1[i],&Y1[i],&X2[i],&Y2[i]);\n    Sweap s(X1,X2,Y1,Y2,n,1);\n    cout<<s.build()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals( A, B ) (fabs((A) - (B)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n    Point( double x = 0, double y = 0 ): x(x), y(y) {}\n    \n    Point operator + ( Point p ) { return Point( x + p.x, y + p.y ); }\n    Point operator - ( Point p ) { return Point( x - p.x, y - p.y ); }\n    Point operator * ( double a ) { return Point( a * x, a * y ); }\n    Point operator / ( double a ) { return Point( x / a, y / a ); }\n\n    double abs() { return sqrt( norm() ); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn ( x != p.x ) ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn equals( x, p.x ) && equals( y, p.y ); \n    }\n\n    double dot( Point a ) { return x * a.x + y * a.y; }\n    double cross( Point a ) { return x * a.y - y * a.x; }\n    double distance( Point a ) {\n\treturn (*this - a).abs();\n    }\n    double arg() {\n\treturn atan2( y, x );\n    }\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\nint contains( Polygon poly, Point p ) {\n    int n = poly.size();\n    int count = 0;\n    for ( int i = 0; i < n; i++ ) {\n\tVector a = poly[i] - p;\n\tVector b = poly[ ( i + 1 ) % n ] - p;\n\n\t// ???????????????\n\tif ( abs( a.cross( b ) ) < EPS && a.dot( b ) < EPS ) {\n\t    return 1;\n\t}\n\t// a.y???b.y??\\?????????????????????\n\tif ( a.y > b.y ) {\n\t    Vector tmp = a; a = b; b = tmp;\n\t}\n\t// ??£?????????????????´????????????????????´???\n\tif ( a.y < EPS && b.y > EPS && a.cross( b ) > EPS ) {\n\t    count++;\n\t}\n    }\n\n    return ( count % 2 ) ? 2 : 0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Line {\npublic:\n    Point p1, p2;\n    Line( Point p1 = Point(), Point p2 = Point() ): p1(p1), p2(p2){}\n    // ?????´????????????( cos = 0 )\n    bool isOrthogonal( Line a ) {\n\treturn equals( 0.0, (p1 - p2).dot( a.p1 - a.p2 ) );\n    }\n    // ??????????????????( sin = 0 )\n    bool isParallel( Line a ) {\n\treturn equals( 0.0, (p1 - p2).cross( a.p1 - a.p2 ) );\n    }\n\n    Point projection( Point p ) {\n\tVector v12 = p2 - p1;\n\tdouble r = v12.dot( p - p1 ) / v12.norm();\n\treturn p1 + v12 * r;\n    }\n\n    Point reflection( Point p ) {\n\treturn p + ( projection( p ) - p ) * 2.0;\n    }\n\n    double distance( Point p ) {\n\tVector v12 = this->p2 -this->p1;\n\tVector v10 = p - this->p1;\n\t\n\treturn abs( v12.cross( v10 ) / v12.abs() );\n    }\n\n    double distanceSP( Point p ) {\n\tif ( (p - this->p1).dot( this->p2 - this->p1 ) < 0.0 ) {\n\t    return this->p1.distance( p );\n\t} else if ( (p - this->p2).dot( this->p1 - this->p2 ) < 0.0 ) {\n\t    return this->p2.distance( p );\n\t}\n\telse {\n\t    return distance( p );\n\t}\n    }\n\n    int ccw( Point p ) {\n\tVector a = p2 - p1;\n\tVector b = p - p1;\n\tif ( a.cross( b ) > EPS ) return COUNTER_CLOCKWISE;\n\telse if ( a.cross( b ) < -EPS ) return CLOCKWISE;\n\telse if ( a.dot( b ) < -EPS ) return ONLINE_BACK;\n\telse if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\telse return ON_SEGMENT;\n    }\n\n    bool intersect( Line l ) {\n\treturn ( ( ccw( l.p1 ) * ccw( l.p2 ) <= 0 && l.ccw( p1 ) * l.ccw( p2 ) <= 0 ) );\n    }\n\n    Point crossPoint( Line l ) {\n\tVector base = p2 - p1;\n\tVector v1 = l.p1 - p1;\n\tVector v2 = l.p2 - p1;\n\tdouble d1 = base.cross( v1 );\n\tdouble d2 = base.cross( v2 );\t\n\tdouble t = d1 / ( d1 + d2 );\n\n\treturn l.p1 + ( l.p2 - l.p1 ) * t;\n    }\n};\n\ntypedef Line Segment;\n\ntypedef enum {\n    EP_BOTTOM,\n    EP_LEFT,\n    EP_RIGHT,\n    EP_TOP,\n} PointType;\n\nclass EndPoint {\npublic:\n    Point p;\n    int id;\n    PointType type;\n    EndPoint() {}\n    EndPoint( Point p, int id, PointType type ): p(p), id(id), type(type) {}\n\n    bool operator < ( const EndPoint &ep ) const {\n\tif ( p.y != ep.p.y ) return ( p.y < ep.p.y );\n\telse return ( type < ep.type );\n    }\n};\n\n#define MAX_N (100010)\n\nSegment S[MAX_N];\n\nEndPoint EP[MAX_N << 1];\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    \n    for ( int i = 0; i < n; i++ ) {\n\tPoint p1, p2;\n\tscanf(\"%lf %lf %lf %lf\", &p1.x, &p1.y, &p2.x, &p2.y);\n\tS[i] = ( p1 < p2 ) ? Segment( p1, p2 ) : Segment( p2, p1 );\n\tif ( p1.y == p2.y ) {\t// ?°´???\n\t    EndPoint ep0 = EndPoint( p1, i, EP_LEFT );\n\t    EndPoint ep1 = EndPoint( p2, i, EP_RIGHT );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n\telse {\t\t\t// ?????´\n\t    EndPoint ep0 = EndPoint( p1, i, EP_BOTTOM );\n\t    EndPoint ep1 = EndPoint( p2, i, EP_TOP );\n\t    EP[i<<1] = ep0;\n\t    EP[(i<<1) + 1] = ep1;\n\t}\n    }\n    \n    sort(EP, EP + (n << 1));\n\n    set<int> T;\t\t// ????????¢?´¢??¨\n    T.insert( 1000000001 );\n    int ans = 0;\n    for ( int i = 0; i < (n<<1); i++ ) {\n\tEndPoint ep = EP[i];\n\tif ( ep.type == EP_BOTTOM ) {\n\t    T.insert( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_TOP ) {\n\t    T.erase( (int)ep.p.x );\n\t}\n\telse if ( ep.type == EP_LEFT ) {\n\t    Segment s = S[ep.id];\n\t    set<int>::iterator l = lower_bound( T.begin(), T.end(), (int)s.p1.x );\n\t    set<int>::iterator u = upper_bound( T.begin(), T.end(), (int)s.p2.x );\n\t    ans += distance( l, u );\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n \n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n \nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n \ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n \nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nvoid convex_hull(vector<Point> a);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double a, double b): x(a), y(b) {}\n \n    friend Point operator -(Point a, Point b)\n    {\n        return Point(a.x-b.x,a.y-b.y);\n    }\n    friend Point operator +(Point a, Point b)\n    {\n        return Point(a.x+b.x,a.y+b.y);\n    }\n    friend bool operator ==(Point a, Point b)\n    {\n        return cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n    }\n    friend Point operator *(Point a, double b)\n    {\n        return Point(a.x*b,a.y*b);\n    }\n    friend Point operator *(double a, Point b)\n    {\n        return Point(a*b.x,a*b.y);\n    }\n    friend Point operator /(Point a, double b)\n    {\n        return Point(a.x/b,a.y/b);\n    }\n    double norm()\n    {\n        return sqrt(sqr(x)+sqr(y));\n    }\n};\n \nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point x, Point y): a(x), b(y) {}\n};\n \nstruct Polygon\n{\n    int n;\n    Point a[MAXN];\n    Polygon() {}\n    int Point_In(Point t)\n    {\n        int num = 0;\n        a[n] = a[0];\n        rep(i, 0, n - 1)\n        {\n            if(PointOnSegment(t, a[i], a[i + 1]))\n                return 2;\n            int k = cmp(det(a[i + 1] - a[i], t - a[i]));\n            int d1 = cmp(a[i].y - t.y);\n            int d2 = cmp(a[i + 1].y - t.y);\n            if(k > 0 && d1 <= 0 && d2 > 0)\n                num++;\n            if(k < 0 && d2 <= 0 && d1 > 0)\n                num--;\n        }\n        return num != 0;\n    }\n};\n \nstruct Polygon_convex\n{\n    vector<Point> P;\n    Polygon_convex(int Size = 0)\n    {\n        P.resize(Size);\n    }\n} res(2*100000 + 50);\n \nbool comp_less(Point a, Point b)\n{\n    return cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n \nvoid convex_hull(vector<Point> a)\n{\n    sort(a.begin(), a.end(), comp_less);\n    a.erase(unique(a.begin(), a.end()), a.end());\n    int m = 0;\n    int len = a.size();\n    rep(i, 0, len - 1)\n    {\n        while(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    int k = m;\n    len = a.size();\n    dow(i, len - 2, 0)\n    {\n        while(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    res.P.resize(m);\n    if(a.size()>1)\n        res.P.resize(m-1);\n}\n \nbool PointOnSegment(Point p, Point s, Point t)\n{\n    return cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\n \nbool parallel(Line a, Line b)\n{\n    return !cmp(det(a.a-a.b,b.a-b.b));\n}\n     \nbool orthogonal(Line a, Line b)\n{\n    return !cmp(dot(a.a - a.b, b.a - b.b));\n}\n \nPoint PointProjLine(Point p, Line l)\n{\n    Point ans;\n    double r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n    ans = l.a + r*(l.b-l.a);\n    return ans;\n}\n \nint cmp(double x)\n{\n    if(abs(x) < EPS)\n        return 0;\n    if(x > 0)\n        return 1;\n    return -1;\n}\n \ndouble dis_point_segment(Point p, Line l)\n{\n    if(cmp(dot(p-l.a,l.b-l.a))<0)\n        return (p-l.a).norm();\n    if(cmp(dot(p-l.b,l.a-l.b))<0)\n        return (p-l.b).norm();\n    return abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n \nbool line_make_point(Line a, Line b, Point &res)\n{\n    if(parallel(a,b))\n        return false;\n    double s1 = det(a.a-b.a,b.b-b.a);\n    double s2 = det(a.b-b.a,b.b-b.a);\n    res = (s1*a.b-s2*a.a)/(s1-s2);\n    return true;\n}\n \ndouble dis_segment_segment(Line a, Line b)\n{\n    Point res;\n    if(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n        return 0.;\n    return min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n \ndouble sqr(double x)\n{\n    return x * x;\n}\n \ndouble det(Point a, Point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n \ndouble dot(Point a, Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n    return (a-b).norm();\n}\n \nPoint rotate_point(Point p, double A)\n{\n    double tx = p.x, ty = p.y;\n    return Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n \nPoint reflect(Line l, Point p)\n{\n    return p + ((PointProjLine(p, l) - p) * 2.0);\n}\n \nbool in_segment(Line l, Point p)\n{\n    bool fa = false, fb = false;\n    if((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n        fa = true;\n    if((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n        fb = true;\n    return fa && fb;\n}\n \nint dcmp(double k)\n{\n    return k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\n \ndouble mysqrt(double n)\n{\n    return sqrt(max(0.0, n));\n}\n \nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n    double x0 = o.x, y0 = o.y;\n    double x1 = a.x, y1 = a.y;\n    double x2 = b.x, y2 = b.y;\n    double dx = x2 - x1, dy = y2 - y1;\n    double A = dx*dx+dy*dy;\n    double B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n    double C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n    double delta = B*B-4*A*C;\n    num = 0;\n    if(dcmp(delta) >= 0)\n    {\n        double t1 = (-B - mysqrt(delta)) / (2*A);\n        double t2 = (-B + mysqrt(delta)) / (2*A);\n        ret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n        ret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n    }\n     \n}\n \nPoint rotate(Point p, double cost, double sint)\n{\n    double x = p.x, y = p.y;\n    return Point(x*cost - y*sint, x*sint + y*cost);\n}\n \npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n    double d = (ap - bp).norm();\n    double cost = (ar*ar + d*d - br*br) / (2*ar*d);\n    double sint = sqrt(1. - cost*cost);\n    Point v = (bp - ap) / (bp - ap).norm() * ar;\n    return make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n \nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n \nstruct Node\n{\n    Point p;\n    Point q;\n    int id;\n    Node(Point p_ = Point(0.,0.), Point q_ = Point(0., 0.), int id_ = 4):p(p_), q(q_), id(id_){}\n    friend bool operator ==(Node a, Node b)\n    {\n        return cmp(a.p.x-b.p.x)==0 && cmp(a.p.y-b.p.y)==0;\n    }\n    friend bool operator <(Node a, Node b)\n    {\n        if(cmp(a.p.y-b.p.y)==0)\n            return a.id < b.id;\n        return a.p.y < b.p.y;\n    }\n} node[MAX * 2];\n \nset<double> s;\n \nint main()\n{   \n#ifdef LOCAL\n    //~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n \n    int n;\n    sfi(n);\n    int cnt = 0;\n    rep(i, 0, n - 1)\n    {\n        Point a, b;\n        scanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n        if(cmp(a.x-b.x)==0)\n        {\n            if(a.y < b.y)\n            {\n                node[cnt++] = Node(a, Point(0., 0.), 1);\n                node[cnt++] = Node(b, Point(0., 0.), 3);\n            }\n            else\n            {\n                node[cnt++] = Node(a, Point(0., 0.), 3);\n                node[cnt++] = Node(b, Point(0., 0.), 1);\n            }\n        }\n        else\n        {\n            if(a.x < b.x)\n                node[cnt++] = Node(a, b, 2);\n            else\n                node[cnt++] = Node(b, a, 2);\n        }\n         \n    }\n    sort(node, node + cnt);\n     \n    int ans = 0;\n    rep(i, 0, cnt - 1)\n    {\n        if(node[i].id == 3)\n        {\n            set<double>::iterator it = s.find(node[i].p.x);\n            s.erase(*it);\n        }\n        else if(node[i].id == 1)\n        {\n            s.insert(node[i].p.x);\n        }\n        else if(node[i].id == 2)\n        {\n            set<double>::iterator it = s.lower_bound(node[i].p.x);\n            for(; it != s.end() && (*it) <= node[i].q.x; it++)\n                ans++;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define INF 1e9\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int opt,l,r,x;}f[N*3];\nstruct seg{int ls,rs,su;}t[10000010];\nint nf,q,p1,p2,q1,q2,ansn,ro,num;\nbool comp(const Info &a,const Info &b){if (a.x==b.x) return a.opt<b.opt;return a.x<b.x;}\nint pa(int x){if (x>=0) return x/2;return (x-1)/2;}\nvoid add(int &nu,int l,int r,int we,int x){\n\tif (!nu) nu=++num;\n\tt[nu].su+=x;\n\tif (l!=r){\n\t\tint mid=pa(l+r);\n\t\tif (we<=mid) add(t[nu].ls,l,mid,we,x);\n\t\telse add(t[nu].rs,mid+1,r,we,x);\n\t}\n}\nint que(int nu,int l,int r,int nl,int nr){\n\tif (!nu) return 0;\n\tif (l==nl&&r==nr) return t[nu].su;\n\tint mid=pa(l+r);\n\tif (nl>mid)return que(t[nu].rs,mid+1,r,nl,nr);\n\tif (nr<=mid) return que(t[nu].ls,l,mid,nl,nr);\n\treturn que(t[nu].ls,l,mid,nl,mid)+que(t[nu].rs,mid+1,r,mid+1,nr);\n}\nint main(){\n\tread(q);\n\tfor (int i=1;i<=q;i++){\n\t\tread(p1);read(q1);read(p2);read(q2);\n\t\tif (p1==p2){\n\t\t\tif (q1>q2) swap(q1,q2);\n\t\t\tf[++nf].opt=1;f[nf].l=p1;f[nf].x=q1;\n\t\t\tf[++nf].opt=-1;f[nf].l=p1;f[nf].x=q2+1;\n\t\t}else{\n\t\t\tif (p1>p2) swap(p1,p2);\n\t\t\tf[++nf].opt=2;f[nf].l=p1;f[nf].r=p2;f[nf].x=q1;\n\t\t}\n\t}\n\tsort(f+1,f+nf+1,comp);\n\tfor (int i=1;i<=nf;i++){\n\t\tif (f[i].opt==2)ansn+=que(ro,-INF,INF,f[i].l,f[i].r);\n\t\telse add(ro,-INF,INF,f[i].l,f[i].opt);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        /*\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n        */\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の点の集合 ( 開始点と終了点で集合を分割する )\nvector<Point> v_parallel_x_start;\nvector<Point> v_parallel_x_end;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x_start.push_back(start);\n            v_parallel_x_end.push_back(end);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n    sort(v_parallel_x_start.begin(), v_parallel_x_start.end());\n    sort(v_parallel_x_end.begin(), v_parallel_x_end.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].y == v_parallel_y[j].p1.y )\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x_start.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x_start[p].x\n                && v_EP[i].y == v_parallel_x_start[p].y )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x_start[p].x; k <= v_parallel_x_end[p].x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n                //　線分は重ならないので, 1つ見つかれば処理終了\n                break;\n            }\n        }\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n            }\n        }\n\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        /*\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n        */\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の点の集合 ( 開始点と終了点で集合を分割する )\nvector<Point> v_parallel_x_start;\nvector<Point> v_parallel_x_end;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x_start.push_back(start);\n            v_parallel_x_end.push_back(end);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n    sort(v_parallel_x_start.begin(), v_parallel_x_start.end());\n    sort(v_parallel_x_end.begin(), v_parallel_x_end.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].y == v_parallel_y[j].p1.y )\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x_start.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x_start[p].x\n                && v_EP[i].y == v_parallel_x_start[p].y )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x_start[p].x; k <= v_parallel_x_end[p].x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n                //　線分は重ならないので, 1つ見つかれば処理終了\n                break;\n            }\n        }\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n            }\n        }\n\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(a*x, a*y); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector <Vector> Polygon;\n\nclass Segment {\n public:\n  Point p1, p2;\n\n  Segment(Point p1 = Point(), Point p2 = Point()): p1(p1), p2(p2) {}\n};\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\n public:\n  Point p;\n  int seg, st;\n  EndPoint() {}\n  EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n  bool operator < (const EndPoint &ep) const {\n    if (p.y == ep.p.y) {\n      return st < ep.st;\n    }else return p.y < ep.p.y;\n  }\n};\n\n// MAX_N:???????????°\n#define MAX_N 100000\n// MAX_P:??§?¨?????????§???(??¶??????)\n#define MAX_P 1000000000\nEndPoint EP[2*MAX_N];\n\n// ??????????????????: ????????????????????????\nint manhattanIntersection(vector<Segment> s) {\n  int n = s.size();\n\n  for (int i = 0, k = 0; i < n; i++) {\n    if (s[i].p1.y == s[i].p2.y) {\n      if (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n    }else if (s[i].p1.y > s[i].p2.y) {\n      swap(s[i].p1, s[i].p2);\n    }\n    if (s[i].p1.y == s[i].p2.y) {\n      EP[k++] = EndPoint(s[i].p1, i, LEFT);\n      EP[k++] = EndPoint(s[i].p2, i, RIGHT);\n    }else {\n      EP[k++] = EndPoint(s[i].p1, i, BOTTOM);\n      EP[k++] = EndPoint(s[i].p2, i, TOP);\n    }\n  }\n\n  sort(EP, EP+(2*n));\n\n  set<int> BT;\n  BT.insert(MAX_P+1);\n  int cnt = 0;\n\n  for (int i = 0; i < 2*n; i++) {\n    if (EP[i].st == TOP) {\n      BT.erase(EP[i].p.x);\n    }else if (EP[i].st == BOTTOM) {\n      BT.insert(EP[i].p.x);\n    }else if (EP[i].st == LEFT) {\n      set<int>::iterator b = lower_bound(BT.begin(), BT.end(), s[EP[i].seg].p1.x);\n      set<int>::iterator e = upper_bound(BT.begin(), BT.end(), s[EP[i].seg].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Segment> p;\n  for (int i = 0; i < n; i++) {\n    Segment l;\n    cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n    p.push_back(l);\n  }\n  cout << manhattanIntersection(p) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nstruct query {\n\tint type;\n\tint lx;\n\tint len;\n};\nint main() {\n\tint N; cin >> N;\n\tmultimap<int, query>mp;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 *= 3; x2 *= 3; y1 *= 3; y2 *= 3;\n\t\tif (x1 == x2) {\n\t\t\t\n\t\t\tif (y1 > y2)swap(y1, y2);\n\t\t\tassert(y1 <= y2);\n\t\t\ty1--;\n\t\t\ty2++;\n\t\t\tmp.insert(make_pair(y1,query{ 0,x1,y2 - y1 }));\n\t\t\tmp.insert(make_pair(y2, query{ 2,x1,y2 - y1 }));\n\t\t}\n\t\telse {\n\t\t\tif (x1 > x2)swap(x1, x2);\n\t\t\tassert(x1 <= x2);\n\t\t\tx1--;\n\t\t\tx2++;\n\t\t\tmp.insert(make_pair(y1, query{1,x1,x2 - x1 }));\n\t\t}\n\t}\n\tvector<int>lines;\n\tint ans = 0;\n\tfor (auto m : mp) {\n\t\tquery q(m.second);\n\t\tif (q.type==1) {\n\t\t\tauto lt = lower_bound(lines.begin(), lines.end(), q.lx);\n\t\t\tauto rt = upper_bound(lines.begin(), lines.end(), q.lx + q.len);\n\t\t\tans += rt - lt;\n\t\t}\n\t\telse if(q.type==0){\n\t\t\tlines.insert(lower_bound(lines.begin(), lines.end(), q.lx),q.lx);\n\t\t}\n\t\telse {\n\t\t\tlines.erase(lower_bound(lines.begin(), lines.end(), q.lx));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        int x, y;\n        // コンストラクタ\n        Point(int x = 0.0, int y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        bool operator < ( const Point &p) const\n        {\n            return y != p.y ? y < p.y : x < p.x;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return y != p.y ? y <= p.y : x <= p.x;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint solveManhattanGeometry(void);\n\n// y 座標を基準に並び替えた端点の集合\nvector<Point> v_EP;\n//　y軸と平行な線分の集合\nvector<Segment> v_parallel_y;\n// x軸と平行な線分の点の集合 ( 開始点と終了点で集合を分割する )\nvector<Point> v_parallel_x_start;\nvector<Point> v_parallel_x_end;\n\nint main(void)\n{\n\n    int n;\n    Point start, end;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        // 点の集合を作成\n        v_EP.push_back(start);\n        v_EP.push_back(end);\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分の集合を作成\n        Segment seg(start, end);\n\n        if( start.y == end.y )\n        {\n            // x軸と平行な線分の集合を作成\n            v_parallel_x_start.push_back(start);\n            v_parallel_x_end.push_back(end);\n        }\n        else\n        {\n            // y軸と平行な線分の集合を作成\n            v_parallel_y.push_back(seg);\n        }\n    }\n\n    // y の値について並び替える (比較関数はPointクラス内で定義)\n    sort(v_EP.begin(), v_EP.end());\n    sort(v_parallel_x_start.begin(), v_parallel_x_start.end());\n    sort(v_parallel_x_end.begin(), v_parallel_x_end.end());\n\n    // 結果の表示\n    printf(\"%d\\n\", solveManhattanGeometry());\n\n    return 0;\n}\n\n// 線分交差問題を解くための関数\nint solveManhattanGeometry(void)\n{\n    int count = 0;\n    // 2分探索木 ( x座標のみで構成 )\n    set<int> setX;\n\n    // y について並び替えた端点を順番に取り出す\n    for(int i = 0; i < v_EP.size(); i++)\n    {\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の下端点の時\n            if( v_EP[i].x == v_parallel_y[j].p1.x\n                && v_EP[i].y == v_parallel_y[j].p1.y)\n            {\n                setX.insert(v_parallel_y[j].p1.x);\n                break;\n            }\n\n        }\n\n        for(int p = 0; setX.size() > 0 && p < v_parallel_x_start.size(); p++)\n        {\n            // 端点が水平成分の左端点の時\n            if( v_EP[i].x == v_parallel_x_start[p].x\n                && v_EP[i].y == v_parallel_x_start[p].y )\n            {\n                // 走査線と重なった線分の x座標の範囲から交点を検索する\n                for(int k = v_parallel_x_start[p].x; k <= v_parallel_x_end[p].x; k++)\n                {\n                    if( setX.find(k) != setX.end() )\n                    {\n                        // 交点が見つかった\n                        count++;\n                    }\n                }\n\n                //　線分は重ならないので, 1つ見つかれば処理終了\n                break;\n            }\n        }\n\n        for(int j = 0; j < v_parallel_y.size(); j++)\n        {\n            // 端点が垂直成分の上端点の時\n            if( v_EP[i].x == v_parallel_y[j].p2.x\n                && v_EP[i].y == v_parallel_y[j].p2.y )\n            {\n                setX.erase(v_parallel_y[j].p1.x);\n                break;\n            }\n        }\n\n    }\n\n    return count;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nenum PointType {\n    BOTTOM,\n    LEFT,\n    RIGHT,\n    TOP,\n};\n\nstruct EndPoint {\n    Point p;\n    size_t seg;\n    PointType type;\n    EndPoint() {}\n    EndPoint(Point p, size_t s, PointType t): p(p), seg(s), type(t) {}\n    bool operator<(const EndPoint &rhs) const {\n        return imag(p)!=imag(rhs.p)? imag(p)<imag(rhs.p) : type<rhs.type;\n    }\n};\n\nsize_t num_mintersect(vector<LineSeg> g) {\n    size_t V=g.size();\n\n    vector<EndPoint> h;\n    for (size_t i=0; i<V; ++i) {\n        if (imag(g[i].first) == imag(g[i].second)) {\n            if (real(g[i].first) > real(g[i].second))\n                swap(g[i].first, g[i].second);\n        } else if (imag(g[i].first) > imag(g[i].second)) {\n            swap(g[i].first, g[i].second);\n        }\n\n        if (imag(g[i].first) == imag(g[i].second)) {\n            h.push_back(EndPoint(g[i].first, i, LEFT));\n            h.push_back(EndPoint(g[i].second, i, RIGHT));\n        } else {\n            h.push_back(EndPoint(g[i].first, i, BOTTOM));\n            h.push_back(EndPoint(g[i].second, i, TOP));\n        }\n    }\n    sort(h.begin(), h.end());\n\n    set<double> vlines;\n    vlines.insert(INF);\n\n    size_t count=0;\n    for (size_t i=0; i<(V<<1); ++i) {\n        if (h[i].type == TOP) {\n            vlines.erase(real(h[i].p));\n        } else if (h[i].type == BOTTOM) {\n            vlines.insert(real(h[i].p));\n        } else if (h[i].type == LEFT) {\n            set<double>::iterator lb=lower_bound(\n                vlines.begin(), vlines.end(), real(g[h[i].seg].first)\n            );\n            set<double>::iterator ub=upper_bound(\n                vlines.begin(), vlines.end(), real(g[h[i].seg].second)\n            );\n            count += distance(lb, ub);\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    vector<LineSeg> g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        g[i] = LineSeg(p1, p2);\n    }\n\n    printf(\"%zu\\n\", num_mintersect(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"inspect.hpp\"\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1>x2)swap(x1,x2);\n\t\tif(y1>y2)swap(y1,y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\t//sort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(-2000000000,-2000000000)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(-2000000000,-2000000000)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n; cin >> n;\n    \n    int x1[100000], y1[100000], x2[100000], y2[100000]; bool tate[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        \n        if(x1[i] == x2[i])\n        {\n            tate[i] = true;\n        }\n        else\n        {\n            tate[i] = false;\n        }\n    }\n    \n    int Ans = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            if(tate[i] == true && tate[j] == false)\n            {\n                if(y1[i] <= y1[j] && y1[j] <= y2[i] && x1[j] <= x1[i] && x1[i] <= x2[j])\n                {\n                    Ans++;\n                }\n            }\n            \n            if(tate[i] == false && tate[j] == true)\n            {\n                if(x1[i] <= x1[j] && x1[j] <= x2[i] && y1[j] <= y1[i] && y1[i] <= y2[j])\n                {\n                    Ans++;\n                }\n            }\n        }\n    }\n    \n    cout << Ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n    bool same(const P& a, const P& b) {\n      P p = a - b;\n      if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n        return true;\n      }\n      return false;\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n  int convex_point(const G &g,const P &p){\n    P q = p-P(-INF,imag(p));\n    double x = real(p),y = imag(p);\n    L l1(p,q);\n    ll cn = 0;\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      L l2 = L(a,b);\n      int k = ccw(a,b,p);\n      if(k == 0){\n        return 1; // p on g\n      }\n    }\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      double y1 = imag(a),y2 = imag(b);\n      if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n        L l2 = L(a,b);\n        P c = crosspoint(l1,l2);\n        if(x < real(c))\n          ++cn;\n      }\n    }\n    if(cn % 2) return 2; // p in g\n    return 0; // p out g\n  }\n  vector<P> convex_hull(vector<P> &ps){\n    sort(all(ps));\n    int k = 0;\n    int n = ps.size();\n    vector<P> qs(ps.size() * 2);\n    rep(i,ps.size()){\n      while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n        k--;\n      }\n      qs[k++] = ps[i];\n    }\n    for(int i = n-2,t = k; i >= 0; i--){\n      while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n        k--;\n      }\n      qs[k++] = ps[i] ;\n    }\n    qs.resize(k-1);\n    return qs;\n  }\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n  double convex_diameter(vector<P> &ps){\n    const int n = ps.size();\n    int is = 0,js = 0;\n    REP(i,1,n){\n      if(imag(ps[i]) > imag(ps[is])) is = i;\n      if(imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double d = norm(ps[is]-ps[js]);\n    int im,jm,i,j;\n    i = im = is;\n    j = jm = js;\n    do {\n      if(cross(diff(ps,i),diff(ps,j)) >= 0) j = (j+1) % n;\n      else i = (i+1) % n;\n      if(norm(ps[i]-ps[j]) > d){\n        d = norm(ps[i]-ps[j]);\n        im = i,jm = j;\n      }\n    } while (i != is || j != js);\n    return sqrt(d);\n  }\n  G convex_cut(G &g, L &l) {\n    G h;\n    rep(i, (int)g.size()) {\n      P p = curr(g, i), q = next(g, i);\n      if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n        if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n        else return G{};                        // p -- l.b -- l.a -- q\n      }\n      if (ccw(l[0], l[1], p) != -1) h.emplace_back(p);\n      if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0)\n        h.emplace_back(crosspoint(L(p, q), l));\n    }\n    return h;\n  }\n  double closestPair_calc(P *p,int n){\n    if(n < 2) return inf;\n    int m = n/2;\n    double x=real(p[m]);\n    double d = min(closestPair_calc(p,m),closestPair_calc(p+m,n-m));\n    inplace_merge(p,p+m,p+n,sorty);\n    vector<P> q;\n    double dx,dy;\n    rep(i,n) {\n      if(abs(real(p[i])-x)>=d)continue;\n\n      for(int j=q.size()-1;j>=0;j--)\n      {\n        dx=real(p[i])-real(q[j]);\n        dy=imag(p[i])-imag(q[j]);\n        if(dy>=d)break;\n        d=min(d,sqrt(dx*dx+dy*dy));\n      }\n      q.push_back(p[i]);\n    }\n    return d;\n  }\n  double closestPair(vector<P> &p,int n) {\n    if(n < 2) return 0.0;\n    sort(all(p));\n    double ans = closestPair_calc(&p[0],n);\n    return ans == inf ? 0.0 : ans;\n  }\n  P unit(const L &l){\n    P p = l[1] - l[0];\n    return p/abs(p);\n  }\n  P unit(const P &a,const P &b){\n    P p = b - a;\n    return p/abs(p);\n  }\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  vector<L> lx,ly;\n  double x,y;\n  L xp = L(P(0,0),P(1,0));\n  L yp = L(P(0,0),P(0,1));\n  rep(i,n){\n    cin >> x >> y;\n    P a(x,y);\n    cin >> x >> y;\n    P b(x,y);\n    L l(a,b);\n    if(linejudge(l,xp) == 2){\n      lx.emplace_back(l);\n    }\n    else{\n      ly.emplace_back(l);\n    }\n  }\n  sort(all(lx));\n  sort(all(ly));\n  ll cnt = 0;\n  rep(i,lx.size()){\n    int l = 0,r = ly.size(),tl,tr;\n    double x1 = real(lx[i][0]),x2 = real(lx[i][1]);\n    rep(j,100){\n      int m = (l+r)/2;\n      if(real(ly[m][0]) < x1){\n        l = m;\n      }\n      else{\n        r = m;\n      }\n    }\n    tl = l;\n    l = 0,r = ly.size();\n    rep(j,100){\n      int m = (l+r)/2;\n      if(real(ly[m][0]) > x2){\n        r = m;\n      }\n      else{\n        l = m;\n      }\n    }\n    tr = r;\n    REP(j,tl,tr){\n      if(intersectSS(lx[i],ly[j])){\n        ++cnt;\n      }\n    }\n  }\n  cout << cnt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF = 1000000001;\n\nint main(){\n  int n;\n  vector<pair<int,pii> > event;\n  set<int> list;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    int x1,y1,x2,y2;\n    scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n    if(y1==y2){\n      event.push_back(make_pair(min(x1,x2),pii(-INF,y1)));\n      event.push_back(make_pair(max(x1,x2),pii(INF,y1)));\n    }else if(x1==x2){\n      event.push_back(make_pair(x1,pii(min(y1,y2),max(y1,y2))));\n    }\n  }\n  sort(event.begin(),event.end());\n  int ans = 0;\n  for(int i=0;i<event.size();i++){\n    int y1 = event[i].second.first, y2 = event[i].second.second;\n    if(y1==-INF) list.insert(y2);\n    else if(y1==INF) list.erase(y2);\n    else ans += distance(list.lower_bound(y1),list.upper_bound(y2));\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn=1e5+10;\n\nstruct point{\n    int x,y;\n    point(){}\n    point(int x,int y):x(x),y(y){}\n} ;\n\nstruct segment{\n    point a,b;\n    int c;                  //用于排序，bottom>(left||right)>top\n    segment(point a,point b,int c):a(a),b(b),c(c){}\n    bool operator <(const segment & p){\n        if(a.y!=p.a.y) return a.y<p.a.y;\n        return c!=p.c?c<p.c:a.x<p.a.x;\n    }\n};\n\nvector<segment> v;\n\nint x[maxn];\n\nint tree[maxn<<2];\n\nvoid up(int p){\n    tree[p]=tree[p<<1]+tree[p<<1|1];\n}\n\nvoid modify(int p,int l,int r,int x,int v){\n    if(l==r){\n        tree[p]+=v;\n        return ;\n    }\n    int mid=l+r>>1;\n    if(x<=mid){\n        modify(p<<1,l,mid,x,v);\n    }else{\n        modify(p<<1|1,mid+1,r,x,v);\n    }\n    up(p);\n}\n\nint query(int p,int l,int r,int x,int y){\n    if(x<=l&&r<=y){\n        return tree[p];\n    }\n    int mid=l+r>>1;\n    int res=0;\n    if(x<=mid){\n        res+=query(p<<1,l,mid,x,y);\n    }\n    if(y>mid){\n        res+=query(p<<1|1,mid+1,r,x,y);\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int len=1;\n    for(int i=0;i<n;i++){\n        point a,b;\n        scanf(\"%d%d%d%d\",&a.x,&a.y,&b.x,&b.y);\n        if(a.x!=b.x){\n            if(a.x>b.x) swap(a,b);\n            x[len++]=a.x;\n            x[len++]=b.x;\n            v.push_back(segment(a,b,2));\n        }else{\n            if(a.y>b.y) swap(a,b);\n            x[len++]=a.x;\n            v.push_back(segment(a,a,1));\n            v.push_back(segment(b,b,3));\n        }\n    }\n    len--;\n//    printf(\"%d\\n\",len);\n    sort(x+1,x+len+1);\n    len=unique(x+1,x+len+1)-(x+1);\n//    for(int i=1;i<=len;i++){\n//        printf(\"%d \",x[i]);\n//    }\n    sort(v.begin(),v.end());\n    int vsize=v.size();\n//    for(int i=0;i<vsize;i++){\n//        printf(\"%d %d %d\\n\",v[i].a.x,v[i].a.y,v[i].c);\n//    }\n    int ans=0;\n    for(int i=0;i<vsize;i++){\n        if(v[i].a.x==v[i].b.x){\n            int id=lower_bound(x+1,x+len+1,v[i].a.x)-x;\n//            printf(\"--%d %d\\n\",v[i].a.x,id);\n            int c=v[i].c==3?-1:1;\n            modify(1,1,len,id,c);\n//            printf(\"123123123\\n\");\n        }else{\n            int id1=lower_bound(x+1,x+len+1,v[i].a.x)-x;\n            int id2=lower_bound(x+1,x+len+1,v[i].b.x)-x;\n//            printf(\"%d %d\\n\",v[i].a.x,id1);\n//            printf(\"%d %d\\n\",v[i].b.x,id2);\n            ans+=query(1,1,len,id1,id2);\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.lower_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\t\t\t\t\t\t       \n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n//closest pair:\nsigned AOJ_CGL5A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<fixed<<setprecision(12)<<closest_pair(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=jp\n*/\n\n//manhattanIntersection:\nsigned AOJ_CGL6A(){\n  int n;\n  cin>>n;\n  vector<Segment> ss(n);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  cout<<manhattanIntersection(ss,1e9+10)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/06/18\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp.size()==1u) pp.emplace_back(pp[0]);\n    if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7E(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto pp=getCrossPointCC(c1,c2);\n  if(pp.size()==1u) pp.emplace_back(pp[0]);\n  if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n  cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=jp\n*/\n\n//tangent to a Circle\nsigned AOJ_CGL7F(){\n  Point p;\n  Circle c;\n  cin>>p>>c;\n  auto pp=tangent(c,p);\n  for(auto p:pp) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//area of 2 circles' intersection\nsigned AOJ_2572(){\n  double uw,uh,a,b,ab;\n  while(cin>>uw>>uh>>a>>b>>ab,uw!=0){\n    Circle c1(Point(0,0),sqrt(a/PI));\n    Circle c2(Point(0,0),sqrt(b/PI));\n    bool f=0;\n    if(c1.r<=c2.r) swap(c1,c2),f=1;\n    double l=max(0.0,c1.r-c2.r),r=c1.r+c2.r+EPS;\n    for(int k=0;k<100;k++){\n      double m=(l+r)/2;\n      c2.c.x=m;\n      //cout<<area(c1,c2)<<endl;\n      if(area(c1,c2)<=ab) r=m;\n      else l=m;\n    }\n    c2.c.x=l;\n    \n    double EPS3=1e-4;\n    assert(abs(area(c1,c2)-ab)<=EPS3);\n\n    l=0,r=PI/2;\n    for(int k=0;k<200;k++){\n      double m=(l+r)/2;\n      Circle t=c2;\n      t.c=translate(c2.c,m);\n      if(c1.r+max(c1.r,t.c.x+t.r)<=uw) r=m;\n      else l=m;\n    }\n    c2.c=translate(c2.c,r);\n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n    \n    Vector v(c1.r,c1.r);\n    c1.c=c1.c+v;\n    c2.c=c2.c+v;\n    \n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n\n    if(f) swap(c1,c2);\n    f=1;\n    f&=(c1.c.x-c1.r>=-EPS3);\n    f&=(c1.c.x+c1.r<=uw+EPS3);\n    f&=(c1.c.y-c1.r>=-EPS3);\n    f&=(c1.c.y+c1.r<=uh+EPS3);\n    f&=(c2.c.x-c2.r>=-EPS3);\n    f&=(c2.c.x+c2.r<=uw+EPS3);\n    f&=(c2.c.y-c2.r>=-EPS3);\n    f&=(c2.c.y+c2.r<=uh+EPS3);\n    if(f) cout<<c1.c<<\" \"<<c1.r<<\" \"<<c2.c<<\" \"<<c2.r<<endl;\n    else cout<<\"impossible\"<<endl;\n    //else cout<<c1.c<<\" \"<<c1.r<<\"/\"<<c2.c<<\" \"<<c2.r<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/12/31\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2572\n*/\n\n//Segment Arrangement\nsigned AOJ_2454(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  \n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<fixed<<setprecision(12)<<ans-tmp<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/27\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2454\n*/\n\n\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  //AOJ_CGL5A();\n\n  AOJ_CGL6A();\n  \n  //AOJ_CGL7A();\n  //AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7F();\n  //AOJ_CGL7G();\n\n  //AOJ_2572();\n  //AOJ_2454();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1>x2)swap(x1,x2);\n\t\tif(y1>y2)swap(y1,y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\t//sort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(-2000000000,-2000000000)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(-2000000000,-2000000000)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <set>\n#include <iterator>         // distance()\n#include <algorithm>        // swap(), sort(), lower_bound(), upper_bound()\n\nusing namespace std;\nstatic const int MAX_N = 100000;\nenum { BOTTOM = 0, LEFT, RIGHT, TOP };\n\nstruct Point\n{\n\tint x;\n\tint y;\n};\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\n\nclass EndPoint\n{\npublic:\n\tPoint p;\n\tint seg; // ??\\????????????ID\n\tint st;  // ??????????¨????\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\tbool operator < (const EndPoint &ep) const\n\t{\n\t\t// y ??§?¨?????°???????????????´???\n\t\tif (p.y != ep.p.y)\n\t\t\treturn p.y < ep.p.y;\n\t\telse\n\t\t\treturn st < ep.st; // y ??????????????´????????????????????????????????????????????????????????????????????????\n\t}\n};\n\nSegment S[MAX_N];\nEndPoint EP[2 * MAX_N]; // ??????????????????\nint n;\n\n// ??????????????????: ????????????????????????\nint\nmanhattanIntersection()\n{\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\t// ?????? p1,p2 ??????????????????????????¶??????????????´\n\t\tif (S[i].p1.y == S[i].p2.y)\n\t\t{\n\t\t\tif (S[i].p1.x > S[i].p2.x)\n\t\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\telse if (S[i].p1.y > S[i].p2.y)\n\t\t\tswap(S[i].p1, S[i].p2);\n\n\t\tif (S[i].p1.y == S[i].p2.y) // ?°´????????????????????????????????????\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\n\t\telse // ?????´?????????????????????????????????\n\t\t{\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP, EP + k); // ????????? y ??§?¨??????¢?????????????????´???\n\n\tset<int> BT; // ????????¢?????¨\n\tBT.insert(1000000001); // ??????????¨????\n\n\tint cnt = 0;\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tif (EP[i].st == TOP)\n\t\t\tBT.erase(EP[i].p.x); // ??????????????????\n\t\telse if (EP[i].st == BOTTOM)\n\t\t\tBT.insert(EP[i].p.x); // ??????????????????\n\t\telse if (EP[i].st == LEFT)\n\t\t{\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x); // O(log n)\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x); // O(log n)\n\t\t\tcnt += distance(b, e); // b ??¨ e ????????¢(????????°)????????????O(k)\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d %d %d %d\", &S[i].p1.x, &S[i].p1.y, &S[i].p2.x, &S[i].p2.y);\n\n\tprintf(\"%d\\n\", manhattanIntersection());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof(a))\n#define pb(a)    push_back(a)\n#define il       inline\n#define reg      register\ntypedef long long ll;\ntypedef double db;\nconst int maxn=10000;\nconst int minn=200000+5;\nstruct Point\n{\n    db x,y;\n    Point(){}\n    Point(db x,db y):x(x),y(y){}\n};\nstruct Seg\n{\n    Point a,b;\n    int c;\n    Seg(Point a,Point b,int c):a(a),b(b),c(c){}\n    friend bool operator<(Seg p,Seg q){\n        if(p.a.y!=q.a.y) return p.a.y<q.a.y;\n    \treturn p.a.x<q.a.x;\n    }\n};\ndb  x[minn<<2];\nint q,lenx,ans,tree[minn<<2];\nvector<Seg> ve;\nvoid init()\n{\n    clr(tree,0);\n    ve.clear();\n    lenx=0;\n    ans=0;\n    return ;\n}\nvoid  pushpu(int k,int c)\n{\n    while(k)\n    {\n        tree[k]+=c;\n        k>>=1;\n    }\n}\nvoid update(int l,int r,int nu,int c,int k)\n{\n    if(nu==l&&r==nu)\n    {\n        pushpu(k,c);\n        return ;\n    }\n    int mind=(l+r)/2;\n    if(nu<=mind){update(l,mind,nu,c,k<<1);}\n    if(nu>mind) {update(mind+1,r,nu,c,k<<1|1);}\n    return ;\n}\nvoid query(int l,int r,int L,int R,int k)\n{\n    if(L<=l&&r<=R)\n    {\n        ans+=tree[k];\n        return ;\n    }\n    int mind=(l+r)/2;\n    if(L<=mind){query(l,mind,L,R,k<<1);}\n    if(R>mind) {query(mind+1,r,L,R,k<<1|1);}\n    return ;\n}\nint slove()\n{\n    sort(ve.begin(),ve.end());\n    sort(x,x+lenx);\n    int res=0;\n    for(reg int i=0;i<ve.size();i++)\n    {\n        if(ve[i].a.x==ve[i].b.x){\n            int nu=lower_bound(x,x+lenx,ve[i].a.x)-x+1;\n            int c=ve[i].c>2?-1:ve[i].c;\n//            printf(\"%d %d \\n\",ve[i].c,c);\n            update(1,lenx,nu,c,1);\n        }\n        else\n        {\n            ans=0;\n            int l=lower_bound(x,x+lenx,ve[i].a.x)-x+1;\n            int r=lower_bound(x,x+lenx,ve[i].b.x)-x+1;\n            query(1,lenx,l,r,1);\n            res+=ans;\n        }\n    }\nreturn res;\n}\nint main()\n{\n//    freopen(\"data.txt\",\"r\",stdin);\n    init();\n    scanf(\"%d\",&q);\n    Point a,b;\n    while(q--)\n    {\n        scanf(\"%lf%lf\",&a.x,&a.y);\n        scanf(\"%lf%lf\",&b.x,&b.y);\n        if(a.x>b.x||a.y>b.y){swap(a,b);}\n        if(a.x!=b.x)\n        {\n            x[lenx++]=a.x;x[lenx++]=b.x;\n            ve.pb(Seg(a,b,2));\n        }\n        else\n        {\n            x[lenx++]=a.x;\n            ve.pb(Seg(a,a,1));\n            ve.pb(Seg(b,b,3));\n        }\n    }\n    printf(\"%d\\n\",slove());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // ????????\\???\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // ????????????????????????\nld dot(Point a, Point b) { return real(conj(a) * b); } // ??????\nld cross(Point a, Point b) { return imag(conj(a) * b); } // ??????\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t // ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n/* ????????????(????????????????????????) */\n// ??????????¨????\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tll seg, st; // ??\\????????????ID, ??????????¨????\n\tEndPoint() {}\n\tEndPoint(Point p, ll seg, ll st) :p(p), seg(seg), st(st) {}\n\t\n\tbool operator < (const EndPoint& ep) const {\n\t\t// y ??§?¨?????°???????????????´???\n\t\tif (p.imag() == ep.p.imag()) {\n\t\t\treturn st < ep.st; // y ??????????????´??????, ?????????, ?????????, ?????????, ???????????????????????????\n\t\t}\n\t\telse return p.imag() < ep.p.imag();\n\t}\n};\n\nvector<EndPoint> EP;\n// ??????????????????: ????????????????????????\nll manhattanIntersection(vector<Line> S) {\n\tll n = S.size();\n\n\tfor (int i = 0, k = 0; i < n;i++) {\n\t\t// ?????? p1, p2 ??????????????????????????¶??????????????´\n\t\tif (S[i].a.imag() == S[i].b.imag()) {\n\t\t\tif (S[i].a.real() > S[i].b.real()) swap(S[i].a, S[i].b);\n\t\t}\n\t\telse if (S[i].a.imag() > S[i].b.imag()) swap(S[i].a, S[i].b);\n\n\t\tif (S[i].a.imag() == S[i].b.imag()) {\t// ?°´????????????????????????????????????\n\t\t\tEP[k++] = EndPoint(S[i].a, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].b, i, RIGHT);\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t// ?????´?????????????????????????????????\n\t\t\tEP[k++] = EndPoint(S[i].a, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].b, i, TOP);\n\t\t}\n\t}\n\tsort(EP.begin(), EP.end()); // ????????? y ??§?¨??????¢?????????????????´???\n\n\tset<ll> BT; // ????????¢?´¢??¨\n\tBT.insert(INF); // ??????????¨????\n\tll cnt = 0;\n\n\tfor (int i = 0; i < 2 * n;i++) {\n\t\tif (EP[i].st == TOP) {\n\t\t\tBT.erase(EP[i].p.real()); // ??????????????????\n\t\t}\n\t\telse if (EP[i].st == BOTTOM) {\n\t\t\tBT.insert(EP[i].p.real()); // ??????????????????\n\t\t}\n\t\telse if (EP[i].st == LEFT) {\n\t\t\tauto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].a.real()); // O(log n)\n\t\t\tauto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].b.real()); // O(log n)\n\t\t\tcnt += distance(b, e); // b ??¨ e ????????¢(????????°)?????????, O(k)\n\t\t}\n\t}\n\treturn cnt;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tEP.resize(2 * n);\n\tvector<Line> S;\n\tfor (int i = 0; i < n;i++) {\n\t\tPoint a = input_point(), b = input_point();\n\t\tS.push_back(Line(a, b));\n\t}\n\tcout << manhattanIntersection(S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nstruct Seg{\n    int x1, x2, y1, y2;\n    Seg(int x1, int y1, int x2, int y2) :x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nbool yparaAsc( const Seg& left, const Seg& right ) {\n    return left.x1 != right.x1 ? left.x1 < right.x1 : left.y1 < right.y1;\n};\n\nstruct Time{\n    int x; //x??§?¨?\n    int y; //y??§?¨?\n    int act; //?????????????????????0 ??§?????????1 ??§?????????\n    Time(int x, int y, int act) : x(x), y(y), act(act) {}\n\n    bool operator<( const Time& right ) const {\n        return x != right.x ? x < right.x : act < right.act;\n    }\n};\n\nint segmentIntersection(vector<Seg> &input){\n    int n = input.size();\n    vector<Seg> xpara, ypara;\n    for (int i=0;i<n;i++){\n        Seg s = input[i];\n        if(s.x1 == s.x2) ypara.push_back(s);\n        if(s.y1 == s.y2) xpara.push_back(s);\n    }\n\n    sort(ypara.begin(), ypara.end(), yparaAsc);\n\n    vector<Time> Timeline;\n    for (int i=0;i<xpara.size();i++){\n        Seg s = xpara[i];\n        Time t1(s.x1, s.y1, 0), t2(s.x2, s.y1, 1);\n        Timeline.push_back(t1);\n        Timeline.push_back(t2);\n    }\n    sort(Timeline.begin(), Timeline.end());\n\n    set<int> st;\n    int i=0;\n    int j=0;\n    int S=0;\n    while(1){\n        if(i >= ypara.size() && j >= Timeline.size()) break;\n\n        if(i >= ypara.size()){\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n            continue;\n        }\n\n        if(j >= Timeline.size()){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            i++;\n            continue;\n        }\n\n        if((ypara[i].x1 < Timeline[j].x) || (ypara[i].x1 == Timeline[j].x && Timeline[j].act == 1)){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            i++;\n        }else{\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n        }\n    }\n    return S;\n}\n\nint main(){\n    int n, x1, x2, y1, y2;\n    cin >> n;\n    vector<Seg> input;\n    for (int i=0;i<n;i++){\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n        Seg s(x1, y1, x2, y2);\n        input.push_back(s);\n    }\n\n    cout << segmentIntersection(input) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point {\npublic:\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point():x(0),y(0){}\n\n    Point operator + (Point p) {return Point(x + p.x,y + p.y);}\n    Point operator - (Point p ){return Point(x - p.x,y - p.y);}\n    Point operator * (double a){return Point(x*a,y*a);}\n    Point operator / (double a){return Point(x/a,y/a);}\n\n    double abs(){return sqrt(norm());}\n    double norm(){return x * x + y * y;}\n\n    bool operator < (const Point & p) const {\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n      return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n\n    void set(double x,double y) {\n      this->x = x;\n      this->y = y;\n    }\n\n    void rotateR(){\n      double xt = x;\n      double yt = y;\n      x = yt;\n      y = -xt;\n    }\n    void rotateL(){\n      double xt = x;\n      double yt = y;\n      x = -yt;\n      y = xt;\n    }\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0):c(c),r(r){}\n};\n\n\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble norm(Point a){\n  return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n  return sqrt(norm(a));\n}\n\n//等しいか\nbool eq(Point a,Point b){\n  return abs(a-b) < EPS;\n}\n\n//内積\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\n\n//外積\ndouble cross(Vector a,Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\n//直交か\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//平行か\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//射影\nPoint project(Segment s,Point p){\n  Point vec1,vec2;\n  vec1 = s.p2 - s.p1;\n  vec2 = p - s.p1;\n  return s.p1 + vec1 * dot(vec1,vec2) / vec1.norm();\n}\n\n//反射\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p) - p)* 2;\n}\n\n//位置関係(時計回りか,線分上かなど)\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(a.norm() < b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n//交わるか\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\n//交わるか\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistance(Point a,Point b){\n  return abs(a-b);\n}\n\n// Line : Point\ndouble getDistanceLP(Line l,Point p){\n  return abs((cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1)));\n}\n\n// Segment : Point\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2 - s.p1,p - s.p1) < 0.0){\n    return abs(p - s.p1);\n  }\n  if(dot(s.p1 - s.p2,p - s.p2) < 0.0){\n    return abs(p - s.p2);\n  }\n  return getDistanceLP(s,p);\n}\n\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)){\n    return 0.0;\n  }\n  double ans = INF;\n  chmin(ans,getDistanceSP(s1,s2.p1));\n  chmin(ans,getDistanceSP(s1,s2.p2));\n  chmin(ans,getDistanceSP(s2,s1.p1));\n  chmin(ans,getDistanceSP(s2,s1.p2));\n  return ans;\n}\n\n//交わるか\nbool intersect(Circle c,Line l){\n  return c.r - getDistanceLP(l,c.c) > -EPS;\n}\n\n//円と直線の交点\npair<Point,Point> getCrossPoint(Line l,Circle c){\n  assert(intersect(c,l));\n  Vector pr = project(l,c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  if(e.x < 0 || (e.x < EPS && e.y < 0)){\n    e = e * -1;\n  }\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr - e * base,pr + e * base);\n}\n\n//交わるか\nbool intersect(Circle c1,Circle c2){\n  double dis = getDistance(c1.c,c2.c);\n  return c1.r + c2.r - dis > -EPS && abs(c1.r - c2.r) - dis < EPS;\n}\n\n//atan\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\n//極座標から平面座標へ\nVector polar(double a,double r){\n  return Point(cos(r) * a ,sin(r) * a);\n}\n\n//円と円の交点\npair<Point,Point> getCrossPoint(Circle c1,Circle c2){\n  assert(intersect(c1,c2));\n  double d = abs(c1.c-c2.c);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = arg(c2.c - c1.c);\n  //cout << d << a << t;\n  return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r,t-a));\n}\n\n\n\n//内包\n// IN:2,ON:1,OUT:0\nint contains(Polygon g,Point p){\n  ull n = g.size();\n  bool x = false;\n  rep(i,n){\n    Point a = g[i] - p;\n    Point b = g[(i+1) % n] - p;\n    if(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1; //線分上にある\n    if(a.y > b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x; //3つ目の条件は、時計回りか半時計回りか\n  }\n  return (x ? 2 : 0);\n}\n\n//凸包:Convex Hull\n//凸包の辺上の点を含む場合は、!= CLOCKWISE を == COUNTER_CLOCKWIS　に置き換える!\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size() < 3){\n    return s;\n  }\n  sort(all(s));//xの昇順にソート\n  //xが小さいものから二つuに追加\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  //xが大きいものから２つuに追加\n  l.push_back(s[s.size() - 1]);\n  l.push_back(s[s.size() - 2]);\n\n  ull len = s.size();\n  //凸包の上部を生成\n  for(ll i = 2;i < len;i++){\n    for(ull n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) == COUNTER_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  //凸包の下部を生成\n  for(ll i = len-3;i >= 0;i--){\n    for(ull n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) == COUNTER_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  //時計回りになる様に凸包の天の列の生成\n  reverse(all(l));\n  for(ull i = u.size()-2;i >= 1;i--){\n    l.push_back(u[i]);\n  }\n  return l;\n}\n\n//端点の種類\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint{\npublic:\n    Point p;\n    ll seg,st; //入力線分のID,端点の種類\n    EndPoint(){}\n    EndPoint(Point p,ll seg,ll st):p(p),seg(seg),st(st){}\n\n    bool operator <(const EndPoint &ep)const{\n      //y座標が小さい順に整列\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n};\n\n/*********************/\nEndPoint EP[2 * 100000]; //端点のリスト\n\n//線分交差問題: マンハッタン幾何\nll manhattanIntersection(vector<Segment> S){\n  ull n = S.size();\n  for(int i = 0,k=0;i < n;i++){\n    //端点p1,p2が左下を基準に並ぶ様に調節\n    if(S[i].p1.y == S[i].p2.y){\n      if(S[i].p1.x > S[i].p2.x){\n        swap(S[i].p1,S[i].p2);\n      }\n    }else if(S[i].p1.y > S[i].p2.y){\n      swap(S[i].p1,S[i].p2);\n    }\n\n    if(S[i].p1.y == S[i].p2.y){\n      EP[k++] = EndPoint(S[i].p1,i,LEFT);\n      EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n    }else{\n      EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n      EP[k++] = EndPoint(S[i].p2,i,TOP);\n    }\n  }\n  sort(EP,EP + (2 * n)); // 端点のy座標に関して昇順に整列\n\n  set<ll> BT; //二分探索木\n  BT.insert(INF); //番兵を設置\n  ll cnt = 0;\n\n  for(ll i = 0;i < 2*n;i++){\n    //cout << EP[i].p.x << \" \" << EP[i].p.y << endl;\n    if(EP[i].st == TOP){\n      BT.erase(EP[i].p.x); //上端点を削除\n    }else if(EP[i].st == BOTTOM){\n      BT.insert(EP[i].p.x);\n    }else if(EP[i].st == LEFT){\n      auto b = BT.lower_bound(S[EP[i].seg].p1.x); //O(log n)\n      auto e = BT.upper_bound(S[EP[i].seg].p2.x); //O(log n)\n      cnt += abs(distance(BT.begin(),b) - distance(BT.begin(),e)); //bとeの距離(点の数)を加算, O(k)\n    }\n  }\n\n  return cnt;\n}\n\n\nint main() {\n  ll n;\n  cin >> n;\n  double x1,x2,y1,y2;\n  vector<Segment> s(n);\n  rep(i,n){\n    cin >> x1 >> y1 >> x2 >> y2;\n    s[i].p1 = Point(x1,y1);\n    s[i].p2 = Point(x2,y2);\n  }\n  cout << manhattanIntersection(s) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntemplate<typename T> bool equals(T a, T b){ return (fabs(a - b)) < EPS;};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstatic const int NOTCROSS = 4;\nstatic const int CIRCUMSCRIBED = 3; \nstatic const int INTERSECT = 2;\nstatic const int INSCRIBED = 1;\nstatic const int INCLUDE = 0;\n\nconst double PI = acos(-1);\n\nclass Point{\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(const Point &p) { x = p.x; y = p.y;};\n\t\n\tPoint operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (const double &a) { return Point(x * a, y * a); }\n\tPoint operator / (const double &a) { return Point(x / a, y / a); }\n\t\n\tPoint & operator = (const Point& p) {x = p.x; y = p.y; return *this;};\n\tPoint & operator += (const Point& p) {x += p.x; y += p.y; return *this;};\n\tPoint & operator -= (const Point& p) {x -= p.x; y -= p.y; return *this;};\n\tPoint & operator *= (const Point& p) {x *= p.x; y *= p.y; return *this;};\n\tPoint & operator /= (const Point& p) {x /= p.x; y /= p.y; return *this;};\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\t\n\tbool operator > (const Point &p) const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\t\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\t\n\tdouble abs() { return sqrt(norm()); };\n\tdouble norm() { return x * x + y * y;};\n};\n\ntypedef Point Vector;\n\n\ndouble norm(Vector a){\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Segment{\n\tPoint p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isPrallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < - EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersect(Circle c1, Circle c2){\n\tdouble dis = abs(c1.c - c2.c);\n\t\n\tif(dis > c1.r + c2.r + EPS) return NOTCROSS;\n\tif(fabs(dis - c1.r - c2.r) < EPS) return CIRCUMSCRIBED;\n\tif(dis > fabs(c1.r - c2.r) + EPS) return INTERSECT;\n\tif(fabs(dis - fabs(c1.r - c2.r)) < EPS) return INSCRIBED;\n\treturn INCLUDE;\n}\n\ndouble getDistace(Point a, Point b){\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrosPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l){\n\treturn getDistanceLP(l, c.c) < c.r + EPS;\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\tassert(intersect(c,l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e *base);\n}\n\ndouble arg(Vector p) {return atan2(p.y, p.x);}\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a);}\n\n\npair<Point, Point> getCrosPoint(Circle c1, Circle c2){\n\tPoint res1, res2;\n\tint ins = intersect(c1, c2);\n\tif(ins == NOTCROSS || ins == INCLUDE) {\n\t\tassert(false); // 0\n\t}\n\tif(ins == INSCRIBED && equals(c1.r, c2.r)){\n\t\tassert(false); // infinity\n\t}\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tres1 = c1.c + polar(c1.r, t + a);\n\tres2 = c1.c + polar(c1.r, t - a);\n\treturn make_pair(res1, res2);\n}\n\n\ndouble getArea(Circle c){\n\treturn c.r*c.r*PI;\n}\n\ndouble getArea(Polygon& p){\n\tdouble area = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tarea += (p[i].x * p[(i + 1) % p.size()].y - p[(i + 1) % p.size()].x * p[i].y);\n\t}\n\t\n\treturn fabs(area)/2;\n}\n\nbool isConvex(Polygon& p){\n\tint b = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tint j = (i + 1) % p.size(), k = (i + 2) % p.size();\n\t\tint c = ccw(p[i], p[j], p[k]);\n\t\tif(c == ON_SEGMENT || c == ONLINE_BACK || c == ONLINE_FRONT) continue;\n\t\tif(c*b < 0) return false;\n\t\tif(!b) b = c;\n\t}\n\t\n\treturn 1;\n}\n\n/*\nIN 2, ON 1, OUT 0\n*/\nint contains(Polygon &g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\tfor(int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s){\n\tPolygon u, l;\n\tif(s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor(int i = 2; i < s.size(); i++){\n\t\t// for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; n--){ //凸包の辺上の点を含めない\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){ //凸包の辺上の点を含める\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i = s.size() - 3; i >= 0; i--){\n\t\t// for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; n--){ //凸包の辺上の点を含めない\n\t\tfor(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; n--){ //凸包の辺上の点を含める\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(), l.end());\n\tfor(int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\t\n\treturn l;\n}\n\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st;\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\t\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t} else return p.y < ep.p.y;\n\t}\n};\n\n\nint manhattanIntersection(vector<Segment> S){\n\tconst int BOTTOM = 0;\n\tconst int LEFT = 1;\n\tconst int RIGHT = 2;\n\tconst int TOP = 3;\n\tint n = S.size();\n\tvector<EndPoint> EP(2*n);\n\t\n\t\n\tfor(int i = 0, k = 0; i < n; i++){\n\t\tif(S[i].p1.y == S[i].p2.y){\n\t\t\tif(S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t} else if(S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\t\t\n\t\tif(S[i].p1.y == S[i].p2.y){\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\t\n\tsort(EP.begin(), EP.end());\n\t\n\tset<int> BT;\n\tconst int INF = (1<<30);\n\tBT.insert(INF);\n\tint cnt = 0;\n\t\n\tfor(int i = 0; i < 2*n; i++){\n\t\tif(EP[i].st == TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t} else if(EP[i].st== BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t} else if(EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\t\n\treturn cnt;\t\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(0);\n\t\n\tint n, q, bi;\n\tPolygon p, ans;\n\tvector<Segment> s;\n\t\n\tcin>>n;\n\t\n\ts.resize(n);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>s[i].p1.x>>s[i].p1.y;\n\t\tcin>>s[i].p2.x>>s[i].p2.y;\n\t}\n\t\n\tcout<<manhattanIntersection(s)<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n    bool same(const P& a, const P& b) {\n      P p = a - b;\n      if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n        return true;\n      }\n      return false;\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n  int convex_point(const G &g,const P &p){\n    P q = p-P(-INF,imag(p));\n    double x = real(p),y = imag(p);\n    L l1(p,q);\n    ll cn = 0;\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      L l2 = L(a,b);\n      int k = ccw(a,b,p);\n      if(k == 0){\n        return 1; // p on g\n      }\n    }\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      double y1 = imag(a),y2 = imag(b);\n      if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n        L l2 = L(a,b);\n        P c = crosspoint(l1,l2);\n        if(x < real(c))\n          ++cn;\n      }\n    }\n    if(cn % 2) return 2; // p in g\n    return 0; // p out g\n  }\n  vector<P> convex_hull(vector<P> &ps){\n    sort(all(ps));\n    int k = 0;\n    int n = ps.size();\n    vector<P> qs(ps.size() * 2);\n    rep(i,ps.size()){\n      while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n        k--;\n      }\n      qs[k++] = ps[i];\n    }\n    for(int i = n-2,t = k; i >= 0; i--){\n      while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n        k--;\n      }\n      qs[k++] = ps[i] ;\n    }\n    qs.resize(k-1);\n    return qs;\n  }\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n  double convex_diameter(vector<P> &ps){\n    const int n = ps.size();\n    int is = 0,js = 0;\n    REP(i,1,n){\n      if(imag(ps[i]) > imag(ps[is])) is = i;\n      if(imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double d = norm(ps[is]-ps[js]);\n    int im,jm,i,j;\n    i = im = is;\n    j = jm = js;\n    do {\n      if(cross(diff(ps,i),diff(ps,j)) >= 0) j = (j+1) % n;\n      else i = (i+1) % n;\n      if(norm(ps[i]-ps[j]) > d){\n        d = norm(ps[i]-ps[j]);\n        im = i,jm = j;\n      }\n    } while (i != is || j != js);\n    return sqrt(d);\n  }\n  G convex_cut(G &g, L &l) {\n    G h;\n    rep(i, (int)g.size()) {\n      P p = curr(g, i), q = next(g, i);\n      if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n        if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n        else return G{};                        // p -- l.b -- l.a -- q\n      }\n      if (ccw(l[0], l[1], p) != -1) h.emplace_back(p);\n      if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0)\n        h.emplace_back(crosspoint(L(p, q), l));\n    }\n    return h;\n  }\n  double closestPair_calc(P *p,int n){\n    if(n < 2) return inf;\n    int m = n/2;\n    double x=real(p[m]);\n    double d = min(closestPair_calc(p,m),closestPair_calc(p+m,n-m));\n    inplace_merge(p,p+m,p+n,sorty);\n    vector<P> q;\n    double dx,dy;\n    rep(i,n) {\n      if(abs(real(p[i])-x)>=d)continue;\n\n      for(int j=q.size()-1;j>=0;j--)\n      {\n        dx=real(p[i])-real(q[j]);\n        dy=imag(p[i])-imag(q[j]);\n        if(dy>=d)break;\n        d=min(d,sqrt(dx*dx+dy*dy));\n      }\n      q.push_back(p[i]);\n    }\n    return d;\n  }\n  double closestPair(vector<P> &p,int n) {\n    if(n < 2) return 0.0;\n    sort(all(p));\n    double ans = closestPair_calc(&p[0],n);\n    return ans == inf ? 0.0 : ans;\n  }\n  P unit(const L &l){\n    P p = l[1] - l[0];\n    return p/abs(p);\n  }\n  P unit(const P &a,const P &b){\n    P p = b - a;\n    return p/abs(p);\n  }\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  vector<L> lx,ly;\n  double x,y;\n  L xp = L(P(0,0),P(1,0));\n  L yp = L(P(0,0),P(0,1));\n  rep(i,n){\n    cin >> x >> y;\n    P a(x,y);\n    cin >> x >> y;\n    P b(x,y);\n    if(b < a) swap(a,b);\n    L l(a,b);\n    if(linejudge(l,xp) == 2){\n      lx.emplace_back(l);\n    }\n    else{\n      ly.emplace_back(l);\n    }\n  }\n  sort(all(lx));\n  sort(all(ly));\n  ll cnt = 0;\n  rep(i,lx.size()){\n    int l = 0,r = ly.size(),tl,tr;\n    double x1 = real(lx[i][0]),x2 = real(lx[i][1]);\n    rep(j,100){\n      int m = (l+r)/2;\n      if(real(ly[m][0]) < x1){\n        l = m;\n      }\n      else{\n        r = m;\n      }\n    }\n    tl = l;\n    l = 0,r = ly.size();\n    rep(j,100){\n      int m = (l+r)/2;\n      if(real(ly[m][0]) > x2){\n        r = m;\n      }\n      else{\n        l = m;\n      }\n    }\n    tr = r;\n    /* cout << endl;                                          */\n    /* std::cout << lx[i][0] << ' ' << lx[i][1] << std::endl; */\n    /* cout << endl;                                          */\n    REP(j,tl,tr){\n      /* std::cout << ly[j][0] << ' ' << ly[j][1]; */\n      if(intersectSS(lx[i],ly[j])){\n        ++cnt;\n        /* cout << 'o'; */\n      }\n      /* cout << endl; */\n    }\n  }\n  cout << cnt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a + EPS > b; }\ninline bool Grt(ld a, ld b){ return a > b + EPS; }\ninline bool Leq(ld a, ld b){ return a < b + EPS; }\ninline bool Lss(ld a, ld b){ return a + EPS < b; }\ninline bool Equ(ld a, ld b){ return Geq(a, b) && Geq(b, a); }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nbool byX(const PT &a, const PT &b){\n\tif (Equ(a.X, b.X))\n\t\t\treturn Lss(a.Y, b.Y);\n\t\treturn Lss(a.X, b.X);\n}\n\n\nstruct cmpXY{\n\tbool operator ()(const PT &a, const PT &b){\n\t\treturn byX(a, b);\n\t}\n};\n\nstruct cmpYX{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.Y, b.Y))\n\t\t\treturn Lss(a.X, b.X);\n\t\treturn Lss(a.Y, b.Y);\n\t}\n};\n\n\n\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}\n\nint main(){\t\n\tvector <PT> adds, rems;\n\tvector <LS> query;\n\tfor (int i = in(); i; i--){\n\t\tPT p, q;\n\t\tcin >> p >> q;\n\t\tif (Equ(p.Y, q.Y)){\n\t\t\tif (byX(q, p))\n\t\t\t\tswap(p, q);\n\t\t\tadds.pb(p);\n\t\t\trems.pb(q);\n\t\t}\n\t\telse{\n\t\t\tif (Lss(q.Y, p.Y))\n\t\t\t\tswap(p, q);\n\t\t\tquery.pb({p, q});\n\t\t}\n\t}\n\tsort(adds.begin(), adds.end(), cmpXY());\n\tsort(rems.begin(), rems.end(), cmpXY());\n\tsort(query.begin(), query.end(), [](LS a, LS b){ return byX(a.F, b.F); });\n\tmultiset <ld> ys;\n\tint iadd = 0, irem = 0;\n\tint ans = 0;\n\tfor (auto p : query){\n//\t\tcout << p.F << ' ' << p.S << endl;\n\t\twhile (irem < rems.size() && Lss(rems[irem].X, p.F.X) && ys.find(rems[irem].Y) != ys.end()){\n//\t\t\tcout << \"remove \" << rems[irem].Y << endl;\n\t\t\tys.erase(ys.find(rems[irem++].Y));\n\t\t}\n\t\twhile (iadd < adds.size() && Leq(adds[iadd].X, p.F.X)){\n//\t\t\tcout << \"add \" << adds[iadd].Y << endl;\n\t\t\tys.insert(adds[iadd++].Y);\n\t\t}\n\t\tint cur = distance(ys.lower_bound(p.F.Y), ys.upper_bound(p.S.Y));\n//\t\tcout << cur << endl;\n\t\tans += cur;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstddef>\n#include <iostream>\n#include <iterator>\n#include <set>\n#include <vector>\n\nconst double kEpsilon = 1e-10;\n\ninline bool equals(double a, double b)\n{\n    return fabs(a - b) < kEpsilon;\n}\n\nclass Point\n{\n  public:\n    int x, y;\n\n    Point() = default;\n    Point(double x, double y) : x(x), y(y)\n    {\n    }\n\n    Point operator+(const Point &p)\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator-(const Point &p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator*(const double k)\n    {\n        return Point(x * k, y * k);\n    }\n\n    double SquaredNorm()\n    {\n        return x * x + y * y;\n    }\n    double abs()\n    {\n        return sqrt(this->SquaredNorm());\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return y != p.y ? y < p.y : x < p.x;\n    }\n    bool operator==(const Point &p) const\n    {\n        return fabs(x - p.x) < kEpsilon && fabs(y - p.y) < kEpsilon;\n    }\n    bool operator!=(const Point &p) const\n    {\n        return !(*this == p);\n    }\n\n    double dot(const Point &p) const\n    {\n        return x * p.x + y * p.y;\n    }\n    double cross(const Point &p) const\n    {\n        return x * p.y - y * p.x;\n    }\n};\n\ndouble dot(const Point &p1, const Point &p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\ndouble cross(const Point &p1, const Point &p2)\n{\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nauto swap = [](auto &a, auto &b) {\n    auto tmp = a;\n    a = b;\n    b = tmp;\n};\n\nclass EndPoint : public Point\n{\n  public:\n    int id, st;\n    EndPoint() = default;\n    EndPoint(double x, double y, int id, int st) : Point(x, y), id(id), st(st){};\n\n    bool operator<(EndPoint &p)\n    {\n        return y != p.y ? y < p.y : st < p.st;\n    }\n};\nstruct Segment\n{\n    Point p1, p2;\n\n    Segment() = default;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2)\n    {\n    }\n};\n\nconst int LEFT = 1;\nconst int RIGHT = 2;\nconst int TOP = 3;\nconst int BOTTOM = 0;\n\nint main()\n{\n    int n;\n    std::cin >> n;\n\n    EndPoint p1, p2;\n    std::vector<EndPoint> endpoints;\n    std::set<int> tree;\n    std::vector<Segment> segments;\n\n    tree.insert(1000000001);\n\n    for (size_t i = 0; i < n; ++i)\n    {\n        std::cin >> p1.x >> p1.y >> p2.x >> p2.y;\n        p1.id = i;\n        p2.id = i;\n        if (p1.y == p2.y)\n        {\n            if (p1.x < p2.x)\n            {\n                p1.st = LEFT;\n                p2.st = RIGHT;\n            }\n            else\n            {\n                p1.st = RIGHT;\n                p2.st = LEFT;\n            }\n        }\n        else if (p1.x == p2.x)\n        {\n            if (p1.y < p2.y)\n            {\n                p1.st = BOTTOM;\n                p2.st = TOP;\n            }\n            else\n            {\n                p1.st = TOP;\n                p2.st = BOTTOM;\n            }\n        }\n        endpoints.push_back(p1);\n        endpoints.push_back(p2);\n\n        if (p1 < p2)\n            segments.push_back(Segment(p1, p2));\n        else\n            segments.push_back(Segment(p2, p1));\n    }\n\n    std::sort(endpoints.begin(), endpoints.end(), [](EndPoint a, EndPoint b) { return a < b; });\n\n    int ans = 0;\n    for (auto p : endpoints)\n    {\n        // auto p = endpoints.at(i);\n        //    printf(\"%d %d: %d %d\\n\", p.x, p.y, p.id, p.st);\n\n        if (p.st == BOTTOM)\n        {\n            tree.insert(p.x);\n        }\n        else if (p.st == TOP)\n        {\n            tree.erase(p.x);\n        }\n        else if (p.st == LEFT)\n        {\n            auto lower = tree.lower_bound(segments[p.id].p1.x);\n            auto upper = tree.upper_bound(segments[p.id].p2.x);\n            ans += std::distance(lower, upper);\n\n            //  std::cout << \"(xl, xu = )\" << segments[p.id].p1.x << \", \" << segments[p.id].p2.x << \":\";\n            // for (auto node : tree)\n            // {\n            //     std::cout << node << \" \";\n            // }\n            // std::cout << std::endl;\n            // std::cout << \"ans+=\" << ans << std::endl\n            //  ;\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point{\n    public:\n    double x,y;\n    Point(double x=0,double y=0):x(x),y(y){}\n    Point operator+(const Point &p){\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator-(const Point &p){\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator*(const double &a){\n        return Point(a*x,a*y);\n    }\n    Point operator/(const double &a){\n        return Point(x/a,y/a);\n    }\n    double abs(){\n        return sqrt(norm());\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n    bool operator<(const Point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator==(const Point &p){\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\ntypedef Point Vector;\nstruct Segment{\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0):c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;   \n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2;\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1))/(l.p2-l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0){\n        return (p-s.p1).abs();\n    }\n    if(dot(s.p1-s.p2,p-s.p2)<0){\n        return (p-s.p2).abs();\n    }\n    return getDistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS) return 2;\n    if(a.norm()<b.norm()) return -2;\n    return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n        ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n        min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nbool intersect(Circle c,Line l){\n    double x=getDistanceLP(l,c.c);\n    return (x<=c.r);    \n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n    return Point(a*cos(r),a*sin(r));\n}\n\nbool intersect(Circle c1,Circle c2){\n    int x=(c1.c-c2.c).abs();\n    return (abs(c1.r-c2.r)<=x&&x<=(c1.r+c2.r));\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon &s){\n    Polygon u,l;\n    if(s.size()<3) return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2;i<s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])>=0;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])>=0;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--){\n        l.push_back(u[i]);\n    }\n    return l;\n}\n\nclass EndPoint{\n    public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n    bool operator<(const EndPoint &ep){\n        if(p.y==ep.p.y){\n            return st<ep.st;\n        }\n        else return p.y<ep.p.y;\n    }\n};\n\nEndPoint EP[200000];\n\nint manhattanIntersection(vector<Segment> &S){\n    int n=S.size();\n    for(int i=0,k=0;i<n;i++){\n        if(S[i].p1.y==S[i].p2.y){\n            if(S[i].p1.x>S[i].p2.x){\n                swap(S[i].p1,S[i].p2);\n            }\n        }\n        else if(S[i].p1.y>S[i].p2.y){\n            swap(S[i].p1,S[i].p2);\n        }\n        if(S[i].p1.y==S[i].p2.y){\n            EP[k++]=EndPoint(S[i].p1,i,1);\n            EP[k++]=EndPoint(S[i].p2,i,2);\n        }\n        else{\n            EP[k++]=EndPoint(S[i].p1,i,0);\n            EP[k++]=EndPoint(S[i].p2,i,3);\n        }\n    }\n    sort(EP,EP+2*n);\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt=0;\n    for(int i=0;i<2*n;i++){\n        if(EP[i].st==3){\n            BT.erase(EP[i].p.x);\n        }\n        else if(EP[i].st==0){\n            BT.insert(EP[i].p.x);\n        }\n        else if(EP[i].st==1){\n            auto b=BT.lower_bound(S[EP[i].seg].p1.x);\n            auto e=BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt+=distance(b,e);\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n,a,b,c,d;\n    cin>>n;\n    vector<Segment> S;\n    for(int i=0;i<n;i++){\n        cin>>a>>b>>c>>d;\n        S.push_back(Segment(Point(a,b),Point(c,d)));\n    }\n\n    cout<<manhattanIntersection(S)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint bit[200000];\nvector<int>v;\nvoid add(int k, int x) {\n\twhile (k <= v.size()) {\n\t\tbit[k] += x;\n\t\tk += k&-k;\n\t}\n}\nint sum(int k) {\n\tint res = 0;\n\twhile (k) {\n\t\tres += bit[k];\n\t\tk -= k&-k;\n\t}\n\treturn res;\n}\nint a[100000], b[100000], c[100000], d[100000];\nstruct st {\n\tint y, t, id;\n};\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tvector<st>xs;\n\trep(i, n) {\n\t\tscanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n\t\tif (a[i] > c[i])swap(a[i], c[i]);\n\t\tif (b[i] > d[i])swap(b[i], d[i]);\n\t\tv.push_back(a[i]); v.push_back(c[i]);\n\t\tif (a[i] == c[i]) {\n\t\t\txs.push_back({ b[i],0,i });\n\t\t\txs.push_back({ d[i],2,i });\n\t\t}\n\t\telse xs.push_back({ b[i],1,i });\n\t}\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tsort(xs.begin(), xs.end(), [](st&a, st&b) {\n\t\tif (a.y == b.y)return a.t < b.t;\n\t\treturn a.y < b.y;\n\t});\n\trep(i, n) {\n\t\ta[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin() + 1;\n\t\tc[i] = lower_bound(v.begin(), v.end(), c[i]) - v.begin() + 1;\n\t}\n\tint ans = 0;\n\tfor (st&p : xs) {\n\t\tif (p.t == 0)add(a[p.id], 1);\n\t\telse if (p.t == 1) {\n\t\t\tans += sum(c[p.id]);\n\t\t\tif (a[p.id])ans -= sum(a[p.id] - 1);\n\t\t}\n\t\telse add(a[p.id], -1);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(a*x, a*y); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment {\n public:\n  Point p1, p2;\n\n  Segment(Point p1 = Point(), Point p2 = Point()): p1(p1), p2(p2) {}\n};\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\n public:\n  Point p;\n  int seg, st;\n  EndPoint() {}\n  EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n  bool operator < (const EndPoint &ep) const {\n    if (p.y == ep.p.y) {\n      return st < ep.st;\n    }else return p.y < ep.p.y;\n  }\n};\n\n#define MAX_N 100000\n#define MAX_P 1000000000\nEndPoint EP[2*MAX_N];\n\nint manhattanIntersection(vector<Segment> s) {\n  int n = s.size();\n\n  for (int i = 0, k = 0; i < n; i++) {\n    if (s[i].p1.y == s[i].p2.y) {\n      if (s[i].p1.x > s[i].p2.x) swap(s[i].p1, s[i].p2);\n    }else if (s[i].p1.y > s[i].p2.y) {\n      swap(s[i].p1, s[i].p2);\n    }\n    if (s[i].p1.y == s[i].p2.y) {\n      EP[k++] = EndPoint(s[i].p1, i, LEFT);\n      EP[k++] = EndPoint(s[i].p2, i, RIGHT);\n    }else {\n      EP[k++] = EndPoint(s[i].p1, i, BOTTOM);\n      EP[k++] = EndPoint(s[i].p2, i, TOP);\n    }\n  }\n\n  sort(EP, EP+(2*n));\n\n  set<int> BT;\n  BT.insert(MAX_P+1);\n  int cnt = 0;\n\n  for (int i = 0; i < 2*n; i++) {\n    if (EP[i].st == TOP) {\n      BT.erase(EP[i].p.x);\n    }else if (EP[i].st == BOTTOM) {\n      BT.insert(EP[i].p.x);\n    }else if (EP[i].st == LEFT) {\n      set<int>::iterator b = lower_bound(BT.begin(), BT.end(), s[EP[i].seg].p1.x);\n      set<int>::iterator e = upper_bound(BT.begin(), BT.end(), s[EP[i].seg].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Segment> p;\n  for (int i = 0; i < n; i++) {\n    Segment l;\n    cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n    p.push_back(l);\n  }\n  cout << manhattanIntersection(p) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\n\nstruct Point{\n    double x;\n    double y;\n};\n\nstruct Segment{\n    Point p1;\n    Point p2;\n};\n\nclass EndPoint{\npublic:\n    Point p;\n    int segId;\n    int state;\n    EndPoint(){};\n    EndPoint(Point p,int segId,int state):p(p),segId(segId),state(state){}\n    \n    bool operator < (const EndPoint &ep) const {\n        if(p.y == ep.p.y){\n            // yが同じなら下端、左端、上端、右端で調べる\n            return state < ep.state;\n        }else{\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanInterSection(vector<Segment>s){\n    int n = s.size();\n    \n    for(int i = 0,k = 0;i < n;++i){\n        // 端点p1,p2が左下に並ぶようにする\n        if(s[i].p1.y == s[i].p2.y){\n            if(s[i].p1.x > s[i].p2.x){\n                swap(s[i].p1,s[i].p2);\n            }\n        }else if(s[i].p1.y > s[i].p2.y){\n            swap(s[i].p1,s[i].p2);\n        }\n        \n        if(s[i].p1.y == s[i].p2.y){\n            // 水平成分を端点へ追加する\n            EP[k++] = EndPoint(s[i].p1,i,LEFT);\n            EP[k++] = EndPoint(s[i].p2,i,RIGHT);\n        }\n        else{\n            // 垂直成分を端点へ追加する\n            EP[k++] = EndPoint(s[i].p1,i,BOTTOM);\n            EP[k++] = EndPoint(s[i].p2,i,TOP);\n        }\n    }\n    \n    // 端点のy座標に関して昇順に並び替える\n    sort(EP,EP + (n * 2));\n    \n    set<int> BT;\n    // 番兵\n    BT.insert(__INT_MAX__);\n    int cnt = 0;\n    \n    for(int i = 0;i < 2 * n;++i){\n        if(EP[i].state == TOP){\n            // 上端点を削除\n            BT.erase(EP[i].p.x);\n        } else if(EP[i].state == BOTTOM){\n            // 下端点を追加\n            BT.insert(EP[i].p.x);\n        }else if(EP[i].state == LEFT){\n            set<int>::iterator b = lower_bound(BT.begin(), BT.end(), s[EP[i].segId].p1.x);\n            set<int>::iterator e = upper_bound(BT.begin(), BT.end(), s[EP[i].segId].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<Segment> s(n);\n    for (int i = 0; i < n; ++i){\n        scanf(\"%lf %lf %lf %lf\", &s[i].p1.x,&s[i].p1.y,&s[i].p2.x, &s[i].p2.y);\n    }\n    int crossPointNum = manhattanInterSection(s);\n    printf(\"%d\\n\", crossPointNum);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nstruct Seg{\n    int x1, x2, y1, y2;\n    Seg(int x1, int y1, int x2, int y2) :x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nbool yparaAsc( const Seg& left, const Seg& right ) {\n    return left.x1 != right.x1 ? left.x1 < right.x1 : left.y1 < right.y1;\n};\n\nstruct Time{\n    int x; //x??§?¨?\n    int y; //y??§?¨?\n    int act; //?????????????????????0 ??§?????????1 ??§?????????\n    Time(int x, int y, int act) : x(x), y(y), act(act) {}\n\n    bool operator<( const Time& right ) const {\n        return x != right.x ? x < right.x : act < right.act;\n    }\n};\n\nint segmentIntersection(vector<Seg> &input){\n    int n = input.size();\n    vector<Seg> xpara, ypara;\n    for (int i=0;i<n;i++){\n        Seg s = input[i];\n        if(s.x1 == s.x2) ypara.push_back(s);\n        if(s.y1 == s.y2) xpara.push_back(s);\n    }\n\n    sort(ypara.begin(), ypara.end(), yparaAsc);\n\n    /*\n    for (int i=0;i<ypara.size();i++){\n        cout << ypara[i].x1 << \" \" << ypara[i].y1 << \" \" << ypara[i].y2 << \" \" <<endl;\n    }\n    cout << endl;\n    */\n\n    vector<Time> Timeline;\n    for (int i=0;i<xpara.size();i++){\n        Seg s = xpara[i];\n        Time t1(s.x1, s.y1, 0), t2(s.x2, s.y1, 1);\n        Timeline.push_back(t1);\n        Timeline.push_back(t2);\n    }\n    sort(Timeline.begin(), Timeline.end());\n\n    /*\n    for (int i=0;i<Timeline.size();i++){\n        cout << Timeline[i].x << \" \" << Timeline[i].y << \" \"  << Timeline[i].act << \" \" <<endl;\n    }\n    cout << endl;\n    */\n    set<int> st;\n    int i=0;\n    int j=0;\n    int S=0;\n    while(1){\n        if(i >= ypara.size() && j >= Timeline.size()) break;\n\n        if(i >= ypara.size()){\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n            continue;\n        }\n\n        if(j >= Timeline.size()){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            i++;\n            continue;\n        }\n\n        if((ypara[i].x1 < Timeline[j].x) || (ypara[i].x1 == Timeline[j].x && Timeline[j].act == 1)){\n            set<int>::iterator a = lower_bound(st.begin(), st.end(), ypara[i].y1);\n            set<int>::iterator b = upper_bound(st.begin(), st.end(), ypara[i].y2);\n            S += distance(a, b);\n            /*\n            cout << i << \" \" << j <<endl;\n\n            set<int>::iterator it = st.begin();\n            while( it != st.end() )\n            {\n                cout << *it << \" \";\n                ++it;\n            }\n            cout << endl;\n            */\n            i++;\n        }else{\n            if(Timeline[j].act == 0) st.insert(Timeline[j].y);\n            if(Timeline[j].act == 1) st.erase(Timeline[j].y);\n            j++;\n        }\n    }\n    return S;\n}\n\nint main(){\n    int n, x1, x2, y1, y2;\n    cin >> n;\n    vector<Seg> input;\n    for (int i=0;i<n;i++){\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n        Seg s(x1, y1, x2, y2);\n        input.push_back(s);\n    }\n\n    cout << segmentIntersection(input) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#define EPS (1e-10)\n#define MAX 100000\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT=0;\nstatic const int TOP=3;\nstatic const int RIGHT=1;\nstatic const int LEFT=2;\nstatic const int BOTTOM=0;\nclass Point{\npublic:\n    double x,y;\n    Point(double x=0, double y=0):x(x),y(y){}\n    Point operator +(const Point &p){\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point &p){\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(double k){\n        return Point(k*x,k*y);\n    }\n    Point operator /(double k){\n        return Point(x/k,y/k);\n    }\n\n    double norm(){\n        return x*x+y*y;\n    }\n    double abs(){\n        return sqrt(norm());\n    }\n};\ntypedef Point Vector;\nclass EndPoint{\npublic:\n    Point p;\n    int seg,state;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int state):p(p),seg(seg),state(state){}\n    bool operator <(const EndPoint &ep) const{\n        if(p.y==ep.p.y)return state<ep.state;\n        return p.y<ep.p.y;\n    }\n};\nvector<Point>g;\ntypedef vector<Point> Polygon;\nPolygon s;\nstruct segment{\n    Point p1,p2;\n};\ntypedef segment Line;\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle (double x=0, double y=0,double r=0):c(x,y),r(r){}\n};\ndouble dot(const Vector &v1,const Vector &v2){\n    return v1.x*v2.x+v1.y*v2.y;\n}\ndouble cross(const Vector &v1,const Vector &v2){\n    return v1.x*v2.y-v1.y*v2.x;\n}\nbool isParallel(const Vector &v1,const Vector &v2){\n    if(fabs(cross(v1,v2)-0.0)<EPS)return true;\n    return false;\n}\nbool isOrthogonal(const Vector &v1,const Vector &v2){\n    if(fabs(dot(v1,v2)-0.0)<EPS)return true;\n    return false;\n}\nPoint projection( Point &p, Point &p1, Point &p2){\n    Vector a=p-p1;\n    Vector b=p2-p1;\n    double r=dot(a,b);\n    double pro_abs=r/b.norm();\n    Vector res=b*pro_abs;\n    return Point(res.x+p1.x,res.y+p1.y);\n}\nPoint reflection(Point &p, Point &p1, Point &p2){\n    Point pro=projection(p,p1,p2);\n    Vector v=pro-p;\n    v=v*2;\n    return Point(v.x+p.x,v.y+p.y);\n}\nint ccw(Point &p, Point &p1, Point &p2){\n    Vector a=p1-p;\n    Vector b=p2-p;\n    if(cross(a,b)>0)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<0)return CLOCKWISE;\n    if(dot(a,b)<0)return ONLINE_BACK;\n    if(a.norm()>b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersect(segment &s1,segment &s2){\n    if(ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0 && ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0)\n        return true;\n    return false;\n}\ndouble getDistanceSP(Point &p,segment &s){\n    if(dot(p-s.p1,s.p2-s.p1)<0)return (p-s.p1).abs();\n    if(dot(p-s.p2,s.p1-s.p2)<0)return (p-s.p2).abs();\n    return fabs(cross(p-s.p1,s.p2-s.p1)/(s.p2-s.p1).abs());\n}\ndouble Distance(segment &s1,segment &s2){\n    if(intersect(s1,s2))return 0;\n    return min(min(getDistanceSP(s1.p1,s2),getDistanceSP(s1.p2,s2)),min(getDistanceSP(s2.p1,s1),getDistanceSP(s2.p2,s1)));\n}\nPoint CrossPoint(segment &s1,segment &s2){\n    Vector base =s2.p2-s2.p1;\n    double d1=fabs(cross(base,s1.p1-s2.p1));\n    double d2=fabs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return (s1.p2-s1.p1)*t+s1.p1;\n}\npair<Point,Point> getCrossPoints(Circle &c,Line &l){\n    Vector e = (l.p2-l.p1)/(l.p2-l.p1).abs();\n    Point p=projection(c.c,l.p1,l.p2);\n    double len=sqrt(c.r*c.r-(p-c.c).norm());\n    return make_pair(p-e*len,p+e*len);\n }\npair<Point,Point> getCrossPoints(Circle &c1,Circle &c2){\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=atan2((c2.c-c1.c).y,(c2.c-c1.c).x);\n    Point p1(c1.r*cos(t+a),c1.r*sin(t+a));\n    Point p2(c1.r*cos(t-a),c1.r*sin(t-a));\n    return make_pair(c1.c+p1,c1.c+p2);\n}\n//点的内包\nint PPC(Point &p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++)\n    {\n        Vector a=g[i]-p;\n        Vector b=g[(i+1)%n]-p;\n        if(fabs(cross(a,b)-0)<EPS && dot(a,b)<=0)return 1;\n        if(a.y>b.y)swap(a,b);\n        if(a.y<EPS && 0<b.y &&cross(a,b)>0)x!=x;\n    }\n    return x?2:0;\n}\nvoid merge(int l,int mid,int r)\n{\n    Polygon left,right;\n    Point p(MAX,MAX);\n    for(int i=0;i<mid-l;i++)\n        left.push_back(s[l+i]);\n    left.push_back(p);\n    for(int i=0;i<r-mid;i++)\n        right.push_back(s[mid+i]);\n    right.push_back(p);\n    int l_index=0,r_index=0;\n    for(int i=l;i<r;i++)\n    {\n        if(left[l_index].x<right[r_index].x){\n            s[i]=left[l_index++];\n        } else if(fabs(left[l_index].x-right[r_index].x)<EPS){\n            if(left[l_index].y<right[r_index].y)\n                s[i]=left[l_index++];\n            else\n                s[i]=right[r_index++];\n        } else\n            s[i]=right[r_index++];\n    }\n}\nvoid mergesort(int l,int r)\n{\n    if(l+1<r){\n        int mid=(l+r)/2;\n        mergesort(l,mid);\n        mergesort(mid,r);\n        merge(l,mid,r);\n    }\n}\nPolygon andrewScan(){\n    Polygon u,l;\n    mergesort(0,s.size());\n    for(int i=0;i<s.size();i++)\n        cout<<s[i].x<<' '<<s[i].y<<endl;\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2;i<s.size();i++)\n    {\n        for(int j=u.size();j>=2;j--)\n            if(ccw(u[j-2],u[j-1],s[i])==COUNTER_CLOCKWISE)u.pop_back();\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--)\n    {\n        for(int j=l.size();j>=2;j--)\n            if(ccw(l[j-2],l[j-1],s[i])==COUNTER_CLOCKWISE)l.pop_back();\n        l.push_back(s[i]);\n    }\n    //cout<<u.size()<<endl<<l.size()<<endl;\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>0;i--)\n        l.push_back(u[i]);\n    return l;\n}\nint manhattanIntersection(vector<segment> &s)\n{\n    int n=s.size(),count=0;\n    EndPoint ep[n*2];\n    int k=0;\n    for(int i=0;i<n;i++){\n        if(s[i].p1.y==s[i].p2.y){\n            if(s[i].p1.x>s[i].p2.x)\n                swap(s[i].p1,s[i].p2);\n            ep[k++]=EndPoint(s[i].p1,i,LEFT);\n            ep[k++]=EndPoint(s[i].p2,i,RIGHT);\n        }\n        else{\n            if(s[i].p1.y>s[i].p2.y)\n                swap(s[i].p1, s[i].p2);\n            ep[k++]=EndPoint(s[i].p1,i,BOTTOM);\n            ep[k++]=EndPoint(s[i].p2,i,TOP);\n        }\n    }\n    sort(ep,ep+n*2);\n    set<double>BT;\n    for(int i=0;i<n*2;i++)\n    {\n        if(ep[i].state==BOTTOM)BT.insert(ep[i].p.x);\n        else if(ep[i].state==TOP)BT.erase(ep[i].p.x);\n        else if(ep[i].state==LEFT){\n            set<double>::iterator a=BT.lower_bound(s[ep[i].seg].p1.x);\n            set<double>::iterator b=BT.upper_bound(s[ep[i].seg].p2.x);\n            count+=distance(a,b);\n        }\n    }\n    return count;\n}\nint main()\n{\n    int n;\n    vector<segment>S;\n    segment s;\n    double x1,y1,x2,y2;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>x1>>y1>>x2>>y2;\n        s.p1=Point(x1,y1);\n        s.p2=Point(x2,y2);\n        S.push_back(s);\n    }\n    cout<<manhattanIntersection(S)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x <<\" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<class T, class... Ts> void err(const T& arg,const Ts&... args) { cout << arg << \" \"; err(args...); }\nconst int N = 100000 + 5;\nvector<int> xall, yall;\nint n;\nstruct Seg{\n    int x1, x2, y1, y2;\n}l[N];\nvector<pair<int,int>> line[2*N], q[2*N];\nll c[2*N];\nint getxid(int x){\n    return lower_bound(xall.begin(),xall.end(), x) - xall.begin() + 1;\n}\nint getyid(int x){\n    return lower_bound(yall.begin(),yall.end(), x) - yall.begin() + 1;\n}\nvoid add(int x, int y){\n    for(;x<2*N;x+=x&-x) c[x]+=y;\n}\nll ask(int x){\n    ll res = 0;\n    for(;x;x-=x&-x) res += c[x];\n    return res;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        int x, y, x2, y2;\n        scanf(\"%d%d%d%d\", &x, &y, &x2, &y2);\n        xall.push_back(x);\n        xall.push_back(x2);\n        yall.push_back(y);\n        yall.push_back(y2);\n        l[i] = Seg{x, x2, y, y2};\n    }\n    sort(xall.begin(),xall.end());xall.erase(unique(xall.begin(),xall.end()),xall.end());\n    sort(yall.begin(),yall.end());yall.erase(unique(yall.begin(),yall.end()),yall.end());\n    for(int i=1;i<=n;i++){\n        if(l[i].x1 == l[i].x2){\n            int xid = getxid(l[i].x1);\n            if(l[i].y1 > l[i].y2) swap(l[i].y1, l[i].y2);\n            q[xid].push_back(make_pair(getyid(l[i].y1), getyid(l[i].y2)));\n        } else {\n            if(l[i].x1 > l[i].x2) swap(l[i].x1, l[i].x2);\n            line[getxid(l[i].x1)].push_back(make_pair(1, getyid(l[i].y1))); //  1表示添加\n            line[getxid(l[i].x2)].push_back(make_pair(2, getyid(l[i].y1))); //  2表示删除\n        }\n    }\n    ll res = 0;\n    for(int i=1;i<=xall.size();i++){\n        for(auto t : line[i]){\n            int type = t.first, y = t.second;\n            if(type == 1){\n               //dbg(xall[i-1], type, yall[y-1]);\n                add(y, 1);\n            }\n        }\n        for(auto t : q[i]){\n            int x1 = t.first, x2 = t.second;\n            // dbg(x1, x2, ask(x2)-ask(x1-1));\n            res += ask(x2) - ask(x1-1);\n        }\n        for(auto t : line[i]){\n            int type = t.first, y = t.second;\n            if(type == 2){\n                //dbg(xall[i-1], type, yall[y-1]);\n                add(y, -1);\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n; cin >> n;\n    \n    int x1[100000], y1[100000], x2[100000], y2[100000]; bool tate[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        \n        if(x1[i] == x2[i])\n        {\n            tate[i] = true;\n        }\n        else\n        {\n            tate[i] = false;\n        }\n    }\n    \n    int Ans = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            if(tate[i] == true && tate[j] == false)\n            {\n                if(y1[i] < y1[j] && y1[j] < y2[i] && x1[j] < x1[i] && x1[i] < x2[j])\n                {\n                    Ans++;\n                }\n            }\n            \n            if(tate[i] == false && tate[j] == true)\n            {\n                if(x1[i] < x1[j] && x1[j] < x2[i] && y1[j] < y1[i] && y1[i] < y2[j])\n                {\n                    Ans++;\n                }\n            }\n        }\n    }\n    \n    cout << Ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT1[MAX_SIZE];\nint BIT2[MAX_SIZE];\nint BIT_N;\n\nvoid add(int BIT[MAX_SIZE], int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int BIT[MAX_SIZE], int l, int r, int x)\n{\n\tadd(BIT, l, x);\n\tadd(BIT, r + 1, -x);\n}\n\nint sum(int BIT[MAX_SIZE], int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (y1 < y2)\n\t\t\t{\n\t\t\t\tadd(BIT1, x1, 1);\n\t\t\t\tadd(BIT2, x2 + 1, -1);\n\t\t\t}\n\t\t\tif (y1 > y2)\n\t\t\t{\n\t\t\t\tadd(BIT1, x1, -1);\n\t\t\t\tadd(BIT2, x2 + 1, 1);\n\t\t\t}\n\t\t\tif (y1 == y2) ans += sum(BIT1, x2) + sum(BIT2, x1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <iomanip>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(x * a, y * a); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\nclass Circle {\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\nclass EndPoint {\n    public:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        } else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000];\n\ntypedef vector<Point> Polygon;\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x; \n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = fabs(cross(s1.p1 - s2.p1, base));\n    double d2 = fabs(cross(s1.p2 - s2.p1, base));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt((c.r * c.r) - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    double d = (c2.c - c1.c).abs();\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for (int i = 0; i != n; ++i) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if ( fabs(cross(a, b)) < EPS && dot(a, b) < EPS ) return 1;\n        if ( a.y > b.y ) swap(a, b);\n        if ( a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n    }\n    return ( x ? 2 : 0 );\n}\n\nbool cmp(Point a, Point b) {\n    return (a.y < b.y || (a.y == b.y && a.x < b.x));\n}\n\nPolygon andrewScan(Polygon s)\n{\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for (int i = 2; i != s.size(); ++i)\n    {\n        for (int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) > 0; --n)\n        {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for (int i = s.size() - 3; i >= 0; --i)\n    {\n        for (int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) > 0; --n)\n        {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; --i)\n    {\n        l.push_back(u[i]);\n    }\n    return l;\n}\n\nint manhattanIntersection(vector<Segment> S)\n{\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; ++i)\n    {\n        if (S[i].p1.y == S[i].p2.y)\n        {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        }\n        else if (S[i].p1.y > S[i].p2.y)\n        {\n            swap(S[i].p1, S[i].p2);\n        }\n\n        if (S[i].p1.y == S[i].p2.y)\n        {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else\n        {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }    \n    }\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * n; ++i)\n    {\n        if (EP[i].st == TOP)\n        {\n            BT.erase(EP[i].p.x);\n        }\n        else if (EP[i].st == BOTTOM)\n        {\n            BT.insert(EP[i].p.x);\n        }\n        else if (EP[i].st == LEFT)\n        {\n            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n    return cnt;\n}\n\nint main()\n{\n    int n;\n    double x1, x2, y1, y2;\n    vector<Segment> S;\n    cin >> n;\n    for (int i = 0; i != n; ++i)\n    {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s;\n        s.p1 = Point(x1, y1);\n        s.p2 = Point(x2, y2);\n        S.push_back(s);\n    }\n    cout << manhattanIntersection(S) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof(a))\n#define pb(a)    push_back(a)\n#define il       inline\n#define reg      register\ntypedef long long ll;\ntypedef double db;\nconst int maxn=10000;\nconst int minn=200000+5;\nstruct Point\n{\n    db x,y;\n    Point(){}\n    Point(db x,db y):x(x),y(y){}\n};\nstruct Seg\n{\n    Point a,b;\n    int c;\n    Seg(Point a,Point b,int c):a(a),b(b),c(c){}\n    friend bool operator<(Seg p,Seg q){\n        if(p.a.y!=q.a.y) return p.a.y<q.a.y;\n    \treturn p.c!=q.c?p.c<q.c:p.a.x<q.a.x;\n    }\n};\ndb  x[minn<<2];\nint q,lenx,ans,tree[minn<<2];\nvector<Seg> ve;\nvoid init()\n{\n    clr(tree,0);\n    ve.clear();\n    lenx=0;\n    ans=0;\n    return ;\n}\nvoid  pushpu(int k,int c)\n{\n    while(k)\n    {\n        tree[k]+=c;\n        k>>=1;\n    }\n}\nvoid update(int l,int r,int nu,int c,int k)\n{\n    if(nu==l&&r==nu)\n    {\n        pushpu(k,c);\n        return ;\n    }\n    int mind=(l+r)/2;\n    if(nu<=mind){update(l,mind,nu,c,k<<1);}\n    if(nu>mind) {update(mind+1,r,nu,c,k<<1|1);}\n    return ;\n}\nvoid query(int l,int r,int L,int R,int k)\n{\n    if(L<=l&&r<=R)\n    {\n        ans+=tree[k];\n        return ;\n    }\n    int mind=(l+r)/2;\n    if(L<=mind){query(l,mind,L,R,k<<1);}\n    if(R>mind) {query(mind+1,r,L,R,k<<1|1);}\n    return ;\n}\nint slove()\n{\n    sort(ve.begin(),ve.end());\n    sort(x,x+lenx);\n    int res=0;\n    for(reg int i=0;i<ve.size();i++)\n    {\n        if(ve[i].a.x==ve[i].b.x){\n            int nu=lower_bound(x,x+lenx,ve[i].a.x)-x+1;\n            int c=ve[i].c;\n            update(1,lenx,nu,c,1);\n        }\n        else\n        {\n            ans=0;\n            int l=lower_bound(x,x+lenx,ve[i].a.x)-x+1;\n            int r=lower_bound(x,x+lenx,ve[i].b.x)-x+1;\n            query(1,lenx,l,r,1);\n            res+=ans;\n        }\n    }\nreturn res;\n}\nint main()\n{\n//    freopen(\"data.txt\",\"r\",stdin);\n    init();\n    scanf(\"%d\",&q);\n    Point a,b;\n    while(q--)\n    {\n        scanf(\"%lf%lf\",&a.x,&a.y);\n        scanf(\"%lf%lf\",&b.x,&b.y);\n        if(a.x>b.x||a.y>b.y){swap(a,b);}\n        if(a.x!=b.x)\n        {\n            x[lenx++]=a.x;x[lenx++]=b.x;\n            ve.pb(Seg(a,b,2));\n        }\n        else\n        {\n            x[lenx++]=a.x;\n            ve.pb(Seg(a,a,1));\n            ve.pb(Seg(b,b,-1));\n        }\n    }\n    printf(\"%d\\n\",slove());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nenum Eptype {\n  BOTTOM = 0,\n  LEFT = 1,\n  TOP = 2,\n};\n\nclass EndPoint {\npublic:\n  int x, y;\n  Eptype t;\n  int rightx; // empty if not LEFT\n  EndPoint() {}\n  EndPoint(int x, int y, Eptype t) : x(x), y(y), t(t) {}\n  EndPoint(int x, int y, Eptype t, int rightx) : x(x), y(y), t(t),rightx(rightx) {}\n  bool operator<(const EndPoint ep) {\n    if (y == ep.y)\n      return t < ep.t;\n    return y < ep.y;\n  }\n};\n\nint manhattan_scan(vector<EndPoint> &epts) {\n  sort(epts.begin(), epts.end());\n  set<int> xs;\n  int count = 0;\n\n  for (int i = 0; i < epts.size(); i++) {\n    EndPoint ept = epts[i];\n    if (ept.t == BOTTOM) {\n      xs.insert(ept.x);\n    } else if (ept.t == TOP) {\n      xs.erase(ept.x);\n    } else if (ept.t == LEFT) {\n      auto lb = lower_bound(xs.begin(), xs.end(), ept.x);\n      auto ub = upper_bound(xs.begin(), xs.end(), ept.rightx);\n      count += distance(lb, ub);\n    }\n  }\n  return count;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<EndPoint> epts;\n  for (int i = 0; i < n; i++) {\n    Eptype t1, t2;\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    if (x1 == x2) {\n      t1 = BOTTOM;\n      t2 = TOP;\n      if (y1 > y2) {\n        t1 = TOP;\n        t2 = BOTTOM;\n      }\n      epts.push_back(EndPoint(x1, y1, t1));\n      epts.push_back(EndPoint(x2, y2, t2));\n    } else {\n      // push only left endpoint with right-x\n      if (x1 < x2) {\n        epts.push_back(EndPoint(x1, y1, LEFT, x2));\n      } else {\n        epts.push_back(EndPoint(x2, y2, LEFT, x1));\n      }\n    }\n  }\n  cout << manhattan_scan(epts) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define mkp make_pair\n#define pa pair<int,int>\nconst int N=1e6+10;\nconst int mod=1e9+7;\nusing namespace std;\n\nstruct Point{int x,y;};\nstruct segment{Point p1,p2;};\nstruct endpoint\n{\n  Point p; int id,type; \n  endpoint(){}\n  endpoint(Point p,int id,int type):p(p),id(id),type(type){}\n  bool operator < (const endpoint &ep)const {return p.y==ep.p.y?type<ep.type:p.y<ep.p.y;}\n};\nint sweep(vector<segment> v)\n{\n   vector<endpoint> ep;\n   for(int i=0,sz=v.size();i<sz;i++)\n   {\n      segment &e=v[i];\n      if(e.p1.x==e.p2.x)\n      {\n         if(e.p1.y>e.p2.y) swap(e.p1,e.p2);\n         ep.pb(endpoint(e.p1,i,0));\n         ep.pb(endpoint(e.p2,i,3));\n      }\n      else \n      {\n         if(e.p1.x>e.p2.x) swap(e.p1,e.p2);\n         ep.pb(endpoint(e.p1,i,1));\n         ep.pb(endpoint(e.p2,i,2));\n      }\n   }\n   sort(ep.begin(),ep.end()); \n   int ans=0; set<int> s; s.insert(inf);\n   for(auto e: ep)\n   {\n      if(e.type==0) s.insert(e.p.x);\n      else if(e.type==3) s.erase(e.p.x);\n      else if(e.type==1) ans+=distance(s.lower_bound(v[e.id].p1.x),s.upper_bound(v[e.id].p2.x));\n   }\n return ans;\n}\nint main()  \n{  \n     int n;  scanf(\"%d\",&n);\n     vector<segment> v; segment t;\n     for(int i=1;i<=n;i++) scanf(\"%d%d%d%d\",&t.p1.x,&t.p1.y,&t.p2.x,&t.p2.y),v.pb(t);\n     printf(\"%d\\n\",sweep(v));\nreturn 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint N_BIT;\n\nvoid add(int i, int x)\n{\n\twhile (i <= N_BIT)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines(n);\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tlines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 0;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tN_BIT = table.size();\n\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\tx1 = table[pp.second.first], x2 = table[pp.second.second];\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\n#include<cmath>\nusing namespace std;\nlong long bit[1000000], _size, n, cnt, __x1[200000], __y1[200000], __x2[200000], __y2[200000];\nvector<long long>XX, YY, _XX, _YY; vector<tuple<long long, long long, long long>>vec;\nvoid add(long long p, long long x) { while (p <= _size) { bit[p] += x; p += p&-p; } }\nlong long sum(long long p) { int _sum = 0; while (p >= 1) { _sum += bit[p]; p -= p&-p; }return _sum; }\nlong long __sum(long long l, long long r) { return sum(r) - sum(l - 1); }\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++)cin >> __x1[i] >> __y1[i] >> __x2[i] >> __y2[i];\n\tfor (int i = 0; i < n; i++) { XX.push_back(__x1[i]); XX.push_back(__x2[i]); YY.push_back(__y1[i]); YY.push_back(__y2[i]); }\n\tsort(XX.begin(), XX.end()); sort(YY.begin(), YY.end());\n\tfor (int i = 0; i < XX.size(); i++) { if (i == 0 || XX[i - 1] != XX[i])_XX.push_back(XX[i]); if (i == 0 || YY[i - 1] != YY[i])_YY.push_back(YY[i]); }\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos1 = lower_bound(_XX.begin(), _XX.end(), __x1[i]) - _XX.begin(), pos2 = lower_bound(_YY.begin(), _YY.end(), __y1[i]) - _YY.begin();\n\t\tint pos3 = lower_bound(_XX.begin(), _XX.end(), __x2[i]) - _XX.begin(), pos4 = lower_bound(_YY.begin(), _YY.end(), __y2[i]) - _YY.begin();\n\t\t__x1[i] = pos1; __y1[i] = pos2; __x2[i] = pos3; __y2[i] = pos4; if (__x1[i] > __x2[i])swap(__x1[i], __x2[i]); if (__y1[i] > __y2[i])swap(__y1[i], __y2[i]);\n\t\tif (__x1[i] == __x2[i]) { vec.push_back(make_tuple(__y1[i], 1LL << 60, __x1[i])); vec.push_back(make_tuple(__y2[i], -1LL << 60, __x1[i])); }\n\t\telse { vec.push_back(make_tuple(__y1[i], __x1[i], __x2[i])); }\n\t}sort(vec.begin(), vec.end()); _size = XX.size() + 10;\n\tfor (int i = 0; i < vec.size(); i++) { if (abs(get<1>(vec[i])) >= 1LL << 50)add(get<2>(vec[i]), get<1>(vec[i]) / (1LL << 60)); else { cnt += __sum(get<1>(vec[i]), get<2>(vec[i])); } }\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n \n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n \n/*????????????(???§??¨?)????????????*/\nclass Vector\n{\npublic:\n    double x,y;\n    Vector(double x=0,double y=0):x(x),y(y){}\n     \n    Vector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n    Vector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n    Vector operator * (double a){return Vector(x*a,y*a);}\n    Vector operator / (double a){return Vector(x/a,y/a);}\n     \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n     \n    bool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n    bool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n \n/*???´???????????????*/\nclass Line\n{\npublic:\n    Vector p,q;\n    Line(Vector p=Vector(),Vector q=Vector()):p(p),q(q){}\n};\n \n/*???????????????*/\nclass Circle\n{\npublic:\n    Vector c;\n    double r;\n    Circle(Vector c=Vector(),double r=0.0):c(c),r(r){}\n};\n \n/*?????§????????????*/\ntypedef vector<Vector> Polygon;\n \n/*?????????????????????¢?????????????§??????*/\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n \n/*???´???????????°????±*/\nVector project(Line l,Vector p)\n{\n    Vector base=l.q-l.p;\n    double r=dot(p-l.p,base)/base.norm();\n    return l.p+base*r;\n}\n \n/*?????????¨?????????????????????????????*/\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return 1;//????????¨???????\n    if(cross(a,b)<-EPS)return -1;//?????¨???????\n    if(dot(a,b)<-EPS)return 2;//p0?????????\n    if(a.norm()<b.norm())return -2;//p1????\\\\\n    return 0;//?????????\n}\n \n/*?????????????????????*/\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    return (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n \n/*???´??????¨???´????????????*/\nVector LLcross(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n    double d1=cross(p3-p2,p0-p2);\n    double d2=cross(p3-p2,p1-p3);\n    return p0+(p1-p0)*(d1/(d1+d2));\n}\n \n/*??????¨???´????????????*/\npair<Vector,Vector> CLcross(Circle c,Line l)\n{\n    Vector pr=project(l,c.c);\n    Vector e=(l.q-l.p)/(l.q-l.p).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n \n/*??????¨????????????*/\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector pol(double a,double r){return Vector(cos(r)*a,sin(r)*a);}\npair<Vector,Vector> CCcross(Circle c1,Circle c2)\n{\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+pol(c1.r,t+a),c1.c+pol(c1.r,t-a));\n}\n \n/*?????§????????????????????????????????????*/\nint contain(Polygon g,Vector p)\n{\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++)\n    {\n        Vector a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//??????\n        if(a.y>b.y)swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);//?????????2?????????0\n}\n \n/*??????(Andrew)*/\nPolygon AndrewScan(Polygon s)\n{\n    Polygon u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);l.push_back(s[s.size()-2]);\n    for(int i=2;i<s.size();i++)\n    {\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])>=0;n--)\n        {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--)\n    {\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])>=0;n--)\n        {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n \n \n//cout<<fixed<<setprecision(10);\n////////////////////////////////////////////////\n#define BOT 0\n#define LEF 1\n#define RIG 2\n#define TOP 3\n\nclass Endpoint\n{\npublic:\n\tVector p;\n\tint seg,st;\n\tEndpoint(){}\n\tEndpoint(Vector p,int seg,int st):p(p),seg(seg),st(st){}\n\t\n\tbool operator < (const Endpoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nEndpoint EP[2*100000];\n\nint manhattanIntersection(vector<Line> S)\n{\n\tint n=S.size();\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(S[i].p1.y==S[i].p2.y)\n\t\t{\n\t\t\tif(S[i].p1.x>S[i].p2.x)swap(S[i].p1,S[i].p2);\n\t\t}\n\t\telse if(S[i].p1.y>S[i].p2.y)swap(S[i].p1,S[i].p2);\n\t\t\n\t\tif(S[i].p1.y==S[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p1,i,LEF);\n\t\t\tEP[k++]=Endpoint(S[i].p2,i,RIG);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=Endpoint(S[i].p1,i,BOT);\n\t\t\tEP[k++]=Endpoint(S[i].p2,i,TOP);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+(2*n));\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==TOP)\n\t\t{\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==BOT)\n\t\t{\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}\n\t\telse if(EP[i].st==LEF)\n\t\t{\n\t\t\tset<int>::iterator b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=BT.lower_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tint n;cin>>n;\n\tLine a;\n\tvector<Line> S;\n\tREP(i,n)\n\t{\n\t\tcin>>a.p.x>>a.p.y>>a.q.x>>a.q.y;\n\t\tS.PB(a);\n\t}\n\t\n\tcout<<manhattanIntersection(S)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define y1 ___y1\nconst int N=300005;\nint rt[N],n,x1,y1,x2,tot1,tot2,tot,y2,cnt,num,a[N],ans;\nstruct Ask{\n\tint x,y,z;\n\tAsk(int _x=0,int _y=0,int _z=0){x=_x;y=_y;z=_z;}\n}A[N],B[N];\nstruct Tree{\n\tint lson,rson,num;\n}T[N*40];\nvoid build(int x,int l,int r){\n\tif (l==r)return;\n\tint mid=(l+r)/2;\n\tbuild(T[x].lson=++cnt,l,mid);\n\tbuild(T[x].rson=++cnt,mid+1,r);\n}\nint ef(int x){\n\tint l=1,r=num;\n\twhile (l<r){\n\t\tint mid=(l+r)/2;\n\t\tif (a[mid]<x)l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nvoid insert(int x,int y,int l,int r,int z,int v){\n\tT[x]=T[y];T[x].num+=v;\n\tif (l==r)return;\n\tint mid=(l+r)/2;\n\tif (z<=mid)insert(T[x].lson=++cnt,T[y].lson,l,mid,z,v);\n\telse insert(T[x].rson=++cnt,T[y].rson,mid+1,r,z,v);\n}\nint find(int x,int l,int r,int z){\n\tif (l==r)return T[x].num;\n\tint mid=(l+r)/2;\n\tif (z<=mid)return find(T[x].lson,l,mid,z);\n\telse return find(T[x].rson,mid+1,r,z)+T[T[x].lson].num;\n}\nint cmp(Ask x,Ask y){\n\treturn x.x<y.x;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\twhile (n--){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2); \n\t\tif (x1==x2){\n\t\t\tif (y1>y2)swap(y1,y2);\n\t\t\ta[++tot]=x1;\n\t\t\tA[++tot1]=Ask(x1,y1,y2);\n\t\t}\n\t\telse {\n\t\t\tif (x1>x2)swap(x1,x2);\n\t\t\ta[++tot]=x1;\n\t\t\ta[++tot]=x2;\n\t\t\tB[++tot2]=Ask(y1,x1,x2);\n\t\t}\n\t}\n\tsort(a+1,a+tot+1);\n\tnum=1;\n\tfor (int i=2;i<=tot;i++)\n\t\tif (a[i]!=a[num])a[++num]=a[i];\n\tfor (int i=1;i<=tot1;i++)A[i].x=ef(A[i].x);\n\tfor (int i=1;i<=tot2;i++)B[i].y=ef(B[i].y),B[i].z=ef(B[i].z);\n\tsort(B+1,B+tot2+1,cmp);\n\tnum++;\n\trt[0]=++cnt;build(1,1,num);\n\tfor (int i=1;i<=tot2;i++){\n\t\trt[i]=++cnt;insert(rt[i],rt[i-1],1,num,B[i].y,1);\n\t\tint k=rt[i];rt[i]=++cnt;insert(rt[i],k,1,num,B[i].z+1,-1);\n\t}\n\tfor (int i=1,j=1;i<=tot1;i++){\n\t\tint L=1,R=tot2+1;\n\t\twhile (L<R){\n\t\t\tint mid=(L+R)/2;\n\t\t\tif (B[mid].x<A[i].y)L=mid+1;\n\t\t\telse R=mid;\n\t\t}\n\t\tint l=L;\n\t\tL=0;R=tot2;\n\t\twhile (L<R){\n\t\t\tint mid=(L+R+1)/2;\n\t\t\tif (B[mid].x<=A[i].z)L=mid;\n\t\t\telse R=mid-1;\n\t\t}\n\t\tint r=L;\n\t\tans+=find(rt[r],1,num,A[i].x)-find(rt[l-1],1,num,A[i].x);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst long double EPS = 1e-10;\n\nclass Point {\n  public:\n  long double x, y;\n\n  Point(long double x = 0, long double y = 0): x(x), y(y) {}\n\n  Point operator + (Point &p) {\n    return Point(x + p.x, y + p.y);\n  }\n\n  Point operator - (Point &p) {\n    return Point(x - p.x, y - p.y);\n  }\n\n  Point operator * (long double k) {\n    return Point(x * k, y * k);\n  }\n\n  Point operator / (long double k) {\n    return Point(x / k, y / k);\n  }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nlong double norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nlong double abs(Point p) {\n  return sqrt(norm(p));\n}\n\nlong double dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\nlong double cross(Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Point v1 = p1 - p0, v2 = p2 - p0;\n  if (cross(v1, v2) > 0) return 1;\n  else if (cross(v1, v2) < 0) return -1;\n  else if (dot(v1, v2) < 0) return 2;\n  else if (norm(v1) < norm(v2)) return -2;\n  else return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nlong double getDistanceLP(Point p1, Point p2, Point p3) {\n  return fabs(cross(p2-p1, p3-p1) / abs(p2-p1));\n}\n\nlong double getDistanceSP(Point p1, Point p2, Point p3) {\n  if (dot(p2-p1, p3-p1) < 0) return abs(p3-p1);\n  else if (dot(p1-p2, p3-p2) < 0) return abs(p3-p2);\n  else return getDistanceLP(p1, p2, p3);\n}\n\nlong double getDistanceTS(Point p1, Point p2, Point p3, Point p4) {\n  if (intersect(p1, p2, p3, p4)) return 0;\n  long double ans = INF;\n  ans = min(ans, getDistanceSP(p1, p2, p3));\n  ans = min(ans, getDistanceSP(p1, p2, p4));\n  ans = min(ans, getDistanceSP(p3, p4, p1));\n  ans = min(ans, getDistanceSP(p3, p4, p2));\n  return ans;\n}\n\nclass Segment {\n  public:\n  Point p1, p2;\n};\n\nclass EndPoint {\n  public:\n  Point p;\n  int seg, st;\n  EndPoint() {}\n  EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n  bool operator < (const EndPoint &ep) const {\n    if (p.y == ep.p.y) {\n      return st < ep.st;\n    }\n    else return p.y < ep.p.y;\n  }\n};\n\nvector<EndPoint> EP;\n\nint manhattanIntersection(vector<Segment> S) {\n  int n = S.size();\n\n  rep(i, n) {\n    if (S[i].p1.y == S[i].p2.y) {\n      if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n    }\n    else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n    if (S[i].p1.y == S[i].p2.y) {\n      EP.push_back(EndPoint(S[i].p1, i, 1));\n      EP.push_back(EndPoint(S[i].p2, i, 2));\n    }\n    else {\n      EP.push_back(EndPoint(S[i].p1, i, 0));\n      EP.push_back(EndPoint(S[i].p2, i, 3));\n    }\n  }\n\n  sort(EP.begin(), EP.end());\n\n  set<int> BT;\n  BT.insert(INF);\n  int cnt = 0;\n\n  rep(i, 2 * n) {\n    if (EP[i].st == 3) {\n      BT.erase(EP[i].p.x);\n    }\n    else if (EP[i].st == 0) {\n      BT.insert(EP[i].p.x);\n    }\n    else if (EP[i].st == 1) {\n      set<int>::iterator b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n      set<int>::iterator e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n      cnt += distance(b, e);\n    }\n  }\n\n  return cnt;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Segment s;\n  vector<Segment> S;\n  rep(i, n) {\n    cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n    S.push_back(s);\n  }\n\n  cout << manhattanIntersection(S) << endl;\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nnamespace {\n\ttemplate<class T>\n\tstruct Vec2\n\t{\n\t\tVec2(T _x, T _y) : x(_x), y(_y) {}\n\t\tVec2 operator+(const Vec2& rhs) const { return Vec2(x + rhs.x, y + rhs.y); }\n\t\tVec2 operator-(const Vec2& rhs) const { return Vec2(x - rhs.x, y - rhs.y); }\n\t\tVec2 operator*(const T t) const { return Vec2(x*t, y*t); }\n\t\tbool operator<(const Vec2& rhs) const { return x != rhs.x ? x < rhs.x : y < rhs.y; }\n\t\tT dot(const Vec2& rhs) const { return x*rhs.x + y*rhs.y; }\n\t\tT cross(const Vec2& rhs) const { return x*rhs.y - y*rhs.x; }\n\t\tT x, y;\n\t};\n\n\ttypedef long long ll;\n\ttypedef Vec2<ll> P;\n\n\tstruct EndPoint\n\t{\n\t\tEndPoint(const pair<P, P>& _seg, bool _start) : seg(_seg), start(_start) {}\n\t\tbool operator<(const EndPoint& rhs) const { return cod().x < rhs.cod().x; }\n\t\tconst P& cod() const { return start ? seg.first : seg.second; }\n\n\t\tpair<P, P> seg;\n\t\tbool start;\n\t};\n}\n\nstatic int countIntersection(const vector<EndPoint>& X)\n{\n\tint num_int = 0;\n\tset<ll> Y;\n\tfor (size_t i = 0; i < X.size(); i++) {\n\t\tconst P& p0 = X[i].seg.first;\n\t\tconst P& p1 = X[i].seg.second;\n\t\tif (p0.x == p1.x) {\n\t\t\tnum_int += distance(Y.lower_bound(p0.y), Y.lower_bound(p1.y));\n\t\t}\n\t\telse if (X[i].start) {\n\t\t\tY.insert(p0.y);\n\t\t}\n\t\telse {\n\t\t\tY.erase(p0.y);\n\t\t}\n\t}\n\n\treturn num_int;\n}\n\nint main()\n{\n\tint n = 0;\n\tcin >> n;\n\n\tvector<EndPoint> X;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tP a(x1, y1), b(x2, y2);\n\t\tif (b < a) {\n\t\t\tswap(a, b);\n\t\t}\n\t\ta = a * 4;\n\t\tb = b * 4;\n\t\tif (a.y == b.y) {\n\t\t\ta.x--;\n\t\t\tb.x++;\n\t\t\tX.push_back(EndPoint(make_pair(a, b), true));\n\t\t\tX.push_back(EndPoint(make_pair(a, b), false));\n\t\t}\n\t\telse {\n\t\t\ta.y--;\n\t\t\tb.y++;\n\t\t\tX.push_back(EndPoint(make_pair(a, b), false));\n\t\t}\n\t}\n\tsort(X.begin(), X.end());\n\tcout << countIntersection(X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define INF 1e9\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int opt,l,r,x;}f[N*3];\nstruct seg{int ls,rs,su;}t[10000010];\nint nf,q,p1,p2,q1,q2,ansn,ro,num;\nbool comp(const Info &a,const Info &b){if (a.x==b.x) return a.opt<b.opt;return a.x<b.x;}\nint pa(int x){if (x>=0) return x/2;return (x-1)/2;}\nvoid add(int &nu,int l,int r,int we,int x){\n\tif (!nu) nu=++num;\n\tt[nu].su+=x;\n\tif (l!=r){\n\t\tint mid=pa(l+r);\n\t\tif (we<=(l+r)/2) add(t[nu].ls,l,mid,we,x);\n\t\telse add(t[nu].rs,mid+1,r,we,x);\n\t}\n}\nint que(int nu,int l,int r,int nl,int nr){\n\tif (!nu) return 0;\n\tif (l==nl&&r==nr) return t[nu].su;\n\tint mid=pa(l+r);\n\tif (nl>mid)return que(t[nu].rs,mid+1,r,nl,nr);\n\tif (nr<=mid) return que(t[nu].ls,l,mid,nl,nr);\n\treturn que(t[nu].ls,l,mid,nl,mid)+que(t[nu].rs,mid+1,r,mid+1,nr);\n}\nint main(){\n\tread(q);\n\tfor (int i=1;i<=q;i++){\n\t\tread(p1);read(q1);read(p2);read(q2);\n\t\tif (p1==p2){\n\t\t\tf[++nf].opt=1;f[nf].l=p1;f[nf].x=q1;\n\t\t\tf[++nf].opt=-1;f[nf].l=p1;f[nf].x=q2+1;\n\t\t}else{\n\t\t\tf[++nf].opt=2;f[nf].l=p1;f[nf].r=p2;f[nf].x=q1;\n\t\t}\n\t}\n\tsort(f+1,f+nf+1,comp);\n\tfor (int i=1;i<=nf;i++){\n\t\tif (f[i].opt==2)ansn+=que(ro,-INF,INF,f[i].l,f[i].r);\n\t\telse add(ro,-INF,INF,f[i].l,f[i].opt);\n\t}\n\tcout<<ansn<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nstruct IntL {\n    long long pos;\n    long long s;\n    long long t;\n};\n\nbool comp_intl(const IntL &a, const IntL &b) {\n    return a.pos < b.pos;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    vector<IntL> vx;\n    vector<IntL> vy;\n\n    for (int i = 0; i < N; i++) {\n        long long x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 == x2) {\n            IntL intL = {x1, min(y1, y2), max(y1, y2)};\n            vy.push_back(intL);\n        }\n        if (y1 == y2) {\n            IntL intL = {y1, min(x1, x2), max(x1, x2)};\n            vx.push_back(intL);\n        }\n    }\n\n    sort(vy.begin(), vy.end(), comp_intl);\n\n    long long ans = 0;\n    for (auto li: vx) {\n        long long left = li.s;\n        long long right = li.t;\n        long long posY = li.pos;\n        auto s1 = lower_bound(vy.begin(), vy.end(), (IntL) {left, LONG_LONG_MIN, LONG_LONG_MIN}, comp_intl);\n        auto s2 = lower_bound(vy.begin(), vy.end(), (IntL) {right, LONG_LONG_MIN, LONG_LONG_MIN}, comp_intl);\n        for (auto i = s1; i != s2; i++) {\n            if (i->s <= posY && posY <= i->t) ans++;\n        }\n    }\n\n    cout << ans << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn=1e5+10;\n\nstruct point{\n    int x,y;\n    point(){}\n    point(int x,int y):x(x),y(y){}\n} ;\n\nstruct segment{\n    point a,b;\n    int c;                  //用于排序，bottom>(left||right)>top\n    segment(point a,point b,int c):a(a),b(b),c(c){}\n    bool operator <(const segment & p){\n        if(a.y!=p.a.y) return a.y<p.a.y;\n        return c!=p.c?c<p.c:a.x<p.a.x;\n    }\n};\n\nvector<segment> v;\n\nint x[maxn*2];\n\nint tree[maxn<<2];\n\nvoid up(int p){\n    tree[p]=tree[p<<1]+tree[p<<1|1];\n}\n\nvoid modify(int p,int l,int r,int x,int v){\n    if(l==r){\n        tree[p]+=v;\n        return ;\n    }\n    int mid=l+r>>1;\n    if(x<=mid){\n        modify(p<<1,l,mid,x,v);\n    }else{\n        modify(p<<1|1,mid+1,r,x,v);\n    }\n    up(p);\n}\n\nint query(int p,int l,int r,int x,int y){\n    if(x<=l&&r<=y){\n        return tree[p];\n    }\n    int mid=l+r>>1;\n    int res=0;\n    if(x<=mid){\n        res+=query(p<<1,l,mid,x,y);\n    }\n    if(y>mid){\n        res+=query(p<<1|1,mid+1,r,x,y);\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int len=1;\n    for(int i=0;i<n;i++){\n        point a,b;\n        scanf(\"%d%d%d%d\",&a.x,&a.y,&b.x,&b.y);\n        if(a.x!=b.x){\n            if(a.x>b.x) swap(a,b);\n            x[len++]=a.x;\n            x[len++]=b.x;\n            v.push_back(segment(a,b,2));\n        }else{\n            if(a.y>b.y) swap(a,b);\n            x[len++]=a.x;\n            v.push_back(segment(a,a,1));\n            v.push_back(segment(b,b,3));\n        }\n    }\n    len--;\n//    printf(\"%d\\n\",len);\n    sort(x+1,x+len+1);\n    len=unique(x+1,x+len+1)-(x+1);\n//    for(int i=1;i<=len;i++){\n//        printf(\"%d \",x[i]);\n//    }\n    sort(v.begin(),v.end());\n    int vsize=v.size();\n//    for(int i=0;i<vsize;i++){\n//        printf(\"%d %d %d\\n\",v[i].a.x,v[i].a.y,v[i].c);\n//    }\n    int ans=0;\n    for(int i=0;i<vsize;i++){\n        if(v[i].a.x==v[i].b.x){\n            int id=lower_bound(x+1,x+len+1,v[i].a.x)-x;\n//            printf(\"--%d %d\\n\",v[i].a.x,id);\n            int c=v[i].c==3?-1:1;\n            modify(1,1,len,id,c);\n//            printf(\"123123123\\n\");\n        }else{\n            int id1=lower_bound(x+1,x+len+1,v[i].a.x)-x;\n            int id2=lower_bound(x+1,x+len+1,v[i].b.x)-x;\n//            printf(\"%d %d\\n\",v[i].a.x,id1);\n//            printf(\"%d %d\\n\",v[i].b.x,id2);\n            ans+=query(1,1,len,id1,id2);\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a - b > -EPS; }\ninline bool Grt(ld a, ld b){ return a - b > EPS; }\ninline bool Leq(ld a, ld b){ return a - b < EPS; }\ninline bool Lss(ld a, ld b){ return a - b < -EPS; }\ninline bool Equ(ld a, ld b){ return abs(a-b) < EPS; }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nbool byX(const PT &a, const PT &b){\n\tif (Equ(a.X, b.X))\n\t\t\treturn Lss(a.Y, b.Y);\n\t\treturn Lss(a.X, b.X);\n}\n\n\nstruct cmpXY{\n\tbool operator ()(const PT &a, const PT &b){\n\t\treturn byX(a, b);\n\t}\n};\n\nstruct cmpYX{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.Y, b.Y))\n\t\t\treturn Lss(a.X, b.X);\n\t\treturn Lss(a.Y, b.Y);\n\t}\n};\n\n\n\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}\n\nint main(){\t\n\tvector <PT> adds, rems;\n\tvector <LS> query;\n\tfor (int i = in(); i; i--){\n\t\tPT p, q;\n\t\tcin >> p >> q;\n\t\tif (Equ(p.Y, q.Y)){\n//\t\t\tcout << \"Here!\\n\";\n\t\t\tif (Lss(q.X, p.X))\n\t\t\t\tswap(p, q);\n\t\t\tadds.pb(p);\n\t\t\trems.pb(q);\n\t\t}\n\t\telse{\n\t\t\tif (Lss(q.Y, p.Y))\n\t\t\t\tswap(p, q);\n\t\t\tquery.pb({p, q});\n\t\t}\n\t}\n\tsort(adds.begin(), adds.end(), cmpXY());\n\tsort(rems.begin(), rems.end(), cmpXY());\n\tsort(query.begin(), query.end(), [](LS a, LS b){ return byX(a.F, b.F); });\n\tmultiset <ld> ys;\n\tint iadd = 0, irem = 0;\n\tint ans = 0;\n\tfor (auto p : query){\n//\t\tcout << p.F << ' ' << p.S << endl;\n\t\twhile (irem < rems.size() && Lss(rems[irem].X, p.F.X) && ys.find(rems[irem].Y) != ys.end()){\n//\t\t\tcout << \"remove \" << rems[irem].Y << endl;\n\t\t\tys.erase(ys.find(rems[irem++].Y));\n\t\t}\n\t\twhile (iadd < adds.size() && Leq(adds[iadd].X, p.F.X)){\n//\t\t\tcout << \"add \" << adds[iadd].Y << endl;\n\t\t\tys.insert(adds[iadd++].Y);\n\t\t}\n\t\tint cur = distance(ys.lower_bound(p.F.Y), ys.upper_bound(p.S.Y));\n//\t\tcout << cur << endl;\n\t\tans += cur;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int INF = 1111111111;\n\n#define equals(a, b) (fabs((a)-(b)) < EPS)\nconst double EPS = (1e-10);\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\nstatic const int BOTTOM = 0;\nstatic const int LEFT = 1;\nstatic const int RIGHT = 2;\nstatic const int TOP = 3;\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\n    bool operator < (const EndPoint &ep) const {\n        if (equals(p.y, ep.p.y)) {\n            return st < ep.st;\n        } else {\n            return p.y < ep.p.y;\n        }\n    }\n};\n\nEndPoint EP[2 * MAX_N];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; i++) {\n        if (equals(S[i].p1.x, S[i].p2.x)) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p1.y) {\n            swap(S[i].p1, S[i].p2);\n        }\n\n\n        if (equals(S[i].p1.y, S[i].p2.y)) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        } else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + 2*n);\n    set<int> BT;\n    BT.insert(INF);\n    int cnt = 0;\n\n    for (int i = 0; i < 2*n; i++) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        } else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        } else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\nint main(void) {\n    int n; cin >> n;\n\n    double x1, y1, x2, y2;\n    vector<Segment> S;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s(Point(x1, y1), Point(x2, y2));\n        S.push_back(s);\n    }\n\n    cout << manhattanIntersection(S) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint bit[200000];\nvector<int>v;\nvoid add(int k, int x) {\n\twhile (k <= v.size()) {\n\t\tbit[k] += x;\n\t\tk += k&-k;\n\t}\n}\nint sum(int k) {\n\tint res = 0;\n\twhile (k) {\n\t\tres += bit[k];\n\t\tk -= k&-k;\n\t}\n\treturn res;\n}\nint a[100000], b[100000], c[100000], d[100000];\nstruct st {\n\tint y, t, id;\n};\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tvector<st>xs;\n\trep(i, n) {\n\t\tscanf(\"%d%d%d%d\", &a[i], &b[i], &c[i], &d[i]);\n\t\tif (a[i] > c[i])swap(a[i], c[i]);\n\t\tv.push_back(a[i]); v.push_back(c[i]);\n\t\tif (a[i] == c[i]) {\n\t\t\txs.push_back({ b[i],0,i });\n\t\t\txs.push_back({ d[i],2,i });\n\t\t}\n\t\telse xs.push_back({ b[i],1,i });\n\t}\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tsort(xs.begin(), xs.end(), [](st&a, st&b) {\n\t\tif (a.y == b.y)return a.t < b.t;\n\t\treturn a.y < b.y;\n\t});\n\trep(i, n) {\n\t\ta[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin() + 1;\n\t\tc[i] = lower_bound(v.begin(), v.end(), c[i]) - v.begin() + 1;\n\t}\n\tint ans = 0;\n\tfor (st&p : xs) {\n\t\tif (p.t == 0)add(a[p.id], 1);\n\t\telse if (p.t == 1) {\n\t\t\tans += sum(c[p.id]);\n\t\t\tif (a[p.id])ans -= sum(a[p.id] - 1);\n\t\t}\n\t\telse add(a[p.id], -1);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n \nenum {\n  VTop,\n  HLeft,\n  VBottom\n};\n \nstruct P {\n  int x, y;\n  int type;\n  int oppo_x;\n  bool operator < (P const& p) const {\n    if(y != p.y) return y < p.y;\n    if(type != p.type) { return type < p.type; }\n    return x < p.x;\n  }\n};\n \nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n \nvoid print(vector<P> const& pts) {\n  int F[10][10] = {};\n  rep(i, pts.size()) {\n    if(pts[i].type != HLeft) {\n      if(pts[i].type == VTop) {\n        REP(j, pts[i].y, 10) { F[j][pts[i].x] = 1; }\n      }\n      else {\n        REP(j, pts[i].y+1, 10) { F[j][pts[i].x] = 0; }\n      }\n    }\n  }\n  rep(i, pts.size()) {\n    if(pts[i].type == HLeft) {\n      REP(j, pts[i].x, pts[i].oppo_x+1) { F[pts[i].y][j] = 1; }\n    }\n  }\n  rep(i, 10) {\n    rep(j, 10) {\n      cout << (F[i][j] ? \"#\" : \"_\");\n    }\n    cout << endl;\n  }\n}\n \nint main() {\n   \n  int N; cin >> N;\n  vector<P> pts;\n  rep(i, N) {\n    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    if(x1 > x2) swap(x1, x2);\n    if(y1 > y2) swap(y1, y2);\n    int type1, type2;\n    if(x1 == x2) {\n      type1 = VTop, type2 = VBottom;\n      pts.push_back((P){x1, y1, type1, -1});\n      pts.push_back((P){x2, y2, type2, -1});\n    }\n    else {\n      type1 = HLeft;\n      pts.push_back((P){x1, y1, type1, x2});\n    }\n  }\n   \n  sort(pts.begin(), pts.end());\n\n  int ret = 0;\n  set<int> xtree;\n  for(auto p: pts) {\n    if(p.type == VTop) {\n      xtree.insert(p.x);\n    }\n    if(p.type == VBottom) {\n      xtree.erase(p.x);\n    }\n    if(p.type == HLeft) {\n      int const x1 = p.x, x2 = p.oppo_x;\n      auto iter1 = xtree.lower_bound(x1);\n      auto iter2 = xtree.upper_bound(x2);\n\n      int cnt = 0;\n      while(iter1 != iter2) {\n        iter1++; cnt++;\n      }\n      ret += cnt;\n    }\n  }\n   \n  cout << ret << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n  \nint main(){\n\tvector<pair<int,pair<int,int>>> vx,vy;\n\tint i=0,r=0,n,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tif(x1>x2)swap(x1,x2);\n\t\tif(y1>y2)swap(y1,y2);\n\t\tif(x1==x2)vy.emplace_back(make_pair(x1,make_pair(y1,y2)));\n\t\telse vx.emplace_back(make_pair(y1,make_pair(x1,x2)));\n\t}\n\t//sort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tfor(auto &e:vx){\n\t\tauto it1=lower_bound(vy.begin(),vy.end(),make_pair(e.second.first,make_pair(-2000000000,-2000000000)));\n\t\tauto it2=lower_bound(vy.begin(),vy.end(),make_pair(e.second.second+1,make_pair(-2000000000,-2000000000)));\n\t\t\n\t\tfor(;it1!=it2;++it1){\n\t\t\tauto &f=*it1;\n\t\t\tif(f.second.first<=e.first&&e.first<=f.second.second)r++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nstruct IntL {\n    long long pos;\n    long long s;\n    long long t;\n};\n\nbool comp_intl(const IntL &a, const IntL &b) {\n    return a.pos < b.pos;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    vector<IntL> vx;\n    vector<IntL> vy;\n\n    for (int i = 0; i < N; i++) {\n        long long x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (x1 == x2) {\n            IntL intL = {x1, min(y1, y2), max(y1, y2)};\n            vy.push_back(intL);\n        }\n        if (y1 == y2) {\n            IntL intL = {y1, min(x1, x2), max(x1, x2)};\n            vx.push_back(intL);\n        }\n    }\n\n    sort(vy.begin(), vy.end(), comp_intl);\n\n    long long ans = 0;\n    for (auto li: vx) {\n        long long left = li.s;\n        long long right = li.t;\n        long long posY = li.pos;\n        auto s1 = lower_bound(vy.begin(), vy.end(), (IntL) {left, LONG_LONG_MIN, LONG_LONG_MIN}, comp_intl);\n        auto s2 = lower_bound(vy.begin(), vy.end(), (IntL) {right + 1, LONG_LONG_MIN, LONG_LONG_MIN}, comp_intl);\n        for (auto i = s1; i != s2; i++) {\n            if (i->s <= posY && posY <= i->t) ans++;\n        }\n    }\n\n    cout << ans << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int, int> i_i;\n\n#define rep(i, n) for(i = 0;i < n;++i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define X first\n#define Y second\n\nstruct rsqsegtree{\n  vector<int> t;\n  int re;\n  int n;\n  void use(int N){\n    re = 0; n = N;\n    int i, j;\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0] = 1 << i;\n    for(i = 1;i < t[0];++i)t[i] = re;\n    t[0] >>= 1;\n    return;\n  }\n  void update(int at, int data){\n    t[t[0] + at] += data;\n    int tmp;\n    for(int x = t[0] + at;x >= 2;x >>= 1)\n    t[x >> 1] = (t[(x >> 1) << 1] + t[((x >> 1) << 1) + 1]);\n    return;\n  }\n  int query(int l, int r, int k, int kl, int kr){\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    return query(l, r, k * 2, kl, (kl + kr) >> 1) + query(l, r, k * 2 + 1, (kl + kr) >> 1, kr);\n  }\n  int getsum(int l, int r){ return query(l, r, 1, 0, t[0]); }\n  void deb(void){\n    int x = 1;\n    t[0] *= 2;\n    printf(\"t[0] : %d\\n\", t[0]);\n    for(int i = 1;i < t[0];++i){\n      printf(\"%11d\", t[i]);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    t[0] /= 2;\n    return;\n  }\n};\n\nstruct query{\n  int q, y, l, r;\n};\nbool ysort(query qwe, query rty){\n  if(qwe.y != rty.y)return qwe.y < rty.y;\n  return !qwe.q < !rty.q;\n}\n\nrsqsegtree ST;\nquery Q[300000];\nvector<int> x;\nint qh = 0;\n\nint inv(int d){\n  int l = 0, r = x.size(), m;\n  for(;l + 1 < r;){\n    m = l + (r - l) / 2;\n    if(d == x[m])return m;\n    if(d > x[m])l = m;\n    else r = m;\n  }\n  return l;\n}\n\nsigned main(void){\n  int i, j;\n  int(n);\n  rep(i, n){\n    int4(x1, y1, x2, y2);\n    if(x1 == x2){\n      Q[qh++] = (query){1, min(y1, y2), x1, 0};\n      Q[qh++] = (query){-1, max(y1, y2), x1, 0};\n      x.pb(x1);\n    }else{\n      Q[qh++] = (query){0, y1, min(x1, x2), max(x1, x2)};\n      x.pb(x1);\n      x.pb(x2);\n    }\n  }\n  sort(Q, Q + qh, ysort);\n  sort(all(x));\n  x.erase(unique(all(x)), x.end());\n\n  ST.use(x.size());\n  int res = 0;\n  rep(i, qh){\n    if(Q[i].q == 0){\n      //printf(\"%d : %d : %d %d\\n\", i, Q[i].y, Q[i].l, inv(Q[i].l));\n      //printf(\"%d : %d : %d %d\\n\", i, Q[i].y, Q[i].r, inv(Q[i].r));\n      res += ST.getsum(inv(Q[i].l), inv(Q[i].r) + 1);\n    }else{\n      ST.update(inv(Q[i].l), Q[i].q);\n    }\n  }\n  printf(\"%d\\n\", res);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<set>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nenum\n{\n\tBOTTOM,\n\tLEFT,\n\tRIGHT,\n\tTOP\n};\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nstruct Segment\n{\n\tP p1, p2;\n\tSegment(P p1,P p2):p1(p1),p2(p2){}\n\tSegment():Segment(P(0,0),P(0,0)){}\n};\n\nstruct EndPoint\n{\n\tP p;\n\tint idx, type;\n\tEndPoint(P p,int idx,int type):p(p),idx(idx),type(type){}\n\tEndPoint() :EndPoint(P(0, 0), -1, -1){}\n\n\tbool operator<(const EndPoint& ep)const\n\t{\n\t\tif (p.y == ep.p.y)\n\t\t{\n\t\t\treturn type < ep.type;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn p.y < ep.p.y;\n\t\t}\n\t}\n};\n\nSegment segments[100000];\nEndPoint eps[200000];\n\nint CalcIntersection(int n)\n{\n\tfor (int i = 0, k = 0; i < n; i++)\n\t{\n\t\tif (segments[i].p1.x == segments[i].p2.x)\n\t\t{\n\t\t\tif (segments[i].p1.y>segments[i].p2.y)\n\t\t\t{\n\t\t\t\tswap(segments[i].p1, segments[i].p2);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (segments[i].p1.x>segments[i].p2.x)\n\t\t\t{\n\t\t\t\tswap(segments[i].p1, segments[i].p2);\n\t\t\t}\n\t\t}\n\n\t\tif (segments[i].p1.x == segments[i].p2.x)\n\t\t{\n\t\t\teps[k++] = EndPoint(segments[i].p1, i, BOTTOM);\n\t\t\teps[k++] = EndPoint(segments[i].p2, i, TOP);\n\t\t}\n\t\telse\n\t\t{\n\t\t\teps[k++] = EndPoint(segments[i].p1, i, LEFT);\n\t\t\teps[k++] = EndPoint(segments[i].p2, i, RIGHT);\n\t\t}\n\t}\n\n\tsort(eps, eps + (2 * n));\n\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint count = 0;\n\n\tfor (int i = 0; i < (2 * n); i++)\n\t{\n\t\tif (eps[i].type == TOP)\n\t\t{\n\t\t\tBT.erase(eps[i].p.x);\n\t\t}\n\t\telse if (eps[i].type == BOTTOM)\n\t\t{\n\t\t\tBT.insert(eps[i].p.x);\n\t\t}\n\t\telse if (eps[i].type == LEFT)\n\t\t{\n\t\t\tauto l = lower_bound(BT.begin(), BT.end(), segments[eps[i].idx].p1.x);\n\t\t\tauto u = upper_bound(BT.begin(), BT.end(), segments[eps[i].idx].p2.x);\n\t\t\tcount += distance(l, u);\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tsegments[i] = Segment(P(x1, y1), P(x2, y2));\n\t}\n\n\tprintf(\"%d\\n\", CalcIntersection(n));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Segment {\n    int x1, y1, x2, y2;\n    \n    Segment(int x1 = 0, int y1 = 0, int x2 = 0, int y2 = 0): \n    x1(min(x1, x2)), x2(max(x1, x2)), y1(min(y1, y2)), y2(max(y1, y2)) {}\n    \n};\n\nconst int LEFT = 0;\nconst int BOTTOM = 1;\nconst int TOP = 2;\nconst int RIGHT = 3;\n\nstruct Event {\n    int seg;\n    int type;\n    int x;\n    \n    Event(int seg = -1, int type = -1, int x = -1): seg(seg), type(type), x(x) {}\n    \n    bool operator<(const Event other) const {\n        if (x == other.x) {\n            return type < other.type;\n        }\n        else {\n            return x < other.x;\n        }\n    } \n};\n\nint main() {\n    int n;\n    cin >> n;\n    int x1, y1, x2, y2;\n    vector<Segment> segs(n);\n    vector<Event> events;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        segs[i] = Segment(x1, y1, x2, y2);\n        if (segs[i].y1 == segs[i].y2) {\n            events.push_back(Event(i, LEFT, segs[i].x1));\n            events.push_back(Event(i, RIGHT, segs[i].x2));\n        }\n        else {\n           events.push_back(Event(i, BOTTOM, segs[i].x1));\n           events.push_back(Event(i, TOP, segs[i].x1)); \n        }  \n    }\n    \n    sort(events.begin(), events.end());\n    \n//    for (Segment s : segs) {\n//        cout << s.x1 << \" \" << s.y1 << \" \" << s.x2 << \" \" << s.y2 << endl;\n//    }\n//    \n//    for (Event e : events) {\n//        cout << e.x << \" \" << e.type << \" \" << e.seg << endl;\n//    }\n    \n    int count = 0;\n    set<int> bst;\n    \n    for (Event e: events) {\n        Segment s = segs.at(e.seg);\n        if (e.type == LEFT) {\n            bst.insert(s.y1);\n        }\n        else if (e.type == RIGHT) {\n            bst.erase(s.y1);\n        }\n        else if (e.type == TOP) {\n            auto lower = bst.lower_bound(s.y1);\n            auto upper = bst.upper_bound(s.y2);\n            count += distance(lower, upper);\n        }\n    }\n    cout << count << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 線分の交差問題\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 2点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\nint main(void)\n{\n\n    int n, count = 0;\n    Point start, end;\n    vector<Segment> v_H_seg, v_V_seg;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> start.x >> start.y >> end.x >> end.y;\n\n        if( end < start )\n        {\n            swap(start, end);\n        }\n\n        // 線分を作成\n        Segment s(start, end);\n\n        if( start.x == end.x )\n        {\n            // y軸に平行な線分\n            v_H_seg.push_back(s);\n        }\n        else\n        {\n            // x軸に平行な線分\n            v_V_seg.push_back(s);\n        }\n    }\n\n    // 線分の交点を検索する\n    for( int i = 0; i < v_V_seg.size(); i++)\n    {\n        for(int j = 0; j < v_H_seg.size(); j++)\n        {\n            // x, y軸方向について, 線分が交差する条件を調べる\n            if( v_V_seg[i].p1.x <= v_H_seg[j].p1.x && v_H_seg[j].p1.x <= v_V_seg[i].p2.x )\n            {\n                if( v_H_seg[j].p1.y <= v_V_seg[i].p1.y && v_V_seg[i].p1.y <= v_H_seg[j].p2.y )\n                {\n                    // 線分が交差する\n                    count++;\n                }\n            }\n        }\n    }\n\n    // 結果の表示\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MAX_SIZE = 200001;\nint BIT[MAX_SIZE];\nint BIT_N;\n\nvoid add(int i, int x)\n{\n\twhile (i <= BIT_N)\n\t{\n\t\tBIT[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nvoid add(int l, int r, int x)\n{\n\tadd(l, x);\n\tadd(r + 1, -x);\n}\n\nint sum(int i)\n{\n\tint s = 0;\n\twhile (i > 0)\n\t{\n\t\ts += BIT[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\ttypedef pair<P, P> PP;\n\t\tvector<PP> lines;\n\t\tset<int> points;\n\t\trep(i, n)\n\t\t{\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\tlines.push_back(PP(P(y1, y2), P(x1, x2)));\n\t\t\tif(y1 != y2) lines.push_back(PP(P(y2, y1), P(x1, x2)));\n\t\t\tpoints.insert(x1);\n\t\t\tpoints.insert(x2);\n\t\t}\n\t\tmap<int, int> table;\n\t\tint idx = 1;\n\t\tfor (int x : points)\n\t\t{\n\t\t\ttable[x] = idx;\n\t\t\tidx++;\n\t\t}\n\t\tBIT_N = table.size();\n\t\tsort(all(lines));\n\n\t\tint ans = 0;\n\t\tfor (PP pp : lines)\n\t\t{\n\t\t\tint y1 = pp.first.first, y2 = pp.first.second,\n\t\t\t\t//x1 = table[pp.second.first], x2 = table[pp.second.second];\n\t\t\t\tx1 = pp.second.first, x2 = pp.second.second;\n\n\t\t\tif (y1 < y2) add(x1, 1);\n\t\t\tif (y1 > y2) add(x1, -1);\n\t\t\tif (y1 == y2) ans += sum(x2) - sum(x1 - 1);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long long              lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MAXE = 2*MAXN;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\n\nenum{ OPEN, LINE, CLOSE };\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\nstruct Event {\n  int t;\n  pt p, q;\n  Event() {}\n  Event( int t, pt p, pt q ) : t(t), p(p), q(q) {}\n};\n\nbool cmp_Event( const Event &A, const Event &B ) {\n  if( A.p.x != B.p.x ) return A.p.x < B.p.x;\n  return A.t < B.t;\n}\n\nint n;\npt P[ 2 ][ MAXN ];\nll zip[ 2 ][ 2*MAXN ];\nint bit[ MAXN ];\nEvent events[ MAXE ];\n\nvoid add( int i ) {\n  for( ; i < MAXN; i += ( i&-i ) ) {\n    ++bit[ i ];\n  }\n}\n\nvoid erase( int i ) {\n  for( ; i < MAXN; i += ( i&-i ) ) {\n    --bit[ i ];\n  }\n}\n\nint query( int i ) {\n  int sum = 0;\n  for( ; i > 0; i -= (i&-i) ) {\n    sum += bit[ i ];\n  }\n  return sum;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[ 0 ][ i ] >> P[ 1 ][ i ];\n    if( P[0][i].y > P[1][i].y ) swap( P[0][i], P[1][i] );\n    if( P[0][i].x > P[1][i].x ) swap( P[0][i], P[1][i] );\n\n    zip[ 0 ][ i ] = P[0][i].x; zip[ 0 ][ i+n ] = P[1][i].x;\n    zip[ 1 ][ i ] = P[0][i].y; zip[ 1 ][ i+n ] = P[1][i].y;\n  }\n  sort( zip[0], zip[0]+2*n ); sort( zip[1], zip[1]+2*n );\n  int sz1 = distance( zip[0], unique( zip[0], zip[0]+2*n ) );\n  int sz2 = distance( zip[1], unique( zip[1], zip[1]+2*n ) );\n\n  for( int i = 0; i < 2; ++i ) {\n    for( int j = 0; j < n; ++j ) {\n      P[i][j].x = lower_bound( zip[0], zip[0]+sz1, P[i][j].x ) - zip[0];\n      P[i][j].y = lower_bound( zip[1], zip[1]+sz2, P[i][j].y ) - zip[1];\n\n    }\n  }\n  int t = 0;\n  for( int i = 0; i < n; ++i ) {\n      if( P[0][i].x == P[1][i].x ) {\n        events[ t++ ] = Event( LINE, P[0][i], P[1][i] );\n      }\n      else {\n        events[ t++ ] = Event( OPEN,  P[0][i], P[0][i] );\n        events[ t++ ] = Event( CLOSE, P[1][i], P[1][i] );\n      }\n  }\n  int ans = 0;\n  sort( events, events+t, cmp_Event );\n  for( int i = 0; i < t; ++i ) {\n    Event &e = events[i];\n    if( e.t == OPEN ) {\n      add( e.p.y );\n    }\n    else if( e.t == CLOSE ) {\n      erase( e.p.y );\n    }\n    else if( e.t == LINE ) {\n      ans += query( e.q.y ) - query( e.p.y-1 );\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll int\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1<<30)-(1<<15))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\n\nint uniquell(ll*a,ll*ans,int cnt){\n\tsortup(a,cnt);\n\tint c=0;\n\tans[0]=a[0];\n\trep(i,1,cnt)if(a[i]!=ans[c])ans[++c]=a[i];\n\treturn c+1;\n}\n//座圧2\n//前準備：\n//圧縮したい配列aに-INFとINFを追加する\n//uniquell(a,comp,n)でcompに昇順の配列を作る\nll cocompf(ll n,ll*comp,int compcnt){\n\t//comp[i]<=n<comp[i+1]なるiを返す\n\tll l=0,r=compcnt;\n\twhile(r-l>1){\n\t\tll m=(l+r)/2;\n\t\tif(comp[m]<=n)l=m;\n\t\telse r=m;\n\t}\n\treturn l;\n}\n\n\n//セグ木ここから\n//*\n//↓ここを変える\ntypedef struct atai{ll a;}atai;\natai xx(atai x,atai y){\n\tatai r;\n\tr.a=x.a+y.a;//sum\n\treturn r;\n}\natai aid={0};\n//↑ここを変える\n\nint segNUM;\natai *segN,*seg;\nvoid seguse(int n){\n\tsegN=(atai*)calloc(2*n,sizeof(atai));\n\tsegNUM=n;\n\tseg=segN+segNUM;\n\trep(i,1,2*segNUM)segN[i]=aid;\n}\n//seg[]に値を与えてから初期化\nvoid seginit(){for(int node=segNUM-1;node;node--)segN[node]=xx(segN[node*2],segN[node*2+1]);}\nvoid segupdate(int node,atai x){\n\t//seg[node]をxに更新\n\tnode+=segNUM;\n\tsegN[node]=x;\n\twhile(node/=2)segN[node]=xx(segN[node*2],segN[node*2+1]);\n}\n\natai segcalcsub(int l,int r,int k,int cl,int cr){\n\tif(l>=r)return aid;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r)return segN[k];\n\n\tint cm=(cl+cr)/2;\n\t//左側だけ\n\tif(r<=cm)return segcalcsub(l,r,2*k  ,cl,cm);\n\t//右側だけ\n\tif(cm<=l)return segcalcsub(l,r,2*k+1,cm,cr);\n\t//両方\n\treturn xx(segcalcsub(l,r,2*k,cl,cm),segcalcsub(l,r,2*k+1,cm,cr));\n}\natai segcalc(int l,int r){return segcalcsub(l,r,1,0,segNUM);}\n//セグ木ここまで\n//*/\n\ntypedef struct Line{int x,y1,y2;}L;\nL yoko[100010],tate[100010];\nint yokoc(const void*p,const void*q){\n\tif((*(L*)p).x<(*(L*)q).x)return -1;\n\treturn 1;\n}\n\nint tate1(const void*p,const void*q){\n\tif(tate[*(int*)p].y1<tate[*(int*)q].y1)return -1;\n\treturn 1;\n}\nint tate2(const void*p,const void*q){\n\tif(tate[*(int*)p].y2<tate[*(int*)q].y2)return -1;\n\treturn 1;\n}\n\nint yokocnt,tatecnt;\nint x[200010],xxx;\nint idx1[100010],idx2[100010];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tif(a==c){\n\t\t\ttate[tatecnt].x =a;\n\t\t\ttate[tatecnt].y1=min(b,d);\n\t\t\ttate[tatecnt].y2=max(b,d);\n\t\t\ttatecnt++;\n\t\t\tx[xxx++]=a;\n\t\t}else{\n\t\t\tyoko[yokocnt].x =b;\n\t\t\tyoko[yokocnt].y1=min(a,c);\n\t\t\tyoko[yokocnt].y2=max(a,c);\n\t\t\tyokocnt++;\n\t\t\tx[xxx++]=a;\n\t\t\tx[xxx++]=c;\n\t\t}\n\t}\n\tx[xxx++]=-INF;\n\tx[xxx++]=INF;\n\txxx=uniquell(x,x,xxx);\n\trep(i,0,tatecnt)idx1[i]=idx2[i]=i;\n\tqsort(yoko,yokocnt,sizeof(L),yokoc);\n\tqsort(idx1,tatecnt,sizeof(int),tate1);\n\tqsort(idx2,tatecnt,sizeof(int),tate2);\n\tint tate1crr=0,tate2crr=0;\n\tlong long ans=0;\n\tseguse(1<<18);\n\trep(i,0,yokocnt){\n\t\twhile(tate1crr<tatecnt&&tate[idx1[tate1crr]].y1<=yoko[i].x){\n\t\t\t//追加\n\t\t\tint cc=cocompf(tate[idx1[tate1crr]].x,x,xxx);\n\t\t\tatai x=seg[cc];\n\t\t\tx.a++;\n\t\t\tsegupdate(cc,x);\n\t\t\ttate1crr++;\n\t\t}\n\t\twhile(tate2crr<tatecnt&&tate[idx2[tate2crr]].y2<yoko[i].x){\n\t\t\t//削除\n\t\t\tint cc=cocompf(tate[idx2[tate2crr]].x,x,xxx);\n\t\t\tatai x=seg[cc];\n\t\t\tx.a--;\n\t\t\tsegupdate(cc,x);\n\t\t\ttate2crr++;\n\t\t}\n\t\t//計算\n\t\tans+=segcalc(cocompf(yoko[i].y1,x,xxx),cocompf(yoko[i].y2,x,xxx)+1).a;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define NIL 0\nenum direction {\n  BOTTOM,\n  LEFT,\n  RIGHT,\n  TOP\n};\nstruct point {\n  double x;\n  double y;\n};\nstruct endpoint {\n  struct point p;\n  int seg;\n  enum direction dir;\n};\nstruct node {\n  int left;\n  int right;\n  int key;\n};\nint count = 1, ans, root = NIL;\nvoid Find(struct node *tree, int, int, int);\nvoid Insert(struct node *tree, int);\nvoid Delete(struct node *tree, int);\nint compare(const void *a, const void *b);\nvoid manhattan_intersection(int n, struct point (*s)[2], struct endpoint *ep, struct node *tree);\nint main (void) {\n  int i, n;\n  struct point (*s)[2];\n  struct endpoint *ep;\n  struct node *tree;\n  scanf(\"%d\", &n);\n  s = (struct point (*)[2])malloc(sizeof(struct point) * n * 2);\n  ep = (struct endpoint*)malloc(sizeof(struct endpoint) * n * 2);\n  tree = (struct node*)malloc(sizeof(struct node) * n * 2);\n  for (i = 0; i < n; i++) scanf(\"%lf%lf%lf%lf\", &s[i][0].x, &s[i][0].y, &s[i][1].x, &s[i][1].y);\n  manhattan_intersection(n, s, ep, tree);\n  free(s);\n  free(ep);\n  free(tree);\n}\nvoid Find(struct node *tree, int lbound, int ubound, int loc)\n{\n  if (loc != NIL) {\n    if (tree[loc].key >= lbound && tree[loc].key <= ubound) ans++;\n    if (tree[loc].key >= lbound) Find(tree, lbound, ubound, tree[loc].left);\n    if (tree[loc].key <= ubound) Find(tree, lbound, ubound, tree[loc].right);\n  }\n}\nvoid Insert(struct node *tree, int data)\n{\n  int parent = NIL, u = root;\n  while (u != NIL) {\n    parent = u;\n    if(tree[u].key == data) return;\n    else if (tree[u].key > data) {\n      u = tree[u].left;\n    }else {\n      u = tree[u].right;\n    }\n  }\n  tree[count].key = data;\n  tree[count].left = tree[count].right = NIL;\n  if (parent == NIL) {\n    root = count++;\n  } else if(tree[parent].key > data) {\n    tree[parent].left = count++;\n  } else {\n    tree[parent].right = count++;\n  }\n}\nvoid Delete(struct node *tree, int data)\n{\n  int u = root, del, parent = NIL;\n  tree[NIL].key = data;\n  while (tree[u].key != data) {\n    parent = u;\n    if (tree[u].key > data) {\n      u = tree[u].left;\n    } else {\n      u = tree[u].right;\n    }\n  }\n  if (u == NIL) return;\n  while (1){\n    if (tree[u].left == NIL) {\n      if (tree[parent].left == u) {\n        tree[parent].left = tree[u].right;\n      }\n      else {\n        tree[parent].right = tree[u].right;\n      }\n      if (parent == NIL) root = tree[u].right;\n      break;\n    } else if (tree[u].right == NIL) {\n      if (tree[parent].left == u) {\n        tree[parent].left = tree[u].left;\n      }\n      else {\n        tree[parent].right = tree[u].left;\n      }\n      if (parent == NIL) root = tree[u].left;\n      break;\n    } else {\n      int temp = tree[u].right;\n      parent = u;\n      while (tree[temp].left != NIL) {\n        parent = temp;\n        temp = tree[temp].left;\n      }\n      tree[u].key = tree[temp].key;\n      u = temp;\n    }\n  }\n}\nint compare(const void *a, const void *b)\n{\n  struct endpoint *ta = (struct endpoint*)a, *tb = (struct endpoint*)b;\n  if (ta->p.y > tb->p.y) return 1;\n  else if (ta->p.y < tb->p.y) return -1;\n  else {\n    if (ta->dir > tb->dir) return 1;\n    else return -1;\n  }\n  return 0;\n}\n\nvoid manhattan_intersection(int n, struct point (*s)[2], struct endpoint *ep, struct node *tree)\n{\n  int i, k = 0;\n  for (i = 0, k = 0; i < n; i++) {\n    if (s[i][0].y == s[i][1].y) {\n      if (s[i][0].x > s[i][1].x) {\n        struct point temp = s[i][0];\n        s[i][0] = s[i][1];\n        s[i][1] = temp;\n      }\n      ep[k].p = s[i][0];\n      ep[k].seg = i;\n      ep[k].dir = LEFT;\n      k++;\n      ep[k].p = s[i][1];\n      ep[k].seg = i;\n      ep[k].dir = RIGHT;\n      k++;\n    } else {\n      if (s[i][0].y > s[i][1].y) {\n        struct point temp = s[i][0];\n        s[i][0] = s[i][1];\n        s[i][1] = temp;\n      }\n      ep[k].p = s[i][0];\n      ep[k].seg = i;\n      ep[k].dir = BOTTOM;\n      k++;\n      ep[k].p = s[i][1];\n      ep[k].seg = i;\n      ep[k].dir = TOP;\n      k++;\n    }\n  }\n  qsort(ep, n * 2, sizeof(struct endpoint), compare);\n  for (i = 0; i < 2 * n; i++) {\n    if (ep[i].dir == TOP) Delete(tree, ep[i].p.x);\n    else if (ep[i].dir == BOTTOM) Insert(tree, ep[i].p.x);\n    else if (ep[i].dir == LEFT) {\n      if (s[ep[i].seg][0].x < s[ep[i].seg][1].x) {\n        Find(tree, s[ep[i].seg][0].x, s[ep[i].seg][1].x, root);\n      } else {\n        Find(tree, s[ep[i].seg][1].x, s[ep[i].seg][0].x, root);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n\n/* **********************************************************************************\n  Red Black Tree\n ********************************************************************************** */\n\ntypedef int key_t;\n\ntypedef struct node {\n  key_t key;\n  int red;\n  struct node *par, *ch[2];\n} node_t;\n\ntypedef node_t* node_ptr;\n\nnode_ptr node_create(key_t key) {\n  node_ptr p = (node_ptr)malloc(sizeof(node_t));\n  p->key = key;\n  p->red = 1;\n  p->par = p->ch[0] = p->ch[1] = NULL;\n  return p;\n}\n\nunsigned rb_sz;\nnode_ptr rb_root, rb_nil;\n\nvoid rb_init(){ \n  rb_sz = 0;\n  rb_nil = node_create(-1);\n  rb_nil->key = -1;\n  rb_nil->red = 0;\n  rb_root = node_create(-1);\n\n  rb_root\n  = rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1]\n  = rb_nil;\n}\n\nunsigned rb_size() { return rb_sz; }\n\nvoid rb_print_node(node_ptr v, int depth, int lr) {\n  int i;\n\n  if(v == rb_nil)\n    return;\n\n  rb_print_node(v->ch[1], depth+1, 1);\n\n  for(i = 0; i < depth; i++)\n    printf(\"  \");\n\n  if(!lr)\n    printf(\"--\");\n  else if(lr == 1)\n    printf(\"???\");\n  else\n    printf(\"??¬\");\n\n  if(v->red)\n    printf(\"\\x1b[31m\");\n\n  printf(\"%d\\n\", v->key);\n  printf(\"\\x1b[0m\");\n  rb_print_node(v->ch[0], depth + 1, 2);\n}\n\nvoid rb_print(){\n  assert(rb_root);\n  rb_print_node(rb_root, 0, 0);\n}\n\nvoid rb_rotate(node_ptr x, int d) {\n  int e = d^1;\n  node_ptr y = x->ch[e];\n  x->ch[e] = y->ch[d];\n  if(y->ch[d] != rb_nil) y->ch[d]->par = x;\n  y->par = x->par;\n  if(x->par == rb_nil) rb_root = y;\n  else if(x == x->par->ch[d]) x->par->ch[d] = y;\n  else x->par->ch[e] = y;\n  y->ch[d] = x;\n  x->par = y;\n}\n\nnode_ptr rb_find(key_t key) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  return x;\n}\n\nvoid rb_insert_update(node_ptr z) {\n  node_ptr y;\n  int d, e;\n  while(z->par->red) {\n    d = z->par == z->par->par->ch[0] ? 0 : 1;\n    e = d^1;\n    y = z->par->par->ch[e];\n    if(y->red) {\n      z->par->red = 0;\n      y->red = 0;\n      z->par->par->red = 1;\n      z = z->par->par;\n    }\n    else if(z == z->par->ch[e]) {\n      z = z->par;\n      rb_rotate(z,d);\n    }\n    else {\n      z->par->red = 0;\n      z->par->par->red = 1;\n      rb_rotate(z->par->par,e);\n    }\n  }\n  rb_root->red = 0;\n}\n\nnode_ptr rb_insert(key_t key) {\n  node_ptr x = rb_root, y = rb_nil;\n  node_ptr z;\n  while(x != rb_nil) {\n    y = x;\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  rb_sz++;\n  z = node_create(key);\n  z->par = y;\n  if(y == rb_nil) rb_root = z;\n  else y->ch[z->key >= y->key] = z;\n  z->ch[0] = z->ch[1] = rb_nil;\n  rb_insert_update(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  return z;\n}\n\nvoid rb_transplant(node_ptr u, node_ptr v) {\n  if(u->par == rb_nil) rb_root = v;\n  else if(u == u->par->ch[0]) u->par->ch[0] = v;\n  else u->par->ch[1] = v;\n  v->par = u->par;\n}\n\nnode_ptr rb_minimum(node_ptr x) {\n  while(x->ch[0] != rb_nil) x = x->ch[0];\n  return x;\n}\n\nvoid rb_erase_update(node_ptr x) {\n  node_ptr w = rb_nil;\n  int d, e;\n  while(x != rb_root && !x->red) {\n    d = x == x->par->ch[0]? 0: 1, e = d^1;\n    w = x->par->ch[e];\n    if(w->red) {\n      w->red = 0;\n      x->par->red = 1;\n      rb_rotate(x->par,d);\n      w = x->par->ch[e];\n    }\n    else if(!w->ch[d]->red && !w->ch[e]->red) {\n      w->red = 1;\n      x = x->par;\n    }\n    else if(!w->ch[e]->red) {\n      w->ch[d]->red = 0;\n      w->red = 1;\n      rb_rotate(w,e);\n      w = x->par->ch[e];\n    }\n    else {\n      w->red = x->par->red;\n      x->par->red = 0;\n      w->ch[e]->red = 0;\n      rb_rotate(x->par,d);\n      x = rb_root;\n    }\n  }\n  x->red = 0;\n}\n\nvoid rb_erase_node(node_ptr z) {\n  node_ptr y, x;\n  int prevy;\n  if(z == rb_nil) return;\n  rb_sz--;\n  y = z;\n  prevy = y->red;\n  if(z->ch[0] == rb_nil) {\n    x = z->ch[1];\n    rb_transplant(z,z->ch[1]);\n  }\n  else if(z->ch[1] == rb_nil) {\n    x = z->ch[0];\n    rb_transplant(z,z->ch[0]);\n  }\n  else {\n    y = rb_minimum(z->ch[1]);\n    prevy = y->red;\n    x = y->ch[1];\n    if(y->par == z) x->par = y;\n    else {\n      rb_transplant(y,y->ch[1]);\n      y->ch[1] = z->ch[1];\n      y->ch[1]->par = y;\n    }\n    rb_transplant(z,y);\n    y->ch[0] = z->ch[0];\n    y->ch[0]->par = y;\n    y->red = z->red;\n  }\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  if(!prevy) rb_erase_update(x);\n  free(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n}\n\nvoid rb_erase(key_t key) {\n  rb_erase_node(rb_find(key));\n}\n\nnode_ptr rb_successor(node_ptr x) {\n  node_ptr y;\n  if(x->ch[1] != rb_nil)\n    return rb_minimum(x->ch[1]);\n  y = x->par;\n  while(y != rb_nil && x == y->ch[1]) {\n    x = y;\n    y = y->par;\n  }\n  return y;\n}\n\nnode_ptr rb_binary_search(key_t key, int upper_bound) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) {\n      if(x->ch[key > x->key] == rb_nil) {\n        if(key > x->key)\n          return rb_successor(x);\n        else return x;\n      }\n      else {\n        x = x->ch[key > x->key];\n      }\n    }\n    else return upper_bound ? rb_successor(x) : x;\n  }\n  return x;\n}\n\nnode_ptr rb_lower_bound(key_t key) {\n  return rb_binary_search(key, 0);\n}\n\nnode_ptr rb_upper_bound(key_t key) {\n  return rb_binary_search(key, 1);\n}\n\n/* **********************************************************************************\n  End of Red Black Tree\n ********************************************************************************** */\n\nenum {\n  VTop = 0,\n  HLeft = 1,\n  VBottom = 2\n};\n  \ntypedef struct P_ {\n  int x, y;\n  int type;\n  int oppo_x;\n} P;\n\nint max(int x, int y) {\n  return x < y ? y : x;\n}\n\nint min(int x, int y) {\n  return x < y ? x : y;\n}\n\nint compare_P(const void *a_, const void *b_) {\n  const P *a = (const P *)a_;\n  const P *b = (const P *)b_;\n  if(a->y != b->y) return a->y - b->y;\n  if(a->type != b->type) return a->type - b->type;\n  return a->x - b->x;\n}\nstruct Line { P ps[2]; };\n\nvoid swap(int* a, int* b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nvoid shuffle(P ary[],int size) {\n  int i;\n  for(i=0;i<size;i++) {\n    int j = rand()%size;\n    P t = ary[i];\n    ary[i] = ary[j];\n    ary[j] = t;\n  }\n}\n\nint main() {\n\n  \n  #if 0\n  /*\n    Red-black tree test code\n  */\n  int i;\n  rb_init();\n  srand((unsigned)(time(NULL)));\n  for(i=0; i<100; i++)\n    rb_insert(rand());\n  rb_print();\n\n  printf(\"minimum: %d\\n\", rb_minimum(rb_root)->key);\n\n  while(~scanf(\"%d\", &i)) {\n    printf(\"lower_bound(%d): %d\\n\", i, rb_lower_bound(i)->key);\n    printf(\"upper_bound(%d): %d\\n\", i, rb_upper_bound(i)->key);\n    printf(\"successor(lower_bound(%d)): %d\\n\", i, rb_successor(rb_lower_bound(i))->key);\n    rb_erase(i);\n    rb_print();\n    printf(\"deleted: %d\\n\", i);\n  }\n\n  return 0;\n}\n  #else\n\n  P pts[200010];\n  int pcnt = 0;\n  int x1, y1, x2, y2;\n  int type1, type2;\n  int ret;\n  int cnt;\n  int i;\n  node_ptr iter1 = NULL, iter2 = NULL;\n  int N;\n\n  scanf(\"%d\", &N);\n\n  for(i = 0; i < N; i++) {\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\n    if(x1 > x2) swap(&x1, &x2);\n    if(y1 > y2) swap(&y1, &y2);\n    if(x1 == x2) {\n      type1 = VTop, type2 = VBottom;\n      pts[pcnt++] = (P){x1, y1, type1, -1};\n      pts[pcnt++] = (P){x2, y2, type2, -1};\n    }\n    else {\n      type1 = HLeft;\n      pts[pcnt++] = (P){x1, y1, type1, x2};\n    }\n  }\n\n  qsort(pts, pcnt, sizeof(P), (int (*)(const void *, const void *))compare_P);\n\n  ret = 0;\n  rb_init();\n\n  for(i = 0; i < pcnt; i++) {\n    if(pts[i].type == VTop) {\n      rb_insert(pts[i].x);\n    }\n    if(pts[i].type == VBottom) {\n      rb_erase(pts[i].x);\n    }\n    if(pts[i].type == HLeft) {\n      x1 = pts[i].x, x2 = pts[i].oppo_x;\n      iter1 = rb_lower_bound(x1);\n      iter2 = rb_upper_bound(x2);\n \n      cnt = 0;\n      while(iter1 != iter2) {\n        iter1 = rb_successor(iter1); cnt++;\n      }\n      ret += cnt;\n    }\n  }\n    \n  printf(\"%d\\n\", ret);\n\n  return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define NIL 0\nenum direction {\n  BOTTOM,\n  LEFT,\n  RIGHT,\n  TOP\n};\nstruct point {\n  double x;\n  double y;\n};\nstruct endpoint {\n  struct point p;\n  int seg;\n  enum direction dir;\n};\nstruct node {\n  int left;\n  int right;\n  int key;\n};\nint count = 1, ans, root = NIL;\nvoid Find(struct node *tree, int, int, int);\nvoid Insert(struct node *tree, int);\nvoid Delete(struct node *tree, int);\nint compare(const void *a, const void *b);\nvoid manhattan_intersection(int n, struct point (*s)[2], struct endpoint *ep, struct node *tree);\nint main (void) {\n  int i, n;\n  struct point (*s)[2];\n  struct endpoint *ep;\n  struct node *tree;\n  scanf(\"%d\", &n);\n  s = (struct point (*)[2])malloc(sizeof(struct point) * n * 2);\n  ep = (struct endpoint*)malloc(sizeof(struct endpoint) * n * 2);\n  tree = (struct node*)malloc(sizeof(struct node) * n * 2);\n  for (i = 0; i < n; i++) scanf(\"%lf%lf%lf%lf\", &s[i][0].x, &s[i][0].y, &s[i][1].x, &s[i][1].y);\n  manhattan_intersection(n, s, ep, tree);\n  free(s);\n  free(ep);\n  free(tree);\n}\nvoid Find(struct node *tree, int lbound, int ubound, int loc)\n{\n  if (tree[loc].key >= lbound && tree[loc].key <= ubound) ans++;\n  if (tree[loc].left != NIL && tree[loc].key >= lbound) Find(tree, lbound, ubound, tree[loc].left);\n  if (tree[loc].right != NIL && tree[loc].key <= ubound) Find(tree, lbound, ubound, tree[loc].right);\n}\nvoid Insert(struct node *tree, int data)\n{\n  int parent = NIL, u = root;\n  while (u != NIL) {\n    parent = u;\n    if(tree[u].key == data) return;\n    else if (tree[u].key > data) {\n      u = tree[u].left;\n    }else {\n      u = tree[u].right;\n    }\n  }\n  tree[count].key = data;\n  tree[count].left = tree[count].right = NIL;\n  if (parent == NIL) {\n    root = count++;\n  } else if(tree[parent].key > data) {\n    tree[parent].left = count++;\n  } else {\n    tree[parent].right = count++;\n  }\n}\nvoid Delete(struct node *tree, int data)\n{\n  int u = root, del, parent = NIL;\n  while (u != NIL && tree[u].key != data) {\n    parent = u;\n    if (tree[u].key > data) {\n      u = tree[u].left;\n    } else {\n      u = tree[u].right;\n    }\n  }\n  if (u == NIL) return;\n  while (1){\n    if (tree[u].left == NIL) {\n      if (tree[parent].left == u) {\n        tree[parent].left = tree[u].right;\n        if (parent == NIL) root = tree[u].right;\n      }\n      else {\n        tree[parent].right = tree[u].right;\n        if (parent == NIL) root = tree[u].right;\n      }\n      break;\n    } else if (tree[u].right == NIL) {\n      if (tree[parent].left == u) {\n        tree[parent].left = tree[u].left;\n        if (parent == NIL) root = tree[u].left;\n      }\n      else {\n        tree[parent].right = tree[u].left;\n        if (parent == NIL) root = tree[u].left;\n      }\n      break;\n    } else {\n      int temp = tree[u].right;\n      parent = u;\n      while (tree[temp].left != NIL) {\n        parent = temp;\n        temp = tree[temp].left;\n      }\n      tree[u].key = tree[temp].key;\n      u = temp;\n    }\n  }\n}\nint compare(const void *a, const void *b)\n{\n  struct endpoint *ta = (struct endpoint*)a, *tb = (struct endpoint*)b;\n  if (ta->p.y > tb->p.y) return 1;\n  else if (ta->p.y < tb->p.y) return -1;\n  else {\n    if (ta->dir > tb->dir) return 1;\n    else return -1;\n  }\n  return 0;\n}\n\nvoid manhattan_intersection(int n, struct point (*s)[2], struct endpoint *ep, struct node *tree)\n{\n  int i, k = 0;\n  for (i = 0, k = 0; i < n; i++) {\n    if (s[i][0].y == s[i][1].y) {\n      if (s[i][0].x > s[i][1].x) {\n        struct point temp = s[i][0];\n        s[i][0] = s[i][1];\n        s[i][1] = temp;\n      }\n      ep[k].p = s[i][0];\n      ep[k].seg = i;\n      ep[k].dir = LEFT;\n      k++;\n      ep[k].p = s[i][1];\n      ep[k].seg = i;\n      ep[k].dir = RIGHT;\n      k++;\n    } else {\n      if (s[i][0].y > s[i][1].y) {\n        struct point temp = s[i][0];\n        s[i][0] = s[i][1];\n        s[i][1] = temp;\n      }\n      ep[k].p = s[i][0];\n      ep[k].seg = i;\n      ep[k].dir = BOTTOM;\n      k++;\n      ep[k].p = s[i][1];\n      ep[k].seg = i;\n      ep[k].dir = TOP;\n      k++;\n    }\n  }\n  qsort(ep, n * 2, sizeof(struct endpoint), compare);\n  //for (i = 0; i < 2 * n; i++) printf(\"%lf %lf %d\\n\", ep[i].p.x, ep[i].p.y, ep[i].dir);\n  for (i = 0; i < 2 * n; i++) {\n    if (ep[i].dir == TOP) Delete(tree, ep[i].p.x);\n    else if (ep[i].dir == BOTTOM) Insert(tree, ep[i].p.x);\n    else if (ep[i].dir == LEFT) {\n      if (s[ep[i].seg][0].x < s[ep[i].seg][1].x) {\n        Find(tree, s[ep[i].seg][0].x, s[ep[i].seg][1].x, root);\n        //printf(\"%d %d\\n\", ans, tree[root].key);\n      } else {\n        Find(tree, s[ep[i].seg][1].x, s[ep[i].seg][0].x, root);\n        //printf(\"%d %d\\n\", ans, tree[root].key);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n\n/////////////////////////////////////////////////////////////////\n// Red Black Tree\n/////////////////////////////////////////////////////////////////\n// totemo sankou nishita: http://algoogle.hadrori.jp/algorithm/rbtree.html\n\ntypedef int key_t;\n\ntypedef struct node {\n  key_t key;\n  int red;\n  struct node *par, *ch[2];\n} node_t;\n\ntypedef node_t* node_ptr;\n\nnode_ptr node_create(key_t key) {\n  node_ptr p = (node_ptr)malloc(sizeof(node_t));\n  p->key = key;\n  p->red = 1;\n  p->par = p->ch[0] = p->ch[1] = NULL;\n  return p;\n}\n\nunsigned rb_sz;\nnode_ptr rb_root, rb_nil;\n\nvoid rb_init(){ \n  rb_sz = 0;\n  rb_nil = node_create(-1);\n  rb_nil->key = -1;\n  rb_nil->red = 0;\n  rb_root = node_create(-1);\n\n  rb_root\n  = rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1]\n  = rb_nil;\n}\n\nunsigned rb_size() { return rb_sz; }\n\nvoid rb_print_node(node_ptr v, int depth, int lr) {\n  int i;\n\n  if(v == rb_nil)\n    return;\n\n  rb_print_node(v->ch[1], depth+1, 1);\n\n  for(i = 0; i < depth; i++)\n    printf(\"  \");\n\n  if(!lr)\n    printf(\"--\");\n  else if(lr == 1)\n    printf(\"???\");\n  else\n    printf(\"??¬\");\n\n  if(v->red)\n    printf(\"\\x1b[31m\");\n\n  printf(\"%d\\n\", v->key);\n  printf(\"\\x1b[0m\");\n  rb_print_node(v->ch[0], depth + 1, 2);\n}\n\nvoid rb_print(){\n  assert(rb_root);\n  rb_print_node(rb_root, 0, 0);\n}\n\nvoid rb_rotate(node_ptr x, int d) {\n  int e = d^1;\n  node_ptr y = x->ch[e];\n  x->ch[e] = y->ch[d];\n  if(y->ch[d] != rb_nil) y->ch[d]->par = x;\n  y->par = x->par;\n  if(x->par == rb_nil) rb_root = y;\n  else if(x == x->par->ch[d]) x->par->ch[d] = y;\n  else x->par->ch[e] = y;\n  y->ch[d] = x;\n  x->par = y;\n}\n\nnode_ptr rb_find(key_t key) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  return x;\n}\n\nvoid rb_insert_update(node_ptr z) {\n  node_ptr y;\n  int d, e;\n  while(z->par->red) {\n    d = z->par == z->par->par->ch[0] ? 0 : 1;\n    e = d^1;\n    y = z->par->par->ch[e];\n    if(y->red) {\n      z->par->red = 0;\n      y->red = 0;\n      z->par->par->red = 1;\n      z = z->par->par;\n    }\n    else if(z == z->par->ch[e]) {\n      z = z->par;\n      rb_rotate(z,d);\n    }\n    else {\n      z->par->red = 0;\n      z->par->par->red = 1;\n      rb_rotate(z->par->par,e);\n    }\n  }\n  rb_root->red = 0;\n}\n\nnode_ptr rb_insert(key_t key) {\n  node_ptr x = rb_root, y = rb_nil;\n  node_ptr z;\n  while(x != rb_nil) {\n    y = x;\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  rb_sz++;\n  z = node_create(key);\n  z->par = y;\n  if(y == rb_nil) rb_root = z;\n  else y->ch[z->key >= y->key] = z;\n  z->ch[0] = z->ch[1] = rb_nil;\n  rb_insert_update(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  return z;\n}\n\nvoid rb_transplant(node_ptr u, node_ptr v) {\n  if(u->par == rb_nil) rb_root = v;\n  else if(u == u->par->ch[0]) u->par->ch[0] = v;\n  else u->par->ch[1] = v;\n  v->par = u->par;\n}\n\nnode_ptr rb_minimum(node_ptr x) {\n  while(x->ch[0] != rb_nil) x = x->ch[0];\n  return x;\n}\n\nvoid rb_erase_update(node_ptr x) {\n  node_ptr w = rb_nil;\n  int d, e;\n  while(x != rb_root && !x->red) {\n    d = x == x->par->ch[0]? 0: 1, e = d^1;\n    w = x->par->ch[e];\n    if(w->red) {\n      w->red = 0;\n      x->par->red = 1;\n      rb_rotate(x->par,d);\n      w = x->par->ch[e];\n    }\n    else if(!w->ch[d]->red && !w->ch[e]->red) {\n      w->red = 1;\n      x = x->par;\n    }\n    else if(!w->ch[e]->red) {\n      w->ch[d]->red = 0;\n      w->red = 1;\n      rb_rotate(w,e);\n      w = x->par->ch[e];\n    }\n    else {\n      w->red = x->par->red;\n      x->par->red = 0;\n      w->ch[e]->red = 0;\n      rb_rotate(x->par,d);\n      x = rb_root;\n    }\n  }\n  x->red = 0;\n}\n\nvoid rb_erase_node(node_ptr z) {\n  node_ptr y, x;\n  int prevy;\n  if(z == rb_nil) return;\n  rb_sz--;\n  y = z;\n  prevy = y->red;\n  if(z->ch[0] == rb_nil) {\n    x = z->ch[1];\n    rb_transplant(z,z->ch[1]);\n  }\n  else if(z->ch[1] == rb_nil) {\n    x = z->ch[0];\n    rb_transplant(z,z->ch[0]);\n  }\n  else {\n    y = rb_minimum(z->ch[1]);\n    prevy = y->red;\n    x = y->ch[1];\n    if(y->par == z) x->par = y;\n    else {\n      rb_transplant(y,y->ch[1]);\n      y->ch[1] = z->ch[1];\n      y->ch[1]->par = y;\n    }\n    rb_transplant(z,y);\n    y->ch[0] = z->ch[0];\n    y->ch[0]->par = y;\n    y->red = z->red;\n  }\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  if(!prevy) rb_erase_update(x);\n  free(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n}\n\nvoid rb_erase(key_t key) {\n  rb_erase_node(rb_find(key));\n}\n\nnode_ptr rb_successor(node_ptr x) {\n  node_ptr y;\n  if(x->ch[1] != rb_nil)\n    return rb_minimum(x->ch[1]);\n  y = x->par;\n  while(y != rb_nil && x == y->ch[1]) {\n    x = y;\n    y = y->par;\n  }\n  return y;\n}\n\nnode_ptr rb_binary_search(key_t key, int upper_bound) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) {\n      if(x->ch[key > x->key] == rb_nil) {\n        if(key > x->key)\n          return rb_successor(x);\n        else return x;\n      }\n      else {\n        x = x->ch[key > x->key];\n      }\n    }\n    else return upper_bound ? rb_successor(x) : x;\n  }\n  return x;\n}\n\nnode_ptr rb_lower_bound(key_t key) {\n  return rb_binary_search(key, 0);\n}\n\nnode_ptr rb_upper_bound(key_t key) {\n  return rb_binary_search(key, 1);\n}\n\n/////////////////////////////////////////////////////////////////\n// End of Red Black Tree\n/////////////////////////////////////////////////////////////////\n\nenum {\n  VTop = 0,\n  HLeft = 1,\n  VBottom = 2\n};\n  \ntypedef struct P_ {\n  int x, y;\n  int type;\n  int oppo_x;\n} P;\n\nint max(int x, int y) {\n  return x < y ? y : x;\n}\n\nint min(int x, int y) {\n  return x < y ? x : y;\n}\n\nint compare_P(const void *a_, const void *b_) {\n  const P *a = (const P *)a_;\n  const P *b = (const P *)b_;\n  if(a->y != b->y) return a->y - b->y;\n  if(a->type != b->type) return a->type - b->type;\n  return a->x - b->x;\n}\nstruct Line { P ps[2]; };\n\nvoid swap(int* a, int* b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nvoid shuffle(P ary[],int size) {\n  int i;\n  for(i=0;i<size;i++) {\n    int j = rand()%size;\n    P t = ary[i];\n    ary[i] = ary[j];\n    ary[j] = t;\n  }\n}\n\nint main() {\n  \n  #if 0\n  /*\n    Red-black tree test code\n  */\n  int i;\n  rb_init();\n  srand((unsigned)(time(NULL)));\n  for(i=0; i<100; i++)\n    rb_insert(rand());\n  rb_print();\n\n  printf(\"minimum: %d\\n\", rb_minimum(rb_root)->key);\n\n  while(~scanf(\"%d\", &i)) {\n    printf(\"lower_bound(%d): %d\\n\", i, rb_lower_bound(i)->key);\n    printf(\"upper_bound(%d): %d\\n\", i, rb_upper_bound(i)->key);\n    printf(\"successor(lower_bound(%d)): %d\\n\", i, rb_successor(rb_lower_bound(i))->key);\n//    rb_erase(i);\n//    rb_print();\n//    printf(\"deleted: %d\\n\", i);\n  }\n\n  return 0;\n}\n  #else\n\n  int N;\n  P pts[100001];\n  int pcnt = 0;\n  int x1, y1, x2, y2;\n  int type1, type2;\n  int ret;\n  int cnt;\n  int i;\n  node_ptr iter1 = NULL, iter2 = NULL;\n\n  scanf(\"%d\", &N);\n  for(i = 0; i < N; i++) {\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    if(x1 > x2) swap(&x1, &x2);\n    if(y1 > y2) swap(&y1, &y2);\n    if(x1 == x2) {\n      type1 = VTop, type2 = VBottom;\n      pts[pcnt++] = (P){x1, y1, type1, -1};\n      pts[pcnt++] = (P){x2, y2, type2, -1};\n    }\n    else {\n      type1 = HLeft;\n      pts[pcnt++] = (P){x1, y1, type1, x2};\n    }\n  }\n\n  shuffle(pts, pcnt);\n  qsort(pts, pcnt, sizeof(P), (int (*)(const void *, const void *))compare_P);\n\n  ret = 0;\n  rb_init();\n\n  for(i = 0; i < pcnt; i++) {\n    if(pts[i].type == VTop) {\n      rb_insert(pts[i].x);\n    }\n    if(pts[i].type == VBottom) {\n      rb_erase(pts[i].x);\n    }\n    if(pts[i].type == HLeft) {\n      x1 = pts[i].x, x2 = pts[i].oppo_x;\n      iter1 = rb_lower_bound(x1);\n      iter2 = rb_upper_bound(x2);\n \n      cnt = 0;\n      while(iter1 != iter2) {\n        iter1 = rb_successor(iter1); cnt++;\n      }\n      ret += cnt;\n    }\n  }\n    \n  printf(\"%d\\n\", ret);\n    \n  return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n\n/////////////////////////////////////////////////////////////////\n// Red Black Tree\n/////////////////////////////////////////////////////////////////\n// totemo sankou nishita: http://algoogle.hadrori.jp/algorithm/rbtree.html\n\ntypedef int key_t;\n\ntypedef struct node {\n  key_t key;\n  int red;\n  struct node *par, *ch[2];\n} node_t;\n\ntypedef node_t* node_ptr;\n\nnode_ptr node_create(key_t key) {\n  node_ptr p = (node_ptr)malloc(sizeof(node_t));\n  p->key = key;\n  p->red = 1;\n  p->par = p->ch[0] = p->ch[1] = NULL;\n  return p;\n}\n\nunsigned rb_sz;\nnode_ptr rb_root, rb_nil;\n\nvoid rb_init(){ \n  rb_sz = 0;\n  rb_nil = node_create(-1);\n  rb_nil->key = -1;\n  rb_nil->red = 0;\n  rb_root = node_create(-1);\n\n  rb_root\n  = rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1]\n  = rb_nil;\n}\n\nunsigned rb_size() { return rb_sz; }\n\nvoid rb_print_node(node_ptr v, int depth, int lr) {\n  int i;\n\n  if(v == rb_nil)\n    return;\n\n  rb_print_node(v->ch[1], depth+1, 1);\n\n  for(i = 0; i < depth; i++)\n    printf(\"  \");\n\n  if(!lr)\n    printf(\"--\");\n  else if(lr == 1)\n    printf(\"???\");\n  else\n    printf(\"??¬\");\n\n  if(v->red)\n    printf(\"\\x1b[31m\");\n\n  printf(\"%d\\n\", v->key);\n  printf(\"\\x1b[0m\");\n  rb_print_node(v->ch[0], depth + 1, 2);\n}\n\nvoid rb_print(){\n  assert(rb_root);\n  rb_print_node(rb_root, 0, 0);\n}\n\nvoid rb_rotate(node_ptr x, int d) {\n  int e = d^1;\n  node_ptr y = x->ch[e];\n  x->ch[e] = y->ch[d];\n  if(y->ch[d] != rb_nil) y->ch[d]->par = x;\n  y->par = x->par;\n  if(x->par == rb_nil) rb_root = y;\n  else if(x == x->par->ch[d]) x->par->ch[d] = y;\n  else x->par->ch[e] = y;\n  y->ch[d] = x;\n  x->par = y;\n}\n\nnode_ptr rb_find(key_t key) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  return x;\n}\n\nvoid rb_insert_update(node_ptr z) {\n  node_ptr y;\n  int d, e;\n  while(z->par->red) {\n    d = z->par == z->par->par->ch[0] ? 0 : 1;\n    e = d^1;\n    y = z->par->par->ch[e];\n    if(y->red) {\n      z->par->red = 0;\n      y->red = 0;\n      z->par->par->red = 1;\n      z = z->par->par;\n    }\n    else if(z == z->par->ch[e]) {\n      z = z->par;\n      rb_rotate(z,d);\n    }\n    else {\n      z->par->red = 0;\n      z->par->par->red = 1;\n      rb_rotate(z->par->par,e);\n    }\n  }\n  rb_root->red = 0;\n}\n\nnode_ptr rb_insert(key_t key) {\n  node_ptr x = rb_root, y = rb_nil;\n  node_ptr z;\n  while(x != rb_nil) {\n    y = x;\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  rb_sz++;\n  z = node_create(key);\n  z->par = y;\n  if(y == rb_nil) rb_root = z;\n  else y->ch[z->key >= y->key] = z;\n  z->ch[0] = z->ch[1] = rb_nil;\n  rb_insert_update(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  return z;\n}\n\nvoid rb_transplant(node_ptr u, node_ptr v) {\n  if(u->par == rb_nil) rb_root = v;\n  else if(u == u->par->ch[0]) u->par->ch[0] = v;\n  else u->par->ch[1] = v;\n  v->par = u->par;\n}\n\nnode_ptr rb_minimum(node_ptr x) {\n  while(x->ch[0] != rb_nil) x = x->ch[0];\n  return x;\n}\n\nvoid rb_erase_update(node_ptr x) {\n  node_ptr w = rb_nil;\n  int d, e;\n  while(x != rb_root && !x->red) {\n    d = x == x->par->ch[0]? 0: 1, e = d^1;\n    w = x->par->ch[e];\n    if(w->red) {\n      w->red = 0;\n      x->par->red = 1;\n      rb_rotate(x->par,d);\n      w = x->par->ch[e];\n    }\n    else if(!w->ch[d]->red && !w->ch[e]->red) {\n      w->red = 1;\n      x = x->par;\n    }\n    else if(!w->ch[e]->red) {\n      w->ch[d]->red = 0;\n      w->red = 1;\n      rb_rotate(w,e);\n      w = x->par->ch[e];\n    }\n    else {\n      w->red = x->par->red;\n      x->par->red = 0;\n      w->ch[e]->red = 0;\n      rb_rotate(x->par,d);\n      x = rb_root;\n    }\n  }\n  x->red = 0;\n}\n\nvoid rb_erase_node(node_ptr z) {\n  node_ptr y, x;\n  int prevy;\n  if(z == rb_nil) return;\n  rb_sz--;\n  y = z;\n  prevy = y->red;\n  if(z->ch[0] == rb_nil) {\n    x = z->ch[1];\n    rb_transplant(z,z->ch[1]);\n  }\n  else if(z->ch[1] == rb_nil) {\n    x = z->ch[0];\n    rb_transplant(z,z->ch[0]);\n  }\n  else {\n    y = rb_minimum(z->ch[1]);\n    prevy = y->red;\n    x = y->ch[1];\n    if(y->par == z) x->par = y;\n    else {\n      rb_transplant(y,y->ch[1]);\n      y->ch[1] = z->ch[1];\n      y->ch[1]->par = y;\n    }\n    rb_transplant(z,y);\n    y->ch[0] = z->ch[0];\n    y->ch[0]->par = y;\n    y->red = z->red;\n  }\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  if(!prevy) rb_erase_update(x);\n  free(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n}\n\nvoid rb_erase(key_t key) {\n  rb_erase_node(rb_find(key));\n}\n\nnode_ptr rb_successor(node_ptr x) {\n  node_ptr y;\n  if(x->ch[1] != rb_nil)\n    return rb_minimum(x->ch[1]);\n  y = x->par;\n  while(y != rb_nil && x == y->ch[1]) {\n    x = y;\n    y = y->par;\n  }\n  return y;\n}\n\nnode_ptr rb_binary_search(key_t key, int upper_bound) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) {\n      if(x->ch[key > x->key] == rb_nil) {\n        if(key > x->key)\n          return rb_successor(x);\n        else return x;\n      }\n      else {\n        x = x->ch[key > x->key];\n      }\n    }\n    else return upper_bound ? rb_successor(x) : x;\n  }\n  return x;\n}\n\nnode_ptr rb_lower_bound(key_t key) {\n  return rb_binary_search(key, 0);\n}\n\nnode_ptr rb_upper_bound(key_t key) {\n  return rb_binary_search(key, 1);\n}\n\n/////////////////////////////////////////////////////////////////\n// End of Red Black Tree\n/////////////////////////////////////////////////////////////////\n\nenum {\n  VTop = 0,\n  HLeft = 1,\n  VBottom = 2\n};\n  \ntypedef struct P_ {\n  int x, y;\n  int type;\n  int oppo_x;\n} P;\n\nint max(int x, int y) {\n  return x < y ? y : x;\n}\n\nint min(int x, int y) {\n  return x < y ? x : y;\n}\n\nint compare_P(const void *a_, const void *b_) {\n  const P *a = (const P *)a_;\n  const P *b = (const P *)b_;\n  if(a->y != b->y) return a->y - b->y;\n  if(a->type != b->type) return a->type - b->type;\n  return a->x - b->x;\n}\nstruct Line { P ps[2]; };\n\nvoid swap(int* a, int* b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint main() {\n  \n  #if 0\n  /*\n    Red-black tree test code\n  */\n  int i;\n  rb_init();\n  srand((unsigned)(time(NULL)));\n  for(i=0; i<100; i++)\n    rb_insert(rand());\n  rb_print();\n\n  printf(\"minimum: %d\\n\", rb_minimum(rb_root)->key);\n\n  while(~scanf(\"%d\", &i)) {\n    printf(\"lower_bound(%d): %d\\n\", i, rb_lower_bound(i)->key);\n    printf(\"upper_bound(%d): %d\\n\", i, rb_upper_bound(i)->key);\n    printf(\"successor(lower_bound(%d)): %d\\n\", i, rb_successor(rb_lower_bound(i))->key);\n//    rb_erase(i);\n//    rb_print();\n//    printf(\"deleted: %d\\n\", i);\n  }\n\n  return 0;\n}\n  #else\n\n  int N;\n  P pts[100001];\n  int pcnt = 0;\n  int x1, y1, x2, y2;\n  int type1, type2;\n  int ret;\n  int cnt;\n  int i;\n  node_ptr iter1 = NULL, iter2 = NULL;\n\n  scanf(\"%d\", &N);\n  for(i = 0; i < N; i++) {\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    if(x1 > x2) swap(&x1, &x2);\n    if(y1 > y2) swap(&y1, &y2);\n    if(x1 == x2) {\n      type1 = VTop, type2 = VBottom;\n      pts[pcnt++] = (P){x1, y1, type1, -1};\n      pts[pcnt++] = (P){x2, y2, type2, -1};\n    }\n    else {\n      type1 = HLeft;\n      pts[pcnt++] = (P){x1, y1, type1, x2};\n    }\n  }\n\n  qsort(pts, pcnt, sizeof(P), (int (*)(const void *, const void *))compare_P);\n\n  ret = 0;\n  rb_init();\n\n  for(i = 0; i < pcnt; i++) {\n    if(pts[i].type == VTop) {\n      rb_insert(pts[i].x);\n    }\n    if(pts[i].type == VBottom) {\n      rb_erase(pts[i].x);\n    }\n    if(pts[i].type == HLeft) {\n      x1 = pts[i].x, x2 = pts[i].oppo_x;\n      iter1 = rb_lower_bound(x1);\n      iter2 = rb_upper_bound(x2);\n \n      cnt = 0;\n      while(iter1 != iter2) {\n        iter1 = rb_successor(iter1); cnt++;\n      }\n      ret += cnt;\n    }\n  }\n    \n  printf(\"%d\\n\", ret);\n    \n  return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define NIL 0\nenum direction {\n  BOTTOM,\n  LEFT,\n  RIGHT,\n  TOP\n};\nstruct point {\n  double x;\n  double y;\n};\nstruct endpoint {\n  struct point p;\n  int seg;\n  enum direction dir;\n};\nstruct node {\n  int left;\n  int right;\n  int key;\n};\nint count = 1, ans, root = NIL;\nvoid Find(struct node *tree, int, int, int);\nvoid Insert(struct node *tree, int);\nvoid Delete(struct node *tree, int);\nint compare(const void *a, const void *b);\nvoid manhattan_intersection(int n, struct point (*s)[2], struct endpoint *ep, struct node *tree);\nint main (void) {\n  int i, n;\n  struct point (*s)[2];\n  struct endpoint *ep;\n  struct node *tree;\n  scanf(\"%d\", &n);\n  s = (struct point (*)[2])malloc(sizeof(struct point) * n * 2);\n  ep = (struct endpoint*)malloc(sizeof(struct endpoint) * n * 2);\n  tree = (struct node*)malloc(sizeof(struct node) * n * 2);\n  for (i = 0; i < n; i++) scanf(\"%lf%lf%lf%lf\", &s[i][0].x, &s[i][0].y, &s[i][1].x, &s[i][1].y);\n  manhattan_intersection(n, s, ep, tree);\n  free(s);\n  free(ep);\n  free(tree);\n}\nvoid Find(struct node *tree, int lbound, int ubound, int loc)\n{\n  if (loc != NIL) {\n    if (tree[loc].key >= lbound && tree[loc].key <= ubound) ans++;\n    if (tree[loc].key >= lbound) Find(tree, lbound, ubound, tree[loc].left);\n    if (tree[loc].key <= ubound) Find(tree, lbound, ubound, tree[loc].right);\n  }\n}\nvoid Insert(struct node *tree, int data)\n{\n  int parent = NIL, u = root;\n  while (u != NIL) {\n    parent = u;\n    if(tree[u].key == data) return;\n    else if (tree[u].key > data) {\n      u = tree[u].left;\n    }else {\n      u = tree[u].right;\n    }\n  }\n  tree[count].key = data;\n  tree[count].left = tree[count].right = NIL;\n  if (parent == NIL) {\n    root = count++;\n  } else if(tree[parent].key > data) {\n    tree[parent].left = count++;\n  } else {\n    tree[parent].right = count++;\n  }\n}\nvoid Delete(struct node *tree, int data)\n{\n  int u = root, del, parent = NIL;\n  while (u != NIL && tree[u].key != data) {\n    parent = u;\n    if (tree[u].key > data) {\n      u = tree[u].left;\n    } else {\n      u = tree[u].right;\n    }\n  }\n  if (u == NIL) return;\n  while (1){\n    if (tree[u].left == NIL) {\n      if (tree[parent].left == u) {\n        tree[parent].left = tree[u].right;\n        if (parent == NIL) root = tree[u].right;\n      }\n      else {\n        tree[parent].right = tree[u].right;\n        if (parent == NIL) root = tree[u].right;\n      }\n      break;\n    } else if (tree[u].right == NIL) {\n      if (tree[parent].left == u) {\n        tree[parent].left = tree[u].left;\n        if (parent == NIL) root = tree[u].left;\n      }\n      else {\n        tree[parent].right = tree[u].left;\n        if (parent == NIL) root = tree[u].left;\n      }\n      break;\n    } else {\n      int temp = tree[u].right;\n      parent = u;\n      while (tree[temp].left != NIL) {\n        parent = temp;\n        temp = tree[temp].left;\n      }\n      tree[u].key = tree[temp].key;\n      u = temp;\n    }\n  }\n}\nint compare(const void *a, const void *b)\n{\n  struct endpoint *ta = (struct endpoint*)a, *tb = (struct endpoint*)b;\n  if (ta->p.y > tb->p.y) return 1;\n  else if (ta->p.y < tb->p.y) return -1;\n  else {\n    if (ta->dir > tb->dir) return 1;\n    else return -1;\n  }\n  return 0;\n}\n\nvoid manhattan_intersection(int n, struct point (*s)[2], struct endpoint *ep, struct node *tree)\n{\n  int i, k = 0;\n  for (i = 0, k = 0; i < n; i++) {\n    if (s[i][0].y == s[i][1].y) {\n      if (s[i][0].x > s[i][1].x) {\n        struct point temp = s[i][0];\n        s[i][0] = s[i][1];\n        s[i][1] = temp;\n      }\n      ep[k].p = s[i][0];\n      ep[k].seg = i;\n      ep[k].dir = LEFT;\n      k++;\n      ep[k].p = s[i][1];\n      ep[k].seg = i;\n      ep[k].dir = RIGHT;\n      k++;\n    } else {\n      if (s[i][0].y > s[i][1].y) {\n        struct point temp = s[i][0];\n        s[i][0] = s[i][1];\n        s[i][1] = temp;\n      }\n      ep[k].p = s[i][0];\n      ep[k].seg = i;\n      ep[k].dir = BOTTOM;\n      k++;\n      ep[k].p = s[i][1];\n      ep[k].seg = i;\n      ep[k].dir = TOP;\n      k++;\n    }\n  }\n  qsort(ep, n * 2, sizeof(struct endpoint), compare);\n  //for (i = 0; i < 2 * n; i++) printf(\"%lf %lf %d\\n\", ep[i].p.x, ep[i].p.y, ep[i].dir);\n  for (i = 0; i < 2 * n; i++) {\n    if (ep[i].dir == TOP) Delete(tree, ep[i].p.x);\n    else if (ep[i].dir == BOTTOM) Insert(tree, ep[i].p.x);\n    else if (ep[i].dir == LEFT) {\n      if (s[ep[i].seg][0].x < s[ep[i].seg][1].x) {\n        Find(tree, s[ep[i].seg][0].x, s[ep[i].seg][1].x, root);\n        //printf(\"%d %d\\n\", ans, tree[root].key);\n      } else {\n        Find(tree, s[ep[i].seg][1].x, s[ep[i].seg][0].x, root);\n        //printf(\"%d %d\\n\", ans, tree[root].key);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n\n/////////////////////////////////////////////////////////////////\n// Red Black Tree\n/////////////////////////////////////////////////////////////////\n// totemo sankou nishita: http://algoogle.hadrori.jp/algorithm/rbtree.html\n\ntypedef int key_t;\n\ntypedef struct node {\n  key_t key;\n  int red;\n  struct node *par, *ch[2];\n} node_t;\n\ntypedef node_t* node_ptr;\n\nnode_ptr node_create(key_t key) {\n  node_ptr p = (node_ptr)malloc(sizeof(node_t));\n  p->key = key;\n  p->red = 1;\n  p->par = p->ch[0] = p->ch[1] = NULL;\n  return p;\n}\n\nunsigned rb_sz;\nnode_ptr rb_root, rb_nil;\n\nvoid rb_init(){ \n  rb_sz = 0;\n  rb_nil = node_create(-1);\n  rb_nil->key = -1;\n  rb_nil->red = 0;\n  rb_root = node_create(-1);\n\n  rb_root\n  = rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1]\n  = rb_nil;\n}\n\nunsigned rb_size() { return rb_sz; }\n\nvoid rb_print_node(node_ptr v, int depth, int lr) {\n  int i;\n\n  if(v == rb_nil)\n    return;\n\n  rb_print_node(v->ch[1], depth+1, 1);\n\n  for(i = 0; i < depth; i++)\n    printf(\"  \");\n\n  if(!lr)\n    printf(\"--\");\n  else if(lr == 1)\n    printf(\"???\");\n  else\n    printf(\"??¬\");\n\n  if(v->red)\n    printf(\"\\x1b[31m\");\n\n  printf(\"%d\\n\", v->key);\n  printf(\"\\x1b[0m\");\n  rb_print_node(v->ch[0], depth + 1, 2);\n}\n\nvoid rb_print(){\n  assert(rb_root);\n  rb_print_node(rb_root, 0, 0);\n}\n\nvoid rb_rotate(node_ptr x, int d) {\n  int e = d^1;\n  node_ptr y = x->ch[e];\n  x->ch[e] = y->ch[d];\n  if(y->ch[d] != rb_nil) y->ch[d]->par = x;\n  y->par = x->par;\n  if(x->par == rb_nil) rb_root = y;\n  else if(x == x->par->ch[d]) x->par->ch[d] = y;\n  else x->par->ch[e] = y;\n  y->ch[d] = x;\n  x->par = y;\n}\n\nnode_ptr rb_find(key_t key) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  return x;\n}\n\nvoid rb_insert_update(node_ptr z) {\n  node_ptr y;\n  int d, e;\n  while(z->par->red) {\n    d = z->par == z->par->par->ch[0] ? 0 : 1;\n    e = d^1;\n    y = z->par->par->ch[e];\n    if(y->red) {\n      z->par->red = 0;\n      y->red = 0;\n      z->par->par->red = 1;\n      z = z->par->par;\n    }\n    else if(z == z->par->ch[e]) {\n      z = z->par;\n      rb_rotate(z,d);\n    }\n    else {\n      z->par->red = 0;\n      z->par->par->red = 1;\n      rb_rotate(z->par->par,e);\n    }\n  }\n  rb_root->red = 0;\n}\n\nnode_ptr rb_insert(key_t key) {\n  node_ptr x = rb_root, y = rb_nil;\n  node_ptr z;\n  while(x != rb_nil) {\n    y = x;\n    if(key != x->key) x = x->ch[key > x->key];\n    else return x;\n  }\n  rb_sz++;\n  z = node_create(key);\n  z->par = y;\n  if(y == rb_nil) rb_root = z;\n  else y->ch[z->key >= y->key] = z;\n  z->ch[0] = z->ch[1] = rb_nil;\n  rb_insert_update(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  return z;\n}\n\nvoid rb_transplant(node_ptr u, node_ptr v) {\n  if(u->par == rb_nil) rb_root = v;\n  else if(u == u->par->ch[0]) u->par->ch[0] = v;\n  else u->par->ch[1] = v;\n  v->par = u->par;\n}\n\nnode_ptr rb_minimum(node_ptr x) {\n  while(x->ch[0] != rb_nil) x = x->ch[0];\n  return x;\n}\n\nvoid rb_erase_update(node_ptr x) {\n  node_ptr w = rb_nil;\n  int d, e;\n  while(x != rb_root && !x->red) {\n    d = x == x->par->ch[0]? 0: 1, e = d^1;\n    w = x->par->ch[e];\n    if(w->red) {\n      w->red = 0;\n      x->par->red = 1;\n      rb_rotate(x->par,d);\n      w = x->par->ch[e];\n    }\n    else if(!w->ch[d]->red && !w->ch[e]->red) {\n      w->red = 1;\n      x = x->par;\n    }\n    else if(!w->ch[e]->red) {\n      w->ch[d]->red = 0;\n      w->red = 1;\n      rb_rotate(w,e);\n      w = x->par->ch[e];\n    }\n    else {\n      w->red = x->par->red;\n      x->par->red = 0;\n      w->ch[e]->red = 0;\n      rb_rotate(x->par,d);\n      x = rb_root;\n    }\n  }\n  x->red = 0;\n}\n\nvoid rb_erase_node(node_ptr z) {\n  node_ptr y, x;\n  int prevy;\n  if(z == rb_nil) return;\n  rb_sz--;\n  y = z;\n  prevy = y->red;\n  if(z->ch[0] == rb_nil) {\n    x = z->ch[1];\n    rb_transplant(z,z->ch[1]);\n  }\n  else if(z->ch[1] == rb_nil) {\n    x = z->ch[0];\n    rb_transplant(z,z->ch[0]);\n  }\n  else {\n    y = rb_minimum(z->ch[1]);\n    prevy = y->red;\n    x = y->ch[1];\n    if(y->par == z) x->par = y;\n    else {\n      rb_transplant(y,y->ch[1]);\n      y->ch[1] = z->ch[1];\n      y->ch[1]->par = y;\n    }\n    rb_transplant(z,y);\n    y->ch[0] = z->ch[0];\n    y->ch[0]->par = y;\n    y->red = z->red;\n  }\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n  if(!prevy) rb_erase_update(x);\n  free(z);\n  rb_nil->par = rb_nil->ch[0] = rb_nil->ch[1] = rb_nil;\n}\n\nvoid rb_erase(key_t key) {\n  rb_erase_node(rb_find(key));\n}\n\nnode_ptr rb_successor(node_ptr x) {\n  node_ptr y;\n  if(x->ch[1] != rb_nil)\n    return rb_minimum(x->ch[1]);\n  y = x->par;\n  while(y != rb_nil && x == y->ch[1]) {\n    x = y;\n    y = y->par;\n  }\n  return y;\n}\n\nnode_ptr rb_binary_search(key_t key, int upper_bound) {\n  node_ptr x = rb_root;\n  while(x != rb_nil) {\n    if(key != x->key) {\n      if(x->ch[key > x->key] == rb_nil) {\n        if(key > x->key)\n          return rb_successor(x);\n        else return x;\n      }\n      else {\n        x = x->ch[key > x->key];\n      }\n    }\n    else return upper_bound ? rb_successor(x) : x;\n  }\n  return x;\n}\n\nnode_ptr rb_lower_bound(key_t key) {\n  return rb_binary_search(key, 0);\n}\n\nnode_ptr rb_upper_bound(key_t key) {\n  return rb_binary_search(key, 1);\n}\n\n/////////////////////////////////////////////////////////////////\n// End of Red Black Tree\n/////////////////////////////////////////////////////////////////\n\nenum {\n  VTop = 0,\n  HLeft = 1,\n  VBottom = 2\n};\n  \ntypedef struct P_ {\n  int x, y;\n  int type;\n  int oppo_x;\n} P;\n\nint max(int x, int y) {\n  return x < y ? y : x;\n}\n\nint min(int x, int y) {\n  return x < y ? x : y;\n}\n\nint compare_P(const void *a_, const void *b_) {\n  const P *a = (const P *)a_;\n  const P *b = (const P *)b_;\n  if(a->y != b->y) return a->y - b->y;\n  if(a->type != b->type) return a->type - b->type;\n  return a->x - b->x;\n}\nstruct Line { P ps[2]; };\n\nvoid swap(int* a, int* b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nvoid shuffle(P ary[],int size)\n{\n    for(int i=0;i<size;i++)\n    {\n        int j = rand()%size;\n        P t = ary[i];\n        ary[i] = ary[j];\n        ary[j] = t;\n    }\n}\n\nint main() {\n  \n  #if 0\n  /*\n    Red-black tree test code\n  */\n  int i;\n  rb_init();\n  srand((unsigned)(time(NULL)));\n  for(i=0; i<100; i++)\n    rb_insert(rand());\n  rb_print();\n\n  printf(\"minimum: %d\\n\", rb_minimum(rb_root)->key);\n\n  while(~scanf(\"%d\", &i)) {\n    printf(\"lower_bound(%d): %d\\n\", i, rb_lower_bound(i)->key);\n    printf(\"upper_bound(%d): %d\\n\", i, rb_upper_bound(i)->key);\n    printf(\"successor(lower_bound(%d)): %d\\n\", i, rb_successor(rb_lower_bound(i))->key);\n//    rb_erase(i);\n//    rb_print();\n//    printf(\"deleted: %d\\n\", i);\n  }\n\n  return 0;\n}\n  #else\n\n  int N;\n  P pts[100001];\n  int pcnt = 0;\n  int x1, y1, x2, y2;\n  int type1, type2;\n  int ret;\n  int cnt;\n  int i;\n  node_ptr iter1 = NULL, iter2 = NULL;\n\n  scanf(\"%d\", &N);\n  for(i = 0; i < N; i++) {\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    if(x1 > x2) swap(&x1, &x2);\n    if(y1 > y2) swap(&y1, &y2);\n    if(x1 == x2) {\n      type1 = VTop, type2 = VBottom;\n      pts[pcnt++] = (P){x1, y1, type1, -1};\n      pts[pcnt++] = (P){x2, y2, type2, -1};\n    }\n    else {\n      type1 = HLeft;\n      pts[pcnt++] = (P){x1, y1, type1, x2};\n    }\n  }\n\n  shuffle(pts, pcnt);\n  qsort(pts, pcnt, sizeof(P), (int (*)(const void *, const void *))compare_P);\n\n  ret = 0;\n  rb_init();\n\n  for(i = 0; i < pcnt; i++) {\n    if(pts[i].type == VTop) {\n      rb_insert(pts[i].x);\n    }\n    if(pts[i].type == VBottom) {\n      rb_erase(pts[i].x);\n    }\n    if(pts[i].type == HLeft) {\n      x1 = pts[i].x, x2 = pts[i].oppo_x;\n      iter1 = rb_lower_bound(x1);\n      iter2 = rb_upper_bound(x2);\n \n      cnt = 0;\n      while(iter1 != iter2) {\n        iter1 = rb_successor(iter1); cnt++;\n      }\n      ret += cnt;\n    }\n  }\n    \n  printf(\"%d\\n\", ret);\n    \n  return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define SENTINEL (1 << 30)\n\ntypedef enum { BOTTOM, LEFT, RIGHT, TOP, UNKNOWN } end_point_t;\ntypedef enum { VERTICAL, HORIZONTAL, DIAGONAL } slope_t;\ntypedef struct { int x, y, pair_x; end_point_t t; } point_t;\ntypedef struct { point_t p0, p1; } segment_t;\ntypedef struct Node { int x; struct Node *p, *l, *r; } node_t;\n\nstatic segment_t swap_point(segment_t s) {\n  point_t tmp;\n\n  tmp = s.p0;\n  s.p0 = s.p1;\n  s.p1 = tmp;\n  return s;\n}\n\nstatic segment_t normalize(segment_t s) {\n  if (s.p0.x == s.p1.x) {\n    if (s.p0.y > s.p1.y) s = swap_point(s);\n    s.p0.t = BOTTOM;\n    s.p1.t = TOP;\n  } else if (s.p0.y == s.p1.y) {\n    if (s.p0.x > s.p1.x) s = swap_point(s);\n    s.p0.t = LEFT;\n    s.p1.t = RIGHT;\n  } else {\n    s.p0.t = s.p1.t = UNKNOWN;\n  }\n  s.p0.pair_x = s.p1.x;\n  s.p1.pair_x = s.p0.x;\n  return s;\n}\n\nstatic void merge(point_t *a, int left, int mid, int right) {\n  int n1, n2, i, j, k;\n  point_t *l, *r;\n\n  n1 = mid - left;\n  l = (point_t *) malloc(sizeof(point_t) * (n1 + 1));\n  for (i = 0; i < n1; ++i) l[i] = a[left + i];\n  l[i].x = l[i].y = SENTINEL;\n\n  n2 = right - mid;\n  r = (point_t *) malloc(sizeof(point_t) * (n2 + 1));\n  for (i = 0; i < n2; ++i) r[i] = a[mid + i];\n  r[i].x = r[i].y = SENTINEL;\n\n  for (i = j = 0, k = left; k < right; ++k) {\n    if (l[i].y < r[j].y || (l[i].y == r[j].y && l[i].t < r[j].t)) {\n      a[k] = l[i++];\n    } else {\n      a[k] = r[j++];\n    }\n  }\n  free(l);\n  free(r);\n}\n\nstatic void merge_sort(point_t *a, int left, int right) {\n  int mid;\n\n  if (left >= right - 1) return;\n  mid = (left + right) / 2;\n  merge_sort(a, left, mid);\n  merge_sort(a, mid, right);\n  merge(a, left, mid, right);\n}\n\nstatic node_t *new_node(int x) {\n  node_t *n;\n\n  n = (node_t *) malloc(sizeof(node_t));\n  n->p = n->l = n->r = NULL;\n  n->x = x;\n  return n;\n}\n\nstatic void insert_node(node_t *r, node_t *n) {\n  if (n->x <= r->x) {\n    if (r->l == NULL) {\n      r->l = n;\n      n->p = r;\n    } else {\n      insert_node(r->l, n);\n    }\n  } else {\n    if (r->r == NULL) {\n      r->r = n;\n      n->p = r;\n    } else {\n      insert_node(r->r, n);\n    }\n  }\n}\n\nstatic node_t *find_node(node_t *n, int x) {\n  node_t *ret;\n\n  if (n == NULL) {\n    ret = NULL;\n  } else if (x == n->x) {\n    ret = n;\n  } else if (n->l != NULL && x < n->x) {\n    ret = find_node(n->l, x);\n  } else if (n->r != NULL && x > n->x) {\n    ret = find_node(n->r, x);\n  } else {\n    ret = NULL;\n  }\n  return ret;\n}\n\nstatic node_t *find_successor(node_t *n) {\n  node_t *p;\n\n  if (n->r != NULL) {\n    n = n->r;\n    while (n->l != NULL) n = n->l;\n    return n;\n  }\n\n  p = n->p;\n  while (p != NULL && n == p->r) {\n    n = p;\n    p = p->p;\n  }\n  return p;\n}\n\nstatic node_t *delete_node(node_t *r, node_t *n) {\n  node_t *dn, *cn, *rn;\n\n  if (n == NULL) return r;\n  dn = (n->l == NULL || n->r == NULL) ? n : find_successor(n);\n  cn = (dn->l != NULL) ? dn->l : dn->r;\n  if (cn != NULL) cn->p = dn->p;\n  rn = r;\n  if (dn->p == NULL) {\n    rn = cn;\n  } else if (dn == dn->p->l) {\n    dn->p->l = cn;\n  } else {\n    dn->p->r = cn;\n  }\n  if (dn != n) n->x = dn->x;\n  free(dn);\n  dn = NULL;\n  return rn;\n}\n\nstatic int count_node(node_t *n, int first, int last) {\n  if (n == NULL) return 0;\n  return (n->x < first || n->x > last ? 0 : 1) + count_node(n->l, first, last) + count_node(n->r, first, last);\n}\n\nstatic void free_node(node_t *n) {\n  if (n == NULL) return;\n  free_node(n->l);\n  free_node(n->r);\n  free(n);\n}\n\n/*\nstatic void print_inorder(const node_t *n) {\n  if (n == NULL) return;\n  print_inorder(n->l);\n  printf(\"%d \", n->x);\n  print_inorder(n->r);\n}\n\nstatic void print_points(const point_t *ps, int size) {\n  int i;\n  char *t;\n\n  for (i = 0; i < size; ++i) {\n    switch (ps[i].t) {\n      case TOP:\n        t = \"TOP\";\n        break;\n      case BOTTOM:\n        t = \"BOTTOM\";\n        break;\n      case LEFT:\n        t = \"LEFT\";\n        break;\n      default:\n        break;\n    }\n    printf(\"x: %d, y: %d, pair-x: %d, type: %s\\n\", ps[i].x, ps[i].y, ps[i].pair_x, t);\n  }\n}\n*/\n\nstatic int sweep_as_manhattan_geometry(const point_t *ps, int size) {\n  node_t *root, *node;\n  int i, cnt;\n\n  //print_points(ps, size);\n  //printf(\"\\n\");\n\n  for (i = cnt = 0, root = NULL; i < size; ++i) {\n    switch (ps[i].t) {\n      case TOP:\n        if (root != NULL) {\n          node = find_node(root, ps[i].x);\n          if (node != NULL) root = delete_node(root, node);\n        }\n        break;\n      case BOTTOM:\n        node = new_node(ps[i].x);\n        if (root == NULL) {\n          root = node;\n        } else {\n          insert_node(root, node);\n        }\n        break;\n      case LEFT:\n        if (root != NULL) {\n          //printf(\"From: %d, To: %d, B-Tree: \", ps[i].x, ps[i].pair_x);\n          //print_inorder(root);\n          //printf(\"\\n\");\n          cnt += count_node(root, ps[i].x, ps[i].pair_x);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  free_node(root);\n  return cnt;\n}\n\nint main(int argc, char **argv) {\n  segment_t s;\n  point_t *ps;\n  int n, i, j;\n\n  scanf(\"%d\", &n);\n  ps = (point_t *) malloc(sizeof(point_t) * n * 2);\n  for (i = j = 0; i < n; ++i) {\n    scanf(\"%d %d %d %d\", &s.p0.x, &s.p0.y, &s.p1.x, &s.p1.y);\n    s = normalize(s);\n    ps[j++] = s.p0;\n    ps[j++] = s.p1;\n  }\n  merge_sort(ps, 0, j);\n  printf(\"%d\\n\", sweep_as_manhattan_geometry(ps, j));\n  free(ps);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint n=sc.I;\n\t\tvar li=new List<int[]>();\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tvar e=sc.Ia;\n\t\t\tif(e[0]==e[2]){li.Add(e);}\n\t\t\telse{\n\t\t\t\tli.Add(new int[]{e[0],e[1],e[0]<e[2]?int.MinValue:int.MaxValue});\n\t\t\t\tli.Add(new int[]{e[2],e[3],e[0]<e[2]?int.MaxValue:int.MinValue});\n\t\t\t}\n\t\t}\n\t\tli.Sort((x,y)=>{var c=x[0].CompareTo(y[0]);return c==0?x[2].CompareTo(y[2]):c;});\n\t\tvar avl=new Avl();\n\t\tlong ans=0;\n\t\tfor(int i = 0;i<li.Count;i++) {\n\t\t\tif(li[i].Length==3){\n\t\t\t\tif(li[i][2]==int.MinValue){avl.Ud(li[i][1],1);}\n\t\t\t\telse{avl.Dl(li[i][1]);}\n\t\t\t}\n\t\t\telse{ans+=li[i][1]<li[i][3]?avl.Rd(li[i][1],li[i][3]):avl.Rd(li[i][3],li[i][1]);}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans);\n\t}\n}\npublic class Avl{\n\tpublic class Nd{\n\t\tpublic int h=1,c=1;\n\t\tpublic readonly int n;\n\t\tpublic long d,ds;\n\t\tpublic Nd l,r;\n\t\tpublic Nd(int n,long d,Nd l,Nd r){this.n=n;this.d=d;ds=d;this.l=l;this.r=r;}\n\t}\n\tpublic Nd root,du;\n\tpublic int cnt=0;\n\tpublic Avl(){\n\t\tdu=new Nd(int.MinValue,0,du,du);du.h=0;du.c=0;\n\t\troot=du;\n\t}\n\tpublic void Ud(int n,int d){\n\t\tNd mn=new Nd(n,d,du,du);\n\t\tif(root==du){root=mn;}\n\t\telse{\n\t\t\tFu(root,n,mn);\n\t\t\tif(Abs(root.l.h-root.r.h)>1){root=Rotate(root);}\n\t\t}\n\t\tcnt++;\n\t}\n\tprivate void Fu(Nd t,int n,Nd mn){\n\t\tt.c++;\n\t\tt.ds+=mn.d;\n\t\tif(t.n>n){\n\t\t\tif(t.l!=du){\n\t\t\t\tFu(t.l,n,mn);\n\t\t\t\tif(Abs(t.l.l.h-t.l.r.h)>1){t.l=Rotate(t.l);}\n\t\t\t}\n\t\t\telse{t.l=mn;}\n\t\t}\n\t\telse{\n\t\t\tif(t.r!=du){\n\t\t\t\tFu(t.r,n,mn);\n\t\t\t\tif(Abs(t.r.l.h-t.r.r.h)>1){t.r=Rotate(t.r);}\n\t\t\t}\n\t\t\telse{t.r=mn;}\n\t\t}\n\t\tt.h=Max(t.l.h,t.r.h)+1;\n\t}\n\tprivate Nd Rotate(Nd t){\n\t\tNd nd=du;\n\t\tif(t.l.h>t.r.h){\n\t\t\tif(t.l.l.h>t.l.r.h){\n\t\t\t\tnd=t.l;t.l=t.l.r;nd.r=t;\n\t\t\t\tFt(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnd=t.l.r;\n\t\t\t\tt.l.r=nd.l;nd.l=t.l;\n\t\t\t\tFt(t.l);\n\t\t\t\tt.l=nd.r;nd.r=t;\n\t\t\t\tFt(t);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(t.r.l.h>t.r.r.h){\n\t\t\t\tnd=t.r.l;\n\t\t\t\tt.r.l=nd.r;nd.r=t.r;\n\t\t\t\tFt(t.r);\n\t\t\t\tt.r=nd.l;nd.l=t;\n\t\t\t\tFt(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnd=t.r;t.r=t.r.l;nd.l=t;\n\t\t\t\tFt(t);\n\t\t\t}\n\t\t}\n\t\tFt(nd);\n\t\treturn nd;\n\t}\n\tprivate void Ft(Nd t){\n\t\tt.h=Max(t.l.h,t.r.h)+1;\n\t\tt.c=t.l.c+t.r.c+1;\n\t\tt.ds=t.l.ds+t.r.ds+t.d;\n\t}\n\tpublic bool Dl(int n){\n\t\tif(cnt==0){return false;}\n\t\tNd t=root;\n\t\tif(t.n==n){\n\t\t\troot=Fd2(root);\n\t\t\tif(cnt==0){return true;}\n\t\t\telse if(Abs(root.l.h-root.r.h)>1){root=Rotate(root);}\n\t\t\telse{Ft(root);}\n\t\t\treturn true;\n\t\t}\n\t\tbool bo=Fd1(root,n);\n\t\tif(Abs(root.l.h-root.r.h)>1){root=Rotate(root);}\n\t\telse{Ft(root);}\n\t\treturn bo;\n\t}\n\tprivate bool Fd1(Nd t,int n){\n\t\tif(t.n>n){\n\t\t\tif(t.l==du){return false;}\n\t\t\telse if(t.l.n!=n){\n\t\t\t\tbool bo=Fd1(t.l,n);\n\t\t\t\tif(Abs(t.l.l.h-t.l.r.h)>1){t.l=Rotate(t.l);}\n\t\t\t\telse{Ft(t.l);}\n\t\t\t\treturn bo;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt.l=Fd2(t.l);\n\t\t\t\tFt(t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(t.r==du){return false;}\n\t\t\telse if(t.r.n!=n){\n\t\t\t\tbool bo=Fd1(t.r,n);\n\t\t\t\tif(Abs(t.r.l.h-t.r.r.h)>1){t.r=Rotate(t.r);}\n\t\t\t\telse{Ft(t.r);}\n\t\t\t\treturn bo;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt.r=Fd2(t.r);\n\t\t\t\tFt(t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tprivate Nd Fd2(Nd dn){\n\t\tcnt--;\n\t\tif(dn.l==du){return dn.r;}\n\t\tif(dn.r==du){return dn.l;}\n\t\tNd u=dn.l;\n\t\tif(u.r==du){\n\t\t\tu.r=dn.r;\n\t\t\tFt(u);\n\t\t\treturn u;\n\t\t}\n\t\tu=Fd3(u,dn);\n\t\tif(Abs(dn.l.l.h-dn.l.r.h)>1){u.l=Rotate(dn.l);}\n\t\telse{Ft(dn.l);}\n\t\tFt(u);\n\t\treturn u;\n\t}\n\tprivate Nd Fd3(Nd u,Nd dn){\n\t\tif(u.r.r!=du){\n\t\t\tNd v=Fd3(u.r,dn);\n\t\t\tif(Abs(u.r.l.h-u.r.r.h)>1){u.r=Rotate(u.r);}\n\t\t\telse{Ft(u.r);}\n\t\t\treturn v;\n\t\t}\n\t\telse{\n\t\t\tNd v=u.r;u.r=u.r.l;v.l=dn.l;v.r=dn.r;\n\t\t\treturn v;\n\t\t}\n\t}\n\tpublic Nd Hs(int n){\n\t\tNd t=root;\n\t\tif(cnt==0){return null;}\n\t\tif(t.n==n){return t;}\n\t\tNd a=null;\n\t\twhile(true){\n\t\t\tif(t.n>n){\n\t\t\t\tif(t.l==du){break;}\n\t\t\t\telse if(t.l.n!=n){t=t.l;}\n\t\t\t\telse{a=t.l;break;}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(t.r==du){break;}\n\t\t\t\telse if(t.r.n!=n){t=t.r;}\n\t\t\t\telse{a=t.r;break;}\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Nd Ra(int n){return cnt>=n?Fr(root,n):null;}\n\tprivate Nd Fr(Nd t,int n){\n\t\tif(t.l.c>n-1){return Fr(t.l,n);}\n\t\tif(t.l.c<n-1){return Fr(t.r,n-t.l.c-1);}\n\t\treturn t;\n\t}\n\tpublic Nd Lb(int n){return cnt!=0?Flb(root,n):null;}\n\tprivate Nd Flb(Nd t,int n){\n\t\tif(t.n<n){\n\t\t\tif(t.r==du){return null;}\n\t\t\treturn Flb(t.r,n);\n\t\t}\n\t\tif(t.n>n){\n\t\t\tif(t.l==du){return t;}\n\t\t\tNd u=Flb(t.l,n);\n\t\t\treturn u==null?t:u;\n\t\t}\n\t\treturn t;\n\t}\n\tpublic Nd Ub(int n){return cnt!=0?Fub(root,n):null;}\n\tprivate Nd Fub(Nd t,int n){\n\t\tif(t.n>n){\n\t\t\tif(t.l==du){return null;}\n\t\t\treturn Fub(t.l,n);\n\t\t}\n\t\tif(t.n<n){\n\t\t\tif(t.r==du){return t;}\n\t\t\tNd u=Fub(t.r,n);\n\t\t\treturn u==null?t:u;\n\t\t}\n\t\treturn t;\n\t}\n\tpublic int Rg(int a,int b){return cnt!=0?Frg(root,a,b,false,false):0;}\n\tprivate int Frg(Nd t,int a,int b,bool l,bool r){\n\t\tif(t.h==0){return 0;}\n\t\tif(l&&r){return t.c;}\n\t\tif(t.n<a){return Frg(t.r,a,b,t.n>=a,r);}\n\t\tif(t.n>b){return Frg(t.l,a,b,l,t.n<=b);}\n\t\treturn Frg(t.l,a,b,l,t.n<=b)+Frg(t.r,a,b,t.n>=a,r)+1;\n\t}\n\tpublic long Rd(int a,int b){return cnt!=0?Frd(root,a,b,false,false):0;}\n\tprivate long Frd(Nd t,int a,int b,bool l,bool r){\n\t\tif(t.h==0){return 0;}\n\t\tif(l&&r){return t.ds;}\n\t\tif(t.n<a){return Frd(t.r,a,b,t.n>=a,r);}\n\t\tif(t.n>b){return Frd(t.l,a,b,l,t.n<=b);}\n\t\treturn Frd(t.l,a,b,l,t.n<=b)+Frd(t.r,a,b,t.n>=a,r)+t.d;\n\t}\n\tpublic void Ad(int n,int d){\n\t\tNd t=root;\n\t\tif(cnt==0){return;}\n\t\tif(t.n==n){t.d+=d;t.ds+=d;return;}\n\t\twhile(true){\n\t\t\tt.ds+=d;\n\t\t\tif(t.n>n){\n\t\t\t\tif(t.l==du){break;}\n\t\t\t\telse if(t.l.n!=n){t=t.l;}\n\t\t\t\telse{t.l.d+=d;t.l.ds+=d;break;}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(t.r==du){break;}\n\t\t\t\telse if(t.r.n!=n){t=t.r;}\n\t\t\t\telse{t.r.d+=d;t.r.ds+=d;break;}\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    enum ST { Bottom, Left, Right, Top }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Segment[] S = new Segment[n];\n            EndPoint[] EP = new EndPoint[n * 2];\n\n            for (int i = 0, k = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point a = new Point(input[0], input[1]);\n                Point b = new Point(input[2], input[3]);\n\n                if (a.y == b.y)\n                {\n                    S[i] = a.x > b.x ? new Segment(b, a) : new Segment(a, b);\n\n                    EP[k++] = new EndPoint(S[i].p1, i, ST.Left);\n                    EP[k++] = new EndPoint(S[i].p2, i, ST.Right);\n                }\n                else\n                {\n                    S[i] = a.y > b.y ? new Segment(b, a) : new Segment(a, b);\n\n                    EP[k++] = new EndPoint(S[i].p1, i, ST.Bottom);\n                    EP[k++] = new EndPoint(S[i].p2, i, ST.Top);\n                }\n            }\n\n            Array.Sort(EP);\n\n            Console.WriteLine(ManhattanGeometry(S, EP));\n        }\n\n        static int ManhattanGeometry(Segment[] S, EndPoint[] EP)\n        {\n            var BT = new HashSet<double>();\n\n            int cnt = 0, n = EP.Length;\n\n            for (int i = 0; i < n; i++)\n            {\n                switch (EP[i].st)\n                {\n                    case ST.Top:\n                        BT.Remove(EP[i].p.x);\n                        break;\n                    case ST.Bottom:\n                        BT.Add(EP[i].p.x);\n                        break;\n                    case ST.Left:\n                        double begin = S[EP[i].seg].p1.x;\n                        double end = S[EP[i].seg].p2.x;\n                        var vol = BT.Where(a => a >= begin && a <= end).Count();\n                        cnt += vol;\n                        break;\n                }\n            }\n            return cnt;\n        }\n    }\n\n    class EndPoint : IComparable\n    {\n        internal Point p;\n        internal int seg;\n        internal ST st;\n\n        public EndPoint(Point p, int seg, ST st)\n        {\n            this.p = p;\n            this.seg = seg;\n            this.st = st;\n        }\n\n        public int CompareTo(object obj)\n        {\n            EndPoint other = obj as EndPoint;\n\n            if (p.y < other.p.y) return -1;\n            if (p.y > other.p.y) return 1;\n            if (st < other.st) return -1;\n            if (st > other.st) return 1;\n            return 0;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass A\n{\n\tstatic void Main()\n\t{\n\t\tvar n = int.Parse(Console.ReadLine());\n\t\tvar ps = new int[n].Select(_ => Console.ReadLine().Split().Select(int.Parse).ToArray()).ToArray();\n\n\t\tvar dy = ps.Select(v => v[1]).Concat(ps.Select(v => v[3])).Distinct().OrderBy(y => y).Select((y, i) => new { y, i }).ToDictionary(_ => _.y, _ => _.i);\n\n\t\tvar xs = ps.Where(v => v[1] == v[3]).SelectMany(v => new[] { new[] { -1, Math.Min(v[0], v[2]), dy[v[1]] }, new[] { 1, Math.Max(v[0], v[2]), dy[v[1]] } }).ToArray();\n\t\tvar ys = ps.Where(v => v[0] == v[2]).Select(v => new[] { 0, v[0], dy[Math.Min(v[1], v[3])], dy[Math.Max(v[1], v[3])] }).ToArray();\n\t\tvar qs = xs.Concat(ys).OrderBy(q => q[1]).ThenBy(q => q[0]);\n\n\t\tvar r = 0L;\n\t\tvar st = new ST(dy.Count);\n\t\tforeach (var q in qs)\n\t\t\tif (q[0] == 0)\n\t\t\t\tr += st.Subsum(q[2], q[3] + 1);\n\t\t\telse\n\t\t\t\tst.Add(q[2], -q[0]);\n\t\tConsole.WriteLine(r);\n\t}\n}\n\nclass ST\n{\n\tstruct KI\n\t{\n\t\tpublic int k, i;\n\t}\n\n\tint kMax;\n\tList<long[]> vs = new List<long[]> { new long[1] };\n\tpublic ST(int n)\n\t{\n\t\tfor (int c = 1; c < n; vs.Add(new long[c <<= 1])) ;\n\t\tkMax = vs.Count - 1;\n\t}\n\n\tKI[] GetLevels(int i)\n\t{\n\t\tvar r = new List<KI>();\n\t\tfor (int k = kMax; k >= 0; --k, i >>= 1) r.Add(new KI { k = k, i = i });\n\t\treturn r.ToArray();\n\t}\n\n\tKI[] GetRange(int minIn, int maxEx)\n\t{\n\t\tvar r = new List<KI>();\n\t\tfor (int k = kMax, f = 1; k >= 0 && minIn < maxEx; --k, f <<= 1)\n\t\t{\n\t\t\tif ((minIn & f) != 0) r.Add(new KI { k = k, i = (minIn += f) / f - 1 });\n\t\t\tif ((maxEx & f) != 0) r.Add(new KI { k = k, i = (maxEx -= f) / f });\n\t\t}\n\t\treturn r.ToArray();\n\t}\n\n\tpublic void Add(int i, long v)\n\t{\n\t\tforeach (var x in GetLevels(i)) vs[x.k][x.i] += v;\n\t}\n\n\tpublic long Subsum(int minIn, int maxEx) => GetRange(minIn, maxEx).Sum(x => vs[x.k][x.i]);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    enum ST { Bottom, Left, Right, Top }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Segment[] S = new Segment[n];\n            EndPoint[] EP = new EndPoint[n * 2];\n\n            for (int i = 0, k = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point a = new Point(input[0], input[1]);\n                Point b = new Point(input[2], input[3]);\n\n                if (a.y == b.y)\n                {\n                    S[i] = a.x > b.x ? new Segment(b, a) : new Segment(a, b);\n\n                    EP[k++] = new EndPoint(S[i].p1, i, ST.Left);\n                    EP[k++] = new EndPoint(S[i].p2, i, ST.Right);\n                }\n                else\n                {\n                    S[i] = a.y > b.y ? new Segment(b, a) : new Segment(a, b);\n\n                    EP[k++] = new EndPoint(S[i].p1, i, ST.Bottom);\n                    EP[k++] = new EndPoint(S[i].p2, i, ST.Top);\n                }\n            }\n\n            EP = EP.OrderBy(a => a.p.y).ThenBy(b => b.st).ToArray();\n\n            Console.WriteLine(ManhattanGeometry(S, EP));\n        }\n\n        static int ManhattanGeometry(Segment[] S, EndPoint[] EP)\n        {\n            var BT = new HashSet<double>();\n\n            int cnt = 0, n = EP.Length;\n\n            for (int i = 0; i < n; i++)\n            {\n                switch (EP[i].st)\n                {\n                    case ST.Top:\n                        BT.Remove(EP[i].p.x);\n                        break;\n                    case ST.Bottom:\n                        BT.Add(EP[i].p.x);\n                        break;\n                    case ST.Left:\n                        double begin = S[EP[i].seg].p1.x;\n                        double end = S[EP[i].seg].p2.x;\n                        var vol = BT.Where(a => a >= begin && a <= end).Count();\n                        cnt += vol;\n                        break;\n                }\n            }\n            return cnt;\n        }\n    }\n\n    class EndPoint\n    {\n        internal Point p;\n        internal int seg;\n        internal ST st;\n\n        public EndPoint(Point p, int seg, ST st)\n        {\n            this.p = p;\n            this.seg = seg;\n            this.st = st;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    enum ST { Bottom, Left, Right, Top }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Segment[] S = new Segment[n];\n            EndPoint[] EP = new EndPoint[n * 2];\n\n            for (int i = 0, k = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point a = new Point(input[0], input[1]);\n                Point b = new Point(input[2], input[3]);\n\n                if (a.y == b.y)\n                {\n                    S[i] = a.x > b.x ? new Segment(b, a) : new Segment(a, b);\n\n                    EP[k++] = new EndPoint(S[i].p1, i, ST.Left);\n                    EP[k++] = new EndPoint(S[i].p2, i, ST.Right);\n                }\n                else\n                {\n                    S[i] = a.y > b.y ? new Segment(b, a) : new Segment(a, b);\n\n                    EP[k++] = new EndPoint(S[i].p1, i, ST.Bottom);\n                    EP[k++] = new EndPoint(S[i].p2, i, ST.Top);\n                }\n            }\n\n            Array.Sort(EP);\n\n            Console.WriteLine(ManhattanGeometry(S, EP));\n        }\n\n        static int ManhattanGeometry(Segment[] S, EndPoint[] EP)\n        {\n            var BT = new HashSet<double>();\n\n            int cnt = 0, n = EP.Length;\n\n            for (int i = 0; i < n; i++)\n            {\n                switch (EP[i].st)\n                {\n                    case ST.Top:\n                        BT.Remove(EP[i].p.x);\n                        break;\n                    case ST.Bottom:\n                        BT.Add(EP[i].p.x);\n                        break;\n                    case ST.Left:\n                        double begin = S[EP[i].seg].p1.x;\n                        double end = S[EP[i].seg].p2.x;\n                        var subset = BT.Where(a => a >= begin && a <= end).ToArray();\n                        cnt += subset.Length;\n                        break;\n                }\n            }\n            return cnt;\n        }\n    }\n\n    class EndPoint : IComparable\n    {\n        internal Point p;\n        internal int seg;\n        internal ST st;\n\n        public EndPoint(Point p, int seg, ST st)\n        {\n            this.p = p;\n            this.seg = seg;\n            this.st = st;\n        }\n\n        public int CompareTo(object obj)\n        {\n            EndPoint other = obj as EndPoint;\n\n            if (p.y < other.p.y) return -1;\n            if (p.y > other.p.y) return 1;\n            if (st < other.st) return -1;\n            if (st > other.st) return 1;\n            return 0;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\n\nnamespace AOJ\n{\n    using Vector = Point;\n    using Line = Segment;\n    using Polygon = List<Point>;\n\n    class Consts\n    {\n        public static readonly double EPS = 1e-10;\n    }\n    class Point : IEquatable<Point>\n    {\n        double x, y;\n        public double X { get { return this.x; } set { this.x = value; } }\n        public double Y { get { return this.y; } set { this.y = value; } }\n        public Point(double x = 0, double y = 0)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        static public Point operator +(Point p1, Point p2) => new Point(p1.x + p2.x, p1.y + p2.y);\n        static public Point operator -(Point p1, Point p2) => new Point(p1.x - p2.x, p1.y - p2.y);\n        static public Point operator *(Point p, double a) => new Point(a * p.x, a * p.y);\n        static public Point operator *(double a, Point p) => p * a;\n        static public Point operator /(Point p, double a) => new Point(p.x / a, p.y / a);\n        static public bool operator <(Point p1, Point p2) => p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y;\n        static public bool operator >(Point p1, Point p2) => p2 < p1;\n\n        static public bool operator ==(Point p1, Point p2) => Math.Abs(p1.x - p2.x) < Consts.EPS && Math.Abs(p1.y - p2.y) < Consts.EPS;\n        static public bool operator !=(Point p1, Point p2) => !(p1 == p2);\n\n        public double abs() => Math.Sqrt(norm());\n        public double norm() => this.x * this.x + this.y * this.y;\n\n        public bool Equals(Point obj)\n        {\n            return this == obj;\n        }\n        public override bool Equals(object obj)\n        {\n            if ((object)obj == null || this.GetType() != obj.GetType())\n            {\n                return false;\n            }\n            var c = (Point)obj;\n            return this == c;\n        }\n        public override int GetHashCode()\n        {\n            return this.x.GetHashCode() ^ this.y.GetHashCode();\n        }\n    }\n    struct Segment\n    {\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n        public Point p1, p2;\n    }\n    class Circle\n    {\n        public Point c;\n        public double r;\n        public Circle(Point c, double r)\n        {\n            this.c = c;\n            this.r = r;\n        }\n    }\n\n    class VecCalc\n    {\n        static bool equals(double a, double b) => Math.Abs(a - b) < Consts.EPS;\n        //内積\n        static public double dot(Vector a, Vector b)\n        {\n            return a.X * b.X + a.Y * b.Y;\n        }\n        //外積\n        static public double cross(Vector a, Vector b)\n        {\n            return a.X * b.Y - a.Y * b.X;\n        }\n        //16.2 直行判定\n        static public bool isOrthogonal(Vector a, Vector b)\n        {\n            return equals(dot(a, b), 0.0);\n        }\n        static public bool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n        {\n            return isOrthogonal(a1 - a2, b1 - b2);\n        }\n        static public bool isOrthogonal(Segment s1, Segment s2)\n        {\n            return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n        }\n        //16.2 平行判定\n        static public bool isParallel(Vector a, Vector b)\n        {\n            return equals(cross(a, b), 0.0);\n        }\n        static public bool isParallel(Point a1, Point a2, Point b1, Point b2)\n        {\n            return isParallel(a1 - a2, b1 - b2);\n        }\n        static public bool isParallel(Segment s1, Segment s2)\n        {\n            return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n        }\n        //16.3 射影\n        static public Point project(Segment s, Point p)\n        {\n            Vector b = s.p2 - s.p1;\n            double r = dot(p - s.p1, b) / b.norm();\n            return s.p1 + b * r;\n        }\n        //16.4 反射\n        static public Point reflection(Segment s, Point p)\n        {\n            return 2 * project(s, p) - p;\n            //mid = project(s, p) - p;\n            //return mid + mid - p;\n        }\n        //16.5 距離\n        //2点間の距離\n        static public double getDistance(Point a, Point b)\n        {\n            return (a - b).abs();\n        }\n        //直線lと点pの距離\n        static public double getDistanceLP(Line l, Point p)\n        {\n            return Math.Abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n        }\n        //線分sと点pの距離\n        static public double getDistanceSP(Segment s, Point p)\n        {\n            if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n            if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n            return getDistanceLP(s, p);\n        }\n        static public double getDistance(Segment s1, Segment s2)\n        {\n            if (intersect(s1, s2)) return 0.0;\n            return Math.Min(\n                    Math.Min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                    Math.Min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n                );\n        }\n        //16.6 反時計回り\n        static public readonly int COUNTER_CLOCKWISE = 1;\n        static public readonly int CLOCKWISE = -1;\n        static public readonly int ONLINE_BACK = 2;\n        static public readonly int ONLINE_FRONT = -2;\n        static public readonly int ON_SEGMENT = 0;\n        static public int ccw(Point p0, Point p1, Point p2)\n        {\n            Vector a = p1 - p0;\n            Vector b = p2 - p0;\n            var dot_ = dot(a, b);\n            var cross_ = cross(a, b);\n            if (Consts.EPS < cross_) return COUNTER_CLOCKWISE;\n            if (cross_ < -Consts.EPS) return CLOCKWISE;\n            if (dot_ < -Consts.EPS) return ONLINE_BACK;\n            if (a.norm() < b.norm()) return ONLINE_FRONT;\n            return ON_SEGMENT;\n        }\n        static public int ccw(Segment s, Point p)\n        {\n            return ccw(s.p1, s.p2, p);\n        }\n        //16.7 線分の交差判定\n        static public bool intersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n                ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n                );\n        }\n        static public bool intersect(Segment s1, Segment s2)\n        {\n            return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n        }\n        //16.8 線分の交点\n        static public Point getCrossPoint(Segment s1, Segment s2)\n        {\n            Vector b = s2.p2 - s2.p1;\n            double d1 = Math.Abs(cross(b, s1.p1 - s2.p1));\n            double d2 = Math.Abs(cross(b, s1.p2 - s2.p1));\n            double t = d1 / (d1 + d2);\n            return s1.p1 + (s1.p2 - s1.p1) * t;\n        }\n        //16.9 円と直線の交点\n        static public Segment getCrossPoints(Circle c, Line l)\n        {\n            Vector pr = project(l, c.c);\n            System.Diagnostics.Debug.Assert((c.c - pr).abs() <= c.r);\n            Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n            double b = Math.Sqrt(c.r * c.r - (c.c - pr).norm());\n            return new Segment(pr + e * b, pr - e * b);\n        }\n        //16.10 円と円の交点\n        static double arg(Vector p) { return Math.Atan2(p.Y, p.X); }\n        static Vector polar(double a, double r) { return new Point(Math.Cos(r) * a, Math.Sin(r) * a); }\n        static public Segment getCrossPoints(Circle c1, Circle c2)\n        {\n            double d = (c1.c - c2.c).abs();\n            System.Diagnostics.Debug.Assert(d <= c1.r + c2.r);\n            double a = Math.Acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n            double t = arg(c2.c - c1.c);\n            return new Segment(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n        }\n        //他ヘロンの公式を使ったり。高さだす、交点の投影点求める、投影点から平行線へのベクトル出す、みたいなの)\n        //16.11 点の内包\n        //IN:2,ON:1,OUT:0\n        static public int contains(Polygon g, Point p)\n        {\n            int n = g.Count;\n            bool x = false;\n            for (var i = 0; i < n; ++i)\n            {\n                Point a = g[i] - p, b = g[(i + 1) % n] - p;\n                if (Math.Abs(cross(a, b)) < Consts.EPS && dot(a, b) < Consts.EPS) return 1;\n                if (b.Y < a.Y)\n                {\n                    var t = a;\n                    a = b;\n                    b = t;\n                }\n                if (a.Y < Consts.EPS && Consts.EPS < b.Y && Consts.EPS < cross(a, b)) x = !x;\n            }\n            return (x ? 2 : 0);\n        }\n        //他、xの最大・最小値を使って半直線を作り、各辺との交差、点を通る場合、辺と平行かつ通る場合を考えていく方法もあり\n        //半直線：判定対象点とPolygonの右端との差を使って適当に作る\n        //Polygonの各辺ごとに処理する\n        //  ccwでライン上にあるか判定\n        //  両方の点を通る場合(平行&通る):辺と点を合わせて1点と考える。次の辺は飛ばす\n        //  点を通る場合：Ｖ、Λの場合は無視する。j+1の点を通る場合は次の処理に任す\n        //16.12 凸包\n        static public Polygon andrewScan(Polygon s)\n        {\n            Polygon u = new Polygon();\n            Polygon l = new Polygon();\n\n            if (s.Count < 3) return s;\n            s = s.OrderBy(e => e.Y).ThenBy(e => e.X).ToList();//X→Yなら最小のXからぐるり\n            var size = s.Count;\n            u.Add(s[0]);\n            u.Add(s[1]);\n            l.Add(s[size - 1]);\n            l.Add(s[size - 2]);\n            for (var i = 2; i < size; ++i)\n            {\n                for (var n = u.Count; 2 <= n && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; --n) //!CLOCKWISEにすると端点のみ(線分中の点は無視)\n                {\n                    u.RemoveAt(u.Count - 1);\n                }\n                u.Add(s[i]);\n            }\n            for (var i = size - 3; 0 <= i; --i)\n            {\n                for (var n = l.Count; 2 <= n && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; --n)\n                {\n                    l.RemoveAt(l.Count - 1);\n                }\n                l.Add(s[i]);\n            }\n            l.Reverse();\n            for (var i = u.Count - 2; 1 <= i; --i) l.Add(u[i]);\n            return l;\n        }\n    }\n    //16.13 線分交差問題\n    class EndPoint\n    {\n        public Point p;\n        public int seg, st;\n        public EndPoint() { }\n        public EndPoint(Point p, int seg, int st)\n        {\n            this.p = p;\n            this.seg = seg;\n            this.st = st;\n        }\n        static public bool operator <(EndPoint e1, EndPoint e2)\n        {\n            if (e1.p.Y == e2.p.Y)\n            { return e1.st < e2.st; }\n            else\n            { return e2.p.Y < e2.p.Y; }\n        }\n        static public bool operator >(EndPoint e1, EndPoint e2)\n        { return e2 < e1; }\n    }\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        static public int manhattanIntersection(List<Segment> S)\n        {\n            var EP = new List<EndPoint>();\n            const int BOTTOM = 0;\n            const int LEFT = 1;\n            const int RIGHT = 2;\n            const int TOP = 3;\n            var n = S.Count;\n            for (int i = 0; i < n; ++i)\n            {\n                if (S[i].p1.Y == S[i].p2.Y)\n                {\n                    if (S[i].p2.X < S[i].p1.X)\n                    { S[i] = new Segment(S[i].p2, S[i].p1); }\n                }\n                else if (S[i].p2.Y < S[i].p1.Y)\n                { S[i] = new Segment(S[i].p2, S[i].p1); }\n\n                if (S[i].p1.Y == S[i].p2.Y)\n                {\n                    EP.Add(new EndPoint(S[i].p1, i, LEFT));\n                    EP.Add(new EndPoint(S[i].p2, i, RIGHT));\n                }\n                else\n                {\n                    EP.Add(new EndPoint(S[i].p1, i, BOTTOM));\n                    EP.Add(new EndPoint(S[i].p2, i, TOP));\n                }\n            }\n            EP = EP.OrderBy(l => l.p.Y).ThenBy(l => l.st).ToList();\n\n            var BT = new HashSet<int>();\n            //var BT = new List<int>();\n            int cnt = 0;\n            for (int i = 0; i < EP.Count; i++)\n            {\n                if (EP[i].st == TOP)\n                { BT.Remove((int)EP[i].p.X); }\n                else if (EP[i].st == BOTTOM)\n                { BT.Add((int)EP[i].p.X); }\n                else if (EP[i].st == LEFT)\n                {\n                    var begin = (int)S[EP[i].seg].p1.X;\n                    var end = (int)S[EP[i].seg].p2.X;\n                    //BT.Sort();\n                    //var lb = -BT.BinarySearch(begin, new lb());\n                    //var ub = -BT.BinarySearch(end, new ub());\n                    //cnt += ub - lb;\n                    cnt+= BT.Where(a => begin <= a && a <= end).Count();\n                } \n            }\n            return cnt;\n        }\n        //upper_bound\n        public class ub : IComparer<int>\n        {\n            public int Compare(int x, int y)\n            { return 0 < x.CompareTo(y) ? 1 : -1; }\n        }\n        //lower_bound\n        public class lb : IComparer<int>\n        {\n            public int Compare(int x, int y)\n            { return 0 <= x.CompareTo(y) ? 1 : -1; }\n        }\n\n        static void Main(string[] args)\n        {\n            var n = (int)Sarray()[0];\n            var ps = new List<Point>();\n            var seg = new List<Segment>();\n            for (var i = 0; i < n; ++i)\n            {\n                var p = Sarray();\n                var pos1 = new Point(p[0], p[1]);\n                var pos2 = new Point(p[2], p[3]);\n                seg.Add(new Segment(pos1, pos2));\n            }\n            WriteLine(manhattanIntersection(seg));\n        }\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n      x.r = n.r\n      x.p = n.p\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n      x.p = n.p\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n   def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n      x.r = n.r\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n      x.p = n\n    else\n      n.p.r = x\n      x.p = n\n    end\n  end\n\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def del(key)\n    n = find(key)\n    if n.l == nil || n.r == nil\n      del_node = n\n    else\n      del_node = get_successor(n)\n    end\n\n    if del_node.l != nil\n      x = del_node.l\n    else\n      x = del_node.r\n    end\n\n    if x\n      x.p = del_node.p\n    end\n\n    if del_node.p == nil\n      @root = x\n    elsif del_node == del_node.p.l\n      del_node.p.l = x\n    else\n      del_node.p.r = x\n    end\n\n    if n != del_node\n      n.key = del_node.key\n    end\n  end\n\n  def get_successor(n)\n    if n.r\n      return get_minimum(n.r)\n    end\n\n    y = n.p\n    while y != nil && n == y.r\n      n = y\n      y = y.p\n    end\n    return y\n  end\n\n  def get_minimum(n)\n    while n.l\n      n = n.l\n    end\n    return n\n  end\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.del(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n      x.l = n.l\n      x.r = n.r\n      x.p.r = nil\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n      x.r = n.r\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nclass BTree\n  attr_accessor :root\n  class Node\n    attr_accessor :r, :l, :key, :p\n\n    def initialize(key)\n      @key = key\n      @p, @r, @l = nil, nil, nil\n    end\n  end\n\n  def initialize\n    @root = nil\n  end\n\n  def insert(key)\n    n = Node.new(key)\n    y = nil\n    x = @root\n\n    while x != nil\n      y = x\n      x = if n.key < x.key\n        x.l\n      else\n        x.r\n      end\n    end\n    n.p = y\n\n    if y == nil\n      @root = n\n    elsif n.key < y.key\n      y.l = n\n    else\n      y.r = n\n    end\n  end\n\n  def find(key)\n    n = @root\n    while n != nil\n      return n if n.key == key\n      n = if key < n.key\n        n.l\n      else\n        n.r\n      end\n    end\n    return nil\n  end\n\n  def remove(key)\n    n = find(key)\n    if n.l == nil && n.r == nil\n      x = nil\n    elsif n.l && n.r\n      x = n.l\n      while x.r\n        x = x.r\n      end\n\n      x.p.r = nil\n      x.l = n.l\n\n    else\n      if n.l\n        x = n.l\n      else\n        x = n.r\n      end\n    end\n\n    if n.p == nil\n      @root = x\n    elsif n.key < n.p.key\n      n.p.l = x\n    else\n      n.p.r = x\n    end\n  end\n\nend\n\nclass EndPoint\n  attr_accessor :type, :p, :seg\n  def initialize(p, type, seg)\n     @type, @p, @seg = type, p, seg\n  end\nend\n\nep = []\ns = []\ngets.to_i.times do |i|\n  x1, y1, x2, y2 = gets.split.map &:to_i\n  s[i] = {}\n  if x1 == x2\n    if y1 > y2\n      s[i][\"TOP\"] = EndPoint.new(Vector[x1, y1], \"TOP\", i)\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x2, y2], \"BOTTOM\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    else\n      s[i][\"BOTTOM\"] = EndPoint.new(Vector[x1, y1], \"BOTTOM\", i)\n      s[i][\"TOP\"] = EndPoint.new(Vector[x2, y2], \"TOP\", i)\n      ep << s[i][\"TOP\"]\n      ep << s[i][\"BOTTOM\"]\n    end\n  else\n    if x1 > x2\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x1, y1], \"RIGHT\", i)\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x2, y2], \"LEFT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    else\n      s[i][\"LEFT\"] = EndPoint.new(Vector[x1, y1], \"LEFT\", i)\n      s[i][\"RIGHT\"] = EndPoint.new(Vector[x2, y2], \"RIGHT\", i)\n      ep << s[i][\"RIGHT\"]\n      ep << s[i][\"LEFT\"]\n    end\n  end\nend\n\nep.sort! { |a, b| a.p[1] <=> b.p[1] }\nbt = BTree.new\nresult = 0\nwhile !ep.empty?\n  n = ep.shift\n  if n.type == \"TOP\"\n    bt.remove(n.p[0])\n  elsif n.type == \"BOTTOM\"\n    bt.insert(n.p[0])\n  elsif n.type == \"LEFT\"\n    l = s[n.seg][\"LEFT\"].p[0]\n    r = s[n.seg][\"RIGHT\"].p[0]\n    (l..r).each do |i|\n      result += 1 if bt.find(i)\n    end\n  end\nend\n\nputs result"
  },
  {
    "language": "Python",
    "code": "import bisect\nfrom collections import deque\n\nn = int(input())\nPs = []\nfor i in range(n):\n    x1,y1,x2,y2 = map(int,input().split())\n    if x1 == x2:\n        if y2 < y1:\n            y1,y2 = y2,y1\n        Ps.append((y1,x1,\"s\",0))\n        Ps.append((y2,x1,\"g\",2))\n\n    else:\n        if x2 < x1:\n            x1,x2 = x2,x1\n        Ps.append((y1,x1,x2,1))\nPs.sort(key=lambda x:x[3])\nPs.sort(key=lambda x:x[0])\nN = len(Ps)\nans = 0\nX = deque()\n\nfor i in range(N):\n    query = Ps[i]\n    if query[2] == \"s\":\n        X.insert(bisect.bisect_left(X,query[1]), query[1])\n    elif query[2] == \"g\":\n        del X[bisect.bisect_left(X,query[1])]\n    else:\n        ans += bisect.bisect_left(X,query[1]) - bisect.bisect_right(X,query[2])\n\nprint(-ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn = input()\n\ndata = [0]*(n+1)\ndef get(i):\n    r = 0\n    while i>0:\n        r += data[i]\n        i -= i & -i\n    return r\ndef add(i, x):\n    while i <= n:\n        data[i] += x\n        i += i & -i\n\nH = []\nV = []\ns = set()\nfor i in xrange(n):\n    x1, y1, x2, y2 = map(int, raw_input().split())\n    if x1 == x2:\n        if y1 > y2: y1, y2 = y2, y1\n        V.append((x1, y1, y2))\n    else:\n        if x1 > x2: x1, x2 = x2, x1\n        H.append((x1, y1, 1))\n        H.append((x2+1, y1, -1))\n        s.add(y1)\nys = sorted(s)\nymap = {e: i for i, e in enumerate(ys)}.__getitem__\nV.sort(); H.sort()\n\nans = 0\nidx_h = 0; hn = len(H)\nfor x, y1, y2 in V:\n    while idx_h < hn and H[idx_h][0] <= x:\n        add(ymap(H[idx_h][1])+1, H[idx_h][2])\n        idx_h += 1\n    idx_l = bisect(ys, y1)-1\n    idx_r = bisect(ys, y2+1)\n    ans += get(idx_r) - get(idx_l)\nprint ans"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n        vs_x.add(x1)\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n\nvs_x = sorted(vs_x)\n\n# Binary Indexed Tree\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.data = [0] * (n + 1)\n        self.num = n\n\n    def switch(self, i, d):\n        while  i <= self.num:\n            self.data[i] += d\n            i += i & -i\n\n    def _sum(self, i):\n        s = 0\n        while i:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def seg_sum(self, a, b):\n        return self._sum(b) - self._sum(a - 1)\n\n# Sweep\nimport bisect\n\nEP.sort()\nBIT = BinaryIndexedTree(len(vs_x))\ncnt = 0\n\nfor p in EP:\n    e = p[1]\n    if e == l:\n        vx = bisect.bisect(vs_x, p[2])\n        BIT.switch(vx, 1)\n    elif e == u:\n        vx = bisect.bisect(vs_x, p[2])\n        BIT.switch(vx, -1)\n    else:\n        l_x = bisect.bisect_left(vs_x, e) + 1\n        r_x = bisect.bisect(vs_x, p[2])\n        cnt += BIT.seg_sum(l_x, r_x)\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_6_A\n\n\nfrom bisect import bisect_left, bisect_right, insort_left\nfrom collections import deque\n\n\nclass BinarySearchTree:\n    def __init__(self, ls: list=[]):\n        '''\n        C++でいうsetを実装する。二分探索木をガチで実装しようとすると大変なので、ここでは配列二分法を用いる。\n        pythonの標準ライブラリがヨイショに抱っこしてくれるおかげで楽に実装できる。\n        https://docs.python.org/ja/3/library/bisect.html\n\n\n        ls ... 渡す初期配列\n        '''\n        self.bst = deque(sorted(ls))  # insertをO(1)にするためにlistの代わりにdequeを用います\n\n    def __repr__(self):\n        return f'BST:{self.bst}'\n\n    def __len__(self):\n        return len(self.bst)\n\n    def __getitem__(self, idx):\n        return self.bst[idx]\n\n    def size(self):\n        return len(self.bst)\n\n    def insert(self, x):\n        insort_left(self.bst, x)\n\n    def remove(self, x):\n        '''\n        xを取り除く。xがself.bstに存在することを保証してください。\n        同一のものが存在した場合は左から消していく\n        '''\n        del self.bst[self.find(x)]\n\n    def bisect_left(self, x):\n        '''\n        ソートされた順序を保ったまま x を self.bst に挿入できる点を探し当てます。\n        lower_bound in C++\n        '''\n        return bisect_left(self.bst, x)\n\n    def bisect_right(self, x):\n        '''\n        bisect_left() と似ていますが、 self.bst に含まれる x のうち、どのエントリーよりも後ろ(右)にくるような挿入点を返します。\n        upper_bound in C++\n        '''\n        return bisect_right(self.bst, x)\n\n    def find(self, x):\n        '''\n        xのidxを探索\n        '''\n        idx = bisect_left(self.bst, x)\n        if idx != len(self.bst) and self.bst[idx] == x:\n            return idx\n        raise ValueError\n\n\n\n    # load data\nN = int(input())\nlines = []\nfor _ in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    # 前処理として、x1,y1を必ず下端点or左端点にする\n    if y1 == y2:  # 平行線の場合\n        if x1 > x2:\n            x1, x2 = x2, x1\n    else:  # 垂直線の場合\n        if y1 > y2:\n            y1, y2 = y2, y1\n    lines.append((x1, y1, x2, y2))\n\n# P409の下の方に書いてあるが、交差を判定する前に削除してしまったり、追加するまえに判定してしまったりすることを防ぐために\n# うまい感じにソートするためにendpointsを導入する\n# 各要素は(y,端点の種類,xで定義される)\nBOTTOM = 0\nLEFT = 1\nRIGHT = 2\nTOP = 3\n# 線分の端点を必ず左下始まりにする\nendpoints = []\nfor x1, y1, x2, y2 in lines:\n    if y1 == y2:  # 平行線の場合\n        endpoints.append((y1, LEFT, x1, x2))  # 左端点の追加\n        endpoints.append((y2, RIGHT, x2, -1))  # 右端点の追加\n    else:  # 垂直線の場合\n        endpoints.append((y1, BOTTOM, x1, -1))  # 下端点の追加\n        endpoints.append((y2, TOP, x2, -1))  # 下端点の追加\n\n# yを下から走査するためにソート\nendpoints.sort()\n\nbst = BinarySearchTree()\nans = 0\nfor y, p_type, x, x_t in endpoints:\n    # if p_type == RIGHT:\n    #     continue  # 後述しますが、右端点は左端点とセットで処理するためスキップしても問題ないです\n\n    # 以下端点の種類ごとに操作を実装\n    if p_type == TOP:\n        bst.remove(x)  # 上端点の場合はbstに登録してあるxを削除\n    elif p_type == BOTTOM:\n        bst.insert(x)  # 下端点の場合はbstにxを登録\n    elif p_type == LEFT:\n        s = bst.bisect_left(x)  # bstにおいて、水平線の左は何番目に大きいか\n        t = bst.bisect_right(x_t)  # bstにおいて、水平線の右は何番目に大きいか(同じ値も含めて)\n        ans += t - s\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\ncache = {}\n\nfor x, y1, y2 in vx:\n    y2 += 1\n    if y1 not in cache:\n        it1 = cache[y1] = bisect.bisect(vy, (y1,))\n    else:\n        it1 = cache[y1]\n    if y2 not in cache:\n        it2 = cache[y2] = bisect.bisect(vy, (y2,))\n    else:\n        it2 = cache[y2]\n    ans += sum(x1 <= x <= x2 for y, x1, x2 in vy[it1:it2])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    # point[2]: 1; left, 2; lower, 3; upper, 4; right\n    if y1 < y2:\n        p1 = (x1, y1, 2)\n        p2 = (x2, y2, 3)\n    elif y1 > y2:\n        p1 = (x1, y1, 3)\n        p2 = (x2, y2, 2)\n    elif x1 < x2:\n        p1 = (x1, y1, 1)\n        p2 = (x2, y2, 4)\n    else:\n        p1 = (x1, y1, 4)\n        p2 = (x2, y2, 1)\n    EP += [p1, p2]\n\n# Sweep function\nimport bisect\n\ndef manhattan_intersection(point_list):\n    point_list.sort(key = lambda p: (p[1], p[0], p[2]))\n    T = []\n    cnt = 0\n    flag = False\n    for p in point_list:\n        position = p[2]\n        if position == 3:\n            T.remove(p[0])\n            if flag:\n                cnt += 1\n        elif position == 2:\n            bisect.insort(T, p[0])\n        elif position == 4:\n            cnt += bisect.bisect(T, p[0]) - left_end\n            flag = False\n        else:\n            left_end = bisect.bisect(T, p[0])\n            flag = True\n    print(cnt)\n\n# Output\nmanhattan_intersection(EP)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# CGL_6_A: Segment Set - Segment Intersections: Manhattan Geometry\n\nfrom enum import IntEnum\n\n\nclass Action(IntEnum):\n    ADD = 1\n    SEARCH = 2\n    REMOVE = 3\n\n\nclass Color(IntEnum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass Node:\n    __slots__ = ('value', 'left', 'right', 'color', 'valid')\n\n    def __init__(self, value):\n        self.value = value\n        self.left = Leaf\n        self.right = Leaf\n        self.color = Color.RED\n        self.valid = True\n\n    def flip_color(self):\n        self.color = Color.flip(self.color)\n\n    def is_red(self):\n        return self.color == Color.RED\n\n    def __str__(self):\n        return ('(' + str(self.left) + ', '\n                + str(self.value) + ', ' + str(self.right) + ')')\n\n\nclass LeafNode(Node):\n    def __init__(self):\n        self.value = None\n        self.left = None\n        self.right = None\n        self.color = None\n        self.valid = False\n\n    def flip_color(self):\n        pass\n\n    def is_red(self):\n        return False\n\n    def __str__(self):\n        return 'Leaf'\n\n\nLeaf = LeafNode()\n\n\nclass RedBlackBST:\n    def __init__(self):\n        self.root = Leaf\n\n    def add(self, value):\n        def _add(node):\n            if node is Leaf:\n                node = Node(value)\n            if node.value > value:\n                node.left = _add(node.left)\n            elif node.value < value:\n                node.right = _add(node.right)\n            else:\n                if not node.valid:\n                    node.valid = True\n\n            node = self._balance(node)\n            return node\n\n        self.root = _add(self.root)\n        self.root.color = Color.BLACK\n\n    def _balance(self, node):\n        if node.right.is_red() and not node.left.is_red():\n            node = self._rotate_left(node)\n        if node.left.is_red() and node.left.left.is_red():\n            node = self._rotate_right(node)\n        if node.left.is_red() and node.right.is_red():\n            node = self._flip_colors(node)\n        return node\n\n    def _rotate_left(self, node):\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        return x\n\n    def _rotate_right(self, node):\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        return x\n\n    def _flip_colors(self, node):\n        node.flip_color()\n        node.left.flip_color()\n        node.right.flip_color()\n        return node\n\n    def remove(self, value):\n        def _remove(node):\n            if node is Leaf:\n                return\n            if node.value > value:\n                _remove(node.left)\n            elif node.value < value:\n                _remove(node.right)\n            else:\n                node.valid = False\n\n        _remove(self.root)\n\n    def count(self, min_, max_):\n        def _range(node):\n            if node is Leaf:\n                return 0\n\n            if node.value > max_:\n                return _range(node.left)\n            elif node.value < min_:\n                return _range(node.right)\n            else:\n                count = _range(node.left) + _range(node.right)\n                if node.valid:\n                    count += 1\n                return count\n\n        return _range(self.root)\n\n    def __str__(self):\n        return str(self.root)\n\n\ndef count_intersections(segments):\n    segments.sort()\n    tree = RedBlackBST()\n    count = 0\n    for seg in segments:\n        x, action, y = seg\n        if action == Action.SEARCH:\n            count += tree.count(*y)\n        elif action == Action.ADD:\n            tree.add(y)\n        elif action == Action.REMOVE:\n            tree.remove(y)\n\n    return count\n\n\ndef run():\n    n = int(input())\n    segs = []\n\n    for _ in range(n):\n        x1, y1, x2, y2 = [int(i) for i in input().split()]\n        if x1 > x2 or y1 > y2:\n            x1, x2 = x2, x1\n            y1, y2 = y2, y1\n        if x1 == x2:\n            segs.append((x1, Action.SEARCH, (y1, y2)))\n        else:\n            segs.append((x1, Action.ADD, y1))\n            segs.append((x2, Action.REMOVE, y2))\n\n    print(count_intersections(segs))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    # point[2]: 1; left, 2; lower, 3; upper, 4; right\n    if y1 < y2:\n        p1 = (x1, y1, 2)\n        p2 = (x2, y2, 3)\n    elif y1 > y2:\n        p1 = (x1, y1, 3)\n        p2 = (x2, y2, 2)\n    elif x1 < x2:\n        p1 = (x1, y1, 1)\n        p2 = (x2, y2, 4)\n    else:\n        p1 = (x1, y1, 4)\n        p2 = (x2, y2, 1)\n    EP += [p1, p2]\n\n# Sweep function\nimport bisect\n\ndef manhattan_intersection(point_list):\n    point_list.sort(key = lambda p: (p[1], p[0], p[2]))\n    T = []\n    cnt = 0\n    flag = False\n    for p in point_list:\n        position = p[2]\n        if position == 3:\n            T.remove(p[0])\n            if flag:\n                cnt += 1\n        elif position == 2:\n            bisect.insort(T, p[0])\n        elif position == 4:\n            cnt += bisect.bisect(T, p[0]) - left_end\n            flag = False\n        else:\n            left_end = bisect.bisect_left(T, p[0])\n            flag = True\n    print(cnt)\n\n# Output\nmanhattan_intersection(EP)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn = input()\n\ndata = [0]*(n+1)\ndef get(i):\n    r = 0\n    while i>0:\n        r += data[i]\n        i -= i & -i\n    return r\ndef add(i, x):\n    while i <= n:\n        data[i] += x\n        i += i & -i\n\nH = []\nV = []\ns = set()\nfor i in xrange(n):\n    x1, y1, x2, y2 = map(int, raw_input().split())\n    if x1 == x2:\n        if y1 > y2: y1, y2 = y2, y1\n        V.append((x1, y1, y2))\n    else:\n        if x1 > x2: x1, x2 = x2, x1\n        H.append((x1, y1, 1))\n        H.append((x2+1, y1, -1))\n        s.add(y1)\nys = sorted(s)\nymap = {e: i for i, e in enumerate(ys)}.__getitem__\nV.sort(); H.sort()\n\nans = 0\nidx_h = 0; hn = len(H)\nfor x, y1, y2 in V:\n    while idx_h < hn and H[idx_h][0] <= x:\n        add(ymap(H[idx_h][1])+1, H[idx_h][2])\n        idx_h += 1\n    idx_l = bisect(ys, y1)\n    idx_r = bisect(ys, y2+1)\n    ans += get(idx_r) - get(idx_l)\nprint ans"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn = input()\n\ndata = [0]*(n+1)\ndef get(i):\n    r = 0\n    while i>0:\n        r += data[i]\n        i -= i & -i\n    return r\ndef add(i, x):\n    while i <= n:\n        data[i] += x\n        i += i & -i\n\nH = []\nV = []\ns = set()\nfor i in xrange(n):\n    x1, y1, x2, y2 = map(int, raw_input().split())\n    if x1 == x2:\n        V.append((x1, y1, y2))\n    else:\n        H.append((x1, y1, 1))\n        H.append((x2+1, y2, -1))\n        s.add(y1)\nys = sorted(s)\nymap = {e: i for i, e in enumerate(ys)}.__getitem__\nV.sort(); H.sort()\n\nans = 0\nidx_h = 0; hn = len(H)\nfor x, y1, y2 in V:\n    while idx_h < hn and H[idx_h][0] <= x:\n        add(ymap(H[idx_h][1])+1, H[idx_h][2])\n        idx_h += 1\n    idx_l = bisect(ys, y1)\n    idx_r = bisect(ys, y2+1)\n    ans += get(idx_r) - get(idx_l)\nprint ans"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn = input()\n\ndata = [0]*(n+1)\ndef get(i):\n    r = 0\n    while i>0:\n        r += data[i]\n        i -= i & -i\n    return r\ndef add(i, x):\n    while i <= n:\n        data[i] += x\n        i += i & -i\n\nH = []\nV = []\ns = set()\nfor i in xrange(n):\n    x1, y1, x2, y2 = map(int, raw_input().split())\n    if x1 == x2:\n        if y1 > y2: y1, y2 = y2, y1\n        V.append((x1, y1, y2))\n    else:\n        if x1 > x2: x1, x2 = x2, x1\n        H.append((x1, y1, 1))\n        H.append((x2+1, y1, -1))\n        s.add(y1)\nys = [-10**18] + sorted(s)\nymap = {e: i for i, e in enumerate(ys)}.__getitem__\nV.sort(); H.sort()\n\nans = 0\nidx_h = 0; hn = len(H)\nfor x, y1, y2 in V:\n    while idx_h < hn and H[idx_h][0] <= x:\n        add(ymap(H[idx_h][1]), H[idx_h][2])\n        idx_h += 1\n    idx_l = bisect(ys, y1-1)-1\n    idx_r = bisect(ys, y2)-1\n    ans += get(idx_r) - get(idx_l)\nprint ans"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\nimport bisect\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def __truediv__(self, scalar):\n        return Vector2(self.x / scalar, self.y / scalar)\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) / abs(p2 - p1)\n    base = math.sqrt(c.r * c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\n\ndef polar(r, a):\n    return Vector2(r * math.cos(a), r * math.sin(a))\n\n\ndef getCrossPointsCircle(c1, c2):\n    base = c2.c - c1.c\n    d = abs(base)\n    a = math.acos((c1.r**2 + d**2 - c2.r**2) / (2 * c1.r * d))\n    t = math.atan2(base.y, base.x)\n    return [c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)]\n\n\ndef contains(g, p):\n    n = len(g)\n    x = 0\n    for i in range(n):\n        a = g[i] - p\n        b = g[(i + 1) % n] - p\n        if a.cross(b) == 0 and a.dot(b) <= 0:\n            return 1\n        if a.y > b.y:\n            a, b = b, a\n        if a.y <= 0 and b.y > 0 and a.cross(b) > 0:\n            x += 1\n\n    if x % 2 == 1:\n        return 2\n    else:\n        return 0\n\n\ndef andrewScan(s):\n    u = []\n    l = []\n    s = sorted(s, key=lambda x: (x.x, x.y))\n    if len(s) < 3:\n        return s\n    u.append(s[0])\n    u.append(s[1])\n    l.append(s[-1])\n    l.append(s[-2])\n\n    for i in range(2, len(s)):\n        for n in range(len(u), 1, -1):\n            if ccw(u[n - 2], u[n - 1], s[i]) != 1:\n                break\n            else:\n                u.pop()\n        u.append(s[i])\n\n    for i in range(len(s) - 3, -1, -1):\n        for n in range(len(l), 1, -1):\n            if ccw(l[n - 2], l[n - 1], s[i]) != 1:\n                break\n            else:\n                l.pop()\n        l.append(s[i])\n\n    ans = l + u[1:-1]\n    ans.reverse()\n    return ans\n\nclass EndPoint():\n    def __init__(self, p, seg, st):\n        self.p = p\n        self.seg = seg\n        self.st = st\n    \n\nif __name__ == '__main__':\n\n    n = int(input())\n    EP = []\n    S = []\n    for i in range(n):\n        a, b, c, d = map(int, input().split())\n        if a == c: # y軸と平行\n            EP.append(EndPoint(Vector2(a, min(b, d)), i, 0)) # bottom\n            EP.append(EndPoint(Vector2(a, max(b, d)), i, 3)) # top\n            S.append([Vector2(a, max(b, d)), Vector2(a, min(b, d))])\n        else: # x軸と平行\n            EP.append(EndPoint(Vector2(min(a, c), b), i, 1)) # left\n            EP.append(EndPoint(Vector2(max(a, c), b), i, 2)) # right\n            S.append([Vector2(min(a, c), b), Vector2(max(a, c), b)])\n    \n    EP = sorted(EP, key=lambda x: (x.p.y, x.st))\n    BT = []\n    cnt = 0\n    for e in EP:\n        if e.st == 3: # top\n            BT.remove(e.p.x)\n        elif e.st == 0: # bottom\n            bisect.insort_left(BT, e.p.x)\n        elif e.st == 1: # left\n            l = bisect.bisect_left(BT, S[e.seg][0].x)\n            r = bisect.bisect_right(BT, S[e.seg][1].x)\n            cnt += r-l\n\n    print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    # point[2] corresponds to the position of the end point.\n    # 1 is left, 2 is lower, 3 is upper and 4 is right.\n    if y1 < y2:\n        p1 = (x1, y1, 2)\n        p2 = (x2, y2, 3)\n    elif y1 > y2:\n        p1 = (x1, y1, 3)\n        p2 = (x2, y2, 2)\n    elif x1 < x2:\n        p1 = (x1, y1, 1)\n        p2 = (x2, y2, 4)\n    else:\n        p1 = (x1, y1, 4)\n        p2 = (x2, y2, 1)\n    EP += [p1, p2]\n\n# Sweep function\nimport bisect\n\ndef manhattan_intersection(point_list):\n    point_list.sort(key = lambda p: (p[1], p[0], p[2]))\n    T = []\n    cnt = 0\n    flag = False\n    for p in point_list:\n        position = p[2]\n        if position == 3:\n            i = bisect.bisect_left(T, p[0])\n            T.pop(i)\n            if flag:\n                cnt += 1\n        elif position == 2:\n            bisect.insort(T, p[0])\n        elif position == 4:\n            cnt += bisect.bisect(T, p[0]) - left_end\n            flag = False\n        else:\n            left_end = bisect.bisect_left(T, p[0])\n            flag = True\n    print(cnt)\n\n# Output\nmanhattan_intersection(EP)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nreadline = stdin.readline\n\n\n#readline = open('???.txt').readline\n\nVERTICAL_LOW, HORIZONTAL, VERTICAL_HIGH = 0, 1, 2\n\nimport math\nclass segment_tree:\n    \n    # self.table is 1-indexed\n    # math.log2 not implemented 3.2.3\n    def __init__(self, size):\n        self.offset = 2 ** math.ceil(math.log(size, 2))\n        self.table = [0] * self.offset * 2\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.table[2 * i] + self.table[2 * i + 1]\n\n    # [l, r] closed-interval\n    def sum(self, l, r):\n        return sum(self.__range(l,r))\n\n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n        \n    def add(self, i, x):\n        i += self.offset\n        self.table[i] += x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.table[2 * i] + self.table[2 * i + 1]\n\ndef main():\n    n = int(readline())\n    p = [list(map(int, readline().split())) for _ in range(n)]\n    x = set(x1 for x1, y1, x2, y2 in p) | set(x2 for x1, y1, x2, y2 in p)\n    c = {xi:i for i, xi in enumerate(sorted(x))}\n    que = []\n    for x1, y1, x2, y2 in p:\n        if y1 == y2:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            que.append((y1, HORIZONTAL, c[x1], c[x2]))\n        else:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            x1 = c[x1]\n            que.append((y1, VERTICAL_LOW, x1, None))\n            que.append((y2, VERTICAL_HIGH, x1, None))\n    que.sort(key=itemgetter(0, 1))\n\n    vertical_info = segment_tree(len(x))\n\n    intersection = 0\n    for y1, action, x1, x2 in que:\n        if action == VERTICAL_LOW:\n            vertical_info.add(x1, 1)\n        elif action == HORIZONTAL:\n            intersection += vertical_info.sum(x1, x2)\n        else:\n            vertical_info.add(x1, -1)\n    print(intersection)\nmain()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\nimport bisect\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def __truediv__(self, scalar):\n        return Vector2(self.x / scalar, self.y / scalar)\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) / abs(p2 - p1)\n    base = math.sqrt(c.r * c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\n\ndef polar(r, a):\n    return Vector2(r * math.cos(a), r * math.sin(a))\n\n\ndef getCrossPointsCircle(c1, c2):\n    base = c2.c - c1.c\n    d = abs(base)\n    a = math.acos((c1.r**2 + d**2 - c2.r**2) / (2 * c1.r * d))\n    t = math.atan2(base.y, base.x)\n    return [c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)]\n\n\ndef contains(g, p):\n    n = len(g)\n    x = 0\n    for i in range(n):\n        a = g[i] - p\n        b = g[(i + 1) % n] - p\n        if a.cross(b) == 0 and a.dot(b) <= 0:\n            return 1\n        if a.y > b.y:\n            a, b = b, a\n        if a.y <= 0 and b.y > 0 and a.cross(b) > 0:\n            x += 1\n\n    if x % 2 == 1:\n        return 2\n    else:\n        return 0\n\n\ndef andrewScan(s):\n    u = []\n    l = []\n    s = sorted(s, key=lambda x: (x.x, x.y))\n    if len(s) < 3:\n        return s\n    u.append(s[0])\n    u.append(s[1])\n    l.append(s[-1])\n    l.append(s[-2])\n\n    for i in range(2, len(s)):\n        for n in range(len(u), 1, -1):\n            if ccw(u[n - 2], u[n - 1], s[i]) != 1:\n                break\n            else:\n                u.pop()\n        u.append(s[i])\n\n    for i in range(len(s) - 3, -1, -1):\n        for n in range(len(l), 1, -1):\n            if ccw(l[n - 2], l[n - 1], s[i]) != 1:\n                break\n            else:\n                l.pop()\n        l.append(s[i])\n\n    ans = l + u[1:-1]\n    ans.reverse()\n    return ans\n\nclass EndPoint():\n    def __init__(self, p, seg, st):\n        self.p = p\n        self.seg = seg\n        self.st = st\n    \n\nif __name__ == '__main__':\n\n    n = int(input())\n    EP = []\n    S = []\n    for i in range(n):\n        a, b, c, d = map(int, input().split())\n        if a == c: # y軸と平行\n            EP.append(EndPoint(Vector2(a, min(b, d)), i, 0)) # bottom\n            EP.append(EndPoint(Vector2(a, max(b, d)), i, 3)) # top\n            S.append([Vector2(a, max(b, d)), Vector2(a, min(b, d))])\n        else: # x軸と平行\n            EP.append(EndPoint(Vector2(min(a, c), b), i, 1)) # left\n            EP.append(EndPoint(Vector2(max(a, c), b), i, 2)) # right\n            S.append([Vector2(min(a, c), b), Vector2(max(a, c), b)])\n    \n    EP = sorted(EP, key=lambda x: (x.p.y, x.st))\n    BT = []\n    cnt = 0\n    for e in EP:\n        if e.st == 3: # top\n            indx = bisect.bisect_left(BT, e.p.x)\n            BT.pop(indx)\n            # BT.remove(e.p.x)\n        elif e.st == 0: # bottom\n            bisect.insort_left(BT, e.p.x)\n        elif e.st == 1: # left\n            l = bisect.bisect_left(BT, S[e.seg][0].x)\n            r = bisect.bisect_right(BT, S[e.seg][1].x)\n            cnt += r-l\n\n    print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nreadline = stdin.readline\n\n\n\n\nVERTICAL_LOW, HORIZONTAL, VERTICAL_HIGH = 0, 1, 2\n\nimport math\nclass segment_tree:\n    \n    # self.table is 1-indexed\n    # math.log2 not implemented 3.2.3\n    def __init__(self, dat, query, default=0):\n        self.offset = 2 ** math.ceil(math.log(len(dat), 2))\n        self.table = [default] * self.offset + dat + [default] * (self.offset - len(dat))\n        self.query = query\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.query([self.table[2 * i], self.table[2 * i + 1]])\n\n    # [l, r] closed-interval\n    def find(self, l, r):\n        return self.query(self.__range(l,r))\n\n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n        \n    def update(self, i, x):\n        i += self.offset\n        self.table[i] = x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.query([self.table[2 * i], self.table[2 * i + 1]])\n\ndef main():\n    n = int(readline())\n    p = [list(map(int, readline().split())) for _ in range(n)]\n    x = set(x1 for x1, y1, x2, y2 in p) | set(x2 for x1, y1, x2, y2 in p)\n    c = {xi:i for i, xi in enumerate(x)}\n    que = []\n    for x1, y1, x2, y2 in p:\n        if y1 == y2:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            que.append((y1, HORIZONTAL, c[x1], c[x2]))\n        else:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            x1 = c[x1]\n            que.append((y1, VERTICAL_LOW, x1, None))\n            que.append((y2, VERTICAL_HIGH, x1, None))\n    que.sort(key=itemgetter(0, 1))\n\n    vertical_info = segment_tree([0] * len(x), sum, default=0)\n\n    intersection = 0\n    for y1, action, x1, x2 in que:\n        if action == VERTICAL_LOW:\n            vertical_info.update(x1, 1)\n        elif action == HORIZONTAL:\n            intersection += vertical_info.find(x1, x2)\n        else:\n            vertical_info.update(x1, 0)\n    print(intersection)\nmain()"
  },
  {
    "language": "Python",
    "code": "\nimport operator\nfrom operator import itemgetter\nclass SegmentTree:\n    # http://tsutaj.hatenablog.com/entry/2017/03/29/204841\n    def __init__(self, size, fn=operator.add, default=None, initial_values=None):\n        \"\"\"\n        :param int size:\n        :param callable fn: 区間に適用する関数。引数を 2 つ取る。min, max, operator.xor など\n        :param default:\n        :param list initial_values:\n        \"\"\"\n        default = default or 0\n\n        # size 以上である最小の 2 冪を size とする\n        n = 1\n        while n < size:\n            n *= 2\n        self._size = n\n        self._fn = fn\n\n        self._tree = [default] * (self._size * 2 - 1)\n        if initial_values:\n            i = self._size - 1\n            for v in initial_values:\n                self._tree[i] = v\n                i += 1\n            i = self._size - 2\n            while i >= 0:\n                self._tree[i] = self._fn(self._tree[i * 2 + 1], self._tree[i * 2 + 2])\n                i -= 1\n\n    def set(self, i, value):\n        \"\"\"\n        i 番目に value を設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self._tree[x] = value\n\n        while x > 0:\n            x = (x - 1) // 2\n            self._tree[x] = self._fn(self._tree[x * 2 + 1], self._tree[x * 2 + 2])\n\n    def add(self, i, value):\n        \"\"\"\n        もとの i 番目と value に fn を適用したものを i 番目に設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self.set(i, self._fn(self._tree[x], value))\n\n    def get(self, from_i, to_i=None, k=0, L=None, r=None):\n        \"\"\"\n        [from_i, to_i) に fn を適用した結果を返す\n        :param int from_i:\n        :param int to_i:\n        :param int k: self._tree[k] が、[L, r) に fn を適用した結果を持つ\n        :param int L:\n        :param int r:\n        :return:\n        \"\"\"\n        if to_i is None:\n            return self._tree[self._size - 1 + from_i]\n\n        L = 0 if L is None else L\n        r = self._size if r is None else r\n\n        if from_i <= L and r <= to_i:\n            return self._tree[k]\n\n        if to_i <= L or r <= from_i:\n            return None\n\n        ret_L = self.get(from_i, to_i, k * 2 + 1, L, (L + r) // 2)\n        ret_r = self.get(from_i, to_i, k * 2 + 2, (L + r) // 2, r)\n        if ret_L is None:\n            return ret_r\n        if ret_r is None:\n            return ret_L\n        return self._fn(ret_L, ret_r)\n\n    def __len__(self):\n        return self._size\n\ndef resolve():\n    BOTTOM, HORIZONTAL, TOP = 0, 1, 2\n    N = int(input())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n    # X軸の点を列挙\n    X = set(x1 for x1, y1, x2, y2 in XY) | set(x2 for x1, y1, x2, y2 in XY)\n    # X軸の点を左端から順序付け\n    c = {xi: i for i, xi in enumerate(sorted(X))}\n\n    que = []\n    for x1, y1, x2, y2 in XY:\n        if y1 == y2:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            # 高さが同じ場合、左、右に点がある\n            que.append((y1, HORIZONTAL, c[x1], c[x2]))\n        else:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            x1 = c[x1]\n            # 高さが違う場合、X軸は同じでY軸は高いか、低いかで場合分け\n            que.append((y1, BOTTOM, x1, None))\n            que.append((y2, TOP, x1, None))\n    # yを下から走査するためにソート\n    que.sort(key=itemgetter(0, 1))\n\n    st = SegmentTree(len(X))\n    ans = 0\n    for y, action, x1, x2 in que:\n        if action == BOTTOM:\n            st.add(x1, 1)\n        elif action == TOP:\n            # 判定が終る線分なので削除\n            st.add(x1, -1)\n        else:\n            # X軸の左右の範囲内にある線分を数える\n            ans += st.get(x1, x2+1)\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\ndef memoize(f):\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            cache[x] = f(x)\n        return cache[x]\n\n    return func\n\n\n@memoize\ndef get_bisect(y):\n    return bisect.bisect(vy, y)\n\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\nneg_inf = float('-inf')\n\nfor x, y1, y2 in vx:\n    it1, it2 = get_bisect((y1, x)), get_bisect((y2 + 1,))\n    ans += sum(x1 <= x <= x2 for y, x1, x2 in vy[it1:it2])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nreadline = stdin.readline\n\n\n\nVERTICAL_LOW, HORIZONTAL, VERTICAL_HIGH = 2, 1, 0\n\n\nimport math\nclass segment_tree:\n    \n    # self.table is 1-indexed\n    # math.log2 not implemented 3.2.3\n    def __init__(self, dat, query, default=0):\n        self.offset = 2 ** math.ceil(math.log(len(dat), 2))\n        self.table = [default] * self.offset + dat + [default] * (self.offset - len(dat))\n        self.query = query\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.query([self.table[2 * i], self.table[2 * i + 1]])\n\n    # [l, r] closed-interval\n    def find(self, l, r):\n        return self.query(self.__range(l,r))\n\n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n        \n    def update(self, i, x):\n        i += self.offset\n        self.table[i] = x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.query([self.table[2 * i], self.table[2 * i + 1]])\n\ndef main():\n    n = int(readline())\n    p = [list(map(int, readline().split())) for _ in range(n)]\n    x = set(x1 for x1, y1, x2, y2 in p) | set(x2 for x1, y1, x2, y2 in p)\n    c = {xi:i for i, xi in enumerate(x)}\n    que = []\n    for x1, y1, x2, y2 in p:\n        if y1 == y2:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            que.append((y1, HORIZONTAL, c[x1], c[x2]))\n        else:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            x1 = c[x1]\n            que.append((y1, VERTICAL_LOW, x1, None))\n            que.append((y2, VERTICAL_HIGH, x1, None))\n    que.sort(key=itemgetter(0, 1))\n\n    vertical_info = segment_tree([0] * len(x), sum, default=0)\n\n    intersection = 0\n    for y1, action, x1, x2 in que:\n        if action == VERTICAL_LOW:\n            vertical_info.update(x1, 1)\n        elif action == HORIZONTAL:\n            intersection += vertical_info.find(x1 + 1, x2 - 1)\n        else:\n            vertical_info.update(x1, 0)\n    print(intersection)\nmain()"
  },
  {
    "language": "Python",
    "code": "#線分交差問題\n\nimport bisect\n\nclass BIT:\n    def __init__(self, n):\n        self.tree = [0]*(n+1)\n        self.n = n\n    \n    def add(self, i, v):\n        while i <= self.n:\n            self.tree[i] += v\n            i += i & -i\n        \n    \n    def _sum(self, i):\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i -= i & -i\n        return ret\n    \n    def sum(self, l, h):\n        return self._sum(h) - self._sum(l-1)\n    \nn = int(input())\nvx = []\nxs = set()\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((y1, float('-inf'),x1))\n        vx.append((y2, float('inf'),x2))\n        xs.add(x1)\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vx.append((y1, x1, x2))\nvx.sort()\n\nbit = BIT(len(xs))\nxs = [float('-inf')] + sorted(xs)\nix = {v: i for i, v in enumerate(xs)}\nans = 0\n\nfor y, j, x2 in vx:\n    if j == float('-inf'):\n        bit.add(ix[x2],1)\n    elif j == float('inf'):\n        bit.add(xs.index(x2), -1)\n    else:\n        l = bisect.bisect_left(xs, j)\n        r = bisect.bisect(xs, x2) - 1\n        ans += bit.sum(l, r)\n        \nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    # point[2]: vertical; True / horizontal; False\n    # point[3]: upper or right end; True / lower or left end; False\n    if y1 < y2:\n        p1 = (x1, y1, True, False)\n        p2 = (x2, y2, True, True)\n    elif y1 > y2:\n        p1 = (x1, y1, True, True)\n        p2 = (x2, y2, True, False)\n    elif x1 < x2:\n        p1 = (x1, y1, False, False)\n        p2 = (x2, y2, False, True)\n    else:\n        p1 = (x1, y1, False, True)\n        p2 = (x2, y2, False, False)\n    EP += [p1, p2]\n\n# Sweep function\nimport bisect\n\ndef manhattan_intersection(point_list):\n    point_list.sort(key = lambda p: (p[1], p[0]))\n    T = []\n    cnt = 0\n    flag = False\n    for p in point_list:\n        if p[2]:\n            if p[3]:\n                T.remove(p[0])\n                if flag:\n                    cnt += 1\n            else:\n                bisect.insort(T, p[0])\n        else:\n            if p[3]:\n                cnt += bisect.bisect(T, p[0]) - left_end\n                flag = False\n            else:\n                left_end = bisect.bisect(T, p[0])\n                flag = True\n    print(cnt)\n\n# Output\nmanhattan_intersection(EP)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\nimport bisect\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def __truediv__(self, scalar):\n        return Vector2(self.x / scalar, self.y / scalar)\n\n    def abs2(self):\n        return float(self.x * self.x + self.y * self.y)\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\ndef project(l, p):\n    p1, p2 = l\n    base = p2 - p1\n    hypo = p - p1\n    return p1 + base * (hypo.dot(base) / abs(base)**2)\n\n\nclass Circle():\n    def __init__(self, c, r):\n        self.c = c\n        self.r = r\n\n\ndef getCrossPoints(c, l):\n    pr = project(l, c.c)\n    p1, p2 = l\n    e = (p2 - p1) / abs(p2 - p1)\n    base = math.sqrt(c.r * c.r - (pr - c.c).abs2())\n    return [pr + e * base, pr - e * base]\n\n\ndef polar(r, a):\n    return Vector2(r * math.cos(a), r * math.sin(a))\n\n\ndef getCrossPointsCircle(c1, c2):\n    base = c2.c - c1.c\n    d = abs(base)\n    a = math.acos((c1.r**2 + d**2 - c2.r**2) / (2 * c1.r * d))\n    t = math.atan2(base.y, base.x)\n    return [c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)]\n\n\ndef contains(g, p):\n    n = len(g)\n    x = 0\n    for i in range(n):\n        a = g[i] - p\n        b = g[(i + 1) % n] - p\n        if a.cross(b) == 0 and a.dot(b) <= 0:\n            return 1\n        if a.y > b.y:\n            a, b = b, a\n        if a.y <= 0 and b.y > 0 and a.cross(b) > 0:\n            x += 1\n\n    if x % 2 == 1:\n        return 2\n    else:\n        return 0\n\n\ndef andrewScan(s):\n    u = []\n    l = []\n    s = sorted(s, key=lambda x: (x.x, x.y))\n    if len(s) < 3:\n        return s\n    u.append(s[0])\n    u.append(s[1])\n    l.append(s[-1])\n    l.append(s[-2])\n\n    for i in range(2, len(s)):\n        for n in range(len(u), 1, -1):\n            if ccw(u[n - 2], u[n - 1], s[i]) != 1:\n                break\n            else:\n                u.pop()\n        u.append(s[i])\n\n    for i in range(len(s) - 3, -1, -1):\n        for n in range(len(l), 1, -1):\n            if ccw(l[n - 2], l[n - 1], s[i]) != 1:\n                break\n            else:\n                l.pop()\n        l.append(s[i])\n\n    ans = l + u[1:-1]\n    ans.reverse()\n    return ans\n\nclass EndPoint():\n    def __init__(self, p, seg, st):\n        self.p = p\n        self.seg = seg\n        self.st = st\n    \n\nif __name__ == '__main__':\n\n    n = int(input())\n    EP = []\n    S = []\n    for i in range(n):\n        a, b, c, d = map(int, input().split())\n        if a == c: # y軸と平行\n            EP.append(EndPoint(Vector2(a, min(b, d)), i, 3)) # top\n            EP.append(EndPoint(Vector2(a, max(b, d)), i, 0)) # bottom\n            S.append([Vector2(a, max(b, d)), Vector2(a, min(b, d))])\n        else: # x軸と平行\n            EP.append(EndPoint(Vector2(min(a, c), b), i, 1)) # left\n            EP.append(EndPoint(Vector2(max(a, c), b), i, 2)) # right\n            S.append([Vector2(min(a, c), b), Vector2(max(a, c), b)])\n    \n    EP = sorted(EP, key=lambda x: (x.p.y, x.st))\n    BT = []\n    cnt = 0\n    for e in EP:\n        if e.st == 0:\n            BT.remove(e.p.x)\n        elif e.st == 3:\n            bisect.insort_left(BT, e.p.x)\n        elif e.st == 1:\n            l = bisect.bisect_left(BT, S[e.seg][0].x)\n            r = bisect.bisect_right(BT, S[e.seg][1].x)\n            cnt += r-l\n\n    print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\ndef memoize(f):\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            cache[x] = f(x)\n        return cache[x]\n\n    return func\n\n\n@memoize\ndef get_bisect(y):\n    return bisect.bisect(vy, (y,))\n\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\n\nfor x, y1, y2 in vx:\n    it1, it2 = get_bisect(y1), get_bisect(y2 + 1)\n    ans += sum(1 for y, x1, x2 in vy[it1:it2] if x1 <= x <= x2)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Vector:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n        \n    def __add__(self,other):\n        return Vector(self.x+other.x,self.y+other.y)\n    \n    def __sub__(self,other):\n        return Vector(self.x-other.x,self.y-other.y)\n    \n    def __mul__(self,scalar):\n        return Vector(self.x*scalar,self.y*scalar)\n    def __rmul__(self, scalar):\n        return Vector(self.x*scalar,self.y*scalar)\n    \n   \n    def __repr__(self):\n        return str([self.x,self.y])\n        \n    def norm_2(self):\n        return dot(self,self)\n    \n    def norm(self):\n        return math.sqrt(self.norm_2())\n    \ndef v_sum(v1,v2):\n    return Vector(v1.x+v2.x,v1.y+v2.y) \ndef scalar_multi(k,v):\n    return Vector(k*v.x,k*v.y)\ndef v_diff(v1,v2):\n    return v_sum(v1,scalar_multi(-1,v2))\n    \ndef dot(vector1,vector2):\n    return vector1.x*vector2.x+vector1.y*vector2.y\n\ndef cross(vector1,vector2):\n    return vector1.x*vector2.y-vector1.y*vector2.x\n\n\nimport bisect\n\nclass EndPoint(Vector):\n    def __init__(self,x,y,state):\n        super().__init__(x,y)\n        self.state = state\n        '''\n        state 0 bottom\n        state 1 top\n        state 2 left\n        state 3 right\n        '''\n        return\n    \nclass Segment:\n    def __init__(self,p1,p2):\n        if p1.x<p2.x:\n            self.p1 = p1\n            self.p2 = p2\n        else:\n            self.p1 = p2\n            self.p2 = p1\n        return\n    \n    \ndef sorting(p):\n    if isinstance(p,Segment):\n        return p.p1.y+0.1\n    else:\n        if p.state == 0:\n            return p.y\n        elif p.state == 1:\n            return p.y+0.2\n    \n    \n    \n\nn = int(input())\npoints = []\nfor i in range(n):\n    x1,y1,x2,y2 = map(int,input().split())\n    if x1 == x2:\n        if y1<y2:\n            points.append(EndPoint(x1,y1,0))\n            points.append(EndPoint(x2,y2,1))\n        else:\n            points.append(EndPoint(x1,y1,1))\n            points.append(EndPoint(x2,y2,0))\n    else:\n        if x1<x2:\n            points.append(Segment(EndPoint(x1,y1,2),EndPoint(x2,y2,3)))\n        else:\n            points.append(Segment(EndPoint(x1,y1,3),EndPoint(x2,y2,2)))\n        \npoints.sort(key = lambda x:sorting(x))\n\nT = []\ncount = 0\nfor i in range(len(points)):\n    if isinstance(points[i],Segment):\n        left = bisect.bisect_left(T,points[i].p1.x)\n        right = bisect.bisect_right(T,points[i].p2.x)\n        count += right-left\n    else:\n        if points[i].state == 0:\n            bisect.insort(T,points[i].x)\n        elif points[i].state == 1:\n            index=bisect.bisect_left(T,points[i].x)\n            T.pop(index)\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nreadline = stdin.readline\n\n\n\nVERTICAL_LOW, HORIZONTAL, VERTICAL_HIGH = 0, 1, 2\n\n# TODO:????????????????????£\n# TODO:?????¶??????\nimport math\nclass segment_tree:\n    \n    # self.table is 1-indexed\n    # math.log2 not implemented 3.2.3\n    def __init__(self, size):\n        self.offset = 2 ** math.ceil(math.log(size, 2))\n        self.table = [0] * self.offset * 2\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.table[2 * i] + self.table[2 * i + 1]\n\n    # [l, r] closed-interval\n    def sum(self, l, r):\n        return sum(self.__range(l,r))\n\n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n        \n    def add(self, i, x):\n        i += self.offset\n        self.table[i] += x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.table[2 * i] + self.table[2 * i + 1]\n\ndef main():\n    n = int(readline())\n    p = [list(map(int, readline().split())) for _ in range(n)]\n    x = set(x1 for x1, y1, x2, y2 in p) | set(x2 for x1, y1, x2, y2 in p)\n    c = {xi:i for i, xi in enumerate(x)}\n    que = []\n    for x1, y1, x2, y2 in p:\n        if y1 == y2:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            que.append((y1, HORIZONTAL, c[x1], c[x2]))\n        else:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            x1 = c[x1]\n            que.append((y1, VERTICAL_LOW, x1, None))\n            que.append((y2, VERTICAL_HIGH, x1, None))\n    que.sort(key=itemgetter(0, 1))\n\n    vertical_info = segment_tree(len(x))\n\n    intersection = 0\n    for y1, action, x1, x2 in que:\n        if action == VERTICAL_LOW:\n            vertical_info.add(x1, 1)\n        elif action == HORIZONTAL:\n            intersection += vertical_info.sum(x1, x2)\n        else:\n            vertical_info.add(x1, -1)\n    print(intersection)\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\nreadline = sys.stdin.readline\nn = int(readline())\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\nh_num = 0\nfor _ in [0] * n:\n    x1, y1, x2, y2 = (map(int, readline().split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n        vs_x.add(x1)\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n        h_num += 1\nclass BinaryIndexedTree:\n    __slots__ = ('data', 'num')\n    def __init__(self, n):\n        self.data = [0] * (n + 1)\n        self.num = n\n    def switch(self, i, d):\n        while i <= self.num:\n            self.data[i] += d\n            i += i & -i\n    def _sum(self, i):\n        s = 0\n        while i:\n            s += self.data[i]\n            i -= i & -i\n        return s\n    def seg_sum(self, a, b):\n        return sum(self.data[:b]) - sum(self.data[:a - 1])\nEP.sort()\nBIT = BinaryIndexedTree(len(vs_x))\nvs_x = [l] + sorted(vs_x)\nd_vs_x = {e: i for i, e in enumerate(vs_x)}\ncnt = 0\nfor p in EP:\n    e = p[1]\n    if e == l:\n        BIT.switch(d_vs_x[p[2]], 1)\n    elif e == u:\n        BIT.switch(d_vs_x[p[2]], -1)\n    else:\n        l_x = bisect.bisect_left(vs_x, e)\n        r_x = bisect.bisect(vs_x, p[2]) - 1\n        cnt += BIT.seg_sum(l_x, r_x)\n        h_num -= 1\n    if h_num == 0: break\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\ndef memoize(f):\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            ret = cache[x] = f(x)\n            return ret\n        return cache[x]\n\n    return func\n\n\n@memoize\ndef get_bisect(y):\n    return bisect.bisect(vy, (y, float('-inf')))\n\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\n\nfor x, y1, y2 in vx:\n    it1, it2 = get_bisect(y1), get_bisect(y2 + 1)\n    ans += sum(x1 <= x <= x2 for y, x1, x2 in vy[it1:it2])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n\n# Sweep\nimport bisect\n\nEP.sort()\nBT = []\ncnt = 0\n\nfor p in EP:\n    e = p[1]\n    if e == l:\n        bisect.insort(BT, p[2])\n    elif e == u:\n        i = bisect.bisect_left(BT, p[2])\n        BT.pop(i)\n    else:\n        cnt += bisect.bisect(BT, p[2]) - bisect.bisect_left(BT, e)\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "#線分交差問題\n\nimport bisect\n\nclass BIT:\n    def __init__(self, n):\n        self.tree = [0]*(n+1)\n        self.n = n\n    \n    def add(self, i, v):\n        while i <= self.n:\n            self.tree[i] += v\n            i += i & -i\n        \n    \n    def _sum(self, i):\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i -= i & -i\n        return ret\n    \n    def sum(self, l, h):\n        return self._sum(h) - self._sum(l-1)\n    \nn = int(input())\nvx = []\nxs = set()\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((y1, float('-inf'),x1))\n        vx.append((y2, float('inf'),x2))\n        xs.add(x1)\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vx.append((y1, x1, x2))\nvx.sort()\n\nbit = BIT(len(xs))\nxs = [float('-inf')] + sorted(xs)\nix = {v: i for i, v in enumerate(xs)}\nans = 0\n\nfor y, j, x2 in vx:\n    if j == float('-inf'):\n        bit.add(ix[x2],1)\n    elif j == float('inf'):\n        bit.add(ix[x2], -1)\n    else:\n        l = bisect.bisect_left(xs, j)\n        r = bisect.bisect(xs, x2) - 1\n        ans += bit.sum(l, r)\n        \nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "lass AvlTree(BinarySearchTree):\n    '''An extension t the BinarySearchTree data structure which \n    strives to keep itself balanced '''\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if current.Node.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChile)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)\n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balancefactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(\n            newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.blanceFactor + 1 + max(\n            rotRoot.balanceFactor, 0)\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot   \n                # leftchild??????\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(\n            newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(\n            rotRoot.balanceFactor, 0)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                self.rotateLeft(node.leftchilc)\n                self.rotateRight(node)\n            else:\n                self.rotateRight(node)\n\n    \n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\ncache = {}\n\nfor x, y1, y2 in vx:\n    y2 += 1\n    if y1 not in cache:\n        it1 = cache[y1] = bisect.bisect(vy, (y1, x))\n    else:\n        it1 = cache[y1]\n    if y2 not in cache:\n        it2 = cache[y2] = bisect.bisect(vy, (y2,))\n    else:\n        it2 = cache[y2]\n    ans += sum(x1 <= x <= x2 for y, x1, x2 in vy[it1:it2])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n        vs_x.add(x1)\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n\n# Binary Indexed Tree\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.data = [0] * (n + 1)\n        self.num = n\n\n    def switch(self, i, d):\n        while  i <= self.num:\n            self.data[i] += d\n            i += i & -i\n\n    def _sum(self, i):\n        s = 0\n        while i:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def seg_sum(self, a, b):\n        return self._sum(b) - self._sum(a - 1)\n\n# Sweep\nimport bisect\n\nEP.sort()\nBIT = BinaryIndexedTree(len(vs_x))\nvs_x = [l] + sorted(vs_x)\nd_vs_x = {e: i for i, e in enumerate(vs_x)}\ncnt = 0\n\nfor p in EP:\n    e = p[1]\n    if e == l:\n        BIT.switch(d_vs_x[p[2]], 1)\n    elif e == u:\n        BIT.switch(d_vs_x[p[2]], -1)\n    else:\n        l_x = bisect.bisect_left(vs_x, e)\n        r_x = bisect.bisect(vs_x, p[2]) - 1\n        cnt += BIT.seg_sum(l_x, r_x)\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nr = 1000000001\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if y1 == y2:\n        EP.append((min(x1, x2), l, y1))\n        EP.append((max(x1, x2), r, y1))\n    else:\n        EP.append((x1, min(y1, y2), max(y1, y2)))\n\n# Sweep\nimport bisect\n\nEP.sort()\nBT = []\ncnt = 0\n\nfor p in EP:\n    y1 = p[1]\n    if y1 == l:\n        bisect.insort(BT, p[2])\n    elif y1 == r:\n        i = bisect.bisect_left(BT, p[2])\n        BT.pop(i)\n    else:\n        cnt += bisect.bisect(BT, p[2]) - bisect.bisect_left(BT, y1)\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\nreadline = sys.stdin.readline\nn = int(readline())\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\nh_num = 0\nfor _ in [0] * n:\n    x1, y1, x2, y2 = (map(int, readline().split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n        vs_x.add(x1)\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n        h_num += 1\nclass BinaryIndexedTree:\n    __slots__ = ('data', 'num')\n    def __init__(self, n):\n        self.data = [0] * (n + 1)\n        self.num = n\n    def switch(self, i, d):\n        while i <= self.num:\n            self.data[i] += d\n            i += i & -i\n    def _sum(self, i):\n        s = 0\n        while i:\n            s += self.data[i]\n            i -= i & -i\n        return s\n    def seg_sum(self, a, b):\n        return self._sum(b) - self._sum(a - 1)\nEP.sort()\nBIT = BinaryIndexedTree(len(vs_x))\nvs_x = [l] + sorted(vs_x)\nd_vs_x = {e: i for i, e in enumerate(vs_x)}\ncnt = 0\nfor p in EP:\n    e = p[1]\n    if e == l:\n        BIT.switch(d_vs_x[p[2]], 1)\n    elif e == u:\n        BIT.switch(d_vs_x[p[2]], -1)\n    else:\n        l_x = bisect.bisect_left(vs_x, e)\n        r_x = bisect.bisect(vs_x, p[2]) - 1\n        cnt += BIT.seg_sum(l_x, r_x)\n        h_num -= 1\n    if h_num == 0: break\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\ndef memoize(f):\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            cache[x] = f(x)\n        return cache[x]\n\n    return func\n\n\n@memoize\ndef get_bisect(y):\n    return bisect.bisect(vy, (y, float('-inf')))\n\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\n\nfor x, y1, y2 in vx:\n    it1, it2 = get_bisect(y1), get_bisect(y2 + 1)\n    for y, x1, x2 in vy[it1:it2]:\n        if x1 <= x <= x2:\n            ans += 1\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from enum import IntEnum\n\n\nclass Action(IntEnum):\n    ADD = 1\n    SEARCH = 2\n    REMOVE = 3\n\n\nclass Color(IntEnum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass Node:\n    __slots__ = ('value', 'left', 'right', 'color', 'valid')\n\n    def __init__(self, value):\n        self.value = value\n        self.left = Leaf\n        self.right = Leaf\n        self.color = Color.RED\n        self.valid = True\n\n    def flip_color(self):\n        self.color = Color.flip(self.color)\n\n    def is_red(self):\n        return self.color == Color.RED\n\n    def __str__(self):\n        return ('(' + str(self.left) + ', '\n                + str(self.value) + ', ' + str(self.right) + ')')\n\n\nclass LeafNode(Node):\n    def __init__(self):\n        self.value = None\n        self.left = None\n        self.right = None\n        self.color = None\n        self.valid = False\n\n    def flip_color(self):\n        pass\n\n    def is_red(self):\n        return False\n\n    def __str__(self):\n        return 'Leaf'\n\n\nLeaf = LeafNode()\n\n\nclass RedBlackBST:\n    def __init__(self):\n        self.root = Leaf\n\n    def add(self, value):\n        def _add(node):\n            if node is Leaf:\n                node = Node(value)\n            if node.value > value:\n                node.left = _add(node.left)\n            elif node.value < value:\n                node.right = _add(node.right)\n            else:\n                if not node.valid:\n                    node.valid = True\n\n            node = self._balance(node)\n            return node\n\n        self.root = _add(self.root)\n        self.root.color = Color.BLACK\n\n    def _balance(self, node):\n        if node.right.is_red() and not node.left.is_red():\n            node = self._rotate_left(node)\n        if node.left.is_red() and node.left.left.is_red():\n            node = self._rotate_right(node)\n        if node.left.is_red() and node.right.is_red():\n            node = self._flip_colors(node)\n        return node\n\n    def _rotate_left(self, node):\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        return x\n\n    def _rotate_right(self, node):\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        return x\n\n    def _flip_colors(self, node):\n        node.flip_color()\n        node.left.flip_color()\n        node.right.flip_color()\n        return node\n\n    def remove(self, value):\n        def _remove(node):\n            if node is Leaf:\n                return\n            if node.value > value:\n                _remove(node.left)\n            elif node.value < value:\n                _remove(node.right)\n            else:\n                node.valid = False\n\n        _remove(self.root)\n\n    def count(self, min_, max_):\n        def _range(node):\n            if node is Leaf:\n                return 0\n\n            if node.value > max_:\n                return _range(node.left)\n            elif node.value < min_:\n                return _range(node.right)\n            else:\n                count = _range(node.left) + _range(node.right)\n                if node.valid:\n                    count += 1\n                return count\n\n        return _range(self.root)\n\n    def __str__(self):\n        return str(self.root)\n\n\ndef count_intersections(segments):\n    segments.sort()\n    tree = RedBlackBST()\n    count = 0\n    for seg in segments:\n        x, action, y = seg\n        if action == Action.SEARCH:\n            count += tree.count(*y)\n        elif action == Action.ADD:\n            tree.add(y)\n        elif action == Action.REMOVE:\n            tree.remove(y)\n\n    return count\n\n\nn=int(input())\nsegs=[]\n\nfor i in range(n):\n  x1,y1,x2,y2=map(int,input().split())\n  if x1>x2 or y1>y2:\n    x1,x2=x2,x1\n    y1,y2=y2,y1\n  if x1==x2:\n    segs.append((x1,Action.SEARCH,(y1,y2)))\n  else:\n    segs.append((x1,Action.ADD,y1))\n    segs.append((x2,Action.REMOVE,y2))\nprint(count_intersections(segs))\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from enum import IntEnum\n\nclass Action(IntEnum):\n  ADD = 1\n  SEARCH = 2\n  REMOVE = 3\n\nclass Color(IntEnum):\n  BLACK=0\n  RED=1\n\n  @staticmethod\n  def flip(c):\n    return [Color.RED,Color.BLACK][c.value]\n\nclass Node:\n  __slots__ = ('value','left','right','color','valid')\n\n  def __init__(self,value):\n    self.value=value\n    self.left=Leaf\n    self.right=Leaf\n    self.color=Color.RED\n    self.valid=True\n\n  def flip_color(self):\n    self.color==Color.RED\n\n  def is_red(self):\n    return self.color == Color.RED\n\n  def __str__(self):\n    return ('('+str(self.left)+','+str(self.value)+','+str(self.right)+')')\n\nclass LeafNode(Node):\n  def __init__(self):\n    self.value=None\n    self.left=None\n    self.right=None\n    self.color=None\n    self.valid=False\n\n  def flip_color(self):\n    pass\n\n  def is_red(self):\n    return False\n\n  def __str__(self):\n    return 'Leaf'\n\nLeaf=LeafNode()\n\nclass RedBlackBST:\n  def __init__(self):\n    self.root=Leaf\n\n  def add(self,value):\n    def _add(node):\n      if node is Leaf:\n        node=Node(value)\n      if node.value>value:\n        node.left=_add(node.right)\n      elif node.value<value:\n        node.right=_add(node.right)\n      else:\n        if not node.valid:\n          node.valid=True\n      node=self._balance(node)\n      return node\n    self.root=_add(self.root)\n    self.root.color=Color.BLACK\n\n  def _balance(self,node):\n    if node.right.is_red() and not node.left.is_red():\n      node=self._rotate_left(node)\n    if node.left.is_red() and node.left.left.is_red():\n      node=self._rotate_right(node)\n    if node.left.is_red() and node.right.is_red():\n      node = self._flip_colors(node)\n    return node\n\n  def _rotate_left(self,node):\n    x=node.right\n    node.right=x.left\n    x.left=node\n    x.color=node.color\n    node.color=Color.RED\n    return x\n\n  def _rotate_right(self,node):\n    x=node.left\n    node.left=x.right\n    x.right=node\n    x.color=node.color\n    node.color=Color.RED\n    return x\n\n  def _flip_colors(self,node):\n    node.flip_color()\n    node.left.flip_color()\n    node.right.flip_color()\n    return node\n\n  def remove(self,value):\n    def _remove(node):\n      if node is Leaf:\n        return\n      if node.value>value:\n        _remove(node.left)\n      elif node.value<value:\n        _remove(node.right)\n      else:\n        node.valid=False\n    _remove(self.root)\n\n  def count(self,min_,max_):\n    def _range(node):\n      if node is Leaf:\n        return 0\n      if node.value>max_:\n        return _range(node.left)\n      elif node.value<min_:\n        return _range(node.right)\n      else:\n        count= _range(node.left)+_range(node.right)\n        if node.valid:\n          count+=1\n        return count\n    return _range(self.root)\n\n  def __str__(self):\n    return str(self.root)\n\ndef count_intersections(segments):\n  segments.sort()\n  tree=RedBlackBST()\n  count=0\n  for seg in segments:\n    x,action,y=seg\n    if action==Action.SEARCH:\n      count+=tree.count(*y)\n    elif action==Action.ADD:\n      tree.add(y)\n    elif action == Action.REMOVE:\n      tree.remove(y)\n  return count\n\n\nn=int(input())\nsegs=[]\n\nfor i in range(n):\n  x1,y1,x2,y2=map(int,input().split())\n  if x1>x2 or y1>y2:\n    x1,x2=x2,x1\n    y1,y2=y2,y1\n  if x1==x2:\n    segs.append((x1,Action.SEARCH,(y1,y2)))\n  else:\n    segs.append((x1,Action.ADD,y1))\n    segs.append((x2,Action.REMOVE,y2))\nprint(count_intersections(segs))\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\ndef memoize(f):\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            ret = cache[x] = f(x)\n            return ret\n        return cache[x]\n\n    return func\n\n\n@memoize\ndef get_bisect(y):\n    return bisect.bisect(vy, (y, float('-inf')))\n\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\n\nfor x, y1, y2 in vx:\n    it1, it2 = get_bisect(y1), get_bisect(y2 + 1)\n    ans += sum(x1 <= x <= x2 for y, x1, x2 in vy[it1:it2])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import bisect\nimport sys\nfrom typing import List, Tuple, Set\n\n\nclass BIT(object):\n    def __init__(self, n: int) -> None:\n        self.tree = [0] * (n + 1)\n        self.n = n\n\n    def add(self, i: int, v: int) -> None:\n        while i <= self.n:\n            self.tree[i] += v\n            i += i & -i\n\n    def _sum(self, i: int) -> int:\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i -= i & -i\n        return ret\n\n    def sum(self, l: int, h: int) -> int:\n        return self._sum(h) - self._sum(l - 1)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    vx: List[Tuple[int, int, int]] = []\n    x_init_set: Set[int] = set()\n    for _ in range(n):\n        x1, y1, x2, y2 = map(lambda x: int(x), input().split())\n        if x1 == x2:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            vx.append((y1, -sys.maxsize, x1))\n            vx.append((y2, sys.maxsize, x1))\n            x_init_set.add(x1)\n        else:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            vx.append((y1, x1, x2))\n    vx.sort()\n\n    bit = BIT(len(x_init_set))\n    xs = [-sys.maxsize] + sorted(x_init_set)\n    ix = {v: i for i, v in enumerate(xs)}\n    ans = 0\n\n    for y, j, x2 in vx:\n        if j == -sys.maxsize:\n            bit.add(ix[x2], 1)\n        elif j == sys.maxsize:\n            bit.add(ix[x2], -1)\n        else:\n            i1 = bisect.bisect_left(xs, j)\n            i2 = bisect.bisect(xs, x2) - 1\n            ans += bit.sum(i1, i2)\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\nh_num = 0\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n        vs_x.add(x1)\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n        h_num += 1\n\n# Binary Indexed Tree\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.data = [0] * (n + 1)\n        self.num = n\n\n    def switch(self, i, d):\n        while  i <= self.num:\n            self.data[i] += d\n            i += i & -i\n\n    def _sum(self, i):\n        s = 0\n        while i:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def seg_sum(self, a, b):\n        return self._sum(b) - self._sum(a - 1)\n\n# Sweep\nimport bisect\n\nEP.sort()\nBIT = BinaryIndexedTree(len(vs_x))\nvs_x = [l] + sorted(vs_x)\nd_vs_x = {e: i for i, e in enumerate(vs_x)}\ncnt = 0\n\nfor p in EP:\n    e = p[1]\n    if e == l:\n        BIT.switch(d_vs_x[p[2]], 1)\n    elif e == u:\n        BIT.switch(d_vs_x[p[2]], -1)\n    else:\n        l_x = bisect.bisect_left(vs_x, e)\n        r_x = bisect.bisect(vs_x, p[2]) - 1\n        cnt += BIT.seg_sum(l_x, r_x)\n        h_num -= 1\n    if h_num == 0:\n        break\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nn = int(input())\nvx, vy = [], []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vy.append((y1, x1, x2))\nvy.sort()\n\nans = 0\n\nfor x, y1, y2 in vx:\n    it1 = bisect.bisect(vy, (y1, float('-inf')))\n    it2 = bisect.bisect(vy, (y2 + 1, float('-inf')))\n    for y, x1, x2 in vy[it1:it2]:\n        if x1 <= x <= x2:\n            ans += 1\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\nclass BIT:\n    def __init__(self, n):\n        self.tree = [0] * (n + 1)\n        self.n = n\n\n    def add(self, i, v):\n        while i <= self.n:\n            self.tree[i] += v\n            i += i & -i\n\n    def _sum(self, i):\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i -= i & -i\n        return ret\n\n    def sum(self, l, h):\n        return self._sum(h) - self._sum(l - 1)\n\n\nn = int(input())\nvx = []\nxs = set()\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        vx.append((y1, float('-inf'), x1))\n        vx.append((y2, float('inf'), x1))\n        xs.add(x1)\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        vx.append((y1, x1, x2))\nvx.sort()\n\nbit = BIT(len(xs))\nxs = [float('-inf')] + sorted(xs)\nix = {v: i for i, v in enumerate(xs)}\nans = 0\n\nfor y, j, x2 in vx:\n    if j == float('-inf'):\n        bit.add(ix[x2], 1)\n    elif j == float('inf'):\n        bit.add(ix[x2], -1)\n    else:\n        i1 = bisect.bisect_left(xs, j)\n        i2 = bisect.bisect(xs, x2) - 1\n        ans += bit.sum(i1, i2)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n\n# Sweep\nimport bisect\n\nEP.sort()\nBT = []\ncnt = 0\n\nfor p in EP:\n    x1 = p[1]\n    if x1 == l:\n        bisect.insort(BT, p[2])\n    elif x1 == u:\n        i = bisect.bisect_left(BT, p[2])\n        BT.pop(i)\n    else:\n        cnt += bisect.bisect(BT, p[2]) - bisect.bisect_left(BT, x1)\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport math\n\nclass Vector:\n    def __init__(self, x=None, y=None):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    # can't  apply \"number * Vector\" but \"Vector * number\"\n    def __mul__(self, k):\n        return Vector(self.x * k, self.y * k)\n\n    def __truediv__(self, k):\n        return Vector(self.x / k, self.y / k)\n\n    def __gt__(self, other):\n        return self.x > other.x and self.y > other.yb\n\n    def __lt__(self, other):\n        return self.x < other.x and self.y < other.yb\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    # usually cross operation return Vector but it returns scalor\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\n    def rotate(self, theta):\n        return Vector(self.x * math.cos(theta)\n                               - self.y * math.sin(theta),\n                               self.x * math.sin(theta)\n                               + self.y * math.cos(theta))\n\nclass Point(Vector):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass Segment:\n    def __init__(self, p1=Point(0, 0), p2=Point(1, 1)):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Line(Segment):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass EndPoint:\n    def __init__(self, p1, p2):\n        self.point = p1\n        self.otherend = p2\n        if p1.x == p2.x:\n            if p1.y > p2.y:\n                self.type = 2 # 'Vertical Top'\n            else:\n                self.type = 0 # 'Vertical Bottom'\n        elif p1.y == p2.y:\n            if p1.x < p2.x:\n                self.type = 1 # 'Horizontal Left'\n            else:\n                self.type = 3 # 'Horizontal Right'\n\ndef manhattan_geometry(S):\n    end_points = []\n    count = 0\n    for i in S:\n        ep1 = EndPoint(i.p1, i.p2)\n        ep2 = EndPoint(i.p2, i.p1)\n        if ep1.type != 3:\n            end_points.append(ep1)\n        if ep2.type != 3:\n            end_points.append(ep2)\n\n    end_points.sort(key=lambda ep: (ep.point.y, ep.type, ep.point.x))\n    T = set({})\n    for i in end_points:\n        if i.type == 2: # 'Vertical Top'\n            T.remove(i.point.x)\n        if i.type == 0: # 'Vertical Bottom'\n            T.add(i.point.x)\n        if i.type == 1: # 'Horizontal Left'\n            inclueded_x = {j for j in T if j >= i.point.x and j <= i.otherend.x}\n            count = count + len(inclueded_x)\n    return count\n\ndef read_segments(n):\n    S = []\n    for _ in range(n):\n        line = stdin.readline().strip().split()\n        p0 = Vector(int(line[0]), int(line[1]))\n        p1 = Vector(int(line[2]), int(line[3]))\n        s = Segment(p0, p1)\n        S.append(s)\n    return S\n\ndef __main():\n    n = int(input())\n    S = read_segments(n)\n    count = manhattan_geometry(S)\n    print(count)\n\nif __name__ == '__main__':\n    __main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\ndef main():\n    num_segments = int(input())\n    events = [None] * num_segments * 2\n    num_events = 0\n\n    lines = sys.stdin.readlines()\n    for line in lines:\n        pt1_x, pt1_y, pt2_x, pt2_y = map(int, line.split())\n        if pt1_x == pt2_x:\n            if pt1_y > pt2_y:\n                pt1_y, pt2_y = pt2_y, pt1_y\n            events[num_events] = (pt1_y, pt1_x, 0)\n            num_events += 1\n            events[num_events] = (pt2_y, pt2_x, 2)\n            num_events += 1\n        elif pt1_y == pt2_y:\n            if pt1_x > pt2_x:\n                pt1_x, pt2_x = pt2_x, pt1_x\n            events[num_events] = (pt1_y, (pt1_x, pt2_x), 1)\n            num_events += 1\n        else:\n            raise AssertionError\n\n    events = events[:num_events]\n    events.sort(key=lambda x: (x[0], x[2]))\n\n    cross_count = 0\n    vertical = []\n    for event in events:\n        if event[2] == 0:\n            bisect.insort_left(vertical, event[1])\n        elif event[2] == 2:\n            i = bisect.bisect_left(vertical, event[1])\n            del vertical[i]\n        else:   # horizontal\n            left_x, right_x = event[1][0], event[1][1]\n            for v_x in vertical:\n                if left_x <= v_x <= right_x:\n                    cross_count += 1\n    print(cross_count)\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom sys import stdin\nfrom typing import Any, List, Optional\n\nfrom enum import IntEnum\n\n\nclass EPStatus(IntEnum):\n    BOTTOM = 0\n    LEFT = 1\n    RIGHT = 2\n    TOP = 3\n\n\nclass Point:\n    def __init__(self, x: float = 0.0, y: float = 0.0) -> None:\n        self.x = x\n        self.y = y\n\n    def __repr__(self) -> str:\n        return \"({}, {})\".format(self.x, self.y)\n\n\nclass Segment:\n    def __init__(\n        self, p1: Optional[Point] = None, p2: Optional[Point] = None\n    ) -> None:\n        self.p1 = Point() if p1 is None else p1\n        self.p2 = Point() if p2 is None else p2\n\n    def __repr__(self) -> str:\n        return \"({}, {})\".format(self.p1, self.p2)\n\n\nclass EndPoint:\n    def __init__(self, p: Point, seg: Segment, st: EPStatus):\n        self.p = p\n        self.seg = seg\n        self.st = st\n\n    def __lt__(self, other: \"EndPoint\") -> bool:\n        return (\n            self.st < other.st\n            if self.p.y == other.p.y\n            else self.p.y < other.p.y\n        )\n\n\nclass Node:\n    def __init__(\n        self,\n        key: Any,\n        parent: Optional[\"Node\"] = None,\n        left: Optional[\"Node\"] = None,\n        right: Optional[\"Node\"] = None,\n    ) -> None:\n        self.key = key\n        self.parent = parent\n        self.left = left\n        self.right = right\n\n    def __str__(self) -> str:\n        return \"({} {} {})\".format(self.key, self.left, self.right)\n\n    def minimum_child(self) -> \"Node\":\n        x = self\n        while x.left is not None:\n            x = x.left\n        return x\n\n    def successor(self) -> Optional[\"Node\"]:\n        if self.right is not None:\n            return self.right.minimum_child()\n\n        x = self\n        y = x.parent\n        while y is not None and x == y.right:\n            x = y\n            y = y.parent\n        return y\n\n\nclass Tree:\n    def __init__(self) -> None:\n        self.root: Optional[Node] = None\n\n    def __str__(self) -> str:\n        return str(self.root) if self.root else \"()\"\n\n    def insert(self, z: Node) -> None:\n        y = None\n        x = self.root\n\n        while x is not None:\n            y = x\n            x = x.left if z.key < x.key else x.right\n\n        z.parent = y\n        if y is None:\n            self.root = z\n        elif z.key < y.key:\n            y.left = z\n        else:\n            y.right = z\n\n    def find(self, key: Any) -> Optional[Node]:\n        x = self.root\n        while x is not None and key != x.key:\n            x = x.left if key < x.key else x.right\n        return x\n\n    def delete(self, z: Node) -> None:\n        y = z if z.left is None or z.right is None else z.successor()\n        x = y.right if y.left is None else y.left\n\n        if x is not None:\n            x.parent = y.parent\n\n        if y.parent is None:\n            self.root = x\n        elif y == y.parent.left:\n            y.parent.left = x\n        else:\n            y.parent.right = x\n\n        if y != z:\n            z.key = y.key\n\n    def lower_bound(self, key: Any) -> Optional[Node]:\n        x = self.root\n        b: Optional[Node] = None\n\n        while x is not None:\n            if key < x.key:\n                if b is None or x.key < b.key:\n                    b = x\n                x = x.left\n            elif key == x.key:\n                b = x\n                break\n            else:\n                x = x.right\n\n        return b\n\n\ndef manhattanIntersection(S: List[Segment]) -> int:\n    def crosses(x1: float, x2: float) -> int:\n        cnt: int = 0\n        node: Optional[Node] = BT.lower_bound(x1)\n        while node is not None and node.key <= x2:\n            cnt += 1\n            node = node.successor()\n        return cnt\n\n    EP: List[EndPoint] = []\n\n    for s in S:\n        if (s.p1.y == s.p2.y and s.p1.x > s.p2.x) or (\n            s.p1.x == s.p2.x and s.p1.y > s.p2.y\n        ):\n            s.p1, s.p2 = s.p2, s.p1\n\n        if s.p1.y == s.p2.y:\n            EP.append(EndPoint(s.p1, s, EPStatus.LEFT))\n        else:\n            EP.append(EndPoint(s.p1, s, EPStatus.BOTTOM))\n            EP.append(EndPoint(s.p2, s, EPStatus.TOP))\n\n    EP.sort()\n\n    BT = Tree()\n    cnt = 0\n\n    for e in EP:\n        if e.st == EPStatus.TOP:\n            BT.delete(BT.find(e.p.x))\n        elif e.st == EPStatus.BOTTOM:\n            BT.insert(Node(e.p.x))\n        elif e.st == EPStatus.LEFT:\n            cnt += crosses(e.seg.p1.x, e.seg.p2.x)\n\n    return cnt\n\n\ndef main() -> None:\n    S = []\n\n    n = int(stdin.readline())\n    for i in range(n):\n        x1, y1, x2, y2 = [int(x) for x in stdin.readline().split()]\n        S.append(Segment(Point(x1, y1), Point(x2, y2)))\n\n    print(manhattanIntersection(S))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfile_input = sys.stdin\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\nh_num = 0\n\nfor line in file_input:\n  x1, y1, x2, y2 = map(int, line.split())\n  if x1 == x2:\n    if y1 < y2:\n      EP.append((y1, l, x1))\n      EP.append((y2, u, x1))\n    else:\n      EP.append((y1, u, x1))\n      EP.append((y2, l, x1))\n    vs_x.add(x1)\n  else:\n    if x1 < x2:\n      EP.append((y1, x1, x2))\n    else:\n      EP.append((y1, x2, x1))\n    h_num += 1\n\nclass BinaryIndexedTree:\n  def __init__(self, n):\n    self.data = [0] *(n+1)\n    self.num = n\n\n  def switch(self, i, d):\n    while  i <= self.num:\n      self.data[i] += d\n      i += i & -i\n\n  def sum(self, i):\n    s = 0\n    while  i:\n      s += self.data[i]\n      i -= i & -i\n    return s\n\n  def seg_sum(self, a, b):\n    return self.sum(b) - self.sum(a- 1)\n\nimport bisect\n\nEP.sort()\nBIT = BinaryIndexedTree(len(vs_x))\nvs_x = [l] + sorted(vs_x)\nd_vs_x = {e:i for i, e in enumerate(vs_x)}\n\ncnt = 0\n\nfor p in EP:\n  e = p[1]\n  if e== l:\n    BIT.switch(d_vs_x[p[2]], 1)\n  elif e==u:\n    BIT.switch(d_vs_x[p[2]], -1)\n  else:\n    l_x = bisect.bisect_left(vs_x, e)\n    r_x = bisect.bisect(vs_x, p[2]) -1\n    cnt += BIT.seg_sum(l_x,r_x)\n    h_num -= 1\n  if h_num ==0:\n    break\nprint(cnt)\n\n\n#一言：平面操作でユーグリッド空間上の線分交点を求める\n#処理の流れ：入力された線分端点をyを基準に昇順にリストに入れる。→順番に取り出す。→下恥ならBSTに挿入。・上端ならBSTから削除。入れたものがx軸と交差したらそこで探索を開始する。\n#計算量：O(nlogn+k)（二分木探索の計算量nlogn+交点k）\n\n"
  },
  {
    "language": "Python",
    "code": "import cmath\nimport itertools\nimport math\nimport operator\nimport os\nimport sys\nfrom collections import defaultdict\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nPI = cmath.pi\nTAU = cmath.pi * 2\nEPS = 1e-10\n\n\nclass Point:\n    \"\"\"\n    2次元空間上の点\n    \"\"\"\n\n    # 反時計回り側にある\n    CCW_COUNTER_CLOCKWISE = 1\n    # 時計回り側にある\n    CCW_CLOCKWISE = -1\n    # 線分の後ろにある\n    CCW_ONLINE_BACK = 2\n    # 線分の前にある\n    CCW_ONLINE_FRONT = -2\n    # 線分上にある\n    CCW_ON_SEGMENT = 0\n\n    def __init__(self, c: complex):\n        self.c = c\n\n    @property\n    def x(self):\n        return self.c.real\n\n    @property\n    def y(self):\n        return self.c.imag\n\n    @staticmethod\n    def from_rect(x: float, y: float):\n        return Point(complex(x, y))\n\n    @staticmethod\n    def from_polar(r: float, phi: float):\n        return Point(cmath.rect(r, phi))\n\n    def __add__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c + p.c)\n\n    def __iadd__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c += p.c\n        return self\n\n    def __sub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c - p.c)\n\n    def __isub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c -= p.c\n        return self\n\n    def __mul__(self, f: float):\n        return Point(self.c * f)\n\n    def __imul__(self, f: float):\n        self.c *= f\n        return self\n\n    def __truediv__(self, f: float):\n        return Point(self.c / f)\n\n    def __itruediv__(self, f: float):\n        self.c /= f\n        return self\n\n    def __repr__(self):\n        return \"({}, {})\".format(round(self.x, 10), round(self.y, 10))\n\n    def __neg__(self):\n        return Point(-self.c)\n\n    def __eq__(self, p):\n        return abs(self.c - p.c) < EPS\n\n    def __abs__(self):\n        return abs(self.c)\n\n    @staticmethod\n    def ccw(a, b, c):\n        \"\"\"\n        線分 ab に対する c の位置\n        線分上にあるか判定するだけなら on_segment とかのが速い\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point a:\n        :param Point b:\n        :param Point c:\n        \"\"\"\n        b = b - a\n        c = c - a\n        det = b.det(c)\n        if det > EPS:\n            return Point.CCW_COUNTER_CLOCKWISE\n        if det < -EPS:\n            return Point.CCW_CLOCKWISE\n        if b.dot(c) < -EPS:\n            return Point.CCW_ONLINE_BACK\n        if c.norm() - b.norm() > EPS:\n            return Point.CCW_ONLINE_FRONT\n        return Point.CCW_ON_SEGMENT\n\n    def dot(self, p):\n        \"\"\"\n        内積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.x + self.y * p.y\n\n    def det(self, p):\n        \"\"\"\n        外積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.y - self.y * p.x\n\n    def dist(self, p):\n        \"\"\"\n        距離\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return abs(self.c - p.c)\n\n    def norm(self):\n        \"\"\"\n        原点からの距離\n        :rtype: float\n        \"\"\"\n        return abs(self.c)\n\n    def phase(self):\n        \"\"\"\n        原点からの角度\n        :rtype: float\n        \"\"\"\n        return cmath.phase(self.c)\n\n    def angle(self, p, q):\n        \"\"\"\n        p に向いてる状態から q まで反時計回りに回転するときの角度\n        -pi <= ret <= pi\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return (cmath.phase(q.c - self.c) - cmath.phase(p.c - self.c) + PI) % TAU - PI\n\n    def area(self, p, q):\n        \"\"\"\n        p, q となす三角形の面積\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return abs((p - self).det(q - self) / 2)\n\n    def projection_point(self, p, q, allow_outer=False):\n        \"\"\"\n        線分 pq を通る直線上に垂線をおろしたときの足の座標\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_outer: 答えが線分の間になくても OK\n        :rtype: Point|None\n        \"\"\"\n        diff_q = q - p\n        # 答えの p からの距離\n        r = (self - p).dot(diff_q) / abs(diff_q)\n        # 線分の角度\n        phase = diff_q.phase()\n\n        ret = Point.from_polar(r, phase) + p\n        if allow_outer or (p - ret).dot(q - ret) < EPS:\n            return ret\n        return None\n\n    def reflection_point(self, p, q):\n        \"\"\"\n        直線 pq を挟んで反対にある点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n        :param Point p:\n        :param Point q:\n        :rtype: Point\n        \"\"\"\n        # 距離\n        r = abs(self - p)\n        # pq と p-self の角度\n        angle = p.angle(q, self)\n        # 直線を挟んで角度を反対にする\n        angle = (q - p).phase() - angle\n        return Point.from_polar(r, angle) + p\n\n    def on_segment(self, p, q, allow_side=True):\n        \"\"\"\n        点が線分 pq の上に乗っているか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        :rtype: bool\n        \"\"\"\n        if not allow_side and (self == p or self == q):\n            return False\n        # 外積がゼロ: 面積がゼロ == 一直線\n        # 内積がマイナス: p - self - q の順に並んでる\n        return abs((p - self).det(q - self)) < EPS and (p - self).dot(q - self) < EPS\n\n\nclass Line:\n    \"\"\"\n    2次元空間上の直線\n    \"\"\"\n\n    def __init__(self, a: float, b: float, c: float):\n        \"\"\"\n        直線 ax + by + c = 0\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @staticmethod\n    def from_gradient(grad: float, intercept: float):\n        \"\"\"\n        直線 y = ax + b\n        :param grad: 傾き\n        :param intercept: 切片\n        :return:\n        \"\"\"\n        return Line(grad, -1, intercept)\n\n    @staticmethod\n    def from_segment(p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        a = p2.y - p1.y\n        b = p1.x - p2.x\n        c = p2.y * (p2.x - p1.x) - p2.x * (p2.y - p1.y)\n        return Line(a, b, c)\n\n    @property\n    def gradient(self):\n        \"\"\"\n        傾き\n        \"\"\"\n        return INF if self.b == 0 else -self.a / self.b\n\n    @property\n    def intercept(self):\n        \"\"\"\n        切片\n        \"\"\"\n        return INF if self.b == 0 else -self.c / self.b\n\n    def is_parallel_to(self, l):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の外積がゼロ\n        return abs(Point.from_rect(self.a, self.b).det(Point.from_rect(l.a, l.b))) < EPS\n\n    def is_orthogonal_to(self, l):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の内積がゼロ\n        return abs(Point.from_rect(self.a, self.b).dot(Point.from_rect(l.a, l.b))) < EPS\n\n    def intersection_point(self, l):\n        \"\"\"\n        交差する点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\n        :param Line l:\n        :rtype: Point|None\n        \"\"\"\n        a1, b1, c1 = self.a, self.b, self.c\n        a2, b2, c2 = l.a, l.b, l.c\n        det = a1 * b2 - a2 * b1\n        if abs(det) < EPS:\n            # 並行\n            return None\n        x = (b1 * c2 - b2 * c1) / det\n        y = (a2 * c1 - a1 * c2) / det\n        return Point.from_rect(x, y)\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        raise NotImplementedError()\n\n    def has_point(self, p):\n        \"\"\"\n        p が直線上に乗っているかどうか\n        :param Point p:\n        \"\"\"\n        return abs(self.a * p.x + self.b * p.y + self.c) < EPS\n\n\nclass Segment:\n    \"\"\"\n    2次元空間上の線分\n    \"\"\"\n\n    def __init__(self, p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n\n    def norm(self):\n        \"\"\"\n        線分の長さ\n        \"\"\"\n        return abs(self.p1 - self.p2)\n\n    def phase(self):\n        \"\"\"\n        p1 を原点としたときの p2 の角度\n        \"\"\"\n        return cmath.phase(self.p2 - self.p1)\n\n    def is_parallel_to(self, s):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 外積がゼロ\n        return abs((self.p1 - self.p2).det(s.p1 - s.p2)) < EPS\n\n    def is_orthogonal_to(self, s):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 内積がゼロ\n        return abs((self.p1 - self.p2).dot(s.p1 - s.p2)) < EPS\n\n    def intersects_with(self, s, allow_side=True):\n        \"\"\"\n        交差するかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        :param Segment s:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        if self.is_parallel_to(s):\n            # 並行なら線分の端点がもう片方の線分の上にあるかどうか\n            return (s.p1.on_segment(self.p1, self.p2, allow_side) or\n                    s.p2.on_segment(self.p1, self.p2, allow_side) or\n                    self.p1.on_segment(s.p1, s.p2, allow_side) or\n                    self.p2.on_segment(s.p1, s.p2, allow_side))\n        else:\n            # allow_side ならゼロを許容する\n            det_upper = EPS if allow_side else -EPS\n            ok = True\n            # self の両側に s.p1 と s.p2 があるか\n            ok &= (self.p2 - self.p1).det(s.p1 - self.p1) * (self.p2 - self.p1).det(s.p2 - self.p1) < det_upper\n            # s の両側に self.p1 と self.p2 があるか\n            ok &= (s.p2 - s.p1).det(self.p1 - s.p1) * (s.p2 - s.p1).det(self.p2 - s.p1) < det_upper\n            return ok\n\n    def closest_point(self, p):\n        \"\"\"\n        線分上の、p に最も近い点\n        :param Point p:\n        \"\"\"\n        # p からおろした垂線までの距離\n        d = (p - self.p1).dot(self.p2 - self.p1) / self.norm()\n        # p1 より前\n        if d < EPS:\n            return self.p1\n        # p2 より後\n        if -EPS < d - self.norm():\n            return self.p2\n        # 線分上\n        return Point.from_polar(d, (self.p2 - self.p1).phase()) + self.p1\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        return abs(p - self.closest_point(p))\n\n    def dist_segment(self, s):\n        \"\"\"\n        他の線分との最短距離\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\n        :param Segment s:\n        \"\"\"\n        if self.intersects_with(s):\n            return 0.0\n        return min(\n            self.dist(s.p1),\n            self.dist(s.p2),\n            s.dist(self.p1),\n            s.dist(self.p2),\n        )\n\n    def has_point(self, p, allow_side=True):\n        \"\"\"\n        p が線分上に乗っているかどうか\n        :param Point p:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        return p.on_segment(self.p1, self.p2, allow_side=allow_side)\n\n\nclass Polygon:\n    \"\"\"\n    2次元空間上の多角形\n    \"\"\"\n\n    def __init__(self, points):\n        \"\"\"\n        :param list of Point points:\n        \"\"\"\n        self.points = points\n\n    def iter2(self):\n        \"\"\"\n        隣り合う2点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point)]\n        \"\"\"\n        return zip(self.points, self.points[1:] + self.points[:1])\n\n    def iter3(self):\n        \"\"\"\n        隣り合う3点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point, Point)]\n        \"\"\"\n        return zip(self.points,\n                   self.points[1:] + self.points[:1],\n                   self.points[2:] + self.points[:2])\n\n    def area(self):\n        \"\"\"\n        面積\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\n        \"\"\"\n        # 外積の和 / 2\n        dets = []\n        for p, q in self.iter2():\n            dets.append(p.det(q))\n        return abs(math.fsum(dets)) / 2\n\n    def is_convex(self, allow_straight=False, allow_collapsed=False):\n        \"\"\"\n        凸多角形かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :param allow_collapsed: 面積がゼロの場合を許容するか\n        \"\"\"\n        ccw = []\n        for a, b, c in self.iter3():\n            ccw.append(Point.ccw(a, b, c))\n        ccw = set(ccw)\n        if len(ccw) == 1:\n            if ccw == {Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_straight and len(ccw) == 2:\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_collapsed and len(ccw) == 3:\n            return ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_ONLINE_BACK, Point.CCW_ON_SEGMENT}\n        return False\n\n    def has_point_on_edge(self, p):\n        \"\"\"\n        指定した点が辺上にあるか\n        :param Point p:\n        :rtype: bool\n        \"\"\"\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return True\n        return False\n\n    def contains(self, p, allow_on_edge=True):\n        \"\"\"\n        指定した点を含むか\n        Winding Number Algorithm\n        https://www.nttpc.co.jp/technology/number_algorithm.html\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\n        :param Point p:\n        :param bool allow_on_edge: 辺上の点を許容するか\n        \"\"\"\n        angles = []\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return allow_on_edge\n            angles.append(p.angle(a, b))\n        # 一周以上するなら含む\n        return abs(math.fsum(angles)) > EPS\n\n    @staticmethod\n    def convex_hull(points, allow_straight=False):\n        \"\"\"\n        凸包。x が最も小さい点のうち y が最も小さい点から反時計回り。\n        Graham Scan O(N log N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\n        :param list of Point points:\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :rtype: list of Point\n        \"\"\"\n        points = points[:]\n        points.sort(key=lambda p: (p.x, p.y))\n\n        # allow_straight なら 0 を許容する\n        det_lower = -EPS if allow_straight else EPS\n\n        sz = 0\n        #: :type: list of (Point|None)\n        ret = [None] * (len(points) * 2)\n        for p in points:\n            while sz > 1 and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        floor = sz\n        for p in reversed(points[:-1]):\n            while sz > floor and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        ret = ret[:sz - 1]\n\n        if allow_straight and len(ret) > len(points):\n            # allow_straight かつ全部一直線のときに二重にカウントしちゃう\n            ret = points\n        return ret\n\n    @staticmethod\n    def diameter(points):\n        \"\"\"\n        直径\n        凸包構築 O(N log N) + カリパー法 O(N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=ja\n        :param list of Point points:\n        \"\"\"\n        # 反時計回り\n        points = Polygon.convex_hull(points, allow_straight=False)\n        if len(points) == 1:\n            return 0.0\n        if len(points) == 2:\n            return abs(points[0] - points[1])\n\n        # x軸方向に最も遠い点対\n        si = points.index(min(points, key=lambda p: (p.x, p.y)))\n        sj = points.index(max(points, key=lambda p: (p.x, p.y)))\n        n = len(points)\n\n        ret = 0.0\n        # 半周回転\n        i, j = si, sj\n        while i != sj or j != si:\n            ret = max(ret, abs(points[i] - points[j]))\n            ni = (i + 1) % n\n            nj = (j + 1) % n\n            # 2つの辺が並行になる方向にずらす\n            if (points[ni] - points[i]).det(points[nj] - points[j]) > 0:\n                j = nj\n            else:\n                i = ni\n        return ret\n\n    def convex_cut_by_line(self, line_p1, line_p2):\n        \"\"\"\n        凸多角形を直線 line_p1-line_p2 でカットする。\n        凸じゃないといけません\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=ja\n        :param line_p1:\n        :param line_p2:\n        :return: (line_p1-line_p2 の左側の多角形, line_p1-line_p2 の右側の多角形)\n        :rtype: (Polygon|None, Polygon|None)\n        \"\"\"\n        n = len(self.points)\n        line = Line.from_segment(line_p1, line_p2)\n        # 直線と重なる点\n        on_line_points = []\n        for i, p in enumerate(self.points):\n            if line.has_point(p):\n                on_line_points.append(i)\n\n        # 辺が直線上にある\n        has_on_line_edge = False\n        if len(on_line_points) >= 3:\n            has_on_line_edge = True\n        elif len(on_line_points) == 2:\n            # 直線上にある点が隣り合ってる\n            has_on_line_edge = abs(on_line_points[0] - on_line_points[1]) in [1, n - 1]\n        # 辺が直線上にある場合、どっちか片方に全部ある\n        if has_on_line_edge:\n            for p in self.points:\n                ccw = Point.ccw(line_p1, line_p2, p)\n                if ccw == Point.CCW_COUNTER_CLOCKWISE:\n                    return Polygon(self.points[:]), None\n                if ccw == Point.CCW_CLOCKWISE:\n                    return None, Polygon(self.points[:])\n\n        ret_lefts = []\n        ret_rights = []\n        d = line_p2 - line_p1\n        for p, q in self.iter2():\n            det_p = d.det(p - line_p1)\n            det_q = d.det(q - line_p1)\n            if det_p > -EPS:\n                ret_lefts.append(p)\n            if det_p < EPS:\n                ret_rights.append(p)\n            # 外積の符号が違う == 直線の反対側にある場合は交点を追加\n            if det_p * det_q < -EPS:\n                intersection = line.intersection_point(Line.from_segment(p, q))\n                ret_lefts.append(intersection)\n                ret_rights.append(intersection)\n\n        # 点のみの場合を除いて返す\n        l = Polygon(ret_lefts) if len(ret_lefts) > 1 else None\n        r = Polygon(ret_rights) if len(ret_rights) > 1 else None\n        return l, r\n\n\ndef closest_pair(points):\n    \"\"\"\n    最近点対 O(N log N)\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    assert len(points) >= 2\n\n    def _rec(xsorted):\n        \"\"\"\n        :param list of Point xsorted:\n        :rtype: (float, (Point, Point))\n        \"\"\"\n        n = len(xsorted)\n        if n <= 2:\n            return xsorted[0].dist(xsorted[1]), (xsorted[0], xsorted[1])\n        if n <= 3:\n            # 全探索\n            d = INF\n            pair = None\n            for p, q in itertools.combinations(xsorted, r=2):\n                if p.dist(q) < d:\n                    d = p.dist(q)\n                    pair = p, q\n            return d, pair\n\n        # 分割統治\n        # 両側の最近点対\n        ld, lp = _rec(xsorted[:n // 2])\n        rd, rp = _rec(xsorted[n // 2:])\n        if ld <= rd:\n            d = ld\n            ret_pair = lp\n        else:\n            d = rd\n            ret_pair = rp\n\n        mid_x = xsorted[n // 2].x\n        # 中央から d 以内のやつを集める\n        mid_points = []\n        for p in xsorted:\n            # if abs(p.x - mid_x) < d:\n            if abs(p.x - mid_x) - d < -EPS:\n                mid_points.append(p)\n\n        # この中で距離が d 以内のペアがあれば更新\n        mid_points.sort(key=lambda p: p.y)\n        mid_n = len(mid_points)\n        for i in range(mid_n - 1):\n            j = i + 1\n            p = mid_points[i]\n            q = mid_points[j]\n            # while q.y - p.y < d\n            while (q.y - p.y) - d < -EPS:\n                pq_d = p.dist(q)\n                if pq_d < d:\n                    d = pq_d\n                    ret_pair = p, q\n                j += 1\n                if j >= mid_n:\n                    break\n                q = mid_points[j]\n        return d, ret_pair\n\n    return _rec(list(sorted(points, key=lambda p: p.x)))\n\n\ndef closest_pair_randomized(points):\n    \"\"\"\n    最近点対 乱択版 O(N)\n    http://ir5.hatenablog.com/entry/20131221/1387557630\n    グリッドの管理が dict だから定数倍気になる\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    n = len(points)\n    assert n >= 2\n    if n == 2:\n        return points[0].dist(points[1]), (points[0], points[1])\n\n    # 逐次構成法\n    import random\n    points = points[:]\n    random.shuffle(points)\n\n    DELTA_XY = list(itertools.product([-1, 0, 1], repeat=2))\n    grid = defaultdict(list)\n    delta = INF\n    dist = points[0].dist(points[1])\n    ret_pair = points[0], points[1]\n    for i in range(2, n):\n        if delta < EPS:\n            return 0.0, ret_pair\n        # i 番目より前までを含む grid を構築\n        # if dist < delta:\n        if dist - delta < -EPS:\n            delta = dist\n            grid = defaultdict(list)\n            for a in points[:i]:\n                grid[a.x // delta, a.y // delta].append(a)\n        else:\n            p = points[i - 1]\n            grid[p.x // delta, p.y // delta].append(p)\n\n        p = points[i]\n        dist = delta\n        grid_x = p.x // delta\n        grid_y = p.y // delta\n        # 周り 9 箇所だけ調べれば OK\n        for dx, dy in DELTA_XY:\n            for q in grid[grid_x + dx, grid_y + dy]:\n                d = p.dist(q)\n                # if d < dist:\n                if d - dist < -EPS:\n                    dist = d\n                    ret_pair = p, q\n    return min(delta, dist), ret_pair\n\n\nclass SegmentTree:\n    # http://tsutaj.hatenablog.com/entry/2017/03/29/204841\n    def __init__(self, size, fn=operator.add, default=None, initial_values=None):\n        \"\"\"\n        :param int size:\n        :param callable fn: 区間に適用する関数。引数を 2 つ取る。min, max, operator.xor など\n        :param default:\n        :param list initial_values:\n        \"\"\"\n        default = default or 0\n\n        # size 以上である最小の 2 冪を size とする\n        n = 1\n        while n < size:\n            n *= 2\n        self._size = n\n        self._fn = fn\n\n        self._tree = [default] * (self._size * 2 - 1)\n        if initial_values:\n            i = self._size - 1\n            for v in initial_values:\n                self._tree[i] = v\n                i += 1\n            i = self._size - 2\n            while i >= 0:\n                self._tree[i] = self._fn(self._tree[i * 2 + 1], self._tree[i * 2 + 2])\n                i -= 1\n\n    def set(self, i, value):\n        \"\"\"\n        i 番目に value を設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self._tree[x] = value\n\n        while x > 0:\n            x = (x - 1) // 2\n            self._tree[x] = self._fn(self._tree[x * 2 + 1], self._tree[x * 2 + 2])\n\n    def add(self, i, value):\n        \"\"\"\n        もとの i 番目と value に fn を適用したものを i 番目に設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self.set(i, self._fn(self._tree[x], value))\n\n    def get(self, from_i, to_i=None, k=0, L=None, r=None):\n        \"\"\"\n        [from_i, to_i) に fn を適用した結果を返す\n        :param int from_i:\n        :param int to_i:\n        :param int k: self._tree[k] が、[L, r) に fn を適用した結果を持つ\n        :param int L:\n        :param int r:\n        :return:\n        \"\"\"\n        if to_i is None:\n            return self._tree[self._size - 1 + from_i]\n\n        L = 0 if L is None else L\n        r = self._size if r is None else r\n\n        if from_i <= L and r <= to_i:\n            return self._tree[k]\n\n        if to_i <= L or r <= from_i:\n            return None\n\n        ret_L = self.get(from_i, to_i, k * 2 + 1, L, (L + r) // 2)\n        ret_r = self.get(from_i, to_i, k * 2 + 2, (L + r) // 2, r)\n        if ret_L is None:\n            return ret_r\n        if ret_r is None:\n            return ret_L\n        return self._fn(ret_L, ret_r)\n\n    def __len__(self):\n        return self._size\n\n\ndef compress(li, origin=0):\n    \"\"\"\n    座圧\n    :param li:\n    :param int origin:\n    :rtype: list of int\n    \"\"\"\n    *ret, = map({v: i + origin for i, v in enumerate(sorted(set(li)))}.__getitem__, li)\n    return ret\n\n\nN = int(sys.stdin.buffer.readline())\nS = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(N)]\n\nflatten = list(itertools.chain.from_iterable(S))\nranks = compress(flatten, origin=1)\nMAX = max(ranks)\nV = []\nH = []\n\nfor x1, y1, x2, y2 in zip(*[iter(ranks)] * 4):\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        V.append(Segment(Point(complex(x1, y1)), Point(complex(x2, y2))))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        H.append(Segment(Point(complex(x1, y1)), Point(complex(x2, y2))))\n\ny_events = defaultdict(list)\nfor s in V:\n    y_events[s.p1.y].append((s.p1.x, 1))\n    y_events[s.p2.y + 1].append((s.p2.x, -1))\n\nH.sort(key=lambda s: s.p1.y)\nys = sorted(y_events.keys())\nyi = 0\nans = 0\nst = SegmentTree(size=MAX + 100)\nfor s in H:\n    while yi < len(ys) and ys[yi] <= s.p1.y:\n        y = ys[yi]\n        for x, d in y_events[y]:\n            st.add(int(x), d)\n        yi += 1\n    ans += st.get(int(s.p1.x), int(s.p2.x + 1))\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\nEP = []\nl = -1000000001\nu = 1000000001\nvs_x = set()\n\nfor line in file_input:\n    x1, y1, x2, y2 = (map(int, line.split()))\n    if x1 == x2:\n        if y1 < y2:\n            EP.append((y1, l, x1))\n            EP.append((y2, u, x1))\n        else:\n            EP.append((y1, u, x1))\n            EP.append((y2, l, x1))\n        vs_x.add(x1)\n    else:\n        if x1 < x2:\n            EP.append((y1, x1, x2))\n        else:\n            EP.append((y1, x2, x1))\n\nvs_x = sorted(vs_x)\n\n# Segment Tree(Range Sum Query)\nimport math\n\nm = 2 ** math.ceil(math.log(len(vs_x), 2))\nST = [0] * (2 * m - 1)\n\ndef switch(i):\n    i += m - 1\n    if ST[i]:\n        d = -1\n    else:\n        d = 1\n    ST[i] += d\n\n    while i > 0:\n        i = (i - 1) // 2\n        ST[i] += d\n\ndef get_sum(s, t, k, l, r):\n    if r < s or t < l:\n        return 0\n    elif s <= l and r <= t:\n        return ST[k]\n    else:\n        mid = (l + r) // 2\n        l_sum = get_sum(s, t, k * 2 + 1, l, mid)\n        r_sum = get_sum(s, t, k * 2 + 2, mid + 1, r)\n        return l_sum + r_sum\n\n# Sweep\nimport bisect\n\nEP.sort()\ncnt = 0\n\nfor p in EP:\n    e = p[1]\n    if e == l or e == u:\n        vs_i = bisect.bisect_left(vs_x, p[2])\n        switch(vs_i)\n    else:\n        l_x = bisect.bisect_left(vs_x, e)\n        r_x = bisect.bisect(vs_x, p[2]) - 1\n        cnt += get_sum(l_x, r_x, 0, 0, m - 1)\n\n# Output\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import bisect\nimport copy\n\n\nEPS=10**(-10)\n       \nclass Point():\n    def __init__(self,x=None,y=None):\n        self.x=x\n        self.y=y\n    def __lt__(self, value):\n        if self.x!=value.x:\n            return self.x<value.x\n        else:\n            return self.y<value.y\n  \n    def __eq__(self,value):\n        cmp= abs(self.x-value.x)<EPS and abs(self.y-value.y)<EPS   \n        return cmp\n    \nclass Segment():\n    def __init__(self,p1=Point(0,0),p2=Point(0,0)):\n        self.p1=p1\n        self.p2=p2\n    \nBOTTOM =0\nLEFT=1 \nRIGHT =2\nTOP=3 \nclass EndPoint():\n    def __init__(self,p=None,seg=None,st=None):\n        self.p=p\n        self.seg=seg\n        self.st=st\n    def __lt__(self, value):\n        if self.p.y==value.p.y:\n            return self.st<value.st\n        return self.p.y<value.p.y\n\n\n    \n\n#线段相交问题，曼哈顿几何\ndef manhattanIntersection(S):\n    \n    n =len(S)\n    global EP\n\n    #按照端点的y坐标升序排序\n    EP.sort()\n\n\n    BT=[]            # 二叉搜索树\n    #BT.insert(10000000001)# 设置标记\n    cnt = 0\n\n    for i in range(2*n):\n        if EP[i].st==TOP:\n            idx=bisect.bisect_left(BT,EP[i].p.x)\n            if idx>=0 and idx< len(EP):\n                BT.pop(idx)\n            #BT.erase(EP[i].p.x) #删除上端点\n        elif (EP[i].st == BOTTOM):\n            bisect.insort_left(BT,EP[i].p.x)\n            #BT.insert(EP[i].p.x)\n        elif (EP[i].st == LEFT):\n            idxb=bisect.bisect_left(BT,S[EP[i].seg].p1.x)\n            idxe=bisect.bisect_left(BT,S[EP[i].seg].p2.x)\n            \n            #set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n            #set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n            \n    #加上b到e距离\n            cnt +=abs(idxe-idxb)  # distance(b, e);\n    \n    return cnt\n\n\n\nn=int(input())\nEP=[ None for i in range(2*n)]\nS=[]\nseglist=[]\nk=0\nfor i in range(n):\n    seg=Segment()\n    ss=[int(x) for x in input().split()]\n    seg.p1.x=ss[0]\n    seg.p1.y=ss[1]\n    seg.p2.x=ss[2]\n    seg.p2.y=ss[3]\n    copy.deepcopy(seg)\n    seglist.append(copy.deepcopy(seg))\n    \n    seg=seglist[i]\n    \n    if seg.p1.y==seg.p2.y:\n        if seg.p1.x>seg.p2.x:\n            seg.p1,seg.p2=seg.p2,seg.p1\n    elif seg.p1.y>seg.p2.y:\n        seg.p1,seg.p2=seg.p2,seg.p1\n\n\n        #将水平线段添加到端点列表\n    if (seg.p1.y == seg.p2.y) :\n        EP[k] = EndPoint(seg.p1, i, LEFT)\n        k+=1\n        EP[k] = EndPoint(seg.p2, i, RIGHT)\n        k+=1\n        \n    else: # 将垂直线段添加到端点列表\n          EP[k] = EndPoint(seg.p1, i, BOTTOM)\n          k+=1\n          EP[k] = EndPoint(seg.p2, i, TOP)\n          k+=1\n                 \n    S.append(seg)\n    \n\nprint(\"%d\"%(manhattanIntersection(S)))\n"
  }
]