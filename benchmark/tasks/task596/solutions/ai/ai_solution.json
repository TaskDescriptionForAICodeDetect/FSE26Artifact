[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Segment;\n\nint compareSegments(const void* a, const void* b) {\n    Segment* seg1 = (Segment*)a;\n    Segment* seg2 = (Segment*)b;\n    \n    if (seg1->y1 != seg2->y1)\n        return seg1->y1 - seg2->y1;\n    return seg1->x1 - seg2->x1;\n}\n\nint countIntersections(Segment* segments, int n) {\n    qsort(segments, n, sizeof(Segment), compareSegments);\n    \n    int intersections = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (segments[j].y1 > segments[i].y1)\n                break;\n            \n            if (segments[i].y1 != segments[i].y2) {\n                if (segments[j].x1 != segments[j].x2) {\n                    if ((segments[i].x1 < segments[j].x1 && segments[i].x2 > segments[j].x1) ||\n                        (segments[i].x1 > segments[j].x1 && segments[i].x1 < segments[j].x2)) {\n                        intersections++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return intersections;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Segment* segments = malloc(n * sizeof(Segment));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &segments[i].x1, &segments[i].y1, \n                              &segments[i].x2, &segments[i].y2);\n    }\n    \n    int result = countIntersections(segments, n);\n    printf(\"%d\\n\", result);\n    \n    free(segments);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Segment;\n\nint isHorizontal(Segment s) {\n    return s.y1 == s.y2;\n}\n\nint isVertical(Segment s) {\n    return s.x1 == s.x2;\n}\n\nint between(int a, int b, int c) {\n    return (a <= b && b <= c) || (c <= b && b <= a);\n}\n\nint intersect(Segment s1, Segment s2) {\n    if (isHorizontal(s1) && isHorizontal(s2)) {\n        return 0;\n    } else if (isVertical(s1) && isVertical(s2)) {\n        return 0;\n    } else if (isHorizontal(s1) && isVertical(s2)) {\n        return between(s1.x1, s2.x1, s1.x2) && between(s2.y1, s1.y1, s2.y2);\n    } else {\n        return between(s2.x1, s1.x1, s2.x2) && between(s1.y1, s2.y1, s1.y2);\n    }\n}\n\nint countIntersections(Segment segments[], int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (intersect(segments[i], segments[j])) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Segment *segments = (Segment*)malloc(n * sizeof(Segment));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &segments[i].x1, &segments[i].y1, &segments[i].x2, &segments[i].y2);\n    }\n    printf(\"%d\\n\", countIntersections(segments, n));\n    free(segments);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nstruct Segment {\n    Point p1, p2;\n    bool isHorizontal() const {\n        return p1.y == p2.y;\n    }\n};\n\nint countIntersections(vector<Segment>& segments) {\n    int count = 0;\n    for (size_t i = 0; i < segments.size(); ++i) {\n        for (size_t j = i + 1; j < segments.size(); ++j) {\n            Segment s1 = segments[i];\n            Segment s2 = segments[j];\n            \n            if (s1.isHorizontal() && !s2.isHorizontal()) {\n                if (s1.p1.x <= s2.p1.x && s2.p1.x <= s1.p2.x && \n                    s2.p1.y <= s1.p1.y && s1.p1.y <= s2.p2.y) {\n                    count++;\n                }\n            } else if (!s1.isHorizontal() && s2.isHorizontal()) {\n                if (s2.p1.x <= s1.p1.x && s1.p1.x <= s2.p2.x && \n                    s1.p1.y <= s2.p1.y && s2.p1.y <= s1.p2.y) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Segment> segments(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> segments[i].p1.x >> segments[i].p1.y >> segments[i].p2.x >> segments[i].p2.y;\n        if (segments[i].isHorizontal() && segments[i].p1.x > segments[i].p2.x) {\n            swap(segments[i].p1.x, segments[i].p2.x);\n        } else if (!segments[i].isHorizontal() && segments[i].p1.y > segments[i].p2.y) {\n            swap(segments[i].p1.y, segments[i].p2.y);\n        }\n    }\n    cout << countIntersections(segments) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Segment {\n    Point p1, p2;\n    boolean isHorizontal;\n    Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.isHorizontal = p1.y == p2.y;\n    }\n}\n\npublic class SegmentIntersection {\n    public static int countIntersections(List<Segment> segments) {\n        int count = 0;\n        for (int i = 0; i < segments.size(); i++) {\n            Segment s1 = segments.get(i);\n            for (int j = i + 1; j < segments.size(); j++) {\n                Segment s2 = segments.get(j);\n                if (s1.isHorizontal != s2.isHorizontal) {\n                    if (s1.isHorizontal) {\n                        if (isBetween(s1.p1.x, s2.p1.x, s1.p2.x) && isBetween(s2.p1.y, s1.p1.y, s2.p2.y)) {\n                            count++;\n                        }\n                    } else {\n                        if (isBetween(s2.p1.x, s1.p1.x, s2.p2.x) && isBetween(s1.p1.y, s2.p1.y, s1.p2.y)) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    private static boolean isBetween(int a, int b, int c) {\n        return (b >= Math.min(a, c) && b <= Math.max(a, c));\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Segment> segments = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            Point p1 = new Point(x1, y1);\n            Point p2 = new Point(x2, y2);\n            segments.add(new Segment(p1, p2));\n        }\n        System.out.println(countIntersections(segments));\n    }\n}",
    "timestamp": "2025-08-05 22:17:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static int countIntersections(int[][] segments) {\n        List<Event> events = new ArrayList<>();\n        \n        for (int[] segment : segments) {\n            int x1 = segment[0], y1 = segment[1];\n            int x2 = segment[2], y2 = segment[3];\n            \n            if (x1 == x2) {  // vertical segment\n                events.add(new Event(Math.min(y1, y2), 0, x1));\n                events.add(new Event(Math.max(y1, y2), 1, x1));\n            } else {  // horizontal segment\n                events.add(new Event(y1, 2, x1, x2));\n            }\n        }\n        \n        Collections.sort(events);\n        \n        int intersections = 0;\n        TreeSet<Integer> activeVerticals = new TreeSet<>();\n        \n        for (Event event : events) {\n            if (event.type == 0) {  // vertical start\n                activeVerticals.add(event.x);\n            } else if (event.type == 1) {  // vertical end\n                activeVerticals.remove(event.x);\n            } else {  // horizontal\n                Integer lower = activeVerticals.lower(Math.max(event.x1, event.x2));\n                Integer higher = activeVerticals.higher(Math.min(event.x1, event.x2));\n                \n                if (lower != null && lower >= Math.min(event.x1, event.x2) && \n                    lower <= Math.max(event.x1, event.x2)) {\n                    intersections++;\n                }\n                \n                if (higher != null && higher >= Math.min(event.x1, event.x2) && \n                    higher <= Math.max(event.x1, event.x2)) {\n                    intersections++;\n                }\n            }\n        }\n        \n        return intersections;\n    }\n    \n    static class Event implements Comparable<Event> {\n        int y, type, x, x1, x2;\n        \n        Event(int y, int type, int x) {\n            this.y = y;\n            this.type = type;\n            this.x = x;\n        }\n        \n        Event(int y, int type, int x1, int x2) {\n            this.y = y;\n            this.type = type;\n            this.x1 = x1;\n            this.x2 = x2;\n        }\n        \n        public int compareTo(Event other) {\n            if (this.y != other.y) return Integer.compare(this.y, other.y);\n            return Integer.compare(this.type, other.type);\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[][] segments = {{1,1,1,4}, {2,2,4,2}, {3,1,3,3}};\n        System.out.println(countIntersections(segments));\n    }\n}",
    "timestamp": "2025-08-05 22:17:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint countIntersections(vector<pair<pair<int, int>, pair<int, int>>>& segments) {\n    vector<pair<int, int>> horizontalSegments;\n    vector<pair<int, int>> verticalSegments;\n\n    // Separate horizontal and vertical segments\n    for (auto& segment : segments) {\n        if (segment.first.first == segment.second.first) {\n            verticalSegments.push_back({min(segment.first.second, segment.second.second), \n                                        max(segment.first.second, segment.second.second)});\n        } else {\n            horizontalSegments.push_back({min(segment.first.first, segment.second.first), \n                                           max(segment.first.first, segment.second.first)});\n        }\n    }\n\n    int intersections = 0;\n\n    // Count intersections between horizontal and vertical segments\n    for (auto& horizontal : horizontalSegments) {\n        for (auto& vertical : verticalSegments) {\n            if (horizontal.first <= vertical.first && vertical.first <= horizontal.second &&\n                vertical.first >= horizontal.first && vertical.first <= horizontal.second) {\n                intersections++;\n            }\n        }\n    }\n\n    return intersections;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<pair<int, int>, pair<int, int>>> segments(n);\n    for (int i = 0; i < n; i++) {\n        cin >> segments[i].first.first >> segments[i].first.second \n            >> segments[i].second.first >> segments[i].second.second;\n    }\n\n    cout << countIntersections(segments) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_intersections(segments):\n    vertical_segments = []\n    horizontal_segments = []\n\n    # Separate vertical and horizontal segments\n    for (x1, y1, x2, y2) in segments:\n        if x1 == x2:\n            # Vertical segment\n            vertical_segments.append((x1, min(y1, y2), max(y1, y2)))\n        elif y1 == y2:\n            # Horizontal segment\n            horizontal_segments.append((min(x1, x2), max(x1, x2), y1))\n\n    count = 0\n\n    # Check intersections between vertical and horizontal segments\n    for (x, y_start, y_end) in vertical_segments:\n        for (x_start, x_end, y) in horizontal_segments:\n            if x_start <= x <= x_end and y_start <= y <= y_end:\n                count += 1\n\n    return count\n\n# Example usage\nsegments = [(1, 1, 1, 4), (0, 2, 3, 2), (2, 0, 2, 5), (0, 3, 4, 3)]\nprint(count_intersections(segments))",
    "timestamp": "2025-08-13 09:45:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SegmentIntersections {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numSegments = scanner.nextInt();\n        List<Segment> horizontal = new ArrayList<>();\n        List<Segment> vertical = new ArrayList<>();\n\n        for (int i = 0; i < numSegments; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n\n            if (y1 == y2) {\n                horizontal.add(new Segment(x1, y1, x2, y2));\n            } else if (x1 == x2) {\n                vertical.add(new Segment(x1, y1, x2, y2));\n            }\n        }\n\n        int intersections = 0;\n\n        for (Segment h : horizontal) {\n            for (Segment v : vertical) {\n                if (v.x1 >= Math.min(h.x1, h.x2) && \n                    v.x1 <= Math.max(h.x1, h.x2) &&\n                    h.y1 >= Math.min(v.y1, v.y2) &&\n                    h.y1 <= Math.max(v.y1, v.y2)) {\n                    intersections++;\n                }\n            }\n        }\n\n        System.out.println(intersections);\n    }\n\n    static class Segment {\n        int x1, y1, x2, y2;\n        Segment(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n    }\n}",
    "timestamp": "2025-08-13 09:45:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Segment;\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint doIntersect(Segment s1, Segment s2) {\n    if (s1.x1 == s1.x2 && s2.y1 == s2.y2) {\n        return min(s1.y1, s1.y2) <= s2.y1 && s2.y1 <= max(s1.y1, s1.y2) &&\n               min(s2.x1, s2.x2) <= s1.x1 && s1.x1 <= max(s2.x1, s2.x2);\n    }\n    if (s1.y1 == s1.y2 && s2.x1 == s2.x2) {\n        return min(s1.x1, s1.x2) <= s2.x1 && s2.x1 <= max(s1.x1, s1.x2) &&\n               min(s2.y1, s2.y2) <= s1.y1 && s1.y1 <= max(s2.y1, s2.y2);\n    }\n    return 0;\n}\n\nint countIntersections(Segment segments[], int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (doIntersect(segments[i], segments[j])) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Segment segments[n];\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", &segments[i].x1, &segments[i].y1, &segments[i].x2, &segments[i].y2);\n    }\n    printf(\"%d\\n\", countIntersections(segments, n));\n    return 0;\n}",
    "timestamp": "2025-08-13 09:45:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_intersections(segments):\n    events = []\n    for i, (x1, y1, x2, y2) in enumerate(segments):\n        if x1 == x2:  # vertical segment\n            events.append((min(y1, y2), 0, i))  # start\n            events.append((max(y1, y2), 2, i))  # end\n        else:  # horizontal segment\n            events.append((x1, 1, i))  # horizontal segment point\n            events.append((x2, 1, i))  # horizontal segment point\n    \n    events.sort()\n    active_horizontal = set()\n    active_vertical = set()\n    intersections = 0\n    \n    for _, event_type, segment_id in events:\n        if event_type == 0:  # vertical segment start\n            active_vertical.add(segment_id)\n        elif event_type == 2:  # vertical segment end\n            active_vertical.remove(segment_id)\n        else:  # horizontal segment point\n            for v_seg in active_vertical:\n                intersections += 1\n            active_horizontal.add(segment_id)\n    \n    return intersections\n\n# Example usage\nsegments = [(1,1,1,3), (2,1,2,3), (3,2,5,2)]\nprint(count_intersections(segments))",
    "timestamp": "2025-08-13 09:45:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.is_horizontal = (p1.y == p2.y)\n        self.is_vertical = (p1.x == p2.x)\n\ndef count_intersections(segments):\n    count = 0\n    n = len(segments)\n    for i in range(n):\n        seg1 = segments[i]\n        for j in range(i + 1, n):\n            seg2 = segments[j]\n            if seg1.is_horizontal and seg2.is_horizontal:\n                continue\n            if seg1.is_vertical and seg2.is_vertical:\n                continue\n            if seg1.is_horizontal and seg2.is_vertical:\n                h_seg = seg1\n                v_seg = seg2\n            elif seg1.is_vertical and seg2.is_horizontal:\n                h_seg = seg2\n                v_seg = seg1\n            else:\n                continue\n            h_y = h_seg.p1.y\n            v_x = v_seg.p1.x\n            h_min_x = min(h_seg.p1.x, h_seg.p2.x)\n            h_max_x = max(h_seg.p1.x, h_seg.p2.x)\n            v_min_y = min(v_seg.p1.y, v_seg.p2.y)\n            v_max_y = max(v_seg.p1.y, v_seg.p2.y)\n            if (h_min_x <= v_x <= h_max_x) and (v_min_y <= h_y <= v_max_y):\n                count += 1\n    return count\n\n# Example usage:\n# segments = [\n#     Segment(Point(1, 2), Point(4, 2)),  # Horizontal\n#     Segment(Point(3, 1), Point(3, 5)),  # Vertical\n#     Segment(Point(2, 3), Point(5, 3)),  # Horizontal\n#     Segment(Point(4, 0), Point(4, 4))   # Vertical\n# ]\n# print(count_intersections(segments))",
    "timestamp": "2025-08-13 09:45:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nstruct Segment {\n    int x1, y1, x2, y2;\n};\n\nbool is_horizontal(const Segment &s) {\n    return s.y1 == s.y2;\n}\n\nbool is_vertical(const Segment &s) {\n    return s.x1 == s.x2;\n}\n\nint count_intersections(const std::vector<Segment> &segments) {\n    std::vector<Segment> horizontal_segments, vertical_segments;\n    \n    // Separate the segments into horizontal and vertical\n    for (const auto &segment : segments) {\n        if (is_horizontal(segment)) {\n            horizontal_segments.emplace_back(segment);\n        } else if (is_vertical(segment)) {\n            vertical_segments.emplace_back(segment);\n        }\n    }\n\n    int intersections = 0;\n    \n    // Map to store y-coordinate to list of x-ranges for horizontal segments\n    std::map<int, std::vector<std::pair<int, int>>> horizontal_map;\n\n    for (const auto &hs : horizontal_segments) {\n        int y = hs.y1;\n        int x1 = std::min(hs.x1, hs.x2);\n        int x2 = std::max(hs.x1, hs.x2);\n        horizontal_map[y].emplace_back(x1, x2);\n    }\n\n    // Check each vertical segment for intersections\n    for (const auto &vs : vertical_segments) {\n        int x = vs.x1;\n        int y1 = std::min(vs.y1, vs.y2);\n        int y2 = std::max(vs.y1, vs.y2);\n\n        for (auto it = horizontal_map.lower_bound(y1); it != horizontal_map.upper_bound(y2); ++it) {\n            // Find if there's any horizontal segment intersecting vertical segment\n            const auto &h_segments = it->second;\n            for (const auto &[hx1, hx2] : h_segments) {\n                if (hx1 <= x && x <= hx2) {\n                    intersections++;\n                }\n            }\n        }\n    }\n\n    return intersections;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Segment> segments(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> segments[i].x1 >> segments[i].y1 >> segments[i].x2 >> segments[i].y2;\n    }\n    std::cout << count_intersections(segments) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:54:38"
  }
]