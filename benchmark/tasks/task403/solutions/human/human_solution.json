[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint G[511][511][2];\n \nbool used[511];\n \nint N,E,Q;\n \n#define INF ( 1<<30)\n \nvoid add_edge(int a,int b){\n  G[a][b][0] = 1; G[b][a][1] = 0;\n}\n \nvoid rem_edge(int a,int b){\n  G[a][b][0] = 0; G[b][a][1] = 0;\n}\n \nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int fr=1;fr>=0;fr--){\n    for(int i=0;i<N;i++){\n      if( !used[i] && G[v][i][fr] > 0 ) {\n\tint d = dfs(i, t, min( f, G[v][i][fr] ) );\n\tif( d > 0 ){\n\t  G[v][i][fr] -= d;\n\t  G[i][v][1-fr] += d;\n\t  return d;\n\t}\n      }\n    }\n  }\n  return 0;\n}\n \n \nint max_flow(int s,int t){\n  int flow = 0;\n  if( s == t ) return 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    //  cout << s << \" -> \" << t << \" = \" << f << endl;\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n  return flow;\n}\n\nvoid view(){\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if( G[i][j][0] == 0 && G[j][i][1] == 0 ) continue;\n      printf(\" %d -> %d : cap = %d  rev( %d -> %d ) = %d\\n\",i+1,j+1,G[i][j][0],j+1,i+1,G[j][i][1]);\n    }\n  }\n}\n \nint main(){\n  cin  >> N >> E >> Q;\n  for(int i=0;i<E;i++){\n    int e,f;\n    cin >> e >> f;\n    --e; --f;\n    add_edge(e,f);\n    add_edge(f,e);\n  }\n  int rflow = max_flow(0,N-1);\n  for(int i=0;i<Q;i++){\n\n    //    view();\n\n    int m,a,b;\n    cin >>m>> a>> b;\n    --a; --b;\n    if( m == 1 ){\n      add_edge(a,b);\n      add_edge(b,a);\n    } else {\n      if( G[a][b][0] == 0 ){\n\t//\tcout << \"rem \" << a << \" <-> \" << b << endl;\n\trem_edge(a,b);\t\n\tint d = max_flow(a,b);\n\tif( d == 0 ){\n\t  max_flow(N-1,b);\n\t  max_flow(a,0);\n\t  rflow--;\n\t}\n      } else\n\trem_edge(a,b);\n\n      if( G[b][a][0] == 0 ){\n\t///cout << \"rem \" << b << \" <-> \" << a << endl;\n\trem_edge(b,a);\n\tint d = max_flow(b,a);\n\t//cout << d << endl;\n\tif( d == 0 ){\n\t  max_flow(N-1,a);\n\t  max_flow(b,0);\n\t  rflow--;\n\t}\n      } else \n\trem_edge(b,a);\n    }\n    rflow += max_flow(0,N-1);\n    cout << rflow << endl;\n  }\n  // view();\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[501];\nbool used[501];\n\nvoid add_edge(int from,int to){\n  G[from].push_back({to,1,(int)G[to].size()});\n  G[to].push_back({from,1,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //  cout<<'v'<<v<<endl;\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int fl=1<<29){\n  if(s==t)return 0;\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,fl);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nvoid remove_edge(int A,int B){\n  int x;\n  for(x=0;G[A][x].to!=B;x++);\n  int r=G[A][x].rev;\n  for(int i=x+1;i<G[A].size();i++){\n    auto e=G[A][i];\n    G[e.to][e.rev].rev--;\n  }\n  for(int i=r+1;i<G[B].size();i++){\n    auto e=G[B][i];\n    G[e.to][e.rev].rev--;\n  }\n  G[A].erase(begin(G[A])+x);\n  G[B].erase(begin(G[B])+r);\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  while(E--){\n    int F,T;\n    cin>>F>>T;\n    add_edge(F,T);\n  }\n  int flow=max_flow(1,N);\n  while(Q--){\n    int M,A,B;\n    cin>>M>>A>>B;\n    if(M==1){\n      add_edge(A,B);\n      flow+=max_flow(1,N);\n    }else{\n      int x;\n      for(x=0;G[A][x].to!=B;x++);\n      if(G[A][x].cap==1){\n\tremove_edge(A,B);\n      }else{\n\tint f=A,t=B;\n\tif(G[A][x].cap!=0){\n\t  swap(f,t);\n\t}\n\tremove_edge(A,B);\n\tif(!max_flow(f,t,1)){\n\t  max_flow(N,t,1);\n\t  max_flow(f,1,1);\n\t  flow--;\n\t}\n      }\n    }\n    cout<<flow<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct dinic{\n  int n;\n  vector< vector<edge> > graph;\n  vi level,iter;\n\n  dinic(int a=0):n(a){graph.resize(a);}\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g){\n\tid = e; rev = graph[s][e].rev;\n      }\n    }\n    if(id<0)return;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n    graph[s][id].rev = rev;\n    graph[g][rev].rev = id;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n\n  void bfs(int s){\n    level = vi(n,-1);\n    level[s] = 0;\n    queue<int> q; q.push(s);\n    while(q.sz){\n      int v = q.front(); q.pop();\n      for(edge e: graph[v]){\n\tif(e.cap>0 && level[e.to]<0){\n\t  level[e.to] = level[v] + 1;\n\t  q.push(e.to);\n\t}\n      }\n    }\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    for(int &i = iter[v];i<(int)graph[v].sz;i++){\n      edge &e = graph[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0)return res;\n      iter = vi(n,0);\n      int f;\n      while((f=dfs(s,t,INF))>0)res += f;\n    }\n  }\n};\n\nint main(){\n  int n,e,q;\n  cin >> n >> e >> q;\n  dinic d(n);\n  rep(i,e){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    d.AddEdge(f,t,1,1);\n    d.AddEdge(t,f,1,1);\n  }\n\n  int f = d.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      d.AddEdge(a,b,1,1);\n      d.AddEdge(b,a,1,1);\n      f += d.max_flow(0,n-1);\n    }else{\n      bool use = false;\n      for(edge e : d.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap==0)use = true;\n      }\n      for(edge e : d.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap==0)use = true;\n      }\n\n      d.DeleteEdge(a,b);\n      d.DeleteEdge(b,a);\n\n      if(use){\n\t//cerr << a << \" \" << b << endl;\n\trep(i,n){\n\t  //cerr << i << endl;\n\t  for(edge &e : d.graph[i]){\n\t  if(e.cost>0)e.cap = 1;\n\t  else e.cap = 0;\n\t  //cerr << e.to << \" \" << e.cost << \" \" << e.cap << endl;\n\t  }\n\t}\n\tf = d.max_flow(0,n-1);\n      }\n    }\n    cout << f << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t//cout << v << ' ' << e.to << ' ' << e.cap << endl;\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\tauto& e = G[a][edge[a][b]];\n\t\t\tauto& re = G[b][e.rev];\n\n\t\t\te.cap = re.cap = 1;\t\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\tauto e = G[a][edge[a][b]];\n\t\t\tint d = e.cap;\n\t\t\tshow(d)\n\t\t\te.cap = G[b][e.rev].cap = 0;\n\t\t\tif(d == 1) return 0;\n\t\t\tif(d == 2){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(b, a, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, a, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(b, s, 1);\n\t\t\t}else{\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(a, s, 1);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tint subCapacity_(int s, int t, int a, int b){\n\t\t\t//cout << \"SUB\" << endl;\n\t\t\t//if(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\t//cout << a << ' ' << b << endl;\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\tif(ab.cap >= 1){\n\t\t\t\t//cout << \"WY\" << endl;\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\t//cout << \"HE\" << endl;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcout << \"OUT\" << endl;\n\n\t\t\t\t//for(auto i : G){\n\t\t\t\t//\tfor(auto j : i){\n\t\t\t\t//\t\tcout << j.to << ' ' << j.cap << ' ' << j.rev << endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint ans = dfs(a, s, 1);\n\t\t\t\t//show(ans)\n\t\t\t\t//assert(ans == 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\t//assert(dfs(t, b, 1) == 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = 0, t = n - 1;\n\t//flow.addEdge(s, 0, INF);\n\t//flow.addEdge(n - 1, t, INF);\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not use[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\t//assert(flow.fordFulkerson(s, t) == 0);\n\t\tcout << ans << endl;\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <functional>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntemplate <typename Weight>\nstruct MaxFlow{\n\tstruct Edge{\n\t\tint v;\n\t\tWeight w;\n\t\tint r;\n\t\tEdge(int v, Weight w,int r=0):v(v),w(w),r(r){}\n\t};\n\ttypedef vector< vector<Edge> > Graph;\n\tint n, source, sink;\n\tGraph g;\n\tWeight flow;\n\tMaxFlow(int n=0):n(n), g(n), flow(0){\n\t\t\n\t}\n\t\n\tvoid add_edge(int u, int v, Weight cap, Weight revcap=0){\n\t\tg[u].emplace_back(v,cap,g[v].size());\n\t\tg[v].emplace_back(u,revcap,g[u].size()-1);\n\t}\n\tvoid rem_edge(int u,int v, Weight cap){\n\t\tfor(auto &e : g[u])if(e.v == v){\n\t\t\tWeight t = min(cap, e.w);\n\t\t\te.w -= t;\n\t\t\tcap -= t;\n\t\t\tif(cap == 0) return;\n\t\t}\n\t\tif(cap != maxflow_dinic(u, v, cap)){\n\t\t\tmaxflow_dinic(sink, v, cap);\n\t\t\tmaxflow_dinic(u, source, cap);\n\t\t\tflow -= cap;\n\t\t}\n\t\trem_edge(v, u, cap);\n\t}\n\t\n\tWeight maxflow_dinic(int source, int sink, Weight limit){\n\t\tif(source == sink) return limit;\n\t\tconst Weight inf = numeric_limits<Weight>::max();\n\t\tWeight flow = 0;\n\t\twhile(true){\n\t\t\tvector<int> level(n, -1);\n\t\t\tqueue<int> q;\n\t\t\tlevel[source] = 0;\n\t\t\tq.push(source);\n\t\t\twhile(!q.empty()){\n\t\t\t\tconst int u = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor(const auto &e : g[u]){\n\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\tif(e.w <= 0 || level[v] >= 0){ continue; }\n\t\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(level[sink] < 0){ break; }\n\t\t\tvector<size_t> itr(n, 0);\n\t\t\twhile(true){\n\t\t\t\tfunction<Weight(int, Weight)> dfs =\n\t\t\t\t\t[&](int u, Weight limit) -> Weight{\n\t\t\t\t\t\tif(u == sink) return limit;\n\t\t\t\t\t\tfor(; itr[u] < g[u].size(); ++itr[u]){\n\t\t\t\t\t\t\tauto &e = g[u][itr[u]];\n\t\t\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\t\t\tif(e.w <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\t\tconst Weight diff = dfs(v, min(e.w, limit));\n\t\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\t\te.w -= diff;\n\t\t\t\t\t\t\t\tg[v][e.r].w += diff;\n\t\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t};\n\t\t\t\tconst auto f = dfs(source, inf);\n\t\t\t\tif(f <= 0){ break; }\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tWeight maxflow(int s, int t){\n\t\tsource = s;\n\t\tsink = t;\n\t\treturn flow += maxflow_dinic(s, t, numeric_limits<Weight>::max());\n\t}\n};\n\nint N, E, Q;\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tMaxFlow<int> g(N);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg.add_edge(u, v, 1, 1);\n\t}\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v; u--; v--;\n\t\tif(f == 1){\n\t\t\tg.add_edge(u, v, 1, 1);\n\t\t}else{\n\t\t\tg.rem_edge(u, v, 1);\n\t\t\tg.rem_edge(v, u, 1);\n\t\t}\n\t\tcout << g.maxflow(0, N-1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.add_edge(1, a, 1);\n\t\t\tflow.add_edge(b, n, 1);\n\t\t\toffset++;\n\t\t}\n\t\tcout << flow.max_flow(1, n) - offset << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nint n, m, q;\nint t[502][502];\nbool used[502];\n\nint dfs(int a, int b, int f){\n  if(a == b){\n    return f;\n  }\n\n  used[a] = true;\n\n  for(int i = 0; i < n; i++){\n    if(!used[i] && t[a][i] > 0){\n      int tmp = dfs(i, b, min(f, t[a][i]));\n      if(tmp > 0){\n        t[a][i] -= tmp;\n        t[i][a] += tmp;\n        return tmp;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint maximum_flow(int a, int b, int f){\n  int res = 0;\n\n  while(true){\n    memset(used, 0, sizeof(used));\n    int tmp = dfs(a, b, f);\n    if(tmp <= 0){\n      return res;\n    }\n    res += tmp;\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &n, &m, &q) != EOF){\n    memset(t, 0, sizeof(t));\n\n    for(int i = 0; i < m; i++){\n      int a, b;\n      scanf(\"%d%d\", &a, &b);\n      a--;\n      b--;\n      t[a][b] = t[b][a] = 1;\n    }\n\n    int ans = maximum_flow(0, n - 1, INT_MAX);\n\n    for(int i = 0; i < q; i++){\n      int flg, a, b;\n      scanf(\"%d%d%d\", &flg, &a, &b);\n      a--;\n      b--;\n\n      if(flg == 1){ //接続\n        t[a][b] = t[b][a] = 1;\n        ans += maximum_flow(0, n - 1, INT_MAX);\n        printf(\"%d\\n\", ans);\n      }\n      else{\n        if(t[a][b] == 0){\n          ans--;\n          t[a][b] = t[b][a] = 0;\n          memset(used, 0, sizeof(used));\n          dfs(n - 1, b, 1);\n          memset(used, 0, sizeof(used));\n          dfs(a, 0, 1);\n        }\n        else if(t[b][a] == 0){\n          ans--;\n          t[a][b] = t[b][a] = 0;\n          memset(used, 0, sizeof(used));\n          dfs(n - 1, a, 1);\n          memset(used, 0, sizeof(used));\n          dfs(b, 0, 1);\n        }\n\n        ans += maximum_flow(0, n - 1, INT_MAX);\n\n        printf(\"%d\\n\", ans);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T> struct Edge{\n\tint v,rev;\n\tT capa,flow;\n};\n\ntemplate<class T>\nstruct AdjList:public vector< vector< Edge<T> > >{\n\tAdjList(int n):vector< vector< Edge<T> > >(n){}\n};\n\ntemplate<class T>\nvoid add_edge(AdjList<T> &adj,int u,int v,T capa){\n\tadj[u].push_back((Edge<T>){v,adj[v].size()  ,capa,0});\n\tadj[v].push_back((Edge<T>){u,adj[u].size()-1,capa,0});\n}\n\ntemplate<class T>\nT augment(AdjList<T> &adj,int s,int t){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<bool> vis(n); vis[s]=true;\n\n\tqueue< pair<int,T> > qu;\n\tqu.push(make_pair(s,INF));\n\n\tT res=0;\n\twhile(!qu.empty()){\n\t\tint u=qu.front().first;\n\t\tT water=qu.front().second;\n\t\tqu.pop();\n\n\t\tif(u==t){ res=water; break; }\n\n\t\trep(i,adj[u].size()){\n\t\t\tEdge<T> &e=adj[u][i];\n\t\t\tif(!vis[e.v] && e.capa-e.flow>0){\n\t\t\t\tvis[e.v]=true;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\tqu.push(make_pair(e.v,min(water,e.capa-e.flow)));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(res>0){\n\t\tfor(int v=t;v!=s;){\n\t\t\tEdge<T> &e1=adj[v][pre[v]];\n\t\t\tEdge<T> &e2=adj[e1.v][e1.rev];\n\t\t\te1.flow-=res;\n\t\t\te2.flow+=res;\n\t\t\tv=e1.v;\n\t\t}\n\t}\n\n\treturn res;\n}\n\ntemplate<class T>\nT Edmonds_Karp(AdjList<T> &adj,int s,int t){\n\tT ans=0;\n\tfor(T water=1;water>0;ans+=water) water=augment(adj,s,t);\n\treturn ans;\n}\n\nbool vis[500];\nbool dfs(int u,int sign,int g,AdjList<int> &adj){\n\tvis[u]=true;\n\tif(u==g) return true;\n\trep(i,adj[u].size()){\n\t\tEdge<int> &e=adj[u][i];\n\t\tif(!vis[e.v] && e.flow*sign>0 && dfs(e.v,sign,g,adj)){\n\t\t\te.flow=0;\n\t\t\tadj[e.v][e.rev].flow=0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\tAdjList<int> adj(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tadd_edge(adj,u,v,1);\n\t}\n\n\tint ans=Edmonds_Karp(adj,0,n-1);\n\n\twhile(q--){\n\t\tint type,u,v; scanf(\"%d%d%d\",&type,&u,&v); u--; v--;\n\t\tif(type==1){ // add\n\t\t\tadd_edge(adj,u,v,1);\n\t\t}\n\t\telse{ // erase\n\t\t\tint i;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v && adj[u][i].capa>0) break;\n\t\t\tint i_rev=adj[u][i].rev;\n\n\t\t\tint flow=adj[u][i].flow;\n\t\t\tadj[u][i].capa=adj[v][i_rev].capa=0;\n\t\t\tadj[u][i].flow=adj[v][i_rev].flow=0;\n\t\t\tif(flow!=0){\n\t\t\t\t// ツフツδ債ーツづーツ可淞つオツ姪淞つキ\n\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\tif(flow>0){ // u ツつゥツづァ v ツづ鳴フツδ債ーツつェツ猟ャツづェツづつ「ツつス\n\t\t\t\t\tdfs(u,-1, 0 ,adj);\n\t\t\t\t\tdfs(v,+1,n-1,adj);\n\t\t\t\t}\n\t\t\t\telse{ // v ツつゥツづァ u\n\t\t\t\t\tdfs(v,-1, 0 ,adj);\n\t\t\t\t\tdfs(u,+1,n-1,adj);\n\t\t\t\t}\n\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tans+=Edmonds_Karp(adj,0,n-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T> struct Edge{\n\tint v,rev;\n\tT capa,flow;\n};\n\ntemplate<class T>\nstruct AdjList:public vector< vector< Edge<T> > >{\n\tAdjList(int n):vector< vector< Edge<T> > >(n){}\n};\n\ntemplate<class T>\nvoid add_edge(AdjList<T> &adj,int u,int v,T capa){\n\tadj[u].push_back((Edge<T>){v,adj[v].size()  ,capa,0});\n\tadj[v].push_back((Edge<T>){u,adj[u].size()-1,capa,0});\n}\n\ntemplate<class T>\nT augment(AdjList<T> &adj,int s,int t){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<bool> vis(n); vis[s]=true;\n\n\tqueue< pair<int,T> > qu;\n\tqu.push(make_pair(s,INF));\n\n\tT res=0;\n\twhile(!qu.empty()){\n\t\tint u=qu.front().first;\n\t\tT water=qu.front().second;\n\t\tqu.pop();\n\n\t\tif(u==t){ res=water; break; }\n\n\t\trep(i,adj[u].size()){\n\t\t\tEdge<T> &e=adj[u][i];\n\t\t\tif(!vis[e.v] && e.capa-e.flow>0){\n\t\t\t\tvis[e.v]=true;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\tqu.push(make_pair(e.v,min(water,e.capa-e.flow)));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(res>0){\n\t\tfor(int v=t;v!=s;){\n\t\t\tEdge<T> &e1=adj[v][pre[v]];\n\t\t\tEdge<T> &e2=adj[e1.v][e1.rev];\n\t\t\te1.flow-=res;\n\t\t\te2.flow+=res;\n\t\t\tv=e1.v;\n\t\t}\n\t}\n\n\treturn res;\n}\n\ntemplate<class T>\nT Edmonds_Karp(AdjList<T> &adj,int s,int t){\n\tT ans=0;\n\tfor(T water=1;water>0;ans+=water) water=augment(adj,s,t);\n\treturn ans;\n}\n\nbool vis[500];\nbool dfs(int u,int sign,int g,AdjList<int> &adj){\n\tvis[u]=true;\n\tif(u==g) return true;\n\trep(i,adj[u].size()){\n\t\tEdge<int> &e=adj[u][i];\n\t\tif(!vis[e.v] && e.flow*sign>0 && dfs(e.v,sign,g,adj)){\n\t\t\te.flow=0;\n\t\t\tadj[e.v][e.rev].flow=0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\tAdjList<int> adj(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tadd_edge(adj,u,v,1);\n\t}\n\n\tint ans=Edmonds_Karp(adj,0,n-1);\n\n\twhile(q--){\n\t\tint type,u,v; scanf(\"%d%d%d\",&type,&u,&v); u--; v--;\n\t\tif(type==1){ // add\n\t\t\tadd_edge(adj,u,v,1);\n\t\t}\n\t\telse{ // erase\n\t\t\tint i;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v && adj[u][i].capa>0) break;\n\t\t\tint i_rev=adj[u][i].rev;\n\n\t\t\tint flow=adj[u][i].flow;\n\t\t\tadj[u][i].capa=adj[v][i_rev].capa=0;\n\t\t\tadj[u][i].flow=adj[v][i_rev].flow=0;\n\t\t\tif(flow!=0){\n\t\t\t\t// ツフツδ債ーツづーツ可淞つオツ姪淞つキ\n\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\tif(flow>0){ // u ツつゥツづァ v ツづ鳴フツδ債ーツつェツ猟ャツづェツづつ「ツつス\n\t\t\t\t\tif(dfs(u,-1,0,adj) && dfs(v,+1,n-1,adj)) ans--;\n\t\t\t\t}\n\t\t\t\telse{ // v ツつゥツづァ u\n\t\t\t\t\tif(dfs(v,-1,0,adj) && dfs(u,+1,n-1,adj)) ans--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans+=Edmonds_Karp(adj,0,n-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 500\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G[to].size()));\n  G2[to].push_back(edge(from,cap,G[from].size()-1));\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) cin>>f>>t,add_edge(f,t,1);\n  while(Q--){\n    int m,a,b;\n    cin>>m>>a>>b;\n    if(m==1){\n      add_edge(a,b,1);\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n    }\n    for(int i=0;i<=N;i++) G[i]=G2[i];\n    cout<<max_flow(1,N)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            Flow tmpcap=e.cap,tmprevcap=reve.cap;\n            \n            Flow revd = max_flow(s,t,d);\n            max_flow(T,S,d-revd);\n            assert(max_flow(s,t,d-revd)==d-revd);\n            flow -= d-revd;\n\n            // e.cap =0;reve.cap = 0;\n            // // S <- s <- t <- T のパス\n            // Flow fs = max_flow(s,S,d);\n            // Flow ft = max_flow(T,t,d);\n            // Flow f = min(fs,ft);\n            // // cerr <<\"::f\" <<f <<endl;\n            // flow -= f;\n            // // 流しすぎ分の除去\n            // max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            // // 閉路の除去\n            // // s -> t -> s\n            // // cerr << make_tuple(s,t,d-f)<<endl;\n            // Flow floop = max_flow(s,t,d-f);\n\n            // s <- t d戻す\n            e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n            // 減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                \n                // edge is not used\n                \n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.getmaxflow(N-1, a, 1);\n                    fl.getmaxflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.getmaxflow(N-1, b, 1);\n                    fl.getmaxflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res = max(0,res);\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, cap, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n          max_flow(from, 0, 1);\n          max_flow(graph.size() - 1, to, 1);\n          return(1);\n        } else {\n          return(0);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n\n            //(1) S <- s <- t <- T の最大パスを求める\n            // e.cap = 0;reve.cap = 0;\n            // Flow fs = max_flow(s,S,d);\n            // Flow ft = max_flow(T,t,d);\n            // Flow f = min(fs,ft);\n            // //(1).1 流しすぎた分戻す\n            // max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\n            max_flow(s,t,d);\n            Flow f = max_flow(T,S,d);\n            flow -= f;\n\n            //(2) 残り(d-f)は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n            e.cap = 0;reve.cap=c + reve.icap;\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll idx = -1;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    idx = j;\n                    break;\n                }\n            }\n            Edge e = G[A][idx];\n            ll r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n            assert(G[B][e.rev].to == A);\n            assert(e.cap + G[B][e.rev].cap == 2);\n            e.cap = 0, e.to = -1;\n            G[B][e.rev].cap = 0, G[B][e.rev].to = -1;\n            // G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n            // G[A].erase(G[A].begin()+idx, G[A].begin()+idx+1);\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else if (r == -1) {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef int flow_t;\n\nconst int MAX_N = 500;\nconst int MAX_E = 20000;\nconst int MAX_Q = 1000;\n\nstruct edge{\n\tint tar;\n\tflow_t cap;\n\tbool on;\n};\n\nstruct query{\n\tint cmd;\n\tint x, y;\n};\n\nint V, E, Q;\nvector<edge> graph[MAX_N];\nint id_table[MAX_N][MAX_N];\nquery qs[MAX_Q];\n\nvoid add_edge(int x, int y, flow_t cap, bool on){\n\tid_table[x][y] = graph[x].size();\n\tid_table[y][x] = graph[y].size();\n\tgraph[x].push_back((edge){y, cap, on});\n\tgraph[y].push_back((edge){x, cap, on});\n}\n\nvoid init(){\n\tscanf(\"%d%d%d\", &V, &E, &Q);\n\tmemset(id_table, -1, sizeof(id_table));\n\tfor(int i=0; i<E; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--; y--;\n\t\tadd_edge(x, y, 1, true);\n\t}\n\n\tfor(int i=0; i<Q; i++){\n\t\tint c, x, y;\n\t\tscanf(\"%d%d%d\", &c, &x, &y);\n\t\tx--; y--;\n\t\tqs[i] = (query){c, x, y};\n\t\tif(id_table[x][y] == -1){\n\t\t\tadd_edge(x, y, 0, false);\n\t\t}\n\t}\n\n}\n\nbool visited[MAX_N];\nint vis_time[MAX_N];\n\nbool dfs(int v, int sink){\n\tif(v == sink){\n\t\treturn true;\n\t}\n\tvisited[v] = true;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0 && !visited[e.tar] && dfs(e.tar, sink)){\n\t\t\te.cap--;\n\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rem_dfs(int v){\n\tvis_time[v] = 2;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0){\n\t\t\tif(vis_time[e.tar] == 1 || (vis_time[e.tar] == 0 && rem_dfs(e.tar))){\n\t\t\t\te.cap--;\n\t\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool remove_cycle(int x, int y){\n\tmemset(vis_time, 0, sizeof(vis_time));\n\tvis_time[y] = 1;\n\treturn rem_dfs(x);\n}\n\nvoid solve(){\n\tconst int source = 0, sink = V - 1;\n\tflow_t current = 0;\n\n\tfor(;memset(visited, false, sizeof(visited)), dfs(source, sink); current++);\n\n\tfor(int i=0; i<Q; i++){\n\t\tif(qs[i].cmd == 1){\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tgraph[x][id_table[x][y]].on = true;\n\t\t\tgraph[y][id_table[y][x]].on = true;\n\t\t\tgraph[x][id_table[x][y]].cap = 1;\n\t\t\tgraph[y][id_table[y][x]].cap = 1;\n\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\tif(dfs(source, sink)){\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tif(graph[x][id_table[x][y]].cap != 1){\n\n\t\t\t\t// ツ個サツ催敖づ郊 -> yツづ猟ャツづェツづつ「ツづゥツづヲツつ、ツづ可暗ェツ氾環可サ\n\t\t\t\tif(graph[x][id_table[x][y]].cap == 2){\n\t\t\t\t\tswap(x, y);\n\t\t\t\t}\n\t\t\t\tif(!remove_cycle(x, y)){\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(x, source);\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(sink, y);\n\t\t\t\t\tcurrent--;\n\t\t\t\t}\n\t\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\t\tgraph[x][id_table[x][y]].cap = 0;\n\t\t\t\tgraph[y][id_table[y][x]].cap = 0;\n\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\tif(dfs(source, sink)){\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", current);\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=200000;\n\nstruct edge{\n\tint to,cap,rev,id;\n\tint flow;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t\tflow=0;\n\t}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,cap,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// ØfÏÝ\n\t\tif(!isUsable[e.id])continue;\n\t\t// Ü¾t[ð¬¹éÈçÎA¬·\n\t\tif(!used[e.to]&&e.flow<e.cap){\n\t\t\t// ¡ñÌ¬Ê\n\t\t\tint quan=e.cap-e.flow;\n\t\t\t//if(e.flow<0)quan=-(e.flow);\n\t\t\tint d=dfs(e.to,t,min(f,quan));\n\t\t\tif(d>0){\n\t\t\t\te.flow+=d;\n\t\t\t\t// ½ÎÉÍ}CiXÌvfðüêÄ¨­\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}// ¸­pXðTõ\nint dfs2(int v,int t){\n\tif(v==t) return 1;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!isUsable[e.id])continue;\n\t\t// 0æè¬³¯êÎAß·\n\t\tif(!used[e.to]&&e.flow<0){\n\t\t\tint d=dfs2(e.to,t);\n\t\t\tif(d>0){\n\t\t\t\te.flow+=1;\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\telse flow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,ee,q;\n\tcin>>n>>ee>>q;\n\tfor(int i=0;i<ee;i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,ee);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=ee;\n\t\t\tisUsable[ee]=true;\n\t\t\tee++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\tfor(int i=0;i<(int)G[a].size();i++){\n\t\t\t\tedge &e=G[a][i];\n\t\t\t\tif(!isUsable[e.id])continue;\n\t\t\t\tif(eidx==e.id){\n\t\t\t\t\t// ¬êÄ¢È¢ê,tOðÜé¾¯\n\t\t\t\t\tif(e.flow==0)isUsable[eidx]=false;\n\t\t\t\t\t// ¬êÄ¢éê\n\t\t\t\t\telse{\n\t\t\t\t\t\tint from=a;\n\t\t\t\t\t\tint to=b;\n\t\t\t\t\t\tif(e.flow>0) swap(from,to);\n\t\t\t\t\t\t// flowð0Éú»\n\t\t\t\t\t\te.flow=G[e.to][e.rev].flow=0;\n\t\t\t\t\t\t// ûüÉµ½ªÁÄtü«Éflowð¬·\n\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(n,from);\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(to,1);\n\t\t\t\t\t\t// Øf\n\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1e8;\n\nstruct Edge {\n\tint to, rev, cap;\n};\n\nstruct Graph {\n\n\tvector<vector<Edge> > g;\n\tint gs, gt;\n\n\tvoid initialize(int n, int s, int t)\n\t{\n\t\tg.resize(n);\n\t\tfill(g.begin(), g.end(), vector<Edge>());\n\t\tgs = s;\n\t\tgt = t;\n\t}\n\n\tvoid add_edge(int a, int b)\n\t{\n\t\tg[a].push_back({b, (int)g[b].size(), 1});\n\t\tg[b].push_back({a, (int)g[a].size() - 1, 1});\n\t}\n\n\tbool flow_dfs(int v, int t, vector<bool> &used)\n\t{\n\t\tif(v == t)\n\t\t\treturn true;\n\t\tused[v] = true;\n\n\t\tfor(auto &e : g[v]) {\n\n\t\t\tif(used[e.to] || e.cap <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tconst bool f = flow_dfs(e.to, t, used);\n\t\t\tif(!f)\n\t\t\t\tcontinue;\n\n\t\t\te.cap -= 1;\n\t\t\tg[e.to][e.rev].cap += 1;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint max_flow_step(int s, int t)\n\t{\n\t\tstatic vector<bool> used;\n\n\t\tif(g.size() > used.size())\n\t\t\tused.resize(g.size());\n\t\tfill(used.begin(), used.end(), false);\n\n\t\treturn flow_dfs(s, t, used);\n\t}\n\n\tint max_flow()\n\t{\n\t\tint flow = 0;\n\n\t\twhile(true) {\n\n\t\t\tconst bool f = max_flow_step(gs, gt);\n\t\t\tif(f)\n\t\t\t\tflow += 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn flow;\n\t}\n\n\tvoid restore_edge(int a, int b)\n\t{\n\t\tfor(auto &e : g[a]) {\n\t\t\tif(e.to != b)\n\t\t\t\tcontinue;\n\t\t\tauto &re = g[b][e.rev];\n\t\t\te.cap += 1;\n\t\t\tre.cap += 1;\n\t\t\treturn;\n\t\t}\n\n\t\tadd_edge(a, b);\n\t}\n\n\tint reflow(Edge &e, Edge &re)\n\t{\n\t\tconst int from = re.to;\n\t\tconst int to = e.to;\n\t\tconst int f = max_flow_step(from, to);\n\n\t\tif(f >= 1) {\n\t\t\tre.cap -= 2;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmax_flow_step(from, gs);\n\t\tmax_flow_step(gt, to);\n\t\tre.cap -= 2;\n\n\t\treturn 1;\n\t}\n\n\tint remove_edge(int a, int b)\n\t{\n\t\tfor(auto &e : g[a]) {\n\n\t\t\tif(e.to != b)\n\t\t\t\tcontinue;\n\n\t\t\tauto &re = g[b][e.rev];\n\n\t\t\tif(e.cap >= 1 && re.cap >= 1) {\n\n\t\t\t\te.cap -= 1;\n\t\t\t\tre.cap -= 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif(e.cap == 0)\n\t\t\t\treturn reflow(e, re);\n\t\t\telse\n\t\t\t\treturn reflow(re, e);\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\n\n\n\nint main()\n{\n\tint n, e, q;\n\tGraph g;\n\n\tscanf(\"%d%d%d\", &n, &e, &q);\n\tconst int gs = 0, gt = n - 1;\n\tg.initialize(n, gs, gt);\n\n\tfor(int i = 0; i < e; ++i) {\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tf -= 1; t -= 1;\n\t\tg.add_edge(f, t);\n\t}\n\n\tint flow = g.max_flow();\n\n\tfor(int query_num = 0; query_num < q; ++query_num) {\n\n\t\tint m, a, b;\n\n\t\tscanf(\"%d%d%d\", &m, &a, &b);\n\t\ta -= 1; b -= 1;\n\n\t\tif(m == 1) {\n\n\t\t\tg.restore_edge(a, b);\n\t\t\tflow += g.max_flow();\n\n\t\t} else {\n\n\t\t\tflow -= g.remove_edge(a, b);\n\t\t}\n\n\t\tprintf(\"%d\\n\", flow);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2313.cc: Box Witch\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 500;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef set<int> si;\ntypedef queue<int> qi;\n\n/* global variables */\n\nsi nbrs[MAX_N];\nint minfs[MAX_N], prvs[MAX_N];\nint flows[MAX_N][MAX_N], caps[MAX_N][MAX_N];\n\n/* subroutines */\n\nint calc_flow(int st, int gl, int maxf) {\n  int f = 0;\n  \n  for (;;) {\n    //printf(\"max_flow = %d, limit = %d\\n\", max_flow, limit);\n\n    memset(prvs, -1, sizeof(prvs));\n    prvs[st] = st;\n    minfs[st] = INF;\n\n    qi q;\n    q.push(st);\n\n    while (! q.empty()) {\n      int ui = q.front(); q.pop();\n\n      if (ui == gl) break;\n      si& nbru = nbrs[ui];\n      for (si::iterator sit = nbru.begin(); sit != nbru.end(); sit++) {\n        int vi = *sit;\n        int vc = caps[ui][vi] - flows[ui][vi];\n        if (prvs[vi] < 0 && vc > 0) {\n          prvs[vi] = ui;\n          minfs[vi] = (minfs[ui] < vc) ? minfs[ui] : vc;\n          q.push(vi);\n        }\n      }\n    }\n\n    if (prvs[gl] < 0) break;\n\n    int min_flow = minfs[gl];\n    for (int j = gl; j != st;) {\n      int i = prvs[j];\n      flows[i][j] += min_flow;\n      flows[j][i] -= min_flow;\n      j = i;\n    }\n\n    f += min_flow;\n    if (f >= maxf) break;\n  }\n\n  return f;\n}\n\nint calc_maxflow(int gl) {\n  int max_flow = 0;\n  si& nbrg = nbrs[gl];\n  for (si::iterator sit = nbrg.begin(); sit != nbrg.end(); sit++)\n    if (flows[*sit][gl] > 0) max_flow += flows[*sit][gl];\n  return max_flow;\n}\n\n/* main */\n\nint main() {\n  int n, en, qn;\n  cin >> n >> en >> qn;\n\n  for (int i = 0; i < en; i++) {\n    int fi, ti;\n    cin >> fi >> ti;\n    fi--, ti--;\n    nbrs[fi].insert(ti);\n    nbrs[ti].insert(fi);\n    caps[fi][ti] = caps[ti][fi] = 1;\n  }\n\n  memset(flows, 0, sizeof(flows));\n  calc_flow(0, n - 1, INF);\n  int mf = calc_maxflow(n - 1);\n\n  while (qn--) {\n    int mi, ai, bi;\n    cin >> mi >> ai >> bi;\n    ai--, bi--;\n    //printf(\"%d: %d, %d\\n\", mi, ai, bi);\n    \n    if (mi == 1) { // add\n      nbrs[ai].insert(bi);\n      nbrs[bi].insert(ai);\n      caps[ai][bi] = caps[bi][ai] = 1;\n      if (calc_flow(0, n - 1, 1)) mf++;\n    }\n    else { // delete\n      int pf = flows[ai][bi];\n      nbrs[ai].erase(bi);\n      nbrs[bi].erase(ai);\n      caps[ai][bi] = caps[bi][ai] = 0;\n      flows[ai][bi] = flows[bi][ai] = 0;\n\n      if (pf != 0) {\n\tif (pf < 0) swap(ai, bi);\n\tif (calc_flow(ai, bi, 1) == 0) {\n\t  calc_flow(n - 1, bi, 1);\n\t  calc_flow(ai, 0, 1);\n\t  mf--;\n\t}\n      }\n    }\n\n    printf(\"%d\\n\", mf);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight;\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i+1 << \", \" << g[i][j].dst+1 << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\nclass FordFulkerson {\npublic:\n    Graph g; // ????????????????????????\n    int s, t; // ?§????, ??????\n    int n; // ????????°\n    ll flow = 0; // ?????§????????????????????????????????????????????????????????¨??´??°??????\n\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // ??????????????????src, dst, cap????????±?????????\n    // ????????°?????????????????????????????????\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // ?????????????????????\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // ????????°???????????????????????????????????´???????????????\n    // flow???????¨??????????\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // ????????°????????????????????????\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n    // ???????????????\n    // ????????°????????§???v??????t????????£??????????????¢?????????????????°???????????????\n    //\n    // s??????t????§???????????????????????????????????????§?????????????????????????????????0????????????\n    // f??????????????¨??????????????????\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // ?????£???????????£????????£?????????????????¢??? \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // ???????????¨???????????????????????£???????????£??????????°??????????????¬???????????????¨??????\n            if (d > 0) {\n                e.cap -= d; // ????????°?????????????????´??°\n                g[e.dst][e.rev].cap += d; // ????????°????????????????????´??°\n                return d;\n            }\n        }\n        return 0;\n    }\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // s??????t???????????§??????????????????\n    // s == t??????INF?????????, ???????????????0?????????\n    ll get(void) {\n        return flow;\n    }\n    // O(V) \n    // from??????to??????????????????cap???????????????????????????????????§???????????????\n    // ???????????????????????¨?????¨???????????£????????????????????????\n    // TODO ????¢????????????????\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // ?????¨?????¨?????£??????\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    //  ??? ??§ ??? ??? ??? ??? ??? ??? ??? ??????from->to???????????????????°????????????°???????????????????????????\n    //\n    // from??????to?????????????????????????????£??????????????¢????????¨??§????????§???????????????????????¶?????§??????????????????????????????\n    // from->to????????????????????£??????????????????????????????????????¨??§from->to????????????????°??????°???????????¨g?????????????????????\n    //\n    // from->??????->to->from??§????????????????????\\???????????°???\n    // from->to????????????????????????????????????????????????????????¨?????§?????????\n    // ?????????????????????????????????????????¨?????????????????????????????¨????????\\??????\n    ll minimizeFlowOfEdgePreservingMaxFlow(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // ???????????????????????????from??????to???????????????????????¨??????\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // ?¶????????????????????????????????????£?????¨??¨?????????????????¨??????\n            // ??????????????????????????£???????????¨??§?????????\n            while (1) { // TODO ?????????????????????????????°??????\n                // e.src?????????????????°??????????????????????????°???????????????\n                bool used[n];\n                rep(i, n) {\n                    used[i] = false;\n                }\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n                        if (tmp.src == e.src && tmp.dst == e.dst) continue;\n                        if (tmp.src == e.dst && tmp.dst == e.dst) continue;\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                e.cap += can_erase;\n                e_rev.cap -= can_erase;\n                sum += can_erase;\n\n                if (can_erase == 0) { // ????????§????¶????????????????\n                    // TODO ??¬?????????????????\\???????????§?????¨??¨??????????¢??????????????????????????¬????????????§???????????????\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n    // O(V) \n    // from??????to?????????????????????cap???????????????????????????????????§???????????????\n    // cap???0????????£?????????????????°????????????????????????????¶??????????\n    int erase(int from, int to, ll cap) {\n        // ???????????¨????????????????????????????¶????????????????????????£???????????????????¢????\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // ?????????????????¨??????\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // ?????£????????????????????£???????°????????????????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // ??????????????????????????????from??????to??????????????????????????¨??????\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n \n        // ??????cap????¶????????????¨????????????\n        // ????????°????????§???t->s???????¢???§??????cap???????????????????????????????????????flow???????°??????????\n        // ????°????????????????????????????????????????????????????????????¨???????????§??????????????¨???????????????????????????\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n    // from??????to??????????????¨?????? \n    //\n    // O(V)\n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, q; cin >> n >> e >> q;\n    Graph g(n);\n    rep(i, e) {\n        ll f, t; cin >> f >> t; f--, t--;\n        addDirected(g, f, t, 0, 1);\n        addDirected(g, t, f, 0, 1);\n    }\n    FordFulkerson ff(g, 0, n-1); \n//        printGraphCap(ff.g);\n//    printGraphCap(ff.g);\n    rep(i, q) {\n        int type, u, v; cin >> type >> u >> v; u--; v--;\n        if (type == 1) {\n            ff.add(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.add(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        } else {\n            ff.erase(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.erase(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        }\n//        printGraphCap(ff.g);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t)  return f;\n\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    int flow = 0;\n    while (bfs(s), s != t && level[t] >= 0 && flow_ > 0) {\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n    }\n\n    return flow;\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        int j = 0;\n        while (G[a][j].to != b) j++;\n        if (m == 1) {\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n, 1);\n        } else {\n            int from = -1, to = -1;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 && to > 0 && max_flow(from, to, 1) == 0) {\n                f--;\n                max_flow(from, 1);\n                max_flow(n, to);\n            }\n        }\n        cout << f << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    // s->t 増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap += c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap -= e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            e.cap = 0;reve.cap = 0;\n            //(1) S <- s <- t <- T のフローを戻す。\n            Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) (1)で流せない分は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n            e.cap = 0;reve.cap = c + reve.icap;\n            e.icap = c;\n\t        flow += max_flow(S,T);\n        }\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n \n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct FordFulkerson {\n\tusing Flow = int;\n\tint n;\n\tint s, t;\n\tFlow maxflow;\n\tvector<vector<Flow>> g;\n\tvector<bool> used;\n\tFordFulkerson(int n, int s = -1, int t = -1) :n(n), g(n, vector<Flow>(n)), used(n), s(s), t(t), maxflow(0) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from][to] = cap;\n\t}\n\tvoid addEdge(int from, int to, Flow cap) {\n\t\taddArc(from, to, cap);\n\t\taddArc(to, from, cap);\n\t}\n\tFlow addEdgeCap(int from, int to, Flow cap) {\n\t\tif (cap > 0) {\n\t\t\tg[from][to] += cap;\n\t\t\tg[to][from] += cap;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tmaxflow += augment(s, t, cap);\n\t\t}\n\t\telse {\n\t\t\tFlow rcap = -cap;\n\t\t\tif (g[from][to] - rcap >= 0 && g[to][from] - rcap >= 0) {\n\t\t\t\tg[from][to] -= rcap;\n\t\t\t\tg[to][from] -= rcap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(s != -1 && t != -1);\n\n\t\t\t\tif (g[from][to] > g[to][from])swap(from, to);\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\taugment(t, to, rcap);\n\t\t\t\taugment(from, s, rcap);\n\n\t\t\t\tg[from][to] += rcap;\n\t\t\t\tg[to][from] -= rcap;\n\n\t\t\t\tg[from][to] -= rcap;\n\t\t\t\tg[to][from] -= rcap;\n\n\t\t\t\tmaxflow += cap;\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tmaxflow += augment(s, t, -cap);\n\t\t\t}\n\t\t}\n\n\t\treturn maxflow;\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tFlow f = augment(s, t, INF);\n\t\t\tif (f == 0)return maxflow = total;\n\t\t\ttotal += f;\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, E, Q; cin >> N >> E >> Q;\n\tFordFulkerson ff(N, 0, N - 1);\n\trep(i, 0, E) {\n\t\tint F, T; cin >> F >> T; F--, T--;\n\t\tff.addEdge(F, T, 1);\n\t}\n\tdump(ff.g);\n\tff.maximumFlow(0, N - 1);\n\tdump(ff.g);\n\trep(i, 0, Q) {\n\t\tint M, A, B; cin >> M >> A >> B;\n\t\tA--, B--;\n\t\tif (M == 1) {\n\t\t\tcout << ff.addEdgeCap(A, B, 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ff.addEdgeCap(A, B, -1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\t//tmp=maxFlow(n,from,to);\n\ttmp=fordFulkerson(n,to,from,1);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,from,s);\n\t  fordFulkerson(n,s,from,1);\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,t,to);\n\t  fordFulkerson(n,to,t,1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint N, E, Q;\nint cap[500][500];\nbool used[500];\nint dfs(int u, int t, int f){\n    if(u == t) return f;\n    used[u] = true;\n    REP(v, N)if(!used[v] && cap[u][v] > 0){\n        int d = dfs(v, t, min(f, cap[u][v]));\n        if(d > 0){\n            cap[u][v] -= d;\n            cap[v][u] += d;\n            return d;\n        }\n    }\n    return 0;\n}\nint main(){\n    while(cin >> N >> E >> Q && N){\n        memset(cap, 0, sizeof cap);\n        REP(_, E){\n            int F, T;\n            cin >> F >> T;\n            F--; T--;\n            cap[F][T] = 1;\n            cap[T][F] = 1;\n        }\n        int flow = 0;\n        REP(_, Q){\n            int M, A, B;\n            cin >> M >> A >> B;\n            A--; B--;\n            if(M == 1){ // add edge\n                assert(cap[A][B] == 0 && cap[B][A] == 0); // assert no edge\n                cap[A][B] = cap[B][A] = 1; // add edge\n            }else{ // delete edge\n                if(cap[A][B] == 2){ // flowing 0->B->A->N-1\n                    memset(used, 0, sizeof used);\n                    assert(dfs(N - 1, A, 1) == 1); // N-1->A\n                    memset(used, 0, sizeof used);\n                    assert(dfs(B, 0, 1) == 1); // B->0\n                    cap[A][B]--; //A->B\n                    cap[B][A]++;\n                    flow--; // reverse flow\n                }else if(cap[B][A] == 2){ // flowing 0->A->B->N-1\n                    memset(used, 0, sizeof used);\n                    assert(dfs(N - 1, B, 1) == 1); // N-1->B\n                    memset(used, 0, sizeof used);\n                    assert(dfs(A, 0, 1) == 1); // A->0\n                    cap[B][A]--; // B->A\n                    cap[A][B]++;\n                    flow--; // reverse flow\n                }\n                assert(cap[A][B] == 1 && cap[B][A] == 1); // assert no flowing\n                cap[A][B] = cap[B][A] = 0; // remove edge\n            }\n            // update flow\n            while(true){\n                memset(used, 0, sizeof used);\n                int f = dfs(0, N - 1, 2);\n                if(f == 0) break;\n                flow += f;\n            }\n            cout << flow << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim=INF){\n    if(s==t)return 0;\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1);\n}\n\nvoid q(int a,int b){\n\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.type==1&&e.to==b){\n            f1=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n    for(auto &e:G[b]){\n        if(e.type==1&&e.to==a){\n            f2=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n\n\n    if(f1==f2)return;\n\n    if(f1){\n        max_flow(N-1,b,1);max_flow(a,0,1);\n    }\n    if(f2){\n        max_flow(N-1,a,1);max_flow(b,0,1);\n    }\n    f--;\n    f+=max_flow(0,N-1);\n}\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);q1(b,a);\n        }\n        else{\n            q(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.type==1&&e.cap==0)cout<<i+1<<\" \"<<e.to+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct FordFulkerson {\n\tusing Flow = int;\n\tint n;\n\tint s, t;\n\tFlow maxflow;\n\tvector<vector<Flow>> g;\n\tvector<bool> used;\n\tFordFulkerson(int n, int s = -1, int t = -1) :n(n), g(n, vector<Flow>(n)), used(n), s(s), t(t), maxflow(0) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from][to] = cap;\n\t}\n\tvoid addEdge(int from, int to, Flow cap) {\n\t\taddArc(from, to, cap);\n\t\taddArc(to, from, cap);\n\t}\n\tFlow addEdgeCap(int from, int to, Flow cap) {\n\t\tif (cap > 0) {\n\t\t\tg[from][to] += cap;\n\t\t\tg[to][from] += cap;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tmaxflow += augment(s, t, cap);\n\t\t}\n\t\telse {\n\t\t\tFlow rcap = -cap;\n\t\t\tif (g[from][to] - rcap >= 0 && g[to][from] - rcap >= 0) {\n\t\t\t\tg[from][to] -= rcap;\n\t\t\t\tg[to][from] -= rcap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(s != -1 && t != -1);\n\n\t\t\t\tif (g[from][to] > g[to][from])swap(from, to);\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\taugment(t, to, rcap);\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\taugment(from, s, rcap);\n\n\t\t\t\tg[from][to] += rcap;\n\t\t\t\tg[to][from] -= rcap;\n\n\t\t\t\tg[from][to] -= rcap;\n\t\t\t\tg[to][from] -= rcap;\n\n\t\t\t\tmaxflow += cap;\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tmaxflow += augment(s, t, -cap);\n\t\t\t}\n\t\t}\n\n\t\treturn maxflow;\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tFlow f = augment(s, t, INF);\n\t\t\tif (f == 0)return maxflow = total;\n\t\t\ttotal += f;\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, E, Q; cin >> N >> E >> Q;\n\tFordFulkerson ff(N, 0, N - 1);\n\trep(i, 0, E) {\n\t\tint F, T; cin >> F >> T; F--, T--;\n\t\tff.addEdge(F, T, 1);\n\t}\n\tdump(ff.g);\n\tff.maximumFlow(0, N - 1);\n\tdump(ff.g);\n\trep(i, 0, Q) {\n\t\tint M, A, B; cin >> M >> A >> B;\n\t\tA--, B--;\n\t\tif (M == 1) {\n\t\t\tcout << ff.addEdgeCap(A, B, 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ff.addEdgeCap(A, B, -1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    // s->t 増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap += c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap -= e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            e.cap = 0;reve.cap = 0;\n            //(1) S <- s <- t <- T のフローを戻す\n            Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) (1)で流せない分は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n            e.cap = 0;reve.cap = c + reve.icap;\n            e.icap = c;\n        }\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n \n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    cin >> f >> t;\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n \nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n \nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n \nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n \nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  int prev=0;\n  for(int i=1;i<=N;i++) G[i]=G2[i];\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      if(M[a].find(b)==M[a].end()) {\n\tadd_edge(a,b,1);\n\tG[a].push_back(edge(b,1,G[a].size()));\n\tG[b].push_back(edge(a,1,G[b].size()-1));\n      }else{\n\tG[a][M[a][b]].cap=G[b][M[b][a]].cap=1;\n\tG2[a][M[a][b]].cap=G2[b][M[b][a]].cap=1;\n      }\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n      for(int i=1;i<=N;i++) G[i]=G2[i];\n      prev=0;\n    }\n    prev=prev+max_flow(1,N);\n    printf(\"%d\\n\",prev);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        add_edge(s,t,1);\n        add_edge(t,s,1);\n    }\n    rep(i,q){\n        int x, s, t;\n        cin >> x >> s >> t;\n        s--; t--;\n        if(x == 1){\n            add_edge(s,t,1);\n            add_edge(t,s,1);\n        } else{\n            vector<edge> tmp1;\n            rep(j,G[s].size()){\n                if(G[s][j].to != t) tmp1.push_back(G[s][j]);\n            }\n            G[s] = tmp1;\n            tmp1.clear();\n            vector<edge> tmp2;\n            rep(j,G[t].size()){\n                if(G[t][j].to != s) tmp2.push_back(G[t][j]);\n            }\n            G[t] = tmp2;\n        }\n        rep(j,n) H[j] = G[j];\n        cout << max_flow(0,n-1) << endl;\n        rep(j,n) G[j] = H[j];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[601];\nint level[601];\nint iter[601];\nint data[601][601];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\tdata[from][to]=G[from].size()-1;\n\tdata[to][from]=G[to].size()-1;\n}\n\nvoid change_flow(int from,int to,int cap){\n\tif(cap==1){\n\t\tG[from][data[from][to]].cap=1;\n\t\tG[to][data[to][from]].cap=1;\n\t}else{\n\t\tG[from][data[from][to]].cap=0;\n\t\tG[to][data[to][from]].cap=0;\n\t}\n}\n\nint check_flow(int from,int to){\n\treturn G[from][data[from][to]].cap;\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nvector<int> vec;\nbool used[601];\n\nint back_dfs(int s,int t,int f){\n\tif(s==t)return f;\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tedge &e=G[s][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=back_dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint n,m,q;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tmemset(data,-1,sizeof(data));\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tadd_edge(f,t,1);\n\t}\n\tint res=max_flow(0,n-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tif(t==1){\n\t\t\tif(data[a][b]==-1)add_edge(a,b,1);\n\t\t\telse{\n\t\t\t\tchange_flow(a,b,1);\n\t\t\t}\n\t\t}else{\n\t\t\tmemset(used,false,sizeof(used));\n\t\t\tint type=check_flow(a,b);\n\t\t\tchange_flow(a,b,0);\n\t\t\tif(type==0){\n\t\t\t\tif(back_dfs(a,b,1)==1){\n\t\t\t\t}else{\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tback_dfs(n-1,b,1);\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tback_dfs(a,0,1);\n\t\t\t\t\tres--;\n\t\t\t\t}\n\t\t\t}else if(type==2){\n\t\t\t\tif(back_dfs(b,a,1)==1){\n\t\t\t\t}else{\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tback_dfs(n-1,a,1);\n\t\t\t\t\tmemset(used,false,sizeof(used));\n\t\t\t\t\tback_dfs(b,0,1);\n\t\t\t\t\tres--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres+=max_flow(0,n-1);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t//cout << v << ' ' << e.to << ' ' << e.cap << endl;\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\tauto& e = G[a][edge[a][b]];\n\t\t\tauto& re = G[b][e.rev];\n\n\t\t\te.cap = re.cap = 1;\t\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\tauto e = G[a][edge[a][b]];\n\t\t\tint d = e.cap;\n\t\t\te.cap = G[b][e.rev].cap = 0;\n\t\t\tif(d == 1) return 0;\n\t\t\tif(d == 2){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(b, a, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, a, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(b, s, 1);\n\t\t\t}else{\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(a, s, 1);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tint subCapacity_(int s, int t, int a, int b){\n\t\t\t//cout << \"SUB\" << endl;\n\t\t\t//if(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\t//cout << a << ' ' << b << endl;\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\tif(ab.cap >= 1){\n\t\t\t\t//cout << \"WY\" << endl;\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\t//cout << \"HE\" << endl;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcout << \"OUT\" << endl;\n\n\t\t\t\t//for(auto i : G){\n\t\t\t\t//\tfor(auto j : i){\n\t\t\t\t//\t\tcout << j.to << ' ' << j.cap << ' ' << j.rev << endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint ans = dfs(a, s, 1);\n\t\t\t\t//show(ans)\n\t\t\t\t//assert(ans == 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\t//assert(dfs(t, b, 1) == 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = 0, t = n - 1;\n\t//flow.addEdge(s, 0, INF);\n\t//flow.addEdge(n - 1, t, INF);\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not use[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\t//assert(flow.fordFulkerson(s, t) == 0);\n\t\tcout << ans << endl;\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#define N 501\nconst int inf= 1000000000;\nusing namespace std;\n \nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  for(int i = 0 ;i < n ; i++){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n        flow[now][next]+=tmp;\n        flow[next][now]=-flow[now][next];\n        return tmp;\n      }\n    }\n  }\n  return 0;\n}\n \nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  for(int i = 0 ; i < n ; i++)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    for(int i = 0 ; i < n ; i++)vis[i]=false;\n  }\n  return ret;\n}\n \nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n        flow[now][next]=flow[next][now]=0;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n \nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n        flow[now][next]+=1;\n        flow[next][now]=-flow[now][next];\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n \n \nint main(void){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n        cap[i][j] = 0;\n        flow[i][j] = 0;\n      }\n    }\n \n    for(int i = 0 ; i < e ; i++){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    for(int i = 0 ; i < q ; i++){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n        cap[from][to]=cap[to][from]=1;\n        tmp = maxFlow(n,s,t);\n        cout << prev+tmp << endl;\n        prev=prev+tmp;\n      }else if (flow[from][to] == 0){\n        cap[from][to]=cap[to][from]=0;\n        cout << prev << endl;\n      }else {//delete\n        if (flow[from][to] < 0)swap(from,to);\n        cap[from][to]=cap[to][from]=0;\n        flow[from][to]=flow[to][from]=0;\n        for(int j = 0 ; j < n ; j++)vis[i] = false;\n        tmp=dfs2(n,from,to);\n        if (tmp != 0){\n          cout << prev << endl;\n          prev=prev;//keep\n        }else {\n          for(int j = 0 ;j < n ; j++)vis[j] = false;\n          dfs(n,from,s);\n          for(int j = 0 ; j < n; j++)vis[j] = false;\n          dfs(n,t,to);\n          cout << prev-1 << endl;\n          prev=prev-1;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(){}\n\tEdge(int s, int d, int c)\n\t\t:src(s), dst(d), cst(c)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint\tcapa[502][502];\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=capa[p][next];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tcapa[p][next]-=f;\n\t\t\tcapa[next][p]+=f;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n//流量を制限するdinic\nint dinic(int S, int T, int L, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end && total < L)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\n\t\t\t\tint next=e.dst;\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]<=0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, L, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t\tif(total >= L) break;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int t, int v, Graph& g)\n{\n\tg[s].push_back(Edge(s,t,v));\n\tg[t].push_back(Edge(t,s,v));\n\n\tcapa[s][t] += v;\n\tcapa[t][s] += v;\n}\n\nvoid add_pass(int s, int t, Graph& g)\n{\n\tg[s].push_back(Edge(s,t,0));\n\tg[t].push_back(Edge(t,s,0));\n}\n\nvoid reduce_cap(int s, int t, int v, Graph& g)\n{\n\tcapa[s][t] -= v;\n\tcapa[t][s] -= v;\n}\n\nvoid add_cap(int s, int t, int v, Graph& g)\n{\n\tcapa[s][t] += v;\n\tcapa[t][s] += v;\n}\n\nvoid solve(int N, Graph& g, vector<Edge>& queries)\n{\n\tint f = dinic(0,N-1,INF,g);\n\tfor(int i=0; i<queries.size(); i++)\n\t{\n\t\tEdge &e = queries[i];\n\n\t\tif(e.cst == 1) {\n\t\t\tadd_cap(e.src, e.dst, 1, g);\n\t\t\tf += dinic(0,N-1,1,g);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(capa[e.src][e.dst] == 1) \n\t\t\t{\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t}\n\n\t\t\telse if(capa[e.src][e.dst] == 2) {\n\t\t\t\tdinic(e.dst, 0, 1, g);\n\t\t\t\tdinic(N-1, e.src, 1, g);\n\t\t\t\tdinic(e.src, e.dst, 1, g);\n\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t\tf--;\n\n\t\t\t\tf+=dinic(0,N-1,1,g);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdinic(e.src, 0, 1, g);\n\t\t\t\tdinic(N-1, e.dst, 1, g);\n\t\t\t\tdinic(e.dst, e.src, 1, g);\n\t\t\t\t\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t\tf--;\n\n\t\t\t\tf+=dinic(0,N-1,1,g);\n\t\t\t}\n\t\t}\n\n\t\tcout << f << endl;\n\t}\n}\n\nint main()\n{\n\tint N,E,Q;\n\tcin >> N >> E >> Q;\n\n\tmemset(capa, 0, sizeof(capa));\n\n\tGraph g(N);\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\tadd_edge(s,t,1,g);\n\t}\n\n\tvector<Edge> queries(Q);\n\n\tfor(int i=0; i<Q; i++)\n\t{\n\t\tint m,s,t;\n\t\tcin >> m >> s >> t;\n\t\ts--; t--;\n\t\tqueries[i] = Edge(s,t,m);\n\t\tif(capa[s][t] == 0) add_pass(s,t,g);\n\t}\n\n\tsolve(N, g, queries);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\n//?????¬\n\n#define MAX_V 20001\n#define INF INT_MAX/6\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G(MAX_V); // ??°???????????£??\\???????????¨???\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\n // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to) {\n\tbool f = true;\n\tfor (auto i = G[from].begin(); i < G[from].end();)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\t(*i).cap = 1;\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tG[from].push_back({ to,1, (int)G[to].size() });\n\t}\n\tf = true;\n\tfor (auto i = G[to].begin(); i < G[to].end();)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 1;\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (f) {\n\t\tG[to].push_back({ from, 1, (int)G[from].size() - 1 });\n\t}\n}\n\n\n\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n// from??????to????????????????????????cap???0??¨?????????\nvoid del_edge(int from, int to) {\n\tint rev = INT_MIN;\n\tfor (auto i = G[from].begin(); i < G[from].end(); i++)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\trev = (*i).rev;\n\t\t\t(*i).cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rev != INT_MIN)\n\t{\n\t\tG[to][rev].cap = 0;\n\t}\n\t/*\n\tfor (auto i = G[to].begin(); i < G[to].end(); i++)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*/\n}\n\nint main() {\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor (size_t i = 0; i < E; i++)\n\t{\n\t\tint F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge(F, T);\n\t}\n\tfor (size_t i = 0; i < Q; i++)\n\t{\n\t\tint M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif (M == 1)\n\t\t{\n\t\t\tadd_edge(A, B);\n\t\t}\n\t\telse {\n\t\t\tdel_edge(A, B);\n\t\t}\n\t\tauto G_ = G;\n\t\tcout << max_flow(0, N - 1) << endl;\n\t\tG = G_;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint n, e, q;\nint x[1000], s[1000], t[1000];\nset<P> saw;\nint pre = 0;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        if(s > t) swap(s,t);\n        s--; t--;\n        saw.insert(P(s,t));\n        add_edge(s,t,1);\n    }\n    rep(i,q){\n        cin >> x[i] >> s[i] >> t[i];\n        s[i]--; t[i]--;\n        if(s[i] > t[i]) swap(s[i],t[i]);\n        if(saw.count(P(s[i],t[i])) == 0){\n            add_edge(s[i],t[i],0);\n            saw.insert(P(s[i],t[i]));\n        }\n    }\n    pre = max_flow(0,n-1);\n    rep(i,q){\n        if(x[i] == 1){\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 1;\n                    G[t[i]][rev].cap = 1;\n                }\n            }\n            memset(used,0,sizeof(used));\n            pre = dfs(0,n-1,1)+pre;\n        } else{\n            int div = 0;\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].to == t[i]){\n                    div = G[s[i]][j].cap;\n                    G[s[i]][j].cap = 0;\n                    G[t[i]][rev].cap = 0;\n                }\n            }\n            memset(used,0,sizeof(used));\n            if(div == 0){\n                if(dfs(s[i],t[i],1) == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,t[i],1);\n                    memset(used,0,sizeof(used));\n                    dfs(s[i],0,1);\n                    pre--;\n                }\n            } else if(div == 2){\n                if(dfs(t[i],s[i],1) == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,s[i],1);\n                    memset(used,0,sizeof(used));\n                    dfs(t[i],0,1);\n                    pre--;\n                }\n            }\n        }\n        cout << pre << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\n#include<cstring>\nstruct edge {\n\tint to, id;\n};\nvector<edge> G[500];\nbool vused[500];\n\nbool eused[21001];\nint loc[21001];\nint par[21001];\n\nvector<vector<int>> vf;\nvector<int> es, cop;\nbool dfs(int v, int t) {\n\tif (v == t)return true;\n\tvused[v] = true;\n\trep(i, G[v].size()) {\n\t\tedge &e = G[v][i];\n\t\tif (vused[e.to])continue;\n\t\tif (eused[e.id]&&par[e.id]!=v) {\n\t\t\tif (dfs(e.to, t)) {\n\t\t\t\teused[e.id] = false;\n\t\t\t\tint l = loc[e.id];\n\t\t\t\tcop.clear();\n\t\t\t\tbool g = false;\n\t\t\t\t//cout << l << endl;\n\t\t\t\tif (l == vf.size())return true;\n\t\t\t\trep(j, vf[l].size()) {\n\t\t\t\t\tif (vf[l][j] == e.id)g = true;\n\t\t\t\t\telse if (g) {\n\t\t\t\t\t\tes.push_back(vf[l][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcop.push_back(vf[l][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvf[l] = es; es = cop;\n\t\t\t\trep(j, vf[l].size())loc[vf[l][j]] = l;\n\t\t\t\trep(j, es.size())loc[es[j]] = vf.size();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if(!eused[e.id]){\n\t\t\tif (dfs(e.to, t)) {\n\t\t\t\teused[e.id] = true;\n\t\t\t\tpar[e.id] = v;\n\t\t\t\tes.push_back(e.id);\n\t\t\t\tloc[e.id] = vf.size();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tes.clear();\n\t\tmemset(vused, 0, sizeof(vused));\n\t\tif (dfs(s, t)) {\n\t\t\tflow++;\n\t\t\tvf.push_back(es);\n\t\t}\n\t\telse return flow;\n\t}\n}\nvoid solve() {\n\tint n, m, q; cin >> n >> m >> q;\n\tint cur = m;\n\trep(i, m) {\n\t\tint v, u; cin >> v >> u; v--; u--;\n\t\tG[v].push_back({ u,i});\n\t\tG[u].push_back({ v,i});\n\t}\n\tint ans = max_flow(0, n - 1);\n\trep(i, q) {\n\t\t/*rep(j, vf.size()) {\n\t\t\trep(k, vf[j].size()) {\n\t\t\t\tcout << vf[j][k]<<loc[vf[j][k]]<<\" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint x, a, b; cin >> x >> a >> b; a--; b--;\n\t\tif (x == 1) {\n\t\t\tG[a].push_back({ b,cur});\n\t\t\tG[b].push_back({ a,cur});\n\t\t\tcur++;\n\t\t}\n\t\telse {\n\t\t\trep(j, G[a].size()) {\n\t\t\t\tedge &e = G[a][j];\n\t\t\t\tif (e.to == b) {\n\t\t\t\t\tif (eused[e.id]) {\n\t\t\t\t\t\tint l = loc[e.id];\n\t\t\t\t\t\t//cout << \"?? \" << e.id << endl;\n\t\t\t\t\t\t//cout << l << endl;\n\t\t\t\t\t\trep(k, vf[l].size()) {\n\t\t\t\t\t\t\teused[vf[l][k]] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t\tG[a].erase(G[a].begin() + j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, G[b].size()) {\n\t\t\t\tif (G[b][j].to == a) {\n\t\t\t\t\tG[b].erase(G[b].begin() + j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans += max_flow(0, n - 1);\n\t\tcout <<ans << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        e.alive = false;\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, to, 1);\n            max_flow(from, 0, 1);  \n            return(1);\n          }\n        }\n        return(0);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n      flow -= graph.remove_edge(B, A);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\tint fordFulkerson(const int n,const int t,int now,int fl);\n\ttmp=fordFulkerson(n,to,from,1);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,from,s);\n\t  fordFulkerson(n,s,from,1);\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,t,to);\n\t  fordFulkerson(n,to,t,1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\n\nconst int MAX = 501;\nbool edge[MAX][MAX];\nbool flow[MAX][MAX];\n\nint N, E, Q;\n\nbool used[500];\nbool _dfs(int s, int t)\n{\n\tif (s == t)\n\t\treturn true;\n\n\tused[s] = true;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (!used[i] && edge[s][i] && !flow[s][i] && _dfs(i, t))\n\t\t{\n\t\t\tif (flow[i][s])\n\t\t\t\tflow[i][s] = false;\n\t\t\telse\n\t\t\t\tflow[s][i] = true;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nbool dfs(int s, int t)\n{\n\tfill(used, used+N+1, false);\n\treturn _dfs(s, t);\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &Q);\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tedge[f][t] = edge[t][f] = true;\n\t}\n\n\tint res = 0;\n\twhile (_dfs(1, N))\n\t\t++res;\n\n\tfor (int i = 0; i < Q; ++i)\n\t{\n\t\tint\tm, a, b;\n\t\tscanf(\"%d%d%d\", &m, &a, &b);\n\n\t\tif (m == 1)\n\t\t\tedge[a][b] = edge[b][a] = true;\n\t\telse\n\t\t\tedge[a][b] = edge[b][a] = false;\n\n\t\tres = 0;\n\t\tmemset(flow, 0, sizeof(flow));\n\t\twhile (dfs(1, N))\n\t\t\t++res;\n\t\tprintf(\"%d\\n\", res);\n\t\t//if (m == 1)\n\t\t//{\n\t\t//\tedge[a][b] = edge[b][a] = true;\n\t\t//\tif (dfs(1, N))\n\t\t//\t\t++res;\n\t\t//}\n\t\t//else\n\t\t//{\n\t\t//\tif (flow[a][b])\n\t\t//\t{\n\t\t//\t\tif (!dfs(1, b))\n\t\t//\t\t\t--res;\n\t\t//\t}\n\t\t//\telse if (flow[b][a])\n\t\t//\t{\n\t\t//\t\tif (!dfs(1, a))\n\t\t//\t\t\t--res;\n\t\t//\t}\n\n\t\t//}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n,m,qn;\n\nint vs[505][505]={};\nint gone[505];\n\nbool dfs(int no,int gl){\n\tif(no==gl)return true;\n\tgone[no]=1;\n\treg(to,1,n){\n\t\tif(gone[to])continue;\n\t\tif(vs[no][to]>0){\n\t\t\tif(dfs(to,gl)){\n\t\t\t\tvs[no][to]--;\n\t\t\t\tvs[to][no]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tvs[a][b]=vs[b][a]=1;\n\t}\n\t\n\tint nf=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tif(dfs(1,n))nf++;\n\t\telse break;\n\t}\n\trep(i,qn){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\tif(t==1){\n\t\t\tvs[a][b]=vs[b][a]=1;\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\telse{\n\t\t\tint fr=-1,to;\n\t\t\tif(vs[a][b]==0){\n\t\t\t\tfr=a; to=b;\n\t\t\t}\n\t\t\telse if(vs[b][a]==0){\n\t\t\t\tfr=b; to=a;\n\t\t\t}\n\t\t\tvs[a][b]=vs[b][a]=0;\n\t\t\tif(fr>=0){\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tdfs(n,to);\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tdfs(fr,1);\n\t\t\t\tnf--;\n\t\t\t}\t\t\t\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\tprintf(\"%d\\n\",nf);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\nconst int MAX_V=500,INF=1e8;\nint G[MAX_V][MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int from, int to){\n    G[from][to]=1;\n    G[to][from]=1;\n}\nvoid erase_edge(int from, int to){\n    G[from][to]=0;\n    G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(int i=0;i<V;i++){\n        int &c=G[v][i];\n        if(!used[i] && c>0){\n            int d=dfs(i,t,min(f,c));\n            if(d>0){\n                c-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int f=dfs(s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\nint main(){\n    int N,E,Q;\n    cin>>N>>E>>Q;\n    V=N;\n    rep(i,E){\n        int F,T;\n        cin>>F>>T;\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,N-1);\n    rep(i,Q){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a,b);\n            now+=max_flow(0,N-1);\n        }else{\n            int ecap=G[a][b];\n            erase_edge(a,b);\n            if(ecap!=1){\n                memset(used,0,sizeof(used));\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memset(used,0,sizeof(used));\n                    dfs(a,0,1);\n                    memset(used,0,sizeof(used));\n                    dfs(N-1,b,1);\n                    now--;\n                }\n            }\n        }\n        cout<<now<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = inf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        int F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    int s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        int M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            int r = 0;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n                    G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n                    G[A].erase(G[A].begin()+j, G[A].begin()+j+1);\n                    break;\n                }\n            }\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(ok[s][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = used[i][j] != used[j][i];\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint N, E, Q;\nint cap[500][500];\nbool used[500];\nint dfs(int u, int t, int f){\n    if(u == t) return f;\n    used[u] = true;\n    REP(v, N)if(!used[v] && cap[u][v] > 0){\n        int d = dfs(v, t, min(f, cap[u][v]));\n        if(d > 0){\n            cap[u][v] -= d;\n            cap[v][u] += d;\n            return d;\n        }\n    }\n    return 0;\n}\nint run(int s, int t, int f){\n    memset(used, 0, sizeof used);\n    return dfs(s, t, f);\n}\nint main(){\n    while(cin >> N >> E >> Q && N){\n        memset(cap, 0, sizeof cap);\n        REP(_, E){\n            int F, T;\n            cin >> F >> T;\n            F--; T--;\n            cap[F][T] = 1;\n            cap[T][F] = 1;\n        }\n        int flow = 0;\n        REP(_, Q){\n            int M, A, B;\n            cin >> M >> A >> B;\n            A--; B--;\n            if(M == 1){ // add edge\n                assert(cap[A][B] == 0 && cap[B][A] == 0); // assert no edge\n                cap[A][B] = cap[B][A] = 1; // add edge\n            }else{ // delete edge\n                if(cap[A][B] == 2) swap(A, B);\n                if(cap[B][A] == 2 && run(A, B, 1) == 1){ // remove cycle\n                    cap[B][A] = cap[A][B] = 1;\n                }\n                if(cap[B][A] == 2){ // flowing 0->A->B->N-1\n                    assert(flow > 0);\n                    assert(run(N - 1, 0, 1) == 1); // N-1 -> 0\n                    flow--;\n                }\n                if(cap[B][A] == 2){ // remove cycle\n                    assert(run(A, B, 1) == 1);\n                    cap[B][A]--;\n                    cap[A][B]++;\n                }\n                assert(cap[A][B] == 1 && cap[B][A] == 1); // assert no flowing\n                cap[A][B] = cap[B][A] = 0; // remove edge\n            }\n            // update flow\n            while(true){\n                int f = run(0, N - 1, 2);\n                if(f == 0) break;\n                flow += f;\n            }\n            cout << flow << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int a,int b,int c):to(a),cap(b),rev(c){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,cap,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim){\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1,INF);\n}\n\nvoid q2(int a,int b){\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.to!=b||e.cap!=2)continue;\n        f2=true;\n        e.cap=0;\n    }\n    for(auto &e:G[b]){\n        if(e.to!=a||e.cap!=2)continue;\n        f1=true;\n        e.cap=0;\n    }\n\n    if(!f1&&!f2)return;\n\n    if(f2)swap(a,b);\n\n\n    int tmp=max_flow(a,b,1);\n\n    if(tmp)return;\n\n    add_edge(0,N-1,1);\n    tmp=max_flow(a,b,1);\n    assert(tmp);\n    G[0].pop_back();\n    G[N-1].pop_back();\n    f--;\n\n    f+=max_flow(0,N-1,INF);\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n    }\n\n    f=max_flow(0,N-1,INF);\n\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n            /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.cap==2)cout<<e.to+1<<\" \"<<i+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[MAX_E*2];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tbool ok=false;\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]!=v)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * F-F ??????????????¨?????????????????¨\n */\ntemplate<int V>\nstruct MaxFlow {\n    struct Edge {\n        int to, rev, cap;\n    };\n    vector<Edge> g[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    /// ??????????????¨?????????, ??????1??????2????????????????????????????????????\n    void add_multi(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    int erase(int from, int to) {\n        for (int i = 0; i < (int)g[from].size(); i++) {\n            auto e = g[from][i];\n            if (e.to == to) {\n                int c = g[to][e.rev].cap - e.cap;\n                g[to][e.rev].cap = 0;\n                g[from][i].cap = 0;\n                return c;\n            }\n        }\n        assert(false);\n    }\n\n    bool used[V];\n    bool dfs(int s, int t) {\n        if (s == t) return true;\n        used[s] = true;\n        for (auto &e : g[s]) {\n            if (used[e.to]) continue;\n            if (!e.cap) continue;\n            if (dfs(e.to, t)) {\n                e.cap -= 1;\n                g[e.to][e.rev].cap += 1;\n                return true;\n            }\n        }\n        return false;\n    }\n    int exec(int s, int t, int F) {\n        int f = 0;\n        while (f < F) {\n            fill_n(used, V, false);\n            if (!dfs(s, t)) break;\n            f++;\n        }\n        return f;\n    }\n    void print() {\n        int ec = 0, cs = 0;\n        for (int i = 0; i < V; i++) {\n            for (auto &e: g[i]) {\n                ec++;\n                cs += e.cap;\n            }\n        }\n    }\n};\n\nMaxFlow<550> mf;\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t; f--; t--;\n        mf.add_multi(f, t, 1);\n    }\n    int f = 0;\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b; a--; b--;\n        if (m == 1) {\n            mf.add_multi(a, b, 1);\n        } else {\n            int u = mf.erase(a, b);\n            if (u) {\n                if (u == -2) swap(a, b);\n                f--;\n                assert(mf.exec(n-1, b, 1));\n                assert(mf.exec(a, 0, 1));\n            }\n        }\n        f += mf.exec(0, n-1, 100000);\n        printf(\"%d\\n\", f);\n        mf.print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nbool modify(Graph& g,int v,int sink,int flow,vi& vis)\n{\n\tif(v==sink) return true;\n\tif(vis[v]) return false;\n\tvis[v]=1;\n\tfor(int i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge e=g.es[i];\n\t\tif(e.flow==-flow) continue;\n\t\tif(modify(g,e.dst,sink,flow,vis)){\n\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n,m,q;cin>>n>>m>>q && n|m|q;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg.AddEdge(u,v,1,1);\n\t\t}\n\t\trep(_,q){\n\t\t\tint t,u,v; cin>>t>>u>>v; u--,v--;\n\t\t\tif(t==1)\n\t\t\t\tg.AddEdge(u,v,1,1);\n\t\t\telse{\n\t\t\t\tint i;\n\t\t\t\tfor(i=g.head[u];i!=-1;i=g.next[i])\n\t\t\t\t\tif(g.es[i].dst==v && g.es[i].cap==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\tg.es[i].cap=g.es[i^1].cap=0;\n\t\t\t\tif(g.es[i].flow){\n\t\t\t\t\tif(g.es[i].flow==-1) swap(u,v);\n\t\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\t\t{vi vis(n); modify(g,v,n-1,-1,vis);}\n\t\t\t\t\t{vi vis(n); modify(g,u,0,-1,vis);}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDinic(g,0,n-1);\n\t\t\tint res=0;\n\t\t\tfor(int j=g.head[0];j!=-1;j=g.next[j])\n\t\t\t\tres+=g.es[j].flow;\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n#include <unistd.h>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv;\n\nint flow(int n,int a,int b,int c){\n\tint ret=0;\n\twhile(1){\n\t\tqueue<int> q;\n\t\tq.push(a);\n\t\tvint used(n,-1);\n\t\tused[a]=a;\n\t\t// cout<<\"hoge\\n\";\n\t\twhile(!q.empty()){\n\t\t\t// cout<<\"hoge\\n\";\n\t\t\tint t=q.front();\n\t\t\t// cout<<\"t \"<<t<<endl;\n\t\t\tsleep(1);\n\t\t\tq.pop();\n\t\t\trep(i,n){\n\t\t\t\tif(used[i]<0&&vv[t][i]>0){\n\t\t\t\t\t// cout<<t<<\" \"<<i<<\" \"<<vv[t][i]<<endl;\n\t\t\t\t\tused[i]=t;\n\t\t\t\t\tq.push(i);\n\t\t\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\t\t\t// cout<<\"q.size \"<<q.size()<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(used[b]>=0) break;\n\t\t}\n\t\tif(used[b]<0) return ret;\n\t\tfor(int i=b;i!=used[i];i=used[i]){\n\t\t\t--vv[used[i]][i];\n\t\t\t++vv[i][used[i]];\n\t\t\t// cout<<i<<endl;\n\t\t}\n\t\tret++;\n\t\tif(c) return ret;\n\t}\n\treturn ret;\n}\n\n\nvoid mainmain(){\n\tint n,e,q;\n\twhile(cin>>n>>e>>q){\n\t\tvint v(n,INF);\n\t\t// v[0]=0;\n\t\tinitvv(vv,n,n,0);\n\t\t// vvint vv(n);\n\t\trep(i,e){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a][b]=1;\n\t\t\tvv[b][a]=1;\n\t\t}\n\t\tint ans=flow(n,0,n-1,0);\n\t\t// cout<<ans<<endl;\n\t\trep(i,q){\n\t\t\tint r,a,b;\n\t\t\tcin>>r>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(r==2){\n\t\t\t\trep(i,2){\n\t\t\t\t\tif(vv[a][b]==2){\n\t\t\t\t\t\tans--;\n\t\t\t\t\t\tflow(n,n-1,b,1);\n\t\t\t\t\t\tflow(n,a,0,1);\n\t\t\t\t\t}\n\t\t\t\t\tswap(a,b);\n\t\t\t\t}\n\t\t\t\tvv[a][b]=0;\n\t\t\t\tvv[b][a]=0;\n\t\t\t\t/*  here  */\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvv[a][b]=1;\n\t\t\t\tvv[b][a]=1;\n\t\t\t\tans+=flow(n,0,n-1,1);\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nint INF = 1 << 20;\n#define MAX_V 500\n\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G( MAX_V ); // ??°???????????£??\\???????????¨???\nbool used[MAX_V]; // DFS??§?????§??????????????????????????°\n\t\t\t\t  // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge( int from, int to, int cap ) {\n\tedge a = {to, cap, G[to].size()};\n\tedge b = {from, 0, G[from].size() - 1};\n\tG[from].push_back( a );\n\tG[to].push_back( b );\n}\n\nvoid del_edge( int from, int to ) {\n\tauto ite = G[from].begin();\n\twhile( ite < G[from].end() ) {\n\t\tif( ( *ite ).to == to ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n\n\n\tite = G[to].begin();\n\twhile( ite < G[to].end() ) {\n\t\t//cout << to << \" \" << ( *ite ).to << \" \" << ( *ite ).cap << endl;\n\t\tif( ( *ite ).to == from ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs( int v, int t, int f ) {\n\tif( v == t ) return f;\n\tused[v] = true;\n\tfor( int i = 0; i < G[v].size(); i++ ) {\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0 ) {\n\t\t\tint d = dfs( e.to, t, min( f, e.cap ) );\n\t\t\tif( d > 0 ) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow( int s, int t ) {\n\tfor( size_t i = 0; i < MAX_V; i++ ) {\n\t\tused[i] = false;\n\t}\n\tint flow = 0;\n\tfor( ;;) {\n\t\tmemset( used, 0, sizeof( used ) );\n\t\tint f = dfs( s, t, INF );\n\t\tif( f == 0 ) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n\tlong long int N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge( F, T, 1 );\n\t\tadd_edge( T, F, 1 );\n\t}\n\tfor( size_t i = 0; i < Q; i++ ) {\n\t\tlong long int M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif( M == 1 ) {\n\t\t\tadd_edge( A, B, 1 );\n\t\t\tadd_edge( B, A, 1 );\n\t\t} else {\n\t\t\tdel_edge( A, B );\n\t\t}\n\t\tauto memo = G;\n\t\tcout << max_flow( 0, N - 1 ) << endl;\n\t\tG = memo;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<limits.h>\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\n#define MAX_V 505\n\nstruct edge{\n    int to,cap,rev,ori_cap;\n};\nint V;\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to){\n    G[from].push_back((edge){to,1,(int)G[to].size(),1});\n    G[to].push_back((edge){from,1,(int)G[from].size()-1,1});\n}\n\nvoid bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int>que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();que.pop();\n        for(int i=0;i<G[v].size();i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    for(int &i=iter[v];i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v]<level[e.to]){\n            int d = dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        bfs(s);\n        if(level[t]<0)return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dfs(s,t,INT_MAX))>0){\n            flow+=f;\n        }\n    }\n}\nint n,e,q;\n\nint main(){\n    cin>>n>>e>>q;\n    V=n;\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        add_edge(f-1, t-1);\n    }\n    for(int j=0;j<q;j++){\n        for(int i=0;i<MAX_V;i++){\n            for(int k=0;k<G[i].size();k++) {\n                G[i][k].cap = G[i][k].ori_cap;\n            }\n        }\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n            cout<<max_flow(0, V-1)<<endl;\n        } else if(m==2){\n            for(int i=0;i<G[a].size();i++){\n                if(G[a][i].to==b){\n                    G[a].erase(G[a].begin()+i);\n                }\n            }\n            for(int i=0;i<G[b].size();i++){\n                if(G[b][i].to==a){\n                    G[b].erase(G[b].begin()+i);\n                }\n            }\n            cout<<max_flow(0, V-1)<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000;\nint cap[1000][1000];\n\nint search(vector<int> &level, vector<bool> &visit, int u, int t, int n,int cur){\n\tif(u==t||cur==0) return cur;\n\tif(visit[u]) return 0;\n\tvisit[u] = true;\n\tfor(int i=0;i<n;i++){\n\t\tif(level[i] > level[u]){\n\t\t\tint f = search(level, visit, i, t, n, min(cur, cap[u][i]));\n\t\t\tif(f > 0){\n\t\t\t\tcap[u][i] -= f; cap[i][u] += f;\n\t\t\t\tvisit[u] = false;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maximumFlow(int n, int s, int t){\n\tint res = 0;\n\tbool end = false;\n\twhile(!end){\n\t\tend = true; \n\t\tqueue<int> qu; qu.push(s);\n\t\tvector<int> level(n,-1); level[s] = 0;\n\t\tfor(int d=n;!qu.empty()&&level[qu.front()]<d; ){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tif(u==t) d = level[u];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(level[i]<0&&cap[u][i]>0){\n\t\t\t\t\tlevel[i] = level[u]+1;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> visit(n);\n\t\tfor(int f=1;f>0; ){\n\t\t\tf = search(level, visit, s, t, n, INF);\n\t\t\tif(f == 0) break;\n\t\t\tres += f;\n\t\t\tend = false;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\t// A->B gpÏÝ\n\t\t\t\tif(cap[A-1][B-1] == 0){\n\t\t\t\t\tint c = B-1;\n\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc = A-1;\n\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t\t}\n\t\t\t\telse if(cap[B-1][A-1] == 0){\n\t\t\t\t\tint c = A-1;\n\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc = B-1;\n\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n      \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n              \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            // e.cap =0;reve.cap = 0;\n            Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) 残り(d-f)は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f); \n            e.cap=0;reve.cap=c + reve.icap;\n            e.icap = c;\n        }\n        flow += max_flow(S,T);\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n \n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1<<28;\nstruct Edge {\n  int v;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int MAXN = 555;\n\nint N, E, Q;\nGraph G;\nint vis[MAXN];\nint cap[MAXN][MAXN];\n\nvoid addEdge(int from, int to) {\n  G[from].push_back((Edge){to});\n  G[to].push_back((Edge){from});\n  cap[from][to] = cap[to][from] = 1;\n}\n\nvoid eraseEdge(int from, int to) {\n  for (int i = 0; i < G[from].size(); ++i) {\n    if (G[from][i].v == to) {\n      G[from].erase(G[from].begin() + i);\n      break;\n    }\n  }\n  for (int i = 0; i < G[to].size(); ++i) {\n    if (G[to][i].v == from) {\n      G[to].erase(G[to].begin() + i);\n      break;\n    }\n  }\n}\n\nint dfs(int v, int t, int f) {\n  vis[v] = true;\n  if (v == t) return f;\n  for (int i = 0; i < G[v].size(); ++i) {\n    Edge &e = G[v][i];\n    if (vis[e.v]) continue;\n    if (cap[v][e.v] == 0) continue;\n    int d = dfs(e.v, t, min(f, cap[v][e.v]));\n    if (d) {\n      cap[v][e.v] -= d;\n      cap[e.v][v] += d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint oneFlow(int s, int t) {\n  memset(vis, 0, sizeof(vis));\n  return dfs(s, t, 1);\n}\n\nint maxFlow(int s, int t) {\n  int f = 0;\n  while (1) {\n    memset(vis, 0, sizeof(vis));\n    int d = dfs(s, t, INF);\n    if (d == 0) return f;\n    f += d;\n  }\n}\n\nint main() {\n  while (cin >> N >> E >> Q) {\n    G = Graph(N);\n    while (E--) {\n      int F, T;\n      cin >> F >> T;\n      --F; --T;\n      addEdge(F, T);\n    }\n    int f = maxFlow(0, N-1);\n    while (Q--) {\n      int M, A, B;\n      cin >> M >> A >> B;\n      --A; --B;\n      if (M == 1) {\n        addEdge(A, B);\n        f += oneFlow(0, N-1);\n      } else {\n        int s, t;\n        if (cap[A][B] == 0) {\n          s = A; t = B;\n        } else if (cap[B][A] == 0) {\n          s = B; t = A;\n        } else {\n          s = t = -1;\n        }\n        eraseEdge(A, B);\n        if (s != -1) {\n          if (oneFlow(s, t) == 0) {\n            --f;\n            if (f) {\n              oneFlow(N-1, 0);\n              oneFlow(s, t);\n            } else {\n              for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < G[i].size(); ++j) {\n                  cap[i][G[i][j].v] = 1;\n                }\n              }\n            }\n          }\n        }\n      }\n      cout << f << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint n;\nvector<vector<Edge> > edges;\nvector<bool> used;\n\nint dfs(int s, int t, int f){\n    if(s == t)\n        return f;\n\tused[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 0){\n            int g = dfs(e.to, t, min(f, e.cap));\n            if(g > 0){\n                e.cap -= g;\n                edges[e.to][e.rev].cap += g;\n                return g;\n            }\n        }\n    }\n    return 0;\n}\n\nint flow(int s, int t, int f){\n\tused.assign(n+1, false);\n\treturn dfs(s, t, f);\n}\n\nint main()\n{\n\tint e, q;\n\tcin >> n >> e >> q;\n\n\tedges.assign(n+1, vector<Edge>());\n\tfor(int i=0; i<e; ++i){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tedges[f].push_back(Edge(t, 1, edges[t].size()));\n\t\tedges[t].push_back(Edge(f, 1, edges[f].size()-1));\n\t}\n\n\tint ret = 0;\n\tfor(;;){\n\t\tint f = flow(1, n, INT_MAX);\n\t\tif(f == 0)\n\t\t\tbreak;\n\t\tret += f;\n\t}\n\n\tfor(int i=0; i<q; ++i){\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tunsigned j = 0;\n\t\t\twhile(j < edges[a].size() && edges[a][j].to != b)\n\t\t\t\t++ j;\n\t\t\tif(j < edges[a].size()){\n\t\t\t\tedges[a][j].cap = 1;\n\t\t\t\tedges[b][edges[a][j].rev].cap = 1;\n\t\t\t}else{\n\t\t\t\tedges[a].push_back(Edge(b, 1, edges[b].size()));\n\t\t\t\tedges[b].push_back(Edge(a, 1, edges[a].size()-1));\n\t\t\t}\n\t\t\tret += flow(1, n, INT_MAX);\n\t\t}else{\n\t\t\tunsigned j = 0;\n\t\t\twhile(edges[a][j].to != b)\n\t\t\t\t++ j;\n            if(edges[a][j].cap == 1){\n\t\t\t\tedges[a][j].cap = 0;\n\t\t\t\tedges[b][edges[a][j].rev].cap = 0;\n            }else{\n\t\t\t    if(edges[a][j].cap == 0){\n\t\t\t\t    edges[b][edges[a][j].rev].cap = 0;\n\t\t\t\t    flow(a, 1, 1);\n\t\t\t\t    flow(n, b, 1);\n\t\t\t    }else{\n\t\t\t\t    edges[a][j].cap = 0;\n\t\t\t\t    flow(b, 1, 1);\n\t\t\t\t    flow(n, a, 1);\n\t\t\t    }\n\t\t\t    -- ret;\n\t\t\t    ret += flow(1, n, INT_MAX);\n            }\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct FordFulkerson {\n\tusing Flow = int;\n\tint n;\n\tint s, t;\n\tFlow maxflow;\n\tvector<vector<Flow>> g;\n\tvector<bool> used;\n\tFordFulkerson(int n, int s = -1, int t = -1) :n(n), g(n, vector<Flow>(n)), used(n), s(s), t(t), maxflow(0) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from][to] = cap;\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\taddArc(a, b, cap);\n\t\taddArc(b, a, cap);\n\t}\n\tFlow addEdgeCap(int a, int b, Flow cap) {\n\t\tif (cap > 0) {\n\t\t\tg[a][b] += cap;\n\t\t\tg[b][a] += cap;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tmaxflow += augment(s, t, cap);\n\t\t}\n\t\telse {\n\t\t\tFlow rcap = -cap;\n\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\tg[a][b] -= rcap;\n\t\t\t\tg[b][a] -= rcap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (g[a][b] > g[b][a])swap(a, b);\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tFlow f = augment(a, b, a, b, rcap);\n\t\t\t\t//dump(a + 1, b + 1);\n\t\t\t\t//dump(f, rcap);\n\t\t\t\tif (f < rcap) {\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\taugment(b, a, b, a, f);\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tFlow sub = augment(t, s, rcap - f);\n\t\t\t\t\tassert(sub == rcap - f);\n\t\t\t\t\tmaxflow -= sub;\n\t\t\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\t\t\tg[a][b] -= rcap;\n\t\t\t\t\t\tg[b][a] -= rcap;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\t\tf = augment(a, b, a, b, rcap);\n\t\t\t\t\t\t//dump(f, rcap);\n\t\t\t\t\t\tassert(f == rcap);\n\t\t\t\t\t\tg[a][b] += rcap; g[a][b] -= rcap;\n\t\t\t\t\t\tg[b][a] -= rcap; g[b][a] -= rcap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tg[a][b] += rcap; g[a][b] -= rcap;\n\t\t\t\t\tg[b][a] -= rcap; g[b][a] -= rcap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tFlow f = augment(s, t, INF);\n\t\t\tif (f == 0)return maxflow += total;\n\t\t\ttotal += f;\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tFlow augment(int v, int t, int a, int b, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (v == a&&to == b)continue;\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, E, Q; cin >> N >> E >> Q;\n\tFordFulkerson ff(N, 0, N - 1);\n\trep(i, 0, E) {\n\t\tint F, T; cin >> F >> T; F--, T--;\n\t\tff.addEdge(F, T, 1);\n\t}\n\t//dump(ff.g);\n\tff.maximumFlow(0, N - 1);\n\t//dump(ff.g);\n\t//dump(ff.maxflow);\n\trep(i, 0, Q) {\n\t\tint M, A, B; cin >> M >> A >> B;\n\t\t//dump(M, A, B);\n\t\tA--, B--;\n\t\tif (M == 1) {\n\t\t\tcout << ff.addEdgeCap(A, B, 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ff.addEdgeCap(A, B, -1) << endl;\n\t\t}\n\t\t//dump(ff.g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    using T = int;\n    struct Edge\n    {\n        int from, to, revind;\n        T capacity, flow;\n        bool reversed;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    int addEdge(const int from, const int to, const T capacity) { return edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false}), edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true}), edge[from].size() - 1; }\n    T FordFulkerson(const int s, const int t, const T limit = INF<T>)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const T& flow) -> T {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (checked[e.to]) { continue; }\n                const T res = e.capacity - e.flow;\n                if (res == 0) { continue; }\n                const T d = self(self, e.to, min(flow, res));\n                if (d > 0) { return e.flow += min(d, res), edge[e.to][e.revind].flow -= min(d, res), d; }\n            }\n            return 0;\n        });\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const T f = dfs(s, limit);\n            flow += f;\n            if (f == 0 or flow >= limit) { break; }\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\n\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Flow f(N);\n    map<pair<int, int>, pair<int, int>> mp;\n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        F--, T--;\n        mp[{T, F}] = mp[{F, T}] = {f.addEdge(F, T, 1), f.addEdge(T, F, 1)};\n    }\n    int flow = f.FordFulkerson(0, N - 1);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            mp[{B, A}] = mp[{A, B}] = {f.addEdge(A, B, 1), f.addEdge(B, A, 1)};\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        } else {\n            const auto es = mp[{A, B}];\n            const int i1 = es.first, i2 = es.second, r1 = f.edge[A][i1].revind, r2 = f.edge[B][i2].revind;\n            auto &e1 = f.edge[A][i1], &e2 = f.edge[B][i2], &e3 = f.edge[A][r2], &e4 = f.edge[B][r1];\n            if (e1.flow + e3.flow == 1) {\n                cout << flow << endl;\n                e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n                continue;\n            }\n            flow--;\n            const bool A_B = e1.flow == 1;\n            const int u = A_B ? A : B, v = A_B ? B : A;\n            e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n            f.FordFulkerson(u, 0, 1), f.FordFulkerson(N - 1, v, 1);\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, cap, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int u, int v){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == v){\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\treturn fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false and \"invalid u, v\");\n\t\t\treturn -INF;\n\t\t}\n\t\tint subCapacity(int s, int t, int u, int V){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == V){\n\t\t\t\t\tint d = e.cap;\n\t\t\t\t\te.cap = G[V][e.rev].cap = 0;\n\t\t\t\t\tif(d == 1) return 0;\n\t\t\t\t\tif(d == 2){\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs(V, u, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(t, u, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(V, s, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs(u, V, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(t, V, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(u, s, 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -INF;\n\t\t}\n\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]){\n\t\t\tflow.addEdge(a[i], b[i], 0);\n\t\t\tuse[a[i]][b[i]] = use[b[i]][a[i]] = true;\n\t\t}\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s,0,INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1) ans += flow.addCapacity(s, t, a[i], b[i]);\n\t\telse ans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 20005;\nconst F MAXF = 1<<29;\n\nstruct MaxFlow {\n    F cap[2*MAXE], flow[2*MAXE];\n    int V, E, level[MAXV], edge[MAXV];\n    int prev[2*MAXE], to[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]] = mf.flow[use_edge[v]^1] = 0;\n    }\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = mf.edge[s]; e != -1; e = mf.prev[e])\n        if (mf.to[e] == t) return e;\n    return -1;\n}\n\nvoid reset(MaxFlow &mf) {\n    for (int i=0; i<mf.E; ++i)\n        mf.flow[i] = 0;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) mf.cap[e] = mf.cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            mf.cap[e] = mf.cap[e^1] = 0;\n            if (mf.flow[e] != 0) {\n                f--;\n                if (mf.flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                mf.flow[e] = mf.flow[e^1] = 0;\n            }\n        }\n        mf.make_level(0);\n        f += mf.augment(0, N-1, 1);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nstruct dat{\n  double x,y,r;\n  bool operator < (const dat a)const {return r < a.r;}\n};\ndat neko,rat;\n\ndouble getDis(dat a,dat b){return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));}\nbool intersect(dat a,dat b){return getDis(a,b) <= a.r + b.r;}\n\n\nvector<int>  DP(vector<dat>&A){\n  int n = A.size();\n  vector<int> dp(n,1);\n  for(int i=0;i<n;i++) //next use\n    for(int j=0;j<i;j++){ //pre use\n      if(intersect(A[i],A[j]) && getDis(A[i],A[j])+min(A[i].r,A[j].r) >= max(A[i].r,A[j].r)) continue;      Max(dp[i],dp[j]+1);\n    }\n\n  return dp;\n}\n\nsigned main(){\n  while(1){\n    int nn;\n    cin>>nn;\n    if(nn == 0) break;\n    cin>>neko.x>>neko.y; neko.r = 0;\n    cin>>rat.x>>rat.y; rat.r = 0;\n  \n    vector<dat> Neko,Rat;\n    for(int i=0;i<nn;i++){\n      dat wall;\n      cin >>wall.x>>wall.y>>wall.r;\n      if(intersect(wall,neko) == intersect(wall,rat)) i--,nn--;\n      else if(intersect(wall,neko)) Neko.push_back(wall);\n      else if(intersect(wall,rat)) Rat.push_back(wall);\n    }\n  \n    sort(Neko.begin(),Neko.end());\n    sort(Rat.begin(),Rat.end());\n    \n    vector<int> ndp = DP(Neko);\n    vector<int> rdp = DP(Rat);\n    int ans = 0, n = Neko.size(), m = Rat.size();\n    \n    for(int a:ndp) Max(ans,a);\n    for(int a:rdp) Max(ans,a);\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n        if(!intersect(Neko[i],Rat[j])) Max(ans,ndp[i] + rdp[j]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tflow = prev - G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight;\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i+1 << \", \" << g[i][j].dst+1 << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\nclass FordFulkerson {\npublic:\n    Graph g; // ????????????????????????\n    int s, t; // ?§????, ??????\n    int n; // ????????°\n    ll flow = 0; // ?????§????????????????????????????????????????????????????????¨??´??°??????\n\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // ??????????????????src, dst, cap????????±?????????\n    // ????????°?????????????????????????????????\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // ?????????????????????\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // ????????°???????????????????????????????????´???????????????\n    // flow???????¨??????????\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // ????????°????????????????????????\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n    // ???????????????\n    // ????????°????????§???v??????t????????£??????????????¢?????????????????°???????????????\n    //\n    // s??????t????§???????????????????????????????????????§?????????????????????????????????0????????????\n    // f??????????????¨??????????????????\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // ?????£???????????£????????£?????????????????¢??? \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // ???????????¨???????????????????????£???????????£??????????°??????????????¬???????????????¨??????\n            if (d > 0) {\n                e.cap -= d; // ????????°?????????????????´??°\n                g[e.dst][e.rev].cap += d; // ????????°????????????????????´??°\n                return d;\n            }\n        }\n        return 0;\n    }\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // s??????t???????????§??????????????????\n    // s == t??????INF?????????, ???????????????0?????????\n    ll get(void) {\n        return flow;\n    }\n    // O(V) \n    // from??????to??????????????????cap???????????????????????????????????§???????????????\n    // ???????????????????????¨?????¨???????????£????????????????????????\n    // TODO ????¢????????????????\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // ?????¨?????¨?????£??????\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    //  ??? ??§ ??? ??? ??? ??? ??? ??? ??? ??????from->to???????????????????°????????????°???????????????????????????\n    //\n    // from??????to?????????????????????=to->from??????????????????????????£?????????=from->to??????????????¢????????¨??§????????§???????????????????????¶?????§??????????????????????????????\n    // from->to????????????????????£??????????????????????????????????????¨??§from->to????????????????°??????°???????????¨g?????????????????????\n    //\n    // from->??????->to->from??§????????????????????\\???????????°???\n    // from->to????????????????????????????????????????????????????????¨?????§?????????\n    // ?????????????????????????????????????????¨?????????????????????????????¨????????\\??????\n    ll minimizeFlowOfEdgePreservingMaxFlow(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // ???????????????????????????from??????to???????????????????????¨??????\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // ?¶????????????????????????????????????£?????¨??¨?????????????????¨??????\n            // ??????????????????????????£???????????¨??§?????????\n            ll ret = 0;\n            while (1) { // TODO ?????????????????????????????°??????\n//                cout << \"##\" << endl;\n                // e.src?????????????????°??????????????????????????°???????????????\n                bool used[n];\n                rep(i, n) {\n                    used[i] = false;\n                }\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n//                        if (tmp.src == e.src && tmp.dst == e.dst) continue;\n//                        cout << v << \"->\" << tmp.dst << endl;\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                ret += can_erase;\n                sum += can_erase;\n                e_rev.cap -= can_erase;\n\n                if (can_erase == 0) { // ????????§????¶????????????????\n                    // TODO ??¬?????????????????\\???????????§?????¨??¨??????????¢??????????????????????????¬????????????§???????????????\n                    break;\n                }\n            }\n            e.cap += ret;\n        }\n        return sum;\n    }\n    // O(V) \n    // from??????to?????????????????????cap???????????????????????????????????§???????????????\n    // cap???0????????£?????????????????°????????????????????????????¶??????????\n    int erase(int from, int to, ll cap) {\n        // ???????????¨????????????????????????????¶????????????????????????£???????????????????¢????\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // ?????????????????¨??????\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // ?????£????????????????????£???????°????????????????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // ??????????????????????????????from??????to??????????????????????????¨??????\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n\n//        cout << \"second\" << endl;\n//        printGraphCap(g);\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n//        printGraphCap(g);\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n \n        // ??????cap????¶????????????¨????????????\n        // ????????°????????§???t->s???????¢???§??????cap???????????????????????????????????????flow???????°??????????\n        // ????°????????????????????????????????????????????????????????????¨???????????§??????????????¨???????????????????????????\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n//            cout << f << endl;\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n//        cout << \"third\" << endl;\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n    // from??????to??????????????¨?????? \n    //\n    // O(V)\n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, q; cin >> n >> e >> q;\n    Graph g(n);\n    rep(i, e) {\n        ll f, t; cin >> f >> t; f--, t--;\n        addDirected(g, f, t, 0, 1);\n        addDirected(g, t, f, 0, 1);\n    }\n    FordFulkerson ff(g, 0, n-1); \n//        printGraphCap(ff.g);\n//    printGraphCap(ff.g);\n    rep(i, q) {\n        int type, u, v; cin >> type >> u >> v; u--; v--;\n        if (type == 1) {\n            ff.add(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.add(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        } else {\n            ff.erase(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.erase(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        }\n//        printGraphCap(ff.g);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <array>\n#include <limits>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\ntemplate <size_t N>\nvector<int> augmenting_path(int src, int dst, array<array<int, N>, N> const & g) {\n    array<bool, N> used = {};\n    vector<int> acc;\n    function<bool (int)> dfs = [&](int i) {\n        acc.push_back(i);\n        if (i == dst) return true;\n        used[i] = true;\n        repeat (j, N) if (not used[j] and g[i][j] >= 1) {\n            if (dfs(j)) {\n                return true;\n            }\n        }\n        acc.pop_back();\n        return false;\n    };\n    dfs(src);\n    return acc;\n}\n\ntemplate <size_t N>\nint maximum_flow(int src, int dst, array<array<int, N>, N> & g) {\n    int acc = 0;\n    while (true) {\n        auto path = augmenting_path(src, dst, g);\n        if (path.empty()) break;\n        int l = path.size();\n        int delta = numeric_limits<int>::max();\n        repeat (i, l - 1) setmin(delta, g[path[i]][path[i + 1]]);\n        repeat (i, l - 1) {\n            g[path[i]][path[i + 1]] -= delta;\n            g[path[i + 1]][path[i]] += delta;\n        }\n        acc += delta;\n    }\n    return acc;\n}\n\ntemplate <size_t N>\nint unwind(int a, int b, int src, int dst, array<array<int, N>, N> & g) {\n    if (g[a][b] == 0 and g[b][a] == 0) {\n        assert (false);\n    } else if (g[b][a] == 0) {\n        return unwind(b, a, src, dst, g);\n    } else if (g[a][b] == 0) {\n        if (a == src and b == dst) {\n            auto path = augmenting_path(dst, src, g);\n            int l = path.size();\n            assert (l >= 1);\n            repeat (i, l - 1) {\n                g[path[i]][path[i + 1]] -= 1;\n                g[path[i + 1]][path[i]] += 1;\n            }\n            return 1;\n        } else {\n            assert (g[src][dst] == 0);\n            g[src][dst] += 1;\n            auto path = augmenting_path(a, b, g);\n            int l = path.size();\n            assert (l >= 1);\n            repeat (i, l - 1) {\n                g[path[i]][path[i + 1]] -= 1;\n                g[path[i + 1]][path[i]] += 1;\n            }\n            g[a][b] += 1;\n            g[b][a] -= 1;\n            if (g[src][dst] == 0) {\n                g[dst][src] -= 1;\n                return 1;\n            } else {\n                g[src][dst] -= 1;\n                return 0;\n            }\n        }\n    } else {\n        return 0;\n    }\n}\n\nconstexpr int max_n = 500;\narray<array<int, max_n>, max_n> g;\nint main() {\n    int n, edges, queries; scanf(\"%d%d%d\", &n, &edges, &queries);\n    assert (n <= max_n);\n    repeat (i, edges) {\n        int from, to; scanf(\"%d%d\", &from, &to); -- from; -- to;\n        g[from][to] += 1;\n        g[to][from] += 1;\n    }\n    const int src = 0;\n    const int dst = n - 1;\n    int flow = maximum_flow(src, dst, g);\n    while (queries --) {\n        int modify, a, b; scanf(\"%d%d%d\", &modify, &a, &b); -- a; -- b;\n        if (modify == 1) { // connect\n            g[a][b] += 1;\n            g[b][a] += 1;\n            flow += maximum_flow(src, dst, g);\n        } else if (modify == 2) { // disconnect\n            assert (g[a][b] + g[b][a] == 2);\n            flow -= unwind(a, b, src, dst, g);\n            g[a][b] -= 1;\n            g[b][a] -= 1;\n            assert (g[a][b] >= 0);\n            assert (g[b][a] >= 0);\n            flow += maximum_flow(src, dst, g);\n        } else {\n            assert (false);\n        }\n        printf(\"%d\\n\", flow);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        if(!used[i]&&G[v][i]>0){\n            int d=dfs(i,t,min(f,G[v][i]));\n            if(d>0){\n                G[v][i]-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&V,&E,&Q);\n    f(i,E){\n        scanf(\"%d%d\",&F,&T);\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        scanf(\"%d%d%d\",&m,&a,&b);\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n            now+=max_flow(0,V-1);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(V-1,b,1);\n                    now--;\n                }\n            }\n        }\n        printf(\"%d\\n\",now);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim=INF){\n    if(s==t)return 0;\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    add_edge(b,a,1);\n    f+=max_flow(0,N-1);\n}\n\nvoid q2(int a,int b){\n\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.type==1&&e.to==b){\n            f1=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n    for(auto &e:G[b]){\n        if(e.type==1&&e.to==a){\n            f2=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n\n\n    if(f1==f2)return;\n\n    if(f1){\n        max_flow(N-1,b,1);max_flow(a,0,1);\n    }\n    if(f2){\n        max_flow(N-1,a,1);max_flow(b,0,1);\n    }\n    f--;\n    f+=max_flow(0,N-1);\n}\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.type==1&&e.cap==0)cout<<i+1<<\" \"<<e.to+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    using T = int;\n    struct Edge\n    {\n        int from, to, revind;\n        T capacity, flow;\n        bool reversed;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    int addEdge(const int from, const int to, const T capacity) { return edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false}), edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true}), edge[from].size() - 1; }\n    T FordFulkerson(const int s, const int t, const T limit = INF<T>)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const T& flow) -> T {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (checked[e.to]) { continue; }\n                const T res = e.capacity - e.flow;\n                if (res == 0) { continue; }\n                const T d = self(self, e.to, min(flow, res));\n                if (d > 0) { return e.flow += min(d, res), edge[e.to][e.revind].flow -= min(d, res), d; }\n            }\n            return 0;\n        });\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const T f = dfs(s, limit);\n            flow += f;\n            if (f == 0 or flow >= limit) { break; }\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\n\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Flow f(N);\n    map<pair<int, int>, pair<int, int>> mp;\n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        F--, T--;\n        const int i1 = f.addEdge(F, T, 1), i2 = f.addEdge(T, F, 1);\n        mp[{F, T}] = {i1, i2}, mp[{T, F}] = {i2, i1};\n    }\n    int flow = f.FordFulkerson(0, N - 1);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            const int i1 = f.addEdge(A, B, 1), i2 = f.addEdge(B, A, 1);\n            mp[{A, B}] = {i1, i2}, mp[{B, A}] = {i2, i1};\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        } else {\n            const auto es = mp[{A, B}];\n            const int i1 = es.first, i2 = es.second, r1 = f.edge[A][i1].revind, r2 = f.edge[B][i2].revind;\n            auto &e1 = f.edge[A][i1], &e2 = f.edge[B][i2], &e3 = f.edge[A][r2], &e4 = f.edge[B][r1];\n            if (e1.flow + e3.flow == 1) {\n                cout << flow << endl;\n                e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n                continue;\n            }\n            flow--;\n            const bool A_B = e1.flow == 1;\n            const int u = A_B ? A : B, v = A_B ? B : A;\n            e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n            f.FordFulkerson(u, 0, 1), f.FordFulkerson(N - 1, v, 1);\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    used[v]=true;\n    if(v==t)return f;\n    for(auto &e:G[v]){\n        if(e.cap==0||used[e.to])continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    int f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            add_edge(a,b,1);\n            add_edge(b,a,1);\n            f+=max_flow(0,N-1);\n        }\n        else{\n            rep(beet,2){\n                for(int i=0;i<G[a].size();i++){\n                    if(G[a][i].type==0||G[a][i].to!=b)continue;\n                    if(G[a][i].cap==1){\n                        G[a][i].cap=0;\n                        G[a][i].type=0;\n                        continue;\n                    }\n\n                    int t=max_flow(a,b);\n                    if(t==1){\n                        G[a][i].type=0;\n                        G[G[a][i].to][G[a][i].rev].cap=0;\n                        continue;\n                    }\n\n                    add_edge(0,N-1,1);\n                    t=max_flow(a,b);\n                    assert(t&&G[0].back().cap==0);\n                    f--;\n                    G[0].pop_back();G[N-1].pop_back();\n\n                    G[a][i].type=0;\n                    G[G[a][i].to][G[a][i].rev].cap=0;\n                }\n\n                f+=max_flow(0,N-1);\n                swap(a,b);\n            }\n        }\n\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct FordFulkerson{\n  int n;\n  vector< vector<edge> > graph;\n  vi use;\n\n  FordFulkerson(int a=0):n(a){\n    graph.resize(a); use.resize(a);\n  }\n\n  void init_use(void){fill(all(use),0);}\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g && graph[s][e].cost>0){\n\tid = e; rev = graph[s][e].rev; break;\n      }\n    }\n    if(id<0)return;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n\n    edge e = graph[s][id];\n    if(id+1!=(int)graph[s].size())graph[e.to][e.rev].rev = id;\n    e = graph[g][rev];\n    if(rev+1!=(int)graph[g].size())graph[e.to][e.rev].rev = rev;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    use[v] = 1;\n    rep(i,graph[v].sz){\n      edge &e = graph[v][i];\n      if(!use[e.to] && e.cap > 0){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      init_use();\n      int f = dfs(s,t,INF);\n      if(!f)return res;\n      res += f;\n    }\n  }\n};\n\nint main(){\n  int n,E,q;\n  cin >> n >> E >> q;\n  FordFulkerson mf(n);\n  rep(i,E){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    mf.AddEdge(f,t,1,1);\n    mf.AddEdge(t,f,1,1);\n  }\n\n  int F = mf.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      mf.AddEdge(a,b,1,1);\n      mf.AddEdge(b,a,1,1);\n      F += mf.max_flow(0,n-1);\n    }else{\n      int use = 0;\n      for(edge e : mf.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap == 0){\n\t  use |= 1; break;\n\t}\n      }\n      for(edge e : mf.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap == 0){\n\t  use |= 2; break;\n\t}\n      }\n      mf.DeleteEdge(a,b);\n      mf.DeleteEdge(b,a);\n\n      if(use==1 || use==2){\n\trep(i,n)mf.use[i] = 0;\n\tint another = 0;\n\tif(use==1)another = mf.dfs(a,b,1);\n\tif(use==2)another = mf.dfs(b,a,1);\n\n\tif(!another){\n\t  mf.init_use();\n\t  mf.dfs(use==1?a:b,0,1);\n\t  mf.init_use();\n\t  mf.dfs(n-1,use==1?b:a,1);\n\t  F--;\n\t}\n      }\n    }\n\n    cout << F << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n,m,qn;\n\nint vs[505][505]={};\nint gone[505];\n\nbool dfs(int no,int gl){\n\tif(no==gl)return true;\n\tgone[no]=1;\n\treg(to,1,n){\n\t\tif(gone[to])continue;\n\t\tif(vs[no][to]>0){\n\t\t\tif(dfs(to,gl)){\n\t\t\t\tvs[no][to]--;\n\t\t\t\tvs[to][no]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tvs[a][b]=vs[b][a]=1;\n\t}\n\t\n\tint nf=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tif(dfs(1,n))nf++;\n\t\telse break;\n\t}\n\trep(q,qn){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\tif(t==1){\n\t\t\tvs[a][b]=vs[b][a]=1;\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\telse{\n\t\t\tint fr=-1,to;\n\t\t\tif(vs[a][b]==0){\n\t\t\t\tfr=a; to=b;\n\t\t\t}\n\t\t\telse if(vs[b][a]==0){\n\t\t\t\tfr=b; to=a;\n\t\t\t}\n\t\t\tvs[a][b]=vs[b][a]=0;\n\t\t\tif(fr>=0){\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(!dfs(fr,to)){\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\t\tok &= dfs(n,to);\n\t\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\t\tok &= dfs(fr,1);\n\t\t\t\t\tnf--;\n\t\t\t\t}\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(dfs(1,n))nf++;\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\",nf);\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n \nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n\ttypedef int Flow;\n\tstruct Edge{int to,rev;Flow icap,cap;bool ex;};\n\ttypedef vector<vector<Edge>> Graph;\n\n\t//iter　次に調べる時の開始位置 距離\n\tvector<int> iter,dist;\n\n\t//sからのbfs距離の計算\n\tvoid bfs_dist(int s){\n\t\tfill(ALL(dist),-1); dist[s]=0;\n\t\tqueue<int> que; que.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();que.pop();\n\t\t\tfor(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n\t\t\t\tdist[e.to]=dist[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//増加パス\n\tFlow dfs_best_path(int s,int t,Flow f){\n\t\tif(s==t)return f;\n\t\tfor(int &i = iter[s];i < (int)G[s].size();i++){\n\t\t\tEdge &e=G[s][i], &reve = G[e.to][e.rev];\n\t\t\tif(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n\t\t\t//search\n\t\t\tFlow d = dfs_best_path(e.to,t,min(f,e.cap));\n\t\t\tif(d==0)continue;\n\t\t\t//found\n\t\t\te.cap-=d;reve.cap+=d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tint V;Graph G;\n\tMaximamFlow(int V):V(V){\n\t\tG=Graph(V);\n\t\tdist=vector<int>(V,-1);iter=vector<int>(V);\n\t}\n\n\tvoid add_edge(int s,int t,Flow cap){\n\t\tint srev=G[t].size(),trev=G[s].size();\n\t\tG[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,-cap,0,false});\n\t}\n\n\tFlow change_cost(int S,int T,int s,int t,int c){\n\t\tFlow flow = 0;\n\t\tfor(Edge& e:G[s])if(e.ex && e.to == t){\n\t\t\tEdge &reve = G[e.to][e.rev];\n\t\t\tif(e.icap <= c){// 単純に増やす\n\t\t\t\te.cap+=c - e.icap;\n\t\t\t}else if(c > e.icap-e.cap){ // 単純に減らす\n\t\t\t\te.cap-=e.icap - c;\n\t\t\t}else{// フローを戻してから減らす\n\t\t\t\tFlow d = e.icap - e.cap - c;\n\t\t\t\tflow -= d;\n\t\t\t\t// S <- s  t <- T\n\t\t\t\tbfs_dist(s); dfs_best_path(s,S,d);\n\t\t\t\tbfs_dist(T); dfs_best_path(T,t,d);\n\t\t\t\t// s <- t\n\t\t\t\te.cap =0;reve.cap = c;\n\t\t\t}\n\t\t\te.icap = c;reve.icap = -c;\n\t\t\tflow += max_flow(S,T);\n\n\t\t\t// cerr <<\"!state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e:G[v])if(!e.ex && e.cap!=0){\n\t\t\t// \tcerr << v+1 <<\"<-\" << e.to+1 <<\" \" << e.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\t\t}\n\t\treturn flow;\n\t}\n\n\tint max_flow(int s,int t){\n\t\tFlow flow=0;\n\t\twhile(true){\n\t\t\tfill(ALL(iter),0);\n\t\t\tbfs_dist(s);\n\t\t\tif(dist[t] == -1)return flow; //限界\n\t\t\tFlow f;\n\t\t\twhile((f=dfs_best_path(s,t,INF<Flow>()))>0)flow+=f;\n\t\t}\n\t\treturn -1;\n\t}\n};\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N,E,Q;cin >> N >> E >> Q;\n\n\t\tMaximamFlow mf(N);\n\t\tREP(i,N)REP(j,N)if(i!=j){\n\t\t\tmf.add_edge(i,j,0);\n\t\t}\n\n\t\tll flow=0;\n\t\tREP(e,E){\n\t\t\tint f,t;cin >> f >> t;f--;t--;\n\t\t\tflow+=mf.change_cost(0,N-1,f,t,1);\n\t\t\tflow+=mf.change_cost(0,N-1,t,f,1);\n\t\t}\n\t\tREP(q,Q){\n\t\t\tint t,a,b;cin >> t >> a >> b;a--;b--;\n\t\t\tif(t==1){\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,1);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,1);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}else{\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,0);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,0);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n \nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\t//show(v)\n\t\t\t//cout << v << \" -> \";\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t//cout << e.to << ' ' << e.cap << endl;\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\t//cout << e.to << ' ' << e.cap << endl;\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//show(\"END\")\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2) {\n\t\t\t//G[v].push_back(Edge(0, INF, static_cast<int>(G[0].size())));\n\t\t\t//G[0].push_back(Edge(v, 0, static_cast<int>(G[v].size() - 1)));\n\t\t\t//G[v - 1].push_back(Edge(v + 1, INF, static_cast<int>(G[v + 1].size())));\n\t\t\t//G[v + 1].push_back(Edge(v - 1, 0, static_cast<int>(G[v - 1].size() - 1)));\n\t\t}\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\t//cout << \"add \" <<from << ' ' << to << endl;\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, cap, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int u, int v){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\t//cout << u << ' ' << v << endl;\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\t//cout << u << ' ' << e.to << endl;\n\t\t\t\tif(e.to == v){\n\t\t\t\t\tassert(e.cap == 0 and G[v][e.rev].cap == 0);\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tint ans = fordFulkerson(s, t);\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false and \"invalid u, v\");\n\t\t\treturn -INF;\n\t\t}\n\t\tint subCapacity(int s, int t, int u, int V){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == V){\n\t\t\t\t\tint d = e.cap;\n\t\t\t\t\te.cap = G[V][e.rev].cap = 0;\n\t\t\t\t\tif(d == 1) return 0;\n\t\t\t\t\tif(d == 2){\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs(V, u, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(t, u, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(V, s, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs(u, V, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(t, V, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(u, s, 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -INF;\n\t\t}\n\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]){\n\t\t\tflow.addEdge(a[i], b[i], 0);\n\t\t\tuse[a[i]][b[i]] = use[b[i]][a[i]] = true;\n\t\t}\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s,0,INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nstruct MaxFlow {\n    static const int N = 512;\n    int n, flow[N][N], capa[N][N], prev[N];\n    void init(int _n) {\n        n = _n;\n        memset(flow, 0, sizeof(flow));\n        memset(capa, 0, sizeof(capa));\n    }\n    void add_edge(int u, int v, int ca) { capa[u][v] = ca; }\n    int pour(int s, int t, int F=1<<30) {\n        int total = 0;\n        while(total < F) {\n            memset(prev, -1, sizeof(prev));\n            queue<int> q;\n            prev[s] = s;\n            q.push(s);\n            while(!q.empty() && prev[t]<0) {\n                const int u = q.front();\n                q.pop();\n                rep(i, n) if(prev[i]<0 && flow[u][i]<capa[u][i]) {\n                    prev[i] = u;\n                    q.push(i);\n                }\n            }\n            if(prev[t]<0) return total;\n            int inc = F-total;\n            for(int j=t; prev[j]!=j; j=prev[j]) {\n                inc = min(inc, capa[prev[j]][j]-flow[prev[j]][j]);\n            }\n            for(int j=t; prev[j]!=j; j=prev[j]) {\n                flow[prev[j]][j] += inc;\n                flow[j][prev[j]] -= inc;\n            }\n            total += inc;\n        }\n        return total;\n    }\n} mf;\n\nint N, E, Q;\n\nint main() {\n    scanf(\"%d%d%d\", &N, &E, &Q);\n    mf.init(N);\n    rep(_, E) {\n        int F, T;\n        scanf(\"%d%d\", &F, &T);\n        F--, T--;\n        mf.add_edge(F, T, 1);\n        mf.add_edge(T, F, 1);\n    }\n    int cur = mf.pour(0, N-1);\n    rep(_, Q) {\n        int M, A, B;\n        scanf(\"%d%d%d\", &M, &A, &B);\n        A--, B--;\n        if(M==1) {\n            mf.add_edge(A, B, 1);\n            mf.add_edge(B, A, 1);\n            cur += mf.pour(0, N-1, 1);\n        }\n        else {\n            if(mf.flow[A][B]==-1) swap(A, B);\n            if(mf.flow[A][B] && !mf.pour(A, B, 1)) {\n                cur--;\n                mf.pour(N-1, B, 1);\n                mf.pour(A, 0, 1);\n            }\n            mf.flow[A][B] = mf.flow[B][A] = 0;\n            mf.capa[A][B] = mf.capa[B][A] = 0;\n        }\n        printf(\"%d\\n\", cur);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nconst int MAX_V=100100;\nstruct edge\n{\n\tint to,cap,rev;\n\tedge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int from,int to,int cap)\n{\n\tedge new_edge1(to,cap,G[to].size());\n\tG[from].pb(new_edge1);\n\tedge new_edge2(from,cap,G[from].size()-1);\n\tG[to].pb(new_edge2);\n}\nint dfs(int v,int t,int f)\n{\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0)\n\t\t{\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow=0;\nint N;\nint max_flow(int s,int t)\n{\n\tfor(;;)\n\t{\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\nint ex[505][505];\nint E,Q;\nint ind(int A,int B){for(int i=0;i<G[A].size();i++)if(G[A][i].to==B)return i;}\nvoid increase(int A,int B)\n{\n\tint id = ind(A,B);\n\tedge &e = G[A][id];\n\te.cap++;\n}\nint decrease(int A,int B)\n{\n\tint id = ind(A,B);\n\tedge &e = G[A][id];\n\tint ret = e.cap;\n\te.cap=0;\n\treturn ret;\n}\nint up_query(int A,int B)\n{\n\tincrease(A,B);\n\tincrease(B,A);\n\treturn max_flow(0,N-1);\n}\nint down_query(int A,int B)\n{\n\tint c = decrease(A,B);\n\tdecrease(B,A);\n\tif(c==2)swap(A,B);\n\tif(c==1)return flow;\n\telse\n\t{\n\t\tmemset(used,0,sizeof(used));\n\t\tif(dfs(A,B,1)>0)return flow;\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(N-1,B,1);\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(A,0,1);\n\t\tflow--;\n\t\treturn flow;\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint F,T;\n\t\tscanf(\"%d %d\",&F,&T);\n\t\tF--;T--;\n\t\tex[F][T]=1;\n\t\tex[T][F]=1;\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tadd_edge(i,j,ex[i][j]);\n\t\t}\n\t}\n\tmax_flow(0,N-1);\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tint M,A,B;\n\t\tscanf(\"%d %d %d\",&M,&A,&B);\n\t\tA--;B--;\n\t\tif(M==1)printf(\"%d\\n\",up_query(A,B));\n\t\telse printf(\"%d\\n\",down_query(A,B));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n \nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass MaximamFlow{\nprivate:\n\ttypedef int Flow;\n\tstruct Edge{int to,rev;Flow icap,cap;bool ex;};\n\ttypedef vector<vector<Edge>> Graph;\n\n\t//iter　次に調べる時の開始位置 距離\n\tvector<int> iter,dist;\n\n\t//sからのbfs距離の計算\n\tvoid bfs_dist(int s){\n\t\tfill(ALL(dist),-1); dist[s]=0;\n\t\tqueue<int> que; que.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();que.pop();\n\t\t\tfor(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n\t\t\t\tdist[e.to]=dist[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//増加パス\n\tFlow dfs_best_path(int s,int t,Flow f){\n\t\tif(s==t)return f;\n\t\tfor(int &i = iter[s];i < (int)G[s].size();i++){\n\t\t\tEdge &e=G[s][i];Edge &reve = G[e.to][e.rev];\n\t\t\tif(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n\t\t\t//search\n\t\t\tFlow d = dfs_best_path(e.to,t,min(f,e.cap));\n\t\t\tif(d==0)continue;\n\t\t\t//found\n\t\t\te.cap-=d;reve.cap+=d;\n\t\t\t\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tint V;Graph G;\n\tMaximamFlow(int V):V(V){\n\t\tG=Graph(V);\n\t\tdist=vector<int>(V,-1);iter=vector<int>(V);\n\t}\n\n\tvoid add_edge(int s,int t,Flow cap){\n\t\tint srev=G[t].size(),trev=G[s].size();\n\t\tG[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,0,0,false});\n\t}\n\n\tFlow change_cost(int S,int T,int s,int t,int c){\n\t\tFlow flow = 0;\n\t\tfor(Edge& e:G[s])if(e.to == t){\n\t\t\tEdge &reve = G[e.to][e.rev];\n\t\t\tif(e.icap <= c){// 単純に増やす\n\t\t\t\t// cerr <<\"add\"<<endl;\n\t\t\t\te.cap+=c - e.icap;\n\t\t\t\te.icap = c;\n\t\t\t}else if(c >= e.icap-e.cap){ // 単純に減らす\n\t\t\t\t// cerr <<\"del\"<<endl;\n\t\t\t\te.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}else{// フローを戻してから減らす\n\t\t\t\t// cerr <<\"del2\"<<endl;\n\t\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t\tFlow d = e.icap - e.cap - c; \n\n\t\t\t\t//出来るだけs->tを使わないフローに置き換える\n\t\t\t\tFlow revd = max_flow(s,t,d);\n\t\t\t\tmax_flow(T,S,d-revd);\n\t\t\t\tassert(max_flow(s,t,d-revd)==d-revd);\n\t\t\t\tflow -= d-revd;\n\t\t\t\t// cerr << d-revd <<endl;\n\t\t\t\t// cerr << make_tuple(e.cap,e.icap,reve.cap,reve.icap)<<endl;\n\t\t\t\te.cap = 0;e.icap = 0;\n\t\t\t\treve.cap = 0;reve.icap = 0;\n\t\t\t\t// e.cap =0;reve.cap = 0;\n\t\t\t\t\n\t\t\t\t// // cerr <<\"!preflow!\"<<endl;\n\t\t\t\t// // REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t\t// // \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t\t// // \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t\t// // }\n\t\t\t\t// // cerr <<endl;\n\t\t\t\t// // cerr << d <<endl;\n\t\t\t\n\t\t\t\t// // S <- s <- t <- T のパス\n\t\t\t\t// // cerr << make_tuple(s,S,d) <<endl;\n\t\t\t\t// Flow fs = max_flow(s,S,d);\n\t\t\t\t// Flow ft = max_flow(T,t,d);\n\t\t\t\t// Flow f = min(fs,ft);\n\t\t\t\t// // cerr <<\"::f\" <<f <<endl;\n\t\t\t\t// flow -= f;\n\t\t\t\t// // cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n\t\t\t\t// // 流しすぎ分の除去\n\t\t\t\t// max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\t\t\t\t// // 閉路の除去\n\t\t\t\t// // s -> t -> s\n\t\t\t\t// // cerr << make_tuple(s,t,d-f)<<endl;\n\t\t\t\t// Flow floop = max_flow(s,t,d-f);\n\n\t\t\t\t// // cerr <<make_tuple(floop,t+1,s+1) <<endl;\n\t\t\t\t// // cerr <<\"!flow!\"<<endl;\n\t\t\t\t// // REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t\t// // \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t\t// // \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t\t// // }\n\t\t\t\t// // cerr <<endl;\n\n\t\t\t\t// // s <- t d戻す\n\t\t\t\t// e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n\t\t\t\t\n\t\t\t\t// // 減らす\n\t\t\t\t// e.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}\n\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(e2.ex){ \n\t\t\t// \tassert(e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex){ \n\t\t\t// \tassert(-e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\n\n\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t// cerr <<\"!pre:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tassert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\n\t\t\tFlow _f = max_flow(S,T);  // cerr <<\"_f:\"<< _f <<endl; \n\t\t\tflow += _f;\n\n\t\t\t// cerr <<\"!post:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tcerr << v+1 <<\" \" << e2.to+1<<endl; \n\t\t\t// \tassert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\t\t}\n\n\t\t// cerr <<\"f:\"<< flow <<endl;\n\n\t\treturn flow;\n\t}\n\n\tint max_flow(int s,int t,Flow Mf=INF<Flow>()){\n\t\tif(s==t)return Mf;\n\t\tFlow flow=0;\n\t\twhile(true){\n\t\t\tfill(ALL(iter),0);\n\t\t\tbfs_dist(s);\n\t\t\tif(Mf==0 || dist[t] == -1)return flow; //限界\n\t\t\tFlow f;\n\t\t\twhile((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n\t\t}\n\t\treturn -1;\n\t}\n};\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N,E,Q;cin >> N >> E >> Q;\n\n\t\tMaximamFlow mf(N);\n\t\tREP(i,N)REP(j,N)if(i<j){mf.add_edge(i,j,0);}\n\n\t\tll flow=0;\n\t\tREP(e,E){\n\t\t\tint f,t;cin >> f >> t;f--;t--;\n\t\t\tflow+=mf.change_cost(0,N-1,f,t,1);\n\t\t\tflow+=mf.change_cost(0,N-1,t,f,1);\n\t\t}\n\t\t// cerr << flow <<endl;\n\t\tREP(q,Q){\n\t\t\tint t,a,b;cin >> t >> a >> b;a--;b--;\n\t\t\t\n\t\t\t// cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n\t\t\tif(t==1){\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,1);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,1);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}else{\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,0);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,0);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n \nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n#include <unistd.h>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv;\n\nint flow(int n,int a,int b,int c){\n\tint ret=0;\n\twhile(1){\n\t\tqueue<int> q;\n\t\tq.push(a);\n\t\tvint used(n,-1);\n\t\tused[a]=a;\n\t\t// cout<<\"hoge\\n\";\n\t\twhile(!q.empty()){\n\t\t\t// cout<<\"hoge\\n\";\n\t\t\tint t=q.front();\n\t\t\t// cout<<\"t \"<<t<<endl;\n\t\t\t// sleep(1);\n\t\t\tq.pop();\n\t\t\trep(i,n){\n\t\t\t\tif(used[i]<0&&vv[t][i]>0){\n\t\t\t\t\t// cout<<t<<\" \"<<i<<\" \"<<vv[t][i]<<endl;\n\t\t\t\t\tused[i]=t;\n\t\t\t\t\tq.push(i);\n\t\t\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\t\t\t// cout<<\"q.size \"<<q.size()<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(used[b]>=0) break;\n\t\t}\n\t\tif(used[b]<0) return ret;\n\t\tfor(int i=b;i!=used[i];i=used[i]){\n\t\t\t--vv[used[i]][i];\n\t\t\t++vv[i][used[i]];\n\t\t\t// cout<<i<<endl;\n\t\t}\n\t\tret++;\n\t\tif(c) return ret;\n\t}\n\treturn ret;\n}\n\n\nvoid mainmain(){\n\tint n,e,q;\n\twhile(cin>>n>>e>>q){\n\t\tvint v(n,INF);\n\t\t// v[0]=0;\n\t\tinitvv(vv,n,n,0);\n\t\t// vvint vv(n);\n\t\trep(i,e){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a][b]=1;\n\t\t\tvv[b][a]=1;\n\t\t}\n\t\tint ans=flow(n,0,n-1,0);\n\t\t// cout<<ans<<endl;\n\t\trep(i,q){\n\t\t\tint r,a,b;\n\t\t\tcin>>r>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(r==2){\n\t\t\t\trep(i,2){\n\t\t\t\t\tif(vv[a][b]==2){\n\t\t\t\t\t\tvv[a][b]=0;\n\t\t\t\t\t\tif(flow(n,0,n-1,1)) continue;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t\tflow(n,n-1,b,1);\n\t\t\t\t\t\tflow(n,a,0,1);\n\t\t\t\t\t}\n\t\t\t\t\tswap(a,b);\n\t\t\t\t}\n\t\t\t\tvv[a][b]=0;\n\t\t\t\tvv[b][a]=0;\n\t\t\t\t/*  here  */\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvv[a][b]=1;\n\t\t\t\tvv[b][a]=1;\n\t\t\t\tans+=flow(n,0,n-1,1);\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint n;\nvector<vector<Edge> > edges;\nvector<bool> used(n, false);\n\nint dfs(int s, int t, int f){\n    if(s == t)\n        return f;\n\tused[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 0){\n            int g = dfs(e.to, t, min(f, e.cap));\n            if(g > 0){\n                e.cap -= g;\n                edges[e.to][e.rev].cap += g;\n\t\t\t\tused[s] = false;\n                return g;\n            }\n        }\n    }\n\tused[s] = false;\n    return 0;\n}\n\nint main()\n{\n\tint e, q;\n\tcin >> n >> e >> q;\n\n\tedges.assign(n, vector<Edge>());\n\tused.assign(n, false);\n\tfor(int i=0; i<e; ++i){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\t-- f;\n\t\t-- t;\n\t\tedges[f].push_back(Edge(t, 1, edges[t].size()));\n\t\tedges[t].push_back(Edge(f, 1, edges[f].size()-1));\n\t}\n\n\tint ret = 0;\n\tfor(;;){\n\t\tint f = dfs(0, n-1, INT_MAX);\n\t\tif(f == 0)\n\t\t\tbreak;\n\t\tret += f;\n\t}\n\n\tfor(int i=0; i<q; ++i){\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\t-- a;\n\t\t-- b;\n\t\tif(m == 1){\n\t\t\tedges[a].push_back(Edge(b, 1, edges[b].size()));\n\t\t\tedges[b].push_back(Edge(a, 1, edges[a].size()-1));\n\t\t\tret += dfs(0, n-1, INT_MAX);\n\t\t}else{\n\t\t\tint j = 0;\n\t\t\twhile(edges[a][j].to != b)\n\t\t\t\t++ j;\n\t\t\tif(edges[a][j].cap == 0){\n\t\t\t\tedges[b][edges[a][j].rev].cap = 0;\n\t\t\t\tdfs(a, 0, 1);\n\t\t\t\tdfs(n-1, b, 1);\n\t\t\t\t-- ret;\n\t\t\t}else{\n\t\t\t\tedges[a][j].cap = 0;\n\t\t\t\tdfs(b, 0, 1);\n\t\t\t\tdfs(n-1, a, 1);\n\t\t\t\t-- ret;\n\t\t\t}\n\t\t\tret += dfs(0, n-1, INT_MAX);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    edge(){}\n    edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}\n  };\n\n  vector< vector<edge> > graph;\n  vector<int> level, iter;\n\n  Dinic(int V):graph(V), level(V), iter(V){}\n  \n  pair<int, int> add_edge(int f, int t, int cap, bool bi = false)\n  {\n    graph[f].push_back(edge(t, cap, graph[t].size()));\n    graph[t].push_back(edge(f, (bi ? cap : 0), graph[f].size()-1));\n    return make_pair(graph[f].size()-1, graph[t].size()-1);\n  }\n  void bfs(int s)\n  {\n    fill(all(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : graph[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < graph[v].size(); i++) {\n      edge& e = graph[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t, int exf = inf)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] <= 0) return flow;\n      fill(all(iter), 0);\n      int f; while((f = dfs(s, t, exf)) > 0) flow += f;\n    }\n  }\n};\n\nint N, E, Q;\nvector< tuple<int, int, int> > query;\nint conn[505][505];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  memset(conn, -1, sizeof(conn));\n  while(E--) {\n    int f, t;\n    cin >> f >> t; f--, t--;\n    tie(conn[f][t], conn[t][f]) = graph.add_edge(f, t, 1, true);\n  }\n  while(Q--) {\n    int m, a, b;\n    cin >> m >> a >> b; a--, b--;\n    query.emplace_back(m, a, b);\n    if(m == 1 && !~conn[a][b]) {\n      tie(conn[a][b], conn[b][a]) = graph.add_edge(a, b, 0, true);\n    }\n  }\n\n  int s = 0, t = N-1; \n  int mxf = graph.max_flow(s, t);\n  \n  for(auto q : query) {\n    int m, a, b;\n    tie(m, a, b) = q;\n    if(m == 1) {\n      graph.graph[a][conn[a][b]].cap = graph.graph[b][conn[b][a]].cap = 1;\n      mxf += graph.max_flow(0, N-1);\n    } else if(m == 2) {\n      int cap = graph.graph[a][conn[a][b]].cap;\n      graph.graph[a][conn[a][b]].cap = graph.graph[b][conn[b][a]].cap = 0;\n      // cap == 1 : didn't use\n      if(cap == 0) { // used a -> b\n\tif(!graph.max_flow(a, b, 1)) {\n\t  graph.max_flow(t, b, 1);\n\t  graph.max_flow(a, s, 1);\n\t  mxf--; \t  \n\t}\n      } else if(cap == 2) { // used b -> a\n\tif(!graph.max_flow(b, a, 1)) {\n\t  graph.max_flow(t, a, 1);\n\t  graph.max_flow(b, s, 1);\n\t  mxf--; \t  \n\t}\n      }\n    }\n    cout << mxf << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n          max_flow(graph.size() - 1, to, 1);\n          max_flow(from, 0, 1);\n          return (true);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, to, 1);\n            max_flow(from, 0, 1);  \n            e.alive = false;\n            return(1);\n          }\n        }\n        e.alive = false;\n        return(0);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n      flow -= graph.remove_edge(B, A);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <functional>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntemplate <typename Weight>\nstruct MaxFlow{\n\tstruct Edge{\n\t\tint v;\n\t\tWeight w;\n\t\tint r;\n\t\tEdge(int v, Weight w,int r=0):v(v),w(w),r(r){}\n\t};\n\ttypedef vector< vector<Edge> > Graph;\n\tint n, source, sink;\n\tGraph g;\n\tWeight flow;\n\tMaxFlow(int n=0, int s=0, int t=0):n(n), g(n), flow(0), source(s), sink(t){\n\t\t\n\t}\n\t\n\tvoid add_edge(int u, int v, Weight cap, Weight revcap=0){\n\t\tg[u].emplace_back(v,cap,g[v].size());\n\t\tg[v].emplace_back(u,revcap,g[u].size()-1);\n\t}\n\tvoid rem_edge(int u,int v, Weight cap){\n\t\tfor(auto &e : g[u])if(e.v == v){\n\t\t\tWeight t = min(cap, e.w);\n\t\t\te.w -= t;\n\t\t\tcap -= t;\n\t\t\tif(cap == 0) return;\n\t\t}\n\t\tWeight t = cap;\n\t\tcap -= maxflow_dinic(u, v, cap);\n\t\tif(cap){\n\t\t\tmaxflow_dinic(sink, v, cap);\n\t\t\tmaxflow_dinic(u, source, cap);\n\t\t\tflow -= cap;\n\t\t}\n\t\trem_edge(v, u, t);\n\t}\n\t\n\tWeight maxflow_dinic(int source, int sink, Weight limit){\n\t\tif(source == sink) return limit;\n\t\tconst Weight inf = numeric_limits<Weight>::max();\n\t\tWeight flow = 0;\n\t\twhile(true){\n\t\t\tvector<int> level(n, -1);\n\t\t\tqueue<int> q;\n\t\t\tlevel[source] = 0;\n\t\t\tq.push(source);\n\t\t\twhile(!q.empty()){\n\t\t\t\tconst int u = q.front(); q.pop();\n\t\t\t\tfor(const auto &e : g[u]){\n\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\tif(e.w <= 0 || level[v] >= 0){ continue; }\n\t\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(level[sink] < 0){ break; }\n\t\t\tvector<size_t> itr(n, 0);\n\t\t\twhile(true){\n\t\t\t\tfunction<Weight(int, Weight)> dfs =\n\t\t\t\t\t[&](int u, Weight limit) -> Weight{\n\t\t\t\t\t\tif(u == sink) return limit;\n\t\t\t\t\t\tfor(; itr[u] < g[u].size(); ++itr[u]){\n\t\t\t\t\t\t\tauto &e = g[u][itr[u]];\n\t\t\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\t\t\tif(e.w <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\t\tconst Weight diff = dfs(v, min(e.w, limit));\n\t\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\t\te.w -= diff;\n\t\t\t\t\t\t\t\tg[v][e.r].w += diff;\n\t\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t};\n\t\t\t\tconst auto f = dfs(source, limit - flow);\n\t\t\t\tif(f <= 0) break;\n\t\t\t\tif((flow += f) == limit) return flow;\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tWeight maxflow(){\n\t\treturn flow += maxflow_dinic(source, sink, numeric_limits<Weight>::max());\n\t}\n};\n\nint N, E, Q;\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tMaxFlow<int> g(N, 0, N-1);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg.add_edge(u, v, 1, 1);\n\t}\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v; u--; v--;\n\t\tif(f == 1){\n\t\t\tg.add_edge(u, v, 1, 1);\n\t\t}else{\n\t\t\tg.rem_edge(u, v, 1);\n\t\t\tg.rem_edge(v, u, 1);\n\t\t}\n\t\tcout << g.maxflow() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n   \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst int INF=1e9;\n\nstruct edge{\n\tint to, cap, rev;\n};\n\nint n;\nvector<int> g[502];\nbool used[502];\nint c[502][502];\n\nvoid add_edge(int from, int to, int cap){\n\tg[from].push_back(to);\n\tg[to].push_back(from);\n\tc[from][to]+=cap;\n}\n\nint dfs(int v, int t, int f){\n\tif(v==t) return f;\n\tused[v]=1;\n\tfor(int i=0; i<g[v].size(); i++){\n\t\tint y=g[v][i];\n\t\tif(!used[y] && c[v][y]>0){\n\t\t\tint d=dfs(y, t, min(f, c[v][y]));\n\t\t\tif(d>0){\n\t\t\t\tc[v][y]-=d;\n\t\t\t\tc[y][v]+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow=0;\n\twhile(1){\n\t\tfill(used, used+n, 0);\n\t\tint f=dfs(s, t, INF);\n\t\tif(f==0) return flow;\n\t\tflow+=f;\n\t}\n}\n\t\nint main()\n{\n\tint e, q;\n\tcin>>n>>e>>q;\n\tfor(int i=0; i<e; i++){\n\t\tint f, t;\n\t\tcin>>f>>t;\n\t\tf--; t--;\n\t\tadd_edge(f, t, 1);\n\t\tadd_edge(t, f, 1);\n\t}\n\tint flow=max_flow(0, n-1);\n\tfor(int i=0; i<q; i++){\n\t\tint m, a, b;\n\t\tcin>>m>>a>>b;\n\t\ta--; b--;\n\t\tif(m==1){\n\t\t\tadd_edge(a, b, 1);\n\t\t\tadd_edge(b, a, 1);\n          fill(used, used+n, 0);\n\t\t\tint f=dfs(0, n-1, 1);\n\t\t\tflow+=f;\n\t\t\tcout<<flow<<endl;\n\t\t}else{\n\t\t\tif(c[a][b]>0 && c[b][a]>0){\n\t\t\t\tc[a][b]--; c[b][a]--;\n\t\t\t\tcout<<flow<<endl;\n\t\t\t}else if(c[a][b]==0){\n\t\t\t\tc[b][a]=0;\n              fill(used, used+n, 0);\n\t\t\t\tif(dfs(a, b, 1)>0){\n\t\t\t\t\tcout<<flow<<endl;\n\t\t\t\t}else{\n                  fill(used, used+n, 0);\n\t\t\t\t\tdfs(a, 0, 1);\n                  fill(used, used+n, 0);\n\t\t\t\t\tdfs(n-1, b, 1);\n\t\t\t\t\tflow--;\n\t\t\t\t\tcout<<flow<<endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tc[a][b]=0;\n              fill(used, used+n, 0);\n\t\t\t\tif(dfs(b, a, 1)){\n\t\t\t\t\tcout<<flow<<endl;\n\t\t\t\t}else{\n                  fill(used, used+n, 0);\n\t\t\t\t\tdfs(b, 0, 1);\n                  fill(used, used+n, 0);\n\t\t\t\t\tdfs(n-1, a, 1);\n\t\t\t\t\tflow--;\n\t\t\t\t\tcout<<flow<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n#include <unistd.h>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv;\n\nint flow(int n,int a,int b,int c){\n\tint ret=0;\n\twhile(1){\n\t\tqueue<int> q;\n\t\tq.push(a);\n\t\tvint used(n,-1);\n\t\tused[a]=a;\n\t\t// cout<<\"hoge\\n\";\n\t\twhile(!q.empty()){\n\t\t\t// cout<<\"hoge\\n\";\n\t\t\tint t=q.front();\n\t\t\t// cout<<\"t \"<<t<<endl;\n\t\t\tsleep(1);\n\t\t\tq.pop();\n\t\t\trep(i,n){\n\t\t\t\tif(used[i]<0&&vv[t][i]>0){\n\t\t\t\t\t// cout<<t<<\" \"<<i<<\" \"<<vv[t][i]<<endl;\n\t\t\t\t\tused[i]=t;\n\t\t\t\t\tq.push(i);\n\t\t\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\t\t\t// cout<<\"q.size \"<<q.size()<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(used[b]>=0) break;\n\t\t}\n\t\tif(used[b]<0) return ret;\n\t\tfor(int i=b;i!=used[i];i=used[i]){\n\t\t\t--vv[used[i]][i];\n\t\t\t++vv[i][used[i]];\n\t\t\t// cout<<i<<endl;\n\t\t}\n\t\tret++;\n\t\tif(c) return ret;\n\t}\n\treturn ret;\n}\n\n\nvoid mainmain(){\n\tint n,e,q;\n\twhile(cin>>n>>e>>q,n){\n\t\tvint v(n,INF);\n\t\t// v[0]=0;\n\t\tinitvv(vv,n,n,0);\n\t\t// vvint vv(n);\n\t\trep(i,e){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a][b]=1;\n\t\t\tvv[b][a]=1;\n\t\t}\n\t\tint ans=flow(n,0,n-1,0);\n\t\t// cout<<ans<<endl;\n\t\trep(i,q){\n\t\t\tint r,a,b;\n\t\t\tcin>>r>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(r==2){\n\t\t\t\trep(i,2){\n\t\t\t\t\tif(vv[a][b]==2){\n\t\t\t\t\t\tans--;\n\t\t\t\t\t\tflow(n,n-1,b,1);\n\t\t\t\t\t\tflow(n,a,0,1);\n\t\t\t\t\t}\n\t\t\t\t\tswap(a,b);\n\t\t\t\t}\n\t\t\t\tvv[a][b]=0;\n\t\t\t\tvv[b][a]=0;\n\t\t\t\t/*  here  */\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvv[a][b]=1;\n\t\t\t\tvv[b][a]=1;\n\t\t\t\tans+=flow(n,0,n-1,1);\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint V,E;\nint G[501][501]; // ??°???????????£??\\???????????¨???\nvector<int> used; // DFS??§?????§???????????????????????°\n\n// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n    G[from][to] = G[to][from] = cap;\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < V; i++) {\n        auto &cap = G[v][i];\n        if (!used[i] && cap > 0) {\n            int d = dfs(i, t, min(f, cap));\n            if (d > 0) {\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\n/* one_path check*/\nbool check(int v, int t) {\n\tif (v == t)return true;\n\tused[v] = true;\n\tfor (int i = 0; i < V;i++) {\n\t\tauto& cap = G[v][i];\n\t\tif (!used[i] && cap > 0) {\n\t\t\tif (check(i, t)) {\n\t\t\t\tcap--;\n\t\t\t\tG[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> V >> E;\n    int Q; cin >> Q;\n    for(int i = 0; i < 501;i++){\n        for(int j = 0;j < 501;j++){\n            G[i][j] = 0;\n        }\n    }\n    used.resize(V);\n    for (int i = 0; i < E;i++) {\n        int s, t; cin >> s >> t;\n        s--;t--;\n        add_edge(s, t, 1);\n    }\n    \n    int f = max_flow(0, V - 1);\n    for(int i = 0; i < Q;i++){\n        int M,A,B; cin >> M >> A >> B;\n        A--;B--;\n        if(M == 1){\n            G[A][B] = G[B][A] = 1;\n            fill(used.begin(),used.end(),0);\n            f += dfs(0,V-1,INF);\n        }else{\n            if(G[A][B] == 0 || G[B][A] == 0){\n                int u,v;\n                if(G[A][B] == 0){ u = A; v = B;}\n                else{u = B; v = A;}\n\t\t\t\tfill(used.begin(), used.end(), 0);\n                if(!check(u,v)){\n                    fill(used.begin(),used.end(),0);\n\t\t\t\t\tcheck(u, 0);\n                    fill(used.begin(),used.end(),0);\n\t\t\t\t\tcheck(V - 1, v);\n                    f--;\n                }\n            }\n            G[A][B] = G[B][A] = 0;\n        }\n\t\tcout << f << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t\tif(q==983||q==984){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n,E,Q;\nint cap[505][505];\n\nbool used[555];\nvector<int>G[505];\n\nvoid add_edge(int from,int to){\n    G[from].push_back(to);\n    G[to].push_back(from);\n    cap[from][to]=cap[to][from]=1;\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        int e=G[v][i];\n        if(!(!used[e]&&cap[v][e]>0))continue;\n        int d=dfs(e,t,min(f,cap[v][e]));\n        if(d){\n            cap[v][e]-=d;\n            cap[e][v]+=d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n        memset(used,0,sizeof(used));\n        int f=dfs(s,t,lim);\n        if(!f)return fl;\n        fl+=f;\n        lim-=f;\n    }\n}\n\nint main(){\n    cin>>n>>E>>Q;\n    r(i,E){\n        int s,t;\n        cin>>s>>t;s--;t--;\n        add_edge(s,t);\n    }\n    int ANS=flow(0,n-1,1e9);\n    r(i,Q){\n        int m,s,t;\n        cin>>m>>s>>t;s--;t--;\n        if(m==1){\n            add_edge(s,t);\n            ANS+=flow(0,n-1,1);\n        }\n        else{\n            if(cap[t][s]==2)swap(s,t);\n            if(cap[s][t]==2){\n                int x=flow(t,s,1);\n                if(!x){\n                    flow(n-1,0,1);\n                    flow(t,s,1);\n                    ANS--;\n                }\n            }\n            cap[s][t]=cap[t][s]=0;\n            G[s].erase(find(G[s].begin(),G[s].end(),t));\n            G[t].erase(find(G[t].begin(),G[t].end(),s));\n        }\n        cout<<ANS<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, cap, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tif (s == to && !flag) return false;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (s == from && e.to != to) continue;\n\t\tbool nf = flag || (s == from && e.to == to);\n\t\tif (!used2[e.to][(int)nf] && e.cap > 0) {\n\t\t\tbool f = dfs2(e.to, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tfor (int i = 0; i < G[a].size(); ++i) {\n\t\tEdge& e = G[a][i];\n\t\tif (e.to == b) {\n\t\t\tif (e.cap > 1) {\n\t\t\t\treturn removeEdge(b, a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cap = e.cap;\n\t\t\t\tif (cap < 1) {\n\t\t\t\t\tmemset(used2, false, sizeof(used2));\n\t\t\t\t\tdfs2(N-1, 0, b, a, false);\n/*\n\t\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\t\tif ( !dfs(a, b, 1) ) {\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(a, 0, 1);\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(N-1, b, 1);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t\tG[b].erase(G[b].begin()+e.rev);\n\t\t\t\tG[a].erase(G[a].begin()+i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tG.resize(N);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T, 1);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b, 1);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tmemset(used, false, sizeof(used)); f += dfs(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include <assert.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != -1){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = -1;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    while(Q--){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            //  edge: a -> b is used\n            if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b,a,1) == 0){\n                    fl.getmaxflow(N-1,0,1);\n                    fl.getmaxflow(b,a,1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a,b,1) == 0){\n                    fl.getmaxflow(N-1, 0,1);\n                    fl.getmaxflow(a,b,1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t//cout << v << ' ' << e.to << ' ' << e.cap << endl;\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, cap, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\tauto& e = G[a][edge[a][b]];\n\t\t\tauto& re = G[b][e.rev];\n\n\t\t\te.cap = re.cap = 1;\t\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\tauto e = G[a][edge[a][b]];\n\t\t\tint d = e.cap;\n\t\t\te.cap = G[b][e.rev].cap = 0;\n\t\t\tif(d == 1) return 0;\n\t\t\tif(d == 2){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(b, a, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, a, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(b, s, 1);\n\t\t\t}else{\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(a, s, 1);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tint subCapacity_(int s, int t, int a, int b){\n\t\t\t//cout << \"SUB\" << endl;\n\t\t\t//if(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\t//cout << a << ' ' << b << endl;\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\tif(ab.cap >= 1){\n\t\t\t\t//cout << \"WY\" << endl;\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\t//cout << \"HE\" << endl;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcout << \"OUT\" << endl;\n\n\t\t\t\t//for(auto i : G){\n\t\t\t\t//\tfor(auto j : i){\n\t\t\t\t//\t\tcout << j.to << ' ' << j.cap << ' ' << j.rev << endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint ans = dfs(a, s, 1);\n\t\t\t\t//show(ans)\n\t\t\t\t//assert(ans == 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\t//assert(dfs(t, b, 1) == 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\t//flow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = 0, t = n - 1;\n\t//flow.addEdge(s, 0, INF);\n\t//flow.addEdge(n - 1, t, INF);\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\t//if(not use[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\t//assert(flow.fordFulkerson(s, t) == 0);\n\t\tcout << ans << endl;\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t)  return f;\n\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    int flow = 0;\n    while (bfs(s), s != t && level[t] >= 0 && flow_ > 0) {\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n    }\n\n    return flow;\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        int j = 0;\n        while (G[a][j].to != b) j++;\n        if (m == 1) {\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n);\n        } else {\n            int from = -1, to = -1;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 && to > 0 && max_flow(from, to, 1) == 0) {\n                f--;\n                max_flow(from, 1);\n                max_flow(n, to);\n            }\n        }\n        cout << f << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\n#define MAX 502\n#define INF INT_MAX\n\nint n;\nint cap[MAX][MAX];\nbool used[MAX];\n\nint dfs(int v , int t, int f){\n  if(v==t) return f;\n  used[v] = true;\n  rep(i,n){\n    int c = cap[v][i];\n    if(!used[i] && c > 0){\n      int d = dfs(i , t , min(f, c));\n      if(d > 0){\n        cap[v][i] -= d;\n        cap[i][v] += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint mf(int s, int t){\n  int flow = 0;\n  for(;;){\n    memset(used , 0 , sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(void){\n  int e,q;\n\n  while(scanf(\"%d%d%d\",&n,&e,&q) != EOF){\n    memset(cap,-1,sizeof(cap));\n\n    rep(i,e){\n      int from,to;\n      scanf(\"%d%d\",&from,&to);\n      from--;\n      to--;\n      cap[from][to] = cap[to][from] = 1;\n    }\n\n    int res = mf(0,n-1);\n\n    while(q--){\n      int flg,a,b;\n      scanf(\"%d%d%d\",&flg,&a,&b);\n      a--;\n      b--;\n\n      if(flg == 1){\n        cap[a][b] = cap[b][a] = 1;\n        res += mf(0,n-1);\n      }\n      else{\n        if(cap[a][b] != 1){\n          if(cap[a][b] != 0) swap(a,b);\n          memset(used,0,sizeof(used));\n          int tmp = dfs(a,b,1);\n          if(tmp != 1){\n            memset(used,0,sizeof(used));\n            dfs(a,0,1);\n            memset(used,0,sizeof(used));\n            dfs(n-1,b,1);\n            res--;\n          }\n        }\n        cap[a][b] = cap[b][a] = -1;\n      }\n      /*\n      rep(i,n){\n        rep(j,n){\n          printf(\"%3d\",cap[i][j]);\n        }\n        cout<<endl;\n      }\n        cout<<endl;\n      */\n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000;\nint cap[1000][1000];\n\nint maximumFlow(int n, int s, int t){\n\tint res = 0;\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\tint inc = INF;\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tinc = min(inc, cap[prev[j]][j]);\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j] -= inc, cap[j][prev[j]] += inc;\n\t\tres += inc;\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\t// A->B gpÏÝ\n\t\t\t\tif(cap[A-1][B-1] == 0){\n\t\t\t\t\tint c = B-1;\n\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc = A-1;\n\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t\telse if(cap[B-1][A-1] == 0){\n\t\t\t\t\tint c = A-1;\n\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tc = B-1;\n\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[c][j] == 1){\n\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t}\n\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t}\n\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[e.to][eind[e.to][s]];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    vector<map<int,int>> eind;\n    MaximamFlow(int V):V(V){\n        G=Graph(V);\n        eind=vector<map<int,int>>(V);\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        if(!eind[s].count(t)){\n        \tint ind=G[s].size();G[s].push_back({t,0,0});eind[s][t]=ind;\n        }\n        if(!eind[t].count(s)){\n        \tint ind=G[t].size();G[t].push_back({s,0,0});eind[t][s]=ind;\n        }\n        G[s][eind[s][t]].icap+=cap; G[s][eind[s][t]].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][eind[s][t]];Edge& reve = G[t][eind[t][s]];\n        \n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n        // cerr <<\"add\"<<endl;\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n        // cerr <<\"del\"<<endl;\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            // cerr <<\"del2\"<<endl;\n            // cerr << s+1 <<\" \" << t+1 <<endl;\n            Flow d = e.icap - e.cap - c;\n            // cerr << d <<endl;\n\n            Flow tmpcap=e.cap,tmprevcap=reve.cap;\n            e.cap =0;reve.cap = 0;\n             \n            // cerr <<\"!preflow!\"<<endl;\n            // REP(v,G.size())for(Edge& e2:G[v]){\n            //  Edge &reve2 = G[e2.to][e2.rev];\n            //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n            // }\n            // cerr <<endl;\n            // cerr << d <<endl;\n\n            // S <- s <- t <- T のパス\n            // cerr << make_tuple(s,S,d) <<endl;\n            Flow fs = max_flow(s,S,d);\n            Flow ft = max_flow(T,t,d);\n            Flow f = min(fs,ft);\n            // cerr <<\"::f\" <<f <<endl;\n            flow -= f;\n\n            // cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n\n            // 流しすぎ分の除去\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\n            // 閉路の除去\n            // s -> t -> s\n            // cerr << make_tuple(s,t,d-f)<<endl;\n            Flow floop = max_flow(s,t,d-f);\n\n            // s <- t d戻す\n            e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n            // 減らす\n            e.cap-=e.icap - c;\n\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            // cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct max_flow{\n    vector<vector<int>> graph;\n    vector<bool> done;\n    int size,flow;\n    max_flow(int size_):size(size_),graph(size_,vector<int>(size_)),done(size_),flow(0){}\n    void add_edge(int from,int to,int cap){\n        graph[from][to]=graph[to][from]=cap;\n    }\n    int dfs(int v,int t,int f){\n        if(v==t) return f;\n        done[v]=true;\n        for(int w=0; w<size; ++w){\n            if(done[w] or graph[v][w]==0) continue;\n            int d=dfs(w,t,min(f,graph[v][w]));\n            if(d>0){\n                graph[v][w]-=d;\n                graph[w][v]+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int calc_max_flow(int s,int t){\n        while(true){\n            fill(done.begin(),done.end(),false);\n            int f=dfs(s,t,inf);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nvoid solve(){\n    int n,e,q;\n    cin >> n >> e >> q;\n    max_flow mf(n);\n    rep(i,0,e){\n        int f,t;\n        cin >> f >> t;\n        --f;\n        --t;\n        mf.add_edge(f,t,1);\n    }\n    mf.calc_max_flow(0,n-1);\n    auto search_path=[&](int s,int t,int c){\n        vector<int> from(n);\n        vector<bool> done(n);\n        queue<int> que;\n        que.push(s);\n        done[s]=true;\n        while(!que.empty()){\n            int u=que.front();\n            que.pop();\n            if(u==t){\n                vector<int> res;\n                int v=u;\n                while(v!=s){\n                    res.push_back(v);\n                    v=from[v];\n                }\n                res.push_back(s);\n                return res;\n            }\n            rep(v,0,n){\n                if(done[v]) continue;\n                if(c==1){\n                    if(mf.graph[u][v]!=1) continue;\n                }else{\n                    if(mf.graph[u][v]!=0 or mf.graph[v][u]!=2) continue;\n                }\n                que.push(v);\n                done[v]=true;\n                from[v]=u;\n            }\n        }\n\n        return vector<int>();\n    };\n    rep(i,0,q){\n        int m,a,b;\n        cin >> m >> a >> b;\n        --a;\n        --b;\n        if(m==1){\n            mf.add_edge(a,b,1);\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }else{\n            if(mf.graph[a][b]==1){\n                cout << mf.calc_max_flow(0,n-1) << endl;\n                continue;\n            }\n            int k=mf.calc_max_flow(0,n-1);\n            if(mf.graph[b][a]==0) swap(a,b);\n            mf.graph[a][b]=mf.graph[b][a]=0;\n            vector<int> vs=search_path(a,b,1);\n            if(!vs.empty()){\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=0;\n                    mf.graph[vs[i+1]][vs[i]]=2;\n                }\n                cout << k << endl;\n                continue;\n            }\n            --mf.flow;\n            if(a!=0){\n                vector<int> vs=search_path(0,a,0);\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=1;\n                    mf.graph[vs[i+1]][vs[i]]=1;\n                }\n            }\n            if(b!=n-1){\n                vector<int> vs=search_path(b,n-1,0);\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=1;\n                    mf.graph[vs[i+1]][vs[i]]=1;\n                }\n            }\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tmap<P,int> m;\n\tint DFS(int v,int t,int f,vi& used){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),used);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tm[{s,t}]=g[s].size();\n\t\tg[s].push_back(edge{t,1,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,1,(int)g[s].size()-1});\n\t}\n\tint Max_Flow(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi used(V);\n\t\t\tint f=DFS(s,t,1,used);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n\tint Add(int u,int v){\n\t\tadd_edge(u,v);\n\t\tvi used(V);\n\t\treturn DFS(0,V-1,inf,used);\n\t}\n\tint Erase(int u,int v){\n\t\tint I=m[{u,v}],J=g[u][I].rev,C=g[u][I].cap;\n\t\tif(C==1){\n\t\t\tg[u][I].cap=0;\n\t\t\tg[v][J].cap=0;\n\t\t\treturn 0;\n\t\t}\n\t\tvi used(V);\n\t\tDFS((C?v:u),0,1,used);\n\t\tused=vi(V);\n\t\tDFS(V-1,(C?u:v),1,used);\n\t\tg[u][I].cap=0;\n\t\tg[v][J].cap=0;\n\t\tused=vi(V);\n\t\treturn 1-DFS(0,V-1,1,used);\n\t}\n};\n\nint n,m,q;\n\nint main(){\n\tcin>>n>>m>>q;\n\tNetwork nt(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tnt.add_edge(u,v);\n\t}\n\tint res=nt.Max_Flow(0,n-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t,u,v;\n\t\tcin>>t>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tif(t==1) res+=nt.Add(u,v);\n\t\telse res-=nt.Erase(u,v);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (!x.add || x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t\tflow.add_edge(t, f, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n \nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass MaximamFlow{\nprivate:\n\ttypedef int Flow;\n\tstruct Edge{int to,rev;Flow icap,cap;bool ex;};\n\ttypedef vector<vector<Edge>> Graph;\n\n\t//iter　次に調べる時の開始位置 距離\n\tvector<int> iter,dist;\n\n\t//sからのbfs距離の計算\n\tvoid bfs_dist(int s){\n\t\tfill(ALL(dist),-1); dist[s]=0;\n\t\tqueue<int> que; que.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();que.pop();\n\t\t\tfor(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n\t\t\t\tdist[e.to]=dist[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//増加パス\n\tFlow dfs_best_path(int s,int t,Flow f){\n\t\tif(s==t)return f;\n\t\tfor(int &i = iter[s];i < (int)G[s].size();i++){\n\t\t\tEdge &e=G[s][i];Edge &reve = G[e.to][e.rev];\n\t\t\tif(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n\t\t\t//search\n\t\t\tFlow d = dfs_best_path(e.to,t,min(f,e.cap));\n\t\t\tif(d==0)continue;\n\t\t\t//found\n\t\t\te.cap-=d;reve.cap+=d;\n\t\t\t\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tint V;Graph G;\n\tMaximamFlow(int V):V(V){\n\t\tG=Graph(V);\n\t\tdist=vector<int>(V,-1);iter=vector<int>(V);\n\t}\n\n\tvoid add_edge(int s,int t,Flow cap){\n\t\tint srev=G[t].size(),trev=G[s].size();\n\t\tG[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,0,0,false});\n\t}\n\n\tFlow change_cost(int S,int T,int s,int t,int c){\n\t\tFlow flow = 0;\n\t\tfor(Edge& e:G[s])if(e.to == t){\n\t\t\tEdge &reve = G[e.to][e.rev];\n\t\t\tif(e.icap <= c){// 単純に増やす\n\t\t\t\t// cerr <<\"add\"<<endl;\n\t\t\t\te.cap+=c - e.icap;\n\t\t\t\te.icap = c;\n\t\t\t}else if(c >= e.icap-e.cap){ // 単純に減らす\n\t\t\t\t// cerr <<\"del\"<<endl;\n\t\t\t\te.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}else{// フローを戻してから減らす\n\t\t\t\t// cerr <<\"del2\"<<endl;\n\t\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t\tFlow d = e.icap - e.cap - c; \n\t\t\t\t\n\t\t\t\t//出来るだけs->tを使わないフローに置き換える\n\t\t\t\tFlow revd = max_flow(s,t,d);\n\t\t\t\tmax_flow(T,S,d-revd);\n\t\t\t\tassert(max_flow(s,t,d-revd)==d-revd);\n\t\t\t\t\n\t\t\t\tflow -= d-revd;\n\t\t\t\t// cerr << d-revd <<endl;\n\t\t\t\t// cerr << make_tuple(e.cap,e.icap,reve.cap,reve.icap)<<endl;\n\t\t\t\te.cap = 0;e.icap = 0;\n\t\t\t\treve.cap = 0;reve.icap = 0;\n\t\t\t\t// e.cap =0;reve.cap = 0;\n\t\t\t\t\n\t\t\t\t// // cerr <<\"!preflow!\"<<endl;\n\t\t\t\t// // REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t\t// // \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t\t// // \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t\t// // }\n\t\t\t\t// // cerr <<endl;\n\t\t\t\t// // cerr << d <<endl;\n\t\t\t\n\t\t\t\t// // S <- s <- t <- T のパス\n\t\t\t\t// // cerr << make_tuple(s,S,d) <<endl;\n\t\t\t\t// Flow fs = max_flow(s,S,d);\n\t\t\t\t// Flow ft = max_flow(T,t,d);\n\t\t\t\t// Flow f = min(fs,ft);\n\t\t\t\t// // cerr <<\"::f\" <<f <<endl;\n\t\t\t\t// flow -= f;\n\t\t\t\t// // cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n\t\t\t\t// // 流しすぎ分の除去\n\t\t\t\t// max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\t\t\t\t// // 閉路の除去\n\t\t\t\t// // s -> t -> s\n\t\t\t\t// // cerr << make_tuple(s,t,d-f)<<endl;\n\t\t\t\t// Flow floop = max_flow(s,t,d-f);\n\n\t\t\t\t// // cerr <<make_tuple(floop,t+1,s+1) <<endl;\n\t\t\t\t// // cerr <<\"!flow!\"<<endl;\n\t\t\t\t// // REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t\t// // \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t\t// // \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t\t// // }\n\t\t\t\t// // cerr <<endl;\n\n\t\t\t\t// // s <- t d戻す\n\t\t\t\t// e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n\t\t\t\t\n\t\t\t\t// // 減らす\n\t\t\t\t// e.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}\n\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(e2.ex){ \n\t\t\t// \tassert(e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex){ \n\t\t\t// \tassert(-e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\n\n\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t// cerr <<\"!pre:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tassert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\n\t\t\tFlow _f = max_flow(S,T);  // cerr <<\"_f:\"<< _f <<endl; \n\t\t\tflow += _f;\n\n\t\t\t// cerr <<\"!post:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tcerr << v+1 <<\" \" << e2.to+1<<endl; \n\t\t\t// \tassert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\t\t}\n\n\t\t// cerr <<\"f:\"<< flow <<endl;\n\n\t\treturn flow;\n\t}\n\n\tint max_flow(int s,int t,Flow Mf=INF<Flow>()){\n\t\tif(s==t)return Mf;\n\t\tFlow flow=0;\n\t\twhile(Mf){\n\t\t\tfill(ALL(iter),0);\n\t\t\tbfs_dist(s);\n\t\t\tif(dist[t]==-1)break;\n\t\t\tFlow f;\n\t\t\twhile((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N,E,Q;cin >> N >> E >> Q;\n\n\t\tMaximamFlow mf(N);\n\t\tREP(i,N)REP(j,N)if(i<j){mf.add_edge(i,j,0);}\n\n\t\tREP(e,E){\n\t\t\tint f,t;cin >> f >> t;f--;t--;\n\t\t\tREP(i,mf.G[f].size())if(mf.G[f][i].to==t){ mf.G[f][i].cap++;mf.G[f][i].icap++; }\n\t\t\tREP(i,mf.G[t].size())if(mf.G[t][i].to==f){ mf.G[t][i].cap++;mf.G[t][i].icap++; }\n\t\t}\n\t\tll flow=mf.max_flow(0,N-1);\n\n\t\tREP(q,Q){\n\t\t\tint t,a,b;cin >> t >> a >> b;a--;b--;\n\t\t\t\n\t\t\t// cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n\t\t\tif(t==1){\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,1);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,1);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}else{\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,0);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,0);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n \nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\n#define MAX 502\n#define INF INT_MAX\n\nint n; //m[h\nint cap[MAX][MAX]; //¬¹éÊÌãÀ\nbool used[MAX]; //dfsp\n\n//m[hv©çtÖü©ÁÄ, fÈºÌlÅÚ¢ÁÏ¢¬¹é¾¯¬·\nint dfs(int v , int t, int f){\n  if(v == t) return f; //S[És«Â¢½ç, »ÌpXÖf¬¹é\n  used[v] = true;\n\n  //ÂÈªéGbWT·\n  rep(i,n){\n    int c = cap[v][i];\n    if(!used[i] && c > 0){\n      int d = dfs(i , t , min(f, c)); //i©çtÖü©ÁÄ, Åå¬ßé\n      if(d > 0){ //1Èã¬¹éÈç¬·\n        cap[v][i] -= d; //v©çiÖÌeÊª¸é\n        cap[i][v] += d; //i©çvÖÌeÊÍ¦é\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s©çtÖÌÅå¬ðßé\nint mf(int s, int t){\n  int flow = 0;\n\n  //s©çtÖü©ÁÄ, ª¬¹éÀè, ¬·\n  for(;;){\n    memset(used , 0 , sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(void){\n  int e,q;\n\n  while(scanf(\"%d%d%d\",&n,&e,&q) != EOF){\n    memset(cap,-1,sizeof(cap)); //ÓÌÈ¢êÍ, -1Æ·é\n\n    rep(i,e){\n      int from,to;\n      scanf(\"%d%d\",&from,&to);\n      from--;\n      to--;\n      cap[from][to] = cap[to][from] = 1;\n    }\n\n    int res = mf(0,n-1); // ç©¶ßÅå¬ðoµÄ, c]OtðßÄ¨­\n\n    while(q--){\n      int flg,a,b;\n      scanf(\"%d%d%d\",&flg,&a,&b);\n      a--;\n      b--;\n\n      //ÓðÇÁ·éÆ«\n      if(flg == 1){\n        cap[a][b] = cap[b][a] = 1; //a<->bÌÓðÇÁ\n        memset(used,0,sizeof(used));\n        res += dfs(0,n-1,INF); //Åå¬ðsÁÄ, V½É\n      }\n      //ÓðÁ·Æ«\n      else{\n        if(cap[a][b] != 1){\n          if(cap[a][b] != 0) swap(a,b);\n          memset(used,0,sizeof(used));\n          int tmp = dfs(a,b,1);\n          if(tmp != 1){\n            memset(used,0,sizeof(used));\n            dfs(a,0,1);\n            memset(used,0,sizeof(used));\n            dfs(n-1,b,1);\n            res--;\n          }\n        }\n        cap[a][b] = cap[b][a] = -1;\n      }\n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n    int to,cap,rev;\n    bool flag;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    edge e;\n    e.to = to;\n    e.cap = cap;\n    e.rev = G[to].size();\n    e.flag=true;\n    G[from].push_back(e);\n    e.to = from;\n    e.cap = 0;\n    e.rev = G[from].size()-1;\n    G[to].push_back(e);\n}\n// ツ堕敖嘉パツスツづーツ探ツ催オ\nint dfs(int v,int t,int f){\n    if(v==t)\n        return f;\n    used[v]=true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e=G[v][i];\n        if(!e.flag)continue;\n        bool b=false;\n        // ツづ慊つセツ古シツつォツつェツ個按づ慊づづつ「ツづ按つ「ツづ按づァツ、ツつアツつアツづ個按津ィ\n        if(!isDirected[v][e.to]){\n            b=true;\n            isDirected[v][e.to]=true;\n            isDirected[e.to][v]=true;\n            // ツ債。ツ嘉アツ猟ャツつキツフツδ債ーツづ個古シツつォツづ可可楪つカツづ容ツ療環づーツ逆ツ転\n            if(e.cap==0){\n                e.cap=1;\n                G[e.to][e.rev].cap=0;\n            }\n            FlowFrom[v][e.to]=v;\n            FlowFrom[e.to][v]=v;\n        }\n        if(!used[e.to]&&e.cap>0){\n            int d = dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        // ツフツδ債ーツつェツ猟ャツつケツづ按つゥツづつスツ湘ェツ債づ債、ツ個按づ慊づづつ「ツづ按つゥツづつスツつアツづづ可つキツづゥ\n        if(b){\n            isDirected[v][e.to]=false;\n            isDirected[e.to][v]=false;\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow = 0;\n    // flowツつェツ猟ャツつケツづ按つュツづ按づゥツづ慊づ猟ャツつキ\n    while(1){\n        fill(used,used+MAX_V,false);\n        int f=dfs(s,t,INF);\n        if(f==0)\n            return flow;\n        else\n            flow+=f;\n    }\n}\nint one_flow(int s,int t){\n    // flowツつェツ猟ャツつケツづ按つュツづ按づゥツづ慊づ猟ャツつキ\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    return f;\n}\n\nint n,e,q;\nint main(){\n    memset(isDirected,0,sizeof(isDirected));\n    memset(FlowFrom,0,sizeof(FlowFrom));\n    cin>>n>>e>>q;\n    for(int i = 0; i < e; i++){\n        int f,t;\n        cin>>f>>t;\n        add_edge(f,t,1);\n    }\n    // ツ個サツ催敖づ慊づづ個催妥・ツ猟ャツ療環づーツ仰づ淞づつィツつュ\n    int cFlow=max_flow(1,n);\n    // ツ各ツクツエツδ環づ個古」ツづ個猟ャツ療環づーツ仰づ淞づゥ\n    for(int i = 0; i < q; i++){\n        int m,a,b;\n        cin>>m>>a>>b;\n        int idx;\n        int ridx;\n        // ツづつづ按つョ\n        if(m==1){\n            add_edge(a,b,1);\n            // ツ催猟ャツ出\n            cFlow+=max_flow(1,n);\n        }\n        // ツ静伉断ツつキツづゥ\n        else{\n            // ツ静伉断ツ嘉督渉環つェツづ慊つセツ津環嘉淞つウツづェツづつ「ツづ按つ「ツ湘ェツ債            if(!isDirected[a][b]){\n                for(int j = 0; j < G[a].size(); j++){\n                    if(G[a][j].to==b&&G[a][j].flag){\n                        edge &e=G[a][j];\n                        G[a][j].flag=false;\n                        G[b][e.rev].flag=false;\n                        isDirected[a][b]=false;\n                        isDirected[b][a]=false;\n                        break;\n                    }\n                }\n                continue;\n            }\n            for(int j = 0; j < G[a].size(); j++){\n                if(G[a][j].to==b&&G[a][j].flag){\n                    idx=j;\n                    edge &e=G[a][j];\n                    ridx=e.rev;\n                    // ü«ÍÜÁÄ¢éª¬Ê0\n                    if((FlowFrom[a][b]==a&&e.cap==1)\n                        ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n                        break;\n                    // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n                    // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n                    int ff=0;\n                    // from a to bÅ¬êÄ¢é\n                    if(FlowFrom[a][b]==a&&e.cap==0)\n                        ff+=one_flow(a,b);\n                    else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0)\n                        ff+=one_flow(b,a);\n                    // ¬ê½çbreak\n                    if(ff>=1)\n                        break;\n                    // ¬¹È¯êÎ\n                    // µß·\n                    int f=0;\n                    if(FlowFrom[a][b]==a&&e.cap==0){\n                        if(n!=b)\n                            f+=one_flow(n,b);\n                        else\n                            f++;\n                        if(a!=1)\n                            f+=one_flow(a,1);\n                        else\n                            f++;\n                    }\n                    else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n                        if(b!=1)\n                            f+=one_flow(b,1);\n                        else\n                            f++;\n                        if(a!=n)\n                            f+=one_flow(n,a);\n                        else\n                            f++;\n                    }\n                    if(f>=2)\n                        cFlow--;\n                    break;\n                }\n            }\n            // Øf\n            // from a,idxÌvfðoûüÅí·é\n            G[a][idx].flag=false;\n            G[b][ridx].flag=false;\n            isDirected[a][b]=false;\n            isDirected[b][a]=false;\n        }\n        cout<<cFlow<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll idx = -1;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    idx = j;\n                    break;\n                }\n            }\n            Edge& e = G[A][idx];\n            ll r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n            // cout << A << \" \" << B << \" \" << e.rev << \" \" << e.to << \" \" << G[B][e.rev].to << endl;\n            assert(G[B][e.rev].to == A);\n            assert(e.cap + G[B][e.rev].cap == 2);\n            e.cap = 0, e.to = -1;\n            G[B][e.rev].cap = 0, G[B][e.rev].to = -1;\n            // G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n            // G[A].erase(G[A].begin()+idx, G[A].begin()+idx+1);\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else if (r == -1) {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n\tflow[now][next]+=1;\n\tflow[next][now]=-flow[now][next];\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\ttmp=dfs2(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    assert(fr >= 0);\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        // cout << A << \" \" << B << \" \" << M << endl;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll idx = -1;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    assert(idx < 0);\n                    idx = j;\n                }\n            }\n            Edge& e = G[A][idx];\n            ll r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n            // cout << A << \" \" << B << \" \" << e.rev << \" \" << e.to << \" \" << G[B][e.rev].to << endl;\n            assert(G[B][e.rev].to == A);\n            assert(e.cap + G[B][e.rev].cap == 2);\n            e.cap = 0, e.to = -1;\n            G[B][e.rev].cap = 0, G[B][e.rev].to = -1;\n            // G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n            // G[A].erase(G[A].begin()+idx, G[A].begin()+idx+1);\n            if (r) {\n                if (r == 1) {\n                    int f1 = max_flow(t, B, 1);\n                    int f2 = max_flow(A, s, 1);\n                    if (f1 == 0 || f2 == 0) {\n                        if (f1 == 1) max_flow(B, t, 1);\n                        if (f2 == 1) max_flow(s, A, 1);\n                        assert( max_flow(A, B, 1) == 1 );\n                    }\n                    else {\n                        --ans;\n                    }\n                }\n                else if (r == -1) {\n                    int f1 = max_flow(t, A, 1);\n                    int f2 = max_flow(B, s, 1);\n                    if (f1 == 0 || f2 == 0) {\n                        if (f1 == 1) max_flow(A, t, 1);\n                        if (f2 == 1) max_flow(s, B, 1);\n                        assert( max_flow(B, A, 1) == 1 );\n                    }\n                    else {\n                        --ans;\n                    }\n                }\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\n\nconst int MAX_V_flow = 510;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tmap<int,int> id[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tid[from][to] = G[from].size();\n\t\tid[to][from] = G[to].size();\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , flow , G[from].size()-1 ) );\n\t}\n\t\n\tint erase_edge(int from,int to){\n\t\tint s = id[from][to];\n\t\tint t = id[to][from];\n\t\tint ret = 0;\n\t\t//cout << G[from][s].sc.fr << \" \" << G[to][t].sc.fr << endl;\n\t\tif(G[from][s].sc.fr == 2){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tdfs(n,from,1);\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tdfs(to,1,1);\n\t\t\tret = 1;\n\t\t}\n\t\telse if(G[to][t].sc.fr == 2){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tdfs(n,to,1);\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tdfs(from,1,1);\n\t\t\tret = 1;\n\t\t}\n\t\tG[from][s].sc.fr = 0;\n\t\tG[to][t].sc.fr = 0;\n\t\treturn ret;\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\t//printf(\"%d %d %d\\n\",v,t,f);\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\tint ret = 0,d = 1;\n\t\twhile(d > 0){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\td = dfs(s,t,INF);\n\t\t\tret += d;\n\t\t}\n\t\treturn ret;\n\t}\n}flow;\n\nint main(){\n\tint e,q;\n\tscanf(\"%d%d%d\",&n,&e,&q);\n\t\n\trep(i,e){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tflow.add_edge(f,t,1);\n\t}\n\tint ret = flow.flow(1,n);\n\trep(i,q){\n\t\tint m,a,b;\n\t\tscanf(\"%d%d%d\",&m,&a,&b);\n\t\tif(m == 1){\n\t\t\tflow.add_edge(a,b,1);\n\t\t}\n\t\telse {\n\t\t\tret -= flow.erase_edge(a,b);\n\t\t}\n\t\tret += flow.flow(1,n);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n\n\nint V;\nint G[501][501]; // ??°???????????£??\\???????????¨???\nvector<int> used; // DFS??§?????§???????????????????????°\n\n// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n    G[from][to] = G[to][from] = cap;\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < V; i++) {\n        auto &cap = G[v][i];\n        if (!used[i] && cap > 0) {\n            int d = dfs(i, t, min(f, cap));\n            if (d > 0) {\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int E; cin >> V >> E;\n    int Q; cin >> Q;\n    for(int i = 0; i < 501;i++){\n        for(int j = 0;j < 501;j++){\n            G[i][j] = 0;\n        }\n    }\n    used.resize(V);\n    for (int i = 0; i < E;i++) {\n        int s, t; cin >> s >> t;\n        s--;t--;\n        add_edge(s, t, 1);\n    }\n    \n    int f = max_flow(0, V - 1);\n    for(int i = 0; i < Q;i++){\n        int M,A,B; cin >> M >> A >> B;\n        A--;B--;\n        if(M == 1){\n            G[A][B] = G[B][A] = 1;\n            fill(used.begin(),used.end(),0);\n            int t_f = dfs(0,V-1,INF);\n            if(t_f != INF){\n                f += t_f;\n            }\n        }else{\n            if(G[A][B] == 0){\n                fill(used.begin(),used.end(),0);\n                int t_f = dfs(A,B,INF);\n                if(t_f == 0){\n                    f--;\n                }\n            }\n            G[A][B] = G[B][A] = 0;\n        }\n        cout << f << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct Graph\n{\n  struct edge\n  {\n    int to;\n    i64 cap;\n    i64 rev;\n    bool alive;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N)\n  {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Dinic_Reverse\n{\n  int N;\n  vector<int> used;\n  Graph G;\n\n  Dinic_Reverse(int n) : G(n) { N = n; }\n\n  void add_edge(int from, int to, i64 cap, i64 rev_cap)\n  {\n    G[from].push_back({to, cap, (int)G[to].size(), true});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1, true});\n  }\n  i64 dfs(int v, int t, i64 f)\n  {\n    if (v == t)\n      return f;\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++)\n    {\n      auto &e = G[v][i];\n      if (!e.alive)\n        continue;\n      if (e.cap > 0 && !used[e.to])\n      {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0)\n        {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n\n  i64 max_flow(int s, int t, i64 limit = 1e9)\n  {\n    i64 result = 0;\n    i64 flow;\n    while (limit > 0)\n    {\n      used.assign(N, 0);\n      if ((flow = dfs(s, t, limit)) == 0)\n        break;\n      result += flow;\n      limit -= flow;\n    }\n    return result;\n  }\n\n  bool back_edge(int from, int to, int s, int t)\n  {\n    for (auto &e : G[from])\n    {\n      if (e.to == to && e.alive)\n      {\n        e.alive = false;\n        if (e.cap && max_flow(from, to, 1) == 0)\n        {\n          max_flow(from, s, 1);\n          max_flow(t, to, 1);\n          return 1;\n        }\n        else\n        {\n          return 0;\n        }\n      }\n    }\n  }\n};\n\n/*\n\nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\nint n;\nint e;\nint q;\n\nint main()\n{\n  cin >> n >> e >> q;\n  Dinic_Reverse dinic(n);\n  int s = 0;\n  int t = n - 1;\n  for (int i = 0; i < e; i++)\n  {\n    int a, b;\n    ;\n    cin >> a >> b;\n    a--;\n    b--;\n    dinic.add_edge(a, b, 1, 0);\n  }\n  int flow = dinic.max_flow(s, t);\n  for (int i = 0; i < q; i++)\n  {\n    int m, a, b;\n    cin >> m >> a >> b;\n    a--;\n    b--;\n    if (m == 1)\n    {\n      dinic.add_edge(a, b, 1, 0);\n      flow += dinic.max_flow(s, t, 1);\n    }\n    else\n    {\n      flow -= dinic.back_edge(a, b, s, t);\n      flow -= dinic.back_edge(b, a, s, t);\n    }\n    cout << flow << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nint INF = 1 << 20;\n#define MAX_V 500\n\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G( MAX_V ); // ??°???????????£??\\???????????¨???\nbool used[MAX_V]; // DFS??§?????§??????????????????????????°\n\t\t\t\t  // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge( int from, int to, int cap ) {\n\tedge a;\n\ta.to = to;\n\ta.cap = cap;\n\ta.rev = G[to].size(); \n\tedge b;\n\tb.to = from;\n\tb.cap = cap;\n\tb.rev = G[from].size();\n\tG[from].push_back( a );\n\tG[to].push_back( b );\n}\n\nvoid del_edge( int from, int to ) {\n\tauto ite = G[from].begin();\n\twhile( ite < G[from].end() ) {\n\t\tif( ( *ite ).to == to ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n\n\n\tite = G[to].begin();\n\twhile( ite < G[to].end() ) {\n\t\t//cout << to << \" \" << ( *ite ).to << \" \" << ( *ite ).cap << endl;\n\t\tif( ( *ite ).to == from ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs( int v, int t, int f ) {\n\tif( v == t ) return f;\n\tused[v] = true;\n\tfor( int i = 0; i < G[v].size(); i++ ) {\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0 ) {\n\t\t\tint d = dfs( e.to, t, min( f, e.cap ) );\n\t\t\tif( d > 0 ) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow( int s, int t ) {\n\tfor( size_t i = 0; i < MAX_V; i++ ) {\n\t\tused[i] = false;\n\t}\n\tint flow = 0;\n\tfor( ;;) {\n\t\tmemset( used, 0, sizeof( used ) );\n\t\tint f = dfs( s, t, INF );\n\t\tif( f == 0 ) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n\tlong long int N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge( F, T, 1 );\n\t\t//add_edge( T, F, 1 );\n\t}\n\tfor( size_t i = 0; i < Q; i++ ) {\n\t\tlong long int M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif( M == 1 ) {\n\t\t\tadd_edge( A, B, 1 );\n\t\t\t//add_edge( B, A, 1 );\n\t\t} else {\n\t\t\tdel_edge( A, B );\n\t\t}\n\t\tauto memo = G;\n\t\tcout << max_flow( 0, N - 1 ) << endl;\n\t\tG = memo;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(ok[j][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(inti = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = used[i][j] != used[j][i];\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\nusing namespace std;\n\n#define init_vec(v,n) v.clear();v.resize(n);\n#define vec_del(v,c) v.erase(remove(v.begin(),v.end(),c),v.end());\nint N,E,Q;\nvector<vector<int> > edge;\nvector<vector<int> > flow;\nint f;\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n\n  for(int i=0;i<edge[from].size();i++){\n    int to_ = edge[from][i];\n    if(used[to_])continue;\n    if(flow[from][to_]==1)continue;\n    if(dfs_(to_,to)){\n      add_flow(from,to_);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  init_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(b);\n  edge[b].push_back(a);\n}\n\nbool cut_flow(int from,int to){\n  if(dfs(from,1)&&dfs(N,to)){\n    f--;\n    return true;\n  }else{\n    return true;\n  }\n}\n\nvoid cut_edge(int a,int b){\n  vec_del(edge[a],b);\n  vec_del(edge[b],a);\n  if(flow[a][b]==1){\n    if(!cut_flow(a,b)){\n      cerr<<\"cut_err:\"<<a<<\" \"<<b<<endl;\n      assert(0);\n    }\n  }else if(flow[b][a]==1){\n    if(!cut_flow(b,a)){\n      cerr<<\"cut_err:\"<<b<<\" \"<<a<<endl;\n      assert(0);\n    }\n  }\n\n  flow[a][b]=0;\n  flow[b][a]=0;\n}\n\n\nint input(){\n  cin>>N>>E>>Q;\n  f=0;\n  init_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    init_vec(flow[i],N+1);\n  }\n  init_vec(edge,N+1);\n  //cout<<\"edge\"<<endl;\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  //cout<<\"dfs\"<<endl;\n  while(dfs(1,N))f++;\n  //cout<<\"fin input:\"<<f<<endl;\n  return 0;\n}\n\nint solve(int m,int a,int  b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\nvoid query(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    //cout<<\"query:\"<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  query();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int V = 500;\nconstexpr int INF = 1000000000;\ntypedef int Weight;\nstruct Edge{\n  \tint src, dest;\n  \tint cap, rev;\n  \tWeight weight;\n  \tbool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n//FordFulkerson(O(F|E|))-----------------------------------------------------------\n//???????????°|V|?????????\nbool add_edge_impl(Graph &g, int src, int dest) {\n  for (size_t i = 0; i < g[src].size(); ++i) {\n    if (g[src][i].dest == dest) {\n      g[src][i].weight = 0;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid add_edge(Graph &g, int src, int dest) {\n  if (!add_edge_impl(g, src, dest)) {\n    g[src].push_back((Edge){src, dest, 1, (int)g[dest].size(), 0});\n    g[dest].push_back((Edge){dest, src, 1, (int)g[src].size() - 1, 0});\n  } else {\n    add_edge_impl(g, dest, src);\n  }\n}\n\nvoid remove_edge_impl(Graph &g, int src, int dest) {\n  for (size_t i = 0; i < g[src].size(); ++i) {\n    if (g[src][i].dest == dest) g[src][i].weight = 1;\n  }\n}\n\nvoid remove_edge(Graph &g, int src, int dest) {\n  remove_edge_impl(g, src, dest);\n  remove_edge_impl(g, dest, src);\n}\n\nbool visited[V];\nint dfs(Graph &g, int v, int t, int f) {\n\tif (v == t) return f;\n\tvisited[v] = true;\n\tREP(i, g[v].size()) {\n\t\tEdge& e = g[v][i];\n    if (e.weight == 1) continue;\n\t\tif (!visited[e.dest] && e.cap > 0) {\n\t\t\tint d = dfs(g, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(Graph &g, int s, int t) {\n\tint flow = 0;\n\tfor(;;) {\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tint f = dfs(g, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint main() {\n  int n,e,q;\n  cin>>n>>e>>q;\n  Graph g(V);\n  REP(i,e) {\n    int f,t;\n    cin>>f>>t;\n    --f;--t;\n    add_edge(g, f, t);\n  }\n  int flow = 0;\n  REP(i,q) {\n    int m, a, b;\n    cin>>m>>a>>b;\n    --a;--b;\n    if (m==1) {\n      add_edge(g, a, b);\n      flow += max_flow(g, 0, n-1);\n      cout << flow << endl;\n    } else {\n      remove_edge(g, a, b);\n      REP(j,n) {\n        for (auto& e:g[j]) e.cap = 1;\n      }\n      flow = max_flow(g, 0, n-1);\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#define N 501\n#define inf 1000000000\nusing namespace std;\n \nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  for(int i = 0 ;i < n ; i++){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n        flow[now][next]+=tmp;\n        flow[next][now]=-flow[now][next];\n        return tmp;\n      }\n    }\n  }\n  return 0;\n}\n \nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  for(int i = 0 ; i < n ; i++)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    for(int i = 0 ; i < n ; i++)vis[i]=false;\n  }\n  return ret;\n}\n \nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n        flow[now][next]=flow[next][now]=0;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n \nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n        flow[now][next]+=1;\n        flow[next][now]=-flow[now][next];\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n \n \nint main(void){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n        cap[i][j] = 0;\n        flow[i][j] = 0;\n      }\n    }\n \n    for(int i = 0 ; i < e ; i++){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    for(int i = 0 ; i < q ; i++){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n        cap[from][to]=cap[to][from]=1;\n        tmp = maxFlow(n,s,t);\n        cout << prev+tmp << endl;\n        prev=prev+tmp;\n      }else if (flow[from][to] == 0){\n        cap[from][to]=cap[to][from]=0;\n        cout << prev << endl;\n      }else {//delete\n        if (flow[from][to] < 0)swap(from,to);\n        cap[from][to]=cap[to][from]=0;\n        flow[from][to]=flow[to][from]=0;\n        for(int j = 0 ; j < n ; j++)vis[i] = false;\n        tmp=dfs2(n,from,to);\n        if (tmp != 0){\n          cout << prev << endl;\n          prev=prev;//keep\n        }else {\n          for(int j = 0 ;j < n ; j++)vis[j] = false;\n          dfs(n,from,s);\n          for(int j = 0 ; j < n; j++)vis[j] = false;\n          dfs(n,t,to);\n          cout << prev-1 << endl;\n          prev=prev-1;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tflow(n, a);\n\t\t\t\tflow(b, 1);\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tflow(n, b);\n\t\t\t\tflow(a, 1);\t\t\n\t\t\t}\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1){\n      g[a][b]=g[b][a]=1;\n      flow+=max_flow(0,n-1);\n    }\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(check(a,b))check(b,a);\n\telse{\n\t  flow--;\t\n\t  check(n-1,b);\n\t  check(a,0);\n\t}\n\tg[a][b]=g[b][a]=0;\n      }\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint n, e, q;\nint x[1000], s[1000], t[1000];\nset<P> saw;\nint pre = 0;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        if(s > t) swap(s,t);\n        s--; t--;\n        saw.insert(P(s,t));\n        add_edge(s,t,1);\n    }\n    rep(i,q){\n        cin >> x[i] >> s[i] >> t[i];\n        s[i]--; t[i]--;\n        if(s[i] > t[i]) swap(s[i],t[i]);\n        if(saw.count(P(s[i],t[i])) == 0){\n            add_edge(s[i],t[i],0);\n            saw.insert(P(s[i],t[i]));\n        }\n    }\n    pre = max_flow(0,n-1);\n    rep(i,q){\n        if(x[i] == 1){\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 1;\n                    G[t[i]][rev].cap = 1;\n                }\n            }\n            memset(used,0,sizeof(used));\n            pre = dfs(0,n-1,1)+pre;\n        } else{\n            int div = 0;\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                div = G[s[i]][j].cap;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 0;\n                    G[t[i]][rev].cap = 0;\n                }\n            }\n            memset(used,0,sizeof(used));\n            if(div == 0){\n                if(dfs(s[i],t[i],1) == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,t[i],1);\n                    memset(used,0,sizeof(used));\n                    dfs(s[i],0,1);\n                    pre--;\n                }\n            } else if(div == 2){\n                if(dfs(t[i],s[i],1) == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,s[i],1);\n                    memset(used,0,sizeof(used));\n                    dfs(t[i],0,1);\n                    pre--;\n                }\n            }\n        }\n        cout << pre << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <climits>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef vector<vector<int> > G;\n\nint flow(G &g, int s, int d, bool one = false){\n  int n = g.size();\n  int ans = 0;\n\n  if(s == d) return 0;\n\n  while(true){\n    vector<int> prevs(n,-1);\n    queue<int> q;\n    bool ok = false;\n\n    prevs[s]=n;\n    q.push(s);\n    while(!q.empty()){\n      int now = q.front();\n      q.pop();\n      if(now == d){\n        ok = true;\n        break;\n      }\n      for(int i=0;i<n;i++){\n        if(g[now][i] > (one ? 1 : 0)){\n          /*\n          if(one){\n            if((s == 0 || d == 0) && i == n - 1)\n              continue;\n            if((s == n - 1 || d == n - 1) && i == 0)\n              continue;\n          }\n          */\n          if(prevs[i]==-1){\n            prevs[i]=now;\n            q.push(i);\n          }\n        }\n      }\n    }\n\n    if(!ok) return ans;\n\n    int f = 100000;\n    int pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      f = min(f,g[pos2][pos]);\n      pos = pos2;\n    }\n    if(one) f = 1;\n    pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      g[pos2][pos]-=f;\n      g[pos][pos2]+=f;\n      pos = pos2;\n    }\n    ans += f;\n    if(one) return ans;\n  }\n}\n\nint main(){\n  int n, e, q;\n  scanf(\"%d%d%d\", &n, &e, &q);\n  vector<vector<int> > g(n, vector<int>(n, 0));\n\n  REP(i, e){\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a-1][b-1] = g[b-1][a-1] = 1;\n  }\n\n  int ans = flow(g, 0, n-1);\n\n  REP(i, q){\n    int m, a, b;\n    scanf(\"%d%d%d\", &m, &a, &b);\n\n    //REP(i,n){REP(j,n)printf(\"%d \", g[i][j]); puts(\"\");}\n    //printf(\"%d %d %d : %d %d : %d\\n\", a - 1, b - 1, m,\n    // g[a-1][b-1], g[b-1][a-1], ans);\n\n    if(m == 1){\n      g[a-1][b-1] = 1;\n      g[b-1][a-1] = 1;\n      ans += flow(g, 0, n-1);\n    }else{\n      if(g[a-1][b-1] != 0 && g[b-1][a-1] != 0){\n        g[a-1][b-1] = g[b-1][a-1] = 0;\n      }else{\n        if((a - 1 == 0 && b - 1 == n - 1) ||\n           (a - 1 == n - 1 && b - 1 == 0)){\n          ans--;\n          g[a-1][b-1] = g[b-1][a-1] = 0;\n        }else{\n          ans--;\n          int tmp = g[a-1][b-1];\n          g[a-1][b-1] = g[b-1][a-1] = 0;\n          if(tmp == 0){\n            int f3 = flow(g, a-1, 0,   true);\n            int f1 = flow(g, n-1, b-1, true);\n            // printf(\"0: f1 = %d  f3 = %d\\n\", f1, f3);\n          }else{\n            int f3 = flow(g, b-1, 0,   true);\n            int f1 = flow(g, n-1, a-1, true);\n            // printf(\"1: f1 = %d  f3 = %d\\n\", f1, f3);\n          }\n          // REP(i,n){REP(j,n)printf(\"%d \", g[i][j]); puts(\"\");}\n          ans += flow(g, 0, n-1);\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t}\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,0,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// Ü¾ØçêÄ¢È¢©ÂgíêÄ¢È¢m[hÖÌJÚ\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\tbool ok=false;\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\t// eÊðfromÌûüÉ½­í¦é\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t// ¡ñÏXðsÁ½\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\t// eÊª0æèå«¢Æ«\n\t\t\tif(e.cap>0){\n\t\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\t// 1Ìt[ª¬¹½ê\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]==e.to)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t// dÌflowð¬·\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// t[ª¬¹È¢ÈçA¡ñèµ½ûüð³ø\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nconstexpr int INF = 1 << 30;\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    vector<map<int, int>> c(N);\n    auto addEdge = [&](const int u, const int v) -> void { c[u][v] = c[v][u] = 1; };\n    auto cutEdge = [&](const int u, const int v) -> void { c[u].erase(v), c[v].erase(u); };\n    auto flow = [&](const int s, const int t, const int limit) {\n        vector<bool> used(N, false);\n        auto dfs = fix([&](auto&& self, const int s, const int t, const int f) -> int {\n            if (s == t) { return f; }\n            used[s] = true;\n            for (auto& e : c[s]) {\n                if (used[e.first] or e.second == 0) { continue; }\n                const int res = min(f, e.second);\n                const int d = self(self, e.first, t, res);\n                if (d == 0) { continue; }\n                return e.second -= d, c[e.first][s] += d, d;\n            }\n            return 0;\n        });\n        for (int flow = 0; flow < limit;) {\n            fill(used.begin(), used.end(), false);\n            const int f = dfs(s, t, limit - flow);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n        return limit;\n    };\n    for (int i = 0, F, T; i < E; i++) {\n        cin >> F >> T;\n        addEdge(F - 1, T - 1);\n    }\n    int ans = flow(0, N - 1, INF);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            addEdge(A, B);\n        } else {\n            const int cap = c[A][B];\n            cutEdge(A, B);\n            if (cap == 2) { swap(A, B); }\n            if (cap != 1 and flow(A, B, 1) == 0) { ans--, flow(A, 0, 1), flow(N - 1, B, 1); }\n        }\n        cout << (ans += flow(0, N - 1, 1)) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n\tflow[now][next]+=1;\n\tflow[next][now]=-flow[now][next];\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\t//tmp=dfs2(n,from,to);\n\ttmp=fordFulkerson(n,to,from,inf);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1){\n      g[a][b]=g[b][a]=1;\n      flow+=max_flow(0,n-1);\n    }\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b)){\n\t  flow--;\t\n\t  check(n-1,b);\n\t  check(a,0);\n\t}\n\tg[a][b]=g[b][a]=0;\n      }\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\nconst int MAX_V = 1000;\nconst int INF = 1 << 25;\n\nint V;\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, 0, int(G[from].size() - 1) });\n}\n\nvoid add_edge2(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, cap, int(G[from].size() - 1) });\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(edge& e : G[v]) {\n\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim) {\n\tint flow = 0;\n\twhile(1) {\n\t\tfill(used, used + V, false);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0 || flow == lim) return flow;\n\t\tflow += f;\n\t\tlim -= f;\n\t}\n\treturn -1;\n}\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nbool ex[1000][1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tint S = N, T = N + 1;\n\tV = N + 2;\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tadd_edge2(a, b, 1);\n\t\tex[a][b] = ex[b][a] = true;\n\t}\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tif(!ex[A[i]][B[i]]) {\n\t\t\tadd_edge2(A[i], B[i], 0);\n\t\t\tex[A[i]][B[i]] = ex[B[i]][A[i]] = true;\n\t\t}\n\t}\n\tadd_edge(S, 0, 1000000);\n\tadd_edge(N - 1, T, 1000000);\n\n\tint f = max_flow(S, T, INF);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tf += max_flow(S, T, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\tint c = e.cap;\n\t\t\t\t\te.cap = G[v][e.rev].cap = 0;\n\t\t\t\t\tif(c == 0) {// u -> v\n\t\t\t\t\t\tif(max_flow(u, v, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(u, v, 1) != 0);\n\t\t\t\t\t\t\t//assert(max_flow(u, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, v, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 2) {// v -> u\n\t\t\t\t\t\tif(max_flow(v, u, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(v, u, 1) != 0);\n\t\t\t\t\t\t\t//assert(max_flow(v, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, u, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <cstring>\nusing namespace std;\n\n#define MAX_V 504\n#define INF 2147483647\n\nmap<int,int> G[MAX_V];\nchar used[MAX_V];\n\nvoid add_edge(int f, int t){\n\tG[f].insert(make_pair(t, 1));\n\tG[t].insert(make_pair(f, 1));\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t){ return f; }\n\tused[v] = 1;\n\tfor(map<int,int>::iterator it = G[v].begin(); it != G[v].end(); ++it){\n\t\tif(!used[it->first] && it->second > 0){\n\t\t\tint d = dfs(it->first, t, min(f, it->second));\n\t\t\tif(d > 0){\n\t\t\t\tit->second -= d;\n\t\t\t\tG[it->first][v] += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim = INF){\n\tint flow = 0;\n\tfor(; lim > 0;){\n\t\tmemset(used, 0, sizeof used);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0){ break; }\n\t\tflow += f;\n\t\tlim -= f;\n\t}\n\treturn flow;\n}\n\n\nint decrease(int f, int t, int n){\n\tif(G[f][t] != 0 || max_flow(f, t, 1) != 0){\n\t\treturn 0;\n\t}\n\tmax_flow(f, 1, 1);\n\tmax_flow(n, t, 1);\n\treturn 1;\n}\n\n\nint main(){\n\tint n, e, q, f, t, m;\n\tscanf(\"%d%d%d\", &n, &e, &q);\n\tfor(int i = 0; i < e; ++i){\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tadd_edge(f, t);\n\t}\n\n\tint flow = max_flow(1, n);\n\tfor(int i = 0; i < q; ++i){\n\t\tscanf(\"%d%d%d\", &m, &f, &t);\n\t\tif(m == 1){\n\t\t\tadd_edge(f, t);\n\t\t\tflow += max_flow(1, n, 1);\n\t\t}\n\t\telse{\n\t\t\tflow -= decrease(f, t, n) + decrease(t, f, n);\n\t\t\tG[f].erase(t);\n\t\t\tG[t].erase(f);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", flow);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 555;\nconst int INF = 1000000000;\n\nint n,e,q;\n\n\nint flow[N][N];\nint edge[N][N];\n\nbool init(){\n\trep(i,N)rep(j,N)flow[i][j]=edge[i][j]=0;\n\tcin>>n>>e>>q;\n\trep(i,e){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tedge[a][b]=1;\n\t\tedge[b][a]=1;\n\t}\n}\n\nint update_edge(int a,int b,int c){\n\tint ret = 0;\n\tif(a==1){\n\t\tedge[b][c]++;\n\t\tedge[c][b]++;\n\t}\n\tif(a==2){\n\t\tedge[b][c]--;\n\t\tedge[c][b]--;\n\t\tret = max(ret, flow[b][c]-edge[b][c]);\n\t\tret = max(ret, flow[c][b]-edge[c][b]);\n\t\tflow[b][c] = min(flow[b][c], edge[b][c]);\n\t\tflow[c][b] = min(flow[c][b], edge[c][b]);\n\t}\n\treturn ret;\n}\n\nvoid printflow(){\n\tprintf(\"flow:\\n\");\n\trep(i,n+2){\n\t\trep(j,n+2){\n\t\t\tprintf(\"%2d \",flow[i][j]);\n\t\t}puts(\"\");\n\t}\n\tprintf(\"edge\\n\");\n\trep(i,n+2){\n\t\trep(j,n+2){\n\t\t\tif(edge[i][j]==INF)printf(\"oo \");\n\t\t\telse printf(\"%2d \",edge[i][j]);\n\t\t}puts(\"\");\n\t}puts(\"\\n\");\n}\nint visit[N];\nint flowrec(int pos, int en, int f){\n\tif(f==0)return 0;\n\tif(visit[pos]==1)return 0;\n\tvisit[pos]=1;\n\t\n\tif(pos==en){\n\t\t//printf(\"flow %d\\n\",pos);\n\t\treturn f;\n\t}\n\t\n\trep(i,N){\n\t\tint f1 = edge[pos][i] - flow[pos][i];\n\t\tint f2 = flow[i][pos];\n\t\t\n\t\tif(f1!=0 && f2==0){\n\t\t\tint val = flowrec(i, en, min(f,f1));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"flow %d %d\\n\",pos,i);\n\t\t\t\tflow[pos][i]+=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t\tif(f2!=0){\n\t\t\tint val = flowrec(i, en, min(f,f2));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"rflow %d %d\\n\",i,pos);\n\t\t\t\tflow[i][pos]-=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flowing(int st, int en, int mix = INF){\n\tint ret = 0;\n\twhile(1){\n\t\trep(i,N)visit[i]=0;\n\t\t\n\t\tint val = flowrec(st, en, mix);\n\t\tif(val==0)break;\n\t\t\n\t\t//printf(\"vvvval = %d\\n\",val);\n\t\t//printflow();\n\t\tret += val;\n\t\t\n\t\tif(mix==1)break;\n\t}\n\treturn ret;\n}\n\nint reflowrec(int pos,int en,int f){\n\tif(visit[pos]==1)return 0;\n\tvisit[pos]=1;\n\t\n\tif(pos==en)return f;\n\t\n\trep(i,N){\n\t\tint f1 = flow[i][pos];\n\t\tif(f1!=0){\n\t\t\tint val = reflowrec(i, en, min(f,f1));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"recrec %d %d %d\\n\",i,pos,val);\n\t\t\t\tflow[i][pos]-=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nvoid reflowing(bool bc, int st, int en, int b, int c){\n\tif(bc){\n\t\t//printf(\"flow[%d][%d] %d\\n\",b,c,flow[b][c]);\n\t\tint val = flowing(b,c,1);\n\t\t\n\t\tif(val==0){\n\t\t\t//printf(\"* val=0\\n\");\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(b, st, 1);\n\t\t\t\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(en, c, 1);\n\t\t}\n\t}else{\n\t\t//printf(\"flow[%d][%d] %d\\n\",c,b,flow[c][b]);\n\t\tint val = flowing(c,b,1);\n\t\t\n\t\tif(val==0){\n\t\t\t//printf(\"* val=0\\n\");\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(c, st, 1);\n\t\t\t\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(en, b, 1);\n\t\t}\n\t}\n}\n\nvoid setflow(){\n\tedge[0][1]=INF;\n\tedge[n][n+1]=INF;\n}\nvoid solve(){\n\t\n\tsetflow();\n\tint st = 0;\n\tint en = n+1;\n\t\n\tint retsum = 0;\n\t\n\tretsum += flowing(st, en);\n\t//printflow();\n\t\n\trep(i,q){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t\n\t\tbool bc = flow[b][c]>0;\n\t\t\n\t\tint dec = update_edge(a,b,c);\n\t\tretsum -= dec;\n\t\t\n\t\tif(a==1){\n\t\t\tretsum += flowing(st, en);\n\t\t}\n\t\tif(a==2){\n\t\t\tif(dec!=0){\n\t\t\t\t//printf(\"dec!=0\\n\");\n\t\t\t\treflowing(bc, st, en, b, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",flow[n][n+1]);\n\t\t//printflow();\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<class T>\nstruct dinic {\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n        bool isrev;\n    };\n\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n\n    void bfs(int s) {\n        level.assign(G.size(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(que.size()) {\n            int v = que.front(); que.pop();\n            for(auto i: G[v]) {\n                if(i.cap > 0 && level[i.to] < 0) {\n                    level[i.to] = level[v] + 1;\n                    que.push(i.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, const int t, T f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(ll)G[v].size(); ++i) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    dinic() {}\n    dinic(int n) : G(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back({to, cap, (int)G[to].size(), false});\n        G[to].push_back({from, 0, (int)G[from].size()-1, true});\n    }\n\n    // sからtへ流量fを流す\n    T maxflow(int s, int t, T f = 1LL<<30) {\n        T flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(G.size(), 0);\n            T tmp;\n            while((tmp = dfs(s, t, f)) > 0) flow += tmp;\n        }\n    }\n    // sからtへ1流す\n    T flow(int s, int t) {\n        bfs(s);\n        if(level[t] < 0) return 0;\n        iter.assign(G.size(), 0);\n        return dfs(s, t, 1);\n    }\n\n    // 始点，終点tのフローで辺e=(from,to)の容量を1増やしたときの最大流の変化\n    // 並列辺はたぶんバグる\n    T add(int from, int to, int s, int t) {\n        for(auto &e: G[from]) {\n            if(e.to == to && !e.isrev) {\n                e.cap++;\n                break;\n            }\n        }\n        return flow(s, t);\n    }\n    // 始点s，終点tのフローで辺e=(from,to)の容量を1減らしたときの最大流の変化\n    // 並列辺はたぶんバグる\n    T sub(int from, int to, int s, int t) {\n        for(auto &e: G[from]) {\n            if(e.to == to && !e.isrev) {\n                T diff = 0;\n                // 辺(from,to)で容量いっぱいに流れている\n                if(e.cap == 0) {\n                    // 残余グラフでfrom→toのパスがない\n                    if(flow(from, to) == 0) {\n                        flow(t, to);\n                        flow(from, s);\n                        diff = -1;\n                    }\n                    G[e.to][e.rev].cap--;\n                } else {\n                    e.cap--;\n                }\n                return diff;\n            }\n        }\n        assert(false); // 存在しない辺を減らそうとした\n    }\n\n    friend ostream &operator <<(ostream& out, const dinic& a){\n        out << endl;\n        for(int i = 0; i < (int)a.G.size(); i++) {\n            for(auto &e : a.G[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = a.G[e.to][e.rev];\n                out << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n        return out;\n    }\n};\n\nint main(void) {\n    ll n, m, q;\n    cin >> n >> m >> q;\n    dinic<ll> flow(n);\n    set<PII> st;\n    REP(i, m) {\n        ll a, b;\n        cin >> a >> b;\n        a--, b--;\n        if(a > b) swap(a, b);\n        st.insert(PII(a, b));\n        flow.add_edge(a, b, 1);\n        flow.add_edge(b, a, 1);\n    }\n    vector<ll> t(q), x(q), y(q);\n    REP(i, q) {\n        cin >> t[i] >> x[i] >> y[i];\n        x[i]--, y[i]--;\n        if(x[i] > y[i]) swap(x[i], y[i]);\n        if(st.find(PII(x[i], y[i])) == st.end()) {\n            st.insert(PII(x[i], y[i]));\n            flow.add_edge(x[i], y[i], 0);\n            flow.add_edge(y[i], x[i], 0);\n        }\n    }\n\n    ll ret = flow.maxflow(0, n-1);\n    REP(i, q) {\n        ll type = t[i], a = x[i], b = y[i];   \n        if(type == 1) {\n            ret += flow.add(a, b, 0, n-1);\n            ret += flow.add(b, a, 0, n-1);\n        } else {\n            ret += flow.sub(a, b, 0, n-1);\n            ret += flow.sub(b, a, 0, n-1);\n        }\n        cout << ret << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1<<28;\nstruct Edge {\n  int v;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int MAXN = 555;\n\nint N, E, Q;\nGraph G;\nint vis[MAXN];\nint cap[MAXN][MAXN];\nint es[MAXN][MAXN];\n\nvoid addEdge(int from, int to) {\n  G[from].push_back((Edge){to});\n  G[to].push_back((Edge){from});\n  cap[from][to] = cap[to][from] = 1;\n  es[from][to] = G[from].size() - 1;\n  es[to][from] = G[to].size() - 1;\n}\n\nvoid eraseEdge(int from, int to) {\n  G[from].erase(G[from].begin() + es[from][to]);\n  G[to].erase(G[to].begin() + es[to][from]);\n}\n\nint dfs(int v, int t, int f) {\n  vis[v] = true;\n  if (v == t) return f;\n  for (int i = 0; i < G[v].size(); ++i) {\n    Edge &e = G[v][i];\n    if (vis[e.v]) continue;\n    if (cap[v][e.v] == 0) continue;\n    int d = dfs(e.v, t, min(f, cap[v][e.v]));\n    if (d) {\n      cap[v][e.v] -= d;\n      cap[e.v][v] += d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint oneFlow(int s, int t) {\n  memset(vis, 0, sizeof(vis));\n  return dfs(s, t, 1);\n}\n\nint maxFlow(int s, int t) {\n  int f = 0;\n  while (1) {\n    memset(vis, 0, sizeof(vis));\n    int d = dfs(s, t, INF);\n    if (d == 0) return f;\n    f += d;\n  }\n}\n\nint main() {\n  while (cin >> N >> E >> Q) {\n    G = Graph(N);\n    while (E--) {\n      int F, T;\n      cin >> F >> T;\n      --F; --T;\n      addEdge(F, T);\n    }\n    int f = maxFlow(0, N-1);\n    while (Q--) {\n      int M, A, B;\n      cin >> M >> A >> B;\n      --A; --B;\n      if (M == 1) {\n        addEdge(A, B);\n        f += oneFlow(0, N-1);\n      } else {\n        int s, t;\n        if (cap[A][B] == 0) {\n          s = A; t = B;\n        } else if (cap[B][A] == 0) {\n          s = B; t = A;\n        } else {\n          s = t = -1;\n        }\n        eraseEdge(A, B);\n        if (s != -1) {\n          --f;\n          if (oneFlow(s, t) == 0) {\n            if (f) {\n              oneFlow(N-1, 0);\n              oneFlow(s, t);\n            } else {\n              for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < G[i].size(); ++j) {\n                  cap[i][G[i][j].v] = 1;\n                }\n              }\n            }\n          } else {\n            ++f;\n          }\n        }\n      }\n      cout << f << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(ok[s][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\tok[s][i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = used[i][j] != used[j][i];\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n\tflow[now][next]+=1;\n\tflow[next][now]=-flow[now][next];\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\tint fordFulkerson(const int n,const int t,int now,int fl);\n\t//tmp=dfs2(n,from,to);\n\ttmp=fordFulkerson(n,to,from,1);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 500; // TODO:initialize\nconst int F_INF = 19191919; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint n;\n\nvoid back(int s, int g, int val)\n{\n    vector<int> par(n,-1);\n    queue<int> que;\n    par[s]=s;\n    que.push(s);\n    while(!que.empty())\n    {\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size())\n        {\n            int nx = G[v][i].to;\n            if(G[v][i].cap==val && G[nx][G[v][i].rev].cap==abs(val-2) && par[nx]==-1)\n            {\n                que.push(nx);\n                par[nx] = v;\n            }\n        }\n    }\n\n    int now = g;\n    while(now!=s)\n    {\n        int nx = par[now];\n        rep(i,G[now].size())\n        {\n            if(G[now][i].to==nx)\n            {\n                G[now][i].cap = 1;\n                G[nx][G[now][i].rev].cap = 1;\n\n                now = nx;\n                break;\n            }\n        }\n        assert(now==nx);\n    }\n}\n\nint main()\n{\n    int e,q;\n    scanf(\" %d %d %d\", &n, &e, &q);\n    rep(i,e)\n    {\n        int f,t;\n        scanf(\" %d %d\", &f, &t);\n        --f;\n        --t;\n        add_edge(f,t,1);\n    }\n\n    int f = max_flow(0,n-1);\n    while(q--)\n    {\n        int m,a,b;\n        scanf(\" %d %d %d\", &m, &a, &b);\n        --a;\n        --b;\n        if(m==1)\n        {\n            bool found = false;\n            rep(i,G[a].size())if(G[a][i].to==b)\n            {\n                G[a][i].cap = 1;\n                G[b][G[a][i].rev].cap = 1;\n                assert(G[b][G[a][i].rev].to == a);\n                found = true;\n                break;\n            }\n\n            if(!found) add_edge(a,b,1);\n            f += max_flow(0,n-1);\n        }\n        else\n        {\n            int id = -1;\n            rep(i,G[a].size())\n            {\n                if(G[a][i].to==b)\n                {\n                    id = i;\n                    int CAP = G[a][i].cap;\n                    if(CAP==2)\n                    {\n                        id = G[a][i].rev;\n                        swap(a,b);\n                    }\n                    break;\n                }\n            }\n\n            assert(G[b][G[a][id].rev].to == a);\n            assert(id!=-1);\n            if(G[a][id].cap==0)\n            {\n                --f;\n                back(a,0,2);\n                back(b,n-1,0);\n            }\n            G[a][id].cap = 0;\n            G[b][G[a][id].rev].cap = 0;\n            f += max_flow(0,n-1);\n        }\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <functional>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntemplate <typename Weight>\nstruct MaxFlow{\n\tstruct Edge{\n\t\tint v;\n\t\tWeight w;\n\t\tint r;\n\t\tEdge(int v, Weight w,int r=0):v(v),w(w),r(r){}\n\t};\n\ttypedef vector< vector<Edge> > Graph;\n\tint n, source, sink;\n\tGraph g;\n\tWeight flow;\n\tMaxFlow(int n=0, int s=0, int t=0):n(n), g(n), flow(0), source(s), sink(t){\n\t\t\n\t}\n\t\n\tvoid add_edge(int u, int v, Weight cap, Weight revcap=0){\n\t\tg[u].emplace_back(v,cap,g[v].size());\n\t\tg[v].emplace_back(u,revcap,g[u].size()-1);\n\t}\n\tvoid rem_edge(int u,int v, Weight cap){\n\t\tfor(auto &e : g[u])if(e.v == v){\n\t\t\tWeight t = min(cap, e.w);\n\t\t\te.w -= t;\n\t\t\tcap -= t;\n\t\t\tif(cap == 0) return;\n\t\t}\n\t\tWeight t = cap;\n\t\tcap -= maxflow_dinic(u, v, cap);\n\t\tif(cap){\n\t\t\tmaxflow_dinic(sink, v, cap);\n\t\t\tmaxflow_dinic(u, source, cap);\n\t\t\tflow -= cap;\n\t\t}\n\t\trem_edge(v, u, t);\n\t}\n\t\n\tWeight maxflow_dinic(int source, int sink, Weight limit){\n\t\tif(source == sink) return limit;\n\t\tconst Weight inf = numeric_limits<Weight>::max();\n\t\tWeight flow = 0;\n\t\twhile(true){\n\t\t\tvector<int> level(n, -1);\n\t\t\tqueue<int> q;\n\t\t\tlevel[source] = 0;\n\t\t\tq.push(source);\n\t\t\twhile(!q.empty()){\n\t\t\t\tconst int u = q.front(); q.pop();\n\t\t\t\tfor(const auto &e : g[u]){\n\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\tif(e.w <= 0 || level[v] >= 0){ continue; }\n\t\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(level[sink] < 0){ break; }\n\t\t\tvector<size_t> itr(n, 0);\n\t\t\twhile(true){\n\t\t\t\tfunction<Weight(int, Weight)> dfs =\n\t\t\t\t\t[&](int u, Weight limit) -> Weight{\n\t\t\t\t\t\tif(u == sink) return limit;\n\t\t\t\t\t\tfor(; itr[u] < g[u].size(); ++itr[u]){\n\t\t\t\t\t\t\tauto &e = g[u][itr[u]];\n\t\t\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\t\t\tif(e.w <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\t\tconst Weight diff = dfs(v, min(e.w, limit));\n\t\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\t\te.w -= diff;\n\t\t\t\t\t\t\t\tg[v][e.r].w += diff;\n\t\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t};\n\t\t\t\tconst auto f = dfs(source, inf);\n\t\t\t\tif(f <= 0){ break; }\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tWeight maxflow(){\n\t\treturn flow += maxflow_dinic(source, sink, numeric_limits<Weight>::max());\n\t}\n};\n\nint N, E, Q;\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tMaxFlow<int> g(N, 0, N-1);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg.add_edge(u, v, 1, 1);\n\t}\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v; u--; v--;\n\t\tif(f == 1){\n\t\t\tg.add_edge(u, v, 1, 1);\n\t\t}else{\n\t\t\tg.rem_edge(u, v, 1);\n\t\t\tg.rem_edge(v, u, 1);\n\t\t}\n\t\tcout << g.maxflow() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint V,E;\nint G[501][501]; // テ」ツつーテ」ツδゥテ」ツδ陛」ツ?ョテゥツ堋」テヲツ篠・テ」ツδェテ」ツつケテ」ツδ暗ィツ。ツィテァツ渉セ\nvector<int> used; // DFSテ」ツ?ァテ」ツ?凖」ツ?ァテ」ツ?ォティツェツソテ」ツ?ケテ」ツ?淌」ツつ嘉」ツδ陛」ツδゥテ」ツつー\n\n// fromテ」ツ?凝」ツつ液oテ」ツ?クテ・ツ青妥」ツ?凝」ツ??・ツョツケテゥツ?縦apテ」ツ?ョティツセツコテ」ツつ津」ツつーテ」ツδゥテ」ツδ陛」ツ?ォティツソツステ・ツ環?」ツ?凖」ツつ?\nvoid add_edge(int from, int to, int cap) {\n    G[from][to] = G[to][from] = cap;\n}\n\n// テ・ツ「ツ療・ツ環?」ツδ妥」ツつケテ」ツつ奪FSテ」ツ?ァテヲツ篠「テ」ツ??\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < V; i++) {\n        auto &cap = G[v][i];\n        if (!used[i] && cap > 0) {\n            int d = dfs(i, t, min(f, cap));\n            if (d > 0) {\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sテ」ツ?凝」ツつ液テ」ツ?クテ」ツ?ョテヲツ慊?・ツ、ツァテヲツオツ?」ツつ津ヲツアツづ」ツつ?」ツつ?\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\n/* one_path check*/\nbool check(int v, int t) {\n\tif (v == t)return true;\n\tused[v] = true;\n\tfor (int i = 0; i < V;i++) {\n\t\tauto& cap = G[v][i];\n\t\tif (!used[i] && cap > 0) {\n\t\t\tif (check(i, t)) {\n\t\t\t\tcap--;\n\t\t\t\tG[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> V >> E;\n    int Q; cin >> Q;\n    for(int i = 0; i < 501;i++){\n        for(int j = 0;j < 501;j++){\n            G[i][j] = 0;\n        }\n    }\n    used.resize(V);\n    for (int i = 0; i < E;i++) {\n        int s, t; cin >> s >> t;\n        s--;t--;\n        add_edge(s, t, 1);\n    }\n    \n    int f = max_flow(0, V - 1);\n    for(int i = 0; i < Q;i++){\n        int M,A,B; cin >> M >> A >> B;\n        A--;B--;\n        if(M == 1){\n            G[A][B] = G[B][A] = 1;\n            fill(used.begin(),used.end(),0);\n            f += dfs(0,V-1,INF);\n        }else{\n            if(G[A][B] == 0 || G[B][A] == 0){\n                int u,v;\n                if(G[A][B] == 0){ u = A; v = B;}\n                else{u = B; v = A;}\n\t\t\t\tfill(used.begin(), used.end(), 0);\n                if(!check(u,v)){\n                    fill(used.begin(),used.end(),0);\n\t\t\t\t\tcheck(u, 0);\n                    fill(used.begin(),used.end(),0);\n\t\t\t\t\tcheck(V - 1, v);\n                    f--;\n                }\n            }\n            G[A][B] = G[B][A] = 0;\n        }\n\t\tcout << f << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a))return 1;\n\t\t\t\tif(!flow(b, 1))return 1;\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b))return 1;\n\t\t\t\tif(!flow(a, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,P> idx;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  idx[P(from,to)].second=G[to].size();\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n  idx[P(from,to)].first=G[from].size()-1;\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int n,e,q,a,b,m;\n  cin>>n>>e>>q;\n  for(int i=0;i<e;i++){\n    cin>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    add_edge(a,b,1);\n  }\n  int ans=max_flow(0,n-1);\n  for(int i=0;i<q;i++){\n    cin>>m>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    if(m==1){\n      add_edge(a,b,1);\n      ans+=max_flow(0,n-1);\n    }else{\n      P x=idx[P(a,b)];\n      int s=-1,t=-1;\n      if(!G[a][x.first].cap)s=a,t=b;\n      if(!G[b][x.second].cap)s=b,t=a;\n      G[a][x.first].cap=0;\n      G[b][x.second].cap=0;\n      if(s>=0&&t>=0){\n\tint r=max_flow(s,t);\n\tif(!r){\n\t  ans--;\n\t  if(s!=0)max_flow(s,0);\n\t  if(t!=n-1)max_flow(n-1,t);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    using T = int;\n    struct Edge\n    {\n        int from, to, revind;\n        T capacity, flow;\n        bool reversed;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    int addEdge(const int from, const int to, const T capacity) { return edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false}), edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true}), edge[from].size() - 1; }\n    T FordFulkerson(const int s, const int t, const T limit = INF<T>)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const T& flow) -> T {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (checked[e.to]) { continue; }\n                const T res = e.capacity - e.flow;\n                if (res == 0) { continue; }\n                const T d = self(self, e.to, min(flow, res));\n                if (d > 0) { return e.flow += min(d, res), edge[e.to][e.revind].flow -= min(d, res), d; }\n            }\n            return 0;\n        });\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const T f = dfs(s, limit);\n            flow += f;\n            if (f == 0 or flow >= limit) { break; }\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\n\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Flow f(N);\n    map<pair<int, int>, pair<int, int>> mp;\n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        F--, T--;\n        mp[{F, T}] = {f.addEdge(F, T, 1), f.addEdge(T, F, 1)};\n    }\n    int flow = f.FordFulkerson(0, N - 1);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            mp[{A, B}] = {f.addEdge(A, B, 1), f.addEdge(B, A, 1)};\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        } else {\n            const auto es = mp[{A, B}];\n            const int i1 = es.first, i2 = es.second, r1 = f.edge[A][i1].revind, r2 = f.edge[B][i2].revind;\n            auto &e1 = f.edge[A][i1], &e2 = f.edge[B][i2], &e3 = f.edge[A][r2], &e4 = f.edge[B][r1];\n            if (e1.flow + e3.flow == 1) {\n                cout << flow << endl;\n                e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n                continue;\n            }\n            flow--;\n            const bool A_B = e1.flow == 1;\n            const int u = A_B ? A : B, v = A_B ? B : A;\n            e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n            f.FordFulkerson(u, 0, 1), f.FordFulkerson(N - 1, v, 1);\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,rev;bool original;};\nvector<edge> graph[vmax];\nint level[vmax],iter[vmax];\n\nvoid add_edge(int from,int to,int cap){\n\tgraph[from].push_back({to,cap,(int)graph[to].size(),true});\n\tgraph[to].push_back({from,0,(int)graph[from].size()-1,false});\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<graph[v].size();i++){\n\t\tedge &e=graph[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d==0) continue;\n\t\t\te.cap-=d;graph[e.to][e.rev].cap+=d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int s,int t){\n\trep(i,vmax) level[i]=-1;\n\tqueue<int> q;\n\tlevel[s]=0,q.push(s);\n\twhile(!q.empty()){\n\t\tint v=q.front();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn level[t]>=0;\n}\n\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(bfs(s,t)){\n\t\trep(i,vmax) iter[i]=0;\n\t\twhile(1){\n\t\t\tint f=dfs(s,t,inf);\n\t\t\tif(f==0) break;\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint flow(int s,int t){\n\tif(!bfs(s,t)) return 0;\n\trep(i,vmax) iter[i]=0;\n\treturn dfs(s,t,1);\n}\n\nint add(int from,int to,int s,int t){\n\tadd_edge(from,to,1);\n\tadd_edge(to,from,1);\n\treturn flow(s,t);\n}\n\nint erase(int from,int to,int s,int t){\n\tint ft=0;\n\tfor(auto &e:graph[from]){\n\t\tif(e.to==to&&e.original){\n\t\t\tif(graph[e.to][e.rev].cap==1) ft++;\n\t\t\te.cap=0,graph[e.to][e.rev].cap=0;\n\t\t}\n\t}\n\n\tfor(auto &e:graph[to]){\n\t\tif(e.to==from&&e.original){\n\t\t\tif(graph[e.to][e.rev].cap==1) ft--;\n\t\t\te.cap=0,graph[e.to][e.rev].cap=0;\n\t\t}\n\t}\n\n\tif(ft==0) return 0;\n\n\tif(ft>0&&flow(from,to)==1) return 0;\n\tif(ft<0&&flow(to,from)==1) return 0;\n\n\tif(ft>0)flow(t,to),flow(from,s);\n\tif(ft<0)flow(t,from),flow(to,s);\n\treturn -1;\n}\n\n\nvoid show(int n){\n\trep(i,n)for(auto &e:graph[i]) if(e.original)\n\t\tcout << i << \" -> \" <<  e.to << \" : \" << graph[e.to][e.rev].cap << endl;\n}\n\n\nint main(void){\n\tint n,m,q;\n\tcin >> n >> m >> q;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b ;\n\t\tadd_edge(a-1,b-1,1);\n\t\tadd_edge(b-1,a-1,1);\n\t}\n\tint sum=max_flow(0,n-1);\n\trep(loop,q){\n\t\tint type,a,b;\n\t\tcin >> type >> a >> b;\n\t\tif(type==1)\n\t\t\tsum+=add(a-1,b-1,0,n-1);\n\t\telse\n\t\t\tsum+=erase(a-1,b-1,0,n-1);\n\t\tcout << sum << endl;\n\t\t//show(n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct FordFulkerson {\n\tusing Flow = int;\n\tint n;\n\tint s, t;\n\tFlow maxflow;\n\tvector<vector<Flow>> g;\n\tvector<bool> used;\n\tFordFulkerson(int n, int s = -1, int t = -1) :n(n), g(n, vector<Flow>(n)), used(n), s(s), t(t), maxflow(0) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from][to] = cap;\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\taddArc(a, b, cap);\n\t\taddArc(b, a, cap);\n\t}\n\tFlow addEdgeCap(int a, int b, Flow cap) {\n\t\tif (cap > 0) {\n\t\t\tg[a][b] += cap;\n\t\t\tg[b][a] += cap;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tmaxflow += augment(s, t, cap);\n\t\t}\n\t\telse {\n\t\t\tFlow rcap = -cap;\n\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\tg[a][b] -= rcap;\n\t\t\t\tg[b][a] -= rcap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (g[a][b] > g[b][a])swap(a, b);\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tFlow f = augment(a, b, a, b, rcap);\n\t\t\t\tdump(a, b);\n\t\t\t\tdump(f, rcap);\n\t\t\t\tif (f < rcap) {\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\taugment(b, a, b, a, f);\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tFlow sub = augment(t, s, rcap - f);\n\t\t\t\t\tassert(sub == rcap - f);\n\t\t\t\t\tmaxflow -= sub;\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tf = augment(a, b, a, b, rcap);\n\t\t\t\t\tassert(f == rcap);\n\t\t\t\t\tg[a][b] += rcap; g[a][b] -= rcap;\n\t\t\t\t\tg[b][a] -= rcap; g[b][a] -= rcap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn maxflow;\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tFlow f = augment(s, t, INF);\n\t\t\tif (f == 0)return maxflow += total;\n\t\t\ttotal += f;\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tFlow augment(int v, int t, int a, int b, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (v == a&&to == b)continue;\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, E, Q; cin >> N >> E >> Q;\n\tFordFulkerson ff(N, 0, N - 1);\n\trep(i, 0, E) {\n\t\tint F, T; cin >> F >> T; F--, T--;\n\t\tff.addEdge(F, T, 1);\n\t}\n\tdump(ff.g);\n\tff.maximumFlow(0, N - 1);\n\tdump(ff.g);\n\tdump(ff.maxflow);\n\trep(i, 0, Q) {\n\t\tint M, A, B; cin >> M >> A >> B;\n\t\tdump(M, A, B);\n\t\tA--, B--;\n\t\tif (M == 1) {\n\t\t\tcout << ff.addEdgeCap(A, B, 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ff.addEdgeCap(A, B, -1) << endl;\n\t\t}\n\t\tdump(ff.g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * F-F ??????????????¨?????????????????¨\n */\ntemplate<int V>\nstruct MaxFlow {\n    struct Edge {\n        int to, rev, cap;\n    };\n    vector<Edge> g[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    /// ??????????????¨?????????, ??????1??????2????????????????????????????????????\n    void add_multi(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    int erase(int from, int to) {\n        for (int i = 0; i < (int)g[from].size(); i++) {\n            auto e = g[from][i];\n            if (e.to == to && e.cap + g[to][e.rev].cap) {\n                int c = g[to][e.rev].cap - e.cap;\n                g[to][e.rev].cap = 0;\n                g[from][i].cap = 0;\n                return c;\n            }\n        }\n        assert(false);\n    }\n\n    bool used[V];\n    bool dfs(int s, int t) {\n        if (s == t) return true;\n        used[s] = true;\n        for (auto &e : g[s]) {\n            if (used[e.to]) continue;\n            assert(e.cap >= 0);\n            if (!e.cap) continue;\n            if (dfs(e.to, t)) {\n                e.cap -= 1;\n                g[e.to][e.rev].cap += 1;\n                return true;\n            }\n        }\n        return false;\n    }\n    int exec(int s, int t, int F) {\n        int f = 0;\n        while (f < F) {\n            fill_n(used, V, false);\n            if (!dfs(s, t)) break;\n            f++;\n        }\n        return f;\n    }\n    void print() {\n        int ec = 0, cs = 0;\n        for (int i = 0; i < V; i++) {\n            for (auto &e: g[i]) {\n                if (e.cap + g[e.to][e.rev].cap == 0) continue;\n                ec++;\n                cs += e.cap;\n                printf(\"%d %d %d\\n\", i, e.to, e.cap);\n            }\n        }\n        printf(\"print %d\\n\", ec);\n    }\n};\n\nMaxFlow<550> mf;\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t; f--; t--;\n        mf.add_multi(f, t, 1);\n    }\n    int f = 0;\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b; a--; b--;\n        if (m == 1) {\n            mf.add_multi(a, b, 1);\n        } else {\n            int u = mf.erase(a, b);\n//            mf.print();\n//            printf(\"erase %d %d %d\\n\", a, b, u);\n            if (u) {\n                if (u == -2) swap(a, b);\n                if (!mf.exec(a, b, 1)) {\n                    f--;\n                    assert(mf.exec(n-1, b, 1));\n                    assert(mf.exec(a, 0, 1));\n                }\n            }\n        }\n        f += mf.exec(0, n-1, 100000);\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct max_flow{\n    vector<vector<int>> graph;\n    vector<bool> done;\n    int size,flow;\n    max_flow(int size_):size(size_),graph(size_,vector<int>(size_)),done(size_),flow(0){}\n    void add_edge(int from,int to,int cap){\n        graph[from][to]=graph[to][from]=cap;\n    }\n    int dfs(int v,int t,int f){\n        if(v==t) return f;\n        done[v]=true;\n        for(int w=0; w<size; ++w){\n            if(done[w] or graph[v][w]==0) continue;\n            int d=dfs(w,t,min(f,graph[v][w]));\n            if(d>0){\n                graph[v][w]-=d;\n                graph[w][v]+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int calc_max_flow(int s,int t){\n        while(true){\n            fill(done.begin(),done.end(),false);\n            int f=dfs(s,t,inf);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nvoid solve(){\n    int n,e,q;\n    cin >> n >> e >> q;\n    max_flow mf(n);\n    rep(i,0,e){\n        int f,t;\n        cin >> f >> t;\n        --f;\n        --t;\n        mf.add_edge(f,t,1);\n    }\n    mf.calc_max_flow(0,n-1);\n    auto search_path=[&](int s,int t,int c){\n        vector<int> from(n);\n        vector<bool> done(n);\n        queue<int> que;\n        que.push(s);\n        done[s]=true;\n        while(!que.empty()){\n            int u=que.front();\n            que.pop();\n            if(u==t){\n                vector<int> res;\n                int v=u;\n                while(v!=s){\n                    res.push_back(v);\n                    v=from[v];\n                }\n                res.push_back(s);\n                reverse(res.begin(),res.end());\n                return res;\n            }\n            rep(v,0,n){\n                if(done[v]) continue;\n                if(c==1){\n                    if(mf.graph[u][v]==0) continue;\n                }else{\n                    if(mf.graph[u][v]!=0 or mf.graph[v][u]!=2) continue;\n                }\n                que.push(v);\n                done[v]=true;\n                from[v]=u;\n            }\n        }\n\n        return vector<int>();\n    };\n    rep(i,0,q){\n        int m,a,b;\n        cin >> m >> a >> b;\n        --a;\n        --b;\n        if(m==1){\n            mf.add_edge(a,b,1);\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }else{\n            int k=mf.calc_max_flow(0,n-1);\n            if(mf.graph[a][b]==1){\n                cout << k << endl;\n                continue;\n            }\n            if(mf.graph[b][a]==0) swap(a,b);\n            mf.graph[a][b]=mf.graph[b][a]=0;\n            {\n                vector<int> vs=search_path(a,b,1);\n                if(!vs.empty()){\n                    rep(i,0,vs.size()-1){\n                        --mf.graph[vs[i]][vs[i+1]];\n                        ++mf.graph[vs[i+1]][vs[i]];\n                    }\n                    cout << k << endl;\n                    continue;\n                }\n            }\n            --mf.flow;\n            if(a!=0){\n                vector<int> vs=search_path(0,a,0);\n                rep(i,0,vs.size()-1){\n                    ++mf.graph[vs[i]][vs[i+1]];\n                    --mf.graph[vs[i+1]][vs[i]];\n                }\n            }\n            if(b!=n-1){\n                vector<int> vs=search_path(b,n-1,0);\n                rep(i,0,vs.size()-1){\n                    ++mf.graph[vs[i]][vs[i+1]];\n                    --mf.graph[vs[i+1]][vs[i]];\n                }\n            }\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t) {\n        return f;\n    }\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    if (s == t) return 0;\n    int flow = 0;\n    for(;;) {\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n    }\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        if (m == 1) {\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n);\n            cout << f << endl;\n        } else {\n            int from = -1, to = -1;\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 &&  to > 0) {\n                if (max_flow(from, to, 1) > 0) {\n                    cout << f << endl;\n                } else {\n                    f--;\n                    max_flow(from, 1);\n                    max_flow(n, to);\n                    cout << f << endl;\n                }\n            }\n            else cout << f << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define crear_vec(v,n) v.clear();v.resize(n);\n#define delete_vec(v,n) v.erase(remove(v.begin(),v.end(),n),v.end());\ntypedef pair<int,int> pii;\nint N,E,Q;\nvector<vector<pii> > edge;\nint f;\nvoid flow(int from,int to){\n  for(int i=0;i<edge[from].size();i++){\n    if(edge[from][i].first==to)edge[from][i].second++;\n  }\n  for(int j=0;j<edge[to].size();j++){\n    if(edge[to][j].first == from)edge[to][j].second--;\n  }\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    if(used[edge[from][i].first]==1)continue;\n    if(edge[from][i].second<1&&dfs_(edge[from][i].first,to)==1){\n      flow(from,edge[from][i].first);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  crear_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(pii(b,0));\n  edge[b].push_back(pii(a,0));\n  while(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff;\n  for(int i=0;i<edge[a].size();i++){\n    if(edge[a][i].first==b){\n      ff=edge[a][i].second;\n      delete_vec(edge[a],edge[a][i]);\n      break;\n    }\n  }\n  for(int i=0;i<edge[b].size();i++){\n    if(edge[b][i].first==a){\n      delete_vec(edge[b],edge[b][i]);\n      break;\n    }\n  }\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(dfs(a,b)){\n      //cerr<<\"roop\"<<endl;\n    }else if(dfs(N,b)&&dfs(a,1)){\n      //cerr<<\"dec flow\"<<endl;\n      f--;\n    }else {\n      //cerr<<\"err\"<<endl;\n    }\n  }\n  while(dfs(1,N))f++;\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  crear_vec(edge,N+1);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  while(dfs(1,N));\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  if(m==1){\n    add_edge(a,b);\n  }else if(m==2){\n    cut_edge(a,b);\n  }\n  return f;\n}\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    //*/\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int a,int b,int c):to(a),cap(b),rev(c){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,cap,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim){\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1,INF);\n}\n\nvoid q2(int a,int b){\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.to!=b||e.cap!=2)continue;\n        f2=true;\n        e.cap=0;\n    }\n    for(auto &e:G[b]){\n        if(e.to!=a||e.cap!=2)continue;\n        f1=true;\n        e.cap=0;\n    }\n    if(!f1&&!f2)assert(0);\n\n    if(f2)swap(a,b);\n\n\n    int tmp=max_flow(a,b,1);\n\n    if(tmp)return;\n\n    add_edge(0,N-1,1);\n    tmp=max_flow(a,b,1);\n    assert(tmp);\n    G[0].pop_back();\n    G[N-1].pop_back();\n    f--;\n\n    f+=max_flow(0,N-1,INF);\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n    }\n\n    f=max_flow(0,N-1,INF);\n\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n            /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.cap==2)cout<<e.to+1<<\" \"<<i+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tflow = prev - G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t\tflow.add_edge(t, f, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    // s->t 増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap += c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap -= e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n        \tFlow d = e.icap - e.cap - c;\n            // e.cap = 0;reve.cap = 0;\n            // //(1) S <- s <- t <- T のフローを戻す\n            // Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            // max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            // flow -= f;\n            // //(2) (1)で流せない分は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            // assert(max_flow(s,t,d-f)==d-f);\n\n        \tFlow revd = max_flow(s,t,d);\n            max_flow(T,S,d-revd);\n            assert(max_flow(s,t,d-revd)==d-revd);\n            flow -= d-revd;\n\n\n            e.cap = 0;reve.cap = c + reve.icap;\n            e.icap = c;\n        }\n        // flow+=max_flow(S,T);\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n \n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }\n        }\n\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1) g[a][b]=g[b][a]=1,flow+=max_flow(0,n-1);\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b))flow--,check(a,0),check(n-1,b);\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E+1];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E+1];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[501][501];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0){\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmemset(isUsable,0,sizeof(isUsable));\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// êxà¬êÄ¢È¢\n\t\t\tif(!isDirected[eidx]){\n\t\t\t\t// Øé¾¯\n\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\tisUsable[eidx]=false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==1){\n\t\t\t\t\t\t\t\tlineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// flowª¬êÄ¢éêAg©çtÜÅAt©çfÜÅAf©çsÜÅ»ê¼ê\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// Øf\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==0){\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// Øf\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cap, rev;\n  Edge(int u, int v, int c, int r) :\n    src(u), dst(v), cap(c), rev(r) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nbool used[500];\nint dfs(int u, int t, int f){\n  if(u == t) return f;\n  used[u] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0 && !used[e->dst]){\n      int d = dfs(e->dst, t, min(f, e->cap));\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nvoid max_flow(int &flow, int S, int T){\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(S, T, INF);\n    if(f == 0) return;\n    flow += f;\n  }\n}\nvoid add_edge(int u, int v){\n  G[u].push_back(Edge(u, v, 1, G[v].size()));\n  G[v].push_back(Edge(v, u, 1, G[u].size() - 1));\n}\n \nint main(){\n  int N, E, Q;\n  while(cin >> N >> E >> Q){\n    G = Graph(N);\n    REP(i, E){\n      int A, B;\n      cin >> A >> B;\n      A--; B--;\n      add_edge(A, B);\n    }\n    int S = 0, T = N - 1;\n    int flow = 0;\n    max_flow(flow, S, T);\n    REP(i, Q){\n      int M, A, B;\n      cin >> M >> A >> B;\n      A--; B--;\n      if(M == 1){\n        add_edge(A, B);\n        max_flow(flow, S, T);\n      }else{\n        FORIT(e, G[A])if(e->dst == B && e->cap == 2){\n          memset(used, 0, sizeof(used));\n          if(dfs(B, A, 1) == 1){\n            goto ERASE;\n          }\n          memset(used, 0, sizeof(used));\n          assert(dfs(T, A, 1) == 1);\n          memset(used, 0, sizeof(used));\n          assert(dfs(B, S, 1) == 1);\n          flow--;\n          goto ERASE;\n        }\n        FORIT(e, G[B])if(e->dst == A && e->cap == 2){\n          memset(used, 0, sizeof(used));\n          if(dfs(A, B, 1) == 1){\n            goto ERASE;\n          }\n          assert(dfs(T, B, 1) == 1);\n          memset(used, 0, sizeof(used));\n          assert(dfs(A, S, 1) == 1);\n          flow--;\n          goto ERASE;\n        }\n        ERASE:\n          FORIT(e, G[A]) if(e->dst == B) { G[A].erase(e); break; }\n          FORIT(e, G[B]) if(e->dst == A) { G[B].erase(e); break; }\n        FLOW:\n          max_flow(flow, S, T);\n      }\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\n\nconst int MAX = 501;\nbool edge[MAX][MAX];\nbool flow[MAX][MAX];\n\nint N, E, Q;\n\nbool used[500];\nbool _dfs(int s, int t)\n{\n\tif (s == t)\n\t\treturn true;\n\n\tused[s] = true;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (!used[i] && edge[s][i])\n\t\t{\n\t\t\tif (!flow[s][i])\n\t\t\t{\n\t\t\t\tif (_dfs(i, t))\n\t\t\t\t{\n\t\t\t\t\tif (flow[i][s])\n\t\t\t\t\t\tflow[i][s] = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tflow[s][i] = true;\n\t\t\t\t\t//flow[s][i] = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flow[i][s])\n\t\t\t{\n\t\t\t\tif (_dfs(i, t))\n\t\t\t\t{\n\t\t\t\t\tflow[i][s] = false;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool dfs(int s, int t)\n{\n\tfill(used, used+N+1, false);\n\treturn _dfs(s, t);\n}\nvoid p()\n{\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tprintf(\"%2d: \", i);\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tif (flow[i][j])\n\t\t\t\tprintf(\"f%2d \", j);\n\t\t\telse if (edge[i][j])\n\t\t\t\tprintf(\"e%2d \", j);\n\t\tprintf(\"\\n\");\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &Q);\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tedge[f][t] = edge[t][f] = true;\n\t}\n\n\tint res = 0;\n\twhile (dfs(1, N))\n\t\t++res;\n\n\tfor (int i = 0; i < Q; ++i)\n\t{\n\t\tint\tm, a, b;\n\t\tscanf(\"%d%d%d\", &m, &a, &b);\n\n\t\tif (m == 1)\n\t\t{\n\t\t\tedge[a][b] = edge[b][a] = true;\n\t\t\tif (dfs(1, N))\n\t\t\t\t++res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tedge[a][b] = edge[b][a] = false;\n\n\t\t\tif (flow[a][b] && !dfs(a, b))\n\t\t\t{\n\t\t\t\tdfs(a, 1);\n\t\t\t\tdfs(N, b);\n\t\t\t\t--res;\n\t\t\t}\n\t\t\tif (flow[b][a] && !dfs(b, a))\n\t\t\t{\n\t\t\t\tdfs(b, 1);\n\t\t\t\tdfs(N, a);\n\t\t\t\t--res;\n\t\t\t}\n\t\t\tflow[a][b] = flow[b][a] = false;\n\t\t}\n\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n \nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n \nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n \nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n \nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  int prev=0;\n  for(int i=1;i<=N;i++) G[i]=G2[i];\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      if(M[a].find(b)==M[a].end()) {\n\tadd_edge(a,b,1);\n\tG[a].push_back(edge(b,1,G[a].size()));\n\tG[b].push_back(edge(a,1,G[b].size()-1));\n      }else{\n\tG[a][M[a][b]].cap=G[b][M[b][a]].cap=1;\n\tG2[a][M[a][b]].cap=G2[b][M[b][a]].cap=1;\n      }\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n      for(int i=1;i<=N;i++) G[i]=G2[i];\n      prev=0;\n    }\n    prev=prev+max_flow(1,N);\n    printf(\"%d\\n\",prev);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint n;\nvector<vector<Edge> > edges;\nvector<bool> used;\n\nint dfs(int s, int t, int f){\n    if(s == t)\n        return f;\n\tused[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 0){\n            int g = dfs(e.to, t, min(f, e.cap));\n            if(g > 0){\n                e.cap -= g;\n                edges[e.to][e.rev].cap += g;\n                return g;\n            }\n        }\n    }\n    return 0;\n}\n\nint flow(int s, int t, int f){\n\tused.assign(n+1, false);\n\treturn dfs(s, t, f);\n}\n\nint main()\n{\n\tint e, q;\n\tcin >> n >> e >> q;\n\n\tedges.assign(n+1, vector<Edge>());\n\tfor(int i=0; i<e; ++i){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tedges[f].push_back(Edge(t, 1, edges[t].size()));\n\t\tedges[t].push_back(Edge(f, 1, edges[f].size()-1));\n\t}\n\n\tint ret = 0;\n\tfor(;;){\n\t\tint f = flow(1, n, INT_MAX);\n\t\tif(f == 0)\n\t\t\tbreak;\n\t\tret += f;\n\t}\n\n\tfor(int i=0; i<q; ++i){\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tunsigned j = 0;\n\t\t\twhile(j < edges[a].size() && edges[a][j].to != b)\n\t\t\t\t++ j;\n\t\t\tif(j < edges[a].size()){\n\t\t\t\tedges[a][j].cap = 1;\n\t\t\t\tedges[b][edges[a][j].rev].cap = 1;\n\t\t\t}else{\n\t\t\t\tedges[a].push_back(Edge(b, 1, edges[b].size()));\n\t\t\t\tedges[b].push_back(Edge(a, 1, edges[a].size()-1));\n\t\t\t}\n\t\t\tret += flow(1, n, 1);\n\t\t}else{\n\t\t\tunsigned j = 0;\n\t\t\twhile(edges[a][j].to != b)\n\t\t\t\t++ j;\n            if(edges[a][j].cap == 1){\n\t\t\t\tedges[a][j].cap = 0;\n\t\t\t\tedges[b][edges[a][j].rev].cap = 0;\n            }else{\n\t\t\t    if(edges[a][j].cap == 0){\n\t\t\t\t    edges[b][edges[a][j].rev].cap = 0;\n\t\t\t\t    flow(a, 1, 1);\n\t\t\t\t    flow(n, b, 1);\n\t\t\t    }else{\n\t\t\t\t    edges[a][j].cap = 0;\n\t\t\t\t    flow(b, 1, 1);\n\t\t\t\t    flow(n, a, 1);\n\t\t\t    }\n\t\t\t    -- ret;\n\t\t\t    ret += flow(1, n, 1);\n            }\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int a,int b,int c):to(a),cap(b),rev(c){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,cap,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1);\n}\n\nbool dfs2(int v,int t,vint &A){\n    used[v]=true;\n    if(v==t){\n        A.pb(v);\n        return true;\n    }\n\n    for(auto &e:G[v]){\n        if(e.cap==0)continue;\n        if(used[e.to])continue;\n        if(dfs2(e.to,t,A)){\n            A.pb(v);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid uku(vint &A){\n    for(int i=0;i+1<A.size();i++){\n        int a=A[i];\n        int b=A[i+1];\n\n        for(auto &e:G[a]){\n            if(e.to==b&&e.cap){\n                e.cap--;\n                G[e.to][e.rev].cap++;\n                break;\n            }\n        }\n    }\n}\n\nvoid q2(int a,int b){\n\n    int d=0;\n    for(auto &e:G[a]){\n        if(e.to==b){\n            if(e.cap==2)d=-1;\n            e.cap=0;\n        }\n    }\n    for(auto &e:G[b]){\n        if(e.to==a){\n            if(e.cap==2)d=1;\n            e.cap=0;\n        }\n    }\n\n    if(d==0)return;\n\n    if(d==-1)swap(a,b);\n\n    vint A,B;\n    memset(used,0,sizeof(used));\n    assert(dfs2(N-1,b,B));\n    memset(used,0,sizeof(used));\n    assert(dfs2(a,0,A));\n\n    reverse(all(A));\n    reverse(all(B));\n\n    map<int,int>ei;\n\n    rep(i,B.size())ei[B[i]]=i;\n\n    int k=-1;\n    rep(i,A.size()){\n        if(ei.find(A[i])==ei.end())continue;\n        k=i;\n        break;\n    }\n\n    if(k==-1){\n        uku(A);uku(B);\n        f--;\n    }\n    else{\n        int l=ei[A[k]];\n        A.erase(A.begin()+k,A.end());\n        for(int i=l;i<B.size();i++)A.pb(B[i]);\n        uku(A);\n    }\n\n    f+=max_flow(0,N-1);\n}\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n    }\n\n    f=max_flow(0,N-1);\n\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n            /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.cap==2)cout<<e.to+1<<\" \"<<i+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef unordered_map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    scanf(\"%d%d\",&a,&b),a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int op,a,b,flow=max_flow(0,n-1);\n  while(q--){\n    scanf(\"%d%d%d\",&op,&a,&b);a--,b--;\n    if(op==1) g[a][b]=g[b][a]=1,flow+=max_flow(0,n-1);\n    else {\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b))flow--,check(a,0),check(n-1,b);\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000;\nint cap[500][500];\n\nint maximumFlow(int n, int s, int t, bool first = false){\n\tint res = 0;\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\tint inc = INF;\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tinc = min(inc, cap[prev[j]][j]);\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j] -= inc, cap[j][prev[j]] += inc;\n\t\tres += inc;\n\t\tif(!first) return res;\n\t}\n\treturn 0;\n}\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1, true);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\tint s = A-1, t = B-1;\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(cap[t][s] == 2){\n\t\t\t\t\t\tcap[t][s] = 0;\n\t\t\t\t\t\tint tmp = maximumFlow(N, s, t); \n\t\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\t\tint c = t;\n\t\t\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc = s;\n\t\t\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswap(s, t);\n\t\t\t\t}\n\t\t\t\tcap[s][t] = cap[t][s] = 0;\n\t\t\t\t/*\n\t\t\t\tif(cap[A-1][B-1] == 0){\n\t\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t\t\tint tmp = maximumFlow(N, A-1, B-1); \n\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\tint c = B-1;\n\t\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = A-1;\n\t\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cap[B-1][A-1] == 0){\n\t\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\t\tint tmp = maximumFlow(N, B-1, A-1);\n\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\tint c = A-1;\n\t\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = B-1;\n\t\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0) {\n          if(e.to) max_flow(graph.size() - 1, to, 1);\n          max_flow(from, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        if(!used[i]&&G[v][i]>0){\n            int d=dfs(i,t,min(f,G[v][i]));\n            if(d>0){\n                G[v][i]-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&V,&E,&Q);\n    f(i,E){\n        scanf(\"%d%d\",&F,&T);\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        scanf(\"%d%d%d\",&m,&a,&b);\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n            now+=max_flow(0,V-1);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(V-1,b,1);\n                    now--;\n                }\n            }\n        }\n        printf(\"%d\\n\",now);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define MAX_N 500\nstruct Edge {\n  int to, cap, rev;\n  Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Dinic {\npublic:\n  vector<Edge> G[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n\n  pair<int, int> add_edge(int from, int to, int cap) {\n    G[from].pb(Edge(to, cap, (int)G[to].size()));\n    G[to].pb(Edge(from, 0, (int)G[from].size() - 1));\n    return make_pair(G[from].size()-1, G[to].size()-1);\n  }\n\n  void bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int x = q.front(); q.pop();\n      for (int i=0; i<G[x].size(); i++) {\n        Edge &e = G[x][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[x] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int x, int t, int f) {\n    if (x == t) return f;\n    for (int &i=iter[x]; i<G[x].size(); i++) {\n      Edge &e = G[x][i];\n      if (e.cap > 0 && level[x] < level[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t, int lim=INF) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      while (lim) {\n        int f = dfs(s, t, lim);\n        if (f <= 0) break;\n        flow += f;\n        lim -= f;\n        if (lim == 0) return flow;\n      }\n    }\n  }\n};\n\nint N, E, Q;\nDinic dinic;\npair<int, int> G[500][500];\n\nint rem(int s, int t) {\n  Edge *e = &dinic.G[s][G[s][t]._1], *rev = &dinic.G[t][G[s][t]._2];\n  if (rev->cap == 0) {\n    e->cap = rev->cap = 0;\n    return 0;\n  }\n  if (dinic.max_flow(s, t, 1) > 0) {\n    e->cap = rev->cap = 0;\n    return 0;\n  }\n  dinic.max_flow(N-1, t, 1);\n  dinic.max_flow(s, 0, 1);\n  e->cap = rev->cap = 0;\n  return -1;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> E >> Q;\n  rep(i, N) rep(j, N) if (i != j) G[i][j] = dinic.add_edge(i, j, 0);\n  rep(i, E) {\n    int f, t;\n    cin >> f >> t;\n    f--, t--;\n    dinic.G[f][G[f][t]._1].cap++;\n    dinic.G[t][G[t][f]._1].cap++;\n  }\n  int f = dinic.max_flow(0, N-1);\n  rep(i, Q) {\n    int m, a, b;\n    cin >> m >> a >> b;\n    a--, b--;\n    if (m == 1) {\n      dinic.G[a][G[a][b]._1].cap++;\n      dinic.G[b][G[b][a]._1].cap++;\n      f += dinic.max_flow(0, N-1, 1);\n    }\n    else {\n      f += rem(a, b);\n      f += rem(b, a);\n    }\n    cout << f << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow - G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tflow = prev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (!x.add || x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t\tflow.add_edge(t, f, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * F-F ??????????????¨?????????????????¨\n */\ntemplate<int V>\nstruct MaxFlow {\n    struct Edge {\n        int to, rev, cap;\n    };\n    vector<Edge> g[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    /// ??????????????¨?????????, ??????1??????2????????????????????????????????????\n    void add_multi(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    int erase(int from, int to) {\n        for (int i = 0; i < (int)g[from].size(); i++) {\n            auto e = g[from][i];\n            if (e.to == to) {\n                int c = g[to][e.rev].cap - e.cap;\n                g[to].erase(g[to].begin()+e.rev);\n                g[from].erase(g[from].begin()+i);\n                return c;\n            }\n        }\n        assert(false);\n    }\n\n    bool used[V];\n    bool dfs(int s, int t) {\n        if (s == t) return true;\n        used[s] = true;\n        for (auto &e : g[s]) {\n            if (used[e.to]) continue;\n            if (!e.cap) continue;\n            if (dfs(e.to, t)) {\n                e.cap -= 1;\n                g[e.to][e.rev].cap += 1;\n                return true;\n            }\n        }\n        return false;\n    }\n    int exec(int s, int t, int F) {\n        int f = 0;\n        while (f < F) {\n            fill_n(used, V, false);\n            if (!dfs(s, t)) break;\n            f++;\n        }\n        return f;\n    }\n    void print() {\n        for (int i = 0; i < V; i++) {\n            for (auto &e: g[i]) {\n                printf(\"(%d %d %d)\\n\", i, e.to, e.cap);\n            }\n        }\n    }\n};\n\nMaxFlow<550> mf;\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t; f--; t--;\n        mf.add_multi(f, t, 1);\n    }\n    int f = 0;\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b; a--; b--;\n        if (m == 1) {\n            mf.add_multi(a, b, 1);\n        } else {\n            int u = mf.erase(a, b);\n            if (u) {\n                if (u == -2) swap(a, b);\n                f--;\n                mf.exec(n-1, b, 1);\n                mf.exec(a, 0, 1);\n            }\n        }\n        f += mf.exec(0, n-1, 10000);\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n \nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n \nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n    level[e.to]=level[v]+1;\n    que.push(e.to);\n      }\n    }\n  }\n}\n \nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n    e.cap-=d;\n    G[e.to][e.rev].cap+=d;\n    return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n \nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      if(M[a].find(b)==M[a].end()) add_edge(a,b,1);\n      else G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n    }\n    for(int i=1;i<=N;i++) G[i]=G2[i];\n    printf(\"%d\\n\",max_flow(1,N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=1;\n    G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=0;\n    G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        int &c = G[v][i];\n        if(!used[i]&&c>0){\n            int d=dfs(i,t,min(f,c));\n            if(d>0){\n                c-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    cin>>V>>E>>Q;\n    f(i,E){\n        cin>>F>>T;\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(b,V-1,1);\n                    now--;\n                }\n            }\n        }\n        cout<<now<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dfs(const int s, const int t, const int f, vector<map<int, int>>& c, vector<bool>& used)\n{\n    if (s == t) { return f; }\n    used[s] = true;\n    for (auto& e : c[s]) {\n        if (used[e.first] or e.second == 0) { continue; }\n        const int res = min(f, e.second);\n        const int d = dfs(e.first, t, res, c, used);\n        if (d == 0) { continue; }\n        return e.second -= d, c[e.first][s] += d, d;\n    }\n    return 0;\n}\nconstexpr int INF = 1 << 30;\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    vector<map<int, int>> c(N);\n    auto addEdge = [&](const int u, const int v) -> void { c[u][v] = c[v][u] = 1; };\n    auto cutEdge = [&](const int u, const int v) -> void { c[u].erase(v), c[v].erase(u); };\n    auto flow = [&](const int s, const int t, const int limit) {\n        vector<bool> used(N, false);\n        for (int flow = 0; flow < limit;) {\n            fill(used.begin(), used.end(), false);\n            const int f = dfs(s, t, limit - flow, c, used);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n        return limit;\n    };\n    for (int i = 0, F, T; i < E; i++) {\n        cin >> F >> T;\n        addEdge(F - 1, T - 1);\n    }\n    int ans = flow(0, N - 1, INF);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            addEdge(A, B);\n        } else {\n            const int cap = c[A][B];\n            cutEdge(A, B);\n            if (cap == 2) { swap(A, B); }\n            //            if (cap != 1 and flow(A, B, 1) == 0) { ans--, flow(A, 0, 1), flow(N - 1, B, 1); }なら通る\n            if (cap != 1) { ans--, flow(A, 0, 1), flow(N - 1, B, 1); }\n        }\n        cout << (ans += flow(0, N - 1, 1)) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{ int to, cap, rev;};\nint INF = (1e9);\nbool used[500];\n\nint dfs(vector< vector <edge> > &G, int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(G, e.to, t, min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(vector< vector <edge> > G, int s, int t){\n  int flow = 0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f = dfs(G, s, t, INF);\n    if(!f) return flow;\n    flow += f;\n  }\n}\nint main(){\n  int N, E, Q;\n  scanf(\"%d %d %d\",&N,&E,&Q);\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  for(int i = 0; i < E; ++i){\n    int f, t;\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  for(int i = 0; i < Q; ++i){\n    int m, a, b, flow;\n    scanf(\"%d %d %d\",&m,&a,&b);\n    --a,--b;\n    G[a][2*b].cap = 2-m;\n    G[b][2*a].cap = 2-m;\n    flow = max_flow(G, 0, N-1);\n    printf(\"%d\\n\", flow);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,E,Q;\nint G[500][500];\nbool visited[500];\nint dfs(int pos,int ti,int f){\n  if(pos==ti)return f;\n  if(visited[pos])return 0;\n  visited[pos]=true;\n  for(int i=0;i<N;i++){\n    int e=G[pos][i];\n    if(e==0)continue;\n    int k=dfs(i,ti,min(f,e));\n    if(k==0)continue;\n    G[pos][i]-=k;\n    G[i][pos]+=k;\n    return k;\n  }\n  return 0;\n}\nint ans;\nvoid maxflow(int si,int ti){\n  ans=0;\n  while(1){\n    memset(visited,false,sizeof(visited));\n    int f=dfs(si,ti,1);\n    if(f==0)break;\n    ans+=f;\n  }\n}\n\nint main(){\n  cin>>N>>E>>Q;\n  for(int i=0;i<E;i++){\n    int F,T;\n    cin>>F>>T;\n    F--,T--;\n    G[F][T]++;\n    G[T][F]++;\n  }\n\n  maxflow(0,N-1);\n  for(int i=0;i<Q;i++){\n    int M,A,B;\n    cin>>M>>A>>B;\n    A--,B--;\n    \n    if(M==1){\n      G[A][B]++;\n      G[B][A]++;\n      memset(visited,false,sizeof(visited));\n      ans+=dfs(0,N-1,1);\n    }else{\n\n      if(G[A][B]>0){\n        G[A][B]--;\n      }else{\n        G[B][A]--;\n        memset(visited,false,sizeof(visited));\n        dfs(N-1,B,1);\n        memset(visited,false,sizeof(visited));\n        dfs(A,0,1);\n        ans--;\n        memset(visited,false,sizeof(visited));\n        ans+=dfs(0,N-1,1);\n      }\n\n      if(G[B][A]>0){\n        G[B][A]--;\n      }else{\n        G[A][B]--;\n        memset(visited,false,sizeof(visited));\n        dfs(N-1,A,1);\n        memset(visited,false,sizeof(visited));\n        dfs(B,0,1);\n        ans--;\n        memset(visited,false,sizeof(visited));\n        ans+=dfs(0,N-1,1);\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0 && max_flow(to, from, 1)) {\n          max_flow(graph.size() - 1, to, 1);\n          max_flow(from, 0, 1);\n          return (true);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v * 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\n\t\t\tab.cap += f;\n\t\t\tba.cap += f;\n\t\t\tassert(ab.cap == 1);\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\t//cout << \"SUB\" << endl;\n\t\t\tif(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\tif(ab.cap >= 1){\n\t\t\t\t//cout << \"WY\" << endl;\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\t//cout << \"HE\" << endl;\n\t\t\t\tif(fordFulkerson(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t//cout << \"OUT\" << endl;\n\n\t\t\t\tassert(fordFulkerson(a, s, 1) == 1);\n\t\t\t\tassert(fordFulkerson(t, b, 1) == 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tint com, a, b;\n\t\tcin >> com >> a >> b;\n\t\ta--; b--;\n\n\t\tif(com == 1){\n\t\t\tif(use[a][b]){\n\t\t\t\tans += flow.addCapacity(s, t, a, b);\n\t\t\t}else{\n\t\t\t\tuse[a][b] = use[b][a] = true;\n\t\t\t\tflow.addEdge(a, b, 1);\n\t\t\t\tflow.addEdge(b, a, 1);\n\t\t\t\tans += flow.fordFulkerson(s, t);\n\t\t\t}\n\t\t}else{\n\n\t\t\tans += flow.subCapacity(s, t, a, b);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <set>\n\ntemplate <class Tp>\nTp inf() { return static_cast<Tp>(1) << (8*sizeof(Tp) - 3); }\n\ntemplate <class Tp>\nstruct Edge {\n  size_t src, dst;\n  Tp cap;\n  size_t rev;\n  Edge(size_t src, size_t dst, Tp cap, size_t rev):\n    src(src), dst(dst), cap(cap), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<Edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<Edge<Tp>>>(n) {}\n\n  void connect_with(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, cap, (*this)[src].size()-1);\n  }\n\n  void connect_to(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, 0, (*this)[src].size()-1);\n  }\n\n  void inspect() const {\n    size_t n = this->size();\n    fprintf(stderr, \"vertex: %zu\\n\", n);\n    for (size_t i = 0; i < n; ++i)\n      for (const auto& e: (*this)[i]) {\n        // fprintf(stderr, \"%zu -> %zu, cap: %zu, rev: [%zu]\\n\",\n        //         e.src, e.dst, e.cap, e.rev);\n        if (e.cap == 0) {\n          const auto& f = (*this)[e.dst][e.rev];\n          if (f.cap == 0) continue;\n          fprintf(stderr, \"%zu -> %zu\\n\", e.src, e.dst);\n        }\n      }\n  }\n};\n\ntemplate <class Tp>\nTp max_flow(graph<Tp>& g, size_t s, size_t t, Tp f0 = inf<Tp>()) {\n  Tp flow = Tp(0);\n  std::vector<size_t> iter, cost;\n\n  auto distance = [&](size_t s) {\n    std::vector<size_t> res(g.size(), inf<size_t>());\n    std::queue<size_t> q;\n    res[s] = 0;\n    q.emplace(s);\n    while (!q.empty()) {\n      size_t v = q.front();\n      q.pop();\n      for (const auto& e: g[v]) {\n        if (static_cast<Tp>(0) < e.cap && res[e.dst] == inf<size_t>()) {\n          res[e.dst] = res[v] + 1;\n          q.push(e.dst);\n        }\n      }\n    }\n    return res;\n  };\n\n  std::function<Tp (size_t, Tp)> augment = [&](size_t v, Tp f)->Tp {\n    if (v == t) return f;\n    for (size_t& i = iter[v]; i < g[v].size(); ++i) {\n      Edge<Tp>& e = g[v][i];\n      if (Tp(0) < e.cap && cost[v] < cost[e.dst]) {\n        Tp d = augment(e.dst, std::min(f, e.cap));\n        if (Tp(0) < d) {\n          e.cap -= d;\n          g[e.dst][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return static_cast<Tp>(0);\n  };\n\n  while (true) {\n    cost = distance(s);\n    if (cost[t] == inf<size_t>()) return flow;\n    iter.assign(g.size(), 0);\n    Tp f;\n    while (Tp(0) < (f = augment(s, f0))) {\n      flow += f;\n      f0 -= f;\n      if (!f0) return flow;\n    }\n  }\n}\n\nint main() {\n  size_t N, E, Q;\n  scanf(\"%zu %zu %zu\", &N, &E, &Q);\n\n  graph<intmax_t> g(N);\n  std::set<std::pair<size_t, size_t>> es0;\n  for (size_t i = 0; i < E; ++i) {\n    size_t F, T;\n    scanf(\"%zu %zu\", &F, &T);\n    --F;\n    --T;\n    g.connect_with(F, T, 1);\n    es0.insert(std::minmax(F, T));\n  }\n\n  std::vector<std::tuple<int, size_t, size_t>> qs;\n  std::set<std::pair<size_t, size_t>> es;\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    scanf(\"%d %zu %zu\", &M, &A, &B);\n    --A;\n    --B;\n    if (A > B) std::swap(A, B);\n    qs.emplace_back(M, A, B);\n    if (!es0.count(std::make_pair(A, B)))\n      es.emplace(A, B);\n  }\n\n  for (const auto& e: es) {\n    size_t s, d;\n    std::tie(s, d) = e;\n    g.connect_with(s, d, 0);\n  }\n\n  // g.inspect();\n  intmax_t first = max_flow(g, 0, N-1);\n  // fprintf(stderr, \"first: %jd\\n\", first);\n\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    std::tie(M, A, B) = qs[i];\n    intmax_t df = 0;\n\n    // g.inspect();\n\n    if (M == 1) {\n      // connect\n      // fprintf(stderr, \"+ %zu %zu\\n\", A, B);\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        e.cap = 1;\n        g[B][e.rev].cap = 1;\n        df = max_flow(g, 0, N-1);\n        break;\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n\n    if (M == 2) {\n      // disconnect\n      // fprintf(stderr, \"- %zu %zu\\n\", A, B);\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        if (e.cap > 0 && g[B][e.rev].cap > 0) {\n          e.cap = 0;\n          g[B][e.rev].cap = 0;\n          break;\n        }\n\n        if (A != 0) {\n          max_flow(g, A, 0, 1L);\n        }\n        if (B != N-1) {\n          max_flow(g, N-1, B, 1L);\n        }\n        e.cap = 0;\n        g[B][e.rev].cap = 0;\n        df += max_flow(g, 0, N-1)-1;\n        break;\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n  }\n\n  // g.inspect();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a))return 0;\n\t\t\t\tif(!flow(b, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b))return 0;\n\t\t\t\tif(!flow(a, 1))return 0;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nbool modify(Graph& g,int p,int v,int sink,int flow)\n{\n\t//dump(mp(p,v));\n\tif(v==sink) return true;\n\tfor(int i=g.head[v];i!=-1;i=g.next[i]){\n\t\tif(g.es[i].dst!=p && g.es[i].flow==-flow){\n\t\t\tif(modify(g,g.es[i].src,g.es[i].dst,sink,flow)){\n\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n,m,q;cin>>n>>m>>q && n|m|q;){\n\t\t//dump(vi({n,m,q}));\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg.AddEdge(u,v,1,1);\n\t\t}\n\t\trep(_,q){\n\t\t\tint t,u,v; cin>>t>>u>>v; u--,v--;\n\t\t\tif(t==1){\n\t\t\t\tg.AddEdge(u,v,1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint i;\n\t\t\t\tfor(i=g.head[u];i!=-1;i=g.next[i])\n\t\t\t\t\tif(g.es[i].dst==v && g.es[i].cap==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\tg.es[i].cap=g.es[i^1].cap=0;\n\t\t\t\tif(g.es[i].flow){\n\t\t\t\t\tint flow=g.es[i].flow;\n\t\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\t\tmodify(g,u,v,n-1,-flow);\n\t\t\t\t\tmodify(g,v,u,0,flow);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDinic(g,0,n-1);\n\t\t\t//for(int i=0;i<n;i++){\n\t\t\t//\tprintf(\"%d:\",i);\n\t\t\t//\tfor(int j=g.head[i];j!=-1;j=g.next[j]){\n\t\t\t//\t\tEdge e=g.es[j];\n\t\t\t//\t\tprintf(\" (%d,%d/%d)\",e.dst,e.flow,e.cap);\n\t\t\t//\t}\n\t\t\t//\tputs(\"\");\n\t\t\t//}\n\t\t\tint res=0;\n\t\t\tfor(int j=g.head[0];j!=-1;j=g.next[j])\n\t\t\t\tres+=g.es[j].flow;\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    if(s==t)return 0;\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1);\n}\n\nvoid q2(int a,int b){\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n\n        if(e.type==0||e.to!=b)continue;\n        if(e.cap){\n            e.cap=0;\n            e.type=0;\n            continue;\n        }\n\n        e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n\n        if(max_flow(a,b))continue;\n\n        max_flow(a,0);max_flow(N-1,b);\n        f--;\n    }\n\n    f+=max_flow(0,N-1);\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);q1(b,a);\n        }\n        else{\n            q2(a,b);q2(b,a);\n        }\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define MAX_N 500\nstruct Edge {\n  int to, cap, rev;\n  Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Dinic {\npublic:\n  vector<Edge> G[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n\n  pair<int, int> add_edge(int from, int to, int cap) {\n    G[from].pb(Edge(to, cap, (int)G[to].size()));\n    G[to].pb(Edge(from, 0, (int)G[from].size() - 1));\n    return make_pair(G[from].size()-1, G[to].size()-1);\n  }\n\n  void bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int x = q.front(); q.pop();\n      for (int i=0; i<G[x].size(); i++) {\n        Edge &e = G[x][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[x] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int x, int t, int f) {\n    if (x == t) return f;\n    for (int &i=iter[x]; i<G[x].size(); i++) {\n      Edge &e = G[x][i];\n      if (e.cap > 0 && level[x] < level[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t, int lim=INF) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      while (lim) {\n        int f = dfs(s, t, lim);\n        if (f <= 0) break;\n        flow += f;\n        if (f >= INF || flow >= INF) return INF;\n      }\n    }\n  }\n};\n\nint N, E, Q;\nDinic dinic;\npair<int, int> G[500][500];\n\nint rem(int s, int t) {\n  Edge *e = &dinic.G[s][G[s][t]._1], *rev = &dinic.G[t][G[s][t]._2];\n  if (rev->cap == 0) {\n    e->cap = rev->cap = 0;\n    return 0;\n  }\n  if (rev->cap == 0) return 0;\n  if (dinic.max_flow(s, t, 1) > 0) {\n    e->cap = rev->cap = 0;\n    return 0;\n  }\n  dinic.max_flow(N-1, 0, 1);\n  assert(dinic.max_flow(s, t, 1));\n  e->cap = rev->cap = 0;\n  return -1;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> E >> Q;\n  rep(i, N) rep(j, N) if (i != j) G[i][j] = dinic.add_edge(i, j, 0);\n  rep(i, E) {\n    int f, t;\n    cin >> f >> t;\n    f--, t--;\n    dinic.G[f][G[f][t]._1].cap++;\n    dinic.G[t][G[t][f]._1].cap++;\n  }\n  int f = dinic.max_flow(0, N-1);\n  rep(i, Q) {\n    int m, a, b;\n    cin >> m >> a >> b;\n    a--, b--;\n    if (m == 1) {\n      dinic.G[a][G[a][b]._1].cap++;\n      dinic.G[b][G[b][a]._1].cap++;\n      f += dinic.max_flow(0, N-1);\n    }\n    else {\n      if (dinic.G[b][G[a][b]._2].cap == 0) swap(a, b);\n      f += rem(b, a);\n      f += rem(a, b);\n    }\n    cout << f << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 20005;\nconst F MAXF = 1<<29;\n\nstruct MaxFlow {\n    F cap[2*MAXE], flow[2*MAXE];\n    int V, E, level[MAXV], edge[MAXV];\n    int prev[2*MAXE], to[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]] = mf.flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.cap[e] - mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    if (prev[t] == -1) return 0;\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]]++;\n        mf.flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = mf.edge[s]; e != -1; e = mf.prev[e])\n        if (mf.to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) mf.cap[e] = mf.cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            mf.cap[e] = mf.cap[e^1] = 0;\n            if (mf.flow[e] != 0) {\n                f--;\n                if (mf.flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                mf.flow[e] = mf.flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    edge(){}\n    edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}\n  };\n\n  vector< vector<edge> > graph;\n  vector<int> level, iter;\n\n  Dinic(int V):graph(V), level(V), iter(V){}\n  \n  pair<int, int> add_edge(int f, int t, int cap, bool bi = false)\n  {\n    graph[f].push_back(edge(t, cap, graph[t].size()));\n    graph[t].push_back(edge(f, (bi ? cap : 0), graph[f].size()-1));\n    return make_pair(graph[f].size()-1, graph[t].size()-1);\n  }\n  void bfs(int s)\n  {\n    fill(all(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : graph[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < graph[v].size(); i++) {\n      edge& e = graph[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t, int exf = inf)\n  {\n    int flow = 0;\n    while(exf) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(all(iter), 0);\n      int f;\n      while(exf && (f = dfs(s, t, exf)) > 0) flow += f, exf -= (exf != inf);\n    }\n    return flow;\n  }\n};\n\nint N, E, Q;\nvector< tuple<int, int, int> > query;\nint conn[505][505];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  memset(conn, -1, sizeof(conn));\n  while(E--) {\n    int f, t;\n    cin >> f >> t; f--, t--;\n    tie(conn[f][t], conn[t][f]) = graph.add_edge(f, t, 1, true);\n  }\n  while(Q--) {\n    int m, a, b;\n    cin >> m >> a >> b; a--, b--;\n    query.emplace_back(m, a, b);\n    if(m == 1 && !~conn[a][b]) {\n      tie(conn[a][b], conn[b][a]) = graph.add_edge(a, b, 0, true);\n    }\n  }\n\n  int s = 0, t = N-1; \n  int mxf = graph.max_flow(s, t);\n  \n  for(auto q : query) {\n    int m, a, b;\n    tie(m, a, b) = q;\n    if(m == 1) {\n      graph.graph[a][conn[a][b]].cap = graph.graph[b][conn[b][a]].cap = 1;\n      mxf += graph.max_flow(0, N-1);\n    } else if(m == 2) {\n      int cap = graph.graph[a][conn[a][b]].cap;\n      graph.graph[a][conn[a][b]].cap = graph.graph[b][conn[b][a]].cap = 0;\n      // cap == 1 : didn't use\n      if(cap == 0) { // used a -> b\n\tif(!graph.max_flow(a, b, 1)) {\n\t  graph.max_flow(t, b, 1);\n\t  graph.max_flow(a, s, 1);\n\t  mxf--; \t  \n\t}\n      } else if(cap == 2) { // used b -> a\n\tif(!graph.max_flow(b, a, 1)) {\n\t  graph.max_flow(t, a, 1);\n\t  graph.max_flow(b, s, 1);\n\t  mxf--; \t  \n\t}\n      }\n    }\n    cout << mxf << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 21005;\nconst F MAXF = 1<<29;\n\nF cap[2*MAXE], flow[2*MAXE];\nint level[MAXV], edge[MAXV], seen[MAXV], to[2*MAXE], prev[2*MAXE];\n\nstruct MaxFlow {\n    int V, E;\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        seen[s] = 1;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == 0 && level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            memset(seen, 0, sizeof(seen));\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(seen, -1, sizeof(seen)); seen[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == -1 && flow[e] > 0) {\n                seen[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    for (int v = t; v != seen[v]; v = seen[v]) {\n        flow[use_edge[v]] = flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(seen, -1, sizeof(seen)); seen[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == -1 && cap[e] - flow[e] > 0) {\n                seen[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    if (seen[t] == -1) return 0;\n    for (int v = t; v != seen[v]; v = seen[v]) {\n        flow[use_edge[v]]++;\n        flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = edge[s]; e != -1; e = prev[e])\n        if (to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) cap[e] = cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            assert(e >= 0);\n            cap[e] = cap[e^1] = 0;\n            if (flow[e] != 0) {\n                f--;\n                if (flow[e] < 0) swap(A, B);\n                // calc_path(0, A, mf);\n                // calc_path(B, N-1, mf);\n                augment_path(A, 0, mf);\n                augment_path(N-1, B, mf);\n                flow[e] = flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t//cout << v << ' ' << e.to << ' ' << e.cap << endl;\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\tauto& e = G[a][edge[a][b]];\n\t\t\tauto& re = G[b][e.rev];\n\n\t\t\te.cap = re.cap = 1;\t\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\tauto e = G[a][edge[a][b]];\n\t\t\tint d = e.cap;\n\t\t\te.cap = G[b][e.rev].cap = 0;\n\t\t\tif(d == 1) return 0;\n\t\t\tif(d == 2){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(a, s, 1);\n\t\t\t}else{\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(b, a, 1)) return 0;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, a, 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(b, s, 1);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tint subCapacity_(int s, int t, int a, int b){\n\t\t\t//cout << \"SUB\" << endl;\n\t\t\t//if(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\t//cout << a << ' ' << b << endl;\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\tif(ab.cap >= 1){\n\t\t\t\t//cout << \"WY\" << endl;\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\t//cout << \"HE\" << endl;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcout << \"OUT\" << endl;\n\n\t\t\t\t//for(auto i : G){\n\t\t\t\t//\tfor(auto j : i){\n\t\t\t\t//\t\tcout << j.to << ' ' << j.cap << ' ' << j.rev << endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint ans = dfs(a, s, 1);\n\t\t\t\t//show(ans)\n\t\t\t\t//assert(ans == 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tdfs(t, b, 1);\n\t\t\t\t//assert(dfs(t, b, 1) == 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = 0, t = n - 1;\n\t//flow.addEdge(s, 0, INF);\n\t//flow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tint com, a, b;\n\t\tcin >> com >> a >> b;\n\t\ta--; b--;\n\n\t\tif(com == 1){\n\t\t\tif(use[a][b]){\n\t\t\t\tans += flow.addCapacity(s, t, a, b);\n\t\t\t}else{\n\t\t\t\tuse[a][b] = use[b][a] = true;\n\t\t\t\tflow.addEdge(a, b, 1);\n\t\t\t\tflow.addEdge(b, a, 1);\n\t\t\t\tans += flow.fordFulkerson(s, t);\n\t\t\t}\n\t\t}else{\n\n\t\t\tans += flow.subCapacity(s, t, a, b);\n\t\t}\n\t\t//assert(flow.fordFulkerson(s, t) == 0);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define MAX_N 500\nclass Dinic {\npublic:\n  struct Edge { int to, cap, rev; };\n  vector<Edge> G[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n\n  void add_edge(int from, int to, int cap) {\n    G[from].pb((Edge) { to, cap, (int)G[to].size() });\n    G[to].pb((Edge) { from, 0, (int)G[from].size() - 1 });\n  }\n\n  void bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int x = q.front(); q.pop();\n      for (int i=0; i<G[x].size(); i++) {\n        Edge &e = G[x][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[x] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int x, int t, int f) {\n    if (x == t) return f;\n    for (int &i=iter[x]; i<G[x].size(); i++) {\n      Edge &e = G[x][i];\n      if (e.cap > 0 && level[x] < level[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      int f;\n      while (true) {\n        f = dfs(s, t, INF);\n        if (f <= 0) break;\n        flow += f;\n        if (flow >= INF) return INF;\n      }\n    }\n  }\n};\n\nint N, E, Q;\nbool G[500][500];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> E >> Q;\n  rep(i, E) {\n    int f, t;\n    cin >> f >> t;\n    f--, t--;\n    G[f][t] = G[t][f] = 1;\n  }\n  rep(i, Q) {\n    int m, a, b;\n    cin >> m >> a >> b;\n    a--, b--;\n    G[a][b] = G[b][a] = m%2;\n    Dinic dinic;\n    rep(i, N) rep(j, N) if (G[i][j]) dinic.add_edge(i, j, 1);\n    cout << dinic.max_flow(0, N-1) << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=1;\n    G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=0;\n    G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        int &c = G[v][i];\n        if(!used[i]&&c>0){\n            int d=dfs(i,t,min(f,c));\n            if(d>0){\n                c-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    cin>>V>>E>>Q;\n    f(i,E){\n        cin>>F>>T;\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n            now+=max_flow(0,V-1);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(V-1,b,1);\n                    now--;\n                }\n            }\n        }\n        cout<<now<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    vector<bool>used;\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n    \n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int backflow(int v,int t,int f){\n        used = vector<bool>(n,false);\n        int res = __backflow(v,t,f);\n        return res;\n    }\n    int __backflow(int v,int t, int f) {\n        if(v==t)return f;\n        used[v]=1;\n        for(int i=0;i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(used[e.to]||e.cap<=0) continue;\n            int d = __backflow(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n    }\n    int res = fl.getmaxflow(0,N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            \n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                \n                // edge is not used\n                //   cout << \"false\" << endl;\n                \n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.backflow(b, a, 1) == 0){\n                    fl.backflow(N-1, a, 1);\n                    fl.backflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.backflow(a, b, 1) == 0){\n                    fl.backflow(N-1, b, 1);\n                    fl.backflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1,INF);\n        cout  << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nint n, m, q, a, b, c;\n\nconst int MAXV = 555;\nclass FordFulkerson {\nprivate:\n\tstruct edge {int to, cap, rev;};\n\tvector<edge> g[MAXV];\n\tbool used[MAXV];\n\tint flow;\npublic:\n\tvoid add_edge(int from, int to, int cap = 1) {\n\t\tg[from].push_back((edge){to, cap, (int)g[to].size()});\n\t\tg[to].push_back((edge){from, cap, (int)g[from].size()-1});\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\tedge &e = g[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint getflow(int s, int t) {\n\t\twhile (1) {\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint f = dfs(s,t,1<<30);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\tvoid del_edge(int from, int to) {\n\t\tint x, y;\n\t\trep(i,g[from].size()) if (g[from][i].to==to) x = i;\n\t\trep(i,g[to].size()) if (g[to][i].to==from) y = i;\n\t\t//cout << g[from][x].cap << ' ' << g[to][y].cap << endl;\n\t\tif (g[from][x].cap && g[to][y].cap) {\n\t\t\tg[from][x].cap = g[to][y].cap = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (g[to][y].cap==0) swap(from,to), swap(x,y);\n\t\tg[to][y].cap = 0;\n\t\tif (dfs(from,to,1)) return;\n\t\tif (flow) flow--;\n\t\t//memset(used,0,sizeof(used));\n\t\t//int f = dfs(from,to,1);\n\t\t//if (f) return;\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(from,0,1);\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(n-1,to,1);\n\t}\n\tvoid debug() {\n\t\tcout << \"### DEBUG START ###\" << endl;\n\t\trep(i,10) each(j,g[i]) {\n\t\t\tcout << i << \"->\" << j.to << ' ' << j.cap << endl;\n\t\t}\n\t\tcout << \"### DEBUG END ###\" << endl << endl;\n\t}\n};\n\nFordFulkerson ff;\n\nsigned main() {\n\tcin >> n >> m >> q;\n\trep(i,m) {\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tff.add_edge(a,b);\n\t}\n\twhile (q--) {\n\t\tcin >> c >> a >> b;\n\t\ta--, b--;\n\t\tif (c==1) ff.add_edge(a,b);\n\t\telse ff.del_edge(a,b);\n\t\tcout << ff.getflow(0,n-1) << endl;\n\t\t//ff.debug();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct FordFulkerson{\n  int n;\n  vector< vector<edge> > graph;\n  vi use;\n\n  FordFulkerson(int a=0):n(a){\n    graph.resize(a); use.resize(a);\n  }\n\n  void init_use(void){fill(all(use),0);}\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g && graph[s][e].cost>0){\n\tid = e; rev = graph[s][e].rev;\n      }\n    }\n    if(id<0)return;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n\n    edge e = graph[s][id];\n    if(id+1!=(int)graph[s].size())graph[e.to][e.rev].rev = id;\n    e = graph[g][rev];\n    if(rev+1!=(int)graph[g].size())graph[e.to][e.rev].rev = rev;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    use[v] = 1;\n    rep(i,graph[v].sz){\n      edge &e = graph[v][i];\n      if(!use[e.to] && e.cap > 0){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      init_use();\n      int f = dfs(s,t,INF);\n      if(!f)return res;\n      res += f;\n    }\n  }\n};\n\nint main(){\n  int n,E,q;\n  cin >> n >> E >> q;\n  FordFulkerson mf(n);\n  rep(i,E){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    mf.AddEdge(f,t,1,1);\n    mf.AddEdge(t,f,1,1);\n  }\n\n  int F = mf.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      mf.AddEdge(a,b,1,1);\n      mf.AddEdge(b,a,1,1);\n      F += mf.max_flow(0,n-1);\n    }else{\n      int use = 0;\n      for(edge e : mf.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap == 0)use |= 1;\n      }\n      for(edge e : mf.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap == 0)use |= 2;\n      }\n      mf.DeleteEdge(a,b);\n      mf.DeleteEdge(b,a);\n\n      if(use==1 || use==2){\n\trep(i,n)mf.use[i] = 0;\n\tint another = 0;\n\tif(use==1)another = mf.dfs(a,b,1);\n\tif(use==2)another = mf.dfs(b,a,1);\n\n\tif(!another){\n\t  mf.init_use();\n\t  mf.dfs(use==1?a:b,0,1);\n\t  mf.init_use();\n\t  mf.dfs(n-1,use==1?b:a,1);\n\t  F--;\n\t}\n      }\n    }\n\n    cout << F << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,E,Q;\nint G[500][500];\nbool visited[500];\nint dfs(int pos,int ti,int f){\n  if(pos==ti)return f;\n  if(visited[pos])return 0;\n  visited[pos]=true;\n  for(int i=0;i<N;i++){\n    int e=G[pos][i];\n    if(e==0)continue;\n    int k=dfs(i,ti,min(f,e));\n    if(k==0)continue;\n    G[pos][i]-=k;\n    G[i][pos]+=k;\n    return k;\n  }\n  return 0;\n}\nint ans;\nvoid maxflow(int si,int ti){\n  ans=0;\n  while(1){\n    memset(visited,false,sizeof(visited));\n    int f=dfs(si,ti,1e9);\n    if(f==0)break;\n    ans+=f;\n  }\n}\n\nint main(){\n  cin>>N>>E>>Q;\n  for(int i=0;i<E;i++){\n    int F,T;\n    cin>>F>>T;\n    F--,T--;\n    G[F][T]++;\n    G[T][F]++;\n  }\n\n  maxflow(0,N-1);\n  for(int i=0;i<Q;i++){\n    int M,A,B;\n    cin>>M>>A>>B;\n    A--,B--;\n    \n    if(M==1){\n      G[A][B]++;\n      G[B][A]++;\n      memset(visited,false,sizeof(visited));\n      ans+=dfs(0,N-1,1e9);\n    }else{\n\n      if(G[A][B]>0){\n        G[A][B]--;\n      }else{\n        G[B][A]--;\n        memset(visited,false,sizeof(visited));\n        dfs(N-1,B,1);\n        memset(visited,false,sizeof(visited));\n        dfs(A,0,1);\n        ans--;\n        memset(visited,false,sizeof(visited));\n        ans+=dfs(0,N-1,1);\n      }\n\n      if(G[B][A]>0){\n        G[B][A]--;\n      }else{\n        G[A][B]--;\n        memset(visited,false,sizeof(visited));\n        dfs(N-1,A,1);\n        memset(visited,false,sizeof(visited));\n        dfs(B,0,1);\n        ans--;\n        memset(visited,false,sizeof(visited));\n        ans+=dfs(0,N-1,1);\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n#define delete_vec(v,n); v.erase(remove(v.begin(),v.end(),n),v.end());\n\nint N,E,Q;\nvector<vector<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    int to = edge[from][i];\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(b);\n  edge[b].push_back(a);\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  delete_vec(edge[a],b);\n  delete_vec(edge[b],a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n    }\n    f--;\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    //*/\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tmap<P,int> m;\n\tint DFS(int v,int t,int f,vi& used,bool b){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0&&(!b||e.cap==2)){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),used,b);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tm[{s,t}]=g[s].size();\n\t\tg[s].push_back(edge{t,1,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,1,(int)g[s].size()-1});\n\t}\n\tint Max_Flow(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi used(V);\n\t\t\tint f=DFS(s,t,1,used,0);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n\tint Add(int u,int v){\n\t\tadd_edge(u,v);\n\t\tvi used(V);\n\t\treturn DFS(0,V-1,inf,used,0);\n\t}\n\tint Erase(int u,int v,int ind){\n\t\tint I=m[{u,v}],J=g[u][I].rev,C=g[u][I].cap;\n\t\tif(C==1){\n\t\t\tg[u][I].cap=0;\n\t\t\tg[v][J].cap=0;\n\t\t\treturn 0;\n\t\t}\n\t\tvi used(V);\n\t\tDFS((C?v:u),0,1,used,1);\n\t\tused=vi(V);\n\t\tDFS(V-1,(C?u:v),1,used,1);\n\t\tg[u][I].cap=0;\n\t\tg[v][J].cap=0;\n\t\tused=vi(V);\n\t\treturn 1-DFS(0,V-1,1,used,0);\n\t}\n};\n\nint n,m,q;\n\nint main(){\n\tcin>>n>>m>>q;\n\tNetwork nt(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tnt.add_edge(u,v);\n\t}\n\tint res=nt.Max_Flow(0,n-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t,u,v;\n\t\tcin>>t>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tif(t==1) res+=nt.Add(u,v);\n\t\telse res-=nt.Erase(u,v,i);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nint cap[500][500] = {0};\nvoid addEdge(int from, int to) {\n\tcap[from][to] = cap[to][from] = 1;\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!used[i] && cap[s][i] > 0) {\n\t\t\tint d = dfs(i, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs2(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!used[i] && cap[s][i] > 1) {\n\t\t\tint d = dfs2(i, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n/*\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tif (s == to && !flag) return false;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (s == from && i != to) continue;\n\t\tbool nf = flag || (s == from && i == to);\n\t\tif (!used2[i][(int)nf] && cap[s][i] > 0) {\n\t\t\tbool f = dfs2(i, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n*/\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tif (cap[a][b] > 1) {\n\t\treturn removeEdge(b, a);\n\t}\n\telse {\n\t\tint c = cap[a][b];\n\t\tcap[a][b] = cap[b][a] = 0;\n\t\tif (c < 1) {\n\t\t\tmemset(used, false, sizeof(used)); int x = dfs2(N-1, b);\n\t\t\tmemset(used, false, sizeof(used)); int y = dfs2(a, 0);\n\t\t\tif (x + y < 2) {\n\t\t\t\tcout << x << \" \" << y << endl;\n\t\t\t\texit(1);\n\t\t\t}\n//\t\t\tfill(&used2[0][0], &used2[0][0]+500*2, false);\n//\t\t\tif ( !dfs2(N-1, 0, b, a, false) ) {\n//\t\t\t\tcout << \"ERROR\" << endl;\n//\t\t\t\twhile (1);\n//\t\t\t}\n\t\t\tres = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tmemset(used, false, sizeof(used)); f += dfs(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\nvector<edge>E[500];\nbool used[500];\nint d[500][500];\nvoid add_edge(int from, int to, int cap) {\n\tE[from].push_back({ to,cap,(int)E[to].size() });\n\tE[to].push_back({ from,cap,(int)E[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = 1;\n\tfor (edge&e : E[v]) {\n\t\tif (used[e.to] || !e.cap)continue;\n\t\tint d = dfs(e.to, t, min(e.cap, f));\n\t\tif (d > 0) {\n\t\t\te.cap -= d; E[e.to][e.rev].cap += d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\nint maxflow(int s, int t, int l = INT_MAX) {\n\tint res = 0;\n\twhile (l) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, l);\n\t\tif (f == 0)break;\n\t\tres += f; l -= f;\n\t}\n\treturn res;\n}\nint m[1000], a[1000], b[1000];\nint main() {\n\tint n, e, q; scanf(\"%d%d%d\", &n, &e, &q);\n\tmemset(d, -1, sizeof(d));\n\trep(i, e) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); a--; b--;\n\t\tadd_edge(a, b, 1);\n\t\td[a][b] = E[a].size() - 1;\n\t\td[b][a] = E[b].size() - 1;\n\t}\n\trep(i, q) {\n\t\tscanf(\"%d%d%d\", &m[i], &a[i], &b[i]); a[i]--; b[i]--;\n\t\tif (~d[a[i]][b[i]])continue;\n\t\tadd_edge(a[i], b[i], 0);\n\t\td[a[i]][b[i]] = E[a[i]].size() - 1;\n\t\td[b[i]][a[i]] = E[b[i]].size() - 1;\n\t}\n\tint ans = maxflow(0, n - 1);\n\trep(i, q) {\n\t\tif (m[i] == 1) {\n\t\t\tE[a[i]][d[a[i]][b[i]]].cap = E[b[i]][d[b[i]][a[i]]].cap = 1;\n\t\t\tans += maxflow(0, n - 1);\n\t\t\tprintf(\"%d\\n\", ans); continue;\n\t\t}\n\t\tif (E[a[i]][d[a[i]][b[i]]].cap == 2)swap(a[i], b[i]);\n\t\tif (E[a[i]][d[a[i]][b[i]]].cap == 0) {\n\t\t\tif (maxflow(a[i], b[i], 1))continue;\n\t\t\tmaxflow(n - 1, b[i], 1);\n\t\t\tmaxflow(a[i], 0, 1);\n\t\t\tans--;\n\t\t}\n\t\tE[a[i]][d[a[i]][b[i]]].cap = E[b[i]][d[b[i]][a[i]]].cap = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define MAX_N 500\nstruct Edge {\n  int to, cap, rev;\n  Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Dinic {\npublic:\n  vector<Edge> G[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n\n  pair<int, int> add_edge(int from, int to, int cap) {\n    G[from].pb(Edge(to, cap, (int)G[to].size()));\n    G[to].pb(Edge(from, 0, (int)G[from].size() - 1));\n    return make_pair(G[from].size()-1, G[to].size()-1);\n  }\n\n  void bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int x = q.front(); q.pop();\n      for (int i=0; i<G[x].size(); i++) {\n        Edge &e = G[x][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[x] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int x, int t, int f) {\n    if (x == t) return f;\n    for (int &i=iter[x]; i<G[x].size(); i++) {\n      Edge &e = G[x][i];\n      if (e.cap > 0 && level[x] < level[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t, int lim=INF) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      while (lim) {\n        int f = dfs(s, t, lim);\n        if (f <= 0) break;\n        flow += f;\n        if (f >= INF || flow >= INF) return INF;\n      }\n    }\n  }\n};\n\nint N, E, Q;\nDinic dinic;\npair<int, int> G[500][500];\n\nint rem(int s, int t) {\n  Edge *e = &dinic.G[s][G[s][t]._1], *rev = &dinic.G[t][G[s][t]._2];\n  if (rev->cap == 0) {\n    e->cap = rev->cap = 0;\n    return 0;\n  }\n  e->cap = rev->cap = 0;\n  if (dinic.max_flow(s, t, 1) > 0) return 0;\n  dinic.max_flow(N-1, 0, 1);\n  dinic.max_flow(s, t, 1);\n  return -1;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> E >> Q;\n  rep(i, E) {\n    int f, t;\n    cin >> f >> t;\n    f--, t--;\n    G[f][t] = dinic.add_edge(f, t, 1);\n    G[t][f] = dinic.add_edge(t, f, 1);\n  }\n  int f = dinic.max_flow(0, N-1);\n  rep(i, Q) {\n    int m, a, b;\n    cin >> m >> a >> b;\n    a--, b--;\n    if (m == 1) {\n      G[a][b] = dinic.add_edge(a, b, 1);\n      G[b][a] = dinic.add_edge(b, a, 1);\n      f += dinic.max_flow(0, N-1);\n    }\n    else {\n      f += rem(a, b);\n      f += rem(b, a);\n    }\n    cout << f << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint n;\nvector<vector<Edge> > edges;\nvector<bool> used;\n\nint dfs(int s, int t, int f){\n    if(s == t)\n        return f;\n    used[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 0){\n            int g = dfs(e.to, t, min(f, e.cap));\n            if(g > 0){\n                e.cap -= g;\n                edges[e.to][e.rev].cap += g;\n                return g;\n            }\n        }\n    }\n    return 0;\n}\n\nint flow(int s, int t){\n    used.assign(n+1, false);\n    return dfs(s, t, INT_MAX);\n}\n\nbool dfs2(int s, int t){\n    if(s == t)\n        return true;\n    used[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 1){\n            if(dfs2(e.to, t)){\n                -- e.cap;\n                ++ edges[e.to][e.rev].cap;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid flowBack(int s, int t){\n    used.assign(n+1, false);\n    dfs2(s, t);\n}\n\nint main()\n{\n    int e, q;\n    cin >> n >> e >> q;\n\n    edges.assign(n+1, vector<Edge>());\n    for(int i=0; i<e; ++i){\n        int f, t;\n        cin >> f >> t;\n        edges[f].push_back(Edge(t, 1, edges[t].size()));\n        edges[t].push_back(Edge(f, 1, edges[f].size()-1));\n    }\n\n    int ret = 0;\n    for(;;){\n        int f = flow(1, n);\n        if(f == 0)\n            break;\n        ret += f;\n    }\n\n    for(int i=0; i<q; ++i){\n        int m, a, b;\n        cin >> m >> a >> b;\n        if(m == 1){\n            unsigned j = 0;\n            while(j < edges[a].size() && edges[a][j].to != b)\n                ++ j;\n            if(j < edges[a].size()){\n                edges[a][j].cap = 1;\n                edges[b][edges[a][j].rev].cap = 1;\n            }else{\n                edges[a].push_back(Edge(b, 1, edges[b].size()));\n                edges[b].push_back(Edge(a, 1, edges[a].size()-1));\n            }\n            ret += flow(1, n);\n        }else{\n            unsigned j = 0;\n            while(edges[a][j].to != b)\n                ++ j;\n            if(edges[a][j].cap == 1){\n                edges[a][j].cap = 0;\n                edges[b][edges[a][j].rev].cap = 0;\n            }else{\n                if(edges[a][j].cap == 0){\n                    edges[b][edges[a][j].rev].cap = 0;\n                    flowBack(a, 1);\n                    flowBack(n, b);\n                }else{\n                    edges[a][j].cap = 0;\n                    flowBack(b, 1);\n                    flowBack(n, a);\n                }\n                -- ret;\n                ret += flow(1, n);\n            }\n        }\n        cout << ret << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to|| x.cap + G[to][x.rev].cap != cap  || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t\tflow.add_edge(t, f, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cap, rev;\n  Edge(int u, int v, int c, int r) :\n    src(u), dst(v), cap(c), rev(r) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nbool used[500];\nbool used2[500][2];\nint dfs(int u, int t, int f){\n  if(u == t) return f;\n  used[u] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0 && !used[e->dst]){\n      int d = dfs(e->dst, t, min(f, e->cap));\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint dfs2(int u, int t, int f, int b, int A, int B){\n  if(u == t){\n    if(b == 1) return f;\n    else return 0;\n  }\n  used2[u][b] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0){\n      int nb = b;\n      if(e->src == A && e->dst == B) nb = 1;\n      if(used2[e->dst][nb]) continue;\n      int d = dfs2(e->dst, t, min(f, e->cap), nb, A, B);\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nvoid max_flow(int &flow, int S, int T){\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(S, T, INF);\n    if(f == 0) return;\n    flow += f;\n  }\n}\nvoid add_edge(int u, int v){\n  G[u].push_back(Edge(u, v, 1, G[v].size()));\n  G[v].push_back(Edge(v, u, 1, G[u].size() - 1));\n}\n\nint main(){\n  int N, E, Q;\n  while(cin >> N >> E >> Q){\n    G = Graph(N);\n    REP(i, E){\n      int A, B;\n      cin >> A >> B;\n      A--; B--;\n      add_edge(A, B);\n    }\n    int S = 0, T = N - 1;\n    int flow = 0;\n    max_flow(flow, S, T);\n    REP(i, Q){\n      int M, A, B;\n      cin >> M >> A >> B;\n      A--; B--;\n      if(M == 1){\n        add_edge(A, B);\n        max_flow(flow, S, T);\n      }else{\n        FORIT(e, G[A])if(e->dst == B && e->cap == 2){\n          // B -> A : now \n          //printf(\"find %d -> %d flow\\n\", B, A);\n          memset(used2, 0, sizeof(used2));\n          assert(dfs2(T, S, 1, 0, A, B) == 1);\n          flow--;\n          goto ERASE;\n        }\n        FORIT(e, G[B])if(e->dst == A && e->cap == 2){\n          //printf(\"find %d -> %d flow\\n\", A, B);\n          memset(used2, 0, sizeof(used2));\n          assert(dfs2(T, S, 1, 0, B, A) == 1);\n          flow--;\n          goto ERASE;\n        }\n        ERASE:\n          FORIT(e, G[A]) if(e->dst == B) { G[A].erase(e); break; }\n          FORIT(e, G[B]) if(e->dst == A) { G[B].erase(e); break; }\n        FLOW:\n          max_flow(flow, S, T);\n      }\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 2000;\nconst int IINF = INT_MAX;\ntypedef pair<int,int> ii;\n\nmap<ii,int> mp; /////////\n\nstruct Edge{ int to,cap,rev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  assert( mp.count(ii(from,to)) == 0 );\n  mp[ii(from,to)] = (int)G[from].size();\n  G[from].push_back((Edge){to,cap,G[to].size()});\n  G[to].push_back((Edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,IINF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(); }\n\nint V,E,Q;\n\n\ninline void remove_edge(int u,int v){\n  G[u][mp[ii(u,v)]].cap = 0;\n  G[v][G[u][mp[ii(u,v)]].rev].cap = 0;\n  G[v][mp[ii(v,u)]].cap = 0;\n  G[u][G[v][mp[ii(v,u)]].rev].cap = 0;\n}\n\ninline bool remove(int u,int v,int source,int sink){\n  //Back:;\n  if( G[u][mp[ii(u,v)]].cap == 1 && G[v][mp[ii(v,u)]].cap == 1 ) {\n    remove_edge(u,v);\n    return false;\n  }\n  /*\n  if( G[u][mp[ii(u,v)]].cap == 0 && G[v][mp[ii(v,u)]].cap == 0 ){\n    G[u][mp[ii(u,v)]].cap = 1;\n    G[v][G[u][mp[ii(u,v)]].rev].cap = 0;\n    G[v][mp[ii(v,u)]].cap = 1;\n    G[u][G[v][mp[ii(v,u)]].rev].cap = 0;\n    goto Back;\n  }\n  */\n\n  if( G[u][mp[ii(u,v)]].cap == 1 ) swap(u,v);\n  memset(used,false,sizeof(used));\n  int tmp = dfs(u,v,IINF);\n  bool ret = false;\n  if( tmp == 0 ) {\n    memset(used,false,sizeof(used));\n    tmp = dfs(sink,source,1);\n    memset(used,false,sizeof(used));\n    tmp = dfs(u,v,1);\n    assert(tmp);\n    ret = true;\n  } \n  remove_edge(u,v);\n  return ret;\n}\n\nint main(){\n\n  set<ii> S;\n  scanf(\"%d %d %d\",&V,&E,&Q);\n  rep(i,E){\n    int F,T;\n    scanf(\"%d %d\",&F,&T);\n    --F, --T;\n    add_edge(F,T,1);\n    add_edge(T,F,1);\n    if( F > T ) swap(F,T);\n    S.insert(ii(F,T));\n  }\n  int source = 0, sink = V-1;\n  int cur_flow = max_flow(source,sink);\n  rep(_,Q){\n    //cout << \"query : \" << _ << \" \";\n    int M,A,B;\n    scanf(\"%d %d %d\",&M,&A,&B);\n    --A, --B;\n    if( A > B ) swap(A,B);\n    if( M == 1 ) { // 接続\n      int F = A, T = B;\n      if( S.count(ii(F,T)) ) {\n        int pos = IINF;\n        G[A][mp[ii(A,B)]].cap = 1;\n        G[B][G[A][mp[ii(A,B)]].rev].cap = 0;\n        G[B][mp[ii(B,A)]].cap = 1;\n        G[A][G[B][mp[ii(B,A)]].rev].cap = 0;\n      } else {\n        add_edge(A,B,1);\n        add_edge(B,A,1);\n        S.insert(ii(F,T));\n      }\n      memset(used,false,sizeof(used));\n      cur_flow += dfs(source,sink,IINF);\n    } else {       // 切断\n      bool res = remove(A,B,source,sink); //| remove(B,A,source,sink);\n      if( res ) cur_flow--;\n    }\n    printf(\"%d\\n\",cur_flow);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    used[v]=true;\n    if(v==t)return f;\n    for(auto &e:G[v]){\n        if(e.cap==0||used[e.to])continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\nstruct test{\n    int x;\n};\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    int f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            add_edge(a,b,1);\n            add_edge(b,a,1);\n            f+=max_flow(0,N-1);\n        }\n        else{\n            rep(beet,2){\n                for(int i=0;i<G[a].size();i++){\n                    if(G[a][i].type==0||G[a][i].to!=b)continue;\n                    if(G[a][i].cap==1){\n                        G[a][i].cap=0;\n                        G[a][i].type=0;\n                        continue;\n                    }\n\n                    int t=max_flow(a,b);\n                    if(t==1){\n                        G[a][i].type=0;\n                        G[G[a][i].to][G[a][i].rev].cap=0;\n                        continue;\n                    }\n\n                    add_edge(0,N-1,1);\n                    t=max_flow(a,b);\n\n                    f--;\n                    G[0].pop_back();G[N-1].pop_back();\n\n                    G[a][i].type=0;\n                    G[G[a][i].to][G[a][i].rev].cap=0;\n                }\n\n                f+=max_flow(0,N-1);\n                swap(a,b);\n            }\n        }\n\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Capacity cap;\n\tEdge(int s, int d, Capacity c) : src(s), dst(d), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tCapacity solve(int s, int t, int lim) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, lim));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tFordFulkerson ff(N + 2);\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tff.addEdge(a, b, 1);\n\t\tff.addEdge(b, a, 1);\n\t}\n\tint S = N, T = N + 1;\n\tff.addEdge(S, 0, 10000000);\n\tff.addEdge(N - 1, T, 10000000);\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tff.addEdge(A[i], B[i], 0);\n\t\tff.addEdge(B[i], A[i], 0);\n\t}\n\tint f = ff.solve(S, T, ff.inf);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tff.addEdge(u, v, 1);\n\t\t\tff.addEdge(v, u, 1);\n\t\t\tf += ff.solve(0, N - 1, 1);\n\t\t}\n\t\telse {\n\t\t\tint uv = ff.flow[u][v], vu = ff.flow[v][u];\n\t\t\tff.cap[u][v] = ff.cap[v][u] = 0;\n\t\t\tff.flow[u][v] = ff.flow[v][u] = 0;\n\n\t\t\tif(uv > vu) {\n\t\t\t\tif(ff.solve(u, v, 1) == 0) {\n\t\t\t\t\tff.solve(u, S, 1);\n\t\t\t\t\tff.solve(T, v, 1);\n\t\t\t\t\tf--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(vu > uv) {\n\t\t\t\tif(ff.solve(v, u, 1) == 0) {\n\t\t\t\t\tff.solve(v, S, 1);\n\t\t\t\t\tff.solve(T, u, 1);\n\t\t\t\t\tf--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,P> idx;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  idx[P(from,to)].second=G[to].size();\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n  idx[P(from,to)].first=G[from].size()-1;\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int X){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, X);\n    if(f == 0)return flow;\n    flow += f;\n    if(X==1)return flow;\n  }\n}\n\nint main(){\n  int n,e,q,a,b,m;\n  cin>>n>>e>>q;\n  for(int i=0;i<e;i++){\n    cin>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    add_edge(a,b,1);\n  }\n  int ans=max_flow(0,n-1,INF);\n  for(int i=0;i<q;i++){\n    cin>>m>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    if(m==1){\n      add_edge(a,b,1);\n      ans+=max_flow(0,n-1,1);\n    }else{\n      P x=idx[P(a,b)];\n      int s=-1,t=-1;\n      if(!G[a][x.first].cap)s=a,t=b;\n      if(!G[b][x.second].cap)s=b,t=a;\n      G[a][x.first].cap=0;\n      G[b][x.second].cap=0;\n      if(s>=0&&t>=0){\n\tint r=max_flow(s,t,1);\n\tif(!r){\n\t  ans--;\n\t  if(s!=0)max_flow(s,0,1);\n\t  if(t!=n-1)max_flow(n-1,t,1);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct FordFulkerson{\n  int n;\n  vector< vector<edge> > graph;\n  vi use;\n\n  FordFulkerson(int a=0):n(a){\n    graph.resize(a); use.resize(a);\n  }\n\n  void init_use(void){fill(all(use),0);}\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g && graph[s][e].cost>0){\n\tid = e; rev = graph[s][e].rev; break;\n      }\n    }\n    if(id<0)return;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n\n    edge e = graph[s][id];\n    if(id+1!=(int)graph[s].size())graph[e.to][e.rev].rev = id;\n    e = graph[g][rev];\n    if(rev+1!=(int)graph[g].size())graph[e.to][e.rev].rev = rev;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    use[v] = 1;\n    rep(i,graph[v].sz){\n      edge &e = graph[v][i];\n      if(!use[e.to] && e.cap > 0){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      init_use();\n      int f = dfs(s,t,INF);\n      if(!f)return res;\n      res += f;\n    }\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,E,q;\n  cin >> n >> E >> q;\n  FordFulkerson mf(n);\n  rep(i,E){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    mf.AddEdge(f,t,1,1);\n    mf.AddEdge(t,f,1,1);\n  }\n\n  int F = mf.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      mf.AddEdge(a,b,1,1);\n      mf.AddEdge(b,a,1,1);\n      F += mf.max_flow(0,n-1);\n    }else{\n      int use = 0;\n      for(edge e : mf.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap == 0){\n\t  use |= 1; break;\n\t}\n      }\n      for(edge e : mf.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap == 0){\n\t  use |= 2; break;\n\t}\n      }\n      mf.DeleteEdge(a,b);\n      mf.DeleteEdge(b,a);\n\n      if(use==1 || use==2){\n\trep(i,n)mf.use[i] = 0;\n\tint another = 0;\n\tif(use==1)another = mf.dfs(a,b,1);\n\tif(use==2)another = mf.dfs(b,a,1);\n\n\tif(!another){\n\t  mf.init_use();\n\t  mf.dfs(use==1?a:b,0,1);\n\t  mf.init_use();\n\t  mf.dfs(n-1,use==1?b:a,1);\n\t  F--;\n\t}\n      }\n    }\n\n    cout << F << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\nvector<edge>E[500];\nbool used[500];\nint d[500][500];\nvoid add_edge(int from, int to, int cap) {\n\tE[from].push_back({ to,cap,(int)E[to].size() });\n\tE[to].push_back({ from,cap,(int)E[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = 1;\n\tfor (edge&e : E[v]) {\n\t\tif (used[e.to] || !e.cap)continue;\n\t\tint d = dfs(e.to, t, min(e.cap, f));\n\t\tif (d > 0) {\n\t\t\te.cap -= d; E[e.to][e.rev].cap += d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\nint maxflow(int s, int t, int l = INT_MAX) {\n\tint res = 0;\n\twhile (l) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, l);\n\t\tif (f == 0)break;\n\t\tres += f; l -= f;\n\t}\n\treturn res;\n}\nint m[1000], a[1000], b[1000];\nint main() {\n\tint n, e, q; scanf(\"%d%d%d\", &n, &e, &q);\n\tmemset(d, -1, sizeof(d));\n\trep(i, e) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); a--; b--;\n\t\tadd_edge(a, b, 1);\n\t\td[a][b] = E[a].size() - 1;\n\t\td[b][a] = E[b].size() - 1;\n\t}\n\trep(i, q) {\n\t\tscanf(\"%d%d%d\", &m[i], &a[i], &b[i]); a[i]--; b[i]--;\n\t\tif (~d[a[i]][b[i]])continue;\n\t\tadd_edge(a[i], b[i], 0);\n\t\td[a[i]][b[i]] = E[a[i]].size() - 1;\n\t\td[b[i]][a[i]] = E[b[i]].size() - 1;\n\t}\n\tint ans = maxflow(0, n - 1);\n\trep(i, q) {\n\t\tif (m[i] == 1) {\n\t\t\tE[a[i]][d[a[i]][b[i]]].cap = E[b[i]][d[b[i]][a[i]]].cap = 1;\n\t\t\tans += maxflow(0, n - 1);\n\t\t\tprintf(\"%d\\n\", ans); continue;\n\t\t}\n\t\tif (E[a[i]][d[a[i]][b[i]]].cap == 2)swap(a[i], b[i]);\n\t\tif (E[a[i]][d[a[i]][b[i]]].cap == 0) {\n\t\t\tif (maxflow(a[i], b[i], 1))goto g;\n\t\t\tmaxflow(n - 1, b[i], 1);\n\t\t\tmaxflow(a[i], 0, 1);\n\t\t\tans--;\n\t\t}\n\tg:;\n\t\tE[a[i]][d[a[i]][b[i]]].cap = E[b[i]][d[b[i]][a[i]]].cap = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        graph[e.to][e.rev].alive = false;\n        if(e.cap == 0) {\n          max_flow(graph.size() - 1, to, 1);\n          max_flow(from, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else if(graph[e.to][e.rev].cap == 0) {\n          max_flow(graph.size() - 1, from, 1);\n          max_flow(to, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      // flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 0){\n                // edge is not used\n            }\n            //  edge: a -> b is used\n           else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.getmaxflow(N-1, a, 1);\n                    fl.getmaxflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.getmaxflow(N-1, b, 1);\n                    fl.getmaxflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n  if(v==t)\n    return f;\n  used[v]=true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    bool b=false;\n    // Ü¾ü«ªÜÁÄ¢È¢ÈçA±±Åè\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ¡ñ¬·t[Ìü«É¶ÄeÊðt]\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // t[ª¬¹È©Á½êÍAÜÁÄ¢È©Á½±ÆÉ·é\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint one_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  fill(used,used+MAX_V,false);\n  int f=dfs(s,t,INF);\n  return f;\n}\n\n\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // »ÝÜÅÌÅå¬ÊðßÄ¨­\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // eNGÌãÌ¬Êðßé\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ÂÈ®\n    if(m==1){\n      add_edge(a,b,1);\n      // Ä¬o\n      cFlow+=max_flow(1,n);\n    }\n    // Øf·é\n    else{\n      // ØfÓªÜ¾Êß³êÄ¢È¢ê\n      if(!isDirected[a][b]){\n\t//cout<<cFlow<<endl;\n\tfor(int j = 0; j < G[a].size(); j++){\n\t  if(G[a][j].to==b){\n\t    edge &e=G[a][j];\n\t    G[a].erase(G[a].begin()+j);\n\t    G[b].erase(G[b].begin()+e.rev);\n\t    isDirected[a][b]=false;\n\t    isDirected[b][a]=false;\n\t    break;\n\t  }\n\t}\n\tcontinue;\n      }\n      // t[ª·ÅÉ¬êÄ¢½êA\n      // ðð½·æ¤Ét[ðµß·\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ü«ÍÜÁÄ¢éª¬Ê0\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    //cout<<\"from a to b\"<<endl;\n\t    ff+=one_flow(a,b);\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    ff+=one_flow(b,a);\n\t  }\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  int f=0;\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b){\n\t      f+=one_flow(n,b);\n\t    }\n\t    else\n\t      f++;\n\t    \n\t    if(a!=1){\n\t      f+=one_flow(a,1);\n\t    }\n\t    else\n\t      f++;\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    if(a!=1){\n\t      f+=one_flow(1,a);\n\t    }\n\t    else\n\t      f++;\n\t    if(b!=n){\n\t      f+=one_flow(b,n);\n\t    }\n\t    else\n\t      f++;\n\t  }\n\t  //cout<<\"head \"<<f<<endl;\n\t  if(f>=2)\n\t    cFlow--;\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a].erase(G[a].begin()+idx);\n      G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\n//const int INF = 2147483647;\n//const long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\n\nconst Weight INF =INT_MAX/2;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//??????0??????????????????????????¨??£???????±??????????????????§??¨???\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ZERO));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n,ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]){\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc = v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;;\n\t\ttotal += inc;\n\t}\n\n\treturn total;\n}\n\nint main()\n{\n\tint N,E,Q;cin>>N>>E>>Q;\n\tGraph g(N);\n\tint s=0;\n\tint t=N-1;\n\t{\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tg[a].push_back(Edge{ a,b,1 });\n\t\t\tg[b].push_back(Edge{ b,a,1 });\n\t\t}\n\t}\n\n\tint n = g.size();\n\tMatrix flow(n, Array(n, ZERO)), capacity(n, Array(n, ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] = capacity[e->src][e->dst] + e->weight;\n\n\tWeight now_sum=0;\n\t{\n\t\tWeight total = ZERO;\n\t\twhile (1) {\n\t\t\tqueue<int> Q; Q.push(s);\n\t\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\t\tint u = Q.front(); Q.pop();\n\t\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\t\tprev[e->dst] = u;\n\t\t\t\t\tQ.push(e->dst);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\t\tWeight inc = INF;\n\t\t\tfor (int j = t; prev[j] != j; j = prev[j]) {\n\t\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\t\tif (inc > v) {\n\t\t\t\t\tinc = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\t\tflow[prev[j]][j] = flow[prev[j]][j] + inc, flow[j][prev[j]] = flow[j][prev[j]] - inc;;\n\t\t\ttotal += inc;\n\t\t}\n\t\tnow_sum=total;\n\t}\n\t\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint at,a,b;cin>>at>>a>>b;\n\t\ta--;b--;\n\t\t//connect\n\t\tif (at == 1) {\n\t\t\tcapacity[a][b]=1;\n\t\t\tcapacity[b][a]=1;\n\t\t\tif (find_if(g[a].begin(), g[a].end(), [&](const Edge&e) {\n\t\t\t\treturn e.dst == b;\n\t\t\t}) == g[a].end()) {\n\t\t\t\tg[a].push_back(Edge(a,b,1));\n\t\t\t\tg[b].push_back(Edge(b,a,1));\n\t\t\t}\n\t\t\tWeight total=0;\n\t\t\twhile (1) {\n\t\t\t\tqueue<int> Q; Q.push(s);\n\t\t\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\t\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\t\t\tint u = Q.front(); Q.pop();\n\t\t\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\t\t\tprev[e->dst] = u;\n\t\t\t\t\t\tQ.push(e->dst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\t\t\tWeight inc = INF;\n\t\t\t\tfor (int j = t; prev[j] != j; j = prev[j]) {\n\t\t\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\t\t\tif (inc > v) {\n\t\t\t\t\t\tinc = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\t\t\tflow[prev[j]][j] = flow[prev[j]][j] + inc, flow[j][prev[j]] = flow[j][prev[j]] - inc;;\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t\tnow_sum+=total;\n\t\t}\n\t\t//disconnect\n\t\telse {\n\t\t\tif (flow[a][b] == -1) {\n\t\t\t\tswap(a,b);\n\t\t\t}\n\t\t\tauto it = find_if(g[a].begin(), g[a].end(), [&](const Edge&e) {\n\t\t\t\treturn e.dst==b;\n\t\t\t});\n\t\t\tg[a].erase(it);\n\t\t\tg[b].erase(find_if(g[b].begin(), g[b].end(), [&](const Edge&e) {\n\t\t\t\treturn e.dst==a;\n\t\t\t}));\n\n\t\t\tcapacity[a][b] = 0;\n\t\t\tcapacity[b][a] = 0;\n\t\t\tif (flow[a][b]==1) {\n\t\t\t\t{\n\t\t\t\t\tqueue<int>que;\n\t\t\t\t\tvector<int>prevs(N,-1);\n\t\t\t\t\tque.push(s);\n\t\t\t\t\tprevs[s]=-2;\n\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\tconst int now = que.front();\n\t\t\t\t\t\tif (now == a)break;\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\t\t\tif (flow[now][next]==1&&prevs[next]==-1) {\n\t\t\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t\t\t\tprevs[next] = now;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tassert(prevs[a]!=-1);\n\t\t\t\t\tint nn(a);\n\t\t\t\t\twhile (prevs[nn] != -2) {\n\t\t\t\t\t\tint pr=prevs[nn];\n\t\t\t\t\t\tflow[pr][nn]=0;\n\t\t\t\t\t\tflow[nn][pr]=0;\n\t\t\t\t\t\tnn=pr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tqueue<int>que;\n\t\t\t\t\tvector<int>prevs(N, -1);\n\t\t\t\t\tque.push(b);\n\t\t\t\t\tprevs[b]=-2;\n\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\tconst int now = que.front();\n\t\t\t\t\t\tif (now ==t)break;\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\t\t\tif (flow[now][next]==1&&prevs[next]==-1) {\n\t\t\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t\t\t\tprevs[next] = now;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tassert(prevs[t] != -1);\n\t\t\t\t\tint nn(t);\n\t\t\t\t\twhile (prevs[nn] != -2) {\n\t\t\t\t\t\tint pr = prevs[nn];\n\t\t\t\t\t\tflow[pr][nn] = 0;\n\t\t\t\t\t\tflow[nn][pr]=0;\n\t\t\t\t\t\tnn = pr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tflow[a][b]=0;\n\t\t\t\tflow[b][a]=0;\n\t\t\t\tcapacity[a][b]=0;\n\t\t\t\tcapacity[b][a]=0;\n\n\t\t\t\tWeight total = 0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tqueue<int> Q; Q.push(s);\n\t\t\t\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\t\t\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\t\t\t\tint u = Q.front(); Q.pop();\n\t\t\t\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\t\t\t\tprev[e->dst] = u;\n\t\t\t\t\t\t\tQ.push(e->dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\t\t\t\tWeight inc = INF;\n\t\t\t\t\tfor (int j = t; prev[j] != j; j = prev[j]) {\n\t\t\t\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\t\t\t\tif (inc > v) {\n\t\t\t\t\t\t\tinc = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\t\t\t\tflow[prev[j]][j] = flow[prev[j]][j] + inc, flow[j][prev[j]] = flow[j][prev[j]] - inc;;\n\t\t\t\t\ttotal += inc;\n\t\t\t\t}\n\t\t\t\tnow_sum += total-1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x=0;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tcout << now_sum << endl;\n\t}\n\t{\n\n\t}\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint N, E, Q;\nint cap[500][500];\nbool used[500];\nint dfs(int u, int t, int f){\n    if(u == t) return f;\n    used[u] = true;\n    REP(v, N)if(!used[v] && cap[u][v] > 0){\n        int d = dfs(v, t, min(f, cap[u][v]));\n        if(d > 0){\n            cap[u][v] -= d;\n            cap[v][u] += d;\n            return d;\n        }\n    }\n    return 0;\n}\nint main(){\n    while(cin >> N >> E >> Q && N){\n        memset(cap, 0, sizeof cap);\n        REP(_, E){\n            int F, T;\n            cin >> F >> T;\n            F--; T--;\n            cap[F][T] = 1;\n            cap[T][F] = 1;\n        }\n        int flow = 0;\n        REP(_, Q){\n            int M, A, B;\n            cin >> M >> A >> B;\n            A--; B--;\n            if(M == 1){ // add edge\n                assert(cap[A][B] == 0 && cap[B][A] == 0); // assert no edge\n                cap[A][B] = cap[B][A] = 1; // add edge\n            }else{ // delete edge\n                if(cap[A][B] == 2) swap(A, B);\n                if(cap[B][A] == 2 && dfs(A, B, 1) == 1){ // remove cycle\n                    cap[B][A] = cap[A][B] = 1;\n                }\n                if(cap[B][A] == 2){ // flowing 0->A->B->N-1\n                    assert(flow > 0);\n                    memset(used, 0, sizeof used);\n                    assert(dfs(N - 1, 0, 1) == 1); // N-1 -> 0\n                    flow--;\n                }\n                if(cap[B][A] == 2){ // remove cycle\n                    memset(used, 0, sizeof used);\n                    assert(dfs(A, B, 1) == 1);\n                    cap[B][A]--;\n                    cap[A][B]++;\n                }\n                assert(cap[A][B] == 1 && cap[B][A] == 1); // assert no flowing\n                cap[A][B] = cap[B][A] = 0; // remove edge\n            }\n            // update flow\n            while(true){\n                memset(used, 0, sizeof used);\n                int f = dfs(0, N - 1, 2);\n                if(f == 0) break;\n                flow += f;\n            }\n            cout << flow << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << e.cap << ' ' << re.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\tshow(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * F-F ??????????????¨?????????????????¨\n */\ntemplate<int V>\nstruct MaxFlow {\n    struct Edge {\n        int to, rev, cap;\n    };\n    vector<Edge> g[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    /// ??????????????¨?????????, ??????1??????2????????????????????????????????????\n    void add_multi(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    int erase(int from, int to) {\n        for (int i = 0; i < (int)g[from].size(); i++) {\n            auto e = g[from][i];\n            if (e.to == to && e.cap + g[to][e.rev].cap) {\n                int c = g[to][e.rev].cap - e.cap;\n                g[to][e.rev].cap = 0;\n                g[from][i].cap = 0;\n                return c;\n            }\n        }\n        assert(false);\n    }\n\n    bool used[V];\n    bool dfs(int s, int t) {\n        if (s == t) return true;\n        used[s] = true;\n        for (auto &e : g[s]) {\n            if (used[e.to]) continue;\n            if (!e.cap) continue;\n            if (dfs(e.to, t)) {\n                e.cap -= 1;\n                g[e.to][e.rev].cap += 1;\n                return true;\n            }\n        }\n        return false;\n    }\n    int exec(int s, int t, int F) {\n        int f = 0;\n        while (f < F) {\n            fill_n(used, V, false);\n            if (!dfs(s, t)) break;\n            f++;\n        }\n        return f;\n    }\n    void print() {\n        int ec = 0, cs = 0;\n        for (int i = 0; i < V; i++) {\n            for (auto &e: g[i]) {\n                ec++;\n                cs += e.cap;\n            }\n        }\n    }\n};\n\nMaxFlow<550> mf;\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t; f--; t--;\n        mf.add_multi(f, t, 1);\n    }\n    int f = 0;\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b; a--; b--;\n        if (m == 1) {\n            mf.add_multi(a, b, 1);\n        } else {\n            int u = mf.erase(a, b);\n            if (u) {\n                if (u == -2) swap(a, b);\n                f--;\n                assert(mf.exec(n-1, b, 1));\n                assert(mf.exec(a, 0, 1));\n            }\n        }\n        f += mf.exec(0, n-1, 100000);\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * F-F ??????????????¨?????????????????¨\n */\ntemplate<int V>\nstruct MaxFlow {\n    struct Edge {\n        int to, rev, cap;\n    };\n    vector<Edge> g[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    /// ??????????????¨?????????, ??????1??????2????????????????????????????????????\n    void add_multi(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    int erase(int from, int to) {\n        for (int i = 0; i < (int)g[from].size(); i++) {\n            auto e = g[from][i];\n            if (e.to == to && e.cap + g[to][e.rev].cap) {\n                int c = g[to][e.rev].cap - e.cap;\n                g[to][e.rev].cap = 0;\n                g[from][i].cap = 0;\n                return c;\n            }\n        }\n        assert(false);\n    }\n\n    bool used[V];\n    bool dfs(int s, int t) {\n        if (s == t) return true;\n        used[s] = true;\n        for (auto &e : g[s]) {\n            if (used[e.to]) continue;\n            assert(e.cap >= 0);\n            if (!e.cap) continue;\n            if (dfs(e.to, t)) {\n                e.cap -= 1;\n                g[e.to][e.rev].cap += 1;\n                return true;\n            }\n        }\n        return false;\n    }\n    int exec(int s, int t, int F) {\n        int f = 0;\n        while (f < F) {\n            fill_n(used, V, false);\n            if (!dfs(s, t)) break;\n            f++;\n        }\n        return f;\n    }\n    void print() {\n        int ec = 0, cs = 0;\n        for (int i = 0; i < V; i++) {\n            for (auto &e: g[i]) {\n                if (e.cap + g[e.to][e.rev].cap == 0) continue;\n                ec++;\n                cs += e.cap;\n                printf(\"%d %d %d\\n\", i, e.to, e.cap);\n            }\n        }\n        printf(\"print %d\\n\", ec);\n    }\n};\n\nMaxFlow<550> mf;\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t; f--; t--;\n        mf.add_multi(f, t, 1);\n    }\n    int f = 0;\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b; a--; b--;\n        if (m == 1) {\n            mf.add_multi(a, b, 1);\n        } else {\n            int u = mf.erase(a, b);\n//            mf.print();\n//            printf(\"erase %d %d %d\\n\", a, b, u);\n            if (u) {\n                if (u == -2) swap(a, b);\n                if (mf.exec(a, b, 1)) continue;\n                f--;\n                assert(mf.exec(n-1, b, 1));\n                assert(mf.exec(a, 0, 1));\n            }\n        }\n        f += mf.exec(0, n-1, 100000);\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G[from].size();\n  M[to][from]=G[to].size();\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,cap,G[from].size()-1));\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, int lim){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0||lim==0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,lim))>0){\n      flow+=f;\n      lim-=f;\n    }\n  }\n}\n\nint max_flow(int s,int t){\n  return max_flow(s,t,INF);\n}\n\nbool back_edge(int s,int t,int from, int to){\n  for(int i=0;i<(int)G[from].size();i++) {\n    edge& e=G[from][i];\n    if(e.to == to) {\n      if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n\tmax_flow(from, s, 1);\n\tmax_flow(t, to, 1);\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  int ans=max_flow(1,N);\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      if(M[a].find(b)==M[a].end()) add_edge(a,b,1);\n      else G[a][M[a][b]].cap=G[b][M[b][a]].cap=1;\n    }else{\n      ans-=back_edge(1,N,a,b);\n      ans-=back_edge(1,N,b,a);\n      G[a][M[a][b]].cap=G[b][M[b][a]].cap=0;\n    }\n    ans+=max_flow(1,N);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct EdgeF{\n  int to, cap, rev;\n  bool del;\n  EdgeF(int to_=0, int cap_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), rev(rev_), del(false){}\n};\nusing GraphF = vector<vector<EdgeF>>;\n\nvoid add_edge(GraphF& G, int from, int to, int cap){\n  G[from].emplace_back(to, cap, G[to].size());\n  G[to].emplace_back(from, cap, G[from].size()-1);\n}\nint max_flow(GraphF& G, int s, int t, int f = INF){\n  const int V = G.size();\n  vector<bool> used(V);\n \n  function<int(int,int,int)> dfs = [&](int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n\tREP(i,SZ(G[v])){\n\t  auto& e =  G[v][i];\n      if(!used[e.to] && e.cap > 0 && !e.del){\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  };\n  if(f < INF){\n    fill(used.begin(), used.end(), false);\n    return dfs(s, t, f);\n  }\n \n  int flow = 0;\n  while(true){\n    fill(used.begin(), used.end(), false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E, Q;\n  cin >> V >> E >> Q;\n  GraphF G(V);\n  REP(i,E){\n\tint f, t;\n\tcin >> f >> t;\n\t--f;\n\t--t;\n\tadd_edge(G, f, t, 1);\n  }\n\n  int f = max_flow(G, 0, V-1);\n  REP(q,Q){\n\tint m, a, b;\n\tcin >> m >> a >> b;\n\t--a, --b;\n\tif(m == 1){\n\t  add_edge(G, a, b, 1);\n\t  f += max_flow(G, 0, V-1);\n\t}\n\telse{\n\t  for(auto& e: G[a]){\n\t\tif(e.to == b && !e.del){\n\t\t  if(e.cap == 0 || e.cap == 2){\n\t\t\tint orig = e.cap;\n\t\t\te.cap = G[b][e.rev].cap = 0;\n\t\t\te.del = G[b][e.rev].del = true;\n\t\t\t--f;\n\t\t\tif(orig == 0){\n\t\t\t  max_flow(G, a, 0, 1);\n\t\t\t  max_flow(G, V-1, b, 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t  max_flow(G, b, 0, 1);\n\t\t\t  max_flow(G, V-1, a, 1);\n\t\t\t}\n\t\t  }\n\t\t  e.cap = G[b][e.rev].cap = 0;\n\t\t  e.del = G[b][e.rev].del = true;\n\t\t  break;\n\t\t}\n\t  }\n\t  f += max_flow(G, 0, V-1);\n\t}\n\tcout << f << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 2000;\nconst int IINF = INT_MAX;\ntypedef pair<int,int> ii;\n\nmap<ii,int> mp; /////////\n\nstruct Edge{ int to,cap,rev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  assert( mp.count(ii(from,to)) == 0 );\n  mp[ii(from,to)] = (int)G[from].size();\n  G[from].push_back((Edge){to,cap,G[to].size()});\n  G[to].push_back((Edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,IINF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(); }\n\nint V,E,Q;\n\n\ninline void remove_edge(int u,int v){\n  G[u][mp[ii(u,v)]].cap = 0;\n  G[v][G[u][mp[ii(u,v)]].rev].cap = 0;\n  G[v][mp[ii(v,u)]].cap = 0;\n  G[u][G[v][mp[ii(v,u)]].rev].cap = 0;\n}\n\ninline bool remove(int u,int v,int source,int sink){\n  Back:;\n  if( G[u][mp[ii(u,v)]].cap == 1 && G[v][mp[ii(v,u)]].cap == 1 ) {\n    remove_edge(u,v);\n    return false;\n  }\n\n  if( G[u][mp[ii(u,v)]].cap == 0 && G[v][mp[ii(v,u)]].cap == 0 ){\n    G[u][mp[ii(u,v)]].cap = 1;\n    G[v][G[u][mp[ii(u,v)]].rev].cap = 0;\n    G[v][mp[ii(v,u)]].cap = 1;\n    G[u][G[v][mp[ii(v,u)]].rev].cap = 0;\n    goto Back;\n  }\n\n\n  if( G[u][mp[ii(u,v)]].cap == 1 ) swap(u,v);\n  memset(used,false,sizeof(used));\n  int tmp = dfs(u,v,IINF);\n  bool ret = false;\n  if( tmp == 0 ) {\n    memset(used,false,sizeof(used));\n    tmp = dfs(sink,source,1);\n    memset(used,false,sizeof(used));\n    tmp = dfs(u,v,1);\n    assert(tmp);\n    ret = true;\n  } \n  remove_edge(u,v);\n  return ret;\n}\n\nint main(){\n\n  set<ii> S;\n  scanf(\"%d %d %d\",&V,&E,&Q);\n  rep(i,E){\n    int F,T;\n    scanf(\"%d %d\",&F,&T);\n    --F, --T;\n    add_edge(F,T,1);\n    add_edge(T,F,1);\n    if( F > T ) swap(F,T);\n    S.insert(ii(F,T));\n  }\n  int source = 0, sink = V-1;\n  int cur_flow = max_flow(source,sink);\n  rep(_,Q){\n    //cout << \"query : \" << _ << \" \";\n    int M,A,B;\n    scanf(\"%d %d %d\",&M,&A,&B);\n    --A, --B;\n    if( A > B ) swap(A,B);\n    if( M == 1 ) { // 接続\n      int F = A, T = B;\n      if( S.count(ii(F,T)) ) {\n        int pos = IINF;\n        G[A][mp[ii(A,B)]].cap = 1;\n        G[B][G[A][mp[ii(A,B)]].rev].cap = 0;\n        G[B][mp[ii(B,A)]].cap = 1;\n        G[A][G[B][mp[ii(B,A)]].rev].cap = 0;\n      } else {\n        add_edge(A,B,1);\n        add_edge(B,A,1);\n        S.insert(ii(F,T));\n      }\n      memset(used,false,sizeof(used));\n      cur_flow += dfs(source,sink,IINF);\n    } else {       // 切断\n      bool res = remove(A,B,source,sink); //| remove(B,A,source,sink);\n      if( res ) cur_flow--;\n    }\n    printf(\"%d\\n\",cur_flow);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim=INF){\n    if(s==t)return 1;\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    add_edge(b,a,1);\n    f+=max_flow(0,N-1);\n}\n\nvoid q2(int a,int b){\n\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.type==1&&e.to==b){\n            f1=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n    for(auto &e:G[b]){\n        if(e.type==1&&e.to==a){\n            f2=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n\n\n    if(f1==f2)return;\n\n    if(f1){\n        assert(max_flow(N-1,b,1)&&max_flow(a,0,1));\n    }\n    if(f2){\n        assert(max_flow(N-1,a,1)&&max_flow(b,0,1));\n    }\n    f--;\n    f+=max_flow(0,N-1);\n}\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.type==1&&e.cap==0)cout<<i+1<<\" \"<<e.to+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            // Flow tmpcap=e.cap,tmprevcap=reve.cap;\n            \n            e.cap =0;reve.cap = 0;\n            //(1) S <- s <- t <- T の最大パスを求める\n            Flow fs = max_flow(s,S,d);\n            Flow ft = max_flow(T,t,d);\n            Flow f = min(fs,ft);\n            //(1).1 流しすぎた分戻す\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) 残り(d-f)は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n\n            // // s <- t 分 d戻す\n            // e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n            // // 減らす\n            // e.cap-=e.icap - c;\n            // assert(e.cap==0);assert(reve.cap == c+reve.icap);\n            \n            e.cap=0;reve.cap=c + reve.icap;\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(){}\n\tEdge(int s, int d, int c)\n\t\t:src(s), dst(d), cst(c)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint flow[502][502],capa[502][502];\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=capa[p][next]-flow[p][next];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]+=f;\n\t\t\tflow[next][p]-=f;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n//流量を制限するdinic\nint dinic(int S, int T, int L, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end && total < L)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\n\t\t\t\tint next=e.dst;\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]-flow[n][next] <= 0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, L, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t\tif(total >= L) break;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int t, int v, Graph& g)\n{\n\tg[s].push_back(Edge(s,t,v));\n\tg[t].push_back(Edge(t,s,v));\n\n\tcapa[s][t] += v;\n\tcapa[t][s] += v;\n}\n\nvoid add_pass(int s, int t, Graph& g)\n{\n\tg[s].push_back(Edge(s,t,0));\n\tg[t].push_back(Edge(t,s,0));\n}\n\nvoid reduce_cap(int s, int t, int v, Graph& g)\n{\n\tcapa[s][t] -= v;\n\tcapa[t][s] -= v;\n}\n\nvoid add_cap(int s, int t, int v, Graph& g)\n{\n\tcapa[s][t] += v;\n\tcapa[t][s] += v;\n}\n\nvoid solve(int N, Graph& g, vector<Edge>& queries)\n{\n\tint f = dinic(0,N-1,INF,g);\n\tfor(int i=0; i<queries.size(); i++)\n\t{\n\t\tEdge &e = queries[i];\n\n\t\tif(e.cst == 1) {\n\t\t\tadd_cap(e.src, e.dst, 1, g);\n\t\t\tf += dinic(0,N-1,1,g);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(flow[e.src][e.dst] == 0) \n\t\t\t{\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile(flow[e.src][e.dst] != 0) {\n\t\t\t\t\tf -= dinic(N-1,0,1,g);\n\t\t\t\t}\n\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t\tf += dinic(0,N-1,INF,g);\n\n\t\t\t}\n\t\t}\n\n\t\tcout << f << endl;\n\t}\n}\n\nint main()\n{\n\tint N,E,Q;\n\tcin >> N >> E >> Q;\n\n\tmemset(flow, 0, sizeof(flow));\n\tmemset(capa, 0, sizeof(capa));\n\n\tGraph g(N);\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\tadd_edge(s,t,1,g);\n\t}\n\n\tvector<Edge> queries(Q);\n\n\tfor(int i=0; i<Q; i++)\n\t{\n\t\tint m,s,t;\n\t\tcin >> m >> s >> t;\n\t\ts--; t--;\n\t\tqueries[i] = Edge(s,t,m);\n\t\tif(capa[s][t] == 0) add_pass(s,t,g);\n\t}\n\n\tsolve(N, g, queries);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef int flow_t;\n\nconst int MAX_N = 500;\nconst int MAX_E = 20000;\nconst int MAX_Q = 1000;\n\nstruct edge{\n\tint tar;\n\tflow_t cap;\n\tbool on;\n};\n\nstruct query{\n\tint cmd;\n\tint x, y;\n};\n\nint V, E, Q;\nvector<edge> graph[MAX_N];\nint id_table[MAX_N][MAX_N];\nquery qs[MAX_Q];\n\nvoid add_edge(int x, int y, flow_t cap, bool on){\n\tid_table[x][y] = graph[x].size();\n\tid_table[y][x] = graph[y].size();\n\tgraph[x].push_back((edge){y, cap, on});\n\tgraph[y].push_back((edge){x, cap, on});\n}\n\nvoid init(){\n\tscanf(\"%d%d%d\", &V, &E, &Q);\n\tmemset(id_table, -1, sizeof(id_table));\n\tfor(int i=0; i<E; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--; y--;\n\t\tadd_edge(x, y, 1, true);\n\t}\n\n\tfor(int i=0; i<Q; i++){\n\t\tint c, x, y;\n\t\tscanf(\"%d%d%d\", &c, &x, &y);\n\t\tx--; y--;\n\t\tqs[i] = (query){c, x, y};\n\t\tif(id_table[x][y] == -1){\n\t\t\tadd_edge(x, y, 0, false);\n\t\t}\n\t}\n\n}\n\nbool visited[MAX_N];\nint vis_time[MAX_N];\n\nbool dfs(int v, int sink){\n\tif(v == sink){\n\t\treturn true;\n\t}\n\tvisited[v] = true;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0 && !visited[e.tar] && dfs(e.tar, sink)){\n\t\t\te.cap--;\n\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rem_dfs(int v){\n\tvis_time[v] = 2;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0){\n\t\t\tif(vis_time[e.tar] == 1 || (vis_time[e.tar] == 0 && rem_dfs(e.tar))){\n\t\t\t\te.cap--;\n\t\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool remove_cycle(int x, int y){\n\tmemset(vis_time, 0, sizeof(vis_time));\n\tvis_time[y] = 1;\n\treturn rem_dfs(x);\n}\n\nvoid solve(){\n\tconst int source = 0, sink = V - 1;\n\tflow_t current = 0;\n\n\tfor(;memset(visited, false, sizeof(visited)), dfs(source, sink); current++);\n\n\tfor(int i=0; i<Q; i++){\n\t\tif(qs[i].cmd == 1){\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tgraph[x][id_table[x][y]].on = true;\n\t\t\tgraph[y][id_table[y][x]].on = true;\n\t\t\tgraph[x][id_table[x][y]].cap = 1;\n\t\t\tgraph[y][id_table[y][x]].cap = 1;\n\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\tif(dfs(source, sink)){\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tif(graph[x][id_table[x][y]].cap != 1){\n\t\t\t\t// ツ個サツ催敖づ郊 -> yツづ猟ャツづェツづつ「ツづゥツづヲツつ、ツづ可暗ェツ氾環可サ\n\t\t\t\tif(graph[x][id_table[x][y]].cap == 2){\n\t\t\t\t\tswap(x, y);\n\t\t\t\t}\n\t\t\t\tif(!remove_cycle(x, y)){\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tif(dfs(sink, source)){\n\t\t\t\t\t\tcurrent--;\n\t\t\t\t\t}\n\t\t\t\t\tint cur = graph[x][id_table[x][y]].cap;\n\t\t\t\t\tif(cur != 1){\n\t\t\t\t\t\tif(cur == 2){\n\t\t\t\t\t\t\tswap(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremove_cycle(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\t\tgraph[x][id_table[x][y]].cap = 0;\n\t\t\t\tgraph[y][id_table[y][x]].cap = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", current);\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight;\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i+1 << \", \" << g[i][j].dst+1 << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\nclass FordFulkerson {\npublic:\n    Graph g; // ????????????????????????\n    int s, t; // ?§????, ??????\n    int n; // ????????°\n    ll flow = 0; // ?????§????????????????????????????????????????????????????????¨??´??°??????\n\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // ??????????????????src, dst, cap????????±?????????\n    // ????????°?????????????????????????????????\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // ?????????????????????\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // ????????°???????????????????????????????????´???????????????\n    // flow???????¨??????????\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // ????????°????????????????????????\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n    // ???????????????\n    // ????????°????????§???v??????t????????£??????????????¢?????????????????°???????????????\n    //\n    // s??????t????§???????????????????????????????????????§?????????????????????????????????0????????????\n    // f??????????????¨??????????????????\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // ?????£???????????£????????£?????????????????¢??? \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // ???????????¨???????????????????????£???????????£??????????°??????????????¬???????????????¨??????\n            if (d > 0) {\n                e.cap -= d; // ????????°?????????????????´??°\n                g[e.dst][e.rev].cap += d; // ????????°????????????????????´??°\n                return d;\n            }\n        }\n        return 0;\n    }\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // s??????t???????????§??????????????????\n    // s == t??????INF?????????, ???????????????0?????????\n    ll get(void) {\n        return flow;\n    }\n    // O(V) \n    // from??????to??????????????????cap???????????????????????????????????§???????????????\n    // ???????????????????????¨?????¨???????????£????????????????????????\n    // TODO ????¢????????????????\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // ?????¨?????¨?????£??????\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    // from??????to?????????????????????????????£?????????????????????????????´?????????\n    // ?????´??§??????????????????????????????\n    //\n    // ????????????from->to->??????->from?????¨??????????????????????????\\???????????°???\n    // from->to????????????????????????????????????????????????????????¨?????§?????????\n    // ?????????????????????????????????????????¨?????????????????????????????¨????????\\??????\n    ll erase_using_circuit(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // ???????????????????????????from??????to???????????????????????¨??????\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // ?¶????????????????????????????????????£?????¨??¨?????????????????¨??????\n            // ??????????????????????????£???????????¨??§?????????\n            while (1) { // TODO ?????????????????????????????°??????\n                // e.src?????????????????°??????????????????????????°???????????????\n                bool used[n];\n                rep(i, n) {\n                    used[i] = false;\n                }\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n//                        cout << v << \" -> \" << tmp.dst << endl;\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                /*\n                cout << e.src << \" \" << e.dst << \" \" << e_rev.cap << endl;\n                cout << can_erase << \"#can_erase\" << endl;\n                */\n                e.cap += can_erase;\n                e_rev.cap -= can_erase;\n                sum += can_erase;\n\n                if (can_erase == 0) { // ????????§????¶????????????????\n                    // TODO ??¬?????????????????\\???????????§?????¨??¨??????????¢??????????????????????????¬????????????§???????????????\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n    // O(V) \n    // from??????to?????????????????????cap???????????????????????????????????§???????????????\n    // cap???0????????£?????????????????°????????????????????????????¶??????????\n    int erase(int from, int to, ll cap) {\n        // ???????????¨????????????????????????????¶????????????????????????£???????????????????¢????\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // ?????????????????¨??????\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // ?????£????????????????????£???????°????????????????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // ??????????????????????????????from??????to??????????????????????????¨??????\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n\n\n        /*\n        cout << \"#first erase\" << endl;\n        cout << \"#prev\" << endl;\n        printGraphCap(g);\n        */\n        erase_using_circuit(from, to);\n        /*\n        cout << \"#aft\" << endl;\n        printGraphCap(g);\n        cout << can_erase << \"#can_erase\" << endl;\n        */\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n \n        // ??????cap????¶????????????¨????????????\n        // ????????°????????§???t->s???????¢???§??????cap???????????????????????????????????????flow???????°??????????\n        // ????°????????????????????????????????????????????????????????????¨???????????§??????????????¨???????????????????????????\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n//        printGraphCap(g);\n        erase_using_circuit(from, to); // ????????§from->to???????????????cap???????????????\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n    // from??????to??????????????¨?????? \n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, q; cin >> n >> e >> q;\n    Graph g(n);\n    rep(i, e) {\n        ll f, t; cin >> f >> t; f--, t--;\n        addDirected(g, f, t, 0, 1);\n        addDirected(g, t, f, 0, 1);\n    }\n    FordFulkerson ff(g, 0, n-1); \n//        printGraphCap(ff.g);\n//    printGraphCap(ff.g);\n    rep(i, q) {\n        int type, u, v; cin >> type >> u >> v; u--; v--;\n        if (type == 1) {\n            ff.add(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.add(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        } else {\n            ff.erase(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.erase(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        }\n//        printGraphCap(ff.g);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n  if(v==t)\n    return f;\n  used[v]=true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    bool b=false;\n    // Ü¾ü«ªÜÁÄ¢È¢ÈçA±±Åè\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ¡ñ¬·t[Ìü«É¶ÄeÊðt]\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // t[ª¬¹È©Á½êÍAÜÁÄ¢È©Á½±ÆÉ·é\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // »ÝÜÅÌÅå¬ÊðßÄ¨­\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // eNGÌãÌ¬Êðßé\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ÂÈ®\n    if(m==1){\n      add_edge(a,b,1);\n      // Ä¬o\n      cFlow+=max_flow(1,n);\n    }\n    // Øf·é\n    else{\n      // ØfÓªÜ¾Êß³êÄ¢È¢ê\n      if(!isDirected[a][b]){\n\tcout<<cFlow<<endl;\n\tfor(int j = 0; j < G[a].size(); j++){\n\t  if(G[a][j].to==b){\n\t    edge &e=G[a][j];\n\t    G[a].erase(G[a].begin()+j);\n\t    G[b].erase(G[b].begin()+e.rev);\n\t    break;\n\t  }\n\t}\n\tcontinue;\n      }\n      // t[ª·ÅÉ¬êÄ¢½êA\n      // ðð½·æ¤Ét[ðµß·\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ü«ÍÜÁÄ¢éª¬Ê0\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0)\n\t    ff+=max_flow(a,b);\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0)\n\t    ff+=max_flow(b,a);\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b)\n\t      max_flow(n,b);\n\t    if(a!=1)\n\t      max_flow(a,1);\n\t    cFlow--;\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    if(b!=n)\n\t      max_flow(b,n);\n\t    if(a!=1)\n\t      max_flow(1,a);\n\t    cFlow--;\n\t  }\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a].erase(G[a].begin()+idx);\n      G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\nconst int MAX_V=500,INF=1e8;\nint G[MAX_V][MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int from, int to){\n    G[from][to]=1;\n    G[to][from]=1;\n}\nvoid erase_edge(int from, int to){\n    G[from][to]=0;\n    G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(int i=0;i<V;i++){\n        int &c=G[v][i];\n        if(!used[i] && c>0){\n            int d=dfs(i,t,min(f,c));\n            if(d>0){\n                c-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int f=dfs(s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\nint main(){\n    int N,E,Q;\n    cin>>N>>E>>Q;\n    V=N;\n    rep(i,E){\n        int F,T;\n        cin>>F>>T;\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,N-1);\n    rep(i,Q){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a,b);\n            now+=max_flow(0,N-1);\n        }else{\n            int ecap=G[a][b];\n            erase_edge(a,b);\n            if(ecap>1)swap(a,b);\n            if(ecap!=1){\n                memset(used,0,sizeof(used));\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memset(used,0,sizeof(used));\n                    dfs(a,0,1);\n                    memset(used,0,sizeof(used));\n                    dfs(N-1,b,1);\n                    now--;\n                }\n            }\n        }\n        cout<<now<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    // s->t 増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[e.to][eid[e.to][s]];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    vector<vector<int>> eid;\n    MaximamFlow(int V):V(V){\n        G=Graph(V);\n        eid=vector<vector<int>>(V,vector<int>(V,-1));\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n    \tif(eid[s][t]<0){\n    \t\teid[s][t]=G[s].size();\n    \t\tG[s].push_back({t,0,0});\n    \t}\n    \tG[s][eid[s][t]].icap=cap;\n    \tG[s][eid[s][t]].cap=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        if(eid[s][t]<0)add_edge(s,t,c);\n        if(eid[t][s]<0)add_edge(t,s,c);\n\n        Edge& e =G[s][eid[s][t]];Edge& reve = G[t][eid[t][s]];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            // cerr <<\"u\"<<endl;\n        \te.cap += c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            // cerr <<\"d\"<<endl;\n        \te.cap -= e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n        \t// cerr <<\"d2\"<<endl;\n        \tFlow d = e.icap - e.cap - c;\n            // e.cap = 0;reve.cap = 0;\n            // //(1) S <- s <- t <- T のフローを戻す\n            // Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            // max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            // flow -= f;\n            // //(2) (1)で流せない分は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            // assert(max_flow(s,t,d-f)==d-f);\n\n        \tFlow revd = max_flow(s,t,d);\n            max_flow(T,S,d-revd);\n            assert(max_flow(s,t,d-revd)==d-revd);\n            flow -= d-revd;\n\n            e.cap = 0;reve.cap = c + reve.icap;\n            e.icap = c;\n        }\n        // flow+=max_flow(S,T);\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)if(es[s][t])mf.add_edge(s,t,es[s][t]);\n\n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--;\n\n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }\n        }\n\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\n\nconst int MAX_V_flow = 510;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tmap<int,int> id[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tid[from][to] = G[from].size();\n\t\tid[to][from] = G[to].size();\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , flow , G[from].size()-1 ) );\n\t}\n\t\n\tint erase_edge(int from,int to){\n\t\tint s = id[from][to];\n\t\tint t = id[to][from];\n\t\tint ret = 0;\n\t\t//cout << G[from][s].sc.fr << \" \" << G[to][t].sc.fr << endl;\n\t\tif(G[from][s].sc.fr == 2){\n\t\t\tret = 1;\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tret = min ( ret , dfs(n,from,1) );\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tret = min ( ret , dfs(to,1,1) );\n\t\t}\n\t\telse if(G[to][t].sc.fr == 2){\n\t\t\tret = 1;\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tret = min ( ret , dfs(n,to,1) );\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tret = min ( ret , dfs(from,1,1) );\n\t\t}\n\t\tG[from][s].sc.fr = 0;\n\t\tG[to][t].sc.fr = 0;\n\t\treturn ret;\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\t//printf(\"%d %d %d\\n\",v,t,f);\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\tint ret = 0,d = 1;\n\t\twhile(d > 0){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\td = dfs(s,t,INF);\n\t\t\tret += d;\n\t\t}\n\t\treturn ret;\n\t}\n}flow;\n\nint main(){\n\tint e,q;\n\tscanf(\"%d%d%d\",&n,&e,&q);\n\t\n\trep(i,e){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tflow.add_edge(f,t,1);\n\t}\n\tint ret = flow.flow(1,n);\n\trep(i,q){\n\t\tint m,a,b;\n\t\tscanf(\"%d%d%d\",&m,&a,&b);\n\t\tif(m == 1){\n\t\t\tflow.add_edge(a,b,1);\n\t\t}\n\t\telse {\n\t\t\tret -= flow.erase_edge(a,b);\n\t\t}\n\t\tret += flow.flow(1,n);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  const int INF = 1 << 30;\n\n  struct edge\n  {\n    int to, cap, rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for(int i = 0; i < graph[p].size(); i++) {\n        const edge &e = graph[p][i];\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return (min_cost[t] != -1);\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    for(int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      int f = 0;\n      while((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n          max_flow(from, 0, 1);\n          max_flow(graph.size() - 1, to, 1);\n          return (1);\n        } else {\n          return (0);\n        }\n      }\n    }\n  }\n\n};\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,rev;bool original;};\nvector<edge> graph[vmax];\nint level[vmax],iter[vmax];\n\nvoid add_edge(int from,int to,int cap){\n\tgraph[from].push_back({to,cap,(int)graph[to].size(),true});\n\tgraph[to].push_back({from,0,(int)graph[from].size()-1,false});\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<graph[v].size();i++){\n\t\tedge &e=graph[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d==0) continue;\n\t\t\te.cap-=d;graph[e.to][e.rev].cap+=d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int s,int t){\n\trep(i,vmax) level[i]=-1;\n\tqueue<int> q;\n\tlevel[s]=0,q.push(s);\n\twhile(!q.empty()){\n\t\tint v=q.front();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn level[t]>=0;\n}\n\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(bfs(s,t)){\n\t\trep(i,vmax) iter[i]=0;\n\t\twhile(1){\n\t\t\tint f=dfs(s,t,inf);\n\t\t\tif(f==0) break;\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint flow(int s,int t){\n\tif(!bfs(s,t)) return 0;\n\trep(i,vmax) iter[i]=0;\n\treturn dfs(s,t,1);\n}\n\nint add(int from,int to,int s,int t){\n\tadd_edge(from,to,1);\n\tadd_edge(to,from,1);\n\treturn flow(s,t);\n}\n\nint erase(int from,int to,int s,int t){\n\tbool ft=false,tf=false;\n\tfor(auto &e:graph[from]){\n\t\tif(e.to==to&&e.original){\n\t\t\tif(graph[e.to][e.rev].cap==1) ft=true;\n\t\t\te.cap=0,graph[e.to][e.rev].cap=0;\n\t\t}\n\t}\n\n\tfor(auto &e:graph[to]){\n\t\tif(e.to==from&&e.original){\n\t\t\tif(graph[e.to][e.rev].cap==1) tf=true;\n\t\t\te.cap=0,graph[e.to][e.rev].cap=0;\n\t\t}\n\t}\n\n\tif(!ft&&!tf) return 0;\n\tif(ft&&flow(from,to)==1) return 0;\n\tif(tf&&flow(to,from)==1) return 0;\n\n\tif(ft)flow(t,to),flow(from,s);\n\tif(tf)flow(t,from),flow(to,s);\n\treturn -1;\n}\n\n/*\nvoid show(int n){\n\trep(i,n)for(auto &e:graph[i])\n\t\tcout << i << \" -> \" <<  e.to << \" : \" << graph[e.to][e.rev].cap << endl;\n}\n*/\n\nint main(void){\n\tint n,m,q;\n\tcin >> n >> m >> q;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b ;\n\t\tadd_edge(a-1,b-1,1);\n\t\tadd_edge(b-1,a-1,1);\n\t}\n\tint sum=max_flow(0,n-1);\n\trep(loop,q){\n\t\tint type,a,b;\n\t\tcin >> type >> a >> b;\n\t\tif(type==1)\n\t\t\tsum+=add(a-1,b-1,0,n-1);\n\t\telse\n\t\t\tsum+=erase(a-1,b-1,0,n-1);\n\t\tcout << sum << endl;\n\t\t//show(n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct max_flow{\n    vector<vector<int>> graph;\n    vector<bool> done;\n    int size,flow;\n    max_flow(int size_):size(size_),graph(size_,vector<int>(size_)),done(size_),flow(0){}\n    void add_edge(int from,int to,int cap){\n        graph[from][to]=graph[to][from]=cap;\n    }\n    int dfs(int v,int t,int f){\n        if(v==t) return f;\n        done[v]=true;\n        for(int w=0; w<size; ++w){\n            if(done[w] or graph[v][w]==0) continue;\n            int d=dfs(w,t,min(f,graph[v][w]));\n            if(d>0){\n                graph[v][w]-=d;\n                graph[w][v]+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int calc_max_flow(int s,int t){\n        while(true){\n            fill(done.begin(),done.end(),false);\n            int f=dfs(s,t,inf);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nvoid solve(){\n    int n,e,q;\n    cin >> n >> e >> q;\n    max_flow mf(n);\n    rep(i,0,e){\n        int f,t;\n        cin >> f >> t;\n        --f;\n        --t;\n        mf.add_edge(f,t,1);\n    }\n    mf.calc_max_flow(0,n-1);\n    auto search_path=[&](int s,int t,int c){\n        vector<int> from(n);\n        vector<bool> done(n);\n        queue<int> que;\n        que.push(s);\n        done[s]=true;\n        while(!que.empty()){\n            int u=que.front();\n            que.pop();\n            if(u==t){\n                vector<int> res;\n                int v=u;\n                while(v!=s){\n                    res.push_back(v);\n                    v=from[v];\n                }\n                res.push_back(s);\n                reverse(res.begin(),res.end());\n                return res;\n            }\n            rep(v,0,n){\n                if(done[v]) continue;\n                if(c==1){\n                    if(mf.graph[u][v]==0) continue;\n                }else{\n                    if(mf.graph[u][v]!=0 or mf.graph[v][u]!=2) continue;\n                }\n                que.push(v);\n                done[v]=true;\n                from[v]=u;\n            }\n        }\n\n        return vector<int>();\n    };\n    rep(i,0,q){\n        int m,a,b;\n        cin >> m >> a >> b;\n        --a;\n        --b;\n        if(m==1){\n            mf.add_edge(a,b,1);\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }else{\n            int k=mf.calc_max_flow(0,n-1);\n            if(mf.graph[a][b]==1){\n                cout << k << endl;\n                continue;\n            }\n            if(mf.graph[b][a]==0) swap(a,b);\n            mf.graph[a][b]=mf.graph[b][a]=0;\n            {\n                vector<int> vs=search_path(a,b,1);\n                if(!vs.empty()){\n                    rep(i,0,vs.size()-1){\n                        mf.graph[vs[i]][vs[i+1]]=0;\n                        mf.graph[vs[i+1]][vs[i]]=2;\n                    }\n                    cout << k << endl;\n                    continue;\n                }\n            }\n            --mf.flow;\n            if(a!=0){\n                vector<int> vs=search_path(0,a,0);\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=1;\n                    mf.graph[vs[i+1]][vs[i]]=1;\n                }\n            }\n            if(b!=n-1){\n                vector<int> vs=search_path(b,n-1,0);\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=1;\n                    mf.graph[vs[i+1]][vs[i]]=1;\n                }\n            }\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight;\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i+1 << \", \" << g[i][j].dst+1 << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\n// TODO ?¨???????????????£????????????\nclass FordFulkerson {\npublic:\n    Graph g; // ????????????????????????\n    int s, t; // ?§????, ??????\n    int n; // ????????°\n    ll flow = 0; // ?????§????????????????????????????????????????????????????????¨?????±?????????\n\n    // ???????????????????????????????????????\n    // O(E ret)\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // ??????????????????src, dst, cap????????±?????????\n    // ????????°?????????????????????????????????\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // ?????????????????????\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // ????????°???????????????????????????????????´???????????????\n    // flow???????¨??????????\n    //\n    // O(V ret)\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // ????????°????????????????????????\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    // ???????????????\n    // ????????°????????§???v??????t????????£??????????????¢?????????????????°???????????????\n    //\n    // s??????t????§???????????????????????????????????????§?????????????????????????????????0????????????\n    // f??????????????¨??????????????????\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // ?????£???????????£????????£?????????????????¢??? \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // ???????????¨???????????????????????£???????????£??????????°??????????????¬???????????????¨??????\n            if (d > 0) {\n                e.cap -= d; // ????????°?????????????????´??°\n                g[e.dst][e.rev].cap += d; // ????????°????????????????????´??°\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // ????????????DFS??????????????¢??°???\n    // s, t????????????????????????????????????????????£???????????£?????????????°????\n    //\n    // O(V)\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // s??????t???????????§??????????????????\n    // s == t??????INF?????????, ???????????????0?????????\n    ll get(void) {\n        return flow;\n    }\n\n    // O(V) \n    // from??????to??????????????????cap???????????????????????????????????§???????????????\n    // ???????????????????????¨?????¨???????????£????????????????????????\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // ?????¨?????¨?????£??????\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    //  ??? ??§ ??? ??? ??? ??? ??? ??? ??? ??????from->to???????????????????°????????????°???????????????????????????\n    //\n    // from??????to?????????????????????=to->from??????????????????????????£?????????=from->to??????????????¢????????¨??§????????§???????????????????????¶?????§??????????????????????????????\n    // from->to????????????????????£??????????????????????????????????????¨??§from->to????????????????°??????°???????????¨g?????????????????????\n    //\n    // from->??????->to->from??§????????????????????\\???????????°???\n    // from->to????????????????????????????????????????????????????????¨?????§?????????\n    // ?????????????????????????????????????????¨?????????????????????????????¨????????\\??????\n    //\n    // O(V ret)\n    ll minimizeFlowOfEdgePreservingMaxFlow(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // ???????????????????????????from??????to???????????????????????¨??????\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // ?¶????????????????????????????????????£?????¨??¨?????????????????¨??????\n            // ??????????????????????????£???????????¨??§?????????\n            ll ret = 0;\n            while (1) { // TODO ?????????????????????????????°??????\n                // e.src?????????????????°??????????????????????????°???????????????\n                bool used[n];\n                rep(i, n) {\n                    used[i] = false;\n                }\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                ret += can_erase;\n                sum += can_erase;\n                e_rev.cap -= can_erase;\n\n                if (can_erase == 0) { // ????????§????¶????????????????\n                    // TODO ??¬?????????????????\\???????????§?????¨??¨??????????¢??????????????????????????¬????????????§???????????????\n                    break;\n                }\n            }\n            e.cap += ret;\n        }\n        return sum;\n    }\n\n    // from??????to?????????????????????cap???????????????????????????????????§???????????????\n    // cap???0????????£?????????????????°????????????????????????????¶??????????\n    //\n    // O(V ret)\n    int erase(int from, int to, ll cap) {\n        // ???????????¨????????????????????????????¶????????????????????????£???????????????????¢????\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // ?????????????????¨??????\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // (1) ?????£????????????????????£???????°????????????????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // ??????????????????????????????from??????to??????????????????????????¨??????\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n\n        // (2) ?????£????????????????????????????????????????????????????????????????????????????????§?????????????????????\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n \n        // (2) ?????????????????????????????????????????§????????????????????¶?????????????????????????????????????????§?????????????????????\n        //\n        // ????????°????????§???t->s???????¢???§??????cap???????????????????????????????????????flow???????°??????????\n        // ????°????????????????????????????????????????????????????????????¨???????????§??????????????¨???????????????????????????\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????????????????cap???????????????\n\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n\n    // from??????to??????????????¨?????? \n    //\n    // O(V ret)\n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, q; cin >> n >> e >> q;\n    Graph g(n);\n    rep(i, e) {\n        ll f, t; cin >> f >> t; f--, t--;\n        addDirected(g, f, t, 0, 1);\n        addDirected(g, t, f, 0, 1);\n    }\n    FordFulkerson ff(g, 0, n-1); \n    rep(i, q) {\n        int type, u, v; cin >> type >> u >> v; u--; v--;\n        if (type == 1) {\n            ff.add(u, v, 1);\n            ff.add(v, u, 1);\n            cout << ff.get() << endl;\n        } else {\n            ff.erase(u, v, 1);\n            ff.erase(v, u, 1);\n            cout << ff.get() << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 502;\nmap<int,int> G[MAX_N];\nbool used[MAX_N];\nint n;\n\nvoid add_edge(int from, int to, int cap){\n    G[from][to] = cap;\n    G[to][from] = cap;\n}\nvoid erase_edge(int from, int to){\n    G[from][to] = 0;\n    G[to][from] = 0;\n}\nint dfs(int v,int t,int f){\n    if(v == t) return f;\n    used[v] = true;\n    each(it,G[v]){\n        int nx = it.fi;\n        int& cap = it.se;\n        if(!used[nx] && cap > 0){\n            int d = dfs(nx,t,min(f,cap));\n            if(d > 0){\n                cap -= d;\n                G[nx][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int f = dfs(s,t,INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int E,q;\n    cin >> n >> E >> q;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        add_edge(a-1,b-1,1);\n    }\n    int res = max_flow(0,n-1);\n    rep(i,q){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --b,--c;\n        if(a == 1){\n            add_edge(b,c,1);\n            res += max_flow(0,n-1);\n        }else{\n            int cap = G[b][c];\n            erase_edge(b,c);\n            //逆向きに1流れてたら\n            if(cap == 2){\n                swap(b,c);\n            }\n            if(cap != 1){\n                memset(used,0,sizeof(used));\n                int f = dfs(b,c,1);\n                //aからbにフローを1流せない(枝(a,b)を削除した分をまかなえない)\n                if(f == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(b,0,1);\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,c,1);\n                    --res;\n                }\n            }\n        }\n        cout << res << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= cp)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 0;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 0;\n\t\t\t\tif(!flow(a, 1, 1))return 0;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to|| x.cap + G[to][x.rev].cap != cap  || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t\tflow.add_edge(t, f, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n    //if (flow[now][next] < 0){\n      if (dfs2(n,next,t)){\n\tflow[now][next]+=1;\n\tflow[next][now]=-flow[now][next];\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\t//tmp=maxFlow(n,from,to);\n\t//tmp=fordFulkerson(n,to,from,1);\n\trep(j,n)vis[j]=false;\n\ttmp=dfs2(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  //assert(fordFulkerson(n,s,from,1) == 1);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  //assert(fordFulkerson(n,to,t,1) == 1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n      /*\n\trep(ii,n){\n\t  rep(jj,n){\n\t    cout << flow[ii][jj] <<\" \";\n\t  }\n\t  cout << endl;\n\t}\n\trep(i,n){\n\t  int cnt=0;\n\t  if (i == 0||i == n-1)continue;\n\t  rep(j,n)cnt+=flow[i][j];\n\t  cout <<\" \" << a << \" \" <<  i <<\": \" << cnt << endl;\n\t  assert(cnt==0);\n\t}\n      */\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 510\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{int to,cap,rev;};\n\nvector<edge>G[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n} \n\nbool used[MAX_V];\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0 && !used[e.to]){\n      int d=dfs(e.to,t,min(e.cap,f));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(true){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint flow_back(int s,int t){\n  int flow=0;\n  fill(used,used+MAX_V,false);\n  int f=dfs(s,t,1);\n  if(f==0)return flow;\n  flow+=f;\n}\n\nint main(void){\n\n  int N,E,Q;\n  cin >> N >> E >> Q;\n  N--;\n  vector<int>F(E),T(E),M(Q),A(Q),B(Q);\n\n  for(int i=0;i<E;i++){\n    cin >> F[i] >> T[i];\n    F[i]--,T[i]--;\n    add_edge(F[i],T[i],1);\n    add_edge(T[i],F[i],1);\n  }\n\n  for(int i=0;i<Q;i++){\n    cin >> M[i] >> A[i] >> B[i];\n    A[i]--,B[i]--;\n    bool fg=false;\n    for(int j=0;j<G[A[i]].size();j++)fg|=G[A[i]][j].to==B[i];\n    if(!fg)add_edge(A[i],B[i],0);\n    fg=false;\n    for(int j=0;j<G[B[i]].size();j++)fg|=G[B[i]][j].to==A[i];\n    if(!fg)add_edge(B[i],A[i],0);\n  }\n  \n  int res=max_flow(0,N);\n  \n  for(int i=0;i<Q;i++){\n    if(M[i]==1){\n      for(int j=0;j<G[A[i]].size();j++){\n\tedge &e=G[A[i]][j];\n\tif(e.to==B[i]){\n\t  e.cap=1;\n\t  G[e.to][e.rev].cap=0;\n\t}\n      }\n\n      for(int j=0;j<G[B[i]].size();j++){\n\tedge &e=G[B[i]][j];\n\tif(e.to==A[i]){\n\t  e.cap=1;\n\t  G[e.to][e.rev].cap=0;\n\t}\n      }\n\n      res=max_flow(0,N);\n      cout << res/2 << endl;\n    }\n    else {\n      int C=0;\n     for(int j=0;j<G[A[i]].size();j++){\n\tedge &e=G[A[i]][j];\n\tif(e.to==B[i]){\n\t  C=max(C,e.cap);\n\t  e.cap=0;\n\t  G[e.to][e.rev].cap=0;\n\t}\n      }\n\n     for(int j=0;j<G[B[i]].size();j++){\n\tedge &e=G[B[i]][j];\n\tif(e.to==A[i]){\n\t  C=max(C,e.cap);\n\t  e.cap=0;\n\t  G[e.to][e.rev].cap=0;\n\t}\n      }\n\n      if(C>0)cout << res << endl;\n      else if(C==0){\n\tflow_back(N,B[i]);\n\tflow_back(A[i],0);\n\tres--;\n\tcout << res << endl;\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > min_cost, used;\n  int flow;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(flow < lim) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim - flow);\n      if(f == 0) return(flow);\n      flow += f;\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    bool flag = false;\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(from, to, 1);\n            flag = true;\n          }\n        } else if(re.cap == 0) {\n          if(max_flow(to, from, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(to, from, 1);\n            flag = true;\n          }\n        }\n        e.alive = re.alive = false;\n        return(flag);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nbool modify(Graph& g,int v,int sink,int flow,vi& vis)\n{\n\tif(v==sink) return true;\n\tif(vis[v]) return false;\n\tvis[v]=1;\n\tfor(int i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge e=g.es[i];\n\t\tif(e.flow!=-flow) continue;\n\t\tif(modify(g,e.dst,sink,flow,vis)){\n\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n,m,q;cin>>n>>m>>q && n|m|q;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg.AddEdge(u,v,1,1);\n\t\t}\n\t\trep(_,q){\n\t\t\tint t,u,v; cin>>t>>u>>v; u--,v--;\n\t\t\tif(t==1)\n\t\t\t\tg.AddEdge(u,v,1,1);\n\t\t\telse{\n\t\t\t\tint i;\n\t\t\t\tfor(i=g.head[u];i!=-1;i=g.next[i])\n\t\t\t\t\tif(g.es[i].dst==v && g.es[i].cap==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\tg.es[i].cap=g.es[i^1].cap=0;\n\t\t\t\tif(g.es[i].flow){\n\t\t\t\t\tif(g.es[i].flow==-1) swap(u,v);\n\t\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\t\t{vi vis(n); modify(g,v,n-1,-1,vis);}\n\t\t\t\t\t{vi vis(n); modify(g,u,0,1,vis);}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDinic(g,0,n-1);\n\t\t\tint res=0;\n\t\t\tfor(int j=g.head[0];j!=-1;j=g.next[j])\n\t\t\t\tres+=g.es[j].flow;\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int a,int b,int c):to(a),cap(b),rev(c){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,cap,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim){\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1,INF);\n}\n\nvoid q2(int a,int b){\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.to!=b||e.cap==0)continue;\n        if(e.cap==2)f2=true;\n        e.cap=0;\n    }\n    for(auto &e:G[b]){\n        if(e.to!=a||e.cap==0)continue;\n        if(e.cap==2)f1=true;\n        e.cap=0;\n    }\n    if(!f1&&!f2)return;\n\n    if(f2)swap(a,b);\n\n\n    int tmp=max_flow(a,b,1);\n\n    if(tmp)return;\n\n    add_edge(0,N-1,1);\n    tmp=max_flow(a,b,1);\n    assert(tmp);\n    G[0].pop_back();\n    G[N-1].pop_back();\n    f--;\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n    }\n\n    f=max_flow(0,N-1,INF);\n\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                cout<<i+1<<\" \"<<e.to+1<<\" \"<<e.cap<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll r = 0;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n                    assert(G[B][e.rev].to == A);\n                    e.cap = 0; e.to = -1;\n                    G[B][e.rev].cap = 0; G[B][e.rev].to = -1;\n                    // G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n                    // G[A].erase(G[A].begin()+j, G[A].begin()+j+1);\n                    break;\n                }\n            }\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else if (r == -1) {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef int flow_t;\n\nconst int MAX_N = 500;\nconst int MAX_E = 20000;\nconst int MAX_Q = 1000;\n\nstruct edge{\n\tint tar;\n\tflow_t cap;\n\tbool on;\n};\n\nstruct query{\n\tint cmd;\n\tint x, y;\n};\n\nint V, E, Q;\nvector<edge> graph[MAX_N];\nint id_table[MAX_N][MAX_N];\nquery qs[MAX_Q];\n\nvoid add_edge(int x, int y, flow_t cap, bool on){\n\tid_table[x][y] = graph[x].size();\n\tid_table[y][x] = graph[y].size();\n\tgraph[x].push_back((edge){y, cap, on});\n\tgraph[y].push_back((edge){x, cap, on});\n}\n\nvoid init(){\n\tscanf(\"%d%d%d\", &V, &E, &Q);\n\tmemset(id_table, -1, sizeof(id_table));\n\tfor(int i=0; i<E; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--; y--;\n\t\tadd_edge(x, y, 1, true);\n\t}\n\n\tfor(int i=0; i<Q; i++){\n\t\tint c, x, y;\n\t\tscanf(\"%d%d%d\", &c, &x, &y);\n\t\tx--; y--;\n\t\tqs[i] = (query){c, x, y};\n\t\tif(id_table[x][y] == -1){\n\t\t\tadd_edge(x, y, 0, false);\n\t\t}\n\t}\n\n}\n\nbool visited[MAX_N];\nint vis_time[MAX_N];\n\nbool dfs(int v, int sink){\n\tif(v == sink){\n\t\treturn true;\n\t}\n\tvisited[v] = true;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0 && !visited[e.tar] && dfs(e.tar, sink)){\n\t\t\te.cap--;\n\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rem_dfs(int v){\n\tvis_time[v] = 1;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap == 0){\n\t\t\tif(vis_time[e.tar] == 1 || (vis_time[e.tar] == 0 && rem_dfs(e.tar))){\n\t\t\t\te.cap++;\n\t\t\t\tgraph[e.tar][id_table[e.tar][v]].cap--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tvis_time[v] = 2;\n\treturn false;\n}\n\nbool remove_cycle(int x, int y){\n\tmemset(vis_time, 0, sizeof(vis_time));\n\tvis_time[x] = 1;\n\treturn rem_dfs(y);\n}\n\nvoid solve(){\n\tconst int source = 0, sink = V - 1;\n\tflow_t current = 0;\n\n\tfor(;memset(visited, false, sizeof(visited)), dfs(source, sink); current++);\n\n\tfor(int i=0; i<Q; i++){\n\t\tif(qs[i].cmd == 1){\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tgraph[x][id_table[x][y]].on = true;\n\t\t\tgraph[y][id_table[y][x]].on = true;\n\t\t\tgraph[x][id_table[x][y]].cap = 1;\n\t\t\tgraph[y][id_table[y][x]].cap = 1;\n\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\tif(dfs(source, sink)){\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tif(graph[x][id_table[x][y]].cap != 1){\n\n\t\t\t\t// ツ個サツ催敖づ郊 -> yツづ猟ャツづェツづつ「ツづゥツづヲツつ、ツづ可暗ェツ氾環可サ\n\t\t\t\tif(graph[x][id_table[x][y]].cap == 2){\n\t\t\t\t\tswap(x, y);\n\t\t\t\t}\n\t\t\t\tif(!remove_cycle(x, y)){\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(x, source);\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(sink, y);\n\t\t\t\t\tcurrent--;\n\t\t\t\t}\n\t\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\t\tgraph[x][id_table[x][y]].cap = 0;\n\t\t\t\tgraph[y][id_table[y][x]].cap = 0;\n\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\tif(dfs(source, sink)){\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", current);\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef int flow_t;\n\nconst int MAX_N = 500;\nconst int MAX_E = 20000;\nconst int MAX_Q = 1000;\n\nstruct edge{\n\tint tar;\n\tflow_t cap;\n\tbool on;\n};\n\nstruct query{\n\tint cmd;\n\tint x, y;\n};\n\nint V, E, Q;\nvector<edge> graph[MAX_N];\nint id_table[MAX_N][MAX_N];\nquery qs[MAX_Q];\n\nvoid add_edge(int x, int y, flow_t cap, bool on){\n\tid_table[x][y] = graph[x].size();\n\tid_table[y][x] = graph[y].size();\n\tgraph[x].push_back((edge){y, cap, on});\n\tgraph[y].push_back((edge){x, cap, on});\n}\n\nvoid init(){\n\tscanf(\"%d%d%d\", &V, &E, &Q);\n\tmemset(id_table, -1, sizeof(id_table));\n\tfor(int i=0; i<E; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--; y--;\n\t\tadd_edge(x, y, 1, true);\n\t}\n\n\tfor(int i=0; i<Q; i++){\n\t\tint c, x, y;\n\t\tscanf(\"%d%d%d\", &c, &x, &y);\n\t\tx--; y--;\n\t\tqs[i] = (query){c, x, y};\n\t\tif(id_table[x][y] == -1){\n\t\t\tadd_edge(x, y, 0, false);\n\t\t}\n\t}\n\n}\n\nbool visited[MAX_N];\nint vis_time[MAX_N];\n\nbool dfs(int v, int sink){\n\tif(v == sink){\n\t\treturn true;\n\t}\n\tvisited[v] = true;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0 && !visited[e.tar] && dfs(e.tar, sink)){\n\t\t\te.cap--;\n\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rem_dfs(int v){\n\tvis_time[v] = 2;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0){\n\t\t\tif(vis_time[e.tar] == 1 || (vis_time[e.tar] == 0 && rem_dfs(e.tar))){\n\t\t\t\te.cap--;\n\t\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool remove_cycle(int x, int y){\n\tmemset(vis_time, 0, sizeof(vis_time));\n\tvis_time[y] = 1;\n\treturn rem_dfs(x);\n}\n\nvoid solve(){\n\tconst int source = 0, sink = V - 1;\n\tflow_t current = 0;\n\n\tfor(;memset(visited, false, sizeof(visited)), dfs(source, sink); current++);\n\n\tfor(int i=0; i<Q; i++){\n\t\tif(qs[i].cmd == 1){\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tgraph[x][id_table[x][y]].on = true;\n\t\t\tgraph[y][id_table[y][x]].on = true;\n\t\t\tgraph[x][id_table[x][y]].cap = 1;\n\t\t\tgraph[y][id_table[y][x]].cap = 1;\n\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\tif(dfs(source, sink)){\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tif(graph[x][id_table[x][y]].cap != 1){\n\t\t\t\t// ツ個サツ催敖づ郊 -> yツづ猟ャツづェツづつ「ツづゥツづヲツつ、ツづ可暗ェツ氾環可サ\n\t\t\t\tif(graph[x][id_table[x][y]].cap == 2){\n\t\t\t\t\tswap(x, y);\n\t\t\t\t}\n\t\t\t\tif(!remove_cycle(x, y)){\n\t\t\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(x, source);\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(sink, y);\n\t\t\t\t\tcurrent--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\tgraph[x][id_table[x][y]].cap = 0;\n\t\t\tgraph[y][id_table[y][x]].cap = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", current);\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tmap<P,int> m;\n\tint DFS(int v,int t,int f,vi& used){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),used);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Flow(int s,int t,int f){\n\t\tvi used(V);\n\t\treturn DFS(s,t,f,used);\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tm[{s,t}]=g[s].size();\n\t\tg[s].push_back(edge{t,1,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,1,(int)g[s].size()-1});\n\t}\n\tint Max_Flow(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tint f=Flow(s,t,1);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n\tvoid Clear(int u,int v){\n\t\tint I=m[{u,v}];\n\t\tg[u][I].cap=0;\n\t\tg[v][g[u][I].rev].cap=0;\n\t}\n\tint Add(int u,int v){\n\t\tadd_edge(u,v);\n\t\treturn Flow(0,V-1,1);\n\t}\n\tint Erase(int u,int v,int ind){\n\t\tint C=g[u][m[{u,v}]].cap;\n\t\tif(C==1){\n\t\t\tClear(u,v);\n\t\t\treturn 0;\n\t\t}\n\t\tint f=Flow((C?v:u),(C?u:v),1);\n\t\tif(f){\n\t\t\tClear(u,v);\n\t\t\treturn 0;\n\t\t}\n\t\tFlow(V-1,0,1);\n\t\tClear(u,v);\n\t\tFlow((C?v:u),(C?u:v),1);\n\t\treturn 1;\n\t}\n};\n\nint n,m,q;\n\nint main(){\n\tcin>>n>>m>>q;\n\tNetwork nt(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tnt.add_edge(u,v);\n\t}\n\tint res=nt.Max_Flow(0,n-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t,u,v;\n\t\tcin>>t>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tif(t==1) res+=nt.Add(u,v);\n\t\telse res-=nt.Erase(u,v,i);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t)  return f;\n\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    int flow = 0;\n    while (bfs(s), level[t] >= 0 && flow_ > 0) {\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n    }\n\n    return flow;\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        int j = 0;\n        while (G[a][j].to != b) j++;\n        if (m == 1) {\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n);\n        } else {\n            int from = -1, to = -1;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 && to > 0 && max_flow(from, to, 1) == 0) {\n                f--;\n                max_flow(from, 1, 1);\n                max_flow(n, to, 1);\n            }\n        }\n        cout << f << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#define N 501\nconst int inf= 1000000000;\nusing namespace std;\n #define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n\tflow[now][next]+=1;\n\tflow[next][now]=-flow[now][next];\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\n \nint main(void){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n        cap[i][j] = 0;\n        flow[i][j] = 0;\n      }\n    }\n \n    for(int i = 0 ; i < e ; i++){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    for(int i = 0 ; i < q ; i++){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n        cap[from][to]=cap[to][from]=1;\n        tmp = maxFlow(n,s,t);\n        cout << prev+tmp << endl;\n        prev=prev+tmp;\n      }else if (flow[from][to] == 0){\n        cap[from][to]=cap[to][from]=0;\n        cout << prev << endl;\n      }else {//delete\n        if (flow[from][to] < 0)swap(from,to);\n        cap[from][to]=cap[to][from]=0;\n        flow[from][to]=flow[to][from]=0;\n        for(int j = 0 ; j < n ; j++)vis[i] = false;\n        tmp=dfs2(n,from,to);\n        if (tmp != 0){\n          cout << prev << endl;\n          prev=prev;//keep\n        }else {\n          for(int j = 0 ;j < n ; j++)vis[j] = false;\n          dfs(n,from,s);\n          for(int j = 0 ; j < n; j++)vis[j] = false;\n          dfs(n,t,to);\n          cout << prev-1 << endl;\n          prev=prev-1;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n\nint N,E,Q;\nvector<set<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(auto i=edge[from].begin();i!=edge[from].end();i++){\n    int to = *i;\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      used[from]=0;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].insert(b);\n  edge[b].insert(a);\n  if(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  edge[a].erase(b);\n  edge[b].erase(a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n      f--;\n    }\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef unordered_map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1) g[a][b]=g[b][a]=1,flow+=max_flow(0,n-1);\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b))flow--,check(a,0),check(n-1,b);\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=int;\n\nstruct Edge{\n    int from,to;\n    Weight cap;\n    bool rev;\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs){\n    if(lhs.from!=rhs.from) return lhs.from<rhs.from;\n    if(lhs.to!=rhs.to) return lhs.to<rhs.to;\n    if(lhs.cap!=rhs.cap) return lhs.cap<rhs.cap;\n    return lhs.rev<rhs.rev;\n}\nusing Edges=multiset<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    Graph g;\n    Weight nowF=0;\n    const Weight INF=1e9;\n    Weight dfs(int v,int t,stack<int>& st,vector<int> &used,bool mustrev){\n        if(used[v]) return 0;\n        if(v==t) return INF;\n        used[v]=true;\n        for(auto &e:g[v]){\n            if(e.cap==0) continue;\n            if(mustrev && !e.rev) continue;\n            Weight f=dfs(e.to,t,st,used,mustrev);\n            if(f>0){\n                st.push(v);\n                return min(f,e.cap);\n            }   \n        }\n        return 0;\n    }\n    Edges::iterator rettf(int fr,int to,int cap,Edges &edges){\n        auto res=edges.find(Edge{fr,to,cap,true});\n        if(res==edges.end()) res=edges.find(Edge{fr,to,cap,false});\n        return res;\n    }\n    public:\n    Flow(int n):g(n){}\n    void addEdge(int from,int to,Weight cap){\n        g[from].insert(Edge{from,to,cap,false});\n        g[to].insert(Edge{to,from,0,true});\n    }\n    Weight maxFlow(int s,int t){\n        Weight res=0;\n        Weight f;\n        vector<int> used(g.size(),false);\n        stack<int> st;\n        while(f=dfs(s,t,st,used,false)){\n            res+=f;\n            while(!st.empty()){\n                int fr=st.top(); st.pop();\n                int to=(st.empty() ? t : st.top());\n                auto it0=rettf(fr,to,1,g[fr]);\n                auto it1=g[to].find(Edge{to,fr,0,!(it0->rev)});\n                assert(it0!=g[fr].end() && it1!=g[to].end());\n                g[fr].insert(Edge{fr,to,0,it0->rev});\n                g[fr].erase(it0);\n                g[to].insert(Edge{to,fr,1,it1->rev});\n                g[to].erase(it1);\n            }\n            fill(used.begin(),used.end(),false);\n        }\n        return nowF=nowF+res;\n    }\n\n    void decEdge(int fr,int to,int s,int t){\n        if(g[fr].find(Edge{fr,to,0,false})==g[fr].end()){\n            g[fr].erase(Edge{fr,to,1,false});\n            g[to].erase(Edge{to,fr,0,true});\n            return;\n        }\n        g[fr].erase(g[fr].find(Edge{fr,to,0,false}));        \n        g[to].erase(g[to].find(Edge{to,fr,1,true}));\n        \n        vector<int> used(g.size(),false);\n        stack<int> st;\n        int f0=dfs(fr,s,st,used,true);\n        \n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? s : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        \n        fill(used.begin(),used.end(),0);\n        int f1=dfs(t,to,st,used,true);        \n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? to : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            assert(it0!=g[frr].end());\n            assert(it1!=g[too].end());\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        nowF--;\n    } \n    \n};\n\nint main(){\n    int n,e,q;\n    cin>>n>>e>>q;\n    Flow flow(n);\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        f--,t--;\n        flow.addEdge(f,t,1);\n        flow.addEdge(t,f,1);\n    }\n    for(int i=0;i<q;i++){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            flow.addEdge(a,b,1);\n            flow.addEdge(b,a,1);\n        }\n        if(m==2){\n            flow.decEdge(a,b,0,n-1);\n            flow.decEdge(b,a,0,n-1);\n        }\n        cout<<flow.maxFlow(0,n-1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint G[511][511][2];\n \nbool used[511];\n \nint N,E,Q;\n \n#define INF ( 1<<30)\n \nvoid add_edge(int a,int b){\n  G[a][b][0] = 1; G[b][a][1] = 0;\n}\n \nvoid rem_edge(int a,int b){\n  G[a][b][0] = 0; G[b][a][1] = 0;\n}\n \nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int fr=1;fr>=0;fr--){\n    for(int i=0;i<N;i++){\n      if( !used[i] && G[v][i][fr] > 0 ) {\n\tint d = dfs(i, t, min( f, G[v][i][fr] ) );\n\tif( d > 0 ){\n\t  G[v][i][fr] -= d;\n\t  G[i][v][1-fr] += d;\n\t  return d;\n\t}\n      }\n    }\n  }\n  return 0;\n}\n \n \nint max_flow(int s,int t){\n  int flow = 0;\n  if( s == t ) return 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    //  cout << s << \" -> \" << t << \" = \" << f << endl;\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n  return flow;\n}\n\nint rdfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<N;i++){\n    if( !used[i] && G[v][i][1] > 0 ) {\n      int d = dfs(i, t, min( f, G[v][i][1] ) );\n      if( d > 0 ){\n\tG[v][i][1] -= d;\n\tG[i][v][0] += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\nint rev_flow(int s,int t){\n  int flow = 0;\n  if( s == t ) return 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = rdfs(s,t,INF);\n    //  cout << s << \" -> \" << t << \" = \" << f << endl;\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n  return flow;\n}\n\nvoid view(){\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if( G[i][j][0] == 0 && G[j][i][1] == 0 ) continue;\n      printf(\" %d -> %d : cap = %d  rev( %d -> %d ) = %d\\n\",i+1,j+1,G[i][j][0],j+1,i+1,G[j][i][1]);\n    }\n  }\n}\n \nint main(){\n  cin  >> N >> E >> Q;\n  for(int i=0;i<E;i++){\n    int e,f;\n    cin >> e >> f;\n    --e; --f;\n    add_edge(e,f);\n    add_edge(f,e);\n  }\n  int rflow = max_flow(0,N-1);\n  for(int i=0;i<Q;i++){\n\n    //    view();\n\n    int m,a,b;\n    cin >>m>> a>> b;\n    --a; --b;\n    if( m == 1 ){\n      add_edge(a,b);\n      add_edge(b,a);\n    } else {\n      if( G[a][b][0] == 0 ){\n\t//\tcout << \"rem \" << a << \" <-> \" << b << endl;\n\trem_edge(a,b);\t\n\tint d = max_flow(a,b);\n\tif( d == 0 ){\n\t  rev_flow(N-1,b);\n\t  rev_flow(a,0);\n\t  rflow--;\n\t}\n      } else\n\trem_edge(a,b);\n\n      if( G[b][a][0] == 0 ){\n\t///cout << \"rem \" << b << \" <-> \" << a << endl;\n\trem_edge(b,a);\n\tint d = max_flow(b,a);\n\t//cout << d << endl;\n\tif( d == 0 ){\n\t  rev_flow(N-1,a);\n\t  rev_flow(b,0);\n\t  rflow--;\n\t}\n      } else \n\trem_edge(b,a);\n    }\n    rflow += max_flow(0,N-1);\n    cout << rflow << endl;\n  }\n  // view();\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    add_edge(b,a,1);\n    f+=max_flow(0,N-1);\n}\n\nbool dfs2(int v,int t,vint &A){\n    used[v]=true;\n    if(v==t){\n        A.pb(v);\n        return true;\n    }\n\n    for(auto &e:G[v]){\n        if(e.cap==0)continue;\n        if(used[e.to])continue;\n        if(dfs2(e.to,t,A)){\n            A.pb(v);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid uku(vint &A){\n    for(int i=0;i+1<A.size();i++){\n        int a=A[i];\n        int b=A[i+1];\n\n        for(auto &e:G[a]){\n            if(e.to==b&&e.cap){\n                e.cap=0;\n                G[e.to][e.rev].cap=1;\n                break;\n            }\n        }\n    }\n}\n\nvoid q2(int a,int b){\n\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.type==1&&e.to==b){\n            f1=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n    for(auto &e:G[b]){\n        if(e.type==1&&e.to==a){\n            f2=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n\n\n    if(f1==f2)return;\n\n    if(f2)swap(a,b);\n\n    vint A,B;\n\n    memset(used,0,sizeof(used));\n    assert(dfs2(N-1,b,B));\n    memset(used,0,sizeof(used));\n    assert(dfs2(a,0,A));\n\n    reverse(all(A));\n    reverse(all(B));\n\n    map<int,int>ei;\n\n    rep(i,B.size())ei[B[i]]=i;\n\n    int k=-1;\n    rep(i,A.size()){\n        if(ei.find(A[i])==ei.end())continue;\n        k=i;\n        break;\n    }\n\n    if(k==-1){\n        uku(A);uku(B);\n        f--;\n    }\n    else{\n        int l=ei[A[k]];\n        A.erase(A.begin()+k,A.end());\n        for(int i=l;i<B.size();i++)A.pb(B[i]);\n        uku(A);\n    }\n\n    f+=max_flow(0,N-1);\n}\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.type==1&&e.cap==0)cout<<i+1<<\" \"<<e.to+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nstruct MaxFlow {\n    static const int N = 512;\n    int n, flow[N][N], capa[N][N], prev[N];\n    void init(int _n) {\n        n = _n;\n        memset(flow, 0, sizeof(flow));\n        memset(capa, 0, sizeof(capa));\n    }\n    void add_edge(int u, int v, int ca) { capa[u][v] = ca; }\n    int pour(int s, int t, int F=1<<30) {\n        int total = 0;\n        while(total < F) {\n            memset(prev, -1, sizeof(prev));\n            queue<int> q;\n            prev[s] = s;\n            q.push(s);\n            while(!q.empty() && prev[t]<0) {\n                const int u = q.front();\n                q.pop();\n                rep(i, n) if(prev[i]<0 && flow[u][i]<capa[u][i]) {\n                    prev[i] = u;\n                    q.push(i);\n                }\n            }\n            if(prev[t]<0) return total;\n            int inc = F-total;\n            for(int j=t; prev[j]!=j; j=prev[j]) {\n                inc = min(inc, capa[prev[j]][j]-flow[prev[j]][j]);\n            }\n            for(int j=t; prev[j]!=j; j=prev[j]) {\n                flow[prev[j]][j] += inc;\n                flow[j][prev[j]] -= inc;\n            }\n            total += inc;\n        }\n        return total;\n    }\n} mf;\n\nint N, E, Q;\n\nint main() {\n    scanf(\"%d%d%d\", &N, &E, &Q);\n    mf.init(N);\n    rep(_, E) {\n        int F, T;\n        scanf(\"%d%d\", &F, &T);\n        F--, T--;\n        mf.add_edge(F, T, 1);\n        mf.add_edge(T, F, 1);\n    }\n    int cur = mf.pour(0, N-1);\n    rep(_, Q) {\n        int M, A, B;\n        scanf(\"%d%d%d\", &M, &A, &B);\n        A--, B--;\n        if(M==1) {\n            mf.add_edge(A, B, 1);\n            mf.add_edge(B, A, 1);\n            cur += mf.pour(0, N-1, 1);\n        }\n        else {\n            if(mf.flow[A][B]==-1) swap(A, B);\n            if(mf.flow[A][B] && !mf.pour(A, B, 1)) {\n                cur--;\n                mf.pour(N-1, B, 1);\n                mf.pour(A, 0, 1);\n            }\n            mf.flow[A][B] = 0;\n            mf.capa[A][B] = 0;\n        }\n        printf(\"%d\\n\", cur);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nconstexpr int INF = 1 << 30;\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    vector<map<int, int>> c(N);\n    auto addEdge = [&](const int u, const int v) -> void { c[u][v] = c[v][u] = 1; };\n    auto cutEdge = [&](const int u, const int v) -> void { c[u].erase(v), c[v].erase(u); };\n    auto flow = [&](const int s, const int t, const int limit) {\n        vector<bool> used(N, false);\n        auto dfs = fix([&](auto&& self, const int s, const int t, const int f) -> int {\n            if (s == t) { return f; }\n            used[s] = true;\n            for (auto& e : c[s]) {\n                if (used[e.first] or e.second == 0) { continue; }\n                const int res = min(f, e.second);\n                const int d = self(self, e.first, t, res);\n                if (d == 0) { continue; }\n                return e.second -= d, c[e.first][s] += d, d;\n            }\n            return 0;\n        });\n        for (int flow = 0; flow < limit;) {\n            fill(used.begin(), used.end(), false);\n            const int f = dfs(s, t, limit - flow);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n        return limit;\n    };\n    for (int i = 0, F, T; i < E; i++) {\n        cin >> F >> T;\n        addEdge(F - 1, T - 1);\n    }\n    int ans = flow(0, N - 1, INF);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            addEdge(A, B);\n            ans += flow(0, N - 1, INF);\n        } else {\n            const int cap = c[A][B];\n            cutEdge(A, B);\n            if (cap == 2) { swap(A, B); }\n            if (cap != 1 and flow(A, B, 1) == 0) { ans--, flow(A, 0, 1), flow(N - 1, B, 1); }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\t//cout << re.cap << ' ' << G[a][re.rev].cap << endl;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\t//cout << ba.cap << ' ' << rba.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tif(dfs(a, b, 1)) return 0;\n\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tif(dfs(b, a, 1)) return 0;\n\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\treturn 0;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn fordFulkerson(s, t) ? 0 : - 1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tused[t][f] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef int Weight;\n\ntypedef set<Weight> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  REP(y, matrix.size()) {\n    REP(x, matrix[0].size()) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nvoid AddEdge(Graph &g, Matrix &capacity, int from, int to) {\n  g[from].insert(to);\n  g[to].insert(from);\n  capacity[from][to]++;\n  capacity[to][from]++;\n}\n\nvoid EraseEdge(Graph &g, Matrix &capacity, int from, int to) {\n  assert(capacity[from][to] == 1);\n  assert(capacity[to][from] == 1);\n  g[from].erase(to);\n  g[to].erase(from);\n  capacity[from][to]--;\n  capacity[to][from]--;\n}\n\nbool visit[1100];\nint DfsFlow(Graph &g, Matrix &capacity, int from, int target) {\n  if (from == target) { return 1; }\n  visit[from] = true;\n  FORIT(it, g[from]) {\n    int to = *it;\n    if (visit[to] || capacity[from][to] == 0) { continue; }\n    if (DfsFlow(g, capacity, to, target)) {\n      capacity[from][to]--;\n      capacity[to][from]++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint n, m, q;\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &q) > 0) {\n    Graph g(n);\n    Matrix capacity(n, Array(n, 0));\n    REP(i, m) {\n      int from, to;\n      int v = scanf(\"%d %d\", &from, &to);\n      assert(v == 2);\n      from--; to--;\n      AddEdge(g, capacity, from, to);\n    }\n    int flow = 0;\n    while (true) {\n      MEMSET(visit, false);\n      if (DfsFlow(g, capacity, 0, n - 1) == 0) { break; }\n      flow++;\n    }\n    REP(iter, q) {\n      int type, from, to;\n      int v = scanf(\"%d %d %d\", &type, &from, &to);\n      from--; to--;\n      assert(v == 3);\n      if (type == 1) {\n        AddEdge(g, capacity, from, to);\n        MEMSET(visit, false);\n        flow += DfsFlow(g, capacity, 0, n - 1);\n      } else {\n        assert(capacity[from][to] + capacity[to][from] == 2);\n        if (capacity[from][to] == 1) {\n          EraseEdge(g, capacity, from, to);\n        } else {\n          MEMSET(visit, false);\n          if (capacity[from][to] == 2) { swap(from, to); }\n          if (DfsFlow(g, capacity, from, to) == 0) {\n            MEMSET(visit, false);\n            int nto1 = DfsFlow(g, capacity, n - 1, 0);\n            assert(nto1);\n            flow--;\n            if (capacity[from][to] != 1) {\n              MEMSET(visit, false);\n              int ftot = DfsFlow(g, capacity, from, to);\n              assert(ftot);\n            }\n          }\n          capacity[from][to] = 1;\n          capacity[to][from] = 1;\n          EraseEdge(g, capacity, from, to);\n        }\n      }\n      printf(\"%d\\n\", flow);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 502;\nint G[MAX_N][MAX_N];\nbool used[MAX_N];\nint n;\n\nvoid add_edge(int from, int to, int cap){\n    G[from][to] = cap;\n    G[to][from] = cap;\n}\nvoid erase_edge(int from, int to){\n    G[from][to] = 0;\n    G[to][from] = 0;\n}\nint dfs(int v,int t,int f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i,n){\n        int& cap = G[v][i];\n        if(!used[i] && cap > 0){\n            int d = dfs(i,t,min(f,cap));\n            if(d > 0){\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int f = dfs(s,t,INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int E,q;\n    cin >> n >> E >> q;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        add_edge(a-1,b-1,1);\n    }\n    int res = max_flow(0,n-1);\n    rep(i,q){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --b,--c;\n        if(a == 1){\n            add_edge(b,c,1);\n            res += max_flow(0,n-1);\n        }else{\n            int cap = G[b][c];\n            erase_edge(b,c);\n            if(cap == 2){\n                swap(b,c);\n            }\n            if(cap != 1){\n                memset(used,0,sizeof(used));\n                int f = dfs(b,c,1);\n                //a??????b???????????????1????????????(???(a,b)???????????????????????????????????????)\n                if(f == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(b,0,1);\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,c,1);\n                    --res;\n                }\n            }\n        }\n        cout << res << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,P> idx;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  idx[P(from,to)].second=G[to].size();\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n  idx[P(from,to)].first=G[from].size()-1;\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t,int X){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, X);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int n,e,q,a,b,m;\n  cin>>n>>e>>q;\n  for(int i=0;i<e;i++){\n    cin>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    add_edge(a,b,1);\n  }\n  int ans=max_flow(0,n-1,INF);\n  for(int i=0;i<q;i++){\n    cin>>m>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    if(m==1){\n      add_edge(a,b,1);\n      ans+=max_flow(0,n-1,1);\n    }else{\n      P x=idx[P(a,b)];\n      int s=-1,t=-1;\n      if(!G[a][x.first].cap)s=a,t=b;\n      if(!G[b][x.second].cap)s=b,t=a;\n      if(a==7&&b==8){\n\tcout<<G[a][x.first].cap<<' '<<G[b][x.second].cap<<endl;\n      }\n      G[a][x.first].cap=0;\n      G[b][x.second].cap=0;\n      if(s>=0&&t>=0){\n\tint r=max_flow(s,t,1);\n\tif(!r){\n\t  ans--;\n\t  if(s!=0)max_flow(s,0,1);\n\t  if(t!=n-1)max_flow(n-1,t,1);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 21005;\nconst F MAXF = 1<<29;\n\nF cap[2*MAXE], flow[2*MAXE];\nint level[MAXV], edge[MAXV], seen[MAXV], to[2*MAXE];\n\nstruct MaxFlow {\n    int V, E, prev[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        seen[s] = 1;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == 0 && level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            memset(seen, 0, sizeof(seen));\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(seen, -1, sizeof(seen)); seen[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = mf.prev[e]) {\n            if (seen[to[e]] == -1 && flow[e] > 0) {\n                seen[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    for (int v = t; v != seen[v]; v = seen[v]) {\n        flow[use_edge[v]] = flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(seen, -1, sizeof(seen)); seen[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = mf.prev[e]) {\n            if (seen[to[e]] == -1 && cap[e] - flow[e] > 0) {\n                seen[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    if (seen[t] == -1) return 0;\n    for (int v = t; v != seen[v]; v = seen[v]) {\n        flow[use_edge[v]]++;\n        flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = edge[s]; e != -1; e = mf.prev[e])\n        if (to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) cap[e] = cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            assert(e >= 0);\n            cap[e] = cap[e^1] = 0;\n            if (flow[e] != 0) {\n                f--;\n                if (flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                flow[e] = flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef unordered_map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    scanf(\"%d%d\",&a,&b),a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int op,a,b,flow=max_flow(0,n-1);\n  while(q--){\n    scanf(\"%d%d%d\",&op,&a,&b);a--,b--;\n    if(op==1) g[a][b]=g[b][a]=1,flow+=max_flow(0,n-1);\n    else {\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b))flow--,check(a,0),check(n-1,b);\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef int flow_t;\n\nconst int MAX_N = 500;\nconst int MAX_E = 20000;\nconst int MAX_Q = 1000;\n\nstruct edge{\n\tint tar;\n\tflow_t cap;\n\tbool on;\n};\n\nstruct query{\n\tint cmd;\n\tint x, y;\n};\n\nint V, E, Q;\nvector<edge> graph[MAX_N];\nint id_table[MAX_N][MAX_N];\nquery qs[MAX_Q];\n\nvoid add_edge(int x, int y, flow_t cap, bool on){\n\tid_table[x][y] = graph[x].size();\n\tid_table[y][x] = graph[y].size();\n\tgraph[x].push_back((edge){y, cap, on});\n\tgraph[y].push_back((edge){x, cap, on});\n}\n\nvoid init(){\n\tscanf(\"%d%d%d\", &V, &E, &Q);\n\tmemset(id_table, -1, sizeof(id_table));\n\tfor(int i=0; i<E; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--; y--;\n\t\tadd_edge(x, y, 1, true);\n\t}\n\n\tfor(int i=0; i<Q; i++){\n\t\tint c, x, y;\n\t\tscanf(\"%d%d%d\", &c, &x, &y);\n\t\tx--; y--;\n\t\tqs[i] = (query){c, x, y};\n\t\tif(id_table[x][y] == -1){\n\t\t\tadd_edge(x, y, 0, false);\n\t\t}\n\t}\n\n}\n\nbool visited[MAX_N];\nint vis_time[MAX_N];\n\nbool dfs(int v, int sink){\n\tif(v == sink){\n\t\treturn true;\n\t}\n\tvisited[v] = true;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0 && !visited[e.tar] && dfs(e.tar, sink)){\n\t\t\te.cap--;\n\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rem_dfs(int v){\n\tvis_time[v] = 2;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0){\n\t\t\tif(vis_time[e.tar] == 1 || (vis_time[e.tar] == 0 && rem_dfs(e.tar))){\n\t\t\t\te.cap--;\n\t\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool remove_cycle(int x, int y){\n\tmemset(vis_time, 0, sizeof(vis_time));\n\tvis_time[y] = 1;\n\treturn rem_dfs(x);\n}\n\nvoid solve(){\n\tconst int source = 0, sink = V - 1;\n\tflow_t current = 0;\n\n\tfor(;memset(visited, false, sizeof(visited)), dfs(source, sink); current++);\n\n\tfor(int i=0; i<Q; i++){\n\t\tif(qs[i].cmd == 1){\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tgraph[x][id_table[x][y]].on = true;\n\t\t\tgraph[y][id_table[y][x]].on = true;\n\t\t\tgraph[x][id_table[x][y]].cap = 1;\n\t\t\tgraph[y][id_table[y][x]].cap = 1;\n\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\tif(dfs(source, sink)){\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tif(graph[x][id_table[x][y]].cap != 1){\n\t\t\t\t// ツ個サツ催敖づ郊 -> yツづ猟ャツづェツづつ「ツづゥツづヲツつ、ツづ可暗ェツ氾環可サ\n\t\t\t\tif(graph[x][id_table[x][y]].cap == 2){\n\t\t\t\t\tswap(x, y);\n\t\t\t\t}\n\t\t\t\tif(!remove_cycle(x, y)){\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tif(dfs(sink, source)){\n\t\t\t\t\t\tcurrent--;\n\t\t\t\t\t}\n\t\t\t\t\tint cur = graph[x][id_table[x][y]].cap;\n\t\t\t\t\tif(cur != 1){\n\t\t\t\t\t\tif(cur == 2){\n\t\t\t\t\t\t\tswap(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremove_cycle(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\tgraph[x][id_table[x][y]].cap = 0;\n\t\t\tgraph[y][id_table[y][x]].cap = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", current);\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nclass FordFulkerson\n{\npublic:\n    using type = int;\n    const int INF = 1e9;\n    struct Edge\n    {\n        // 行き先, 容量, 逆辺\n        int to;\n        type cap;\n        int rev;\n        Edge(int _t, type _c, int _r) : to(_t), cap(_c), rev(_r) {}\n    };\n\n    using Graph = std::vector<std::vector<Edge>>;\n    int V;\n    Graph G;\n    // dfs で訪問済みか\n    std::vector<bool> usd;\n\n    // 増加パスを dfs で探す\n    type dfs(int v, int t, type f)\n    {\n        if (v == t)\n            return f;\n        usd[v] = true;\n        for (auto &e : G[v])\n        {\n            if (!usd[e.to] && e.cap > 0)\n            {\n                auto d = dfs(e.to, t, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    FordFulkerson(int _v) : V(_v), G(_v), usd(_v) {}\n    // 無向辺\n    void add(int from, int to, type cap)\n    {\n        G[from].push_back(Edge{to, cap, (int)G[to].size()});\n        G[to].push_back(Edge{from, cap, (int)G[from].size() - 1});\n    }\n    // s->t の最大流を求める\n    type maxFlow(int s, int t)\n    {\n        type ret = 0;\n        while (true)\n        {\n            for (int i = 0; i < (int)G.size(); i++)\n                usd[i] = false;\n            type f = dfs(s, t, INF);\n            if (f == 0)\n                return ret;\n            ret += f;\n        }\n    }\n    type max2(int s, int t)\n    {\n        for (int i = 0; i < (int)G.size(); i++)\n            usd[i] = false;\n        return dfs(s, t, 1);\n    }\n    void printG()\n    {\n        for (const auto &v : G)\n        {\n            cout << \"!\" << endl;\n            for (const auto &e : v)\n            {\n                cout << e.to << \" \" << e.cap << endl;\n            }\n        }\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, e, q;\n    cin >> n >> e >> q;\n    FordFulkerson flow(n);\n    for (int i = 0; i < e; i++)\n    {\n        int f, t;\n        cin >> f >> t;\n        f--;\n        t--;\n        flow.add(f, t, 1);\n    }\n    int ret = flow.maxFlow(0, n - 1);\n    while (q--)\n    {\n        // cout << \"!!!\" << endl;\n        // flow.printG();\n        int m, a, b;\n        cin >> m >> a >> b;\n        a--;\n        b--;\n\n        if (m == 1)\n        {\n            flow.add(a, b, 1);\n            ret += flow.maxFlow(0, n - 1);\n            cout << ret << endl;\n            continue;\n        }\n        // 使われてない辺があるか\n        bool f = false;\n        for (auto &e : flow.G[a])\n        {\n            if (e.to == b && e.cap == 1)\n            {\n                f = true;\n                int rev = e.rev;\n                e.cap = flow.G[e.to][rev].cap = 0;\n                break;\n            }\n        }\n        if (f)\n        {\n            cout << ret << endl;\n            continue;\n        }\n        // a->b に流れているか?\n        bool dir = true;\n        for (auto &e : flow.G[a])\n        {\n            if (e.to != b)\n                continue;\n            // 削除済み辺\n            int rev = e.rev;\n            if (e.cap == 0 && flow.G[e.to][rev].cap == 0)\n                continue;\n            if (e.cap != 0)\n                dir = false;\n            break;\n        }\n        // cout << (dir ? \"TRUE\" : \"NO\") << endl;\n        if (!dir)\n            swap(a, b);\n        // 流せるパスが残っているか\n        int p = flow.max2(a, b);\n        if (p == 0)\n        {\n            ret--;\n            flow.max2(n - 1, b);\n            flow.max2(a, 0);\n        }\n        for (auto &e : flow.G[a])\n        {\n            if (e.to != b)\n                continue;\n            // 削除済み辺\n            int rev = e.rev;\n            if (e.cap == 0 && flow.G[e.to][rev].cap == 0)\n                continue;\n            flow.G[e.to][rev].cap = 0;\n            break;\n        }\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <set>\n\ntemplate <class Tp>\nTp inf() { return static_cast<Tp>(1) << (8*sizeof(Tp) - 3); }\n\ntemplate <class Tp>\nstruct Edge {\n  size_t src, dst;\n  Tp cap;\n  size_t rev;\n  Edge(size_t src, size_t dst, Tp cap, size_t rev):\n    src(src), dst(dst), cap(cap), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<Edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<Edge<Tp>>>(n) {}\n\n  void connect_with(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, cap, (*this)[src].size()-1);\n  }\n\n  void connect_to(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, 0, (*this)[src].size()-1);\n  }\n\n  void inspect() const {\n    size_t n = this->size();\n    fprintf(stderr, \"vertex: %zu\\n\", n);\n    for (size_t i = 0; i < n; ++i)\n      for (const auto& e: (*this)[i]) {\n        // fprintf(stderr, \"%zu -> %zu, cap: %zu, rev: [%zu]\\n\",\n        //         e.src, e.dst, e.cap, e.rev);\n        if (e.cap == 0) {\n          const auto& f = (*this)[e.dst][e.rev];\n          if (f.cap == 0) continue;\n          fprintf(stderr, \"%zu -> %zu\\n\", e.src, e.dst);\n        }\n      }\n  }\n};\n\ntemplate <class Tp>\nTp max_flow(graph<Tp>& g, size_t s, size_t t, Tp f0 = inf<Tp>()) {\n  Tp flow = Tp(0);\n  std::vector<size_t> iter, cost;\n\n  auto distance = [&](size_t s) {\n    std::vector<size_t> res(g.size(), inf<size_t>());\n    std::queue<size_t> q;\n    res[s] = 0;\n    q.emplace(s);\n    while (!q.empty()) {\n      size_t v = q.front();\n      q.pop();\n      for (const auto& e: g[v]) {\n        if (static_cast<Tp>(0) < e.cap && res[e.dst] == inf<size_t>()) {\n          res[e.dst] = res[v] + 1;\n          q.push(e.dst);\n        }\n      }\n    }\n    return res;\n  };\n\n  std::function<Tp (size_t, Tp)> augment = [&](size_t v, Tp f)->Tp {\n    if (v == t) return f;\n    for (size_t& i = iter[v]; i < g[v].size(); ++i) {\n      Edge<Tp>& e = g[v][i];\n      if (Tp(0) < e.cap && cost[v] < cost[e.dst]) {\n        Tp d = augment(e.dst, std::min(f, e.cap));\n        if (Tp(0) < d) {\n          e.cap -= d;\n          g[e.dst][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return static_cast<Tp>(0);\n  };\n\n  while (true) {\n    cost = distance(s);\n    if (cost[t] == inf<size_t>()) return flow;\n    iter.assign(g.size(), 0);\n    Tp f;\n    while (Tp(0) < (f = augment(s, f0))) {\n      flow += f;\n      f0 -= f;\n      if (!f0) return flow;\n    }\n  }\n}\n\nint main() {\n  size_t N, E, Q;\n  scanf(\"%zu %zu %zu\", &N, &E, &Q);\n\n  graph<intmax_t> g(N);\n  std::set<std::pair<size_t, size_t>> es0;\n  for (size_t i = 0; i < E; ++i) {\n    size_t F, T;\n    scanf(\"%zu %zu\", &F, &T);\n    --F;\n    --T;\n    g.connect_with(F, T, 1);\n    es0.insert(std::minmax(F, T));\n  }\n\n  std::vector<std::tuple<int, size_t, size_t>> qs;\n  std::set<std::pair<size_t, size_t>> es;\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    scanf(\"%d %zu %zu\", &M, &A, &B);\n    --A;\n    --B;\n    if (A > B) std::swap(A, B);\n    qs.emplace_back(M, A, B);\n    if (!es0.count(std::make_pair(A, B)))\n      es.emplace(A, B);\n  }\n\n  for (const auto& e: es) {\n    size_t s, d;\n    std::tie(s, d) = e;\n    g.connect_with(s, d, 0);\n  }\n\n  // g.inspect();\n  intmax_t first = max_flow(g, 0, N-1);\n  // fprintf(stderr, \"first: %jd\\n\", first);\n\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    std::tie(M, A, B) = qs[i];\n    intmax_t df = 0;\n\n    // g.inspect();\n\n    if (M == 1) {\n      // connect\n      // fprintf(stderr, \"+ %zu %zu\\n\", A, B);\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        e.cap = 1;\n        g[B][e.rev].cap = 1;\n        df = max_flow(g, 0, N-1);\n        break;\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n\n    if (M == 2) {\n      // disconnect\n      // fprintf(stderr, \"- %zu %zu\\n\", A, B);\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        if (e.cap > 0 && g[B][e.rev].cap > 0) {\n          e.cap = 0;\n          g[B][e.rev].cap = 0;\n          break;\n        }\n\n        if (e.cap == 0) {\n          intmax_t tmp = max_flow(g, e.src, e.dst, 1L);\n          if (tmp == 0) {\n            df = -max_flow(g, N-1, 0, 1L);\n            max_flow(g, e.src, e.dst, 1L);\n          }\n          e.cap = 0;\n          g[B][e.rev].cap = 0;\n          break;\n        }\n        if (g[B][e.rev].cap == 0) {\n          intmax_t tmp = max_flow(g, e.dst, e.src, 1L);\n          if (tmp == 0) {\n            df = -max_flow(g, N-1, 0, 1L);\n            max_flow(g, e.dst, e.src, 1L);\n          }\n          e.cap = 0;\n          g[B][e.rev].cap = 0;\n          break;\n        }\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n  }\n\n  // g.inspect();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll r = 0;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n                    G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n                    G[A].erase(G[A].begin()+j, G[A].begin()+j+1);\n                    break;\n                }\n            }\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow - G[to][x.rev].cap;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow - G[to][x.rev].cap;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint V,E;\nint G[501][501]; // ??°???????????£??\\???????????¨???\nvector<int> used; // DFS??§?????§???????????????????????°\n\n// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n    G[from][to] = G[to][from] = cap;\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < V; i++) {\n        auto &cap = G[v][i];\n        if (!used[i] && cap > 0) {\n            int d = dfs(i, t, min(f, cap));\n            if (d > 0) {\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> V >> E;\n    int Q; cin >> Q;\n    for(int i = 0; i < 501;i++){\n        for(int j = 0;j < 501;j++){\n            G[i][j] = 0;\n        }\n    }\n    used.resize(V);\n    for (int i = 0; i < E;i++) {\n        int s, t; cin >> s >> t;\n        s--;t--;\n        add_edge(s, t, 1);\n    }\n    \n    int f = max_flow(0, V - 1);\n    cout << endl;\n    cout << \"===================\" << endl;\n    for(int i = 0;i < V;i++){\n        for(int j = 0; j < V;j++){\n            if(G[i][j] == 0)continue;\n            cout << \"[\" << i << \"=>\" <<j<<\" : \" << G[i][j] << \"] \";\n        }\n        cout << endl;\n    }\n    for(int i = 0; i < Q;i++){\n        int M,A,B; cin >> M >> A >> B;\n        A--;B--;\n        if(M == 1){\n            G[A][B] = G[B][A] = 1;\n            fill(used.begin(),used.end(),0);\n            f += dfs(0,V-1,INF);\n        }else{\n            if(G[A][B] == 0 || G[B][A] == 0){\n                int u,v;\n                if(G[A][B] == 0){ u = A; v = B;}\n                else{u = B; v = A;}\n                if(dfs(u,v,INF) == 0){\n                    fill(used.begin(),used.end(),0);\n                    dfs(u,0,INF);\n                    fill(used.begin(),used.end(),0);\n                    dfs(V-1,v,INF);\n                    f--;\n                    dfs(0,V-1,INF);\n                }\n            }\n            G[A][B] = G[B][A] = 0;\n        }\n        cout << f << endl;\n        cout << \"===================\" << endl;\n        for(int i = 0;i < V;i++){\n            for(int j = 0; j < V;j++){\n                if(G[i][j] == 0)continue;\n                cout << \"[\" << i << \"=>\" <<j<<\" : \" << G[i][j] << \"] \";\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nconst int MAX_V=500,inf=1e8;\nmap<int,int> G[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int from, int to, int cap){\n\tG[from][to]=G[to][from]=cap;\n}\nvoid erase_edge(int from,int to){\n\tG[from].erase(to);\n\tG[to].erase(from);\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(auto &e:G[v]){\n\t\tif(!used[e.fs] && e.sc>0){\n\t\t\tint d=dfs(e.fs,t,min(f,e.sc));\n\t\t\tif(d>0){\n\t\t\t\te.sc-=d;\n\t\t\t\tG[e.fs][v]+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,inf);\n\t\tif(f==0) return flow;\n\t\tflow+=f;\n\t}\n}\nint main(){\n\tint N,E,Q;\n\tcin>>N>>E>>Q;\n\trep(i,E){\n\t\tint F,T;\n\t\tcin>>F>>T;\n\t\tadd_edge(F-1,T-1,1);\n\t}\n\tint now=max_flow(0,N-1);\n\trep(i,Q){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\ta--,b--;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1);\n\t\t\tnow+=max_flow(0,N-1);\n\t\t}else{\n\t\t\tint ecap=G[a][b];\n\t\t\terase_edge(a,b);\n\t\t\tif(ecap==2) swap(a,b);\n\t\t\tif(ecap!=1){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tint f=dfs(a,b,1);\n\t\t\t\tif(f==0){\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tdfs(a,0,1);\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tdfs(N-1,b,1);\n\t\t\t\t\tnow--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",now);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G[from].size();\n  M[to][from]=G[to].size();\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,0,G[from].size()-1));\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, int lim){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0||lim==0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,lim))>0){\n      flow+=f;\n      lim-=f;\n    }\n  }\n}\n\nint max_flow(int s,int t){\n  return max_flow(s,t,INF);\n}\n\nbool back_edge(int s,int t,int from, int to){\n  for(int i=0;i<(int)G[from].size();i++) {\n    edge& e=G[from][i];\n    if(e.to == to) {\n      if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n\tmax_flow(from, s, 1);\n\tmax_flow(t, to, 1);\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  int ans=max_flow(1,N);\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      if(M[a].find(b)==M[a].end()) add_edge(a,b,1);\n      else G[a][M[a][b]].cap=G[b][M[b][a]].cap=1;\n    }else{\n      ans-=back_edge(1,N,a,b);\n      ans-=back_edge(1,N,b,a);\n      G[a][M[a][b]].cap=G[b][M[b][a]].cap=0;\n    }\n    ans+=max_flow(1,N);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nclass FF{\n\tpublic :\n\t\tvoid init(int _n){\n\t\t\tn=_n;\n\t\t\tG.resize(n);\n\n            rep(a, n){\n                G[a] = vector<edge>(2 * n);\n            }\n            rep(a, n){\n                rep(b, n){\n                    G[a][b]     = {b, 0, n + a};\n                    G[b][n + a] = {a, 0, b};\n                }\n            }\n\t\t}\n\n\t\tvoid add_edge(int from,int to ,ll cap){\n\t\t\tG[from][to].cap = cap;\n\t\t}\n\t\n\t\tvoid add_edge_both(int from,int to ,ll cap){\n\t\t\tadd_edge(from,to,cap);\n\t\t\tadd_edge(to,from,cap);\n\t\t}\n\t\n\t\tll max_flow(int s,int t){\n\t\t\tll flow=0;\n\t\t\tfor(;;){\n                used = vi(n);\n                ll f = dfs(s, t, inf);\n                if(f == 0) return flow;\n                flow += f;\n\t\t\t}\n\t\t}\n\n        ll connect(int a, int b){\n            G[a][b].cap = G[b][a].cap = 1;\n            used = vi(n);\n            ll ret = dfs(0, n-1, 1);\n            return ret;\n        }\n\n        ll disconnect(int a, int b){\n            ll ret = 0;\n\n            rep(loop, 2){\n                if(G[a][b].cap > 0){ // not used a->b\n                    G[a][b].cap = 0;\n                }\n                else if(G[a][b].cap == 0 and G[b][n+a].cap > 0){ // used\n                    used = vi(n);\n                    if(dfs(a, b, 1) == 0){\n                        used2 = vi(n); dfs2(n-1, b);\n                        used2 = vi(n); dfs2(a, 0);\n                        ret -= 1;\n                    }\n                    G[b][n+a].cap = 0;\n                }\n                swap(a, b);\n            }\n\n            return ret;\n        }\n\tprivate:\n\t\n\t\tint n;\n\t\tstruct edge{int to; ll cap; int rev;};\n\t\tvector< vector<edge> > G;\n        vi used, used2;\n\n        bool dfs2(int v, int z){\n            used2[v] = true;\n            if(v == z){\n                return true;\n            }\n            for(auto& e : G[v]){\n                if(e.cap == 0 or used2[e.to]) continue;\n                if(dfs2(e.to, z)){\n                    e.cap = 0;\n                    G[e.to][e.rev].cap = 1;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n\t\tll dfs(int v,int t,ll f){\n\t\t\tif(v == t) return f;\n            used[v] = true;\n            for(auto& e : G[v]){\n                if(used[e.to] or e.cap == 0) continue;\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n\t\t\treturn 0;\n\t\t}\n};\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, Q; cin >> n >> m >> Q;\n    FF ff;\n    ff.init(n);\n\n    rep(loop, m){\n        int a, b; cin >> a >> b;\n        a--, b--;\n        ff.add_edge_both(a, b, 1);\n    }\n\n    int s = 0, t = n - 1;\n    ll f = ff.max_flow(s, t);\n\n    rep(loop, Q){\n        int op, a, b; cin >> op >> a >> b;\n        a--, b--;\n\n        // connect\n        if(op == 1){\n            f += ff.connect(a, b);\n        }\n\n        // disconnect\n        else { assert(op == 2);\n            f += ff.disconnect(a, b);\n        }\n\n        cout << f << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\t//cout << re.cap << ' ' << G[a][re.rev].cap << endl;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\t//cout << ba.cap << ' ' << rba.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tshow(fordFulkerson(s,t))\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tshow(fordFulkerson(s,t))\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\t\tshow(fordFulkerson(s,t))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tused[t][f] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nint main() {\n  int N, E, Q; cin >>N >>E >>Q;\n  vector<int> v(N, 0);\n  REP(i, E){\n    int s, t; cin >>s >>t;\n    if(s > t) swap(s, t);\n    FOR(j, s, t) ++v[j];\n  }\n  REP(i, Q){\n    int type, s, t; cin >>type >>s >>t;\n    if(s > t) swap(s, t);\n    if(type == 1) FOR(j, s, t) ++v[j];\n    else FOR(j, s, t) --v[j];\n    int ans = 1e9;\n    FOR(j, 1, v.size()) ans = min(ans, v[j]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct flowGraph{\n\tstruct edge{ int to, cap, rev; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tint add(int s, int t, int cap){\n\t\tG[s].pb((edge){t, cap, G[t].size()});\n\t\tG[t].pb((edge){s, 0, G[s].size() - 1});\n\t\treturn G[s].size() - 1;\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t, int lim = inf){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, lim - flow)) > 0) flow += f;\n\t\t\tif(flow == lim) return flow;\n\t\t}\n\t}\n};\nint n, e, q;\nint m[1000], a[1000], b[1000];\n\nint main(){\n\tcin >> n >> e >> q;\n\tmap<pi, int> id;\n\tflowGraph g(n);\n\trep(i, e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\trep(it, 2){\n\t\t\tint j = g.add(f, t, 1);\n\t\t\tif(!id.count(mp(f, t))) id[mp(f, t)] = j;\n\t\t\tswap(f, t);\n\t\t}\n\t}\n\trep(i, q){\n\t\tcin >> m[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\trep(it, 2){\n\t\t\tif(!id.count(mp(a[i], b[i]))){\n\t\t\t\tint j = g.add(a[i], b[i], 0);\n\t\t\t\tid[mp(a[i], b[i])] = j;\n\t\t\t}\n\t\t\tswap(a[i], b[i]);\n\t\t}\n\t}\n\tint ans = g.max_flow(0, n - 1);\n\t\n\trep(i, q){\n\t\tif(m[i] == 1){\n\t\t\tg.G[a[i]][id[mp(a[i], b[i])]].cap++;\n\t\t\tg.G[b[i]][id[mp(b[i], a[i])]].cap++;\n\t\t\tans += g.max_flow(0, n - 1);\n\t\t}\n\t\telse{\n\t\t\tint j = id[mp(a[i], b[i])];\n\t\t\tif(g.G[b[i]][g.G[a[i]][j].rev].cap == 0){\n\t\t\t\tswap(a[i], b[i]);\n\t\t\t\tj = id[mp(a[i], b[i])];\n\t\t\t}\n\t\t\tg.G[b[i]][id[mp(b[i], a[i])]].cap = 0;\n\t\t\t\n\t\t\tint t = g.max_flow(a[i], b[i], 1);\n\t\t\tif(!t){\n\t\t\t\tg.max_flow(n - 1, 0, 1);\n\t\t\t\tint u = g.max_flow(a[i], b[i], 1);\n\t\t\t\tassert(u);\n\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cap, rev;\n  Edge(int u, int v, int c, int r) :\n    src(u), dst(v), cap(c), rev(r) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nbool used[500];\nint dfs(int u, int t, int f){\n  if(u == t) return f;\n  used[u] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0 && !used[e->dst]){\n      int d = dfs(e->dst, t, min(f, e->cap));\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nvoid max_flow(int &flow, int S, int T){\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(S, T, INF);\n    if(f == 0) return;\n    flow += f;\n  }\n}\nvoid add_edge(int u, int v){\n  G[u].push_back(Edge(u, v, 1, G[v].size()));\n  G[v].push_back(Edge(v, u, 1, G[u].size() - 1));\n}\n \nint main(){\n  int N, E, Q;\n  while(cin >> N >> E >> Q){\n    G = Graph(N);\n    REP(i, E){\n      int A, B;\n      cin >> A >> B;\n      A--; B--;\n      add_edge(A, B);\n    }\n    int S = 0, T = N - 1;\n    int flow = 0;\n    max_flow(flow, S, T);\n    REP(i, Q){\n      int M, A, B;\n      cin >> M >> A >> B;\n      A--; B--;\n      if(M == 1){\n        add_edge(A, B);\n        max_flow(flow, S, T);\n      }else{\n        FORIT(e, G[A])if(e->dst == B && e->cap == 2){\n          memset(used, 0, sizeof(used));\n          if(dfs(B, A, 1) == 1){\n            goto ERASE;\n          }\n          memset(used, 0, sizeof(used));\n          assert(dfs(T, A, 1) == 1);\n          memset(used, 0, sizeof(used));\n          assert(dfs(B, S, 1) == 1);\n          flow--;\n          goto ERASE;\n        }\n        FORIT(e, G[B])if(e->dst == A && e->cap == 2){\n          memset(used, 0, sizeof(used));\n          if(dfs(A, B, 1) == 1){\n            goto ERASE;\n          }\n          memset(used, 0, sizeof(used));\n          assert(dfs(T, B, 1) == 1);\n          memset(used, 0, sizeof(used));\n          assert(dfs(A, S, 1) == 1);\n          flow--;\n          goto ERASE;\n        }\n        ERASE:\n          FORIT(e, G[A]) if(e->dst == B) { G[A].erase(e); break; }\n          FORIT(e, G[B]) if(e->dst == A) { G[B].erase(e); break; }\n        FLOW:\n          max_flow(flow, S, T);\n      }\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, cap, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int u, int v){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == v){\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\treturn dinic(s, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false and \"invalid u, v\");\n\t\t\treturn -INF;\n\t\t}\n\t\tint subCapacity(int s, int t, int u, int V){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == V){\n\t\t\t\t\tint d = e.cap;\n\t\t\t\t\te.cap = G[V][e.rev].cap = 0;\n\t\t\t\t\tif(d == 1) return 0;\n\t\t\t\t\tif(d == 2){\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs(V, u, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(t, u, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(V, s, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs(u, V, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(t, V, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs(u, s, 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -INF;\n\t\t}\n\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]){\n\t\t\tflow.addEdge(a[i], b[i], 0);\n\t\t\tuse[a[i]][b[i]] = use[b[i]][a[i]] = true;\n\t\t}\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s,0,INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.dinic(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1) ans += flow.addCapacity(s, t, a[i], b[i]);\n\t\telse ans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n\nint N,E,Q;\nvector<set<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(auto i=edge[from].begin();i!=edge[from].end();i++){\n    int to = *i;\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].insert(b);\n  edge[b].insert(a);\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  edge[a].erase(b);\n  edge[b].erase(a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n      f--;\n    }\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t}\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,0,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tbool ok=false;\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]!=v)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ³Éß·\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\t//cout << re.cap << ' ' << G[a][re.rev].cap << endl;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\t//cout << ba.cap << ' ' << rba.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\t\tshow(fordFulkerson(s,t))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tused[t][f] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\ntemplate<typename T,bool directed>\nstruct Dinic{\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n    edge(){}\n    edge(int to,T cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  vector<vector<edge> > G;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int n):G(n),level(n),iter(n){}\n\n  int add_edge(int from,int to,T cap){\n    G[from].emplace_back(to,cap,G[to].size());\n    G[to].emplace_back(from,directed?0:cap,G[from].size()-1);\n    return G[to].back().rev;\n  }\n\n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.emplace(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n\n  T dfs(int v,int t,T f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        T d=dfs(e.to,t,min(f,e.cap));\n        if(d==0) continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\n  T flow(int s,int t,T lim){\n    T fl=0;\n    while(1){\n      bfs(s);\n      if(level[t]<0||lim==0) break;\n      fill(iter.begin(),iter.end(),0);\n\n      while(1){\n        T f=dfs(s,t,lim);\n        if(f==0) break;\n        fl+=f;\n        lim-=f;\n      }\n    }\n    return fl;\n  }\n\n  T flow(int s,int t){\n    return flow(s,t,numeric_limits<T>::max()/2);\n  }\n\n  T cut(int s,int t,int x,int a){\n    static_assert(directed, \"must be directed\");\n    auto &e=G[x][a];\n    int y=e.to;\n    T cr=G[y][e.rev].cap;\n    if(cr==0) return e.cap=0;\n    e.cap=G[y][e.rev].cap=0;\n    T cap=cr-flow(x,y,cr);\n    if(x!=s&&cap!=0) flow(x,s,cap);\n    if(t!=y&&cap!=0) flow(t,y,cap);\n    return cap;\n  }\n\n  T link(int s,int t,int x,int a,T f){\n    auto &e=G[x][a];\n    e.cap+=f;\n    return flow(s,t,f);\n  }\n};\n\n//INSERT ABOVE HERE\n\n\nsigned main(){\n  int n,e,q;\n  cin>>n>>e>>q;\n  Dinic<int, true> G(n);\n  vector< map<int, int> > I(n);\n  for(int i=0;i<e;i++){\n    int f,t;\n    cin>>f>>t;\n    f--;t--;\n    I[f][t]=G.add_edge(f,t,1);\n    I[t][f]=G.add_edge(t,f,1);\n  }\n\n  vector<int> ms(q),as(q),bs(q);\n  for(int i=0;i<q;i++){\n    cin>>ms[i]>>as[i]>>bs[i];\n    as[i]--;bs[i]--;\n    if(I[as[i]].count(bs[i])) continue;\n    I[as[i]][bs[i]]=G.add_edge(as[i],bs[i],0);\n    I[bs[i]][as[i]]=G.add_edge(bs[i],as[i],0);\n  }\n\n  int res=G.flow(0,n-1);\n  for(int i=0;i<q;i++){\n    if(ms[i]==1){\n      res+=G.link(0,n-1,as[i],I[as[i]][bs[i]],1);\n      res+=G.link(0,n-1,bs[i],I[bs[i]][as[i]],1);\n    }\n    if(ms[i]==2){\n      res-=G.cut(0,n-1,as[i],I[as[i]][bs[i]]);\n      res-=G.cut(0,n-1,bs[i],I[bs[i]][as[i]]);\n    }\n    cout<<res<<\"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0) {\n          if(to != graph.size() - 1) max_flow(graph.size() - 1, to, 1);\n          if(from != 0) max_flow(from, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a))return 0;\n\t\t\t\tif(!flow(b, 1))return 0;\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b))return 0;\n\t\t\t\tif(!flow(a, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define crear_vec(v,n) v.clear();v.resize(n);\n#define delete_vec(v,n) v.erase(remove(v.begin(),v.end(),n),v.end());\ntypedef pair<int,int> pii;\nint N,E,Q;\nvector<vector<pii> > edge;\nint f;\nvoid flow(int from,int to){\n  for(int i=0;i<edge[from].size();i++){\n    if(edge[from][i].first==to)edge[from][i].second++;\n  }\n  for(int j=0;j<edge[to].size();j++){\n    if(edge[to][j].first == from)edge[to][j].second--;\n  }\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    if(used[edge[from][i].first]==1)continue;\n    if(edge[from][i].second<1&&dfs_(edge[from][i].first,to)==1){\n      flow(from,edge[from][i].first);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  crear_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(pii(b,0));\n  edge[b].push_back(pii(a,0));\n  while(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff;\n  for(int i=0;i<edge[a].size();i++){\n    if(edge[a][i].first==b){\n      ff=edge[a][i].second;\n      delete_vec(edge[a],edge[a][i]);\n      break;\n    }\n  }\n  for(int i=0;i<edge[b].size();i++){\n    if(edge[b][i].first==a){\n      delete_vec(edge[b],edge[b][i]);\n      break;\n    }\n  }\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(dfs(a,b)){\n      cerr<<\"roop\"<<endl;\n    }else if(dfs(N,b)&&dfs(a,1)){\n      cerr<<\"dec flow\"<<endl;\n      f--;\n    }else {\n      cerr<<\"err\"<<endl;\n    }\n  }\n  while(dfs(1,N))f++;\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  crear_vec(edge,N+1);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  while(dfs(1,N));\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  if(m==1){\n    add_edge(a,b);\n  }else if(m==2){\n    cut_edge(a,b);\n  }\n  return f;\n}\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    //*/\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\n//?????¬\n\n#define MAX_V 20001\n#define INF INT_MAX/6\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G(MAX_V); // ??°???????????£??\\???????????¨???\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\n // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to) {\n\tbool f = true;\n\tfor (auto i = G[from].begin(); i < G[from].end();)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\t(*i).cap = 1;\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tG[from].push_back({ to,1, (int)G[to].size() });\n\t}\n\tf = true;\n\tfor (auto i = G[to].begin(); i < G[to].end();)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 1;\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (f) {\n\t\tG[to].push_back({ from, 1, (int)G[from].size() - 1 });\n\t}\n}\n\n// from??????to????????????????????????cap???0??¨?????????\nvoid del_edge(int from, int to) {\n\tfor (auto i = G[from].begin(); i < G[from].end(); i++)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\t(*i).cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (auto i = G[to].begin(); i < G[to].end(); i++)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor (size_t i = 0; i < E; i++)\n\t{\n\t\tint F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge(F, T);\n\t}\n\tfor (size_t i = 0; i < Q; i++)\n\t{\n\t\tint M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif (M == 1)\n\t\t{\n\t\t\tadd_edge(A, B);\n\t\t}\n\t\telse {\n\t\t\tdel_edge(A, B);\n\t\t}\n\t\tauto G_ = G;\n\t\tcout << max_flow(0, N - 1) << endl;\n\t\tG = G_;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing graph = vector<vector<int>>;\n\nint dfs(graph& g, vector<bool>& visited, vector<vector<int>>& cap, int v, int t) {\n    if(v == t) {\n        return 1;\n    }\n    visited[v] = true;\n    for(auto to : g[v]) {\n        if(visited[to] || cap[v][to] == 0) {\n            continue;\n        }\n        if(dfs(g, visited, cap, to, t) == 1) {\n            cap[to][v]++;\n            cap[v][to]--;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint max_flow(graph& g, vector<vector<int>>& cap, int s, int t, int cnt = 100000) {\n    vector<bool> visited(g.size());\n    int f = 0;\n    while(cnt--) {\n        fill(visited.begin(), visited.end(), false);\n        if(dfs(g, visited, cap, s, t) == 1) {\n            f++;\n        } else {\n            break;\n        }\n    }\n    return f;\n}\n\nint main() {\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    graph g(N);\n    vector<vector<int>> cap(N, vector<int>(N));\n    auto add_edge = [&](int from, int to) {\n        g[from].push_back(to);\n        g[to].push_back(from);\n        cap[from][to] = cap[to][from] = 1;\n    };\n    for(int i = 0; i < E; ++i) {\n        int f, t;\n        cin >> f >> t;\n        f--; t--;\n        add_edge(f, t);\n    }\n\n    int res = max_flow(g, cap, 0, N - 1);\n    while(Q--) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        a--; b--;\n        if(m == 1) {\n            add_edge(a, b);\n        } else {\n            // used b -> a\n            if(cap[a][b] == 2) {\n                // doesn't exist circuit b -> a on residual graph\n                if(max_flow(g, cap, b, a, 1) == 0) {\n                    max_flow(g, cap, N - 1, 0, 1);\n                    max_flow(g, cap, b, a, 1);\n                    res--;\n                }\n            } else if(cap[b][a] == 2) {\n                if(max_flow(g, cap, a, b, 1) == 0) {\n                    max_flow(g, cap, N - 1, 0, 1);\n                    max_flow(g, cap, a, b, 1);\n                    res--;\n                }\n            }\n\n            cap[a][b] = cap[b][a] = 0;\n            g[a].erase(find(g[a].begin(), g[a].end(), b));\n            g[b].erase(find(g[b].begin(), g[b].end(), a));\n        }\n\n        res += max_flow(g, cap, 0, N - 1);\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct edge{ int to, cap, rev, alive; };\n\nvector<edge> G[500];\nbool used[500];\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),true});\n  G[to].push_back((edge){from,cap,(int)G[from].size()-1,true});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    if(!e.alive)continue;\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int lim){\n  int flow=0;\n  while(lim>0){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,lim);\n    if(f==0)break;\n    flow+=f;\n    lim-=f;\n  }\n  return flow;\n}\n\nint N,M,Q;\n\nint main(){\n  cin>>N>>M>>Q;\n  rep(i,M){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b,1);\n  }\n  int src=0,sink=N-1;\n  int crtf=max_flow(src,sink,INF);\n  while(Q--){\n    int t,u,v;\n    cin>>t>>u>>v;\n    u--;v--;\n    if(t==1){\n      add_edge(u,v,1);\n      crtf+=max_flow(src,sink,1);\n      cout<<crtf<<endl;\n    }else{\n      rep(i,G[u].size()){\n        if(G[u][i].to==v&&G[u][i].alive){\n          G[u][i].alive=false;\n          if(G[u][i].cap==0&&max_flow(u,v,1)==0){\n            max_flow(u,src,1); max_flow(sink,v,1);\n            crtf-=1;\n          }\n          break;\n        }\n      }\n      rep(i,G[v].size()){\n        if(G[v][i].to==u&&G[v][i].alive){\n          G[v][i].alive=false;\n          if(G[v][i].cap==0&&max_flow(v,u,1)==0){\n            max_flow(v,src,1); max_flow(sink,u,1);\n            crtf-=1;\n          }\n          break;\n        }\n      }\n      cout<<crtf<<endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint n;\nvector<vector<Edge> > edges;\nvector<bool> used;\n\nint dfs(int s, int t, int f){\n    if(s == t)\n        return f;\n\tused[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 0){\n            int g = dfs(e.to, t, min(f, e.cap));\n            if(g > 0){\n                e.cap -= g;\n                edges[e.to][e.rev].cap += g;\n                return g;\n            }\n        }\n    }\n    return 0;\n}\n\nint flow(int s, int t, int f){\n\tused.assign(n+1, false);\n\treturn dfs(s, t, f);\n}\n\nint main()\n{\n\tint e, q;\n\tcin >> n >> e >> q;\n\n\tedges.assign(n+1, vector<Edge>());\n\tfor(int i=0; i<e; ++i){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tedges[f].push_back(Edge(t, 1, edges[t].size()));\n\t\tedges[t].push_back(Edge(f, 1, edges[f].size()-1));\n\t}\n\n\tint ret = 0;\n\tfor(;;){\n\t\tint f = flow(1, n, INT_MAX);\n\t\tif(f == 0)\n\t\t\tbreak;\n\t\tret += f;\n\t}\n\n\tfor(int i=0; i<q; ++i){\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tunsigned j = 0;\n\t\t\twhile(j < edges[a].size() && edges[a][j].to != b)\n\t\t\t\t++ j;\n\t\t\tif(j < edges[a].size()){\n\t\t\t\tedges[a][j].cap = 1;\n\t\t\t\tedges[b][edges[a][j].rev].cap = 1;\n\t\t\t}else{\n\t\t\t\tedges[a].push_back(Edge(b, 1, edges[b].size()));\n\t\t\t\tedges[b].push_back(Edge(a, 1, edges[a].size()-1));\n\t\t\t}\n\t\t\tret += flow(1, n, 1);\n\t\t}else{\n\t\t\tunsigned j = 0;\n\t\t\twhile(edges[a][j].to != b)\n\t\t\t\t++ j;\n            if(edges[a][j].cap == 1){\n\t\t\t\tedges[a][j].cap = 0;\n\t\t\t\tedges[b][edges[a][j].rev].cap = 0;\n            }else{\n                if(edges[a][j].cap != 0){\n                    j = edges[a][j].rev;\n                    swap(a, b);\n                }\n\t\t\t\tedges[b][edges[a][j].rev].cap = 0;\n                if(flow(a, b, 1) == 0){\n\t\t\t\t    flow(a, 1, 1);\n\t\t\t\t    flow(n, b, 1);\n\t\t\t        -- ret;\n\t\t\t        ret += flow(1, n, 1);\n                }\n            }\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int V = 500;\nconstexpr int INF = 1000000000;\ntypedef int Weight;\nstruct Edge{\n  \tint src, dest;\n  \tint cap, rev;\n  \tWeight weight;\n  \tbool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n//FordFulkerson(O(F|E|))-----------------------------------------------------------\n//???????????°|V|?????????\nbool add_edge_impl(Graph &g, int src, int dest) {\n  for (int i = 0; i < g[src].size(); ++i) {\n    if (g[src][i].dest == dest) {\n      g[src][i].weight = 0;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid add_edge(Graph &g, int src, int dest) {\n  if (!add_edge_impl(g, src, dest)) {\n    g[src].push_back((Edge){src, dest, 1, g[dest].size(), 0});\n    g[dest].push_back((Edge){dest, src, 1, g[src].size() - 1, 0});\n  } else {\n    add_edge_impl(g, dest, src);\n  }\n}\n\nvoid remove_edge_impl(Graph &g, int src, int dest) {\n  for (int i = 0; i < g[src].size(); ++i) {\n    if (g[src][i].dest == dest) g[src][i].weight = 1;\n  }\n}\n\nvoid remove_edge(Graph &g, int src, int dest) {\n  remove_edge_impl(g, src, dest);\n  remove_edge_impl(g, dest, src);\n}\n\nbool visited[V];\nint dfs(Graph &g, int v, int t, int f) {\n\tif (v == t) return f;\n\tvisited[v] = true;\n\tREP(i, g[v].size()) {\n\t\tEdge& e = g[v][i];\n    if (e.weight == 1) continue;\n\t\tif (!visited[e.dest] && e.cap > 0) {\n\t\t\tint d = dfs(g, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(Graph &g, int s, int t) {\n\tint flow = 0;\n\tfor(;;) {\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tint f = dfs(g, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint main() {\n  int n,e,q;\n  cin>>n>>e>>q;\n  Graph g(V);\n  REP(i,e) {\n    int f,t;\n    cin>>f>>t;\n    --f;--t;\n    add_edge(g, f, t);\n  }\n  int flow = 0;\n  REP(i,q) {\n    int m, a, b;\n    cin>>m>>a>>b;\n    --a;--b;\n    if (m==1) {\n      add_edge(g, a, b);\n      flow += max_flow(g, 0, n-1);\n      cout << flow << endl;\n    } else {\n      remove_edge(g, a, b);\n      REP(j,n) {\n        for (auto& e:g[j]) e.cap = 1;\n      }\n      flow = max_flow(g, 0, n-1);\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 500; // TODO:initialize\nconst int F_INF = 19191919; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint main()\n{\n    int n,e,q;\n    scanf(\" %d %d %d\", &n, &e, &q);\n    rep(i,e)\n    {\n        int f,t;\n        scanf(\" %d %d\", &f, &t);\n        --f;\n        --t;\n        add_edge(f,t,1);\n    }\n\n    int f = max_flow(0,n-1);\n    while(q--)\n    {\n        int m,a,b;\n        scanf(\" %d %d %d\", &m, &a, &b);\n        --a;\n        --b;\n        if(m==1)\n        {\n            bool found = false;\n            rep(i,G[a].size())\n            {\n                if(G[a][i].to==b)\n                {\n                    G[a][i].cap = 1;\n                    G[b][G[a][i].rev].cap = 1;\n                    found = true;\n                    break;\n                }\n            }\n\n            if(!found) add_edge(a,b,1);\n            f += max_flow(0,n-1);\n        }\n        else\n        {\n            int id = -1;\n            rep(i,G[a].size())\n            {\n                if(G[a][i].to==b)\n                {\n                    id = i;\n                    int CAP = G[a][i].cap;\n                    if(CAP!=1)\n                    {\n                        if(CAP==2) swap(a,b);\n                        break;\n                    }\n                }\n            }\n\n            assert(id!=-1);\n            if(G[a][id].cap==0)\n            {\n                --f;\n                int now = a;\n                while(now!=0)\n                {\n                    rep(i,G[now].size())\n                    {\n                        if(G[now][i].cap==2)\n                        {\n                            int nx = G[now][i].to;\n                            G[now][i].cap = 1;\n                            G[nx][G[now][i].rev].cap = 1;\n\n                            now = nx;\n                            break;\n                        }\n                    }\n                }\n\n                now = b;\n                while(now!=n-1)\n                {\n                    rep(i,G[now].size())\n                    {\n                        if(G[now][i].cap==0)\n                        {\n                            int nx = G[now][i].to;\n                            G[now][i].cap = 1;\n                            G[nx][G[now][i].rev].cap = 1;\n\n                            now = nx;\n                            break;\n                        }\n                    }\n                }\n            }\n            G[a][id].cap = 0;\n            G[b][G[a][id].rev].cap = 0;\n            f += max_flow(0,n-1);\n        }\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> vvec; \n\nint dfs(int cur,int t,vvec& g,vvec& cap,vec& vis){\n    if(cur==t) return 1;\n    vis[cur] = 1;\n    for(int x=0;x<(int) g[cur].size();x++) if(g[cur][x]){\n        //訪問済み、流れているなら進まない\n        if(vis[x] || !cap[cur][x]) continue;\n        if(dfs(x,t,g,cap,vis)){\n            cap[x][cur]++;\n            cap[cur][x]--;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,vvec& g,vvec& cap,int cnt=100000){\n    int n = g.size();\n    vec vis(n);\n    int flow = 0;\n    while(cnt--){\n        for(int i=0;i<n;i++) vis[i] = 0;\n        if(dfs(s,t,g,cap,vis)) flow++;\n        else break;\n    }\n    return flow;\n}\n\nint main(){\n    int N,M,Q;\n    cin >> N >> M >> Q;\n    vvec g(N,vec(N,0)),cap(N,vec(N,0));\n    for(int i=0;i<M;i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        g[a][b] = g[b][a] = 1;\n        cap[a][b] = cap[b][a] = 1;\n    }\n    int ans = max_flow(0,N-1,g,cap);\n    for(int i=0;i<Q;i++){\n        int m,a,b;\n        cin >> m >> a >> b;\n        a--; b--;\n        if(m==1){\n            g[a][b] = g[b][a] = 1;\n            cap[a][b] = cap[b][a] = 1;\n        }else{\n            if(cap[a][b]!=1){\n                if(cap[a][b]==0) swap(a,b);\n                if(!max_flow(b,a,g,cap,1)){\n                    max_flow(b,0,g,cap,1);\n                    max_flow(N-1,a,g,cap,1);\n                    ans--;\n                }\n            }\n            cap[a][b] = cap[b][a] = 0;\n            g[a][b] = g[b][a] = 0;\n        }\n        ans += max_flow(0,N-1,g,cap);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n,m,qn;\n\nint vs[505][505]={};\nint gone[505];\n\nbool dfs(int no,int gl){\n\tif(no==gl)return true;\n\tgone[no]=1;\n\treg(to,1,n){\n\t\tif(gone[to])continue;\n\t\tif(vs[no][to]>0){\n\t\t\tif(dfs(to,gl)){\n\t\t\t\tvs[no][to]--;\n\t\t\t\tvs[to][no]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tvs[a][b]=vs[b][a]=1;\n\t}\n\t\n\tint nf=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tif(dfs(1,n))nf++;\n\t\telse break;\n\t}\n\trep(i,qn){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\tif(t==1){\n\t\t\tvs[a][b]=vs[b][a]=1;\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\telse{\n\t\t\tint fr=-1,to;\n\t\t\tif(vs[a][b]==0){\n\t\t\t\tfr=a; to=b;\n\t\t\t}\n\t\t\telse if(vs[b][a]==0){\n\t\t\t\tfr=b; to=a;\n\t\t\t}\n\t\t\tvs[a][b]=vs[b][a]=0; a=0;\n\t\t\tif(fr>=0){\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(!dfs(n,to))a=1/a;\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(!dfs(fr,1))a=1/a;\n\t\t\t\tnf--;\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(dfs(1,n))nf++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",nf);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\t//cout << re.cap << ' ' << G[a][re.rev].cap << endl;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\t//cout << ba.cap << ' ' << rba.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tif(dfs(a, b, 1)) return 0;\n\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tif(dfs(b, a, 1)) return 0;\n\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\treturn 0;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn fordFulkerson(s, t) ? 0 : - 1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tused[t][f] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nbool modify(Graph& g,int v,int sink,int flow,vi& vis)\n{\n\tif(v==sink) return true;\n\tif(vis[v]) return false;\n\tvis[v]=1;\n\tfor(int i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge e=g.es[i];\n\t\tif(e.flow==-flow){\n\t\t\tif(modify(g,e.dst,sink,flow,vis)){\n\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n,m,q;cin>>n>>m>>q && n|m|q;){\n\t\t//dump(vi({n,m,q}));\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg.AddEdge(u,v,1,1);\n\t\t}\n\t\trep(_,q){\n\t\t\tint t,u,v; cin>>t>>u>>v; u--,v--;\n\t\t\tif(t==1){\n\t\t\t\tg.AddEdge(u,v,1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint i;\n\t\t\t\tfor(i=g.head[u];i!=-1;i=g.next[i])\n\t\t\t\t\tif(g.es[i].dst==v && g.es[i].cap==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\tg.es[i].cap=g.es[i^1].cap=0;\n\t\t\t\tif(g.es[i].flow){\n\t\t\t\t\tif(g.es[i].flow==-1) swap(u,v);\n\t\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\t\tvi vis(n);\n\t\t\t\t\tassert(modify(g,v,n-1,-1,vis));\n\t\t\t\t\tfill(all(vis),0);\n\t\t\t\t\tassert(modify(g,u,0,1,vis));\n\t\t\t\t}\n\t\t\t}\n\t\t\tDinic(g,0,n-1);\n\t\t\t//for(int i=0;i<n;i++){\n\t\t\t//\tprintf(\"%d:\",i);\n\t\t\t//\tfor(int j=g.head[i];j!=-1;j=g.next[j]){\n\t\t\t//\t\tEdge e=g.es[j];\n\t\t\t//\t\tprintf(\" (%d,%d/%d)\",e.dst,e.flow,e.cap);\n\t\t\t//\t}\n\t\t\t//\tputs(\"\");\n\t\t\t//}\n\t\t\tint res=0;\n\t\t\tfor(int j=g.head[0];j!=-1;j=g.next[j])\n\t\t\t\tres+=g.es[j].flow;\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 2000;\nconst int IINF = INT_MAX;\ntypedef pair<int,int> ii;\n\nmap<ii,int> mp; /////////\n\nstruct Edge{ int to,cap,rev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  assert( mp.count(ii(from,to)) == 0 );\n  mp[ii(from,to)] = (int)G[from].size();\n  G[from].push_back((Edge){to,cap,G[to].size()});\n  G[to].push_back((Edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,IINF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(); }\n\nint V,E,Q;\n\n\ninline void remove_edge(int u,int v){\n  G[u][mp[ii(u,v)]].cap = 0;\n  G[v][G[u][mp[ii(u,v)]].rev].cap = 0;\n  G[v][mp[ii(v,u)]].cap = 0;\n  G[u][G[v][mp[ii(v,u)]].rev].cap = 0;\n}\n\ninline bool remove(int u,int v,int source,int sink){\n  //Back:;\n  if( G[u][mp[ii(u,v)]].cap == 1 && G[v][mp[ii(v,u)]].cap == 1 ) {\n    remove_edge(u,v);\n    return false;\n  }\n/*\n  if( G[u][mp[ii(u,v)]].cap == 0 && G[v][mp[ii(v,u)]].cap == 0 ){\n    G[u][mp[ii(u,v)]].cap = 1;\n    G[v][G[u][mp[ii(u,v)]].rev].cap = 0;\n    G[v][mp[ii(v,u)]].cap = 1;\n    G[u][G[v][mp[ii(v,u)]].rev].cap = 0;\n    goto Back;\n  }\n*/\n\n  if( G[u][mp[ii(u,v)]].cap == 1 ) swap(u,v);\n  memset(used,false,sizeof(used));\n  int tmp = dfs(u,v,IINF);\n  bool ret = false;\n  if( tmp == 0 ) {\n    memset(used,false,sizeof(used));\n    tmp = dfs(sink,source,1);\n    memset(used,false,sizeof(used));\n    tmp = dfs(u,v,1);\n    assert(tmp);\n    ret = true;\n  } \n  remove_edge(u,v);\n  return ret;\n}\n\nint main(){\n\n  set<ii> S;\n  scanf(\"%d %d %d\",&V,&E,&Q);\n  rep(i,E){\n    int F,T;\n    scanf(\"%d %d\",&F,&T);\n    --F, --T;\n    add_edge(F,T,1);\n    add_edge(T,F,1);\n    if( F > T ) swap(F,T);\n    S.insert(ii(F,T));\n  }\n  int source = 0, sink = V-1;\n  int cur_flow = max_flow(source,sink);\n  rep(_,Q){\n    //cout << \"query : \" << _ << \" \";\n    int M,A,B;\n    scanf(\"%d %d %d\",&M,&A,&B);\n    --A, --B;\n    if( A > B ) swap(A,B);\n    if( M == 1 ) { // 接続\n      int F = A, T = B;\n      if( S.count(ii(F,T)) ) {\n        int pos = IINF;\n        G[A][mp[ii(A,B)]].cap = 1;\n        G[B][G[A][mp[ii(A,B)]].rev].cap = 0;\n        G[B][mp[ii(B,A)]].cap = 1;\n        G[A][G[B][mp[ii(B,A)]].rev].cap = 0;\n      } else {\n        add_edge(A,B,1);\n        add_edge(B,A,1);\n        S.insert(ii(F,T));\n      }\n      memset(used,false,sizeof(used));\n      cur_flow += dfs(source,sink,IINF);\n    } else {       // 切断\n      bool res = remove(A,B,source,sink); //| remove(B,A,source,sink);\n      if( res ) cur_flow--;\n    }\n    printf(\"%d\\n\",cur_flow);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Capacity cap;\n\tEdge(int s, int d, Capacity c) : src(s), dst(d), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tCapacity solve(int s, int t, int lim) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, lim));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tFordFulkerson ff(N + 2);\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tff.addEdge(a, b, 1);\n\t\tff.addEdge(b, a, 1);\n\t}\n\tint S = N, T = N + 1;\n\tff.addEdge(S, 0, 10000000);\n\tff.addEdge(N - 1, T, 10000000);\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tff.addEdge(A[i], B[i], 0);\n\t}\n\tint f = ff.solve(S, T, ff.inf);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tff.addEdge(u, v, 1);\n\t\t\tff.addEdge(v, u, 1);\n\t\t\tf += ff.solve(0, N - 1, 1);\n\t\t}\n\t\telse {\n\t\t\tint uv = ff.flow[u][v], vu = ff.flow[v][u];\n\t\t\tff.cap[u][v] = ff.cap[v][u] = 0;\n\t\t\tff.flow[u][v] = ff.flow[v][u] = 0;\n\n\t\t\tif(uv > vu) {\n\t\t\t\tif(ff.solve(u, v, 1) == 0) {\n\t\t\t\t\tff.solve(u, S, 1);\n\t\t\t\t\tff.solve(T, v, 1);\n\t\t\t\t\tf--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(vu > uv) {\n\t\t\t\tif(ff.solve(v, u, 1) == 0) {\n\t\t\t\t\tff.solve(v, S, 1);\n\t\t\t\t\tff.solve(T, u, 1);\n\t\t\t\t\tf--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t//cout << v << ' ' << e.to << ' ' << e.cap << endl;\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v * 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\t//cout << \"ADD\" << endl;\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\n\t\t\tab.cap += f;\n\t\t\tba.cap += f;\n\t\t\tassert(ab.cap == 1);\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\t//cout << \"SUB\" << endl;\n\t\t\tif(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\tif(ab.cap >= 1){\n\t\t\t\t//cout << \"WY\" << endl;\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\t//cout << \"HE\" << endl;\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tif(dfs(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t//cout << \"OUT\" << endl;\n\n\t\t\t\t//for(auto i : G){\n\t\t\t\t//\tfor(auto j : i){\n\t\t\t\t//\t\tcout << j.to << ' ' << j.cap << ' ' << j.rev << endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tassert(dfs(a, s, 1) == 1);\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tassert(dfs(t, b, 1) == 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = 0, t = n - 1;\n\t//flow.addEdge(s, 0, INF);\n\t//flow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tint com, a, b;\n\t\tcin >> com >> a >> b;\n\t\ta--; b--;\n\n\t\tif(com == 1){\n\t\t\tif(use[a][b]){\n\t\t\t\tans += flow.addCapacity(s, t, a, b);\n\t\t\t}else{\n\t\t\t\tuse[a][b] = use[b][a] = true;\n\t\t\t\tflow.addEdge(a, b, 1);\n\t\t\t\tflow.addEdge(b, a, 1);\n\t\t\t\tans += flow.fordFulkerson(s, t);\n\t\t\t}\n\t\t}else{\n\n\t\t\tans += flow.subCapacity(s, t, a, b);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > min_cost, used;\n  int flow;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(flow < lim) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim - flow);\n      if(f == 0) return(flow);\n      flow += f;\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    bool flag = false;\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(from, to, 1);\n            flag = true;\n          }\n        } else if(re.cap == 0) {\n          if(max_flow(to, from, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(to, from, 1);\n            flag = true;\n          }\n        }\n        e.alive = re.alive = false;\n        return(flag);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0 && max_flow(to, from, 1) == 0) {\n          max_flow(graph.size() - 1, to, 1);\n          max_flow(from, 0, 1);\n          return (true);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n\n\nint V;\nint G[501][501]; // ??°???????????£??\\???????????¨???\nvector<int> used; // DFS??§?????§???????????????????????°\n\n// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n    G[from][to] = G[to][from] = cap;\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < V; i++) {\n        auto &cap = G[v][i];\n        if (!used[i] && cap > 0) {\n            int d = dfs(i, t, min(f, cap));\n            if (d > 0) {\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int E; cin >> V >> E;\n    int Q; cin >> Q;\n    for(int i = 0; i < 501;i++){\n        for(int j = 0;j < 501;j++){\n            G[i][j] = 0;\n        }\n    }\n    used.resize(V);\n    for (int i = 0; i < E;i++) {\n        int s, t; cin >> s >> t;\n        s--;t--;\n        add_edge(s, t, 1);\n    }\n    \n    int f = max_flow(0, V - 1);\n    for(int i = 0; i < Q;i++){\n        int M,A,B; cin >> M >> A >> B;\n        A--;B--;\n        if(M == 1){\n            G[A][B] = G[B][A] = 1;\n            fill(used.begin(),used.end(),0);\n            f += dfs(0,V-1,INF);\n        }else{\n            if(G[A][B] == 0 || G[B][A] == 0){\n                int u,v;\n                if(G[A][B] == 0){ u = A; v = B;}\n                else{u = B; v = A;}\n                if(dfs(u,v,INF) == 0){\n                    f--;\n                    fill(used.begin(),used.end(),0);\n                    dfs(u,0,INF);\n                    fill(used.begin(),used.end(),0);\n                    dfs(V-1,v,INF);\n                }\n            }\n            G[A][B] = G[B][A] = 0;\n        }\n        cout << f << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n  if(v==t)\n    return f;\n  used[v]=true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    bool b=false;\n    // Ü¾ü«ªÜÁÄ¢È¢ÈçA±±Åè\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ¡ñ¬·t[Ìü«É¶ÄeÊðt]\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // t[ª¬¹È©Á½êÍAÜÁÄ¢È©Á½±ÆÉ·é\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // »ÝÜÅÌÅå¬ÊðßÄ¨­\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // eNGÌãÌ¬Êðßé\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ÂÈ®\n    if(m==1){\n      add_edge(a,b,1);\n      // Ä¬o\n      cFlow+=max_flow(1,n);\n    }\n    // Øf·é\n    else{\n      // ØfÓªÜ¾Êß³êÄ¢È¢ê\n      if(!isDirected[a][b]){\n\tcout<<cFlow<<endl;\n\tfor(int j = 0; j < G[a].size(); j++){\n\t  if(G[a][j].to==b){\n\t    edge &e=G[a][j];\n\t    G[a].erase(G[a].begin()+j);\n\t    G[b].erase(G[b].begin()+e.rev);\n\t    isDirected[a][b]=false;\n\t    isDirected[b][a]=false;\n\t    break;\n\t  }\n\t}\n\tcontinue;\n      }\n      // t[ª·ÅÉ¬êÄ¢½êA\n      // ðð½·æ¤Ét[ðµß·\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ü«ÍÜÁÄ¢éª¬Ê0\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0)\n\t    ff+=max_flow(a,b);\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0)\n\t    ff+=max_flow(b,a);\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b)\n\t      max_flow(n,b);\n\t    if(a!=1)\n\t      max_flow(a,1);\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    if(a!=1)\n\t      max_flow(1,a);\n\t    if(b!=n)\n\t      max_flow(b,n);\n\t  }\n\t  cFlow--;\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a].erase(G[a].begin()+idx);\n      G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\n#define MAX 502\n#define INF INT_MAX\n\nint n;\nint cap[MAX][MAX];\nbool used[MAX];\n\nint dfs(int v , int t, int f){\n  if(v==t) return f;\n  used[v] = true;\n  rep(i,n){\n    int c = cap[v][i];\n    if(!used[i] && c > 0){\n      int d = dfs(i , t , min(f, c));\n      if(d > 0){\n        cap[v][i] -= d;\n        cap[i][v] += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint mf(int s, int t){\n  int flow = 0;\n  for(;;){\n    memset(used , 0 , sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(void){\n  int e,q;\n\n  while(scanf(\"%d%d%d\",&n,&e,&q) != EOF){\n    memset(cap,0,sizeof(cap));\n\n    rep(i,e){\n      int from,to;\n      scanf(\"%d%d\",&from,&to);\n      from--;\n      to--;\n      cap[from][to] = cap[to][from] = 1;\n    }\n\n    int res = mf(0,n-1);\n\n    while(q--){\n      int flg,a,b;\n      scanf(\"%d%d%d\",&flg,&a,&b);\n      a--;\n      b--;\n\n      if(flg == 1){\n        cap[a][b] = cap[b][a] = 1;\n        res += mf(0,n-1);\n      }\n      else{\n        if(cap[a][b] == 1){\n          cap[a][b] = cap[b][a] = 0;\n        }\n        else{\n          if(cap[a][b] != 0) swap(a,b);\n          memset(used,0,sizeof(used));\n          int tmp = dfs(a,b,1);\n          if(tmp != 1){\n            memset(used,0,sizeof(used));\n            dfs(a,0,1);\n            memset(used,0,sizeof(used));\n            dfs(n-1,b,1);\n            cap[a][b] = cap[b][a] = 0;\n            res--;\n          }\n        }\n      }\n\n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1){\n      g[a][b]=g[b][a]=1;\n      flow+=max_flow(0,n-1);\n    }\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(check(a,b))check(b,a);\n\telse flow--,check(a,0),check(n-1,b);\n\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                // edge is not used\n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.getmaxflow(N-1, a, 1);\n                    fl.getmaxflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.getmaxflow(N-1, b, 1);\n                    fl.getmaxflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t}\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,0,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// Ü¾ØçêÄ¢È¢©ÂgíêÄ¢È¢m[hÖÌJÚ\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\tbool ok=false;\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\t// eÊðfromÌûüÉ½­í¦é\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t// ¡ñÏXðsÁ½\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\t// eÊª0æèå«¢Æ«\n\t\t\tif(e.cap>0){\n\t\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\t// 1Ìt[ª¬¹½ê\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]==e.to)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t// dÌflowð¬·\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// t[ª¬¹È¢ÈçA¡ñèµ½ûüð³ø\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[MAX_V];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[501][501];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tbool ok=false;\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]==v){\n\t\t\t\t\t\tif(e.cap==1)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmemset(isUsable,0,sizeof(isUsable));\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(!isDirected[eidx]){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n//\t\t\t\t\t\t\tif(G[a][i].cap==1){\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// flowª¬êÄ¢éêAg©çtÜÅAt©çfÜÅAf©çsÜÅ»ê¼ê\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t//\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t//\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\t//if(G[a][i].cap==0){\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//else{\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 0){\n                // edge is not used\n            }\n            //  edge: a -> b is used\n           else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.getmaxflow(N-1, a, 1);\n                    fl.getmaxflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.getmaxflow(N-1, b, 1);\n                    fl.getmaxflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\n#define size(v) v.size()\n\ntemplate <class T, bool Scaling = false> struct dinic {\n  struct edge {\n    int to;\n    T cap;\n  };\n  const T inf = numeric_limits<T>::max(), eps = 1e-10;\n  int n, s, t;\n  vector<edge> es;\n  vector<vector<int>> g;\n  T scale;\n  vector<int> h, ptr;\n  dinic(int _n, int _s, int _t) : n(_n), s(_s), t(_t), g(n), h(n), ptr(n) {}\n  void add(int from, int to, T cap, T rev_cap = 0) {\n    g[from].push_back(size(es)), es.push_back({to, cap});\n    g[to].push_back(size(es)), es.push_back({from, rev_cap});\n  }\n  bool bfs() {\n    static vector<int> que(n);\n    fill(begin(h), end(h), -1);\n    h[t] = 0, que[0] = t;\n    for (int bg = 0, ed = 1; bg < ed; ) {\n      int v = que[bg++];\n      for (int id : g[v])\n        if (es[id ^ 1].cap > scale and h[es[id].to] == -1) {\n          h[es[id].to] = h[v] + 1, que[ed++] = es[id].to;\n          if (es[id].to == s) return true;\n        }\n    }\n    return false;\n  }\n  T dfs(int v, T f) {\n    if (v == t) return f;\n    for (int& i = ptr[v]; i >= 0; --i) {\n      int id = g[v][i];\n      if (es[id].cap > scale and h[v] > h[es[id].to]) {\n        T df = dfs(es[id].to, min(f, es[id].cap));\n        if (df > eps) return es[id].cap -= df, es[id ^ 1].cap += df, df;\n      }\n    }\n    return 0;\n  }\n  T max_flow(T upper = numeric_limits<T>::max()) {\n    T flow = 0, max_cap = 0;\n    for (auto&& e : es) max_cap = max(max_cap, e.cap);\n    for (scale = Scaling ? max_cap / 2 : eps; ; scale /= 2) {\n      while (bfs()) {\n        for (int v = 0; v < n; ++v) ptr[v] = (int)size(g[v]) - 1;\n        for (T df; (df = dfs(s, upper - flow)) > eps; ) flow += df;\n        if (flow == upper) break;\n      }\n      if (scale <= eps) break;\n    }\n    return flow;\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  dinic<int> g(n, 0, n - 1);\n  vector<vector<int>> eid(n, vector<int>(n, -1));\n  while (m--) {\n    int f, t;\n    cin >> f >> t;\n    --f, --t;\n    tie(f, t) = minmax({f, t});\n    eid[f][t] = size(g.es);\n    g.add(f, t, 1, 1);\n  }\n  int res = g.max_flow();\n  while (q--) {\n    int t, a, b;\n    cin >> t >> a >> b;\n    --a, --b;\n    tie(a, b) = minmax({a, b});\n    if (t == 1) {\n      if (eid[a][b] == -1) {\n        eid[a][b] = size(g.es);\n        g.add(a, b, 1, 1);\n      } else {\n        int id = eid[a][b];\n        assert(g.es[id].cap == 0);\n        assert(g.es[id ^ 1].cap == 0);\n        g.es[id].cap = 1;\n        g.es[id ^ 1].cap = 1;\n      }\n      res += g.max_flow();\n    } else {\n      int id = eid[a][b];\n      if (g.es[id].cap == 1) {\n        assert(g.es[id ^ 1].cap == 1);\n        g.es[id].cap = 0;\n        g.es[id ^ 1].cap = 0;\n      } else {\n        if (g.es[id].cap) {\n          assert(g.es[id].cap == 2);\n          assert(g.es[id ^ 1].cap == 0);\n          swap(a, b);\n          id ^= 1;\n        }\n        assert(g.es[id].cap == 0);\n        assert(g.es[id ^ 1].cap == 2);\n        g.es[id ^ 1].cap = 0;\n        g.s = a, g.t = b;\n        if (g.max_flow(1) == 0) {\n          if (a) {\n            g.s = a, g.t = 0;\n            g.max_flow(1);\n          }\n          if (b != n - 1) {\n            g.s = n - 1, g.t = b;\n            g.max_flow(1);\n          }\n          --res;\n        }\n        g.s = 0, g.t = n - 1;\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[MAX_V];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[501][501];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tbool ok=false;\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]==v){\n\t\t\t\t\t\tif(e.cap==1)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmemset(isUsable,0,sizeof(isUsable));\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(!isDirected[eidx]){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==1){\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// flowª¬êÄ¢éêAg©çtÜÅAt©çfÜÅAf©çsÜÅ»ê¼ê\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==0){\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n\nint N,E,Q;\nvector<set<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(auto i=edge[from].begin();i!=edge[from].end();i++){\n    int to = *i;\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].insert(b);\n  edge[b].insert(a);\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  edge[a].erase(b);\n  edge[b].erase(a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n      f--;\n    }\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int a,int b,int c):to(a),cap(b),rev(c){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,cap,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim){\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1,INF);\n}\n\nvoid q2(int a,int b){\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.to!=b||e.cap==0)continue;\n        if(e.cap==2)f2=true;\n        e.cap=0;\n    }\n    for(auto &e:G[b]){\n        if(e.to!=a||e.cap==0)continue;\n        if(e.cap==2)f1=true;\n        e.cap=0;\n    }\n    if(!f1&&!f2)return;\n\n    if(f2)swap(a,b);\n\n\n    int tmp=max_flow(a,b,1);\n\n    if(tmp)return;\n\n    add_edge(0,N-1,1);\n    tmp=max_flow(a,b,1);\n    assert(tmp);\n    G[0].pop_back();\n    G[N-1].pop_back();\n    f--;\n\n    f+=max_flow(0,N-1,INF);\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n    }\n\n    f=max_flow(0,N-1,INF);\n\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                cout<<i+1<<\" \"<<e.to+1<<\" \"<<e.cap<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T> struct Edge{\n\tint v,rev;\n\tT capa,flow;\n};\n\ntemplate<class T>\nstruct AdjList:public vector< vector< Edge<T> > >{\n\tAdjList(int n):vector< vector< Edge<T> > >(n){}\n};\n\ntemplate<class T>\nvoid add_edge(AdjList<T> &adj,int u,int v,T capa){\n\tadj[u].push_back((Edge<T>){v,adj[v].size()  ,capa,0});\n\tadj[v].push_back((Edge<T>){u,adj[u].size()-1,capa,0});\n}\n\ntemplate<class T>\nT augment(AdjList<T> &adj,int s,int t){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<bool> vis(n); vis[s]=true;\n\n\tqueue< pair<int,T> > qu;\n\tqu.push(make_pair(s,INF));\n\n\tT res=0;\n\twhile(!qu.empty()){\n\t\tint u=qu.front().first;\n\t\tT water=qu.front().second;\n\t\tqu.pop();\n\n\t\tif(u==t){ res=water; break; }\n\n\t\trep(i,adj[u].size()){\n\t\t\tEdge<T> &e=adj[u][i];\n\t\t\tif(!vis[e.v] && e.capa-e.flow>0){\n\t\t\t\tvis[e.v]=true;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\tqu.push(make_pair(e.v,min(water,e.capa-e.flow)));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(res>0){\n\t\tfor(int v=t;v!=s;){\n\t\t\tEdge<T> &e1=adj[v][pre[v]];\n\t\t\tEdge<T> &e2=adj[e1.v][e1.rev];\n\t\t\te1.flow-=res;\n\t\t\te2.flow+=res;\n\t\t\tv=e1.v;\n\t\t}\n\t}\n\n\treturn res;\n}\n\ntemplate<class T>\nT Edmonds_Karp(AdjList<T> &adj,int s,int t){\n\tT ans=0;\n\tfor(T water=1;water>0;ans+=water) water=augment(adj,s,t);\n\treturn ans;\n}\n\nbool vis[500];\n// u-t t[Ì¬Êð 1 ¸ç·\nbool dfs_dec(int u,int t,AdjList<int> &adj){\n\tvis[u]=true;\n\tif(u==t) return true;\n\trep(i,adj[u].size()){\n\t\tEdge<int> &e=adj[u][i];\n\t\tif(!vis[e.v] && e.flow>0 && dfs_dec(e.v,t,adj)){\n\t\t\te.flow--;\n\t\t\tadj[e.v][e.rev].flow++;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// u-t ÔÉ 1 PÊÌt[ð¬·\nbool dfs_loop(int u,int t,AdjList<int> &adj){\n\tvis[u]=true;\n\tif(u==t) return true;\n\trep(i,adj[u].size()){\n\t\tEdge<int> &e=adj[u][i];\n\t\tif(!vis[e.v] && e.capa-e.flow>0 && dfs_loop(e.v,t,adj)){\n\t\t\te.flow++;\n\t\t\tadj[e.v][e.rev].flow--;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\tAdjList<int> adj(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tadd_edge(adj,u,v,1);\n\t}\n\n\tint ans=Edmonds_Karp(adj,0,n-1);\n\n\twhile(q--){\n\t\tint type,u,v; scanf(\"%d%d%d\",&type,&u,&v); u--; v--;\n\t\tif(type==1){ // add\n\t\t\tint i,i_rev;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v) break;\n\t\t\tif(i<adj[u].size()){ // êxÁµ½ÓðÄÑÇÁ·éÆ«\n\t\t\t\ti_rev=adj[u][i].rev;\n\t\t\t\tadj[u][i].capa=adj[v][i_rev].capa=1;\n\t\t\t}\n\t\t\telse add_edge(adj,u,v,1);\n\t\t}\n\t\telse{ // erase\n\t\t\tint i,i_rev;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v) break;\n\t\t\ti_rev=adj[u][i].rev;\n\n\t\t\tint flow=adj[u][i].flow;\n\t\t\tif(flow<0){ // u ©ç v ÖÌt[ð²×é\n\t\t\t\tswap(u,v);\n\t\t\t\tswap(i,i_rev);\n\t\t\t}\n\n\t\t\tif(flow!=0){\n\t\t\t\t// 1 PÊÌt[ðµß·\n\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\tdfs_dec(0,n-1,adj);\n\t\t\t\tans--;\n\n\t\t\t\t// Ó (v,u) ðÜÞ[vÉÁÄ 1 PÊÌt[ð¬·\n\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\tdfs_loop(u,v,adj);\n\t\t\t}\n\t\t\tadj[u][i].capa=adj[v][i_rev].capa=0;\n\t\t\tadj[u][i].flow=adj[v][i_rev].flow=0;\n\t\t}\n\t\tans+=Edmonds_Karp(adj,0,n-1);\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\nconst int MAX_V = 1000;\nconst int INF = 1 << 25;\n\nint V;\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, 0, int(G[from].size() - 1) });\n}\n\nvoid add_edge2(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, cap, int(G[from].size() - 1) });\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(edge& e : G[v]) {\n\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim) {\n\tint flow = 0;\n\twhile(1) {\n\t\tfill(used, used + V, false);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0 || flow == lim) return flow;\n\t\tflow += f;\n\t\tlim -= f;\n\t}\n\treturn -1;\n}\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nbool ex[1000][1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tint S = N, T = N + 1;\n\tV = N + 2;\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tadd_edge2(a, b, 1);\n\t\tex[a][b] = ex[b][a] = true;\n\t}\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tif(!ex[A[i]][B[i]]) {\n\t\t\tadd_edge2(A[i], B[i], 0);\n\t\t\tex[A[i]][B[i]] = ex[B[i]][A[i]] = true;\n\t\t}\n\t}\n\tadd_edge(S, 0, 1000000);\n\tadd_edge(N - 1, T, 1000000);\n\n\tint f = max_flow(S, T, INF);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tf += max_flow(S, T, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\tint c = e.cap;\n\n\t\t\t\t\tif(c == 0) {// u -> v\n\t\t\t\t\t\tif(max_flow(u, v, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(u, v, 1) != 0);\n\t\t\t\t\t\t\t//assert(max_flow(u, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, v, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 2) {// v -> u\n\t\t\t\t\t\tif(max_flow(v, u, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(v, u, 1) != 0);\n\t\t\t\t\t\t\t//assert(max_flow(v, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, u, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\te.cap = G[v][e.rev].cap = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n,m,qn;\n\nint vs[505][505]={};\nint gone[505];\n\nbool dfs(int no,int gl){\n\tif(no==gl)return true;\n\tgone[no]=1;\n\treg(to,1,n){\n\t\tif(gone[to])continue;\n\t\tif(vs[no][to]>0){\n\t\t\tif(dfs(to,gl)){\n\t\t\t\tvs[no][to]--;\n\t\t\t\tvs[to][no]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tvs[a][b]=vs[b][a]=1;\n\t}\n\t\n\tint nf=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tif(dfs(1,n))nf++;\n\t\telse break;\n\t}\n\trep(q,qn){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\tif(t==1){\n\t\t\tvs[a][b]=vs[b][a]=1;\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\telse{\n\t\t\tint fr=-1,to;\n\t\t\tif(vs[a][b]==0){\n\t\t\t\tfr=a; to=b;\n\t\t\t}\n\t\t\telse if(vs[b][a]==0){\n\t\t\t\tfr=b; to=a;\n\t\t\t}\n\t\t\tvs[a][b]=vs[b][a]=0;\n\t\t\tif(fr>=0){\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(!dfs(fr,to)){\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\t\tok &= dfs(n,to);\n\t\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\t\tok &= dfs(fr,1);\n\t\t\t\t\tnf--;\n\t\t\t\t}\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(dfs(1,n))nf++;\n\t\t\t}\n\t\t\t/*\n\t\t\tif(fr>=0){\n\t\t\t\tbool ok=true;\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tok &= dfs(n,to);\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tok &= dfs(fr,1);\n\t\t\t\tif(!ok){\n\t\t\t\t\tprintf(\"%d (%d %d %d)\\n\",q,t,a,b);\n\t\t\t\t\treg(i,1,n){\n\t\t\t\t\t\treg(j,1,n)printf(\"%d%c\",vs[i][j],j==n?'\\n':' ');\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok)return -1;\n\t\t\t\t}\n\t\t\t\tnf--;\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(dfs(1,n))nf++;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"%d\\n\",nf);\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n  if(v==t)\n    return f;\n  used[v]=true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    bool b=false;\n    // Ü¾ü«ªÜÁÄ¢È¢ÈçA±±Åè\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ¡ñ¬·t[Ìü«É¶ÄeÊðt]\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // t[ª¬¹È©Á½êÍAÜÁÄ¢È©Á½±ÆÉ·é\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint one_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  fill(used,used+MAX_V,false);\n  int f=dfs(s,t,INF);\n  return f;\n}\n\n\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // »ÝÜÅÌÅå¬ÊðßÄ¨­\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // eNGÌãÌ¬Êðßé\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ÂÈ®\n    if(m==1){\n      add_edge(a,b,1);\n      // Ä¬o\n      cFlow+=max_flow(1,n);\n    }\n    // Øf·é\n    else{\n      // ØfÓªÜ¾Êß³êÄ¢È¢ê\n      if(!isDirected[a][b]){\n\t//cout<<cFlow<<endl;\n\tfor(int j = 0; j < G[a].size(); j++){\n\t  if(G[a][j].to==b){\n\t    edge &e=G[a][j];\n\t    G[a].erase(G[a].begin()+j);\n\t    G[b].erase(G[b].begin()+e.rev);\n\t    isDirected[a][b]=false;\n\t    isDirected[b][a]=false;\n\t    break;\n\t  }\n\t}\n\tcontinue;\n      }\n      // t[ª·ÅÉ¬êÄ¢½êA\n      // ðð½·æ¤Ét[ðµß·\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ü«ÍÜÁÄ¢éª¬Ê0\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    //cout<<\"from a to b\"<<endl;\n\t    ff+=one_flow(a,b);\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    ff+=one_flow(b,a);\n\t  }\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  int f=0;\n\t  //cout<<\"reverse flow\"<<endl;\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b){\n\t      f+=one_flow(n,b);\n\t    }\n\t    else\n\t      f++;\n\t    if(a!=1)\n\t      f+=one_flow(a,1);\n\t    else\n\t      f++;\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    //cout<<\"from a to b\"<<endl;\n\t    if(b!=1)\n\t      f+=one_flow(b,1);\n\t    else\n\t      f++;\n\t    //cout<<f<<endl;\n\t    if(a!=n)\n\t      f+=one_flow(n,a);\n\t    else\n\t      f++;\n\t  }\n\t  //cout<<f<<endl;\n\t  if(f>=2)\n\t  cFlow--;\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a].erase(G[a].begin()+idx);\n      G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int t, Flow f, int r) : src(s), dest(t), cap(f), rev(r) {}\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow max_flow(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nFlow unit_flow(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tvector<bool> used(g.size(), false);\n\tFlow f = dfs(g, used, s, t, 1);\n\tflow += f;\n\treturn flow;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tGraph g(n);\n\tREP(i, n)REP(j, n)\n\t{\n\t\tg[i].emplace_back(i, j, 0, i);\n\t}\n\tREP(i, e)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b].cap++;\n\t\tg[b][a].cap++;\n\t}\n\tint tmp = max_flow(g, 0, n - 1);\n\tREP(i, q)\n\t{\n\t\tint a, b, c;\n\t\tcin >> c >> a >> b;\n\t\ta--; b--;\n\t\tif (c == 1)\n\t\t{\n\t\t\tassert(g[a][b].cap == 0 && g[b][a].cap == 0);\n\t\t\tg[a][b].cap++;\n\t\t\tg[b][a].cap++;\n\t\t\ttmp += unit_flow(g, 0, n - 1);\n\t\t}\n\t\tif (c == 2)\n\t\t{\n\t\t\tassert(g[a][b].cap != 0 || g[b][a].cap != 0);\n\t\t\tif (g[a][b].cap == 1 && g[b][a].cap == 1)\n\t\t\t{\n\t\t\t}\n\t\t\telse if (g[a][b].cap == 2 && g[b][a].cap == 0)\n\t\t\t{\n\t\t\t\tif (unit_flow(g, b, a) == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp--;\n\t\t\t\t\tunit_flow(g, b, 0);\n\t\t\t\t\tunit_flow(g, n - 1, a);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (g[a][b].cap == 0 && g[b][a].cap == 2)\n\t\t\t{\n\t\t\t\tif (unit_flow(g, a, b) == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp--;\n\t\t\t\t\tunit_flow(g, a, 0);\n\t\t\t\t\tunit_flow(g, n - 1, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse assert(false);\n\t\t\tg[a][b].cap = g[b][a].cap = 0;\n\t\t}\n\t\tcout << tmp << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\nint g[500][500];\nint flow[500][500];\nbool visited[500];\n\nbool aug(int s, int t) {\n  visited[s] = 1;\n  if (s==t) return 1;\n  REP(i,n) {\n    if (g[s][i]-flow[s][i]>=1 && !visited[i]) {\n      if (aug(i, t)) {\n        flow[s][i]++;\n        flow[i][s]--;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nbool augment(int s, int t) {\n  memset(visited,0,sizeof(visited));\n  return aug(s,t);\n}\n\n\nint main() {\n  int m,q;\n  cin >> n >> m >> q;\n  \n  REP(i,m) {\n    int f,t;\n    cin >> f>>t;\n    f--;t--;\n    g[f][t] = 1;\n    g[t][f] = 1;\n  }\n  int maxflow = 0;\n  while(1) {\n    if (!augment(0,n-1))\n      break;\n    maxflow++;\n  }\n  REP(i,q) {\n    int m,a,b;\n    cin >>m>>a>>b;\n    a--;b--;\n    if (m==1) {\n      g[a][b] = 1;\n      g[b][a] = 1;\n      if (augment(0,n-1))\n        maxflow++;\n    } else {\n      g[a][b] = 0; g[b][a] = 0;\n      if (flow[a][b] == 0) {\n      } else {\n        if (flow[a][b] == 1) {\n          flow[a][b] = flow[b][a] = 0;\n          if (augment(a,b)) {\n          } else {\n            augment(n-1, b);\n            augment(a, 0);\n            maxflow--;\n          }\n        } else {\n          flow[a][b] = flow[b][a] = 0;\n          if (augment(b,a)) {\n          } else {\n            augment(n-1, a);\n            augment(b, 0);\n            maxflow--;\n          }\n        }\n      }\n    }\n    cout << maxflow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000;\nint cap[500][500];\n\nint maximumFlow(int n, int s, int t, bool first = false){\n\tint res = 0;\n\tint prev[500];\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tmemset(prev, -1, sizeof(prev)); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j]--, cap[j][prev[j]]++;\n\t\tres++;\n\t\tif(!first) return res;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1, true);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\tint s = A-1, t = B-1;\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(cap[t][s] == 2){\n\t\t\t\t\t\tcap[t][s] = 0;\n\t\t\t\t\t\tint tmp = maximumFlow(N, s, t); \n\t\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\t\tmaximumFlow(N, s, 0);\n\t\t\t\t\t\t\tmaximumFlow(N, N-1, t);\n\t\t\t\t\t\t\tcur--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswap(s, t);\n\t\t\t\t}\n\t\t\t\tcap[s][t] = cap[t][s] = 0;\n\t\t\t}\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef complex<double> P;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\n//AOJ 2313\nstruct edge{\n\tint to,flow,cap,rev;\n\tedge(int _to, int _cap, int _rev):to(_to),cap(_cap),rev(_rev),flow(0){};\n};\nint n,e,q;\nint id[555][555];\nint visit[555];\nvector<vector<edge> > g;\nTIII Q[1111];\n\nvoid addedge(int s, int t, int cap){\n\tif(id[s][t]!=-1)return;\n\tg[s].PB(edge(t, cap, g[t].size()));\n\tg[t].PB(edge(s, cap, g[s].size()-1));\n\tid[s][t]=g[s].size()-1;\n\tid[t][s]=g[t].size()-1;\n}\n\n//Ford Fulkerson\nint DFS(int s, int t, int flow){\n\tif(visit[s]!=0)return 0;\n\tvisit[s]=1;\n\tif(s==t)return flow;\n\tint res=0;\n\tREP(i,g[s].size()){\n\t\tif(g[s][i].cap-g[s][i].flow>0){\n\t\t\tif((res=DFS(g[s][i].to, t, min(flow, g[s][i].cap-g[s][i].flow)))!=0){\n\t\t\t\tg[s][i].flow += res;\n\t\t\t\tg[g[s][i].to][g[s][i].rev].flow -= res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\tif(flow==0)break;\n\t}\n\treturn res;\n}\n\nint flow(int s, int t, int flow){\n\tint res=0, ret=0;\n\twhile(flow){\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tres = DFS(s,t,flow);\n\t\tflow-=res;\n\t\tif(res==0)break;\n\t\tret+=res;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tmemset(id,-1,sizeof(id));\n\tcin>>n>>e>>q;\n\tg=vector<vector<edge> >(n+1);\n\tREP(i,e){\n\t\tint n1,n2;\n\t\tscanf(\"%d%d\", &n1, &n2);\n\t\taddedge(n1,n2,1);\n\t}\n\tREP(i,q){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tQ[i]=MT(a,b,c);\n\t\taddedge(b,c,0);\n\t}\n\tint current_flow = flow(1,n,111111111);\n\tint d_flow;\n\tREP(i,q){\n\t\tif(Q[i].T1==1){\n\t\t\tg[Q[i].T2][id[Q[i].T2][Q[i].T3]].cap=1;\n\t\t\tg[Q[i].T3][id[Q[i].T3][Q[i].T2]].cap=1;\n\t\t\td_flow = flow(1,n,1);\n\t\t\tcurrent_flow+=d_flow;\n\t\t}else{\n\t\t\tif(g[Q[i].T2][id[Q[i].T2][Q[i].T3]].flow!=0){\n\t\t\t\tif(g[Q[i].T2][id[Q[i].T2][Q[i].T3]].flow<0)swap(Q[i].T2,Q[i].T3);\n\t\t\t\td_flow = flow(Q[i].T2, Q[i].T3, 1);\n\t\t\t\tif(d_flow)g[Q[i].T2][id[Q[i].T2][Q[i].T3]].cap=g[Q[i].T2][id[Q[i].T2][Q[i].T3]].flow=g[Q[i].T3][id[Q[i].T3][Q[i].T2]].cap=g[Q[i].T3][id[Q[i].T3][Q[i].T2]].flow=0;\n\t\t\t\telse{\n\t\t\t\t\tflow(n,1,1);\n\t\t\t\t\tg[Q[i].T2][id[Q[i].T2][Q[i].T3]].cap=g[Q[i].T2][id[Q[i].T2][Q[i].T3]].flow=0;\n\t\t\t\t\tg[Q[i].T3][id[Q[i].T3][Q[i].T2]].cap=g[Q[i].T3][id[Q[i].T3][Q[i].T2]].flow=0;\n\t\t\t\t\tflow(Q[i].T2, Q[i].T3, 1);\n\t\t\t\t\tcurrent_flow--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << current_flow << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_V = 550;\nconstexpr int INF = (1 << 29);\n\nint N;\nint cap[MAX_V][MAX_V];\nbool G[MAX_V][MAX_V];\nbool used[MAX_V];\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    used[v] = 1;\n    for (int i = 0; i < N; i++) {\n        if (!used[i] && cap[v][i] > 0) {\n            int d = dfs(i, t, min(f, cap[v][i]));\n            if (d > 0) {\n                cap[v][i] -= d;\n                cap[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint one_flow(int s, int t)\n{\n    memset(used, 0, sizeof(used));\n    return dfs(s, t, 1);\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nvoid add_edge(int from, int to)\n{\n    cap[from][to] = cap[to][from] = 1;\n}\n\nvoid remove_edge(int from, int to)\n{\n    cap[from][to] = cap[to][from] = 0;    \n}\n\nint main()\n{\n    int E, Q;\n    cin >> N >> E >> Q;\n    \n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        add_edge(F - 1, T - 1);\n    }\n    \n    int f = max_flow(0, N - 1);\n    for (int i = 0; i < Q; i++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A -= 1; B -= 1;\n        if (M == 1) {\n            add_edge(A, B);\n            f += one_flow(0, N - 1);\n        } else {\n            if (cap[A][B] != 0) swap(A, B);\n\n            if (cap[A][B] == 0 && one_flow(A, B) == 0) {\n                one_flow(N - 1, B);\n                one_flow(A, 0);\n                f -= 1;\n            }\n            \n            remove_edge(A, B);\n        }\n        \n        cout << f << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap) {\n\tfor (int i = 0; i < G[from].size(); ++i) {\n\t\tEdge& e = G[from][i];\n\t\tif (e.to == to) {\n\t\t\te.cap = G[e.to][e.rev].cap = cap;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, cap, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n//\tif (s == to && !flag) return false;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n//\t\tif (s == from && e.to != to) continue;\n\t\tbool nf = flag || (s == from && e.to == to);\n\t\tif (!used2[e.to][(int)nf] && e.cap > 0) {\n\t\t\tbool f = dfs2(e.to, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tfor (int i = 0; i < G[a].size(); ++i) {\n\t\tEdge& e = G[a][i];\n\t\tif (e.to == b) {\n\t\t\tif (e.cap > 1) {\n\t\t\t\treturn removeEdge(b, a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cap = e.cap;\n\t\t\t\tif (cap < 1) {\n\t\t\t\t\tfill(&used2[0][0], &used2[0][0]+500*2, false);\n\t\t\t\t\tif ( !dfs2(N-1, 0, b, a, false) ) {\n\t\t\t\t\t\tcout << \"ERROR\" << endl;\n\t\t\t\t\t}\n/*\n\t\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\t\tif ( !dfs(a, b, 1) ) {\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(a, 0, 1);\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(N-1, b, 1);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t\te.cap = G[e.to][e.rev].cap = 0;\n//\t\t\t\tG[b].erase(G[b].begin()+e.rev);\n//\t\t\t\tG[a].erase(G[a].begin()+i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tG.resize(N);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T, 1);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b, 1);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tmemset(used, false, sizeof(used)); f += dfs(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nconst int MAX_V=500,INF=1e8;\nint G[MAX_V][MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int from, int to){\n\tG[from][to]=1;\n\tG[to][from]=1;\n}\nvoid erase_edge(int from, int to){\n\tG[from][to]=0;\n\tG[to][from]=0;\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<V;i++){\n\t\tint &c=G[v][i];\n\t\tif(!used[i] && c>0){\n\t\t\tint d=dfs(i,t,min(f,c));\n\t\t\tif(d>0){\n\t\t\t\tc-=d;\n\t\t\t\tG[i][v]+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0) return flow;\n\t\tflow+=f;\n\t}\n}\nvoid show_matrix(){\n\trep(i,V){\n\t\trep(j,V) cout<<G[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n}\nint main(){\n\tint N,E,Q;\n\tcin>>N>>E>>Q;\n\tV=N;\n\trep(i,E){\n\t\tint F,T;\n\t\tcin>>F>>T;\n\t\tadd_edge(F-1,T-1);\n\t}\n\tint now=max_flow(0,N-1);\n\trep(i,Q){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\ta--,b--;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b);\n\t\t\tnow+=max_flow(0,N-1);\n\t\t}else{\n\t\t\tint ecap=G[a][b];\n\t\t\terase_edge(a,b);\n\t\t\tif(ecap==2) swap(a,b);\n\t\t\tif(ecap!=1){\n//\t\t\t\tshow(a);\n//\t\t\t\tshow(b);\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tint f=dfs(a,b,1);\n\t\t\t\tif(f==0){\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tdfs(a,0,1);\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tdfs(N-1,b,1);\n\t\t\t\t\tnow--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",now);\n//\t\tshow_matrix();\n//\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cap, rev;\n  Edge(int u, int v, int c, int r) :\n    src(u), dst(v), cap(c), rev(r) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nbool used[500];\nbool used2[500][2];\nint dfs(int u, int t, int f){\n  if(u == t) return f;\n  used[u] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0 && !used[e->dst]){\n      int d = dfs(e->dst, t, min(f, e->cap));\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint dfs2(int u, int t, int f, int b, int A, int B){\n  if(u == t){\n    if(b == 1) return f;\n    else return 0;\n  }\n  used2[u][b] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0){\n      int nb = b;\n      if(e->src == A && e->dst == B) nb = 1;\n      if(used2[e->dst][nb]) continue;\n      int d = dfs2(e->dst, t, min(f, e->cap), nb, A, B);\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nvoid max_flow(int &flow, int S, int T){\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(S, T, INF);\n    if(f == 0) return;\n    flow += f;\n  }\n}\nvoid add_edge(int u, int v){\n  G[u].push_back(Edge(u, v, 1, G[v].size()));\n  G[v].push_back(Edge(v, u, 1, G[u].size() - 1));\n}\n\nint main(){\n  int N, E, Q;\n  while(cin >> N >> E >> Q){\n    G = Graph(N);\n    REP(i, E){\n      int A, B;\n      cin >> A >> B;\n      A--; B--;\n      add_edge(A, B);\n    }\n    int S = 0, T = N - 1;\n    int flow = 0;\n    max_flow(flow, S, T);\n    REP(i, Q){\n      int M, A, B;\n      cin >> M >> A >> B;\n      A--; B--;\n      if(M == 1){\n        add_edge(A, B);\n        max_flow(flow, S, T);\n      }else{\n        FORIT(e, G[A])if(e->dst == B && e->cap == 2){\n          // B -> A : now \n          //printf(\"find %d -> %d flow\\n\", B, A);\n          memset(used2, 0, sizeof(used2));\n          int d = dfs2(T, S, 1, 0, A, B);\n          if(d == 1){\n            flow--;\n            //cerr << d << endl;\n            //assert(false);\n          }\n          goto ERASE;\n        }\n        FORIT(e, G[B])if(e->dst == A && e->cap == 2){\n          //printf(\"find %d -> %d flow\\n\", A, B);\n          memset(used2, 0, sizeof(used2));\n          int d = dfs2(T, S, 1, 0, B, A);\n          if(d == 1){\n            flow--;\n            //cerr << d << endl;\n            //assert(false);\n          }\n          goto ERASE;\n        }\n        ERASE:\n          FORIT(e, G[A]) if(e->dst == B) { G[A].erase(e); break; }\n          FORIT(e, G[B]) if(e->dst == A) { G[B].erase(e); break; }\n          max_flow(flow, S, T);\n      }\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n \nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass MaximamFlow{\nprivate:\n\ttypedef int Flow;\n\tstruct Edge{int to,rev;Flow icap,cap;bool ex;};\n\ttypedef vector<vector<Edge>> Graph;\n\n\t//iter　次に調べる時の開始位置 距離\n\tvector<int> iter,dist;\n\n\t//sからのbfs距離の計算\n\tvoid bfs_dist(int s){\n\t\tfill(ALL(dist),-1); dist[s]=0;\n\t\tqueue<int> que; que.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();que.pop();\n\t\t\tfor(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n\t\t\t\tdist[e.to]=dist[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//増加パス\n\tFlow dfs_best_path(int s,int t,Flow f){\n\t\tif(s==t)return f;\n\t\tfor(int &i = iter[s];i < (int)G[s].size();i++){\n\t\t\tEdge &e=G[s][i];Edge &reve = G[e.to][e.rev];\n\t\t\tif(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n\t\t\t//search\n\t\t\tFlow d = dfs_best_path(e.to,t,min(f,e.cap));\n\t\t\tif(d==0)continue;\n\t\t\t//found\n\t\t\te.cap-=d;reve.cap+=d;\n\t\t\t// cerr <<\"p:\"<<s+1 <<\" \" << e.to+1<<\" \" << e.cap<<\" \" <<reve.cap <<\" \" <<(e.ex?\"ex\":\"zan\") <<endl;\n\t\t\t\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tint V;Graph G;\n\tMaximamFlow(int V):V(V){\n\t\tG=Graph(V);\n\t\tdist=vector<int>(V,-1);iter=vector<int>(V);\n\t}\n\n\tvoid add_edge(int s,int t,Flow cap){\n\t\tint srev=G[t].size(),trev=G[s].size();\n\t\tG[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,0,0,false});\n\t}\n\n\tFlow change_cost(int S,int T,int s,int t,int c){\n\t\tFlow flow = 0;\n\t\tfor(Edge& e:G[s])if(e.to == t){\n\t\t\tEdge &reve = G[e.to][e.rev];\n\t\t\tif(e.icap <= c){// 単純に増やす\n\t\t\t// cerr <<\"add\"<<endl;\n\t\t\t\te.cap+=c - e.icap;\n\t\t\t\te.icap = c;\n\t\t\t}else if(c >= e.icap-e.cap){ // 単純に減らす\n\t\t\t// cerr <<\"del\"<<endl;\n\t\t\t\te.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}else{// フローを戻してから減らす\n\t\t\t\t// cerr <<\"del2\"<<endl;\n\t\t\t\tFlow d = e.icap - e.cap - c;\n\t\t\t\tflow -= d;\n\n\t\t\t\t// cerr << d <<endl;\n\t\t\t\t// 一時的にカット\n\t\t\t\tFlow tmpcap=e.cap,tmprevcap=reve.cap;\n\t\t\t\te.cap =0;reve.cap = 0;\n\t\t\t\tbfs_dist(s); assert(dfs_best_path(s,S,d)==d);\n\t\t\t\tbfs_dist(T); assert(dfs_best_path(T,t,d)==d);\n\t\t\t\t// s <- t d戻す\n\t\t\t\te.cap=tmpcap + d;reve.cap = tmprevcap - d;\n\n\t\t\t\t// 単純に減らす\n\t\t\t\te.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}\n\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(e2.ex){ \n\t\t\t// \tassert(e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex){ \n\t\t\t// \tassert(-e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\n\n\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t// cerr <<\"!pre:state!\"<<endl;\n\t\t\t\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\n\t\t\tflow += max_flow(S,T);\n\n\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t// cerr <<\"!post:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex && e2.cap!=0){\n\t\t\t// \tcerr << v+1 <<\"<-\" << e2.to+1 <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\t\t}\n\t\treturn flow;\n\t}\n\n\tint max_flow(int s,int t){\n\t\tFlow flow=0;\n\t\twhile(true){\n\t\t\tfill(ALL(iter),0);\n\t\t\tbfs_dist(s);\n\t\t\tif(dist[t] == -1)return flow; //限界\n\t\t\tFlow f;\n\t\t\twhile((f=dfs_best_path(s,t,INF<Flow>()))>0)flow+=f;\n\t\t}\n\t\treturn -1;\n\t}\n};\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N,E,Q;cin >> N >> E >> Q;\n\n\t\tMaximamFlow mf(N);\n\t\tREP(i,N)REP(j,N)if(i<j){mf.add_edge(i,j,0);}\n\n\t\tll flow=0;\n\t\tREP(e,E){\n\t\t\tint f,t;cin >> f >> t;f--;t--;\n\t\t\tflow+=mf.change_cost(0,N-1,f,t,1);\n\t\t\tflow+=mf.change_cost(0,N-1,t,f,1);\n\t\t}\n\t\t// cerr << flow <<endl;\n\t\tREP(q,Q){\n\t\t\tint t,a,b;cin >> t >> a >> b;a--;b--;\n\t\t\tif(t==1){\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,1);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,1);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}else{\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,0);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,0);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n \nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct FordFulkerson {\n\tusing Flow = int;\n\tint n;\n\tint s, t;\n\tFlow maxflow;\n\tvector<vector<Flow>> g;\n\tvector<bool> used;\n\tFordFulkerson(int n, int s = -1, int t = -1) :n(n), g(n, vector<Flow>(n)), used(n), s(s), t(t), maxflow(0) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from][to] = cap;\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\taddArc(a, b, cap);\n\t\taddArc(b, a, cap);\n\t}\n\tFlow addEdgeCap(int a, int b, Flow cap) {\n\t\tif (cap > 0) {\n\t\t\tg[a][b] += cap;\n\t\t\tg[b][a] += cap;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tmaxflow += augment(s, t, cap);\n\t\t}\n\t\telse {\n\t\t\tFlow rcap = -cap;\n\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\tg[a][b] -= rcap;\n\t\t\t\tg[b][a] -= rcap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (g[a][b] > g[b][a])swap(a, b);\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tFlow f = augment(a, b, a, b, rcap);\n\t\t\t\tdump(a + 1, b + 1);\n\t\t\t\tdump(f, rcap);\n\t\t\t\tif (f < rcap) {\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\taugment(b, a, b, a, f);\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tFlow sub = augment(t, s, rcap - f);\n\t\t\t\t\tassert(sub == rcap - f);\n\t\t\t\t\tmaxflow -= sub;\n\t\t\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\t\t\tg[a][b] -= rcap;\n\t\t\t\t\t\tg[b][a] -= rcap;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\t\tf = augment(a, b, a, b, rcap);\n\t\t\t\t\t\tdump(f, rcap);\n\t\t\t\t\t\tassert(f == rcap);\n\t\t\t\t\t\tg[a][b] += rcap; g[a][b] -= rcap;\n\t\t\t\t\t\tg[b][a] -= rcap; g[b][a] -= rcap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn maxflow;\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tFlow f = augment(s, t, INF);\n\t\t\tif (f == 0)return maxflow += total;\n\t\t\ttotal += f;\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tFlow augment(int v, int t, int a, int b, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (v == a&&to == b)continue;\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, E, Q; cin >> N >> E >> Q;\n\tFordFulkerson ff(N, 0, N - 1);\n\trep(i, 0, E) {\n\t\tint F, T; cin >> F >> T; F--, T--;\n\t\tff.addEdge(F, T, 1);\n\t}\n\tdump(ff.g);\n\tff.maximumFlow(0, N - 1);\n\tdump(ff.g);\n\tdump(ff.maxflow);\n\trep(i, 0, Q) {\n\t\tint M, A, B; cin >> M >> A >> B;\n\t\tdump(M, A, B);\n\t\tA--, B--;\n\t\tif (M == 1) {\n\t\t\tcout << ff.addEdgeCap(A, B, 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ff.addEdgeCap(A, B, -1) << endl;\n\t\t}\n\t\tdump(ff.g);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <set>\n\ntemplate <class Tp>\nTp inf() { return static_cast<Tp>(1) << (8*sizeof(Tp) - 3); }\n\ntemplate <class Tp>\nstruct Edge {\n  size_t src, dst;\n  Tp cap;\n  size_t rev;\n  Edge(size_t src, size_t dst, Tp cap, size_t rev):\n    src(src), dst(dst), cap(cap), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<Edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<Edge<Tp>>>(n) {}\n\n  void connect_with(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, cap, (*this)[src].size()-1);\n  }\n\n  void connect_to(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, 0, (*this)[src].size()-1);\n  }\n\n  void inspect() const {\n    size_t n = this->size();\n    fprintf(stderr, \"vertex: %zu\\n\", n);\n    for (size_t i = 0; i < n; ++i)\n      for (const auto& e: (*this)[i]) {\n        // fprintf(stderr, \"%zu -> %zu, cap: %zu, rev: [%zu]\\n\",\n        //         e.src, e.dst, e.cap, e.rev);\n        if (e.cap == 0) {\n          const auto& f = (*this)[e.dst][e.rev];\n          if (f.cap == 0) continue;\n          fprintf(stderr, \"%zu -> %zu\\n\", e.src, e.dst);\n        }\n      }\n  }\n};\n\ntemplate <class Tp>\nTp max_flow(graph<Tp>& g, size_t s, size_t t, Tp f0 = inf<Tp>()) {\n  Tp flow = Tp(0);\n  std::vector<size_t> iter, cost;\n\n  auto distance = [&](size_t s) {\n    std::vector<size_t> res(g.size(), inf<size_t>());\n    std::queue<size_t> q;\n    res[s] = 0;\n    q.emplace(s);\n    while (!q.empty()) {\n      size_t v = q.front();\n      q.pop();\n      for (const auto& e: g[v]) {\n        if (static_cast<Tp>(0) < e.cap && res[e.dst] == inf<size_t>()) {\n          res[e.dst] = res[v] + 1;\n          q.push(e.dst);\n        }\n      }\n    }\n    return res;\n  };\n\n  std::function<Tp (size_t, Tp)> augment = [&](size_t v, Tp f)->Tp {\n    if (v == t) return f;\n    for (size_t& i = iter[v]; i < g[v].size(); ++i) {\n      Edge<Tp>& e = g[v][i];\n      if (Tp(0) < e.cap && cost[v] < cost[e.dst]) {\n        Tp d = augment(e.dst, std::min(f, e.cap));\n        if (Tp(0) < d) {\n          e.cap -= d;\n          g[e.dst][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return static_cast<Tp>(0);\n  };\n\n  while (true) {\n    cost = distance(s);\n    if (cost[t] == inf<size_t>()) return flow;\n    iter.assign(g.size(), 0);\n    Tp f;\n    while (Tp(0) < (f = augment(s, f0))) {\n      flow += f;\n      f0 -= f;\n      if (!f0) return flow;\n    }\n  }\n}\n\nint main() {\n  size_t N, E, Q;\n  scanf(\"%zu %zu %zu\", &N, &E, &Q);\n\n  graph<intmax_t> g(N);\n  std::set<std::pair<size_t, size_t>> es0;\n  for (size_t i = 0; i < E; ++i) {\n    size_t F, T;\n    scanf(\"%zu %zu\", &F, &T);\n    --F;\n    --T;\n    g.connect_with(F, T, 1);\n    es0.insert(std::minmax(F, T));\n  }\n\n  std::vector<std::tuple<int, size_t, size_t>> qs;\n  std::set<std::pair<size_t, size_t>> es;\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    scanf(\"%d %zu %zu\", &M, &A, &B);\n    --A;\n    --B;\n    if (A > B) std::swap(A, B);\n    qs.emplace_back(M, A, B);\n    if (!es0.count(std::make_pair(A, B)))\n      es.emplace(A, B);\n  }\n\n  for (const auto& e: es) {\n    size_t s, d;\n    std::tie(s, d) = e;\n    g.connect_with(s, d, 0);\n  }\n\n  // g.inspect();\n  intmax_t first = max_flow(g, 0, N-1);\n  // fprintf(stderr, \"first: %jd\\n\", first);\n\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    std::tie(M, A, B) = qs[i];\n    intmax_t df = 0;\n\n    // g.inspect();\n\n    if (M == 1) {\n      // connect\n      // fprintf(stderr, \"+ %zu %zu\\n\", A, B);\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        e.cap = 1;\n        g[B][e.rev].cap = 1;\n        df = max_flow(g, 0, N-1);\n        break;\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n\n    if (M == 2) {\n      // disconnect\n      // fprintf(stderr, \"- %zu %zu\\n\", A, B);\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        if (e.cap > 0 && g[B][e.rev].cap > 0) {\n          e.cap = 0;\n          g[B][e.rev].cap = 0;\n          break;\n        }\n\n        if (e.cap == 0) {\n          intmax_t tmp = max_flow(g, e.src, e.dst, 1L);\n          if (tmp > 0) break;\n          max_flow(g, N-1, 0, 1L);\n          max_flow(g, e.src, e.dst, 1L);\n          df = -1;\n          break;\n        }\n        if (g[B][e.rev].cap == 0) {\n          intmax_t tmp = max_flow(g, e.dst, e.src, 1L);\n          if (tmp > 0) break;\n          max_flow(g, N-1, 0, 1L);\n          max_flow(g, e.dst, e.src, 1L);\n          df = -1;\n          break;\n        }\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n  }\n\n  // g.inspect();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\nconst int MAX_V = 1000;\nconst int INF = 1 << 25;\n\nint V;\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, 0, int(G[from].size() - 1) });\n}\n\nvoid add_edge2(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, cap, int(G[from].size() - 1) });\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(edge& e : G[v]) {\n\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim) {\n\tint flow = 0;\n\twhile(1) {\n\t\tfill(used, used + V, false);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0 || flow == lim) return flow;\n\t\tflow += f;\n\t\tlim -= f;\n\t}\n\treturn -1;\n}\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nbool ex[1000][1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tint S = N, T = N + 1;\n\tV = N + 2;\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tadd_edge2(a, b, 1);\n\t\tex[a][b] = ex[b][a] = true;\n\t}\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tif(!ex[A[i]][B[i]]) {\n\t\t\tadd_edge2(A[i], B[i], 0);\n\t\t\tex[A[i]][B[i]] = ex[B[i]][A[i]] = true;\n\t\t}\n\t}\n\tadd_edge(S, 0, 1000000);\n\tadd_edge(N - 1, T, 1000000);\n\n\tint f = max_flow(S, T, INF);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tf += max_flow(S, T, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\tint c = e.cap;\n\t\t\t\t\te.cap = G[v][e.rev].cap = 0;\n\t\t\t\t\tif(c == 0) {// u -> v\n\t\t\t\t\t\tif(max_flow(u, v, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(u, v, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(u, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, v, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 2) {// v -> u\n\t\t\t\t\t\tif(max_flow(v, u, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(v, u, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(v, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, u, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(ok[s][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\tok[s][i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = (used[i][j] != used[j][i]);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 0;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 0;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 D : nRÌ\n\n#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint cap[500][500];\n\nint maximumFlow(int n, int s, int t, bool first = false){\n\tint res = 0;\n\tint prev[500];\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tmemset(prev, -1, sizeof(prev)); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\t// êxÉ¬·t[ÌeÊÍ1Åè\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j]--, cap[j][prev[j]]++;\n\t\tres++;\n\t\t// ñÅÈ¯êÎ¬êéÊÍX1\n\t\tif(!first) return res;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1, true);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\t// }ðÇÁµAt[ðvZ\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\tint s = A-1, t = B-1;\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t// s->tÌ}ªgpÏÝÌ\n\t\t\t\t\tif(cap[t][s] == 2){\n\t\t\t\t\t\tcap[t][s] = 0;\n\t\t\t\t\t\tint tmp = maximumFlow(N, s, t); \n\t\t\t\t\t\t// s->tÖÌÊÌpXª¶ÝµÈ¢Æ«\n\t\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\t\t// 0->s ÖÌt[ðÅ¿Á·\n\t\t\t\t\t\t\tmaximumFlow(N, s, 0);\n\t\t\t\t\t\t\t// t->N-1ÖÌt[ðÅ¿Á·\n\t\t\t\t\t\t\tmaximumFlow(N, N-1, t);\n\t\t\t\t\t\t\t// t[ÌÊÍ1¸­\n\t\t\t\t\t\t\tcur--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswap(s, t);\n\t\t\t\t}\n\t\t\t\tcap[s][t] = cap[t][s] = 0;\n\t\t\t}\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool dfs(int v, int t, vector<vector<int>> &mat, vector<bool> &used) {\n\tif(v == t) return true;\n\n\tused[v] = true;\n\tconst int n = mat.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(mat[v][i] > 0 && !used[i] && dfs(i, t, mat, used)) {\n\t\t\t--mat[v][i];\n\t\t\t++mat[i][v];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rdfs(int v, int t, vector<vector<int>> &mat, vector<bool> &used) {\n\tif(v == t) return true;\n\n\tused[v] = true;\n\tconst int n = mat.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(mat[v][i] == 2 && !used[i] && rdfs(i, t, mat, used)) {\n\t\t\t--mat[v][i];\n\t\t\t++mat[i][v];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tvector<vector<int>> mat(n, vector<int>(n, 0));\n\twhile(m--) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tmat[a][b] = mat[b][a] = 1;\n\t}\n\n\tconst int s = 0;\n\tconst int t = n - 1;\n\n\tint flow = 0;\n\tvector<bool> used(n, false);\n\twhile(dfs(s, t, mat, used)) {\n\t\t++flow;\n\t\tfill(used.begin(), used.end(), false);\n\t}\n\n\twhile(q--) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\t--a; --b;\n\n\t\tif(m == 1) { // connect\n\t\t\tmat[a][b] = mat[b][a] = 1;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tflow += dfs(s, t, mat, used);\n\t\t}\n\t\telse { // cut\n\t\t\tif(mat[a][b] != 1) {\n\t\t\t\t--flow;\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(mat[a][b] == 0) {\n\t\t\t\t\tmat[b][a] = 0;\n\t\t\t\t\trdfs(a, s, mat, used);\n\t\t\t\t\trdfs(t, b, mat, used);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmat[a][b] = 0;\n\t\t\t\t\trdfs(b, s, mat, used);\n\t\t\t\t\trdfs(t, a, mat, used);\n\t\t\t\t}\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tflow += dfs(s, t, mat, used);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmat[a][b] = mat[b][a] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow << \"\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow - G[to][x.rev].cap;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tflow = prev - G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n \nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n \nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n    level[e.to]=level[v]+1;\n    que.push(e.to);\n      }\n    }\n  }\n}\n \nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n    e.cap-=d;\n    G[e.to][e.rev].cap+=d;\n    return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n \nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      if(M[a].find(b)==M[a].end()) add_edge(a,b,1);\n      else G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=1;\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n    }\n    for(int i=1;i<=N;i++) G[i]=G2[i];\n    printf(\"%d\\n\",max_flow(1,N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing Flow = int;\n\nint N;\nvector<vector<int>> cap;\n\ntemplate<Flow inf> Flow fordFulkerson(const int &source, const int &sink) {\n  vector<int> used(N);\n  function<Flow(int, Flow)> dfs = [&](int v, Flow f) -> Flow {\n    if (v == sink) return f;\n    used[v] = true;\n    rep(i, N) {\n      if (used[i] || cap[v][i] <= 0) continue;\n      Flow d = dfs(i, min(f, cap[v][i]));\n      if (d <= 0) continue;\n      cap[v][i] -= d;\n      cap[i][v] += d;\n      return d;\n    }\n    return 0;\n  };\n  if (inf == 1) {\n    fill(used.begin(), used.end(), false);\n    return dfs(source, inf);\n  }\n  Flow s, f;\n  for (s = 0; (f = dfs(source, inf)); s += f) fill(used.begin(), used.end(), false);\n  return s;\n}\n\nint main() {\n  int E, Q;\n  cin >> N >> E >> Q;\n  cap = vector<vector<int>>(N, vector<int>(N));\n  rep(i, E) {\n    int f, t;\n    cin >> f >> t;\n    --f, --t;\n    cap[f][t] = cap[t][f] = 1;\n  }\n  Flow f = fordFulkerson<1000000000>(0, N - 1);\n  rep(i, Q) {\n    int m, a, b;\n    cin >> m >> a >> b;\n    --a, --b;\n    if (m == 1) {\n      cap[a][b] = cap[b][a] = 1;\n      f += fordFulkerson<1>(0, N - 1);\n    } else {\n      if (cap[a][b] != 0) swap(a, b);\n      if (cap[a][b] == 0 && fordFulkerson<1>(a, b) == 0) {\n        fordFulkerson<1>(N - 1, b);\n        fordFulkerson<1>(a, 0);\n        f--;\n      }\n      cap[a][b] = cap[b][a] = 0;\n    }\n    cout << f << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    //scanf(\"%d%d\",&f,&t);\n    cin >> f >> t;\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\nint x[1000], s[1000], t[1000];\nset<P> saw;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        if(s > t) swap(s,t);\n        s--; t--;\n        saw.insert(P(s,t));\n        add_edge(s,t,1);\n    }\n    rep(i,q){\n        cin >> x[i] >> s[i] >> t[i];\n        s[i]--; t[i]--;\n        if(s[i] > t[i]) swap(s[i],t[i]);\n        if(saw.count(P(s[i],t[i])) == 0){\n            add_edge(s[i],t[i],0);\n            saw.insert(P(s[i],t[i]));\n        }\n    }\n    rep(i,q){\n        if(x[i] == 1){\n            rep(j,G[s[i]].size()){\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 1;\n                }\n            }\n            rep(j,G[t[i]].size()){\n                if(G[t[i]][j].to == s[i]){\n                    G[t[i]][j].cap = 1;\n                }\n            }\n        } else{\n            rep(j,G[s[i]].size()){\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 0;\n                }\n            }\n            rep(j,G[t[i]].size()){\n                if(G[t[i]][j].to == s[i]){\n                    G[t[i]][j].cap = 0;\n                }\n            }\n        }\n        rep(j,n) H[j] = G[j];\n        cout << max_flow(0,n-1) << endl;\n        rep(j,n) G[j] = H[j];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n\tint src, dst; Capacity cap;\n\tEdge(int s, int d, Capacity c) : src(s), dst(d), cap(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct FordFulkerson {\n\ttypedef vector<vector<Capacity>> Matrix;\n\tint n, t;\n\tvector<bool> vis;\n\tvector<vector<Capacity>> cap, flow;\n\tvector<vector<int>> g;\n\tCapacity inf;\n\tFordFulkerson(int n)\n\t\t: n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf(numeric_limits<Capacity>::max() / 8) {\n\t}\n\tFordFulkerson(const Graph &graph) {\n\t\t*this = FordFulkerson(graph.size());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n\t\t}\n\t}\n\tvoid addEdge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tif(count(g[u].begin(), g[u].end(), v) == 0) {\n\t\t\tg[u].push_back(v); g[v].push_back(u);\n\t\t}\n\t}\n\tCapacity solve(int s, int t, int lim) {\n\t\tthis->t = t;\n\t\tCapacity res = 0, aug = 1;\n\t\twhile(aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, lim));\n\t\t}\n\t\treturn res;\n\t}\n\tCapacity augment(const int &v, const Capacity &lim) {\n\t\tvis[v] = true;\n\t\tif(v == t) return lim;\n\t\tfor(const int &d : g[v]) {\n\t\t\tif(vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tCapacity aug = augment(d, min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif(aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tFordFulkerson ff(N + 2);\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tff.addEdge(a, b, 1);\n\t\tff.addEdge(b, a, 1);\n\t}\n\tint S = N, T = N + 1;\n\tff.addEdge(S, 0, 10000);\n\tff.addEdge(N - 1, T, 10000);\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tff.addEdge(A[i], B[i], 0);\n\t\tff.addEdge(B[i], A[i], 0);\n\t}\n\tint f = ff.solve(S, T, ff.inf);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tff.addEdge(u, v, 1);\n\t\t\tff.addEdge(v, u, 1);\n\t\t\tf += ff.solve(0, N - 1, 1);\n\t\t}\n\t\telse {\n\t\t\tint uv = ff.flow[u][v], vu = ff.flow[v][u];\n\t\t\tff.cap[u][v] = ff.cap[v][u] = 0;\n\t\t\tff.flow[u][v] = ff.flow[v][u] = 0;\n\n\t\t\tif(uv > vu) {\n\t\t\t\tif(ff.solve(u, v, 1) == 0) {\n\t\t\t\t\tff.solve(u, S, 1);\n\t\t\t\t\tff.solve(T, v, 1);\n\t\t\t\t\tf--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(vu > uv) {\n\t\t\t\tif(ff.solve(v, u, 1) == 0) {\n\t\t\t\t\tff.solve(v, S, 1);\n\t\t\t\t\tff.solve(T, u, 1);\n\t\t\t\t\tf--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P, P> PP;\nconstexpr ll MOD = ll(1e9 + 7);\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, cap, rev;\n    bool deleted, isrev;\n};\n\nint V, E, Q, F;\nvector<vector<edge> > G;\nvector<bool> used;\n\nvoid add_edge(int from, int to, int cap){\n    G[from].emplace_back((edge){to, cap, int(G[to].size()), false, false});\n    G[to].emplace_back((edge){from, 0, int(G[from].size())-1, false, true});\n}\n\n// 増加路の探索\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(auto &e : G[v]){\n        if(!used[e.to] && e.cap > 0 && !e.deleted){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint flow(int s, int t, int lim){\n    int fl = 0;\n    while(1){\n        fill(used.begin(), used.end(), false);\n        int f = dfs(s, t, lim);\n        if(f==0) break;\n        fl += f;\n        lim -= f;\n    }\n    return fl;\n}\n\nvoid delete_edge(int from, int to){\n    bool ft = false, tf = false;\n    for(auto &e : G[from]){\n        if(e.to == to && !e.deleted){\n            if(e.isrev && e.cap > 0){\n                ft = true;\n            }\n        }\n    }\n    for(auto &e : G[to]){\n        if(e.to == from && !e.deleted){\n            if(e.isrev && e.cap > 0){\n                tf = true;\n            }\n        }\n    }\n    if(ft && !tf){\n        if(flow(to, from, 1)==0){\n            flow(V-1, 0, 1);\n            flow(to, from, 1);\n            F--;\n        }\n    }\n    if(tf && !ft){\n        if(flow(from, to, 1)==0){\n            flow(V-1, 0, 1);\n            flow(from, to, 1);\n            F--;\n        }\n    }\n    for(auto &e : G[from]){\n        if(e.to == to && !e.deleted){\n            e.deleted = true;\n        }\n    }\n    for(auto &e : G[to]){\n        if(e.to == from && !e.deleted){\n            e.deleted = true;\n        }\n    }\n}\n\nint main() {\n    cin >> V >> E >> Q;\n    G.resize(V);\n    used.resize(V);\n    for(int i=0;i<E;i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        add_edge(u, v, 1);\n        add_edge(v, u, 1);\n    }\n    F = 0;\n    for(int i=0;i<Q;i++){\n        int m, a, b;\n        cin >> m >> a >> b;\n        a--; b--;\n        if(m == 1){\n            add_edge(a, b, 1);\n            add_edge(b, a, 1);\n        }\n        else{\n            delete_edge(a, b);\n        }\n        F += flow(0, V-1, IINF);\n        cout << F << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nint INF = 1 << 20;\n#define MAX_V 500\n\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G( MAX_V ); // ??°???????????£??\\???????????¨???\nbool used[MAX_V]; // DFS??§?????§??????????????????????????°\n\t\t\t\t  // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge( int from, int to, int cap ) {\n\tedge a;\n\ta.to = to;\n\ta.cap = cap;\n\ta.rev = G[to].size(); \n\tedge b;\n\tb.to = from;\n\tb.cap = 0;\n\tb.rev = G[from].size();\n\tG[from].push_back( a );\n\tG[to].push_back( b );\n}\n\nvoid del_edge( int from, int to ) {\n\tauto ite = G[from].begin();\n\twhile( ite < G[from].end() ) {\n\t\tif( ( *ite ).to == to ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n\n\n\tite = G[to].begin();\n\twhile( ite < G[to].end() ) {\n\t\t//cout << to << \" \" << ( *ite ).to << \" \" << ( *ite ).cap << endl;\n\t\tif( ( *ite ).to == from ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs( int v, int t, int f ) {\n\tif( v == t ) return f;\n\tused[v] = true;\n\tfor( int i = 0; i < G[v].size(); i++ ) {\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0 ) {\n\t\t\tint d = dfs( e.to, t, min( f, e.cap ) );\n\t\t\tif( d > 0 ) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow( int s, int t ) {\n\tfor( size_t i = 0; i < MAX_V; i++ ) {\n\t\tused[i] = false;\n\t}\n\tint flow = 0;\n\tfor( ;;) {\n\t\tmemset( used, 0, sizeof( used ) );\n\t\tint f = dfs( s, t, INF );\n\t\tif( f == 0 ) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n\tlong long int N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge( F, T, 1 );\n\t\tadd_edge( T, F, 1 );\n\t}\n\tfor( size_t i = 0; i < Q; i++ ) {\n\t\tlong long int M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif( M == 1 ) {\n\t\t\tadd_edge( A, B, 1 );\n\t\t\tadd_edge( B, A, 1 );\n\t\t} else {\n\t\t\tdel_edge( A, B );\n\t\t}\n\t\tauto memo = G;\n\t\tcout << max_flow( 0, N - 1 ) << endl;\n\t\tG = memo;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter, used;\n  int flow;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front(); que.pop();\n      for(const edge& e : graph[p]) {\n        if(!e.alive) continue;\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return(min_cost[t] != -1);\n  }\n   \n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    for(int i = iter[idx]; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(flow < lim && bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      int f = 0;\n      while((f = dfs(s, t, lim - flow)) > 0) {\n        flow += f;\n      }\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    bool flag = false;\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(from, to, 1);\n            flag = true;\n          }\n        } else if(re.cap == 0) {\n          if(max_flow(to, from, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(to, from, 1);\n            flag = true;\n          }\n        }\n        e.alive = re.alive = false;\n        return(flag);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[501];\nbool used[501];\n\nvoid add_edge(int from,int to){\n  G[from].push_back({to,1,(int)G[to].size()});\n  G[to].push_back({from,1,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //  cout<<'v'<<v<<endl;\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int fl=1<<29){\n  if(s==t)return 0;\n  int flow=0;\n  for(;;){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,fl);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  while(E--){\n    int F,T;\n    cin>>F>>T;\n    add_edge(F,T);\n  }\n  int flow=max_flow(1,N);\n  while(Q--){\n    int M,A,B;\n    cin>>M>>A>>B;\n    if(M==1){\n      add_edge(A,B);\n      flow+=max_flow(1,N);\n    }else{\n      int x;\n      for(x=0;G[A][x].to!=B;x++);\n      if(G[A][x].cap!=1){\n\tint f,t;\n\tif(G[A][x].cap==0){\n\t  f=A;\n\t  t=B;\n\t}else{\n\t  f=B;\n\t  t=A;\n\t}\n\tif(!max_flow(f,t,1)){\n\t  max_flow(N,t,1);\n\t  max_flow(f,1,1);\n\t  flow--;\n\t}\n      }\n      int r=G[A][x].rev;\n      for(int i=x+1;i<G[A].size();i++){\n\tauto e=G[A][i];\n\tG[e.to][e.rev].rev--;\n      }\n      for(int i=r+1;i<G[B].size();i++){\n\tauto e=G[B][i];\n\tG[e.to][e.rev].rev--;\n      }\n      G[A].erase(begin(G[A])+x);\n      G[B].erase(begin(G[B])+r);\n    }\n    cout<<flow<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool augument(vector<vector<int> >& flow, const vector<vector<int> >& capacity, int s, int g)\n{\n  int size = capacity.size();\n  queue<int> q;\n  vector<int> prev(size, -1);\n  prev[s] = s;\n  q.push(s);\n  while (!q.empty()) {\n    int n = q.front();\n    q.pop();\n    for (int i = 0; i < size; i++) {\n      if (capacity[n][i] - flow[n][i] <= 0) continue;\n      if (prev[i] != -1) continue;\n      prev[i] = n;\n      q.push(i);\n      if (i == g) goto endloop;\n    }\n  }\nendloop:\n  if (prev[g] == -1) return false;\n  for (int i = g; prev[i] != i; i = prev[i]) {\n    ++flow[prev[i]][i];\n    --flow[i][prev[i]];\n  }\n  return true;\n}\n\npair<int, vector<vector<int> > >\nmaxflow(const vector<vector<int> >& capacity, int s, int g) {\n  int size = capacity.size();\n  vector<vector<int> > flow(size, vector<int>(size, 0));\n  int ans = 0;\n  while (augument(flow, capacity, s, g)) {\n    ++ans;\n  }\n  return make_pair(ans, flow);\n}\n\nvoid bfs(vector<vector<int> >& flow, int start, int goal)\n{\n  const int N = flow.size();\n  queue<int> q;\n  vector<int> prev(N, -1);\n  q.push(start);\n  prev[start] = start;\n  while (!q.empty()) {\n    int n = q.front();\n    q.pop();\n    if (n == goal) {\n      while (prev[n] != n) {\n        flow[prev[n]][n] = flow[n][prev[n]] = 0;\n        n = prev[n];\n      }\n      return;\n    }\n    for (int i = 0; i < N; i++) {\n      if (flow[n][i] > 0 && prev[i] == -1) {\n        prev[i] = n;\n        q.push(i);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector<vector<int> > capacity(N, vector<int>(N, 0));\n  for (int i = 0; i < E; i++) {\n    int f, t;\n    cin >> f >> t;\n    --f;    --t;\n    capacity[f][t] = capacity[t][f] = 1;\n  }\n\n  pair<int, vector<vector<int> > > r = maxflow(capacity, 0, N-1);\n  int maxf = r.first;\n  vector<vector<int> > flow = r.second;\n  while (Q-- > 0) {\n    int m, a, b;\n    cin >> m >> a >> b;\n    --a;    --b;\n    if (m == 1) {\n      capacity[a][b] = capacity[b][a] = 1;\n    } else {\n      capacity[a][b] = capacity[b][a] = 0;\n      if (flow[a][b] != 0) {\n        --maxf;\n        if (flow[a][b] < 0) {\n          swap(a, b);\n        }\n        flow[a][b] = flow[b][a] = 0;\n        bfs(flow, 0, a);\n        bfs(flow, b, N-1);\n      }\n    }\n    if (augument(flow, capacity, 0, N-1)) {\n      ++maxf;\n    }\n\n    cout << maxf << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    int f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            add_edge(a,b,1);\n            add_edge(b,a,1);\n            f+=max_flow(0,N-1);\n        }\n        else{\n            rep(beet,2){\n                for(int i=0;i<G[a].size();i++){\n                    if(G[a][i].type==0||G[a][i].to!=b)continue;\n                    if(G[a][i].cap==1){\n                        G[a][i].cap=0;\n                        G[a][i].type=0;\n                        continue;\n                    }\n\n                    int t=max_flow(a,b);\n                    if(t==1){\n                        G[a][i].type=0;\n                        G[G[a][i].to][G[a][i].rev].cap=0;\n                        continue;\n                    }\n\n                    add_edge(0,N-1,1);\n                    t=max_flow(a,b);\n                    assert(t&&G[0].back().cap==0);\n                    f--;\n                    G[0].pop_back();G[N-1].pop_back();\n\n                    G[a][i].type=0;\n                    G[G[a][i].to][G[a][i].rev].cap=0;\n                }\n\n                f+=max_flow(0,N-1);\n                swap(a,b);\n            }\n        }\n\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath(N-1,v);\n//\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, cap, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n/*\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tbool nf = flag || (s == from && e.to == to);\n\t\tif (!used2[e.to][(int)nf] && e.cap > 0) {\n\t\t\tbool f = dfs2(e.to, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\te.cap -= 1;\n\t\t\t\tG[e.to][e.rev].cap += 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n*/\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tfor (int i = 0; i < G[a].size(); ++i) {\n\t\tEdge& e = G[a][i];\n\t\tif (e.to == b) {\n\t\t\tif (e.cap > 1) {\n\t\t\t\treturn removeEdge(b, a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cap = e.cap;\n\t\t\t\tG[b].erase(G[b].begin()+e.rev);\n\t\t\t\tG[a].erase(G[a].begin()+i);\n\n\t\t\t\tif (cap < 1) {\n//\t\t\t\t\tmemset(used2, false, sizeof(used2));\n//\t\t\t\t\tdfs2(N-1, 0, b, a, false);\n\t\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\t\tif ( !dfs(a, b, 1) ) {\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(a, 0, 1);\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(N-1, b, 1);\n\t\t\t\t\t}\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tG.resize(N);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T, 1);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b, 1);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tf += flow(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\nconst int MAX_V = 1000;\nconst int INF = 1 << 25;\n\nint V;\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, G[to].size() });\n\tG[to].push_back(edge{ from, cap, G[from].size() - 1 });\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(edge& e : G[v]) {\n\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim) {\n\tint flow = 0;\n\twhile(1) {\n\t\tfill(used, used + V, false);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n\treturn -1;\n}\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nbool ex[1000][1000];\n\ntypedef pair<int, int> Pii;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tint S = N, T = N + 1;\n\tV = N + 2;\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tadd_edge(a, b, 1);\n\t\tex[a][b] = ex[b][a] = true;\n\t}\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tif(!ex[A[i]][B[i]]) {\n\t\t\tadd_edge(A[i], B[i], 0);\n\t\t\tex[A[i]][B[i]] = ex[B[i]][A[i]] = true;\n\t\t}\n\t}\n\tadd_edge(S, 0, 1000000);\n\tadd_edge(N - 1, T, 1000000);\n\tint f = max_flow(S, T, INF);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tf += max_flow(S, T, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\tint c = e.cap;\n\t\t\t\t\te.cap = G[v][e.rev].cap = 0;\n\t\t\t\t\tif(c == 0) {// u -> v\n\t\t\t\t\t\tif(max_flow(u, v, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(u, S, 1);\n\t\t\t\t\t\t\tmax_flow(T, v, 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 2) {// v -> u\n\t\t\t\t\t\tif(max_flow(v, u, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(v, S, 1);\n\t\t\t\t\t\t\tmax_flow(T, u, 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\ttmp=maxFlow(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E+1];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E+1];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[501][501];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0){\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmemset(isUsable,0,sizeof(isUsable));\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// êxà¬êÄ¢È¢\n\t\t\tif(!isDirected[eidx]){\n\t\t\t\t// Øé¾¯\n\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\tisUsable[eidx]=false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==1){\n\t\t\t\t\t\t\t\tlineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// flowª¬êÄ¢éêAg©çtÜÅAt©çfÜÅAf©çsÜÅ»ê¼ê\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// Øf\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==0){\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// Øf\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, cap, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tfor (int i = 0; i < G[a].size(); ++i) {\n\t\tEdge& e = G[a][i];\n\t\tif (e.to == b) {\n\t\t\tif (e.cap > 1) {\n\t\t\t\treturn removeEdge(b, a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint d = 1 - e.cap;\n\t\t\t\tG[b].erase(G[b].begin()+e.rev);\n\t\t\t\tG[a].erase(G[a].begin()+i);\n\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(a, 0, 1);\n\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(N-1, b, 1);\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tG.resize(N);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T, 1);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b, 1);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tf += flow(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tes[u][v]=0;\n\tes[v][u]=0;\n\tif(findpath2(v,u)){\n\t\treturn true;\n\t}\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\nint x[1000], s[1000], t[1000];\nset<P> saw;\nint pre = 0;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        if(s > t) swap(s,t);\n        s--; t--;\n        saw.insert(P(s,t));\n        add_edge(s,t,1);\n    }\n    rep(i,q){\n        cin >> x[i] >> s[i] >> t[i];\n        s[i]--; t[i]--;\n        if(s[i] > t[i]) swap(s[i],t[i]);\n        if(saw.count(P(s[i],t[i])) == 0){\n            add_edge(s[i],t[i],0);\n            saw.insert(P(s[i],t[i]));\n        }\n    }\n    rep(i,q){\n        if(x[i] == 1){\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 1;\n                    G[t[i]][rev].cap = 1;\n                }\n            }\n            pre = max_flow(0,n-1)+pre;\n        } else{\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 0;\n                    G[t[i]][rev].cap = 0;\n                }\n            }\n            rep(j,n) rep(k,G[j].size()){\n                int rev = G[j][k].rev;\n                int to = G[j][k].to;\n                if(G[j][k].cap == 2){\n                    G[j][k].cap = 1;\n                    G[to][rev].cap = 1;\n                }\n            }\n            pre = max_flow(0,n-1);\n        }\n        cout << pre << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap) {\n\tfor (int i = 0; i < G[from].size(); ++i) {\n\t\tEdge& e = G[from][i];\n\t\tif (e.to == to) {\n\t\t\te.cap = G[e.to][e.rev].cap = cap;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, cap, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tif (s == to && !flag) return false;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (s == from && e.to != to) continue;\n\t\tbool nf = flag || (s == from && e.to == to);\n\t\tif (!used2[e.to][(int)nf] && e.cap > 0) {\n\t\t\tbool f = dfs2(e.to, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\t--e.cap;\n\t\t\t\t++G[e.to][e.rev].cap;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tfor (int i = 0; i < G[a].size(); ++i) {\n\t\tEdge& e = G[a][i];\n\t\tif (e.to == b) {\n\t\t\tif (e.cap > 1) {\n\t\t\t\treturn removeEdge(b, a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cap = e.cap;\n\t\t\t\tif (cap < 1) {\n\t\t\t\t\tfill(&used2[0][0], &used2[0][0]+500*2, false);\n\t\t\t\t\tif ( !dfs2(N-1, 0, b, a, false) ) {\n\t\t\t\t\t\tcout << \"ERROR\" << endl;\n\t\t\t\t\t}\n/*\n\t\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\t\tif ( !dfs(a, b, 1) ) {\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(a, 0, 1);\n\t\t\t\t\t\tmemset(used, false, sizeof(used)); dfs(N-1, b, 1);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t\te.cap = G[e.to][e.rev].cap = 0;\n//\t\t\t\tG[b].erase(G[b].begin()+e.rev);\n//\t\t\t\tG[a].erase(G[a].begin()+i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tG.resize(N);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T, 1);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b, 1);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tmemset(used, false, sizeof(used)); f += dfs(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\n\nconst int MAX = 501;\nbool edge[MAX][MAX];\nbool flow[MAX][MAX];\n\nint N, E, Q;\n\nbool used[500];\nbool _dfs(int s, int t)\n{\n\tif (s == t)\n\t\treturn true;\n\n\tused[s] = true;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (!used[i] && edge[s][i])\n\t\t{\n\t\t\tif (!flow[s][i])\n\t\t\t{\n\t\t\t\tif (_dfs(i, t))\n\t\t\t\t{\n\t\t\t\t\tif (flow[i][s])\n\t\t\t\t\t\tflow[i][s] = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tflow[s][i] = true;\n\t\t\t\t\t//flow[s][i] = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flow[i][s])\n\t\t\t{\n\t\t\t\tif (_dfs(i, t))\n\t\t\t\t{\n\t\t\t\t\tflow[i][s] = false;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool dfs(int s, int t)\n{\n\tfill(used, used+N+1, false);\n\treturn _dfs(s, t);\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &Q);\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tedge[f][t] = edge[t][f] = true;\n\t}\n\n\tint res = 0;\n\twhile (dfs(1, N))\n\t\t++res;\n\n\tfor (int i = 0; i < Q; ++i)\n\t{\n\t\tint\tm, a, b;\n\t\tscanf(\"%d%d%d\", &m, &a, &b);\n\n\t\tif (m == 1)\n\t\t{\n\t\t\tedge[a][b] = edge[b][a] = true;\n\t\t\tif (dfs(1, N))\n\t\t\t\t++res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tedge[a][b] = edge[b][a] = false;\n\n\t\t\tif (flow[a][b] && !dfs(a, b))\n\t\t\t{\n\t\t\t\tdfs(a, 1);\n\t\t\t\tdfs(N, b);\n\t\t\t\t--res;\n\t\t\t}\n\t\t\tif (flow[b][a] && !dfs(b, a))\n\t\t\t{\n\t\t\t\tdfs(b, 1);\n\t\t\t\tdfs(N, a);\n\t\t\t\t--res;\n\t\t\t}\n\t\t\tflow[a][b] = flow[b][a] = false;\n\t\t}\n\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 510\n\n\nint V,E;\nint capacity[NUM][NUM];\n\nvector<int> G[NUM];\nbool used[NUM];\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n\tcapacity[from][to] = 1;\n\tcapacity[to][from] = 1;\n}\n\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow;\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint to = G[node_id][i];\n\t\tif(used[to] == false &&  capacity[node_id][to] > 0){\n\t\t\tint tmp_flow = dfs(to,sink,min(flow,capacity[node_id][to]));\n\t\t\tif(tmp_flow > 0){\n\t\t\t\tcapacity[node_id][to] -= tmp_flow;\n\t\t\t\tcapacity[to][node_id] += tmp_flow;\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint max_flow(int source,int sink,int limit){\n\tint flow = 0,add;\n\twhile(limit > 0){\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,1);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t\tlimit--;\n\t}\n\treturn flow;\n}\n\n\nint main(){\n\n\tint N,E,Q;\n\tscanf(\"%d %d %d\",&N,&E,&Q);\n\n\tV = N;\n\n\tint from,to;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to);\n\t}\n\n\tint ans = max_flow(0,N-1,BIG_NUM);\n\n\tint command,A,B;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%d %d %d\",&command,&A,&B);\n\t\tA--;\n\t\tB--;\n\n\t\tif(command == 1){\n\t\t\tadd_edge(A,B);\n\t\t}else{\n\n\t\t\tif(capacity[A][B] == 1 && capacity[B][A] == 1){\n\t\t\t\t//Do nothing\n\t\t\t}else if(capacity[A][B] == 2){\n\t\t\t\tif(max_flow(B,A,1) == 1){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tmax_flow(N-1,0,1);\n\t\t\t\t\tif(capacity[B][A] == 1){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmax_flow(B,A,1);\n\t\t\t\t\t}\n\t\t\t\t\tans--;\n\t\t\t\t}\n\t\t\t}else{ //capacity[B][A] == 2\n\n\t\t\t\tif(max_flow(A,B,1) == 1){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tmax_flow(N-1,0,1);\n\t\t\t\t\tif(capacity[A][B] == 1){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmax_flow(A,B,1);\n\t\t\t\t\t}\n\t\t\t\t\tans--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcapacity[A][B] = 0;\n\t\t\tcapacity[B][A] = 0;\n\t\t}\n\n\t\tans += max_flow(0,N-1,1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to; bool cap; int rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nbool dfs(int v, int t, bool f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap && level[v] < level[e.to]){\n      bool d = dfs(e.to,t,f&e.cap,G);\n      if(d){\n        e.cap = false;\n        G[e.to][e.rev].cap = true;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    bool f;\n    while((f = dfs(s,t,INF,G))){\n      ++flow;\n    }\n  }\n}\n\nint main(){\n  int N, E, Q;\n  scanf(\"%d %d %d\",&N,&E,&Q);\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  for(int i = 0; i < E; ++i){\n    int f, t;\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  for(int i = 0; i < Q; ++i){\n    int m, a, b, flow;\n    scanf(\"%d %d %d\",&m,&a,&b);\n    --a,--b;\n    G[a][2*b].cap = (m != 2);\n    G[b][2*a].cap = (m != 2);\n    flow = max_flow(0, N-1, G);\n    printf(\"%d\\n\", flow);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n  if(v==t)\n    return f;\n  used[v]=true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    bool b=false;\n    // Ü¾ü«ªÜÁÄ¢È¢ÈçA±±Åè\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ¡ñ¬·t[Ìü«É¶ÄeÊðt]\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // t[ª¬¹È©Á½êÍAÜÁÄ¢È©Á½±ÆÉ·é\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // »ÝÜÅÌÅå¬ÊðßÄ¨­\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // eNGÌãÌ¬Êðßé\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ÂÈ®\n    if(m==1){\n      add_edge(a,b,1);\n      // Ä¬o\n      cFlow+=max_flow(1,n);\n    }\n    // Øf·é\n    else{\n      // ØfÓªÜ¾Êß³êÄ¢È¢ê\n      if(!isDirected[a][b]){\n\tcout<<cFlow<<endl;\n\tfor(int j = 0; j < G[a].size(); j++){\n\t  if(G[a][j].to==b){\n\t    edge &e=G[a][j];\n\t    G[a].erase(G[a].begin()+j);\n\t    G[b].erase(G[b].begin()+e.rev);\n\t    isDirected[a][b]=false;\n\t    isDirected[b][a]=false;\n\t    break;\n\t  }\n\t}\n\tcontinue;\n      }\n      // t[ª·ÅÉ¬êÄ¢½êA\n      // ðð½·æ¤Ét[ðµß·\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ü«ÍÜÁÄ¢éª¬Ê0\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0)\n\t    ff+=max_flow(a,b);\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0)\n\t    ff+=max_flow(b,a);\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b)\n\t      max_flow(n,b);\n\t    if(a!=1)\n\t      max_flow(a,1);\n\t    cFlow--;\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    if(b!=n)\n\t      max_flow(b,n);\n\t    if(a!=1)\n\t      max_flow(1,a);\n\t    cFlow--;\n\t  }\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a].erase(G[a].begin()+idx);\n      G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint n;\nvector<vector<Edge> > edges;\nvector<bool> used;\n\nint dfs(int s, int t, int f){\n    if(s == t)\n        return f;\n    used[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 0){\n            int g = dfs(e.to, t, min(f, e.cap));\n            if(g > 0){\n                e.cap -= g;\n                edges[e.to][e.rev].cap += g;\n                return g;\n            }\n        }\n    }\n    return 0;\n}\n\nint flow(int s, int t){\n    used.assign(n+1, false);\n    return dfs(s, t, INT_MAX);\n}\n\nbool dfs2(int s, int t){\n    if(s == t)\n        return true;\n    used[s] = true;\n    for(unsigned i=0; i<edges[s].size(); ++i){\n        Edge& e = edges[s][i];\n        if(!used[e.to] && e.cap > 1 && dfs2(e.to, t)){\n            -- e.cap;\n            ++ edges[e.to][e.rev].cap;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid flowBack(int s, int t){\n    used.assign(n+1, false);\n    if(!dfs2(s, t))\n        for(;;);\n}\n\nint main()\n{\n    int e, q;\n    cin >> n >> e >> q;\n\n    edges.assign(n+1, vector<Edge>());\n    for(int i=0; i<e; ++i){\n        int f, t;\n        cin >> f >> t;\n        edges[f].push_back(Edge(t, 1, edges[t].size()));\n        edges[t].push_back(Edge(f, 1, edges[f].size()-1));\n    }\n\n    int ret = 0;\n    for(;;){\n        int f = flow(1, n);\n        if(f == 0)\n            break;\n        ret += f;\n    }\n\n    for(int i=0; i<q; ++i){\n        int m, a, b;\n        cin >> m >> a >> b;\n        if(m == 1){\n            unsigned j = 0;\n            while(j < edges[a].size() && edges[a][j].to != b)\n                ++ j;\n            if(j < edges[a].size()){\n                edges[a][j].cap = 1;\n                edges[b][edges[a][j].rev].cap = 1;\n            }else{\n                edges[a].push_back(Edge(b, 1, edges[b].size()));\n                edges[b].push_back(Edge(a, 1, edges[a].size()-1));\n            }\n            ret += flow(1, n);\n        }else{\n            unsigned j = 0;\n            while(edges[a][j].to != b)\n                ++ j;\n            if(edges[a][j].cap == 1){\n                edges[a][j].cap = 0;\n                edges[b][edges[a][j].rev].cap = 0;\n            }else{\n                if(edges[a][j].cap == 0){\n                    edges[b][edges[a][j].rev].cap = 0;\n                    flowBack(a, 1);\n                    flowBack(n, b);\n                }else{\n                    edges[a][j].cap = 0;\n                    flowBack(b, 1);\n                    flowBack(n, a);\n                }\n                -- ret;\n                ret += flow(1, n);\n            }\n        }\n        cout << ret << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct FordFulkerson{\n  int n;\n  vector< vector<edge> > graph;\n  vi use;\n\n  FordFulkerson(int a=0):n(a){\n    graph.resize(a); use.resize(a);\n  }\n\n  void init_use(void){fill(all(use),0);}\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g && graph[s][e].cost>0){\n\tid = e; rev = graph[s][e].rev; break;\n      }\n    }\n    if(id<0)return;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n\n    edge e = graph[s][id];\n    if(id+1!=(int)graph[s].size())graph[e.to][e.rev].rev = id;\n    e = graph[g][rev];\n    if(rev+1!=(int)graph[g].size())graph[e.to][e.rev].rev = rev;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    use[v] = 1;\n    rep(i,graph[v].sz){\n      edge &e = graph[v][i];\n      if(!use[e.to] && e.cap > 0){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      init_use();\n      int f = dfs(s,t,INF);\n      if(!f)return res;\n      res += f;\n    }\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,E,q;\n  cin >> n >> E >> q;\n  FordFulkerson mf(n);\n  rep(i,E){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    mf.AddEdge(f,t,1,1);\n    mf.AddEdge(t,f,1,1);\n  }\n\n  int F = mf.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      mf.AddEdge(a,b,1,1);\n      mf.AddEdge(b,a,1,1);\n      F += mf.max_flow(0,n-1);\n    }else{\n      int use = 0;\n      for(edge e : mf.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap == 0){\n\t  use |= 1; break;\n\t}\n      }\n      for(edge e : mf.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap == 0){\n\t  use |= 2; break;\n\t}\n      }\n      mf.DeleteEdge(a,b);\n      mf.DeleteEdge(b,a);\n\n      if(use==1 || use==2){\n\trep(i,n)mf.use[i] = 0;\n\tint another = 0;\n\tif(use==1)another = mf.dfs(a,b,1);\n\tif(use==2)another = mf.dfs(b,a,1);\n\n\tif(!another){\n\t  mf.init_use();\n\t  mf.dfs(use==1?a:b,0,1);\n\t  mf.init_use();\n\t  mf.dfs(n-1,use==1?b:a,1);\n\t  F--;\n\t}\n      }\n    }\n\n    cout << F << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll r = 0;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n                    e.cap = 0;\n                    G[B][e.rev].cap = 0;\n                    // G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n                    // G[A].erase(G[A].begin()+j, G[A].begin()+j+1);\n                    break;\n                }\n            }\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else if (r == -1) {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n \nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n \nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n \nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n \nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  int prev=0;\n  for(int i=1;i<=N;i++) G[i]=G2[i];\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      \n      if(M[a].find(b)==M[a].end()) {\n\tadd_edge(a,b,1);\n\tG[a].push_back(edge(b,1,G[b].size()));\n\tG[b].push_back(edge(a,1,G[a].size()-1));\n      }else{\n\tG[a][M[a][b]].cap=G[b][M[b][a]].cap=1;\n\tG2[a][M[a][b]].cap=G2[b][M[b][a]].cap=1;\n      }\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n      for(int i=1;i<=N;i++) G[i]=G2[i];\n      prev=0;\n    }\n    prev=prev+max_flow(1,N);\n    printf(\"%d\\n\",prev);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n#define delete_vec(v,n); v.erase(remove(v.begin(),v.end(),n),v.end());\n\nint N,E,Q;\nvector<vector<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    int to = edge[from][i];\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(b);\n  edge[b].push_back(a);\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  delete_vec(edge[a],b);\n  delete_vec(edge[b],a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n      f--;\n    }\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    //*/\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=int;\n\nstruct Edge{\n    int from,to;\n    Weight cap;\n    bool rev;\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs){\n    if(lhs.from!=rhs.from) return lhs.from<rhs.from;\n    if(lhs.to!=rhs.to) return lhs.to<rhs.to;\n    if(lhs.cap!=rhs.cap) return lhs.cap<rhs.cap;\n    return lhs.rev<rhs.rev;\n}\nusing Edges=multiset<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    Graph g;\n    Weight nowF=0;\n    const Weight INF=1e9;\n    Weight dfs(int v,int t,stack<int>& st,vector<int> &used,bool mustrev){\n        if(used[v]) return 0;\n        if(v==t) return INF;\n        used[v]=true;\n        for(auto &e:g[v]){\n            if(e.cap==0) continue;\n            if(mustrev && !e.rev) continue;\n            Weight f=dfs(e.to,t,st,used,mustrev);\n            if(f>0){\n                st.push(v);\n                return min(f,e.cap);\n            }   \n        }\n        return 0;\n    }\n    Edges::iterator rettf(int fr,int to,int cap,Edges &edges){\n        auto res=edges.find(Edge{fr,to,cap,true});\n        if(res==edges.end()) res=edges.find(Edge{fr,to,cap,false});\n        return res;\n    }\n    public:\n    Flow(int n):g(n){}\n    void addEdge(int from,int to,Weight cap){\n        g[from].insert(Edge{from,to,cap,false});\n        g[to].insert(Edge{to,from,0,true});\n    }\n    Weight maxFlow(int s,int t){\n        Weight res=0;\n        Weight f;\n        vector<int> used(g.size(),false);\n        stack<int> st;\n        while(f=dfs(s,t,st,used,false)){\n            res+=f;\n            while(!st.empty()){\n                int fr=st.top(); st.pop();\n                int to=(st.empty() ? t : st.top());\n                auto it0=rettf(fr,to,1,g[fr]);\n                auto it1=g[to].find(Edge{to,fr,0,!(it0->rev)});\n                assert(it0!=g[fr].end() && it1!=g[to].end());\n                g[fr].insert(Edge{fr,to,0,it0->rev});\n                g[fr].erase(it0);\n                g[to].insert(Edge{to,fr,1,it1->rev});\n                g[to].erase(it1);\n            }\n            fill(used.begin(),used.end(),false);\n        }\n        return nowF=nowF+res;\n    }\n\n    void decEdge(int fr,int to,int s,int t){\n        if(g[fr].find(Edge{fr,to,0,false})==g[fr].end()){\n            g[fr].erase(Edge{fr,to,1,false});\n            g[to].erase(Edge{to,fr,0,true});\n            return;\n        }\n        g[fr].erase(g[fr].find(Edge{fr,to,0,false}));        \n        g[to].erase(g[to].find(Edge{to,fr,1,true}));\n        \n        vector<int> used(g.size(),false);\n        stack<int> st;\n        int f0=dfs(fr,s,st,used,true);\n        assert(f0>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? s : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        \n        fill(used.begin(),used.end(),0);\n        int f1=dfs(t,to,st,used,true);        \n        assert(f1>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? to : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            assert(it0!=g[frr].end());\n            assert(it1!=g[too].end());\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        nowF--;\n    } \n    \n};\n\nint main(){\n    int n,e,q;\n    cin>>n>>e>>q;\n    Flow flow(n);\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        f--,t--;\n        flow.addEdge(f,t,1);\n        flow.addEdge(t,f,1);\n    }\n    for(int i=0;i<q;i++){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            flow.addEdge(a,b,1);\n            flow.addEdge(b,a,1);\n        }\n        if(m==2){\n            flow.decEdge(a,b,0,n-1);\n            flow.decEdge(b,a,0,n-1);\n        }\n        cout<<flow.maxFlow(0,n-1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\n//?????¬\n\n#define MAX_V 20001\n#define INF INT_MAX/6\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G(MAX_V); // ??°???????????£??\\???????????¨???\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\n // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to) {\n\tint rev = INT_MIN;\n\tfor (auto i = G[from].begin(); i < G[from].end();)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\trev = (*i).rev;\n\t\t\t(*i).cap = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (rev == INT_MIN)\n\t{\n\t\tG[from].push_back({ to,1, (int)G[to].size() });\n\t\tG[to].push_back({ from, 1, (int)G[from].size() - 1 });\n\t\treturn;\n\t}\n\telse {\n\t\tG[to][rev].cap = 1;\n\t}\n}\n\n\n\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n// from??????to????????????????????????cap???0??¨?????????\nvoid del_edge(int from, int to) {\n\tint rev = INT_MIN;\n\tfor (auto i = G[from].begin(); i < G[from].end(); i++)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\trev = (*i).rev;\n\t\t\t(*i).cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rev != INT_MIN)\n\t{\n\t\tG[to][rev].cap = 0;\n\t}\n\t/*\n\tfor (auto i = G[to].begin(); i < G[to].end(); i++)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*/\n}\n\nint main() {\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor (size_t i = 0; i < E; i++)\n\t{\n\t\tint F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge(F, T);\n\t}\n\tfor (size_t i = 0; i < Q; i++)\n\t{\n\t\tint M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif (M == 1)\n\t\t{\n\t\t\tadd_edge(A, B);\n\t\t}\n\t\telse {\n\t\t\tdel_edge(A, B);\n\t\t}\n\t\tauto G_ = G;\n\t\tcout << max_flow(0, N - 1) << endl;\n\t\tG = G_;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint V,E;\nint G[501][501]; // ??°???????????£??\\???????????¨???\nvector<int> used; // DFS??§?????§???????????????????????°\n\n// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n    G[from][to] = G[to][from] = cap;\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < V; i++) {\n        auto &cap = G[v][i];\n        if (!used[i] && cap > 0) {\n            int d = dfs(i, t, min(f, cap));\n            if (d > 0) {\n                cap -= d;\n                G[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> V >> E;\n    int Q; cin >> Q;\n    for(int i = 0; i < 501;i++){\n        for(int j = 0;j < 501;j++){\n            G[i][j] = 0;\n        }\n    }\n    used.resize(V);\n    for (int i = 0; i < E;i++) {\n        int s, t; cin >> s >> t;\n        s--;t--;\n        add_edge(s, t, 1);\n    }\n    \n    int f = max_flow(0, V - 1);\n    //cout << endl;\n    //cout << \"===================\" << endl;\n    //for(int i = 0;i < V;i++){\n    //    for(int j = 0; j < V;j++){\n    //        if(G[i][j] == 0)continue;\n    //        cout << \"[\" << i << \"=>\" <<j<<\" : \" << G[i][j] << \"] \";\n    //    }\n    //    cout << endl;\n    //}\n    for(int i = 0; i < Q;i++){\n        int M,A,B; cin >> M >> A >> B;\n        A--;B--;\n        if(M == 1){\n            G[A][B] = G[B][A] = 1;\n            fill(used.begin(),used.end(),0);\n            f += dfs(0,V-1,INF);\n        }else{\n            if(G[A][B] == 0 || G[B][A] == 0){\n                int u,v;\n                if(G[A][B] == 0){ u = A; v = B;}\n                else{u = B; v = A;}\n                if(dfs(u,v,INF) == 0){\n                    fill(used.begin(),used.end(),0);\n                    dfs(u,0,INF);\n                    fill(used.begin(),used.end(),0);\n                    dfs(V-1,v,INF);\n                    f--;\n                    dfs(0,V-1,INF);\n                }\n            }\n            G[A][B] = G[B][A] = 0;\n        }\n        cout << f << endl;\n        //cout << \"===================\" << endl;\n        //for(int i = 0;i < V;i++){\n        //    for(int j = 0; j < V;j++){\n        //        if(G[i][j] == 0)continue;\n        //        cout << \"[\" << i << \"=>\" <<j<<\" : \" << G[i][j] << \"] \";\n        //    }\n        //    cout << endl;\n        //}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(ok[s][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t\tok[s][i] = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = used[i][j] != used[j][i];\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define crear_vec(v,n) v.clear();v.resize(n);\n#define delete_vec(v,n) v.erase(remove(v.begin(),v.end(),n),v.end());\ntypedef pair<int,int> pii;\nint N,E,Q;\nvector<vector<pii> > edge;\nint f;\nvoid flow(int from,int to){\n  for(int i=0;i<edge[from].size();i++){\n    if(edge[from][i].first==to)edge[from][i].second++;\n  }\n  for(int j=0;j<edge[to].size();j++){\n    if(edge[to][j].first == from)edge[to][j].second--;\n  }\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    if(used[edge[from][i].first]==1)continue;\n    if(edge[from][i].second<1&&dfs_(edge[from][i].first,to)==1){\n      flow(from,edge[from][i].first);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  crear_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(pii(b,0));\n  edge[b].push_back(pii(a,0));\n  while(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff;\n  for(int i=0;i<edge[a].size();i++){\n    if(edge[a][i].first==b){\n      ff=edge[a][i].second;\n      delete_vec(edge[a],edge[a][i]);\n      break;\n    }\n  }\n  for(int i=0;i<edge[b].size();i++){\n    if(edge[b][i].first==a){\n      delete_vec(edge[b],edge[b][i]);\n      break;\n    }\n  }\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(dfs(N,b)&&dfs(a,1))f--;\n  }\n  while(dfs(1,N))f++;\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  crear_vec(edge,N+1);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  while(dfs(1,N));\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  if(m==1){\n    add_edge(a,b);\n  }else if(m==2){\n    cut_edge(a,b);\n  }\n  return f;\n}\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    //*/\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool dfs(int v, int t, vector<vector<int>> &mat, vector<bool> &used) {\n\tif(v == t) return true;\n\n\tused[v] = true;\n\tconst int n = mat.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(mat[v][i] > 0 && !used[i] && dfs(i, t, mat, used)) {\n\t\t\t--mat[v][i];\n\t\t\t++mat[i][v];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rdfs(int v, int t, vector<vector<int>> &mat, vector<bool> &used) {\n\tif(v == t) return true;\n\n\tused[v] = true;\n\tconst int n = mat.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(mat[v][i] == 2 && !used[i] && rdfs(i, t, mat, used)) {\n\t\t\t--mat[v][i];\n\t\t\t++mat[i][v];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tvector<vector<int>> mat(n, vector<int>(n, 0));\n\twhile(m--) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tmat[a][b] = mat[b][a] = 1;\n\t}\n\n\tconst int s = 0;\n\tconst int t = n - 1;\n\n\tint flow = 0;\n\tvector<bool> used(n, false);\n\twhile(dfs(s, t, mat, used)) {\n\t\t++flow;\n\t\tfill(used.begin(), used.end(), false);\n\t}\n\n\twhile(q--) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\t--a; --b;\n\n\t\tif(m == 1) { // connect\n\t\t\tmat[a][b] = mat[b][a] = 1;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tflow += dfs(s, t, mat, used);\n\t\t}\n\t\telse { // cut\n\t\t\tif(mat[a][b] != 1) {\n\t\t\t\t--flow;\n\t\t\t\tif(mat[b][a] == 0) swap(a, b);\n\t\t\t\tmat[b][a] = 0;\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\trdfs(a, s, mat, used);\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\trdfs(t, b, mat, used);\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tflow += dfs(s, t, mat, used);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmat[a][b] = mat[b][a] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow << \"\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Dinic\n{\n  const int INF = 1 << 30;\n \n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter, used;\n  int flow;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front(); que.pop();\n      for(const edge& e : graph[p]) {\n        if(!e.alive) continue;\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return(min_cost[t] != -1);\n  }\n   \n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    for(int i = iter[idx]; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      int f = 0;\n      while((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    bool flag = false;\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to) == 0) {\n            max_flow(graph.size() - 1, 0);\n            max_flow(from, to);\n            flag = true;\n          }\n        } else if(re.cap == 0) {\n          if(max_flow(to, from) == 0) {\n            max_flow(graph.size() - 1, 0);\n            max_flow(to, from);\n            flag = true;\n          }\n        }\n        e.rev = re.rev = false;\n        return(flag);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n    }\n    flow += graph.max_flow(0, N - 1);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nconstexpr int INF = 1 << 30;\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    vector<map<int, int>> c(N);\n    auto addEdge = [&](const int u, const int v) -> void { c[u][v] = c[v][u] = 1; };\n    auto cutEdge = [&](const int u, const int v) -> void { c[u].erase(v), c[v].erase(u); };\n    auto flow = [&](const int s, const int t, const int limit) {\n        vector<bool> used(N, false);\n        auto dfs = fix([&](auto&& self, const int s, const int t, const int f) -> int {\n            if (s == t) { return f; }\n            used[s] = true;\n            for (auto& e : c[s]) {\n                if (used[e.first] or e.second == 0) { continue; }\n                const int res = min(f, e.second);\n                const int d = self(self, e.first, t, res);\n                if (d == 0) { continue; }\n                return e.second -= d, c[e.first][s] += d, d;\n            }\n            return 0;\n        });\n        for (int flow = 0; flow < limit;) {\n            fill(used.begin(), used.end(), false);\n            const int f = dfs(s, t, limit - flow);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n        return limit;\n    };\n    for (int i = 0, F, T; i < E; i++) {\n        cin >> F >> T;\n        addEdge(F - 1, T - 1);\n    }\n    int ans = flow(0, N - 1, INF);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (M == 1) {\n            addEdge(A, B);\n        } else {\n            const int cap = c[A][B];\n            cutEdge(A, B);\n            if (cap == 2) { swap(A, B); }\n            if (cap != 1 and flow(A, B, 1) == 0) { ans--, flow(A, 0, 1), flow(N - 1, B, 1); }\n        }\n        cout << (ans += flow(0, N - 1, 1)) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n\n            //(1) S <- s <- t <- T の最大パスを求める\n            // e.cap = 0;reve.cap = 0;\n            // Flow fs = max_flow(s,S,d);\n            // Flow ft = max_flow(T,t,d);\n            // Flow f = min(fs,ft);\n            // //(1).1 流しすぎた分戻す\n            // max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\n            Flow f = max_flow(T,S,d);\n            flow -= f;\n\n            //(2) 残り(d-f)は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n            e.cap = 0;reve.cap=c + reve.icap;\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t}\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,0,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f,bool back=false){\n\tif(v==t)\n\t\treturn f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// Ü¾ØçêÄ¢È¢©ÂgíêÄ¢È¢m[hÖÌJÚ\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\tbool ok=false;\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]&&!back){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\t// eÊðfromÌûüÉ½­í¦é\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t// ¡ñÏXðsÁ½\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\t// eÊª0æèå«¢Æ«\n\t\t\tif(e.cap>0&&isDirected[e.id]){\n\t\t\t\tint d=dfs(e.to,t,min(f,e.cap),back);\n\t\t\t\t// 1Ìt[ª¬¹½ê\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]==e.to)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t// dÌflowð¬·\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// t[ª¬¹È¢ÈçA¡ñèµ½ûüð³ø\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tif(j==806){\n\t\t//\tcout<<endl;\n\t\t}\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1,true);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1,true);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1,true);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1,true);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define crear_vec(v,n) v.clear();v.resize(n);\n#define delete_vec(v,n) v.erase(remove(v.begin(),v.end(),n),v.end());\ntypedef pair<int,int> pii;\nint N,E,Q;\nvector<vector<pii> > edge;\nint f;\nvoid flow(int from,int to){\n  for(int i=0;i<edge[from].size();i++){\n    if(edge[from][i].first==to)edge[from][i].second++;\n  }\n  for(int j=0;j<edge[to].size();j++){\n    if(edge[to][j].first == from)edge[to][j].second--;\n  }\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    if(used[edge[from][i].first]==1)continue;\n    if(edge[from][i].second>=1)continue;\n    if(dfs_(edge[from][i].first,to)==1){\n      flow(from,edge[from][i].first);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  crear_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(pii(b,0));\n  edge[b].push_back(pii(a,0));\n  while(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff;\n  for(int i=0;i<edge[a].size();i++){\n    if(edge[a][i].first==b){\n      ff=edge[a][i].second;\n      delete_vec(edge[a],edge[a][i]);\n      break;\n    }\n  }\n  for(int i=0;i<edge[b].size();i++){\n    if(edge[b][i].first==a){\n      delete_vec(edge[b],edge[b][i]);\n      break;\n    }\n  }\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(N,b))cerr<<\"err\"<<endl;\n    if(!dfs(a,1))cerr<<\"err\"<<endl;\n    f--;\n  }\n  while(dfs(1,N))f++;\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  crear_vec(edge,N+1);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  while(dfs(1,N));\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  if(m==1){\n    add_edge(a,b);\n  }else if(m==2){\n    cut_edge(a,b);\n  }\n  return f;\n}\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    */\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=int;\n\nstruct Edge{\n    int from,to;\n    Weight cap;\n    bool rev;\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs){\n    if(lhs.from!=rhs.from) return lhs.from<rhs.from;\n    if(lhs.to!=rhs.to) return lhs.to<rhs.to;\n    if(lhs.cap!=rhs.cap) return lhs.cap<rhs.cap;\n    return lhs.rev<rhs.rev;\n}\nusing Edges=multiset<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    Graph g;\n    Weight nowF=0;\n    const Weight INF=1e9;\n    Weight dfs(int v,int t,stack<int>& st,vector<int> &used,bool mustrev){\n        if(used[v]) return 0;\n        if(v==t) return INF;\n        used[v]=true;\n        for(auto &e:g[v]){\n            if(e.cap==0) continue;\n            if(mustrev && !e.rev) continue;\n            Weight f=dfs(e.to,t,st,used,mustrev);\n            if(f>0){\n                st.push(v);\n                return min(f,e.cap);\n            }   \n        }\n        return 0;\n    }\n    Edges::iterator rettf(int fr,int to,int cap,Edges &edges){\n        auto res=edges.find(Edge{fr,to,cap,true});\n        if(res==edges.end()) res=edges.find(Edge{fr,to,cap,false});\n        return res;\n    }\n    public:\n    Flow(int n):g(n){}\n    void addEdge(int from,int to,Weight cap){\n        g[from].insert(Edge{from,to,cap,false});\n        g[to].insert(Edge{to,from,0,true});\n    }\n    Weight maxFlow(int s,int t){\n        Weight res=0;\n        Weight f;\n        vector<int> used(g.size(),false);\n        stack<int> st;\n        while(f=dfs(s,t,st,used,false)){\n            res+=f;\n            while(!st.empty()){\n                int fr=st.top(); st.pop();\n                int to=(st.empty() ? t : st.top());\n                auto it0=rettf(fr,to,1,g[fr]);\n                auto it1=g[to].find(Edge{to,fr,0,!(it0->rev)});\n                assert(it0!=g[fr].end() && it1!=g[to].end());\n                g[fr].insert(Edge{fr,to,0,it0->rev});\n                g[fr].erase(it0);\n                g[to].insert(Edge{to,fr,1,it1->rev});\n                g[to].erase(it1);\n            }\n            fill(used.begin(),used.end(),false);\n        }\n        return nowF=nowF+res;\n    }\n\n    void decEdge(int fr,int to,int s,int t){\n        if(g[fr].find(Edge{fr,to,0,false})==g[fr].end()){\n            g[fr].erase(Edge{fr,to,1,false});\n            g[to].erase(Edge{to,fr,0,true});\n            return;\n        }\n        g[fr].erase(g[fr].find(Edge{fr,to,0,false}));        \n        g[to].erase(g[to].find(Edge{to,fr,1,true}));\n        \n        vector<int> used(g.size(),false);\n        stack<int> st;\n        int f0=dfs(fr,s,st,used,true);\n        assert(f0>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? s : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        \n        fill(used.begin(),used.end(),0);\n        int f1=dfs(t,to,st,used,true);        \n        assert(f1>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? to : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            assert(it0!=g[frr].end());\n            assert(it1!=g[too].end());\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        nowF--;\n    } \n    \n};\n\nint main(){\n    int n,e,q;\n    cin>>n>>e>>q;\n    Flow flow(n);\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        f--,t--;\n        flow.addEdge(f,t,1);\n        flow.addEdge(t,f,1);\n    }\n    for(int i=0;i<q;i++){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            flow.addEdge(a,b,1);\n            flow.addEdge(b,a,1);\n        }\n        if(m==2){\n            flow.decEdge(a,b,0,n-1);\n            flow.decEdge(b,a,0,n-1);\n        }\n        cout<<flow.maxFlow(0,n-1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t}\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,0,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f,bool back=false){\n\tif(v==t)\n\t\treturn f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// Ü¾ØçêÄ¢È¢©ÂgíêÄ¢È¢m[hÖÌJÚ\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\tbool ok=false;\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]&&!back){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\t// eÊðfromÌûüÉ½­í¦é\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t// ¡ñÏXðsÁ½\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\t// eÊª0æèå«¢Æ«\n\t\t\tif(e.cap>0&&isDirected[e.id]){\n\t\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\t// 1Ìt[ª¬¹½ê\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]==e.to)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t// dÌflowð¬·\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// t[ª¬¹È¢ÈçA¡ñèµ½ûüð³ø\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1,true);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1,true);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1,true);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1,true);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T> struct Edge{\n\tint v,rev;\n\tT capa,flow;\n};\n\ntemplate<class T>\nstruct AdjList:public vector< vector< Edge<T> > >{\n\tAdjList(int n):vector< vector< Edge<T> > >(n){}\n};\n\ntemplate<class T>\nvoid add_edge(AdjList<T> &adj,int u,int v,T capa){\n\tadj[u].push_back((Edge<T>){v,adj[v].size()  ,capa,0});\n\tadj[v].push_back((Edge<T>){u,adj[u].size()-1,capa,0});\n}\n\ntemplate<class T>\nT augment(AdjList<T> &adj,int s,int t){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<bool> vis(n); vis[s]=true;\n\n\tqueue< pair<int,T> > qu;\n\tqu.push(make_pair(s,INF));\n\n\tT res=0;\n\twhile(!qu.empty()){\n\t\tint u=qu.front().first;\n\t\tT water=qu.front().second;\n\t\tqu.pop();\n\n\t\tif(u==t){ res=water; break; }\n\n\t\trep(i,adj[u].size()){\n\t\t\tEdge<T> &e=adj[u][i];\n\t\t\tif(!vis[e.v] && e.capa-e.flow>0){\n\t\t\t\tvis[e.v]=true;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\tqu.push(make_pair(e.v,min(water,e.capa-e.flow)));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(res>0){\n\t\tfor(int v=t;v!=s;){\n\t\t\tEdge<T> &e1=adj[v][pre[v]];\n\t\t\tEdge<T> &e2=adj[e1.v][e1.rev];\n\t\t\te1.flow-=res;\n\t\t\te2.flow+=res;\n\t\t\tv=e1.v;\n\t\t}\n\t}\n\n\treturn res;\n}\n\ntemplate<class T>\nT Edmonds_Karp(AdjList<T> &adj,int s,int t){\n\tT ans=0;\n\tfor(T water=1;water>0;ans+=water) water=augment(adj,s,t);\n\treturn ans;\n}\n\nbool vis[500];\nbool dfs(int u,AdjList<int> &adj){\n\tint n=adj.size();\n\tvis[u]=true;\n\tif(u==0 || u==n-1) return true;\n\trep(i,adj[u].size()){\n\t\tEdge<int> &e=adj[u][i];\n\t\tif(!vis[e.v] && e.flow!=0 && dfs(e.v,adj)){\n\t\t\te.flow=0;\n\t\t\tadj[e.v][e.rev].flow=0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\tAdjList<int> adj(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tadd_edge(adj,u,v,1);\n\t}\n\n\tint ans=Edmonds_Karp(adj,0,n-1);\n\n\twhile(q--){\n\t\tint type,u,v; scanf(\"%d%d%d\",&type,&u,&v); u--; v--;\n\t\tif(type==1){ // add\n\t\t\tadd_edge(adj,u,v,1);\n\t\t}\n\t\telse{ // erase\n\t\t\tint i,i_rev;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v) break;\n\t\t\ti_rev=adj[u][i].rev;\n\t\t\tif(adj[u][i].flow!=0){\n\t\t\t\t// ツフツδ債ーツづーツ可淞つオツ姪淞つキ\n\t\t\t\trep(k,2){\n\t\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\t\tdfs(u,adj);\n\t\t\t\t}\n\t\t\t\tans--;\n\t\t\t}\n\t\t\tadj[u][i].capa=adj[v][i_rev].capa=0;\n\t\t}\n\t\tans+=Edmonds_Karp(adj,0,n-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint cap[500][500];\n\nint maximumFlow(int n, int s, int t, bool first = false){\n\tint res = 0;\n\tint prev[500];\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tmemset(prev, -1, sizeof(prev)); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j]--, cap[j][prev[j]]++;\n\t\tres++;\n\t\tif(!first) return res;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1, true);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\tint s = A-1, t = B-1;\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(cap[t][s] == 2){\n\t\t\t\t\t\tcap[t][s] = 0;\n\t\t\t\t\t\tint tmp = maximumFlow(N, s, t); \n\t\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\t\tmaximumFlow(N, s, 0);\n\t\t\t\t\t\t\tmaximumFlow(N, N-1, t);\n\t\t\t\t\t\t\tcur--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswap(s, t);\n\t\t\t\t}\n\t\t\t\tcap[s][t] = cap[t][s] = 0;\n\t\t\t}\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\n//?????¬\n\n#define MAX_V 20001\n#define INF INT_MAX/6\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G(MAX_V); // ??°???????????£??\\???????????¨???\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\n // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n\tbool f = true;\n\tfor (auto i = G[from].begin(); i < G[from].end();)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\t(*i).cap = 1;\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tG[from].push_back({ to, cap, (int)G[to].size() });\n\t}\n\tf = true;\n\tfor (auto i = G[to].begin(); i < G[to].end();)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 1;\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (f) {\n\t\tG[to].push_back({ from, cap, (int)G[from].size() - 1 });\n\t}\n}\n\n// from??????to????????????????????????cap???0??¨?????????\nvoid del_edge(int from, int to) {\n\tfor (auto i = G[from].begin(); i < G[from].end();i++)\n\t{\n\t\tif ((*i).to == to)\n\t\t{\n\t\t\t(*i).cap = 0;\n\t\t}\n\t}\n\tfor (auto i = G[to].begin(); i < G[to].end();i++)\n\t{\n\t\tif ((*i).to == from)\n\t\t{\n\t\t\t(*i).cap = 0;\n\t\t}\n\t}\n}\n\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor (size_t i = 0; i < E; i++)\n\t{\n\t\tint F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge(F, T, 1);\n\t}\n\tfor (size_t i = 0; i < Q; i++)\n\t{\n\t\tint M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif (M == 1)\n\t\t{\n\t\t\tadd_edge(A, B, 1);\n\t\t}\n\t\telse {\n\t\t\tdel_edge(A, B);\n\t\t}\n\t\tauto G_ = G;\n\t\tcout << max_flow(0, N - 1) << endl;\n\t\tG = G_;\n\t\t/*\n\t\tfor (size_t j = 0; j < N; j++)\n\t\t{\n\t\t\tfor (auto x : G[j]) {\n\t\t\t\tcout << j << \" \" << x.to << \" \" << x.cap << \" \" << x.rev << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef int flow_t;\n\nconst int MAX_N = 500;\nconst int MAX_E = 20000;\nconst int MAX_Q = 1000;\n\nstruct edge{\n\tint tar;\n\tflow_t cap;\n\tbool on;\n};\n\nstruct query{\n\tint cmd;\n\tint x, y;\n};\n\nint V, E, Q;\nvector<edge> graph[MAX_N];\nint id_table[MAX_N][MAX_N];\nquery qs[MAX_Q];\n\nvoid add_edge(int x, int y, flow_t cap, bool on){\n\tid_table[x][y] = graph[x].size();\n\tid_table[y][x] = graph[y].size();\n\tgraph[x].push_back((edge){y, cap, on});\n\tgraph[y].push_back((edge){x, cap, on});\n}\n\nvoid init(){\n\tscanf(\"%d%d%d\", &V, &E, &Q);\n\tmemset(id_table, -1, sizeof(id_table));\n\tfor(int i=0; i<E; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--; y--;\n\t\tadd_edge(x, y, 1, true);\n\t}\n\n\tfor(int i=0; i<Q; i++){\n\t\tint c, x, y;\n\t\tscanf(\"%d%d%d\", &c, &x, &y);\n\t\tx--; y--;\n\t\tqs[i] = (query){c, x, y};\n\t\tif(id_table[x][y] == -1){\n\t\t\tadd_edge(x, y, 0, false);\n\t\t}\n\t}\n\n}\n\nbool visited[MAX_N];\nint vis_time[MAX_N];\n\nbool dfs(int v, int sink){\n\tif(v == sink){\n\t\treturn true;\n\t}\n\tvisited[v] = true;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0 && !visited[e.tar] && dfs(e.tar, sink)){\n\t\t\te.cap--;\n\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool rem_dfs(int v){\n\tvis_time[v] = 2;\n\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\tedge& e = graph[v][i];\n\t\tif(e.on && e.cap > 0){\n\t\t\tif(vis_time[e.tar] == 1 || (vis_time[e.tar] == 0 && rem_dfs(e.tar))){\n\t\t\t\te.cap--;\n\t\t\t\tgraph[e.tar][id_table[e.tar][v]].cap++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool remove_cycle(int x, int y){\n\tmemset(vis_time, 0, sizeof(vis_time));\n\tvis_time[y] = 1;\n\treturn rem_dfs(x);\n}\n\nvoid solve(){\n\tconst int source = 0, sink = V - 1;\n\tflow_t current = 0;\n\n\tfor(;memset(visited, false, sizeof(visited)), dfs(source, sink); current++);\n\n\tfor(int i=0; i<Q; i++){\n\t\tif(qs[i].cmd == 1){\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tgraph[x][id_table[x][y]].on = true;\n\t\t\tgraph[y][id_table[y][x]].on = true;\n\t\t\tgraph[x][id_table[x][y]].cap = 1;\n\t\t\tgraph[y][id_table[y][x]].cap = 1;\n\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\tif(dfs(source, sink)){\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x = qs[i].x, y = qs[i].y;\n\t\t\tif(graph[x][id_table[x][y]].cap != 1){\n\n\t\t\t\t// ツ個サツ催敖づ郊 -> yツづ猟ャツづェツづつ「ツづゥツづヲツつ、ツづ可暗ェツ氾環可サ\n\t\t\t\tif(graph[x][id_table[x][y]].cap == 2){\n\t\t\t\t\tswap(x, y);\n\t\t\t\t}\n\t\t\t\tif(!remove_cycle(x, y)){\n\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\tdfs(sink, source);\n\t\t\t\t\tcurrent--;\n\t\t\t\t\tint cur = graph[x][id_table[x][y]].cap;\n\t\t\t\t\tif(cur != 1){\n\t\t\t\t\t\tif(cur == 2){\n\t\t\t\t\t\t\tswap(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremove_cycle(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgraph[x][id_table[x][y]].on = false;\n\t\t\t\tgraph[y][id_table[y][x]].on = false;\n\t\t\t\tgraph[x][id_table[x][y]].cap = 0;\n\t\t\t\tgraph[y][id_table[y][x]].cap = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", current);\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cap, rev;\n  Edge(int u, int v, int c, int r) :\n    src(u), dst(v), cap(c), rev(r) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nbool used[500];\nbool used2[500][2];\nint dfs(int u, int t, int f){\n  if(u == t) return f;\n  used[u] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0 && !used[e->dst]){\n      int d = dfs(e->dst, t, min(f, e->cap));\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint dfs2(int u, int t, int f, int b, int A, int B){\n  if(u == t){\n    if(b == 1) return f;\n    else return 0;\n  }\n  used2[u][b] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0){\n      int nb = b;\n      if(e->src == A && e->dst == B) nb = 1;\n      if(used2[e->dst][nb]) continue;\n      int d = dfs2(e->dst, t, min(f, e->cap), nb, A, B);\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nvoid max_flow(int &flow, int S, int T){\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(S, T, INF);\n    if(f == 0) return;\n    flow += f;\n  }\n}\nvoid add_edge(int u, int v){\n  G[u].push_back(Edge(u, v, 1, G[v].size()));\n  G[v].push_back(Edge(v, u, 1, G[u].size() - 1));\n}\n\nint main(){\n  int N, E, Q;\n  while(cin >> N >> E >> Q){\n    G = Graph(N);\n    REP(i, E){\n      int A, B;\n      cin >> A >> B;\n      A--; B--;\n      add_edge(A, B);\n    }\n    int S = 0, T = N - 1;\n    int flow = 0;\n    max_flow(flow, S, T);\n    REP(i, Q){\n      int M, A, B;\n      cin >> M >> A >> B;\n      A--; B--;\n      if(M == 1){\n        add_edge(A, B);\n        max_flow(flow, S, T);\n      }else{\n        FORIT(e, G[A])if(e->dst == B && e->cap == 2){\n          // B -> A : now \n          //printf(\"find %d -> %d flow\\n\", B, A);\n          memset(used2, 0, sizeof(used2));\n          int d = dfs2(T, S, 1, 0, A, B);\n          if(d != 1){\n            cerr << d << endl;\n            assert(false);\n          }\n          flow--;\n          goto ERASE;\n        }\n        FORIT(e, G[B])if(e->dst == A && e->cap == 2){\n          //printf(\"find %d -> %d flow\\n\", A, B);\n          memset(used2, 0, sizeof(used2));\n          int d = dfs2(T, S, 1, 0, B, A);\n          if(d != 1){\n            cerr << d << endl;\n            assert(false);\n          }\n          flow--;\n          goto ERASE;\n        }\n        ERASE:\n          FORIT(e, G[A]) if(e->dst == B) { G[A].erase(e); break; }\n          FORIT(e, G[B]) if(e->dst == A) { G[B].erase(e); break; }\n          max_flow(flow, S, T);\n      }\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=200000;\n\nstruct edge{\n\tint to,cap,rev,id;\n\tint flow;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t\tflow=0;\n\t}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,cap,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// ØfÏÝ\n\t\tif(!isUsable[e.id])continue;\n\t\t// Ü¾t[ð¬¹éÈçÎA¬·\n\t\tif(!used[e.to]&&e.flow<e.cap){\n\t\t\t// ¡ñÌ¬Ê\n\t\t\tint quan=e.cap-e.flow;\n\t\t\tif(e.flow<0)quan=-(e.flow);\n\t\t\tint d=dfs(e.to,t,min(f,quan));\n\t\t\tif(d>0){\n\t\t\t\te.flow+=d;\n\t\t\t\t// ½ÎÉÍ}CiXÌvfðüêÄ¨­\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}// ¸­pXðTõ\nint dfs2(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!isUsable[e.id])continue;\n\t\t// 0æè¬³¯êÎAß·\n\t\tif(!used[e.to]&&e.flow<0){\n\t\t\tint d=dfs(e.to,t,min(f,-(e.flow)));\n\t\t\tif(d>0){\n\t\t\t\te.flow=0;\n\t\t\t\tG[e.to][e.rev].flow=0;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\telse flow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,ee,q;\n\tcin>>n>>ee>>q;\n\tfor(int i=0;i<ee;i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,ee);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=ee;\n\t\t\tisUsable[ee]=true;\n\t\t\tee++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\tfor(int i=0;i<(int)G[a].size();i++){\n\t\t\t\tedge &e=G[a][i];\n\t\t\t\tif(eidx==e.id){\n\t\t\t\t\t// ¬êÄ¢È¢\n\t\t\t\t\tif(e.flow==0) isUsable[eidx]=false;\n\t\t\t\t\t// ¬êÄ¢éê\n\t\t\t\t\telse{\n\t\t\t\t\t\tint from=a;\n\t\t\t\t\t\tint to=b;\n\t\t\t\t\t\tif(e.flow>0) swap(from,to);\n\t\t\t\t\t\t// flowð0Éú»\n\t\t\t\t\t\te.flow=G[e.to][e.rev].flow=0;\n\t\t\t\t\t\t// ûüÉµ½ªÁÄtü«Éflowð¬·\n\t\t\t\t\t\t//dfs2(from,to,1);\n\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(n,from,1);\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(to,1,1);\n\t\t\t\t\t\t// Øf\n\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntypedef int Weight;\nconst Weight INF=99999999;\nstruct Edge{\n\tint src,dst;\n\tWeight weight;\n\tint rev;\n\tEdge(int f, int t, Weight c,int rev=0):src(f),dst(t),weight(c),rev(rev){}\n};\ntypedef vector< vector<Edge> > Graph;\n\npii add_edge(Graph &G,int s,int t,Weight cap){\n\tG[s].push_back(Edge(s,t,cap,G[t].size()));\n\tG[t].push_back(Edge(t,s,cap,G[s].size()-1));\n\treturn pii(G[s].size()-1, G[t].size()-1);\n}\n\n\nvoid bfs(const Graph &G,vector<int> &level,int s){\n\tlevel[s]=0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();que.pop();\n\t\tREP(i,G[v].size()){\n\t\t\tconst Edge &e=G[v][i];\n\t\t\tif(e.weight>0 && level[e.dst] < 0){\n\t\t\t\tlevel[e.dst] = level[v] +1;\n\t\t\t\tque.push(e.dst);\n\t\t\t}\n\t\t}\n\t}\n}\nWeight dfs(Graph &G,vector<int> &level,vector<int> &iter,int v,int t,Weight flow){\n\tif(v==t)return flow;\n\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\tEdge &e=G[v][i];\n\t\tif(e.weight>0&&level[v]<level[e.dst]){\n\t\t\tWeight d=dfs(G,level,iter,e.dst,t,min(flow,e.weight));\n\t\t\tif(d>0){\n\t\t\t\te.weight-=d;\n\t\t\t\tG[e.dst][e.rev].weight+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\nreturn 0;\n}\n\n// Dinic\n// O(EV^2)\nWeight max_flow(Graph &G,int s,int t,int ff=0){\n\tWeight flow = 0;\n\twhile(true){\n\t\tvector<int> level(G.size(),-1);\n\t\tvector<int> iter(G.size(),0);\n\t\tbfs(G,level,s);\n\t\tif(level[t]<0)break; // もう流せない\n\t\tif(ff){\n\t\t\treturn dfs(G,level,iter,s,t,1);\n\t\t}\n\t\tWeight f=0;\n\t\twhile((f=dfs(G,level,iter,s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\nint N, E, Q;\nint idx[501][501];\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tmemset(idx, -1, sizeof(idx));\n\tGraph g(N);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tif(idx[u][v] < 0){\n\t\t\tpii res = add_edge(g, u, v, 0);\n\t\t\tidx[u][v] = res.first;\n\t\t\tidx[v][u] = res.second;\n\t\t}\n\t\tg[u][idx[u][v]].weight ++;\n\t\tg[v][idx[v][u]].weight ++;\n\t}\n\tint cur = 0;\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v;u--;v--;\n\t\tif(idx[u][v] < 0){\n\t\t\tpii res = add_edge(g, u, v, 0);\n\t\t\tidx[u][v] = res.first;\n\t\t\tidx[v][u] = res.second;\n\t\t}\n\t\tif(f == 1){\n\t\t\tg[u][idx[u][v]].weight ++;\n\t\t\tg[v][idx[v][u]].weight ++;\n\t\t}else{\n\t\t\tif(g[u][idx[u][v]].weight == 2) swap(u, v);\n\t\t\tif(g[u][idx[u][v]].weight == 0){\n\t\t\t\tcur -= max_flow(g, N-1, 0, 1);\n\t\t\t\tif(g[u][idx[u][v]].weight != 1){\n\t\t\t\t\tmax_flow(g, u, v, 1);\n\t\t\t\t\tmax_flow(g, v, u, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[u][idx[u][v]].weight --;\n\t\t\tg[v][idx[v][u]].weight --;\n\t\t}\n\t\tcout << (cur += max_flow(g, 0, N-1)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        add_edge(s,t,1);\n        add_edge(t,s,1);\n    }\n    rep(i,q){\n        int x, s, t;\n        cin >> x >> s >> t;\n        s--; t--;\n        if(x == 1){\n            add_edge(s,t,1);\n            add_edge(t,s,1);\n        } else{\n            vector<edge> tmp1;\n            rep(j,G[s].size()){\n                if(G[s][j].to != t) tmp1.push_back(G[s][j]);\n            }\n            G[s] = tmp1;\n            tmp1.clear();\n            rep(j,G[t].size()){\n                if(G[t][j].to != s) tmp1.push_back(G[t][j]);\n            }\n            G[t] = tmp1;\n        }\n        rep(j,n) H[j] = G[j];\n        cout << max_flow(0,n-1) << endl;\n        rep(j,n) G[j] = H[j];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tvector<vector<int>> edge;\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v * 2), edge(v + 2, vector<int>(v + 2)) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b, int f = 1){\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\n\t\t\tab.cap += f;\n\t\t\trab.cap += f;\n\t\t\tassert(ab.cap == 1);\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){\n\t\t\tif(G[a][G[b][edge[b][a]].rev].cap >= 1) swap(a,b);\n\n\t\t\tauto& ab = G[a][edge[a][b]];\n\t\t\tauto& rab = G[b][ab.rev];\n\t\t\tauto& ba = G[b][edge[b][a]];\n\t\t\tauto& rba = G[a][ba.rev];\n\n\t\t\tif(ab.cap >= 1){\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tab.cap = ba.cap = 0;\n\t\t\t\trab.cap = rba.cap = 0;\n\n\t\t\t\tif(fordFulkerson(a, b, 1)){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tfordFulkerson(a, s, 1);\n\t\t\t\tfordFulkerson(t, b, 1);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tint com, a, b;\n\t\tcin >> com >> a >> b;\n\t\ta--; b--;\n\n\t\tif(com == 1){\n\t\t\tif(use[a][b]){\n\t\t\t\tans += flow.addCapacity(s, t, a, b);\n\t\t\t}else{\n\t\t\t\tuse[a][b] = use[b][a] = true;\n\t\t\t\tflow.addEdge(a, b, 1);\n\t\t\t\tflow.addEdge(b, a, 1);\n\t\t\t\tans += flow.fordFulkerson(s, t);\n\t\t\t}\n\t\t}else{\n\n\t\t\tans += flow.subCapacity(s, t, a, b);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct FordFulkerson{\n  int n;\n  vector< vector<edge> > graph;\n  vi use;\n\n  FordFulkerson(int a=0):n(a){\n    graph.resize(a); use.resize(a);\n  }\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g && graph[s][e].cost>0){\n\tid = e; rev = graph[s][e].rev;\n      }\n    }\n    if(id<0)return;\n    //cout << id << \" \" << rev << endl;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n\n    edge e = graph[s][id];\n    //cout << s << \" \" << e.to << \" \" << e.rev << endl;\n    if(id+1!=(int)graph[s].size())graph[e.to][e.rev].rev = id;\n    e = graph[g][rev];\n    //cout << g << \" \" << e.to << \" \" << e.rev << endl;\n    if(rev+1!=(int)graph[g].size())graph[e.to][e.rev].rev = rev;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    use[v] = 1;\n    rep(i,graph[v].sz){\n      edge &e = graph[v][i];\n      if(!use[e.to] && e.cap > 0){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      rep(i,n)use[i] = 0;\n      int f = dfs(s,t,INF);\n      if(!f)return res;\n      res += f;\n    }\n  }\n};\n\nint main(){\n  int n,E,q;\n  cin >> n >> E >> q;\n  FordFulkerson mf(n);\n  rep(i,E){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    mf.AddEdge(f,t,1,1);\n    mf.AddEdge(t,f,1,1);\n  }\n\n  int F = mf.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      mf.AddEdge(a,b,1,1);\n      mf.AddEdge(b,a,1,1);\n      F += mf.max_flow(0,n-1);\n    }else{\n      int use = 0;\n      for(edge e : mf.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap == 0)use |= 1;\n      }\n      for(edge e : mf.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap == 0)use |= 2;\n      }\n      //cout << \"use: \" << use << endl;\n      mf.DeleteEdge(a,b);\n      mf.DeleteEdge(b,a);\n\n      if(use==1 || use==2){\n\trep(i,n)mf.use[i] = 0;\n\tint another = 0;\n\tif(use==1)another = mf.dfs(a,b,1);\n\tif(use==2)another = mf.dfs(b,a,1);\n\n\tif(!another){\n\t  rep(i,n)mf.use[i] = 0;\n\t  mf.dfs(use==1?a:b,0,1);\n\t  rep(i,n)mf.use[i] = 0;\n\t  mf.dfs(n-1,use==1?b:a,1);\n\t  F--;\n\t}\n      }\n    }\n    //rep(i,n)for(edge e: mf.graph[i])cout << i << \" \" << e.to << \" \" << e.cost << \" \" << e.cap << \" \" << e.rev <<  endl;\n\n    cout << F << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct max_flow{\n    vector<vector<int>> graph;\n    vector<bool> done;\n    int size,flow;\n    max_flow(int size_):size(size_),graph(size_,vector<int>(size_)),done(size_),flow(0){}\n    void add_edge(int from,int to,int cap){\n        graph[from][to]=graph[to][from]=cap;\n    }\n    int dfs(int v,int t,int f){\n        if(v==t) return f;\n        done[v]=true;\n        for(int w=0; w<size; ++w){\n            if(done[w] or graph[v][w]==0) continue;\n            int d=dfs(w,t,min(f,graph[v][w]));\n            if(d>0){\n                graph[v][w]-=d;\n                graph[w][v]+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int calc_max_flow(int s,int t){\n        while(true){\n            fill(done.begin(),done.end(),false);\n            int f=dfs(s,t,inf);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nvoid solve(){\n    int n,e,q;\n    cin >> n >> e >> q;\n    max_flow mf(n);\n    rep(i,0,e){\n        int f,t;\n        cin >> f >> t;\n        --f;\n        --t;\n        mf.add_edge(f,t,1);\n    }\n    mf.calc_max_flow(0,n-1);\n    auto search_path=[&](int s,int t,int c){\n        vector<int> from(n);\n        vector<bool> done(n);\n        queue<int> que;\n        que.push(s);\n        done[s]=true;\n        while(!que.empty()){\n            int u=que.front();\n            que.pop();\n            if(u==t){\n                vector<int> res;\n                int v=u;\n                while(v!=s){\n                    res.push_back(v);\n                    v=from[v];\n                }\n                res.push_back(s);\n                return res;\n            }\n            rep(v,0,n){\n                if(done[v]) continue;\n                if(c==1){\n                    if(mf.graph[u][v]==0) continue;\n                }else{\n                    if(mf.graph[u][v]!=0 or mf.graph[v][u]!=2) continue;\n                }\n                que.push(v);\n                done[v]=true;\n                from[v]=u;\n            }\n        }\n\n        return vector<int>();\n    };\n    rep(i,0,q){\n        int m,a,b;\n        cin >> m >> a >> b;\n        --a;\n        --b;\n        if(m==1){\n            mf.add_edge(a,b,1);\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }else{\n            int k=mf.calc_max_flow(0,n-1);\n            if(mf.graph[a][b]==1){\n                cout << k << endl;\n                continue;\n            }\n            if(mf.graph[b][a]==0) swap(a,b);\n            mf.graph[a][b]=mf.graph[b][a]=0;\n            {\n                vector<int> vs=search_path(a,b,1);\n                if(!vs.empty()){\n                    rep(i,0,vs.size()-1){\n                        mf.graph[vs[i]][vs[i+1]]=0;\n                        mf.graph[vs[i+1]][vs[i]]=2;\n                    }\n                    cout << k << endl;\n                    continue;\n                }\n            }\n            --mf.flow;\n            if(a!=0){\n                vector<int> vs=search_path(0,a,0);\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=1;\n                    mf.graph[vs[i+1]][vs[i]]=1;\n                }\n            }\n            if(b!=n-1){\n                vector<int> vs=search_path(b,n-1,0);\n                rep(i,0,vs.size()-1){\n                    mf.graph[vs[i]][vs[i+1]]=1;\n                    mf.graph[vs[i+1]][vs[i]]=1;\n                }\n            }\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                // edge is not used\n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.getmaxflow(N-1, a, 1);\n                    fl.getmaxflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.getmaxflow(N-1, b, 1);\n                    fl.getmaxflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntypedef int Weight;\nconst Weight INF=99999999;\nstruct Edge{\n\tint src,dst;\n\tWeight weight;\n\tint rev;\n\tEdge(int f, int t, Weight c,int rev=0):src(f),dst(t),weight(c),rev(rev){}\n};\ntypedef vector< vector<Edge> > Graph;\n\npii add_edge(Graph &G,int s,int t,Weight cap){\n\tG[s].push_back(Edge(s,t,cap,G[t].size()));\n\tG[t].push_back(Edge(t,s,cap,G[s].size()-1));\n\treturn pii(G[s].size()-1, G[t].size()-1);\n}\n\n\nvoid bfs(const Graph &G,vector<int> &level,int s){\n\tlevel[s]=0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();que.pop();\n\t\tREP(i,G[v].size()){\n\t\t\tconst Edge &e=G[v][i];\n\t\t\tif(e.weight>0 && level[e.dst] < 0){\n\t\t\t\tlevel[e.dst] = level[v] +1;\n\t\t\t\tque.push(e.dst);\n\t\t\t}\n\t\t}\n\t}\n}\nWeight dfs(Graph &G,vector<int> &level,vector<int> &iter,int v,int t,Weight flow){\n\tif(v==t)return flow;\n\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\tEdge &e=G[v][i];\n\t\tif(e.weight>0&&level[v]<level[e.dst]){\n\t\t\tWeight d=dfs(G,level,iter,e.dst,t,min(flow,e.weight));\n\t\t\tif(d>0){\n\t\t\t\te.weight-=d;\n\t\t\t\tG[e.dst][e.rev].weight+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\nreturn 0;\n}\n\n// Dinic\n// O(EV^2)\nWeight max_flow(Graph &G,int s,int t,int f=0){\n\tstatic Weight flow = 0;\n\twhile(true){\n\t\tvector<int> level(G.size(),-1);\n\t\tvector<int> iter(G.size(),0);\n\t\tbfs(G,level,s);\n\t\tif(level[t]<0)break; // もう流せない\n\t\tif(f){\n\t\t\tdfs(G,level,iter,s,t,1);\n\t\t\treturn 1;\n\t\t}\n\t\tWeight f=0;\n\t\twhile((f=dfs(G,level,iter,s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\nint N, E, Q;\nint idx[501][501];\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tmemset(idx, -1, sizeof(idx));\n\tGraph g(N);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tif(idx[u][v] < 0){\n\t\t\tpii res = add_edge(g, u, v, 0);\n\t\t\tidx[u][v] = res.first;\n\t\t\tidx[v][u] = res.second;\n\t\t}\n\t\tg[u][idx[u][v]].weight ++;\n\t\tg[v][idx[v][u]].weight ++;\n\t}\n\tint cur = 0;\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v;u--;v--;\n\t\tif(idx[u][v] < 0){\n\t\t\tpii res = add_edge(g, u, v, 0);\n\t\t\tidx[u][v] = res.first;\n\t\t\tidx[v][u] = res.second;\n\t\t}\n\t\tif(f == 1){\n\t\t\tg[u][idx[u][v]].weight ++;\n\t\t\tg[v][idx[v][u]].weight ++;\n\t\t}else{\n\t\t\tREP(j, 2){\n\t\t\t\tif(g[u][idx[u][v]].weight == 0){\n\t\t\t\t\tmax_flow(g, N-1, v, 1);\n\t\t\t\t\tmax_flow(g, u, 0, 1);\n\t\t\t\t\tg[v][idx[v][u]].weight --;\n\t\t\t\t\tcur ++;\n\t\t\t\t}else g[u][idx[u][v]].weight --;\n\t\t\t\tswap(u, v);\n\t\t\t}\n\t\t}\n\t\tcout << (max_flow(g, 0, N-1) - cur) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <functional>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntemplate <typename Weight>\nstruct MaxFlow{\n\tstruct Edge{\n\t\tint v;\n\t\tWeight w;\n\t\tint r;\n\t\tEdge(int v, Weight w,int r=0):v(v),w(w),r(r){}\n\t};\n\ttypedef vector< vector<Edge> > Graph;\n\tint n, source, sink;\n\tGraph g;\n\tWeight flow;\n\tMaxFlow(int n=0):n(n), g(n), flow(0){\n\t\t\n\t}\n\t\n\tvoid add_edge(int u, int v, Weight cap, Weight revcap=0){\n\t\tg[u].emplace_back(v,cap,g[v].size());\n\t\tg[v].emplace_back(u,revcap,g[u].size()-1);\n\t}\n\tvoid rem_edge(int u,int v, Weight cap){\n\t\tfor(auto &e : g[u])if(e.v == v){\n\t\t\tWeight t = min(cap, e.w);\n\t\t\te.w -= t;\n\t\t\tcap -= t;\n\t\t\tif(cap == 0) return;\n\t\t}\n\t\tif(cap != maxflow_dinic(u, v, cap)){\n\t\t\tmaxflow_dinic(sink, v, cap);\n\t\t\tmaxflow_dinic(u, source, cap);\n\t\t\tflow -= cap;\n\t\t}\n\t\trem_edge(v, u, cap);\n\t}\n\t\n\tWeight maxflow_dinic(int source, int sink, Weight limit){\n\t\tif(source == sink) return limit;\n\t\tconst Weight inf = numeric_limits<Weight>::max();\n\t\tWeight flow = 0;\n\t\twhile(true){\n\t\t\tvector<int> level(n, -1);\n\t\t\tqueue<int> q;\n\t\t\tlevel[source] = 0;\n\t\t\tq.push(source);\n\t\t\twhile(!q.empty()){\n\t\t\t\tconst int u = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor(const auto &e : g[u]){\n\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\tif(e.w <= 0 || level[v] >= 0){ continue; }\n\t\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(level[sink] < 0){ break; }\n\t\t\tvector<size_t> itr(n, 0);\n\t\t\twhile(true){\n\t\t\t\tfunction<Weight(int, Weight)> dfs =\n\t\t\t\t\t[&](int u, Weight limit){\n\t\t\t\t\t\tif(u == sink) return limit;\n\t\t\t\t\t\tfor(; itr[u] < g[u].size(); ++itr[u]){\n\t\t\t\t\t\t\tauto &e = g[u][itr[u]];\n\t\t\t\t\t\t\tconst int v = e.v;\n\t\t\t\t\t\t\tif(e.w <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\t\tconst Weight diff = dfs(v, min(e.w, limit));\n\t\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\t\te.w -= diff;\n\t\t\t\t\t\t\t\tg[v][e.r].w += diff;\n\t\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t};\n\t\t\t\tconst auto f = dfs(source, inf);\n\t\t\t\tif(f <= 0){ break; }\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tWeight maxflow(int s, int t){\n\t\tsource = s;\n\t\tsink = t;\n\t\treturn flow += maxflow_dinic(s, t, numeric_limits<Weight>::max());\n\t}\n};\n\nint N, E, Q;\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tMaxFlow<int> g(N);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg.add_edge(u, v, 1, 1);\n\t}\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v; u--; v--;\n\t\tif(f == 1){\n\t\t\tg.add_edge(u, v, 1, 1);\n\t\t}else{\n\t\t\tg.rem_edge(u, v, 1);\n\t\t\tg.rem_edge(v, u, 1);\n\t\t}\n\t\tcout << g.maxflow(0, N-1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to,cap,rev;\n};\nusing Graph=vector<vector<Edge>>;\nclass Flow{\n    Graph g;\n    vector<int> used;\n    int S,T;\n    int flow=0;\n    const int INF=1e9;\n    int bound;\n    int dfs(int v,int t,int f){\n        used[v]=true;\n        if(v==t) return f;\n        for(auto &e:g[v]){\n            if(used[e.to] || e.cap<=bound) continue;\n            int ret=dfs(e.to,t,min(f,e.cap));\n            if(ret){\n                e.cap-=ret;\n                g[e.to][e.rev].cap+=ret;\n                return ret;\n            }\n        }\n        return 0;\n    }\n    int dash(int v,int t,int f){\n        int ret=dfs(v,t,f);\n        fill(used.begin(),used.end(),false);\n        return ret;\n    }\n\n    public:\n    Flow(int n,int S,int T):g(n),used(n),S(S),T(T){}\n\n    void addEdge(int a,int b){\n        g[a].push_back(Edge{a,b,1,(int)g[b].size()});\n        g[b].push_back(Edge{b,a,1,(int)g[a].size()-1});\n    }\n\n    void removeEdge(int a,int b){\n        auto remove=[&](int from,int to){\n            bound=1;\n            for(auto &e:g[to]){\n                if(e.to==from){\n                    if(e.cap==2){\n                        e.cap=0;\n                        g[e.to][e.rev].cap=0;\n                        if(dash(from,S,1)==1){\n                            dash(T,to,1);\n                            flow--;\n                        }\n                        else{\n\n                            dash(from,to,1);\n                        }\n                    }\n                    else if(e.cap==1){\n                        e.cap=0;\n                        g[e.to][e.rev].cap=0;\n                    }\n                }\n            }\n        };\n        remove(a,b);\n        remove(b,a);\n        \n    }\n\n    int maxFlow(){\n        bound=0;\n        int f;\n        while(f=dash(S,T,INF)){\n            flow+=f;\n        }\n        return flow;\n    }\n\n};\nint main(){\n    int n,e,q;\n    cin>>n>>e>>q;\n    Flow flow(n,0,n-1);\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        f--,t--;\n        flow.addEdge(f,t);\n    }\n    while(q--){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            flow.addEdge(a,b);\n        }\n        else{\n            flow.removeEdge(a,b);\n        }\n        cout<<flow.maxFlow()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[501];\nbool used[501];\n\nvoid add_edge(int from,int to){\n  G[from].push_back({to,1,(int)G[to].size()});\n  G[to].push_back({from,1,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //  cout<<'v'<<v<<endl;\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t,int fl=1<<29){\n  if(s==t)return 0;\n  int flow=0;\n  while(fl){\n    fill(begin(used),end(used),false);\n    int f=dfs(s,t,fl);\n    if(f==0)break;\n    fl-=f;\n    flow+=f;\n  }\n  return flow;\n}\n\nvoid remove_edge(int A,int B){\n  int x;\n  for(x=0;G[A][x].to!=B;x++);\n  int r=G[A][x].rev;\n  for(int i=x+1;i<G[A].size();i++){\n    auto e=G[A][i];\n    G[e.to][e.rev].rev--;\n  }\n  for(int i=r+1;i<G[B].size();i++){\n    auto e=G[B][i];\n    G[e.to][e.rev].rev--;\n  }\n  G[A].erase(begin(G[A])+x);\n  G[B].erase(begin(G[B])+r);\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  while(E--){\n    int F,T;\n    cin>>F>>T;\n    add_edge(F,T);\n  }\n  int flow=max_flow(1,N);\n  while(Q--){\n    int M,A,B;\n    cin>>M>>A>>B;\n    if(M==1){\n      add_edge(A,B);\n      flow+=max_flow(1,N);\n    }else{\n      int x;\n      for(x=0;G[A][x].to!=B;x++);\n      if(G[A][x].cap==1){\n\tremove_edge(A,B);\n      }else{\n\tint f=A,t=B;\n\tif(G[A][x].cap!=0){\n\t  swap(f,t);\n\t}\n\tremove_edge(A,B);\n\tif(!max_flow(f,t,1)){\n\t  max_flow(N,t,1);\n\t  max_flow(f,1,1);\n\t  flow--;\n\t}\n      }\n    }\n    cout<<flow<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nint n;\nint g[500][500];\nint flow[500][500];\nbool visited[500];\n\nbool aug(int s, int t) {\n  visited[s] = 1;\n  if (s==t) return 1;\n  REP(i,n) {\n    if (g[s][i]-flow[s][i]>=1 && !visited[i]) {\n      if (aug(i, t)) {\n        flow[s][i]++;\n        flow[i][s]--;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nbool augment(int s, int t) {\n  memset(visited,0,sizeof(visited));\n  return aug(s,t);\n}\n\n\nint main() {\n  int m,q;\n  cin >> n >> m >> q;\n  \n  REP(i,m) {\n    int f,t;\n    cin >> f>>t;\n    f--;t--;\n    g[f][t] = 1;\n    g[t][f] = 1;\n  }\n  int ans = 0;\n  while(1) {\n    if (!augment(0,n-1))\n      break;\n    ans++;\n  }\n  \n  REP(i,q) {\n    int m,a,b;\n    cin >>m>>a>>b;\n    a--;b--;\n    if (m==1) {\n      g[a][b] = 1;\n      g[b][a] = 1;\n      if (augment(0,n-1))\n        ans++;\n    } else {\n      g[a][b] = 0; g[b][a] = 0;\n      if (flow[a][b] == -1) swap(a,b);\n      if (flow[a][b] == 1) {\n        flow[a][b] = flow[b][a] = 0;\n        if (!augment(a,b)) {\n          augment(n-1, b);\n          augment(a, 0);\n          ans--;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool dfs(int v, int t, vector<vector<int>> &mat, vector<bool> &used) {\n\tif(v == t) return true;\n\n\tused[v] = true;\n\tconst int n = mat.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(mat[v][i] > 0 && !used[i] && dfs(i, t, mat, used)) {\n\t\t\t--mat[v][i];\n\t\t\t++mat[i][v];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tvector<vector<int>> mat(n, vector<int>(n, 0));\n\twhile(m--) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tmat[a][b] = mat[b][a] = 1;\n\t}\n\n\tconst int s = 0;\n\tconst int t = n - 1;\n\n\tint flow = 0;\n\tvector<bool> used(n, false);\n\twhile(dfs(s, t, mat, used)) {\n\t\t++flow;\n\t\tfill(used.begin(), used.end(), false);\n\t}\n\n\twhile(q--) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\t--a; --b;\n\n\t\tif(m == 1) { // connect\n\t\t\tmat[a][b] = mat[b][a] = 1;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tflow += dfs(s, t, mat, used);\n\t\t}\n\t\telse { // cut\n\t\t\tif(mat[a][b] != 1) {\n\t\t\t\tif(mat[b][a] == 0) swap(a, b);\n\n\t\t\t\tif(flow) {\n\t\t\t\t\t--flow;\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tdfs(t, s, mat, used);\n\t\t\t\t}\n\n\t\t\t\tif(mat[a][b] == 0) {\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tdfs(a, b, mat, used);\n\t\t\t\t}\n\n\t\t\t\tmat[a][b] = mat[b][a] = 0;\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tflow += dfs(s, t, mat, used);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmat[a][b] = mat[b][a] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow << \"\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= cp)continue;\n\t\t//if(ok[s][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\tok[s][i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tif(!flow(b, a))\n\t\t\t\t{\n\t\t\t\t\tflow(n, 1);\n\t\t\t\t\tflow(b, a);\n\t\t\t\t\tres--;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tif(!flow(a, b)){\n\t\t\t\t\tflow(n, 1);\n\t\t\t\t\tflow(a, b);\n\t\t\t\t\tres--;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n \nusing i64 = long long;\n \nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 rev;\n    bool alive;\n  };\n \n  int n;\n  vector<vector<edge>> edges;\n \n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n \n  int size() const { return n; }\n \n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n \nstruct Dinic_Reverse {\n  int N;\n  vector<int> level;\n  vector<int> itr;\n  Graph G;\n \n  Dinic_Reverse(int n) : G(n) { N = n; }\n \n  void add_edge(int from, int to, i64 cap, i64 rev_cap) {\n    G[from].push_back({to, cap, (int)G[to].size(),true});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1,true});\n  }\n \n  bool g_level(int s, int t) {\n    level.assign(N, -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (auto &e : G[v]) {\n          if(!e.alive) continue;\n        if (e.cap > 0 && level[e.to] == -1) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] >= 0;\n  }\n \n  i64 dfs(int v, int t, i64 f) {\n    if (v == t)\n      return f;\n \n    for (int &i = itr[v]; i < (int)G[v].size(); i++) {\n      auto &e = G[v][i];\n      if(!e.alive) continue;\n      if (e.cap > 0 && level[e.to] > level[v]) {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0) {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n \n  i64 max_flow(int s, int t , i64 limit = 1e9) {\n    i64 result = 0;\n    i64 flow;\n    while (g_level(s, t) && limit > 0) {\n      itr.assign(N, 0);\n      while ((flow = dfs(s, t, limit)) > 0)\n      {\n        result += flow;\n        limit -= flow;\n      }\n    }\n    return result;\n  }\n \n  bool back_edge(int from,int to,int s,int t){\n      for(auto& e : G[from]){\n          if(e.to == to && e.alive){\n              e.alive = false;\n              if(e.cap == 0 && max_flow(from, to, 1) == 0){\n                  max_flow(from, s, 1);\n                  max_flow(t,to,1);\n                  return 1;\n              }\n              else{\n                  return 0;\n              }\n          }\n      }\n  }\n};\n \n/*\n \nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\nint n;\nint e;\nint q;\n \nint main(){\n    cin >> n >> e >> q;\n    Dinic_Reverse dinic(n);\n    int s = 0;\n    int t = n - 1;\n    for(int i = 0;i < e;i++){\n        int a,b;;\n        cin >> a >> b;\n    a--;\n    b--;\n        dinic.add_edge(a, b , 1, 1);\n    }\n    int flow = dinic.max_flow(s, t );\n    for(int i = 0;i < q;i++){\n        int m,a,b;\n        cin >> m >> a >> b;\n        a--;\n        b--;\n        if(m == 1){\n            dinic.add_edge(a , b, 1 , 1);\n            flow += dinic.max_flow(s , t , 1);\n        }\n        else{\n            flow -= dinic.back_edge(a, b , s , t);\n            flow -= dinic.back_edge(b, a, s , t);\n        }\n        cout << flow << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1e8;\n\nstruct Edge {\n\tint to, rev, cap;\n};\n\nstruct Graph {\n\n\tvector<vector<Edge> > g;\n\n\tvoid initialize(int n)\n\t{\n\t\tg.resize(n);\n\t\tfill(g.begin(), g.end(), vector<Edge>());\n\t}\n\n\tvoid add_edge(int from, int to)\n\t{\n\t\tg[from].push_back({to, (int)g[to].size(), 1});\n\t\tg[to].push_back({from, (int)g[from].size() - 1, 1});\n\t}\n\n\tbool flow_dfs(int v, int t, vector<bool> &used)\n\t{\n\t\tif(v == t)\n\t\t\treturn true;\n\t\tused[v] = true;\n\n\t\tfor(auto &e : g[v]) {\n\n\t\t\tif(used[e.to] || e.cap <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tconst bool d = flow_dfs(e.to, t, used);\n\t\t\tif(!d)\n\t\t\t\tcontinue;\n\n\t\t\te.cap -= 1;\n\t\t\tg[e.to][e.rev].cap += 1;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint max_flow_step(int s, int t)\n\t{\n\t\tstatic vector<bool> used;\n\n\t\tif(g.size() > used.size())\n\t\t\tused.resize(g.size());\n\t\tfill(used.begin(), used.end(), false);\n\n\t\treturn flow_dfs(s, t, used);\n\t}\n\n\tint max_flow(int s, int t)\n\t{\n\t\tint flow = 0;\n\n\t\twhile(true) {\n\n\t\t\tconst bool f = max_flow_step(s, t);\n\t\t\tif(f)\n\t\t\t\tflow += 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn flow;\n\t}\n\n\tvoid restore_edge(int from, int to)\n\t{\n\t\tfor(auto &e : g[from]) {\n\t\t\tif(e.to == to) {\n\t\t\t\tauto &re = g[to][e.rev];\n\t\t\t\te.cap += 1;\n\t\t\t\tre.cap += 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tadd_edge(from, to);\n\t}\n\n\tint remove_edge(int a, int b, int s, int t)\n\t{\n\t\tauto reflow = [this, s, t](Edge &e, Edge &re){\n\n\t\t\tint from = re.to;\n\t\t\tint to = e.to;\n\n\t\t\tint f = max_flow_step(from, to);\n\n\t\t\tif(f >= 1) {\n\t\t\t\tre.cap -= 2;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tmax_flow_step(from, s);\n\t\t\tmax_flow_step(t, to);\n\n\t\t\treturn 1;\n\t\t};\n\n\t\tfor(auto &e : g[a]) {\n\n\t\t\tif(e.to != b)\n\t\t\t\tcontinue;\n\n\t\t\tauto &re = g[b][e.rev];\n\n\t\t\tif(e.cap >= 1 && re.cap >= 1) {\n\n\t\t\t\te.cap -= 1;\n\t\t\t\tre.cap -= 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif(e.cap == 0)\n\t\t\t\treturn reflow(e, re);\n\t\t\telse\n\t\t\t\treturn reflow(re, e);\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\n\n\n\nint main()\n{\n\tint n, e, q;\n\tGraph g;\n\n\tscanf(\"%d%d%d\", &n, &e, &q);\n\tg.initialize(n);\n\tconst int gs = 0, gt = n - 1;\n\n\tfor(int i = 0; i < e; ++i) {\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tf -= 1; t -= 1;\n\t\tg.add_edge(f, t);\n\t}\n\n\tint flow = g.max_flow(gs, gt);\n\n\tfor(int query_num = 0; query_num < q; ++query_num) {\n\n\t\tint m, a, b;\n\n\t\tscanf(\"%d%d%d\", &m, &a, &b);\n\t\ta -= 1; b -= 1;\n\n\t\tif(m == 1) {\n\n\t\t\tg.restore_edge(a, b);\n\t\t\tflow += g.max_flow(gs, gt);\n\n\t\t} else {\n\n\t\t\tflow -= g.remove_edge(a, b, gs, gt);\n\t\t}\n\n\t\tprintf(\"%d\\n\", flow);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint G[511][511];\n \nbool used[511];\n \nint N,E,Q;\n \n#define INF ( 1<<30)\n \nvoid add_edge(int a,int b){\n  G[a][b] = G[b][a] = 1;\n}\n \nvoid rem_edge(int a,int b){\n  G[a][b] = G[b][a] = 0;\n}\n \nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<N;i++){\n    if( !used[i] && G[v][i] > 0 ) {\n      int d = dfs(i, t, min( f, G[v][i] ) );\n      if( d > 0 ){\n\tG[v][i]--;\n\tG[i][v]++;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n \n \nint max_flow(int s,int t,int F){\n  int flow = 0;\n  if( s == t ) return 0;\n  for(int i=0;i<F;i++){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,F);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n  return flow;\n}\n\nint main(){\n  cin  >> N >> E >> Q;\n  for(int i=0;i<E;i++){\n    int e,f;\n    cin >> e >> f;\n    --e; --f;\n    add_edge(e,f);\n  }\n  int rflow = max_flow(0,N-1,INF);\n  for(int i=0;i<Q;i++){\n    int m,a,b;\n    cin >>m>> a>> b;\n    --a; --b;\n    if( m == 1 ){\n      add_edge(a,b);\n    } else {\n      if( G[a][b] == 0 ) {\n\tint d = max_flow(a,b,1);\n\tif( d == 0 ){\n\t  max_flow(N-1,0,1);\n\t  max_flow(a,b,1);\t\n\t  rflow--;\n\t}\n      } else if( G[b][a] == 0 ){\n\tint d = max_flow(b,a,1);\n\tif( d == 0 ){\n\t  max_flow(N-1,0,1);\n\t  max_flow(b,a,1);\n\t  rflow--;\n\t}\n      }\n      rem_edge(a,b);\n    }\n    rflow += max_flow(0,N-1,INF);\n    cout << rflow << endl;\n  }\n  // view();\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include <assert.h>\n#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        /*\n        if(indexOf[from][to] != -1){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            */\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n       // }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = -1;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    while(Q--){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            assert(fl.G[a][tob].to == b && fl.G[b][toa].to == a);\n            assert(tob != -1 && toa != -1);\n            if(fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                \n                //edge: a -> b and edge: b-> a are not used\n                \n            } else {\n                //  edge: a -> b is used\n                if(fl.G[a][tob].cap == 2){\n                    if(fl.getmaxflow(b,a,1) == 0){\n                        fl.getmaxflow(N-1,0,1);\n                        fl.getmaxflow(b,a,1);\n                        --res;\n                    }\n                }else if(fl.G[b][toa].cap  == 2){\n                    if(fl.getmaxflow(a,b,1) == 0){\n                        fl.getmaxflow(N-1, 0,1);\n                        fl.getmaxflow(a,b,1);\n                        --res;\n                    }\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct Graph\n{\n  struct edge\n  {\n    int to;\n    i64 cap;\n    i64 rev;\n    bool alive;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N)\n  {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Dinic_Reverse\n{\n  int N;\n  vector<int> used;\n  Graph G;\n\n  Dinic_Reverse(int n) : G(n) { N = n; }\n\n  void add_edge(int from, int to, i64 cap, i64 rev_cap)\n  {\n    G[from].push_back({to, cap, (int)G[to].size(), true});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1, true});\n  }\n  i64 dfs(int v, int t, i64 f)\n  {\n    if (v == t)\n      return f;\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++)\n    {\n      auto &e = G[v][i];\n      if (!e.alive)\n        continue;\n      if (e.cap > 0 && !used[e.to])\n      {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0)\n        {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n\n  i64 max_flow(int s, int t, i64 limit = 1e9)\n  {\n    i64 result = 0;\n    i64 flow;\n    while (limit > 0)\n    {\n      used.assign(N, 0);\n      if ((flow = dfs(s, t, limit)) == 0)\n        break;\n      result += flow;\n      limit -= flow;\n    }\n    return result;\n  }\n\n  bool back_edge(int from, int to, int s, int t)\n  {\n    for (auto &e : G[from])\n    {\n      if (e.to == to && e.alive)\n      {\n        e.alive = false;\n        if (e.cap == 0 && max_flow(from, to, 1) == 0)\n        {\n          max_flow(from, s, 1);\n          max_flow(t, to, 1);\n          return 1;\n        }\n        else\n        {\n          return 0;\n        }\n      }\n    }\n  }\n};\n\n/*\n \nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\nint n;\nint e;\nint q;\n\nint main()\n{\n  cin >> n >> e >> q;\n  Dinic_Reverse dinic(n);\n  int s = 0;\n  int t = n - 1;\n  for (int i = 0; i < e; i++)\n  {\n    int a, b;\n    ;\n    cin >> a >> b;\n    a--;\n    b--;\n    dinic.add_edge(a, b, 1, 1);\n  }\n  int flow = dinic.max_flow(s, t);\n  for (int i = 0; i < q; i++)\n  {\n    int m, a, b;\n    cin >> m >> a >> b;\n    a--;\n    b--;\n    if (m == 1)\n    {\n      dinic.add_edge(a, b, 1, 1);\n      flow += dinic.max_flow(s, t, 1);\n    }\n    else\n    {\n      flow -= dinic.back_edge(a, b, s, t);\n      flow -= dinic.back_edge(b, a, s, t);\n    }\n    cout << flow << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=int;\n\nstruct Edge{\n    int from,to;\n    Weight cap;\n    bool rev;\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs){\n    if(lhs.from!=rhs.from) return lhs.from<rhs.from;\n    if(lhs.to!=rhs.to) return lhs.to<rhs.to;\n    if(lhs.cap!=rhs.cap) return lhs.cap<rhs.cap;\n    return lhs.rev<rhs.rev;\n}\nusing Edges=multiset<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    Graph g;\n    Weight nowF=0;\n    const Weight INF=1e9;\n    Weight dfs(int v,int t,stack<int>& st,vector<int> &used,bool mustrev){\n        if(used[v]) return 0;\n        if(v==t) return INF;\n        used[v]=true;\n        for(auto &e:g[v]){\n            if(e.cap==0) continue;\n            if(mustrev && !e.rev) continue;\n            Weight f=dfs(e.to,t,st,used,mustrev);\n            if(f>0){\n                st.push(v);\n                return min(f,e.cap);\n            }   \n        }\n        return 0;\n    }\n    Edges::iterator rettf(int fr,int to,int cap,Edges &edges){\n        auto res=edges.find(Edge{fr,to,cap,true});\n        if(res==edges.end()) res=edges.find(Edge{fr,to,cap,false});\n        return res;\n    }\n    public:\n    Flow(int n):g(n){}\n    void addEdge(int from,int to,Weight cap){\n        g[from].insert(Edge{from,to,cap,false});\n        g[to].insert(Edge{to,from,0,true});\n    }\n    Weight maxFlow(int s,int t){\n        Weight res=0;\n        Weight f;\n        vector<int> used(g.size(),false);\n        stack<int> st;\n        while(f=dfs(s,t,st,used,false)){\n            res+=f;\n            while(!st.empty()){\n                int fr=st.top(); st.pop();\n                int to=(st.empty() ? t : st.top());\n                auto it0=rettf(fr,to,1,g[fr]);\n                auto it1=g[to].find(Edge{to,fr,0,!(it0->rev)});\n                assert(it0!=g[fr].end() && it1!=g[to].end());\n                g[fr].insert(Edge{fr,to,0,it0->rev});\n                g[fr].erase(it0);\n                g[to].insert(Edge{to,fr,1,it1->rev});\n                g[to].erase(it1);\n            }\n            fill(used.begin(),used.end(),false);\n        }\n        return nowF=nowF+res;\n    }\n\n    void decEdge(int fr,int to,int s,int t){\n        if(g[fr].find(Edge{fr,to,0,false})==g[fr].end()){\n            g[fr].erase(Edge{fr,to,1,false});\n            g[to].erase(Edge{to,fr,0,true});\n            return;\n        }\n        g[fr].erase(g[fr].find(Edge{fr,to,0,false}));        \n        g[to].erase(g[to].find(Edge{to,fr,1,true}));\n        \n        vector<int> used(g.size(),false);\n        stack<int> st;\n        int f0=dfs(fr,s,st,used,true);\n        assert(f0>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? s : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        \n        int f1=dfs(t,to,st,used,true);        \n        assert(f1>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? to : st.top());\n            auto it0=g[frr].find(Edge{frr,too,1,true});\n            auto it1=g[too].find(Edge{too,frr,0,false});\n            assert(it0!=g[frr].end());\n            assert(it1!=g[too].end());\n            g[frr].insert(Edge{frr,too,0,true});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,false});\n            g[too].erase(it1);\n        }\n        nowF--;\n    } \n    \n};\n\nint main(){\n    int n,e,q;\n    cin>>n>>e>>q;\n    Flow flow(n);\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        f--,t--;\n        flow.addEdge(f,t,1);\n        flow.addEdge(t,f,1);\n    }\n    for(int i=0;i<q;i++){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            flow.addEdge(a,b,1);\n            flow.addEdge(b,a,1);\n        }\n        if(m==2){\n            flow.decEdge(a,b,0,n-1);\n            flow.decEdge(b,a,0,n-1);\n        }\n        cout<<flow.maxFlow(0,n-1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool dfs(int v, int t, vector<vector<int>> &mat, vector<bool> &used) {\n\tif(v == t) return true;\n\n\tused[v] = true;\n\tconst int n = mat.size();\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(mat[v][i] > 0 && !used[i] && dfs(i, t, mat, used)) {\n\t\t\t--mat[v][i];\n\t\t\t++mat[i][v];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tvector<vector<int>> mat(n, vector<int>(n, 0));\n\twhile(m--) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tmat[a][b] = mat[b][a] = 1;\n\t}\n\n\tconst int s = 0;\n\tconst int t = n - 1;\n\n\tint flow = 0;\n\tvector<bool> used(n, false);\n\twhile(dfs(s, t, mat, used)) {\n\t\t++flow;\n\t\tfill(used.begin(), used.end(), false);\n\t}\n\n\twhile(q--) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\t--a; --b;\n\n\t\tif(m == 1) { // connect\n\t\t\tmat[a][b] = mat[b][a] = 1;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tflow += dfs(s, t, mat, used);\n\t\t}\n\t\telse { // cut\n\t\t\tif(mat[a][b] != 1) {\n\t\t\t\t--flow;\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(mat[a][b] == 0) {\n\t\t\t\t\tmat[b][a] = 0;\n\t\t\t\t\tdfs(a, s, mat, used);\n\t\t\t\t\tdfs(t, b, mat, used);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmat[a][b] = 0;\n\t\t\t\t\tdfs(b, s, mat, used);\n\t\t\t\t\tdfs(t, a, mat, used);\n\t\t\t\t}\n\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tflow += dfs(s, t, mat, used);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmat[a][b] = mat[b][a] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcout << flow << \"\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t) {\n        return f;\n    }\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    if (s == t) return 0;\n    int flow = 0;\n    for(;;) {\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n    }\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        if (m == 1) {\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n);\n            cout << f << endl;\n        } else {\n            int from = -1, to = -1;\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 &&  to > 0) {\n                if (max_flow(from, to, 1) > 0) {\n                    cout << f << endl;\n                } else {\n                    f--;\n                    max_flow(from, 1);\n                    max_flow(n, to);\n                    cout << f << endl;\n                }\n            }\n            else cout << f << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\n\nconst int MAX_V_flow = 510;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tmap<int,int> id[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tid[from][to] = G[from].size();\n\t\tid[to][from] = G[to].size();\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , flow , G[from].size()-1 ) );\n\t}\n\t\n\tint erase_edge(int from,int to){\n\t\tint s = id[from][to];\n\t\tint t = id[to][from];\n\t\tint ret = 0;\n\t\t//cout << G[from][s].sc.fr << \" \" << G[to][t].sc.fr << endl;\n\t\tif(G[from][s].sc.fr == 2){\n\t\t\tG[from][s].sc.fr = 0;\n\t\t\tG[to][t].sc.fr = 0;\n\t\t\tret = 1;\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tret = min ( ret , dfs(n,from,1) );\n\t\t\tif(ret != 0){\n\t\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\t\tret = min ( ret , dfs(to,1,1) );\n\t\t\t\tif(ret == 0){\n\t\t\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\t\t\tdfs(from,n,1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ret == 0){\n\t\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\t\tdfs(to,from,1);\n\t\t\t}\n\t\t}\n\t\telse if(G[to][t].sc.fr == 2){\n\t\t\tG[from][s].sc.fr = 0;\n\t\t\tG[to][t].sc.fr = 0;\n\t\t\tret = 1;\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\tret = min ( ret , dfs(n,to,1) );\n\t\t\tif(ret != 0){\n\t\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\t\tret = min ( ret , dfs(from,1,1) );\n\t\t\t\tif(ret == 0){\n\t\t\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\t\t\tdfs(to,n,1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ret == 0){\n\t\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\t\tdfs(from,to,1);\n\t\t\t}\n\t\t}\n\t\tG[from][s].sc.fr = 0;\n\t\tG[to][t].sc.fr = 0;\n\t\treturn ret;\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\t//printf(\"%d %d %d\\n\",v,t,f);\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\tint ret = 0,d = 1;\n\t\twhile(d > 0){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\td = dfs(s,t,INF);\n\t\t\tret += d;\n\t\t}\n\t\treturn ret;\n\t}\n}flow;\n\nint main(){\n\tint e,q;\n\tscanf(\"%d%d%d\",&n,&e,&q);\n\t\n\trep(i,e){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tflow.add_edge(f,t,1);\n\t}\n\tint ret = flow.flow(1,n);\n\trep(i,q){\n\t\tint m,a,b;\n\t\tscanf(\"%d%d%d\",&m,&a,&b);\n\t\tif(m == 1){\n\t\t\tflow.add_edge(a,b,1);\n\t\t}\n\t\telse {\n\t\t\tret -= flow.erase_edge(a,b);\n\t\t}\n\t\tret += flow.flow(1,n);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tmap<P,int> m;\n\tint DFS(int v,int t,int f,vi& used,int u){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0&&e.to!=u){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),used,V);\n\t\t\t\tif(d>0){\n\t//\t\t\t\tif(t==11) cout<<'A'<<e.to<<endl;\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tm[{s,t}]=g[s].size();\n\t\tg[s].push_back(edge{t,1,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,1,(int)g[s].size()-1});\n\t}\n\tint Max_Flow(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi used(V);\n\t\t\tint f=DFS(s,t,1,used,V);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n\tint Add(int u,int v){\n\t\tadd_edge(u,v);\n\t\tvi used(V);\n\t\treturn DFS(0,V-1,inf,used,V);\n\t}\n\tint Erase(int u,int v,int ind){\n\t\tint I=m[{u,v}],J=g[u][I].rev,C=g[u][I].cap;\n//\t\tif(ind==817) cout<<C<<endl;\n//\t\tif(ind==816) cout<<g[1][m[{1,3}]].cap<<endl;\n\t\tif(C==1){\n\t\t\tg[u][I].cap=0;\n\t\t\tg[v][J].cap=0;\n\t\t\treturn 0;\n\t\t}\n\t\tvi used(V);\n\t\tint f=DFS((C?v:u),(C?u:v),1,used,V);\n\t\tif(f) return 0;\n\t\tused=vi(V);\n\t\tDFS(V-1,0,1,used,V);\n\t\tg[u][I].cap=0;\n\t\tg[v][J].cap=0;\n\t\tused=vi(V);\n\t\tDFS((C?v:u),(C?u:v),1,used,v);\n//\t\tcout<<\"!!!!!\"<<f<<endl;\n\t\treturn 1;\n\t}\n\tvoid Open(){\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<g[i].size();j++) if(g[i][j].cap==2) cout<<g[i][j].to<<' '<<i<<endl;\n\t\t}\n\t}\n};\n\nint n,m,q;\n\nint main(){\n\tcin>>n>>m>>q;\n\tNetwork nt(n);\n\tvvi g(n,vi(n));\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tnt.add_edge(u,v);\n\t\tg[u][v]++;\n\t\tg[v][u]++;\n\t}\n\tvi a(q);\n\tint res=nt.Max_Flow(0,n-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t,u,v;\n\t\tcin>>t>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tif(t==1){\n\t\t\tres+=nt.Add(u,v);\n\t\t\tg[u][v]++;\n\t\t\tg[v][u]++;\n\t\t}\n\t\telse{\n\t\t\tres-=nt.Erase(u,v,i);\n\t\t\tg[u][v]--;\n\t\t\tg[v][u]--;\n\t\t}\n\t\ta[i]=res;\n\t\tcout<<res<<endl;\n/*\t\tif(i==816||i==817){\n\t\t\tcout<<u<<' '<<v<<endl;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++) cout<<g[j][k]<<' ';\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}*/\n\t}\n/*\tfor(int i=0;i<q;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(a[i]!=x){\n\t\t\tcout<<i<<endl;\n//\t\t\tcout<<x<<' '<<a[i]<<endl;\n\t\t\tbreak;\n\t\t}\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 555;\nconst int INF = 1000000000;\n\nint n,e,q;\n\n\nint flow[N][N];\nint edge[N][N];\n\nbool init(){\n\tcin>>n>>e>>q;\n\trep(i,e){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tedge[a][b]=1;\n\t\tedge[b][a]=1;\n\t}\n}\n\nint update_edge(int a,int b,int c){\n\tint ret = 0;\n\tif(a==1){\n\t\tedge[b][c]++;\n\t\tedge[c][b]++;\n\t}\n\tif(a==2){\n\t\tedge[b][c]--;\n\t\tedge[c][b]--;\n\t\tret = max(ret, flow[b][c]-edge[b][c]);\n\t\tret = max(ret, flow[c][b]-edge[c][b]);\n\t\tflow[b][c] = min(flow[b][c], edge[b][c]);\n\t\tflow[c][b] = min(flow[c][b], edge[c][b]);\n\t}\n\treturn ret;\n}\n\nvoid printflow(){\n\tprintf(\"flow:\\n\");\n\trep(i,n+2){\n\t\trep(j,n+2){\n\t\t\tprintf(\"%2d \",flow[i][j]);\n\t\t}puts(\"\");\n\t}\n\tprintf(\"edge\\n\");\n\trep(i,n+2){\n\t\trep(j,n+2){\n\t\t\tif(edge[i][j]==INF)printf(\"oo \");\n\t\t\telse printf(\"%2d \",edge[i][j]);\n\t\t}puts(\"\");\n\t}puts(\"\\n\");\n}\nint visit[N];\nint flowrec(int pos, int en, int f){\n\tif(visit[pos]==1)return 0;\n\tvisit[pos]=1;\n\t\n\tif(pos==en)return f;\n\t\n\trep(i,N){\n\t\tint f1 = edge[pos][i] - flow[pos][i];\n\t\tint f2 = flow[i][pos];\n\t\t\n\t\tif(f1!=0 && f2==0){\n\t\t\tint val = flowrec(i, en, min(f,f1));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"flow %d %d\\n\",pos,i);\n\t\t\t\tflow[pos][i]+=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t\tif(f2!=0){\n\t\t\tint val = flowrec(i, en, min(f,f2));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"rflow %d %d\\n\",i,pos);\n\t\t\t\tflow[i][pos]-=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flowing(int st, int en){\n\tint ret = 0;\n\twhile(1){\n\t\trep(i,N)visit[i]=0;\n\t\t\n\t\tint val = flowrec(st, en, INF);\n\t\tif(val==0)break;\n\t\tret += val;\n\t}\n\treturn ret;\n}\n\nint reflowrec(int pos,int en,int f){\n\tif(visit[pos]==1)return 0;\n\tvisit[pos]=1;\n\t\n\tif(pos==en)return f;\n\t\n\trep(i,N){\n\t\tint f1 = flow[i][pos];\n\t\tif(f1!=0){\n\t\t\tint val = reflowrec(i, en, min(f,f1));\n\t\t\tif(val!=0){\n\t\t\t\tflow[i][pos]-=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nvoid reflowing(bool bc, int st, int en, int b, int c){\n\tif(bc){\n\t\t//printf(\"flow[%d][%d] %d\\n\",b,c,flow[b][c]);\n\t\tint val = flowing(b,c);\n\t\tif(val==0){\n\t\t\t//printf(\"* val=0\\n\");\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(b, st, 1);\n\t\t\t\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(en, c, 1);\n\t\t}\n\t}else{\n\t\t//printf(\"flow[%d][%d] %d\\n\",c,b,flow[c][b]);\n\t\tint val = flowing(c,b);\n\t\t\n\t\tif(val==0){\n\t\t\t//printf(\"* val=0\\n\");\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(c, st, 1);\n\t\t\t\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(en, b, 1);\n\t\t}\n\t}\n}\n\nvoid setflow(){\n\tedge[0][1]=INF;\n\tedge[n][n+1]=INF;\n}\nvoid solve(){\n\t\n\tsetflow();\n\tint st = 0;\n\tint en = n+1;\n\t\n\tint retsum = 0;\n\t\n\tretsum += flowing(st, en);\n\t//printflow();\n\t\n\trep(i,q){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t\n\t\tbool bc = flow[b][c]>0;\n\t\t\n\t\tint dec = update_edge(a,b,c);\n\t\tretsum -= dec;\n\t\t\n\t\tif(a==1){\n\t\t\tretsum += flowing(st, en);\n\t\t}\n\t\tif(a==2){\n\t\t\tif(dec!=0){\n\t\t\t\t//printf(\"dec!=0\\n\");\n\t\t\t\treflowing(bc, st, en, b, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",flow[n][n+1]);\n\t\t//printflow();\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, to, 1);\n            max_flow(from, 0, 1);  \n            e.alive = false;\n            return(1);\n          }\n        }\n        e.alive = false;\n        return(0);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n      flow -= graph.remove_edge(B, A);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t) {\n        return f;\n    }\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    if (s == t) return 0;\n    int flow = 0;\n    for(;;) {\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n    }\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        if (m == 1) {\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n);\n            cout << f << endl;\n        } else {\n            int from = -1, to = -1;\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 &&  to > 0) {\n                if (max_flow(from, to, 1) > 0) {\n                    cout << f << endl;\n                } else {\n                    f--;\n                    max_flow(from, 1);\n                    max_flow(n, to);\n                    cout << f << endl;\n                }\n            }\n            else cout << f << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct EdgeF{\n  int to, cap, rev;\n  bool del;\n  EdgeF(int to_=0, int cap_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), rev(rev_), del(false){}\n};\nusing GraphF = vector<vector<EdgeF>>;\n\nvoid add_edge(GraphF& G, int from, int to, int cap){\n  G[from].emplace_back(to, cap, G[to].size());\n  G[to].emplace_back(from, cap, G[from].size()-1);\n}\nint max_flow(GraphF& G, int s, int t, int ff = INF){\n  if(s == t) return ff;\n  \n  const int V = G.size();\n  vector<bool> used(V);\n \n  function<int(int,int,int)> dfs = [&](int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n\tREP(i,SZ(G[v])){\n\t  auto& e =  G[v][i];\n      if(!used[e.to] && e.cap > 0 && !e.del){\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  };\n  if(ff < INF){\n    fill(used.begin(), used.end(), false);\n    return dfs(s, t, ff);\n  }\n \n  int flow = 0;\n  while(true){\n    fill(used.begin(), used.end(), false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E, Q;\n  cin >> V >> E >> Q;\n  GraphF G(V);\n  REP(i,E){\n\tint f, t;\n\tcin >> f >> t;\n\t--f;\n\t--t;\n\tadd_edge(G, f, t, 1);\n  }\n\n  int f = max_flow(G, 0, V-1);\n  REP(q,Q){\n\tint m, a, b;\n\tcin >> m >> a >> b;\n\t--a, --b;\n\tif(m == 1){\n\t  add_edge(G, a, b, 1);\n\t  f += max_flow(G, 0, V-1);\n\t}\n\telse{\n\t  for(auto& e: G[a]){\n\t\tif(e.to == b && !e.del){\n\t\t  if(e.cap == 0 || e.cap == 2){\n\t\t\tint orig = e.cap;\n\t\t\te.cap = G[b][e.rev].cap = 0;\n\t\t\te.del = G[b][e.rev].del = true;\n\t\t\tif(orig == 0){ // 0 -> a -> b -> V-1\n\t\t\t  if(max_flow(G, a, b, 1) == 0){\n\t\t\t\t--f;\n\t\t\t\tmax_flow(G, a, 0, 1);\n\t\t\t\tmax_flow(G, V-1, b, 1);\n\t\t\t  }\n\t\t\t}\n\t\t\telse{ // 0 -> b -> a -> V-1\n\t\t\t  if(max_flow(G, b, a, 1) == 0){\n\t\t\t\t--f;\n\t\t\t\tmax_flow(G, b, 0, 1);\n\t\t\t\tmax_flow(G, V-1, a, 1);\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t  e.cap = G[b][e.rev].cap = 0;\n\t\t  e.del = G[b][e.rev].del = true;\n\t\t  break;\n\t\t}\n\t  }\n\t}\n\tcout << f << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct flowGraph{\n\tstruct edge{ int to, cap, rev; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tint add(int s, int t, int cap){\n\t\tG[s].pb((edge){t, cap, G[t].size()});\n\t\tG[t].pb((edge){s, 0, G[s].size() - 1});\n\t\treturn G[s].size() - 1;\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t, int lim = inf){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, lim - flow)) > 0) flow += f;\n\t\t\tif(flow == lim) return flow;\n\t\t}\n\t}\n};\nint n, e, q;\nint m[1000], a[1000], b[1000];\n\nint main(){\n\tcin >> n >> e >> q;\n\tmap<pi, int> id;\n\tflowGraph g(n);\n\trep(i, e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\trep(it, 2){\n\t\t\tint j = g.add(f, t, 1);\n\t\t\tif(!id.count(mp(f, t))) id[mp(f, t)] = j;\n\t\t\tswap(f, t);\n\t\t}\n\t}\n\trep(i, q){\n\t\tcin >> m[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\trep(it, 2){\n\t\t\tif(!id.count(mp(a[i], b[i]))){\n\t\t\t\tint j = g.add(a[i], b[i], 0);\n\t\t\t\tid[mp(a[i], b[i])] = j;\n\t\t\t}\n\t\t\tswap(a[i], b[i]);\n\t\t}\n\t}\n\tint ans = g.max_flow(0, n - 1);\n\t\n\trep(i, q){\n\t\tif(m[i] == 1){\n\t\t\tg.G[a[i]][id[mp(a[i], b[i])]].cap++;\n\t\t\tg.G[b[i]][id[mp(b[i], a[i])]].cap++;\n\t\t\tans += g.max_flow(0, n - 1);\n\t\t}\n\t\telse{\n\t\t\tint j = g.G[a[i]][id[mp(a[i], b[i])]].rev;\n\t\t\tif(g.G[b[i]][j].cap == 0){\n\t\t\t\tswap(a[i], b[i]);\n\t\t\t\tj = g.G[a[i]][id[mp(a[i], b[i])]].rev;\n\t\t\t}\n\t\t\t\n\t\t\tint t = g.max_flow(a[i], b[i], 1);\n\t\t\tif(!t){\n\t\t\t\tg.max_flow(n - 1, 0, 1);\n\t\t\t\tint u = g.max_flow(a[i], b[i], 1);\n\t\t\t\tassert(u);\n\t\t\t\tans--;\n\t\t\t}\n\t\t\tg.G[a[i]][id[mp(a[i], b[i])]].cap = 0;\n\t\t\tg.G[b[i]][j].cap = 0;\n\t\t\tg.G[b[i]][id[mp(b[i], a[i])]].cap = 0;\n\t\t\tg.G[a[i]][g.G[b[i]][id[mp(b[i], a[i])]].rev].cap = 0;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        if(!used[i]&&G[v][i]>0){\n            int d=dfs(i,t,min(f,G[v][i]));\n            if(d>0){\n                G[v][i]-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&V,&E,&Q);\n    f(i,E){\n        scanf(\"%d%d\",&F,&T);\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        scanf(\"%d%d%d\",&m,&a,&b);\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n            now+=max_flow(0,V-1);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(V-1,b,1);\n                    now--;\n                }\n            }\n        }\n        printf(\"%d\\n\",now);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=200000;\n\nstruct edge{\n\tint to,cap,rev,id;\n\tint flow;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t\tflow=0;\n\t}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,cap,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// ØfÏÝ\n\t\tif(!isUsable[e.id])continue;\n\t\t// Ü¾t[ð¬¹éÈçÎA¬·\n\t\tif(!used[e.to]&&e.flow<e.cap){\n\t\t\t// ¡ñÌ¬Ê\n\t\t\tint quan=e.cap-e.flow;\n\t\t\t//if(e.flow<0)quan=-(e.flow);\n\t\t\tint d=dfs(e.to,t,min(f,quan));\n\t\t\tif(d>0){\n\t\t\t\te.flow+=d;\n\t\t\t\t// ½ÎÉÍ}CiXÌvfðüêÄ¨­\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}// ¸­pXðTõ\nint dfs2(int v,int t){\n\tif(v==t) return 1;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!isUsable[e.id])continue;\n\t\t// 0æè¬³¯êÎAß·\n\t\tif(!used[e.to]&&e.flow<0){\n\t\t\tint d=dfs2(e.to,t);\n\t\t\tif(d>0){\n\t\t\t\te.flow+=1;\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\telse flow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,ee,q;\n\tcin>>n>>ee>>q;\n\tfor(int i=0;i<ee;i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,ee);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=ee;\n\t\t\tisUsable[ee]=true;\n\t\t\tee++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\tfor(int i=0;i<(int)G[a].size();i++){\n\t\t\t\tedge &e=G[a][i];\n\t\t\t\tif(!isUsable[e.id])continue;\n\t\t\t\tif(eidx==e.id){\n\t\t\t\t\t// ¬êÄ¢È¢ê,tOðÜé¾¯\n\t\t\t\t\tif(e.flow==0)isUsable[eidx]=false;\n\t\t\t\t\t// ¬êÄ¢éê\n\t\t\t\t\telse{\n\t\t\t\t\t\tint from=a;\n\t\t\t\t\t\tint to=b;\n\t\t\t\t\t\tif(e.flow>0) swap(from,to);\n\t\t\t\t\t\t// flowð0Éú»\n\t\t\t\t\t\te.flow=G[e.to][e.rev].flow=0;\n\t\t\t\t\t\t// ûüÉµ½ªÁÄtü«Éflowð¬·\n\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tint num=dfs(to,from,1);\n\t\t\t\t\t\t// ¬¹½ê\n\t\t\t\t\t\tif(num==1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// ¬¹È©Á½ê,ß·\n\t\t\t\t\t\t//dfs2(from,to);\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(n,from);\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(to,1);\n\t\t\t\t\t\t// Øf\n\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#define N 501\nconst int inf= 1000000000;\nusing namespace std;\n #define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\n\nint fordFulkerson(const int n,int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  for(int i = 0 ;i < n ; i++){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n        flow[now][next]+=tmp;\n        flow[next][now]=-flow[now][next];\n        return tmp;\n      }\n    }\n  }\n  return 0;\n}\n \nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  for(int i = 0 ; i < n ; i++)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    for(int i = 0 ; i < n ; i++)vis[i]=false;\n  }\n  return ret;\n}\n \nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n        flow[now][next]=flow[next][now]=0;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n \nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n        flow[now][next]+=1;\n        flow[next][now]=-flow[now][next];\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n \nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\ttmp=dfs2(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 502;\nmap<int,int> G[MAX_N];\nbool used[MAX_N];\nint n;\n\nvoid add_edge(int from, int to, int cap){\n    G[from][to] = cap;\n    G[to][from] = cap;\n}\nvoid erase_edge(int from, int to){\n    G[from][to] = 0;\n    G[to][from] = 0;\n}\nint dfs(int v,int t,int f){\n    if(v == t) return f;\n    used[v] = true;\n    each(it,G[v]){\n        int nx = it.fi;\n        int& cap = it.se;\n        if(!used[nx] && cap > 0){\n            int d = dfs(nx,t,min(f,cap));\n            if(d > 0){\n                cap -= d;\n                G[nx][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int f = dfs(s,t,INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int E,q;\n    cin >> n >> E >> q;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        add_edge(a-1,b-1,1);\n    }\n    int res = max_flow(0,n-1);\n    rep(i,q){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --b,--c;\n        if(a == 1){\n            add_edge(b,c,1);\n            res += max_flow(0,n-1);\n        }else{\n            int cap = G[b][c];\n            erase_edge(b,c);\n            //逆向きに1流れてたら\n            if(cap == 2){\n                swap(b,c);\n            }\n            if(cap != 1){\n                memset(used,0,sizeof(used));\n                int f = dfs(b,c,1);\n                //aからbにフローを1流せない(枝(a,b)を削除した分をまかなえない)\n                if(f == 0){\n                    memset(used,0,sizeof(used));\n                    dfs(b,0,1);\n                    memset(used,0,sizeof(used));\n                    dfs(n-1,c,1);\n                    --res;\n                }\n            }\n        }\n        cout << res << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int t, Flow f, int r) : src(s), dest(t), cap(f), rev(r) {}\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow max_flow(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nFlow unit_flow(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tvector<bool> used(g.size(), false);\n\tFlow f = dfs(g, used, s, t, 1);\n\tflow += f;\n\treturn flow;\n}\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\t//FGraph<int> g(n);\n\tGraph g(n);\n\tREP(i, n)REP(j, n)\n\t{\n\t\tg[i].emplace_back(i, j, 0, i);\n\t}\n\tREP(i, e)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b].cap++;\n\t\tg[b][a].cap++;\n\t}\n\tint tmp = max_flow(g, 0, n - 1);\n\tREP(i, q)\n\t{\n\t\tint a, b, c;\n\t\tcin >> c >> a >> b;\n\t\ta--; b--;\n\t\tif (c == 1)\n\t\t{\n\t\t\tassert(g[a][b].cap == 0 && g[b][a].cap == 0);\n\t\t\tg[a][b].cap++;\n\t\t\tg[b][a].cap++;\n\t\t\ttmp += unit_flow(g, 0, n - 1);\n\t\t}\n\t\tif (c == 2)\n\t\t{\n\t\t\tassert(g[a][b].cap != 0 || g[b][a].cap != 0);\n\t\t\tif (g[a][b].cap == 1 && g[b][a].cap == 1)\n\t\t\t{\n\t\t\t}\n\t\t\telse if (g[a][b].cap == 2 && g[b][a].cap == 0)\n\t\t\t{\n\t\t\t\tif (unit_flow(g, b, a) == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp--;\n\t\t\t\t\tunit_flow(g, b, 0);\n\t\t\t\t\tunit_flow(g, n - 1, a);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (g[a][b].cap == 0 && g[b][a].cap == 2)\n\t\t\t{\n\t\t\t\tif (unit_flow(g, a, b) == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp--;\n\t\t\t\t\tunit_flow(g, a, 0);\n\t\t\t\t\tunit_flow(g, n - 1, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse assert(false);\n\t\t\tg[a][b].cap = g[b][a].cap = 0;\n\t\t}\n\t\tcout << tmp << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,rev;};\nvector<edge> graph[vmax];\nint level[vmax],iter[vmax];\n\nvoid add_edge(int from,int to,int cap){\n\tgraph[from].push_back({to,cap,(int)graph[to].size()});\n\tgraph[to].push_back({from,0,(int)graph[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<graph[v].size();i++){\n\t\tedge &e=graph[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d==0) continue;\n\t\t\te.cap-=d;graph[e.to][e.rev].cap+=d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int s,int t){\n\trep(i,vmax) level[i]=-1;\n\tqueue<int> q;\n\tlevel[s]=0,q.push(s);\n\twhile(!q.empty()){\n\t\tint v=q.front();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn level[t]>=0;\n}\n\n\nint max_flow(int s,int t){\n\n\tint flow=0;\n\twhile(bfs(s,t)){\n\t\trep(i,vmax) iter[i]=0;\n\t\twhile(1){\n\t\t\tint f=dfs(s,t,inf);\n\t\t\tif(f==0) break;\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint flow(int s,int t){\n\tif(!bfs(s,t)) return 0;\n\trep(i,vmax) iter[i]=0;\n\treturn dfs(s,t,1);\n}\n\nint add(int from,int to,int s,int t){\n\tadd_edge(from,to,1);\n\tadd_edge(to,from,1);\n\treturn flow(s,t);\n}\n\nint erase(int from,int to,int s,int t){\n\tbool ft=false,tf=false;\n\tfor(auto &e:graph[from]){\n\t\tif(e.to==to){\n\t\t\tif(graph[e.to][e.rev].cap==1) ft=true;\n\t\t\te.cap=0,graph[e.to][e.rev].cap=0;\n\t\t}\n\t}\n\n\tfor(auto &e:graph[to]){\n\t\tif(e.to==from){\n\t\t\tif(graph[e.to][e.rev].cap==1) tf=true;\n\t\t\te.cap=0,graph[e.to][e.rev].cap=0;\n\t\t}\n\t}\n\n\tif(ft&&flow(from,to)==1) return 0;\n\tif(tf&&flow(to,from)==1) return 0;\n\n\tif(ft)flow(t,to),flow(from,s);\n\tif(tf)flow(t,from),flow(to,s);\n\treturn -1;\n}\n\nint main(void){\n\tint n,m,q;\n\tcin >> n >> m >> q;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b ;\n\t\tadd_edge(a-1,b-1,1);\n\t\tadd_edge(b-1,a-1,1);\n\t}\n\tint sum=max_flow(0,n-1);\n\trep(loop,q){\n\t\tint type,a,b;\n\t\tcin >> type >> a >> b;\n\t\tif(type==1)\n\t\t\tsum+=add(a-1,b-1,0,n-1);\n\t\telse\n\t\t\tsum+=erase(a-1,b-1,0,n-1);\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nnamespace{\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nstatic const int INF=1<<24;\nvvint vv;\n\nint flow(int n,int a,int b,int c){\n\tint ret=0;\n\twhile(1){\n\t\tqueue<int> q;\n\t\tq.push(a);\n\t\tvint used(n,-1);\n\t\tused[a]=a;\n\t\twhile(!q.empty()){\n\t\t\tint t=q.front();\n\t\t\tq.pop();\n\t\t\trep(i,n){\n\t\t\t\tif(used[i]<0&&vv[t][i]>0){\n\t\t\t\t\tused[i]=t;\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(used[b]>=0) break;\n\t\t}\n\t\tif(used[b]<0) return ret;\n\t\tfor(int i=b;i!=used[i];i=used[i]){\n\t\t\t--vv[used[i]][i];\n\t\t\t++vv[i][used[i]];\n\t\t}\n\t\tret++;\n\t\tif(c) return ret;\n\t}\n\treturn ret;\n}\nvoid mainmain(){\n\tint n,e,q;\n\twhile(cin>>n>>e>>q){\n\t\tvint v(n,INF);\n\t\tinitvv(vv,n,n,0);\n\t\trep(i,e){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a][b]=1;\n\t\t\tvv[b][a]=1;\n\t\t}\n\t\tint ans=flow(n,0,n-1,0);\n\t\trep(i,q){\n\t\t\tint r,a,b;\n\t\t\tcin>>r>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(r==2){\n\t\t\t\trep(i,2){\n\t\t\t\t\tif(vv[b][a]==2){\n\t\t\t\t\t\tvv[b][a]=0;\n\t\t\t\t\t\tif(flow(n,a,b,1)) continue;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t\tflow(n,n-1,b,1);\n\t\t\t\t\t\tflow(n,a,0,1);\n\t\t\t\t\t}\n\t\t\t\t\tswap(a,b);\n\t\t\t\t}\n\t\t\t\tvv[a][b]=0;\n\t\t\t\tvv[b][a]=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvv[a][b]=1;\n\t\t\t\tvv[b][a]=1;\n\t\t\t\tans+=flow(n,0,n-1,1);\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n#define delete_vec(v,n); v.erase(remove(v.begin(),v.end(),n),v.end());\n\nint N,E,Q;\nvector<vector<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    int to = edge[from][i];\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(b);\n  edge[b].push_back(a);\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  delete_vec(edge[a],b);\n  delete_vec(edge[b],a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n    }\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    //*/\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if (i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nbool dfs(int now, int t, vector<bool> &sel, vector<int> &pr, const vvi &g) {\n  if(now == t) return true;\n  bool res = false;\n  for(int i=0;i<((int)(g.size()));++i) {\n    if(g[now][i] == 0) continue;\n    if(!sel[i]) {\n      sel[i] = true;\n      int tmp = pr[i];\n      pr[i] = now;\n      bool tmp2 = dfs(i, t, sel, pr, g);\n      if(tmp2) {\n        res = true;\n        break;\n      }\n      pr[i] = tmp;\n    }\n  }\n  return res;\n}\nbool heiro(int now, int t, vector<bool> &sel, vector<int> &pr, const vvi &g) {\n  bool res = false;\n  for(int i=0;i<((int)(g.size()));++i) {\n    if(g[now][i] == 0) continue;\n    if(i == t) {\n      pr[i] = now;\n      return true;\n    } else if(!sel[i]) {\n      sel[i] = true;\n      int tmp = pr[i];\n      pr[i] = now;\n      bool tmp2 = heiro(i, t, sel, pr, g);\n      if(tmp2) {\n        return true;\n      }\n      pr[i] = tmp;\n    }\n  }\n  return false;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, e, q;\n  cin >> n >> e >> q;\n  vvi g(n, vi(n, 0));\n  for(int i=0;i<(e);++i) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    g[u][v]++;\n    g[v][u]++;\n  }\n  int flow = 0;\n  while(1) {\n    vector<bool> sel(n, false);\n    vi pr(n, -1);\n    sel[0] = true;\n    bool res = dfs(0, n-1, sel, pr, g);\n    if(res == 0) break;\n    int pos = n-1;\n    while(pr[pos] != -1) {\n      g[pr[pos]][pos]--;\n      g[pos][pr[pos]]++;\n      pos = pr[pos];\n    }\n    flow++;\n  }\n  for(int _=0;_<(q);++_) {\n    int t, u, v; cin >> t >> u >> v;\n    u--; v--;\n    if(t == 1) {\n      g[u][v]++;\n      g[v][u]++;\n      vector<bool> sel(n, false);\n      vi pr(n, -1);\n      sel[0] = true;\n      bool res = dfs(0, n-1, sel, pr, g);\n      if(res) {\n        int pos = n-1;\n        while(pr[pos] != -1) {\n          g[pr[pos]][pos]--;\n          g[pos][pr[pos]]++;\n          pos = pr[pos];\n        }\n        flow++;\n      }\n    } else {\n      if(g[u][v] == 1 && g[v][u] == 1) {\n        g[u][v] = g[v][u] = 0;\n      } else {\n        if(g[v][u] == 2) swap(u, v);\n        vector<bool> sel(n, false);\n        vi pr(n, -1);\n        sel[u] = true;\n        sel[v] = true;\n        pr[v] = u;\n        bool res = heiro(v, u, sel, pr, g);\n        if(!res) {\n          for(int i=0;i<(n);++i) sel[i] = false, pr[i] = -1;\n          sel[n-1] = true;\n          bool res = dfs(n-1, 0, sel, pr, g);\n          assert(res);\n          int pos = 0;\n          while(pr[pos] != -1) {\n            g[pr[pos]][pos]--;\n            g[pos][pr[pos]]++;\n            pos = pr[pos];\n          }\n          flow--;\n          for(int i=0;i<(n);++i) sel[i] = false, pr[i] = -1;\n          sel[u] = true;\n          sel[v] = true;\n          pr[v] = u;\n          heiro(v, u, sel, pr, g);\n        }\n        int pos = u;\n        while(pr[pos] != u) {\n          g[pr[pos]][pos]--;\n          g[pos][pr[pos]]++;\n          pos = pr[pos];\n        }\n        g[u][v]--;\n        g[v][u]++;\n        assert(g[u][v] == 1 && g[v][u] == 1);\n        g[u][v] = 0;\n        g[v][u] = 0;\n      }\n    }\n    cout << flow << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    used[v]=true;\n    if(v==t)return f;\n    for(auto &e:G[v]){\n        if(e.cap==0||used[e.to])continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\nstruct test{\n    int x;\n};\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    int f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            add_edge(a,b,1);\n            add_edge(b,a,1);\n            f+=max_flow(0,N-1);\n        }\n        else{\n            rep(beet,2){\n                for(int i=0;i<G[a].size();i++){\n                    edge &e=G[a][i];\n                    if(e.type==0||e.to!=b)continue;\n                    if(e.cap==1){\n                        e.cap=0;\n                        e.type=0;\n                        continue;\n                    }\n\n                    int t=max_flow(a,b);\n                    if(t==1){\n                        e.type=0;\n                        G[e.to][e.rev].cap=0;\n                        continue;\n                    }\n\n                    add_edge(0,N-1,1);\n                    t=max_flow(a,b);\n\n                    f--;\n                    G[0].pop_back();G[N-1].pop_back();\n\n                    G[a][i].type=0;\n                    G[G[a][i].to][G[a][i].rev].cap=0;\n                }\n\n                f+=max_flow(0,N-1);\n                swap(a,b);\n            }\n        }\n\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            //assert(G[from][tot].cap == 0  && G[to][tof].cap == 0);\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n        \n    }\n    int res = fl.getmaxflow(0, N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 0){\n                // edge is not used\n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.getmaxflow(N-1, a, 1);\n                    fl.getmaxflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.getmaxflow(N-1, b, 1);\n                    fl.getmaxflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1, INF);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,cap,flow;\n\tEdge(){}\n\tEdge(int s,int d,int c,int f=0):src(s),dst(d),cap(c),flow(f){}\n};\nstruct Graph{\n\tvector<Edge> es;\n\tvi head,next;\n\tGraph(){}\n\tGraph(int n):head(n,-1){}\n\t// 有向辺を追加するとき逆辺の容量c2は普通0である．\n\t// 両方向に容量があるならc2も指定する．\n\tvoid AddEdge(int u,int v,int c1,int c2=0){\n\t\tes.emplace_back(u,v,c1); next.push_back(head[u]); head[u]=es.size()-1;\n\t\tes.emplace_back(v,u,c2); next.push_back(head[v]); head[v]=es.size()-1;\n\t}\n};\n\nvoid BFS(const Graph& g,int tap,vi& layer)\n{\n\tqueue<pii> q; q.emplace(tap,0);\n\twhile(q.size()){\n\t\tint u,d; tie(u,d)=q.front(); q.pop();\n\t\tif(layer[u]!=INF) continue;\n\t\tlayer[u]=d;\n\t\tfor(int i=g.head[u];i!=-1;i=g.next[i])\n\t\t\tif(g.es[i].cap-g.es[i].flow>0)\n\t\t\t\tq.emplace(g.es[i].dst,d+1);\n\t}\n}\n\nint DFS(Graph& g,int v,int sink,const vi& layer,int flow)\n{\n\tif(v==sink) return flow;\n\tint f=flow;\n\tfor(int& i=g.head[v];i!=-1;i=g.next[i]){\n\t\tEdge& e=g.es[i];\n\t\tif(layer[e.src]>=layer[e.dst]) continue;\n\t\tint residue=e.cap-e.flow;\n\t\tif(residue==0) continue;\n\t\tint augment=DFS(g,e.dst,sink,layer,min(residue,f));\n\t\te.flow+=augment;\n\t\tg.es[i^1].flow-=augment;\n\t\tf-=augment;\n\t\tif(f==0) break;\n\t}\n\treturn flow-f;\n}\n\nint Dinic(Graph& g,int tap,int sink)\n{\n\tint res=0;\n\tfor(int n=g.head.size();;){\n\t\tvi layer(n,INF);\n\t\tBFS(g,tap,layer);\n\t\tif(layer[sink]==INF) break;\n\t\tvi temp=g.head;\n\t\tres+=DFS(g,tap,sink,layer,INF);\n\t\tswap(g.head,temp);\n\t}\n\treturn res;\n}\n\nbool modify(Graph& g,int p,int v,int sink,int flow)\n{\n\t//dump(mp(p,v));\n\tif(v==sink) return true;\n\tfor(int i=g.head[v];i!=-1;i=g.next[i]){\n\t\tif(g.es[i].dst!=p && g.es[i].flow==-flow){\n\t\t\tif(modify(g,g.es[i].src,g.es[i].dst,sink,flow)){\n\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n,m,q;cin>>n>>m>>q && n|m|q;){\n\t\t//dump(vi({n,m,q}));\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg.AddEdge(u,v,1,1);\n\t\t}\n\t\trep(_,q){\n\t\t\tint t,u,v; cin>>t>>u>>v; u--,v--;\n\t\t\tif(t==1){\n\t\t\t\tg.AddEdge(u,v,1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint i;\n\t\t\t\tfor(i=g.head[u];i!=-1;i=g.next[i])\n\t\t\t\t\tif(g.es[i].dst==v && g.es[i].cap==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\tg.es[i].cap=g.es[i^1].cap=0;\n\t\t\t\tif(g.es[i].flow){\n\t\t\t\t\tif(g.es[i].flow==-1) swap(u,v);\n\t\t\t\t\tg.es[i].flow=g.es[i^1].flow=0;\n\t\t\t\t\tassert(modify(g,u,v,n-1,-1));\n\t\t\t\t\tassert(modify(g,v,u,0,1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tDinic(g,0,n-1);\n\t\t\t//for(int i=0;i<n;i++){\n\t\t\t//\tprintf(\"%d:\",i);\n\t\t\t//\tfor(int j=g.head[i];j!=-1;j=g.next[j]){\n\t\t\t//\t\tEdge e=g.es[j];\n\t\t\t//\t\tprintf(\" (%d,%d/%d)\",e.dst,e.flow,e.cap);\n\t\t\t//\t}\n\t\t\t//\tputs(\"\");\n\t\t\t//}\n\t\t\tint res=0;\n\t\t\tfor(int j=g.head[0];j!=-1;j=g.next[j])\n\t\t\t\tres+=g.es[j].flow;\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 500; // TODO:initialize\nconst int F_INF = 19191919; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint main()\n{\n    int n,e,q;\n    scanf(\" %d %d %d\", &n, &e, &q);\n    rep(i,e)\n    {\n        int f,t;\n        scanf(\" %d %d\", &f, &t);\n        --f;\n        --t;\n        add_edge(f,t,1);\n    }\n\n    int f = max_flow(0,n-1);\n    while(q--)\n    {\n        int m,a,b;\n        scanf(\" %d %d %d\", &m, &a, &b);\n        --a;\n        --b;\n        if(m==1)\n        {\n            bool found = false;\n            rep(i,G[a].size())if(G[a][i].to==b)\n            {\n                G[a][i].cap = 1;\n                G[b][G[a][i].rev].cap = 1;\n                assert(G[b][G[a][i].rev].to == a);\n                found = true;\n                break;\n            }\n\n            if(!found) add_edge(a,b,1);\n            f += max_flow(0,n-1);\n        }\n        else\n        {\n            int id = -1;\n            rep(i,G[a].size())\n            {\n                if(G[a][i].to==b)\n                {\n                    id = i;\n                    int CAP = G[a][i].cap;\n                    if(CAP==2)\n                    {\n                        id = G[a][i].rev;\n                        swap(a,b);\n                    }\n                    break;\n                }\n            }\n\n            assert(G[b][G[a][id].rev].to == a);\n            assert(id!=-1);\n            if(G[a][id].cap==0)\n            {\n                --f;\n                int now = a;\n                while(now!=0)\n                {\n                    rep(i,G[now].size())\n                    {\n                        if(G[now][i].cap==2)\n                        {\n                            int nx = G[now][i].to;\n                            G[now][i].cap = 1;\n                            G[nx][G[now][i].rev].cap = 1;\n\n                            now = nx;\n                            break;\n                        }\n                    }\n                }\n\n                now = b;\n                while(now!=n-1)\n                {\n                    rep(i,G[now].size())\n                    {\n                        if(G[now][i].cap==0)\n                        {\n                            int nx = G[now][i].to;\n                            G[now][i].cap = 1;\n                            G[nx][G[now][i].rev].cap = 1;\n\n                            now = nx;\n                            break;\n                        }\n                    }\n                }\n            }\n            G[a][id].cap = 0;\n            G[b][G[a][id].rev].cap = 0;\n            f += max_flow(0,n-1);\n        }\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, cap, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n          max_flow(from, 0, 1);\n          max_flow(graph.size() - 1, to, 1);\n          return(1);\n        } else {\n          return(0);\n        }\n      }\n    }\n  }\n  void remove_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        graph[e.to][e.rev].alive = false;\n        return;\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n      graph.remove_edge(A, B);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return true;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\ttmp=maxFlow(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_V = 550;\nconstexpr int INF = (1 << 29);\n\nint N;\nint cap[MAX_V][MAX_V];\nbool G[MAX_V][MAX_V];\nbool used[MAX_V];\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    used[v] = 1;\n    for (int i = 0; i < N; i++) {\n        if (!used[i] && cap[v][i] > 0) {\n            int d = dfs(i, t, min(f, cap[v][i]));\n            if (d > 0) {\n                cap[v][i] -= d;\n                cap[i][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint one_flow(int s, int t)\n{\n    memset(used, 0, sizeof(used));\n    return dfs(s, t, 1);\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nvoid add_edge(int from, int to)\n{\n    cap[from][to] = cap[to][from] = 1;\n}\n\nvoid remove_edge(int from, int to)\n{\n    cap[from][to] = cap[to][from] = -1;    \n}\n\nint main()\n{\n    int E, Q;\n    cin >> N >> E >> Q;\n    \n    memset(cap, -1, sizeof(cap));\n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        add_edge(F - 1, T - 1);\n    }\n    \n    int f = max_flow(0, N - 1);\n    for (int i = 0; i < Q; i++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A -= 1; B -= 1;\n        if (M == 1) {\n            add_edge(A, B);\n            f += one_flow(0, N - 1);\n        } else {\n            if (cap[A][B] != 0) swap(A, B);\n\n            if (one_flow(A, B) == 0) {\n                one_flow(N - 1, B);\n                one_flow(A, 0);\n                f -= 1;\n            }\n            \n            remove_edge(A, B);\n        }\n        \n        cout << f << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  edge(int a,int b,int c,int d,int e)\n    :from(a),to(b),cost(c),cap(d),rev(e){}\n};\n\nstruct FordFulkerson{\n  int n;\n  vector< vector<edge> > graph;\n  vi use;\n\n  FordFulkerson(int a=0):n(a){\n    graph.resize(a); use.resize(a);\n  }\n\n  void AddEdge(int s,int g,int c,int p){\n    graph[s].pb( edge(s,g,c,p,graph[g].sz) );\n    graph[g].pb( edge(g,s,-c,0,graph[s].sz-1) );\n  }\n\n  void DeleteEdge(int s, int g){\n    int id = -1, rev = -1;\n    rep(e,graph[s].sz){\n      if(graph[s][e].to == g && graph[s][e].cost>0){\n\tid = e; rev = graph[s][e].rev;\n      }\n    }\n    if(id<0)return;\n\n    swap(graph[s][id],graph[s].back());\n    swap(graph[g][rev],graph[g].back());\n\n    edge e = graph[s][id];\n    graph[e.to][e.rev].rev = id;\n    e = graph[g][rev];\n    graph[e.to][e.rev].rev = rev;\n    graph[s].pop_back(); graph[g].pop_back();\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v==t)return f;\n    use[v] = 1;\n    for(edge &e : graph[v]){\n      if(!use[e.to] && e.cap > 0){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int max_flow(int s, int t){\n    int res = 0;\n    for(;;){\n      rep(i,n)use[i] = 0;\n      int f = dfs(s,t,INF);\n      if(!f)return res;\n      res += f;\n    }\n  }\n};\n\nint main(){\n  int n,e,q;\n  cin >> n >> e >> q;\n  FordFulkerson mf(n);\n  rep(i,e){\n    int f,t;\n    cin >> f >> t; f--; t--;\n    mf.AddEdge(f,t,1,1);\n    mf.AddEdge(t,f,1,1);\n  }\n\n  int f = mf.max_flow(0,n-1);\n  rep(i,q){\n    int m,a,b;\n    cin >> m >> a >> b; a--; b--;\n    if(m==1){\n      mf.AddEdge(a,b,1,1);\n      mf.AddEdge(b,a,1,1);\n      f += mf.max_flow(0,n-1);\n    }else{\n      int use = 0;\n      for(edge e : mf.graph[a]){\n\tif(e.to == b && e.cost>0 && e.cap == 0)use = 1;\n      }\n      for(edge e : mf.graph[b]){\n\tif(e.to == a && e.cost>0 && e.cap == 0)use = 2;\n      }\n\n      mf.DeleteEdge(a,b);\n      mf.DeleteEdge(b,a);\n\n      if(use){\n\t//cerr << use << endl;\n\trep(i,n)mf.use[i] = 0;\n\tint another = 0;\n\t/*\n\trep(v,n){\n\t  for(edge e: mf.graph[v]){\n\t    cerr << v << \" \" << e.to << \" \" << e.cost << \" \" << e.cap << endl;\n\t  }\n\t}\n\t*/\n\n\tif(use==1)another = mf.dfs(a,b,1);\n\tif(use==2)another = mf.dfs(b,a,1);\n\t//cerr << another << endl;\n\n\tif(!another){\n\t  rep(i,n)mf.use[i] = 0;\n\t  mf.dfs(a,0,1);\n\t  rep(i,n)mf.use[i] = 0;\n\t  mf.dfs(n-1,b,1);\n\t  f--;\n\t}\n      }\n    }\n\n    cout << f << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 20005;\nconst F MAXF = 1<<29;\n\nstruct MaxFlow {\n    F cap[2*MAXE], flow[2*MAXE];\n    int V, E, level[MAXV], edge[MAXV], seen[MAXV];\n    int prev[2*MAXE], to[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        seen[s] = 1;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == 0 && level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            memset(seen, 0, sizeof(seen));\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]] = mf.flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.cap[e] - mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    if (prev[t] == -1) return 0;\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]]++;\n        mf.flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = mf.edge[s]; e != -1; e = mf.prev[e])\n        if (mf.to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) mf.cap[e] = mf.cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            mf.cap[e] = mf.cap[e^1] = 0;\n            if (mf.flow[e] != 0) {\n                f--;\n                if (mf.flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                mf.flow[e] = mf.flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        add_edge(s,t,1);\n        //add_edge(t,s,1);\n    }\n    rep(i,q){\n        int x, s, t;\n        cin >> x >> s >> t;\n        s--; t--;\n        if(x == 1){\n            add_edge(s,t,1);\n            //add_edge(t,s,1);\n        } else{\n            vector<edge> tmp1;\n            rep(j,G[s].size()){\n                if(G[s][j].to != t) tmp1.push_back(G[s][j]);\n            }\n            G[s] = tmp1;\n            tmp1.clear();\n            vector<edge> tmp2;\n            rep(j,G[t].size()){\n                if(G[t][j].to != s) tmp2.push_back(G[t][j]);\n            }\n            G[t] = tmp2;\n        }\n        rep(j,n) H[j] = G[j];\n        cout << max_flow(0,n-1) << endl;\n        rep(j,n) G[j] = H[j];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, cap, rev; };\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t) {\n        return f;\n    }\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, int flow_=INF) {\n    if (s == t) return 0;\n    int flow = 0;\n    for(;;) {\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, flow_)) > 0) {\n            flow += f;\n            if (flow_ != INF) flow_ -= f;\n        }\n        if (!(flow_ > 0)) return flow;\n    }\n}\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            add_edge(i, j, 0);\n        }\n    }\n    for (int i = 0; i < e; i++) {\n        int f, t;\n        cin >> f >> t;\n        int j = 0;\n        while (G[f][j].to != t) j++;\n        G[f][j].cap = 1;\n        G[t][G[f][j].rev].cap = 1;\n    }\n\n    int f = max_flow(1, n);\n    for (int i = 0; i < q; i++) {\n        int m, a, b;\n        cin >> m >> a >> b;\n        if (m == 1) {\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            G[a][j].cap = 1;\n            G[b][G[a][j].rev].cap = 1;\n            f += max_flow(1, n);\n            cout << f << endl;\n        } else {\n            int from = -1, to = -1;\n            int j = 0;\n            while (G[a][j].to != b) j++;\n            if (G[a][j].cap == 2) from = b, to = a;\n            if (G[b][G[a][j].rev].cap == 2) from = a, to = b;\n            G[a][j].cap = 0;\n            G[b][G[a][j].rev].cap = 0;\n            if (from > 0 &&  to > 0) {\n                if (max_flow(from, to, 1) > 0) {\n                    cout << f << endl;\n                } else {\n                    f--;\n                    max_flow(from, 1);\n                    max_flow(n, to);\n                    cout << f << endl;\n                }\n            }\n            else cout << f << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Dinic\n{\n  const int INF = 1 << 30;\n \n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter, used;\n  int flow;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front(); que.pop();\n      for(const edge& e : graph[p]) {\n        if(!e.alive) continue;\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return(min_cost[t] != -1);\n  }\n   \n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    for(int i = iter[idx]; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      int f = 0;\n      while((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    bool flag = false;\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to) == 0) {\n            max_flow(graph.size() - 1, 0);\n            max_flow(from, to);\n            flag = true;\n          }\n        } else if(re.cap == 0) {\n          if(max_flow(to, from) == 0) {\n            max_flow(graph.size() - 1, 0);\n            max_flow(to, from);\n            flag = true;\n          }\n        }\n        e.rev = re.rev = false;\n        return(flag);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n    }\n    flow += graph.max_flow(0, N - 1);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    // s->t 増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[e.to][eid[e.to][s]];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    vector<vector<int>> eid;\n    MaximamFlow(int V):V(V){\n        G=Graph(V);\n        eid=vector<vector<int>>(V,vector<int>(V,-1));\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n    \tif(eid[s][t]<0){\n    \t\teid[s][t]=G[s].size();\n    \t\tG[s].push_back({t,0,0});\n    \t}\n    \tG[s][eid[s][t]].icap=cap;\n    \tG[s][eid[s][t]].cap=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        if(eid[s][t]<0)add_edge(s,t,c);\n        if(eid[t][s]<0)add_edge(t,s,c);\n\n        Edge& e =G[s][eid[s][t]];Edge& reve = G[t][eid[t][s]];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n        \te.cap += c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n        \te.cap -= e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n        \tFlow d = e.icap - e.cap - c;\n            e.cap = 0;reve.cap = 0;\n            //(1) S <- s <- t <- T のフローを戻す\n            Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) (1)で流せない分は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n\n        \t// Flow revd = max_flow(s,t,d);\n         //    max_flow(T,S,d-revd);\n         //    assert(max_flow(s,t,d-revd)==d-revd);\n         //    flow -= d-revd;\n\n            e.cap = 0;reve.cap = c + reve.icap;\n            e.icap = c;\n        }\n        // flow+=max_flow(S,T);\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)if(es[s][t])mf.add_edge(s,t,es[s][t]);\n\n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--;\n\n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                flow+=mf.max_flow(0,N-1);\n                cout << flow <<endl;\n            }\n        }\n\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      add_edge(a,b,1);\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n    }\n    for(int i=1;i<=N;i++) G[i]=G2[i];\n    cout<<max_flow(1,N)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef unordered_map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1) g[a][b]=g[b][a]=1,flow+=max_flow(0,n-1);\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b))flow--,check(a,0),check(n-1,b);\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int a,int b,int c):to(a),cap(b),rev(c){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,cap,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t,int lim){\n    int f=0;\n    while(lim){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,lim);\n        if(ff==0)return f;\n        f+=ff;\n        lim-=ff;\n    }\n    return f;\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    f+=max_flow(0,N-1,INF);\n}\n\nvoid q2(int a,int b){\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.to!=b||e.cap!=2)continue;\n        f2=true;\n        e.cap=0;\n    }\n    for(auto &e:G[b]){\n        if(e.to!=a||e.cap!=2)continue;\n        f1=true;\n        e.cap=0;\n    }\n    if(f1&&f2)assert(0);\n    if(!f1&&!f2)return;\n\n    if(f2)swap(a,b);\n\n\n    int tmp=max_flow(a,b,1);\n\n    if(tmp)return;\n\n    add_edge(0,N-1,1);\n    tmp=max_flow(a,b,1);\n    assert(tmp);\n    G[0].pop_back();\n    G[N-1].pop_back();\n    f--;\n\n    f+=max_flow(0,N-1,INF);\n}\n\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n    }\n\n    f=max_flow(0,N-1,INF);\n\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n            /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.cap==2)cout<<e.to+1<<\" \"<<i+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nint INF = 1 << 20;\n#define MAX_V 500\n\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<vector<edge>> G( MAX_V ); // ??°???????????£??\\???????????¨???\nbool used[MAX_V]; // DFS??§?????§??????????????????????????°\n\t\t\t\t  // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge( int from, int to, int cap ) {\n\tedge a{to, cap, G[to].size()};\n\tedge b{from, 0, G[from].size() - 1};\n\tG[from].push_back( a );\n\tG[to].push_back( b );\n}\n\nvoid del_edge( int from, int to ) {\n\tauto ite = G[from].begin();\n\twhile( ite < G[from].end() ) {\n\t\tif( ( *ite ).to == to ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n\n\n\tite = G[to].begin();\n\twhile( ite < G[to].end() ) {\n\t\t//cout << to << \" \" << ( *ite ).to << \" \" << ( *ite ).cap << endl;\n\t\tif( ( *ite ).to == from ) {\n\t\t\t( *ite ).cap = 0;\n\t\t}\n\t\tite++;\n\n\t}\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs( int v, int t, int f ) {\n\tif( v == t ) return f;\n\tused[v] = true;\n\tfor( int i = 0; i < G[v].size(); i++ ) {\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0 ) {\n\t\t\tint d = dfs( e.to, t, min( f, e.cap ) );\n\t\t\tif( d > 0 ) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow( int s, int t ) {\n\tfor( size_t i = 0; i < MAX_V; i++ ) {\n\t\tused[i] = false;\n\t}\n\tint flow = 0;\n\tfor( ;;) {\n\t\tmemset( used, 0, sizeof( used ) );\n\t\tint f = dfs( s, t, INF );\n\t\tif( f == 0 ) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n\tlong long int N, E, Q;\n\tcin >> N >> E >> Q;\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int F, T;\n\t\tcin >> F >> T;\n\t\tF--; T--;\n\t\tadd_edge( F, T, 1 );\n\t\tadd_edge( T, F, 1 );\n\t}\n\tfor( size_t i = 0; i < Q; i++ ) {\n\t\tlong long int M, A, B;\n\t\tcin >> M >> A >> B;\n\t\tA--; B--;\n\t\tif( M == 1 ) {\n\t\t\tadd_edge( A, B, 1 );\n\t\t\tadd_edge( B, A, 1 );\n\t\t} else {\n\t\t\tdel_edge( A, B );\n\t\t}\n\t\tauto memo = G;\n\t\tcout << max_flow( 0, N - 1 ) << endl;\n\t\tG = memo;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 21005;\nconst F MAXF = 1<<29;\n\nF cap[2*MAXE], flow[2*MAXE];\nint level[MAXV], edge[MAXV], seen[MAXV], to[2*MAXE];\n\nstruct MaxFlow {\n    int V, E, prev[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        seen[s] = 1;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == 0 && level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            memset(seen, 0, sizeof(seen));\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[to[e]] == -1 && flow[e] > 0) {\n                prev[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        flow[use_edge[v]] = flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[to[e]] == -1 && cap[e] - flow[e] > 0) {\n                prev[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    if (prev[t] == -1) return 0;\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        flow[use_edge[v]]++;\n        flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = edge[s]; e != -1; e = mf.prev[e])\n        if (to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) cap[e] = cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            assert(e >= 0);\n            cap[e] = cap[e^1] = 0;\n            if (flow[e] != 0) {\n                f--;\n                if (flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                flow[e] = flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        add_edge(s,t,1);\n        add_edge(t,s,1);\n    }\n    rep(i,q){\n        int x, s, t;\n        cin >> x >> s >> t;\n        s--; t--;\n        if(x == 1){\n            add_edge(s,t,1);\n            add_edge(t,s,1);\n        } else{\n            vector<edge> tmp1;\n            rep(j,G[s].size()){\n                if(G[s][j].to != t) tmp1.push_back(G[s][j]);\n            }\n            G[s] = tmp1;\n            tmp1.clear();\n            rep(j,G[t].size()){\n                if(G[t][j].to != s) tmp1.push_back(G[t][j]);\n            }\n            G[t] = tmp1;\n        }\n        rep(j,n) H[j] = G[j];\n        cout << max_flow(0,n-1) << endl;\n        rep(j,n) G[j] = H[j];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, cap, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int u, int v){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == v){\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\treturn dinic(s, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false and \"invalid u, v\");\n\t\t\treturn -INF;\n\t\t}\n\t\tint subCapacity(int s, int t, int u, int V){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == V){\n\t\t\t\t\tint d = e.cap;\n\t\t\t\t\te.cap = G[V][e.rev].cap = 0;\n\t\t\t\t\tif(d == 1) return 0;\n\t\t\t\t\tif(d == 2){\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs_(V, u, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs_(t, u, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs_(V, s, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tif(dfs_(u, V, 1)) return 0;\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs_(t, V, 1);\n\t\t\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\t\t\tdfs_(u, s, 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -INF;\n\t\t}\n\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]){\n\t\t\tflow.addEdge(a[i], b[i], 0);\n\t\t\tuse[a[i]][b[i]] = use[b[i]][a[i]] = true;\n\t\t}\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s,0,INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.dinic(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1) ans += flow.addCapacity(s, t, a[i], b[i]);\n\t\telse ans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint G[511][511];\nint rG[511][511];\n \nbool used[511];\n \nint N,E,Q;\n \n#define INF ( 1<<30)\n \nvoid add_edge(int a,int b){\n  G[a][b] = 1; rG[b][a] = 0;\n  G[b][a] = 1; rG[a][b] = 0;\n}\n \nvoid rem_edge(int a,int b){\n  G[a][b] = 0; rG[b][a] = 0;\n  G[b][a] = 0; rG[a][b] = 0;\n}\n \nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<N;i++){\n    if( !used[i] && G[v][i] > 0 ) {\n      int d = dfs(i, t, min( f, G[v][i] ) );\n      if( d > 0 ){\n\tG[v][i] -= d;\n\trG[i][v] += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n \n \nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n  return flow;\n}\n \nvoid rdfs(int s,int t){\n  if( s == t ) return ;\n  for(int i=0;i<N;i++){\n    if( rG[s][i] == 1 ){\n      rG[s][i] = 0;\n      G[i][s] = 1;\n      rdfs(i,t);\n    }\n  }\n}\n \nint main(){\n  cin  >> N >> E >> Q;\n  for(int i=0;i<E;i++){\n    int e,f;\n    cin >> e >> f;\n    --e; --f;\n    add_edge(e,f);\n  }\n  int rflow = max_flow(0,N-1);\n  for(int i=0;i<Q;i++){\n    int m,a,b;\n    int nf;\n    cin >>m>> a>> b;\n    --a; --b;\n    if( m == 1 ){\n      add_edge(a,b);\n      nf = max_flow(0,N-1);\n    } else {\n      if( rG[a][b] == 1 ){\n\trem_edge(a,b);\n\tint d = max_flow(b,a);\n\tif( d == 0 ){\n\t  rdfs(N-1,a);\n\t  rdfs(b,0);\n\t  rflow--;\n\t  nf = max_flow(0,N-1);\n\t}\n      } else if( rG[b][a] == 1 ){\n\trem_edge(a,b);\n\tint d = max_flow(a,b);\n\tif( d == 0 ){\n\t  rdfs(N-1,b);\n\t  rdfs(a,0);\n\t  rflow--;\n\t  nf = max_flow(0,N-1);\n\t}\n      } else {\n\trem_edge(a,b);\n\tnf = max_flow(0,N-1);\n      }     \n    }\n    rflow += nf;\n    cout << rflow << endl;\n  }\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[601];\nint level[601];\nint iter[601];\nint data[601][601];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,cap,G[from].size()-1));\n\tdata[from][to]=G[from].size()-1;\n\tdata[to][from]=G[to].size()-1;\n}\n\nvoid change_flow(int from,int to,int cap){\n\tif(cap==1){\n\t\tG[from][data[from][to]].cap=1;\n\t\tG[to][data[to][from]].cap=1;\n\t}else{\n\t\tG[from][data[from][to]].cap=0;\n\t\tG[to][data[to][from]].cap=0;\n\t}\n}\n\nint check_flow(int from,int to){\n\treturn G[from][data[from][to]].cap;\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nvoid send_flow(int s,int t,int cap){\n\tint flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0)return;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,cap))>0){\n\t\t\tcap-=f;\n\t\t\tif(cap==0)return;\n\t\t}\n\t}\n}\n\nint n,m,q;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tmemset(data,-1,sizeof(data));\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tadd_edge(f,t,1);\n\t}\n\tint res=0;\n\tfor(int i=0;i<q;i++){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tif(t==1){\n\t\t\tif(data[a][b]==-1)add_edge(a,b,1);\n\t\t\telse{\n\t\t\t\tchange_flow(a,b,1);\n\t\t\t}\n\t\t\tres+=max_flow(0,n-1);\n\t\t}else{\n\t\t\tint type=check_flow(a,b);\n\t\t\tchange_flow(a,b,0);\n\t\t\tif(type==0){\n\t\t\t\tsend_flow(a,0,1);\n\t\t\t\tsend_flow(n-1,b,1);\n\t\t\t\tres--;\n\t\t\t}else if(type==2){\n\t\t\t\tsend_flow(b,0,1);\n\t\t\t\tsend_flow(n-1,a,1);\n\t\t\t\tres--;\n\t\t\t}\n\t\t\tres+=max_flow(0,n-1);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= cp)continue;\n\t\t//if(ok[s][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\tok[s][i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = (used[i][j] != used[j][i]);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 0;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 0;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n \nusing i64 = long long;\n \nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 rev;\n    bool alive;\n  };\n \n  int n;\n  vector<vector<edge>> edges;\n \n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n \n  int size() const { return n; }\n \n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n \nstruct Dinic_Reverse {\n  int N;\n  vector<int> level;\n  vector<int> itr;\n  Graph G;\n \n  Dinic_Reverse(int n) : G(n) { N = n; }\n \n  void add_edge(int from, int to, i64 cap, i64 rev_cap) {\n    G[from].push_back({to, cap, (int)G[to].size(),true});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1,true});\n  }\n \n  bool g_level(int s, int t) {\n    level.assign(N, -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (auto &e : G[v]) {\n          if(!e.alive) continue;\n        if (e.cap > 0 && level[e.to] == -1) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] >= 0;\n  }\n \n  i64 dfs(int v, int t, i64 f) {\n    if (v == t)\n      return f;\n \n    for (int &i = itr[v]; i < (int)G[v].size(); i++) {\n      auto &e = G[v][i];\n      if(!e.alive) continue;\n      if (e.cap > 0 && level[e.to] > level[v]) {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0) {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n \n  i64 max_flow(int s, int t , i64 limit = 1e9) {\n    i64 result = 0;\n    i64 flow;\n    while (g_level(s, t) && limit > 0) {\n      itr.assign(N, 0);\n      while ((flow = dfs(s, t, limit)) > 0)\n      {\n        result += flow;\n        limit -= flow;\n      }\n    }\n    return result;\n  }\n \n  bool back_edge(int from,int to,int s,int t){\n      for(auto& e : G[from]){\n          if(e.to == to && e.alive){\n              e.alive = false;\n              if(e.cap == 0 && max_flow(from, to, 1) == 0){\n                  max_flow(from, s, 1);\n                  max_flow(t,to,1);\n                  return 1;\n              }\n              else{\n                  return 0;\n              }\n          }\n      }\n  }\n};\n \n/*\n \nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\nint n;\nint e;\nint q;\n \nint main(){\n    cin >> n >> e >> q;\n    Dinic_Reverse dinic(n);\n    int s = 0;\n    int t = n - 1;\n    for(int i = 0;i < e;i++){\n        int a,b;;\n        cin >> a >> b;\n    a--;\n    b--;\n        dinic.add_edge(a, b , 1, 1);\n    }\n    int flow = dinic.max_flow(s, t );\n    for(int i = 0;i < q;i++){\n        int m,a,b;\n        cin >> m >> a >> b;\n        a--;\n        b--;\n        if(m == 1){\n            dinic.add_edge(a , b, 1 , 1);\n            flow += dinic.max_flow(s , t , 1);\n        }\n        else{\n            flow -= dinic.back_edge(a, b , s , t);\n            flow -= dinic.back_edge(b, a, s , t);\n        }\n        cout << flow << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\t//tmp=maxFlow(n,from,to);\n\ttmp=fordFulkerson(n,to,from,1);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,from,s);\n\t  assert(fordFulkerson(n,s,from,1) == 1);\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,t,to);\n\t  assert(fordFulkerson(n,to,t,1) == 1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\ttmp=maxFlow(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,from,s);\n\t  fordFulkerson(n,s,from,1);\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,t,to);\n\t  fordFulkerson(n,to,t,1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct FordFulkerson {\n\tusing Flow = int;\n\tint n;\n\tint s, t;\n\tFlow maxflow;\n\tvector<vector<Flow>> g;\n\tvector<bool> used;\n\tFordFulkerson(int n, int s = -1, int t = -1) :n(n), g(n, vector<Flow>(n)), used(n), s(s), t(t), maxflow(0) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from][to] = cap;\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\taddArc(a, b, cap);\n\t\taddArc(b, a, cap);\n\t}\n\t// ??¨???????????????????¢?????????????????????????????????????????????§???????????? O(V^2)? ??§?±???????\n\tFlow addEdgeCap(int a, int b, Flow cap) {\n\t\tif (cap > 0) {\n\t\t\tg[a][b] += cap;\n\t\t\tg[b][a] += cap;\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tmaxflow += augment(s, t, cap);\n\t\t}\n\t\telse {\n\t\t\tFlow rcap = -cap;\n\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\tg[a][b] -= rcap;\n\t\t\t\tg[b][a] -= rcap;\n\t\t\t}\n\t\t\t// ????????????????????????????????????\n\t\t\telse {\n\t\t\t\t// ??¢?????? (a,b) ?????????????????????????????????????????±???\n\t\t\t\tif (g[a][b] > g[b][a])swap(a, b);\n\t\t\t\t// ??¢?????? (b,a) ????????????????????????????????????\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tFlow f = augment(a, b, a, b, rcap);\n\t\t\t\t// ?????????????????´???\n\t\t\t\tif (f < rcap) {\n\t\t\t\t\t// ????????????\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\taugment(b, a, b, a, f);\n\t\t\t\t\t// sink ?????? source ?????????????????£??????????????????\n\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\tmaxflow -= augment(t, s, rcap - f);\n\t\t\t\t\tif (g[a][b] - rcap >= 0 && g[b][a] - rcap >= 0) {\n\t\t\t\t\t\tg[a][b] -= rcap;\n\t\t\t\t\t\tg[b][a] -= rcap;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\t\t\taugment(a, b, a, b, rcap);\n\t\t\t\t\t\tg[a][b] += rcap; g[a][b] -= rcap;\n\t\t\t\t\t\tg[b][a] -= rcap; g[b][a] -= rcap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tg[a][b] += rcap; g[a][b] -= rcap;\n\t\t\t\t\tg[b][a] -= rcap; g[b][a] -= rcap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tFlow f = augment(s, t, INF);\n\t\t\tif (f == 0)return maxflow += total;\n\t\t\ttotal += f;\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t// ??¢?????? (a,b) ???????????? f ?????????\n\tFlow augment(int v, int t, int a, int b, Flow f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tfor (int to = 0; to < n; to++) {\n\t\t\tif (v == a&&to == b)continue;\n\t\t\tif (!used[to] && g[v][to] > 0) {\n\t\t\t\tFlow d = augment(to, t, min(f, g[v][to]));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tg[v][to] -= d;\n\t\t\t\t\tg[to][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, E, Q; cin >> N >> E >> Q;\n\tFordFulkerson ff(N, 0, N - 1);\n\trep(i, 0, E) {\n\t\tint F, T; cin >> F >> T; F--, T--;\n\t\tff.addEdge(F, T, 1);\n\t}\n\tff.maximumFlow(0, N - 1);\n\trep(i, 0, Q) {\n\t\tint M, A, B; cin >> M >> A >> B;\n\t\tA--, B--;\n\t\tif (M == 1) {\n\t\t\tcout << ff.addEdgeCap(A, B, 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ff.addEdgeCap(A, B, -1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct max_flow{\n    vector<vector<int>> graph;\n    vector<bool> done;\n    int size,flow;\n    max_flow(int size_):size(size_),graph(size_,vector<int>(size_)),done(size_),flow(0){}\n    void add_edge(int from,int to,int cap){\n        graph[from][to]=graph[to][from]=cap;\n    }\n    int dfs(int v,int t,int f){\n        if(v==t) return f;\n        done[v]=true;\n        for(int w=0; w<size; ++w){\n            if(done[w] or graph[v][w]==0) continue;\n            int d=dfs(w,t,min(f,graph[v][w]));\n            if(d>0){\n                graph[v][w]-=d;\n                graph[w][v]+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int calc_max_flow(int s,int t){\n        while(true){\n            fill(done.begin(),done.end(),false);\n            int f=dfs(s,t,inf);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nvoid solve(){\n    int n,e,q;\n    cin >> n >> e >> q;\n    max_flow mf(n);\n    rep(i,0,e){\n        int f,t;\n        cin >> f >> t;\n        --f;\n        --t;\n        mf.add_edge(f,t,1);\n    }\n    mf.calc_max_flow(0,n-1);\n    auto search_path=[&](int s,int t,int c){\n        vector<int> from(n);\n        vector<bool> done(n);\n        queue<int> que;\n        que.push(s);\n        done[s]=true;\n        while(!que.empty()){\n            int u=que.front();\n            que.pop();\n            if(u==t){\n                vector<int> res;\n                int v=u;\n                while(v!=s){\n                    res.push_back(v);\n                    v=from[v];\n                }\n                res.push_back(s);\n                reverse(res.begin(),res.end());\n                return res;\n            }\n            rep(v,0,n){\n                if(done[v]) continue;\n                if(c==1){\n                    if(mf.graph[u][v]==0) continue;\n                }else{\n                    if(mf.graph[u][v]!=0 or mf.graph[v][u]!=2) continue;\n                }\n                que.push(v);\n                done[v]=true;\n                from[v]=u;\n            }\n        }\n        return vector<int>();\n    };\n    rep(i,0,q){\n        int m,a,b;\n        cin >> m >> a >> b;\n        --a;\n        --b;\n        if(m==1){\n            mf.add_edge(a,b,1);\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }else{\n            if(mf.graph[a][b]==1){\n                mf.graph[a][b]=mf.graph[b][a]=0;\n                cout << mf.calc_max_flow(0,n-1) << endl;\n                continue;\n            }\n            if(mf.graph[b][a]==0) swap(a,b);\n            mf.graph[a][b]=mf.graph[b][a]=0;\n            {\n                vector<int> vs=search_path(a,b,1);\n                if(!vs.empty()){\n                    rep(i,0,vs.size()-1){\n                        --mf.graph[vs[i]][vs[i+1]];\n                        ++mf.graph[vs[i+1]][vs[i]];\n                    }\n                    cout << mf.calc_max_flow(0,n-1) << endl;\n                    continue;\n                }\n            }\n            --mf.flow;\n            if(a!=0){\n                vector<int> vs=search_path(0,a,0);\n                rep(i,0,vs.size()-1){\n                    ++mf.graph[vs[i]][vs[i+1]];\n                    --mf.graph[vs[i+1]][vs[i]];\n                }\n            }\n            if(b!=n-1){\n                vector<int> vs=search_path(b,n-1,0);\n                rep(i,0,vs.size()-1){\n                    ++mf.graph[vs[i]][vs[i+1]];\n                    --mf.graph[vs[i+1]][vs[i]];\n                }\n            }\n            cout << mf.calc_max_flow(0,n-1) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n#define RED_FILE\n\n//#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E+1];\n// »ÌûüªÇ¿ç©\nint fromNode[2*MAX_E+1];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[501][501];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0){\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmemset(isUsable,0,sizeof(isUsable));\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// êxà¬êÄ¢È¢\n\t\t\tif(!isDirected[eidx]){\n\t\t\t\t// Øé¾¯\n\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\tisUsable[eidx]=false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==1){\n\t\t\t\t\t\t\t\tlineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// flowª¬êÄ¢éêAg©çtÜÅAt©çfÜÅAf©çsÜÅ»ê¼ê\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// Øf\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tif(G[a][i].cap==0){\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t\t// Øf\n\t\t\t\t\t\t\t\t//lineIdx[a][b]=lineIdx[b][a]=-1;\n\t\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tif (s == t)return fmax;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow - G[to][x.rev].cap;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow - G[to][x.rev].cap;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n\tes[u][v]=0;\n\tes[v][u]=0;\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define clear_vec(v,n); v.clear();v.resize(n);\n\nint N,E,Q;\nvector<set<int> > edge;\nvector<vector<int> > flow;\nint f;\n\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int end){\n  if(from==end)return 1;\n  used[from]=1;\n  for(auto i=edge[from].begin();i!=edge[from].end();i++){\n    int to = *i;\n    if(used[to]==1)continue;\n    if(flow[from][to]<1 && dfs_(to,end)==1){\n      add_flow(from,to);\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint dfs(int from,int end){\n  clear_vec(used,N+1);\n  return dfs_(from,end);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].insert(b);\n  edge[b].insert(a);\n}\n\nvoid cut_edge(int a,int b){\n  int ff = flow[a][b];\n  flow[a][b]=flow[b][a]=0;\n  edge[a].erase(b);\n  edge[b].erase(a);\n\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(a,b)){\n      dfs(N,b),dfs(a,1);\n      f--;\n    }\n  }\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  clear_vec(edge,N+1);\n  clear_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    clear_vec(flow[i],N+1);\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      if(dfs(1,N))f++;\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  return f;\n}\n\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  while(dfs(1,N))f++;\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        e.alive = false;\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, to, 1);\n            max_flow(from, 0, 1);  \n            return(1);\n          }\n        }\n        return(0);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n      flow -= graph.remove_edge(B, A);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tflow(n, a);\n\t\t\t\tflow(b, 1);\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tflow(n, b);\n\t\t\t\tflow(a, 1);\t\t\n\t\t\t}\n\tif(used[a][b] != used[b][a])return 1;\n\t\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\t//cout << re.cap << ' ' << G[a][re.rev].cap << endl;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\t//cout << ba.cap << ' ' << rba.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tused[t][f] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight;\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i+1 << \", \" << g[i][j].dst+1 << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\nclass FordFulkerson {\npublic:\n    Graph g; // ????????????????????????\n    int s, t; // ?§????, ??????\n    int n; // ????????°\n    ll flow = 0; // ?????§????????????????????????????????????????????????????????¨??´??°??????\n\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // ??????????????????src, dst, cap????????±?????????\n    // ????????°?????????????????????????????????\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // ?????????????????????\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // ????????°???????????????????????????????????´???????????????\n    // flow???????¨??????????\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // ????????°????????????????????????\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n    // ???????????????\n    // ????????°????????§???v??????t????????£??????????????¢?????????????????°???????????????\n    //\n    // s??????t????§???????????????????????????????????????§?????????????????????????????????0????????????\n    // f??????????????¨??????????????????\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // ?????£???????????£????????£?????????????????¢??? \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // ???????????¨???????????????????????£???????????£??????????°??????????????¬???????????????¨??????\n            if (d > 0) {\n                e.cap -= d; // ????????°?????????????????´??°\n                g[e.dst][e.rev].cap += d; // ????????°????????????????????´??°\n                return d;\n            }\n        }\n        return 0;\n    }\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // s??????t???????????§??????????????????\n    // s == t??????INF?????????, ???????????????0?????????\n    ll get(void) {\n        return flow;\n    }\n    // O(V) \n    // from??????to??????????????????cap???????????????????????????????????§???????????????\n    // ???????????????????????¨?????¨???????????£????????????????????????\n    // TODO ????¢????????????????\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // ?????¨?????¨?????£??????\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    //  ??? ??§ ??? ??? ??? ??? ??? ??? ??? ??????from->to???????????????????°????????????°???????????????????????????\n    //\n    // from??????to?????????????????????????????£??????????????¢????????¨??§????????§???????????????????????¶?????§??????????????????????????????\n    // from->to????????????????????£??????????????????????????????????????¨??§from->to????????????????°??????°???????????¨g?????????????????????\n    //\n    // from->??????->to->from??§????????????????????\\???????????°???\n    // from->to????????????????????????????????????????????????????????¨?????§?????????\n    // ?????????????????????????????????????????¨?????????????????????????????¨????????\\??????\n    ll minimizeFlowOfEdgePreservingMaxFlow(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // ???????????????????????????from??????to???????????????????????¨??????\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // ?¶????????????????????????????????????£?????¨??¨?????????????????¨??????\n            // ??????????????????????????£???????????¨??§?????????\n            while (1) { // TODO ?????????????????????????????°??????\n                // e.src?????????????????°??????????????????????????°???????????????\n                bool used[n];\n                rep(i, n) {\n                    used[i] = false;\n                }\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n                        if (tmp.src == e.src && tmp.dst == e.dst) continue;\n                        if (tmp.src == e.dst && tmp.dst == e.dst) continue;\n//                        cout << v << \"->\" << tmp.dst << endl;\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                cout << \"#\" << endl;\n                printGraphCap(g);\n                cout << e_rev.cap << endl;\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                e.cap += can_erase;\n                e_rev.cap -= can_erase;\n                cout << e_rev.cap << endl;\n                sum += can_erase;\n\n                if (can_erase == 0) { // ????????§????¶????????????????\n                    // TODO ??¬?????????????????\\???????????§?????¨??¨??????????¢??????????????????????????¬????????????§???????????????\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n    // O(V) \n    // from??????to?????????????????????cap???????????????????????????????????§???????????????\n    // cap???0????????£?????????????????°????????????????????????????¶??????????\n    int erase(int from, int to, ll cap) {\n        // ???????????¨????????????????????????????¶????????????????????????£???????????????????¢????\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // ?????????????????¨??????\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // ?????£????????????????????£???????°????????????????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // ??????????????????????????????from??????to??????????????????????????¨??????\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // ???????¶??????????????????????????????????\n            return flow;\n        }\n \n        // ??????cap????¶????????????¨????????????\n        // ????????°????????§???t->s???????¢???§??????cap???????????????????????????????????????flow???????°??????????\n        // ????°????????????????????????????????????????????????????????????¨???????????§??????????????¨???????????????????????????\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // ????????§from->to???????????????cap???????????????\n\n        // ??????????????????????¶????\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n    // from??????to??????????????¨?????? \n    //\n    // O(V)\n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, q; cin >> n >> e >> q;\n    Graph g(n);\n    rep(i, e) {\n        ll f, t; cin >> f >> t; f--, t--;\n        addDirected(g, f, t, 0, 1);\n        addDirected(g, t, f, 0, 1);\n    }\n    FordFulkerson ff(g, 0, n-1); \n//        printGraphCap(ff.g);\n//    printGraphCap(ff.g);\n    rep(i, q) {\n        int type, u, v; cin >> type >> u >> v; u--; v--;\n        if (type == 1) {\n            ff.add(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.add(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        } else {\n            ff.erase(u, v, 1);\n//            printGraphCap(ff.g);\n            ff.erase(v, u, 1);\n//            printGraphCap(ff.g);\n            cout << ff.get() << endl;\n        }\n//        printGraphCap(ff.g);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\tint fordFulkerson(const int n,const int t,int now,int fl);\n\ttmp=fordFulkerson(n,to,from,1);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,from,s);\n\t  fordFulkerson(n,s,from,1);\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,t,to);\n\t  fordFulkerson(n,to,t,1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, cap, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tbool nf = flag || (s == from && e.to == to);\n\t\tif (!used2[e.to][(int)nf] && e.cap > 0) {\n\t\t\tbool f = dfs2(e.to, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\te.cap -= 1;\n\t\t\t\tG[e.to][e.rev].cap += 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tfor (int i = 0; i < G[a].size(); ++i) {\n\t\tEdge& e = G[a][i];\n\t\tif (e.to == b) {\n\t\t\tif (e.cap > 1) {\n\t\t\t\treturn removeEdge(b, a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (e.cap < 1) {\n\t\t\t\t\tmemset(used2, false, sizeof(used2));\n\t\t\t\t\tdfs2(N-1, 0, b, a, false);\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t\tG[b].erase(G[b].begin()+e.rev);\n\t\t\t\tG[a].erase(G[a].begin()+i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tG.resize(N);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T, 1);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b, 1);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tf += flow(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nconst int MAX_V=500,inf=1e8;\n//??????????????¨???????????¨????????????erase??§???????????????????????????\n//map[s][t]???edge????????±(??????cap??????)?????????\nmap<int,int> G[MAX_V];\nint level[MAX_V];\nmap<int,int>::iterator iter[MAX_V];\nvoid add_edge(int from, int to, int cap=1){\n\tG[from][to]=G[to][from]=cap;\n}\nvoid erase_edge(int from, int to){\n\tG[from].erase(to);\n\tG[to].erase(from);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(auto e:G[v]){\n\t\t\tif(e.sc>0 && level[e.fs]<0){\n\t\t\t\tlevel[e.fs]=level[v]+1;\n\t\t\t\tque.push(e.fs);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(;iter[v]!=G[v].end();iter[v]++){\n\t\tint u=iter[v]->fs;\n\t\tif(G[v][u]>0 && level[v]<level[u]){\n\t\t\tint d=dfs(u,t,min(f,G[v][u]));\n\t\t\tif(d>0){\n\t\t\t\tG[v][u]-=d;\n\t\t\t\tG[u][v]+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\trep(i,MAX_V) iter[i]=G[i].begin();\n\t\tint f;\n\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t}\n}\nint main(){\n\tint N,E,Q;\n\tcin>>N>>E>>Q;\n\trep(i,E){\n\t\tint F,T;\n\t\tcin>>F>>T;\n\t\tadd_edge(F-1,T-1);\n\t}\n\tint now=max_flow(0,N-1);\n\trep(i,Q){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\ta--,b--;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b);\n\t\t\tnow+=max_flow(0,N-1);\n\t\t}else{\n\t\t\tint ecap=G[a][b];\n\t\t\terase_edge(a,b);\n\t\t\tif(ecap==2) swap(a,b);\n\t\t\tif(ecap!=1){\n\t\t\t\trep(i,N) iter[i]=G[i].begin();\n\t\t\t\tbfs(a);\n\t\t\t\tint f=dfs(a,b,1);\n\t\t\t\tif(f==0){\n\t\t\t\t\trep(i,N) iter[i]=G[i].begin();\n\t\t\t\t\tbfs(a);\n\t\t\t\t\tdfs(a,0,1);\n\t\t\t\t\trep(i,N) iter[i]=G[i].begin();\n\t\t\t\t\tbfs(N-1);\n\t\t\t\t\tdfs(N-1,b,1);\n\t\t\t\t\tnow--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",now);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cap, rev;\n  Edge(int u, int v, int c, int r) :\n    src(u), dst(v), cap(c), rev(r) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nbool used[500];\nint dfs(int u, int t, int f){\n  if(u == t) return f;\n  used[u] = true;\n  FORIT(e, G[u]){\n    if(e->cap > 0 && !used[e->dst]){\n      int d = dfs(e->dst, t, min(f, e->cap));\n      if(d > 0){\n        e->cap -= d;\n        G[e->dst][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nvoid max_flow(int &flow, int S, int T){\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(S, T, INF);\n    if(f == 0) return;\n    flow += f;\n  }\n}\nvoid add_edge(int u, int v){\n  G[u].push_back(Edge(u, v, 1, G[v].size()));\n  G[v].push_back(Edge(v, u, 1, G[u].size() - 1));\n}\n\nint main(){\n  int N, E, Q;\n  while(cin >> N >> E >> Q){\n    G = Graph(N);\n    REP(i, E){\n      int A, B;\n      cin >> A >> B;\n      A--; B--;\n      add_edge(A, B);\n    }\n    int S = 0, T = N - 1;\n    int flow = 0;\n    max_flow(flow, S, T);\n    REP(i, Q){\n      int M, A, B;\n      cin >> M >> A >> B;\n      A--; B--;\n      if(M == 1){\n        add_edge(A, B);\n        max_flow(flow, S, T);\n      }else{\n        FORIT(e, G[A])if(e->dst == B && e->cap == 2){\n          // B -> A : now \n          //printf(\"find %d -> %d flow\\n\", B, A);\n          memset(used, 0, sizeof(used));\n          assert(dfs(T, A, 1) == 1);\n          memset(used, 0, sizeof(used));\n          assert(dfs(B, S, 1) == 1);\n          flow--;\n          goto ERASE;\n        }\n        FORIT(e, G[B])if(e->dst == A && e->cap == 2){\n          //printf(\"find %d -> %d flow\\n\", A, B);\n          memset(used, 0, sizeof(used));\n          assert(dfs(T, B, 1) == 1);\n          memset(used, 0, sizeof(used));\n          assert(dfs(A, S, 1) == 1);\n          flow--;\n          goto ERASE;\n        }\n        ERASE:\n          FORIT(e, G[A]) if(e->dst == B) { G[A].erase(e); break; }\n          FORIT(e, G[B]) if(e->dst == A) { G[B].erase(e); break; }\n        FLOW:\n          max_flow(flow, S, T);\n      }\n      cout << flow << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n\tflow[now][next]+=1;\n\tflow[next][now]=-flow[now][next];\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\trep(j,n)vis[j]=false;\n\ttmp=dfs2(n,from,to);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n//\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tes[u][v]=0;\n\tes[v][u]=0;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tif(findpath2(u,v)){\n\t\treturn true;\n\t}\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a))return 0;\n\t\t\t\tif(!flow(b, 1))return 1;\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b))return 0;\n\t\t\t\tif(!flow(a, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <set>\n\ntemplate <class Tp>\nTp inf() { return static_cast<Tp>(1) << (8*sizeof(Tp) - 3); }\n\ntemplate <class Tp>\nstruct Edge {\n  size_t src, dst;\n  Tp cap;\n  size_t rev;\n  Edge(size_t src, size_t dst, Tp cap, size_t rev):\n    src(src), dst(dst), cap(cap), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<Edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<Edge<Tp>>>(n) {}\n\n  void connect_with(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, cap, (*this)[src].size()-1);\n  }\n\n  void connect_to(size_t src, size_t dst, Tp cap) {\n    (*this)[src].emplace_back(src, dst, cap, (*this)[dst].size());\n    (*this)[dst].emplace_back(dst, src, 0, (*this)[src].size()-1);\n  }\n\n  void inspect() const {\n    size_t n = this->size();\n    fprintf(stderr, \"vertex: %zu\\n\", n);\n    for (size_t i = 0; i < n; ++i)\n      for (const auto& e: (*this)[i])\n        fprintf(stderr, \"%zu -> %zu, cap: %zu, rev: [%zu]\\n\",\n                e.src, e.dst, e.cap, e.rev);\n  }\n};\n\ntemplate <class Tp>\nTp max_flow(graph<Tp>& g, size_t s, size_t t, Tp f0 = inf<Tp>()) {\n  Tp flow = Tp(0);\n  std::vector<size_t> iter, cost;\n\n  auto distance = [&](size_t s) {\n    std::vector<size_t> res(g.size(), inf<size_t>());\n    std::queue<size_t> q;\n    res[s] = 0;\n    q.emplace(s);\n    while (!q.empty()) {\n      size_t v = q.front();\n      q.pop();\n      for (const auto& e: g[v]) {\n        if (static_cast<Tp>(0) < e.cap && res[e.dst] == inf<size_t>()) {\n          res[e.dst] = res[v] + 1;\n          q.push(e.dst);\n        }\n      }\n    }\n    return res;\n  };\n\n  std::function<Tp (size_t, Tp)> augment = [&](size_t v, Tp f)->Tp {\n    if (v == t) return f;\n    for (size_t& i = iter[v]; i < g[v].size(); ++i) {\n      Edge<Tp>& e = g[v][i];\n      if (Tp(0) < e.cap && cost[v] < cost[e.dst]) {\n        Tp d = augment(e.dst, std::min(f, e.cap));\n        if (Tp(0) < d) {\n          e.cap -= d;\n          g[e.dst][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return static_cast<Tp>(0);\n  };\n\n  while (true) {\n    cost = distance(s);\n    if (cost[t] == inf<size_t>()) return flow;\n    iter.assign(g.size(), 0);\n    Tp f;\n    while (Tp(0) < (f = augment(s, f0))) {\n      flow += f;\n      f0 -= f;\n      if (!f0) return flow;\n    }\n  }\n}\n\nint main() {\n  size_t N, E, Q;\n  scanf(\"%zu %zu %zu\", &N, &E, &Q);\n\n  graph<intmax_t> g(N);\n  std::set<std::pair<size_t, size_t>> es0;\n  for (size_t i = 0; i < E; ++i) {\n    size_t F, T;\n    scanf(\"%zu %zu\", &F, &T);\n    --F;\n    --T;\n    g.connect_with(F, T, 1);\n    es0.insert(std::minmax(F, T));\n  }\n\n  std::vector<std::tuple<int, size_t, size_t>> qs;\n  std::set<std::pair<size_t, size_t>> es;\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    scanf(\"%d %zu %zu\", &M, &A, &B);\n    --A;\n    --B;\n    qs.emplace_back(M, A, B);\n    if (!es0.count(std::minmax(A, B)))\n      es.insert(std::minmax(A, B));\n  }\n\n  for (const auto& e: es) {\n    size_t s, d;\n    std::tie(s, d) = e;\n    g.connect_with(s, d, 0);\n  }\n\n  // g.inspect();\n  intmax_t first = max_flow(g, 0, N-1);\n  // fprintf(stderr, \"first: %jd\\n\", first);\n\n  for (size_t i = 0; i < Q; ++i) {\n    int M;\n    size_t A, B;\n    std::tie(M, A, B) = qs[i];\n    intmax_t df = 0;\n\n    // g.inspect();\n\n    if (M == 1) {\n      // connect\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        e.cap = 1;\n        g[B][e.rev].cap = 1;\n        df = max_flow(g, 0, N-1);\n        break;\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n\n    if (M == 2) {\n      // disconnect\n      for (auto& e: g[A]) {\n        if (e.dst != B) continue;\n\n        if (e.cap > 0 && g[B][e.rev].cap > 0) {\n          e.cap = 0;\n          g[B][e.rev].cap = 0;\n          break;\n        }\n\n        if (A != 0) {\n          max_flow(g, A, 0, 1L);\n        }\n        if (B != N-1) {\n          max_flow(g, N-1, B, 1L);\n        }\n        e.cap = 0;\n        g[B][e.rev].cap = 0;\n        df += max_flow(g, 0, N-1)-1;\n        break;\n      }\n      first += df;\n      // fprintf(stderr, \"delta: %jd\\n\", df);\n      printf(\"%jd\\n\", first);\n      continue;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nstruct edge{\n\tint to,cap,rev;\n\tint id;\n};\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=20000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ûüªÜÁ½©Ç¤©\nbool isDirected[2*MAX_E];\n// »ÌûüªÇ¿ç©\nint fromNode[MAX_V];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[2*MAX_E];\n// idxðßé\nint lineIdx[501][501];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tedge e;\n\te.id=id;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n\tG[from].push_back(e);\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<(int)(G[v].size());i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&isUsable[e.id]){\n\t\t\t// Ü¾ûüª¢è\n\t\t\tbool ok=false;\n\t\t\tif(!isDirected[e.id]){\n\t\t\t\tisDirected[e.id]=true;\n\t\t\t\tfromNode[e.id]=v;\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tswap(e.cap,G[e.to][e.rev].cap);\n\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(e.cap>0){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t// eÊªÅÌóÔÉàÇÁ½çADirectedtOðð\n\t\t\t\t\tif(fromNode[e.id]!=v)\n\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t//\t\t\t\t\t}\n\t\t\t\t\t//\t\t\t\t\telse{\n\t\t\t\t\t//\t\t\t\t\t\tif(e.cap==0)\n\t\t\t\t\t//\t\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t\t//\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tisDirected[e.id]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,e,q;\n\tcin>>n>>e>>q;\n\tfor(int i = 0; i < e; i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,e);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=e;\n\t\t\tisUsable[e]=true;\n\t\t\te++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\t// Øf\n\t\t\tisUsable[eidx]=false;\n\t\t\tif(isDirected[eidx]){\n\t\t\t\tfor(int i = 0; i < (int)G[a].size(); i++){\n\t\t\t\t\t// ­©\n\t\t\t\t\tif(eidx==G[a][i].id){\n\t\t\t\t\t\tif(fromNode[eidx]==a){\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\t// flowª¬êÄ¢éêAg©çtÜÅAt©çfÜÅAf©çsÜÅ»ê¼ê\n\t\t\t\t\t\t\t// 1Ìflowð¬µÄµß·\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,b,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(a,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ûüÍÜÁÄ¢éªAt[ÉÍÖWµÈ¢\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(n,a,1);\n\t\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\t\tdfs(b,1,1);\n\t\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\t\t// ¬¹éÈç¬·\n\t\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to; bool cap; int rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nbool dfs(int v, int t, bool f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap && level[v] < level[e.to]){\n      bool d = dfs(e.to,t,f&e.cap,G);\n      if(d){\n        e.cap = false;\n        G[e.to][e.rev].cap = true;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    bool f;\n    while((f = dfs(s,t,INF,G))){\n      ++flow;\n    }\n  }\n}\n\nint main(){\n  int N, E, Q;\n  scanf(\"%d %d %d\",&N,&E,&Q);\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  for(int i = 0; i < E; ++i){\n    int f, t;\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  for(int i = 0; i < Q; ++i){\n    int m, a, b, flow;\n    scanf(\"%d %d %d\",&m,&a,&b);\n    --a,--b;\n    G[a][2*b].cap = 2-m;\n    G[b][2*a].cap = 2-m;\n    flow = max_flow(0, N-1, G);\n    printf(\"%d\\n\", flow);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T> struct Edge{\n\tint v,rev;\n\tT capa,flow;\n};\n\ntemplate<class T>\nstruct AdjList:public vector< vector< Edge<T> > >{\n\tAdjList(int n):vector< vector< Edge<T> > >(n){}\n};\n\ntemplate<class T>\nvoid add_edge(AdjList<T> &adj,int u,int v,T capa){\n\tadj[u].push_back((Edge<T>){v,adj[v].size()  ,capa,0});\n\tadj[v].push_back((Edge<T>){u,adj[u].size()-1,capa,0});\n}\n\ntemplate<class T>\nT augment(AdjList<T> &adj,int s,int t){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<bool> vis(n); vis[s]=true;\n\n\tqueue< pair<int,T> > qu;\n\tqu.push(make_pair(s,INF));\n\n\tT res=0;\n\twhile(!qu.empty()){\n\t\tint u=qu.front().first;\n\t\tT water=qu.front().second;\n\t\tqu.pop();\n\n\t\tif(u==t){ res=water; break; }\n\n\t\trep(i,adj[u].size()){\n\t\t\tEdge<T> &e=adj[u][i];\n\t\t\tif(!vis[e.v] && e.capa-e.flow>0){\n\t\t\t\tvis[e.v]=true;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\tqu.push(make_pair(e.v,min(water,e.capa-e.flow)));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(res>0){\n\t\tfor(int v=t;v!=s;){\n\t\t\tEdge<T> &e1=adj[v][pre[v]];\n\t\t\tEdge<T> &e2=adj[e1.v][e1.rev];\n\t\t\te1.flow-=res;\n\t\t\te2.flow+=res;\n\t\t\tv=e1.v;\n\t\t}\n\t}\n\n\treturn res;\n}\n\ntemplate<class T>\nT Edmonds_Karp(AdjList<T> &adj,int s,int t){\n\tT ans=0;\n\tfor(T water=1;water>0;ans+=water) water=augment(adj,s,t);\n\treturn ans;\n}\n\nbool vis[500];\nbool dfs(int u,int t,AdjList<int> &adj){\n\tvis[u]=true;\n\tif(u==t) return true;\n\trep(i,adj[u].size()){\n\t\tEdge<int> &e=adj[u][i];\n\t\tif(!vis[e.v] && e.capa-e.flow>0 && dfs(e.v,t,adj)){\n\t\t\te.flow++;\n\t\t\tadj[e.v][e.rev].flow--;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\tAdjList<int> adj(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tadd_edge(adj,u,v,1);\n\t}\n\n\tint ans=Edmonds_Karp(adj,0,n-1);\n\n\twhile(q--){\n\t\tint type,u,v; scanf(\"%d%d%d\",&type,&u,&v); u--; v--;\n\t\tif(type==1){\n\t\t\tint i,i_rev;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v) break;\n\t\t\tif(i<adj[u].size()){\n\t\t\t\ti_rev=adj[u][i].rev;\n\t\t\t\tadj[u][i].capa=adj[v][i_rev].capa=1;\n\t\t\t}\n\t\t\telse add_edge(adj,u,v,1);\n\t\t}\n\t\telse{\n\t\t\tint i,i_rev;\n\t\t\tfor(i=0;i<adj[u].size();i++) if(adj[u][i].v==v) break;\n\t\t\ti_rev=adj[u][i].rev;\n\n\t\t\tif(adj[u][i].flow<0){\n\t\t\t\tswap(u,v);\n\t\t\t\tswap(i,i_rev);\n\t\t\t}\n\n\t\t\tif(adj[u][i].flow==0){\n\t\t\t\tadj[u][i].capa=adj[v][i_rev].capa=0;\n\t\t\t\tadj[u][i].flow=adj[v][i_rev].flow=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ans>0){\n\t\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\t\tdfs(n-1,0,adj);\n\t\t\t\t\tans--;\n\t\t\t\t}\n\n\t\t\t\tif(adj[u][i].flow!=0){\n\t\t\t\t\trep(w,n) vis[w]=false;\n\t\t\t\t\tdfs(u,v,adj);\n\t\t\t\t}\n\t\t\t\tadj[u][i].capa=adj[v][i_rev].capa=0;\n\t\t\t\tadj[u][i].flow=adj[v][i_rev].flow=0;\n\t\t\t}\n\t\t}\n\t\tans+=Edmonds_Karp(adj,0,n-1);\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=200000;\n\nstruct edge{\n\tint to,cap,rev,id;\n\tint flow;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t\tflow=0;\n\t}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// Ü¾¶«Äéü©Ç¤©\nbool isUsable[MAX_E];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,cap,G[from].size()-1,id));\n}\n\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// ØfÏÝ\n\t\tif(!isUsable[e.id])continue;\n\t\t// Ü¾t[ð¬¹éÈçÎA¬·\n\t\tif(!used[e.to]&&e.flow<e.cap){\n\t\t\t// ¡ñÌ¬Ê\n\t\t\tint quan=e.cap-e.flow;\n\t\t\t//if(e.flow<0)quan=-(e.flow);\n\t\t\tint d=dfs(e.to,t,min(f,quan));\n\t\t\tif(d>0){\n\t\t\t\te.flow+=d;\n\t\t\t\t// ½ÎÉÍ}CiXÌvfðüêÄ¨­\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}// ¸­pXðTõ\nint dfs2(int v,int t){\n\tif(v==t) return 1;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!isUsable[e.id])continue;\n\t\t// 0æè¬³¯êÎAß·\n\t\tif(!used[e.to]&&e.flow<0){\n\t\t\tint d=dfs2(e.to,t);\n\t\t\tif(d>0){\n\t\t\t\te.flow+=1;\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\telse flow+=f;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n,ee,q;\n\tcin>>n>>ee>>q;\n\tfor(int i=0;i<ee;i++){\n\t\tint f,t;\n\t\tcin>>f>>t;\n\t\t// Æè ¦¸ÇÁ\n\t\tadd_edge(f,t,1,i);\n\t\tisUsable[i]=true;\n\t\tlineIdx[f][t]=lineIdx[t][f]=i;\n\t}\n\t// »ÝÌÅåflowðßé\n\tint cflow=max_flow(1,n);\n\tfor(int j=0;j<q;j++){\n\t\tint m,a,b;\n\t\tcin>>m>>a>>b;\n\t\tif(m==1){\n\t\t\tadd_edge(a,b,1,ee);\n\t\t\tlineIdx[a][b]=lineIdx[b][a]=ee;\n\t\t\tisUsable[ee]=true;\n\t\t\tee++;\n\t\t\tcflow+=max_flow(1,n);\n\t\t}\n\t\telse{\n\t\t\t// Ú±ªØê½Æ«AØê½êÉt[ª¬êÄ¢é©»¤ÅÈ¢©Åêª¯\n\t\t\tint eidx=lineIdx[a][b];\n\t\t\tfor(int i=0;i<(int)G[a].size();i++){\n\t\t\t\tedge &e=G[a][i];\n\t\t\t\tif(!isUsable[e.id])continue;\n\t\t\t\tif(eidx==e.id){\n\t\t\t\t\t// ¬êÄ¢È¢ê,tOðÜé¾¯\n\t\t\t\t\tif(e.flow==0)isUsable[eidx]=false;\n\t\t\t\t\t// ¬êÄ¢éê\n\t\t\t\t\telse{\n\t\t\t\t\t\tint from=a;\n\t\t\t\t\t\tint to=b;\n\t\t\t\t\t\tif(e.flow>0) swap(from,to);\n\t\t\t\t\t\t// flowð0Éú»\n\t\t\t\t\t\te.flow=G[e.to][e.rev].flow=0;\n\t\t\t\t\t\t// ûüÉµ½ªÁÄtü«Éflowð¬·\n\t\t\t\t\t\tisUsable[eidx]=false;\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tint num=dfs(to,from,1);\n\t\t\t\t\t\t// ¬¹½ê\n\t\t\t\t\t\tif(num==1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// ¬¹È©Á½ê,ß·\n\t\t\t\t\t\t//dfs2(from,to);\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(n,from);\n\t\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\t\tdfs2(to,1);\n\t\t\t\t\t\t// Øf\n\t\t\t\t\t\tcflow--;\n\t\t\t\t\t\tcflow+=max_flow(1,n);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cflow<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000;\nint cap[1000][1000];\n\nint maximumFlow(int n, int s, int t){\n\tint res = 0;\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\tint inc = INF;\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tinc = min(inc, cap[prev[j]][j]);\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j] -= inc, cap[j][prev[j]] += inc;\n\t\tres += inc;\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\t// A->B gpÏÝ\n\t\t\t\tif(cap[A-1][B-1] == 0){\n\t\t\t\t\tint c = B-1;\n\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc = A-1;\n\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t\telse if(cap[B-1][A-1] == 0){\n\t\t\t\t\tint c = A-1;\n\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc = B-1;\n\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t}\n\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t}\n\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 500; // TODO:initialize\nconst int F_INF = 19191919; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint main()\n{\n    int n,e,q;\n    scanf(\" %d %d %d\", &n, &e, &q);\n    rep(i,e)\n    {\n        int f,t;\n        scanf(\" %d %d\", &f, &t);\n        --f;\n        --t;\n        add_edge(f,t,1);\n    }\n\n    int f = max_flow(0,n-1);\n    while(q--)\n    {\n        int m,a,b;\n        scanf(\" %d %d %d\", &m, &a, &b);\n        --a;\n        --b;\n        if(m==1)\n        {\n            bool found = false;\n            rep(i,G[a].size())if(G[a][i].to==b)\n            {\n                G[a][i].cap = 1;\n                G[b][G[a][i].rev].cap = 1;\n                assert(G[b][G[a][i].rev].to == a);\n                found = true;\n                break;\n            }\n\n            if(!found) add_edge(a,b,1);\n            f += max_flow(0,n-1);\n        }\n        else\n        {\n            int id = -1;\n            rep(i,G[a].size())\n            {\n                if(G[a][i].to==b)\n                {\n                    id = i;\n                    int CAP = G[a][i].cap;\n                    if(CAP==2)\n                    {\n                        id = G[a][i].rev;\n                        swap(a,b);\n                    }\n                    break;\n                }\n            }\n\n            assert(G[b][G[a][id].rev].to == a);\n            assert(id!=-1);\n            if(G[a][id].cap==0)\n            {\n                --f;\n                int now = a;\n                while(now!=0)\n                {\n                    rep(i,G[now].size())\n                    {\n                        if(G[now][i].cap==2 && G[G[now][i].to][G[now][i].rev].cap==0)\n                        {\n                            int nx = G[now][i].to;\n                            G[now][i].cap = 1;\n                            G[nx][G[now][i].rev].cap = 1;\n\n                            now = nx;\n                            break;\n                        }\n                    }\n                }\n\n                now = b;\n                while(now!=n-1)\n                {\n                    rep(i,G[now].size())\n                    {\n                        if(G[now][i].cap==0 && G[G[now][i].to][G[now][i].rev].cap==2)\n                        {\n                            int nx = G[now][i].to;\n                            G[now][i].cap = 1;\n                            G[nx][G[now][i].rev].cap = 1;\n\n                            now = nx;\n                            break;\n                        }\n                    }\n                }\n            }\n            G[a][id].cap = 0;\n            G[b][G[a][id].rev].cap = 0;\n            f += max_flow(0,n-1);\n        }\n        printf(\"%d\\n\", f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nstruct Edge {\n  int to, cap, rev, m_cap;\n  Edge(int t, int c, int r) : to(t), cap(c), m_cap(c), rev(r) {}\n  Edge() {}\n};\n\n#define MAX_N 1005\n\nclass Dinic {\n  vector<Edge> g[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n  int dist[MAX_N];\n  int flow, n;\n  int st, en;\n  map<P, int> edges;\n\n  void bfs(int s) {\n    rep(i, n) level[i] = -1, dist[i] = INF;\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      rep(i, g[v].size()) {\n        Edge &e = g[v][i];\n        if(e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          dist[e.to] = mind(e.cap, dist[v]);\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    for(int &i=iter[v]; i<g[v].size(); ++i) {\n      Edge &e = g[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, t, mind(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          g[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  Dinic(int n, int s, int t) {\n    flow = 0;\n    st = s; en = t;\n    this->n = n;\n  }\n\n  // ??????????????????\n  void add_edge(int from, int to, int cap) {\n    edges[P(from, to)] = g[from].size();\n    g[from].push_back(Edge(to, cap, g[to].size()));\n    edges[P(to, from)] = g[to].size();\n    g[to].push_back(Edge(from, 0, g[from].size()-1));\n  }\n\n  // ??????????????????\n  void add_multi_edge(int v1, int v2, int cap) {\n    edges[P(v1, v2)] = g[v1].size();\n    g[v1].push_back(Edge(v2, cap, g[v2].size()));\n    edges[P(v2, v1)] = g[v2].size();\n    g[v2].push_back(Edge(v1, cap, g[v1].size()-1));\n  }\n\n  // ?????§???????±???????\n  int max_flow(int s = -1, int t = -1, int rest = -1) {\n    //cout << \"----\" SP s SP t SP rest << endl;\n    if(s == -1) s = st;\n    if(t == -1) t = en;\n    int su = 0;\n    while(rest) {\n      bfs(s);\n      if(level[t] < 0) break;\n      rep(i, n) iter[i] = 0;\n      int f;\n      //cout << \"e\" SP rest << endl;\n      while(rest && (f = dfs(s, t, rest == -1 ? INF : rest)) > 0) {\n        if(rest == -1) {\n          flow += f;\n        } else {\n          rest -= f;\n        }\n        su += f;\n      }\n    }\n    return rest == -1 ? flow : su;\n  }\n\n  // ???????¢????\n  void inc_edge(int s, int t, int c) {\n    //cout << \"inc_edge\" SP s SP t SP c << endl;\n    P key = P(s, t);\n    if(edges.find(key) != edges.end()) {\n      g[s][edges[key]].cap += c;\n      g[s][edges[key]].m_cap += c;\n    } else {\n      add_edge(s, t, c);\n    }\n  }\n\n  // ??????????°?\n  void dec_edge(int s, int t, int c) {\n    //cout << \"dec_edge\" SP s SP t SP c << endl;\n    P key = P(s, t);\n    if(edges.find(key) != edges.end()) {\n      int cap = g[s][edges[key]].cap;\n      if(c <= cap) {\n        g[s][edges[key]].cap -= c;\n      } else {\n        int rest = c - cap;\n\n        //cout << \"d\" SP c SP cap SP g[t][edges[P(t, s)]].cap << endl;\n        //cout << \"m\" SP g[s][edges[P(s, t)]].m_cap SP g[t][edges[P(t, s)]].m_cap << endl;\n        g[s][edges[key]].cap = 0;\n        g[t][edges[P(t, s)]].cap -= rest;\n\n        bfs(s);\n        //cout << level[t] << endl;\n        if(level[t] >= 0) {\n          int ff = max_flow(s, t, rest);\n          rest -= ff;\n        }\n\n        if(rest) {\n          int f1 = max_flow(en, t, rest);\n          int f2 = max_flow(s, st, rest);\n          //cout << f1 SP f2 << endl;\n\n          assert(f1 == f2 && f1 == rest && f2 == rest);\n          flow -= rest;\n        }\n      }\n      g[s][edges[key]].m_cap -= c;\n    }\n  }\n\n  void debug() {\n    rep(i, n) {\n      rep(j, n) {\n        if(i == j) continue;\n        if(edges.find(P(i, j)) != edges.end()) {\n          Edge &e = g[i][edges[P(i, j)]];\n          cout << i SP j SP e.cap << endl;\n        }\n      }\n    }\n  }\n\n};\n\n\nint main() {\n  int n, e, q;\n  cin >> n >> e >> q;\n  Dinic dinic(n, 0, n-1);\n  rep(i, e) {\n    int f, t;\n    cin >> f >> t; --f; --t;\n    dinic.add_multi_edge(f, t, 1);\n  }\n  //cout << dinic.max_flow() << endl;\n  rep(i, q) {\n    int m, a, b;\n    cin >> m >> a >> b; --a; --b;\n    //dinic.debug();\n    if(m == 1) {\n      dinic.inc_edge(a, b, 1);\n      dinic.inc_edge(b, a, 1);\n    } else {\n      dinic.dec_edge(a, b, 1);\n      dinic.dec_edge(b, a, 1);\n    }\n    int f = dinic.max_flow();\n    cout << f << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nstruct edge{\n    int to,cap,rev,type;\n    edge(int a,int b,int c,int d):to(a),cap(b),rev(c),type(d){}\n};\n\nint N,E,Q;\n\nconst int MAX_V=600;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size(),1));\n    G[to].pb(edge(from,0,G[from].size()-1,0));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to]||e.cap==0)continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d==0)continue;\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int f=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int ff=dfs(s,t,INF);\n        if(ff==0)return f;\n        f+=ff;\n    }\n}\n\n\nint f;\nvoid q1(int a,int b){\n    add_edge(a,b,1);\n    add_edge(b,a,1);\n    f+=max_flow(0,N-1);\n}\n\nbool dfs2(int v,int t,vint &A){\n    used[v]=true;\n    if(v==t){\n        A.pb(v);\n        return true;\n    }\n\n    for(auto &e:G[v]){\n        if(e.cap==0)continue;\n        if(used[e.to])continue;\n        if(dfs2(e.to,t,A)){\n            A.pb(v);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid uku(vint &A){\n    for(int i=0;i+1<A.size();i++){\n        int a=A[i];\n        int b=A[i+1];\n\n        for(auto &e:G[a]){\n            if(e.to==b&&e.cap){\n                e.cap=0;\n                G[e.to][e.rev].cap=1;\n                break;\n            }\n        }\n    }\n}\n\nvoid q2(int a,int b){\n\n    bool f1=false,f2=false;\n\n    for(auto &e:G[a]){\n        if(e.type==1&&e.to==b){\n            f1=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n    for(auto &e:G[b]){\n        if(e.type==1&&e.to==a){\n            f2=e.cap==0;\n            e.cap=0;e.type=0;G[e.to][e.rev].cap=0;\n        }\n    }\n\n\n    if(f1==f2)return;\n\n    if(f2)swap(a,b);\n\n    vint A,B;\n\n    memset(used,0,sizeof(used));\n    dfs2(N-1,b,B);\n    memset(used,0,sizeof(used));\n    dfs2(a,0,A);\n\n    reverse(all(A));\n    reverse(all(B));\n\n    map<int,int>ei;\n\n    rep(i,B.size())ei[B[i]]=i;\n\n    int k=-1;\n    rep(i,A.size()){\n        if(ei.find(A[i])==ei.end())continue;\n        k=i;\n        break;\n    }\n\n    if(k==-1){\n        uku(A);uku(B);\n        f--;\n    }\n    else{\n        int l=ei[A[k]];\n        A.erase(A.begin()+k,A.end());\n        for(int i=l;i<B.size();i++)A.pb(B[i]);\n        uku(A);\n    }\n\n    f+=max_flow(0,N-1);\n}\nsigned main(){\n\n    cin>>N>>E>>Q;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n    }\n\n    f=max_flow(0,N-1);\n\n    while(Q--){\n        int t,a,b;\n        cin>>t>>a>>b;\n        a--;b--;\n        if(t==1){\n            q1(a,b);\n        }\n        else{\n            q2(a,b);\n        }\n        /*\n        cout<<f<<\"-------------\"<<endl;\n        for(int i=0;i<N;i++){\n            for(auto &e:G[i]){\n                if(e.type==1&&e.cap==0)cout<<i+1<<\" \"<<e.to+1<<endl;\n            }\n        }*/\n        printf(\"%lld\\n\",f);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define init_vec(v,n) v.clear();v.resize(n);\n#define vec_del(v,c) v.erase(remove(v.begin(),v.end(),c),v.end());\nint N,E,Q;\nvector<vector<int> > edge;\nvector<vector<int> > flow;\nint f;\nvoid add_flow(int from,int to){\n  flow[from][to]++;\n  flow[to][from]--;\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n\n  for(int i=0;i<edge[from].size();i++){\n    int to_ = edge[from][i];\n    if(used[to_])continue;\n    if(flow[from][to_]==1)continue;\n    if(dfs_(to_,to)){\n      add_flow(from,to_);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  init_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(b);\n  edge[b].push_back(a);\n}\n\nbool cut_flow(int from,int to){\n  if(dfs(from,1)&&dfs(N,to)){\n    f--;\n    return true;\n  }else{\n    return true;\n  }\n}\n\nvoid cut_edge(int a,int b){\n  vec_del(edge[a],b);\n  vec_del(edge[b],a);\n  if(flow[a][b]==1){\n    if(!cut_flow(a,b))cerr<<\"cut_err:\"<<a<<\" \"<<b<<endl;\n  }else if(flow[b][a]==1){\n    if(!cut_flow(b,a))cerr<<\"cut_err:\"<<b<<\" \"<<a<<endl;\n  }\n\n  flow[a][b]=0;\n  flow[b][a]=0;\n}\n\n\nint input(){\n  cin>>N>>E>>Q;\n  f=0;\n  init_vec(flow,N+1);\n  for(int i=0;i<N+1;i++){\n    init_vec(flow[i],N+1);\n  }\n  init_vec(edge,N+1);\n  //cout<<\"edge\"<<endl;\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  //cout<<\"dfs\"<<endl;\n  while(dfs(1,N))f++;\n  //cout<<\"fin input:\"<<f<<endl;\n  return 0;\n}\n\nint solve(int m,int a,int  b){\n  switch(m){\n    case 1:\n      add_edge(a,b);\n      break;\n    case 2:\n      cut_edge(a,b);\n      break;\n  }\n  while(dfs(1,N))f++;\n  return f;\n}\nvoid query(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    //cout<<\"query:\"<<a<<\" \"<<b<<\" \"<<c<<endl;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  query();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n,m,qn;\n\nint vs[505][505]={};\nint gone[505];\n\nbool dfs(int no,int gl){\n\tif(no==gl)return true;\n\tgone[no]=1;\n\treg(to,1,n){\n\t\tif(gone[to])continue;\n\t\tif(vs[no][to]>0){\n\t\t\tif(dfs(to,gl)){\n\t\t\t\tvs[no][to]--;\n\t\t\t\tvs[to][no]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tvs[a][b]=vs[b][a]=1;\n\t}\n\t\n\tint nf=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tif(dfs(1,n))nf++;\n\t\telse break;\n\t}\n\trep(i,qn){\n\t\tint t,a,b;\n\t\tscanf(\"%d%d%d\",&t,&a,&b);\n\t\tif(t==1){\n\t\t\tvs[a][b]=vs[b][a]=1;\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\telse{\n\t\t\tint fr=-1,to;\n\t\t\tif(vs[a][b]==0){\n\t\t\t\tfr=a; to=b;\n\t\t\t}\n\t\t\telse if(vs[b][a]==0){\n\t\t\t\tfr=b; to=a;\n\t\t\t}\n\t\t\tvs[a][b]=vs[b][a]=0; a=0;\n\t\t\tif(fr>=0){\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(!dfs(n,to))a=1/a;\n\t\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\t\tif(!dfs(fr,1))a=1/a;\n\t\t\t\tnf--;\n\t\t\t}\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tif(dfs(1,n))nf++;\n\t\t}\n\t\tprintf(\"%d\\n\",nf);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int MAX_N = 510;\n\nint N, E, Q, G[MAX_N][MAX_N];\n\nint dfs(int now, int g, vector<bool> &visited){\n  visited[now] = true;\n  if(now == g) return 1;\n  REP(i, N){\n    if(visited[i] || G[now][i] <= 0) continue;\n    if(dfs(i, g, visited)){\n      ++G[i][now];\n      --G[now][i];\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint flow(int s, int t){\n  vector<bool> visited(N, false);\n  return dfs(s, t, visited);\n}\n\nint main() {\n  int ans = 0;\n  cin >>N >>E >>Q;\n  memset(G, 0, sizeof(G));\n  REP(i, E){\n    int f, t; cin >>f >>t;\n    --f; --t;\n    G[f][t] = G[t][f] = 1;\n  }\n  REP(i, Q){\n    int m, f, t; cin >>m >>f >>t;\n    --f; --t;\n    if(m == 1) G[f][t] = G[t][f] = 1;\n    else {\n      if(G[f][t] == 2 && !flow(t, f)) { flow(N - 1, 0); flow(t, f); --ans; }\n      else if(G[t][f] == 2 && !flow(f, t)) { flow(N - 1, 0); flow(f, t); --ans; }\n      G[f][t] = G[t][f] = 0;\n    }\n    while(flow(0, N - 1)) ++ans;\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V], H[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, e, q;\nint x[1000], s[1000], t[1000];\nset<P> saw;\nint pre = 0;\n\nint main(){\n    cin >> n >> e >> q;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        if(s > t) swap(s,t);\n        s--; t--;\n        saw.insert(P(s,t));\n        add_edge(s,t,1);\n    }\n    rep(i,q){\n        cin >> x[i] >> s[i] >> t[i];\n        s[i]--; t[i]--;\n        if(s[i] > t[i]) swap(s[i],t[i]);\n        if(saw.count(P(s[i],t[i])) == 0){\n            add_edge(s[i],t[i],0);\n            saw.insert(P(s[i],t[i]));\n        }\n    }\n    pre = max_flow(0,n-1);\n    rep(i,q){\n        if(x[i] == 1){\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 1;\n                    G[t[i]][rev].cap = 1;\n                }\n            }\n            pre = max_flow(0,n-1)+pre;\n        } else{\n            bool ok = true;\n            rep(j,G[s[i]].size()){\n                int rev = G[s[i]][j].rev;\n                if(G[s[i]][j].cap != 1) ok = false;\n                if(G[s[i]][j].to == t[i]){\n                    G[s[i]][j].cap = 0;\n                    G[t[i]][rev].cap = 0;\n                }\n            }\n            if(!ok){\n                rep(j,n) rep(k,G[j].size()){\n                    int rev = G[j][k].rev;\n                    int to = G[j][k].to;\n                    if(G[j][k].cap == 2){\n                        G[j][k].cap = 1;\n                        G[to][rev].cap = 1;\n                    }\n                }\n                pre = max_flow(0,n-1);\n            }\n        }\n        cout << pre << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint go_imp(int from, int to, vector<vector<bool>> &cap, vector<vector<bool>> &flow, vector<bool> &used){\n    if(used[from]) return 0;\n    used[from] = true;\n    if(from == to) return 1;\n    int n = cap.size();\n    for(int i=0; i<n; i++){\n        if(cap[from][i] and !flow[from][i]){\n            if(go_imp(i, to, cap, flow, used)){\n                if(flow[i][from]){\n                    flow[i][from] = false;\n                }else{\n                    flow[from][i] = true;\n                }\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint go(int from, int to, vector<vector<bool>> &cap, vector<vector<bool>> &flow){\n    vector<bool> used(cap.size(), false);\n    return go_imp(from, to, cap, flow, used);\n}\n\nint main(){\n    int n,m,q;\n    cin >> n >> m >> q;\n    vector<vector<bool>> cap(n, vector<bool>(n, false));\n    vector<vector<bool>> flow(n, vector<bool>(n, false));\n    for(int i=0; i<m; i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        cap[a][b] = cap[b][a] = true;\n    }\n    int total = 0;\n    while(go(0, n-1, cap, flow)) total++;\n    for(int i=0; i<q; i++){\n        int s,a,b;\n        cin >> s >> a >> b;\n        a--; b--;\n        if(s == 1){\n            cap[a][b] = cap[b][a] = true;\n            total += go(0, n-1, cap, flow);\n        }else{\n            cap[a][b] = cap[b][a] = false;\n            if(flow[b][a]){\n                swap(a, b);\n            }\n            if(flow[a][b]){\n                flow[a][b] = false;\n                if(!go(a, b, cap, flow)){\n                    go(n-1, b, cap, flow);\n                    go(a, 0, cap, flow);\n                    total--;\n                    total += go(0, n-1, cap, flow);\n                }\n            }\n        }\n        cout << total << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#define N 501\n#define inf 10000000\nusing namespace std;\n \nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  for(int i = 0 ;i < n ; i++){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n        flow[now][next]+=tmp;\n        flow[next][now]=-flow[now][next];\n        return tmp;\n      }\n    }\n  }\n  return 0;\n}\n \nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  for(int i = 0 ; i < n ; i++)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    for(int i = 0 ; i < n ; i++)vis[i]=false;\n  }\n  return ret;\n}\n \nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return false;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n        flow[now][next]=flow[next][now]=0;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n \nint dfs2(int n,int now,int t){\n  if (now == t)return 1;\n  if (vis[now])return 0;\n  vis[now]=true;\n  for(int i = 0 ; i < n ; i++){\n    int &next=i;\n    if (cap[now][next]-flow[now][next] > 0){\n      if (dfs2(n,next,t)){\n        flow[now][next]+=1;\n        flow[next][now]=-flow[now][next];\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n \n \nint main(void){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n        cap[i][j] = 0;\n        flow[i][j] = 0;\n      }\n    }\n \n    for(int i = 0 ; i < e ; i++){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    for(int i = 0 ; i < q ; i++){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n        cap[from][to]=cap[to][from]=1;\n        tmp = maxFlow(n,s,t);\n        cout << prev+tmp << endl;\n        prev=prev+tmp;\n      }else if (flow[from][to] == 0){\n        cap[from][to]=cap[to][from]=0;\n        cout << prev << endl;\n      }else {//delete\n        if (flow[from][to] < 0)swap(from,to);\n        cap[from][to]=cap[to][from]=0;\n        flow[from][to]=flow[to][from]=0;\n        for(int j = 0 ; j < n ; j++)vis[i] = false;\n        tmp=dfs2(n,from,to);\n        if (tmp != 0){\n          cout << prev << endl;\n          prev=prev;//keep\n        }else {\n          for(int j = 0 ;j < n ; j++)vis[j] = false;\n          dfs(n,from,s);\n          for(int j = 0 ; j < n; j++)vis[j] = false;\n          dfs(n,t,to);\n          cout << prev-1 << endl;\n          prev=prev-1;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,E,Q;\nint G[500][500];\nint visited[500];\nint dfs(int pos,int ti,int f){\n  if(pos==ti)return f;\n  if(visited[pos])return 0;\n  visited[pos]=1;\n  for(int i=0;i<N;i++){\n    int e=G[pos][i];\n    if(e==0)continue;\n    int k=dfs(i,ti,min(f,e));\n    if(k==0)continue;\n    G[pos][i]-=k;\n    G[i][pos]+=k;\n    return k;\n  }\n  return 0;\n}\nint ans;\nvoid maxflow(int si,int ti){\n  ans=0;\n  while(1){\n    memset(visited,0,sizeof(visited));\n    int f=dfs(si,ti,1);\n    if(f==0)break;\n    ans+=f;\n  }\n}\n\nint main(){\n  cin>>N>>E>>Q;\n  for(int i=0;i<E;i++){\n    int F,T;\n    cin>>F>>T;\n    F--,T--;\n    G[F][T]++;\n    G[T][F]++;\n  }\n\n  maxflow(0,N-1);\n  for(int i=0;i<Q;i++){\n    int M,A,B;\n    cin>>M>>A>>B;\n    A--,B--;\n    \n    if(M==1){\n      G[A][B]++;\n      memset(visited,0,sizeof(visited));\n      ans+=dfs(0,N-1,1);\n      G[B][A]++;\n      memset(visited,0,sizeof(visited));\n      ans+=dfs(0,N-1,1);\n    }else{\n\n      if(G[A][B]>0){\n        G[A][B]--;\n      }else{\n        G[B][A]--;\n        memset(visited,0,sizeof(visited));\n        if( dfs(A,B,1) == 0 ){\n          memset(visited,0,sizeof(visited));\n          dfs(N-1,B,1);\n          memset(visited,0,sizeof(visited));\n          dfs(A,0,1);\n          ans--;\n          memset(visited,0,sizeof(visited));\n          ans+=dfs(0,N-1,1);\n        }\n      }\n\n      if(G[B][A]>0){\n        G[B][A]--;\n      }else{\n        G[A][B]--;\n        memset(visited,0,sizeof(visited));\n        if( dfs(B,A,1) == 0 ){\n          memset(visited,0,sizeof(visited));\n          dfs(N-1,A,1);\n          memset(visited,0,sizeof(visited));\n          dfs(B,0,1);\n          ans--;\n          memset(visited,0,sizeof(visited));\n          ans+=dfs(0,N-1,1);\n        }\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(){}\n\tEdge(int s, int d, int c)\n\t\t:src(s), dst(d), cst(c)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint\tcapa[502][502];\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=capa[p][next];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tcapa[p][next]-=f;\n\t\t\tcapa[next][p]+=f;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n//流量を制限するdinic\nint dinic(int S, int T, int L, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end && total < L)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\n\t\t\t\tint next=e.dst;\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]<=0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, L, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t\tif(total >= L) break;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int t, int v, Graph& g)\n{\n\tg[s].push_back(Edge(s,t,v));\n\tg[t].push_back(Edge(t,s,v));\n\n\tcapa[s][t] += v;\n\tcapa[t][s] += v;\n}\n\nvoid add_pass(int s, int t, Graph& g)\n{\n\tg[s].push_back(Edge(s,t,0));\n\tg[t].push_back(Edge(t,s,0));\n}\n\nvoid reduce_cap(int s, int t, int v, Graph& g)\n{\n\tcapa[s][t] -= v;\n\tcapa[t][s] -= v;\n}\n\nvoid add_cap(int s, int t, int v, Graph& g)\n{\n\tcapa[s][t] += v;\n\tcapa[t][s] += v;\n}\n\nvoid solve(int N, Graph& g, vector<Edge>& queries)\n{\n\tint f = dinic(0,N-1,INF,g);\n\tfor(int i=0; i<queries.size(); i++)\n\t{\n\t\tEdge &e = queries[i];\n\n\t\tif(e.cst == 1) {\n\t\t\tadd_cap(e.src, e.dst, 1, g);\n\t\t\tf += dinic(0,N-1,1,g);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(capa[e.src][e.dst] == 1) \n\t\t\t{\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t}\n\n\t\t\telse if(capa[e.src][e.dst] == 2) \n\t\t\t{\n\t\t\t\tif(dinic(e.dst, e.src, 1, g) != 1)\n\t\t\t\t{\n\t\t\t\t\tf--;\n\t\t\t\t\tdinic(N-1, 0, 1, g);\n\t\t\t\t\tdinic(e.dst, e.src, 1, g);\n\t\t\t\t}\n\n\t\t\t\tdinic(e.src, e.dst, 1, g);\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t\tf+=dinic(0, N-1, 1, g);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dinic(e.src, e.dst, 1, g) != 1)\n\t\t\t\t{\n\t\t\t\t\tf--;\n\t\t\t\t\tdinic(N-1, 0, 1, g);\n\t\t\t\t\tdinic(e.src, e.dst, 1, g);\n\t\t\t\t}\n\n\t\t\t\tdinic(e.dst, e.src, 1, g);\n\t\t\t\treduce_cap(e.src, e.dst, 1, g);\n\t\t\t\tf+=dinic(0, N-1, 1, g);\n\n\t\t\t}\n\t\t}\n\n\t\tcout << f << endl;\n\t}\n}\n\nint main()\n{\n\tint N,E,Q;\n\tcin >> N >> E >> Q;\n\n\tmemset(capa, 0, sizeof(capa));\n\n\tGraph g(N);\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\tadd_edge(s,t,1,g);\n\t}\n\n\tvector<Edge> queries(Q);\n\n\tfor(int i=0; i<Q; i++)\n\t{\n\t\tint m,s,t;\n\t\tcin >> m >> s >> t;\n\t\ts--; t--;\n\t\tqueries[i] = Edge(s,t,m);\n\t\tif(capa[s][t] == 0) add_pass(s,t,g);\n\t}\n\n\tsolve(N, g, queries);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to,rev;Flow icap,cap;bool ex;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[e.to][e.rev];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V);\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        int srev=G[t].size(),trev=G[s].size();\n        G[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,0,0,false});\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Flow flow = 0;\n        for(Edge& e:G[s])if(e.to == t){\n            Edge &reve = G[e.to][e.rev];\n            if(e.icap <= c){// 単純に増やす\n            // cerr <<\"add\"<<endl;\n                e.cap+=c - e.icap;\n                e.icap = c;\n            }else if(c >= e.icap-e.cap){ // 単純に減らす\n            // cerr <<\"del\"<<endl;\n                e.cap-=e.icap - c;\n                e.icap = c;\n            }else{// フローを戻してから減らす\n                // cerr <<\"del2\"<<endl;\n                // cerr << s+1 <<\" \" << t+1 <<endl;\n                Flow d = e.icap - e.cap - c;\n                // cerr << d <<endl;\n \n                Flow tmpcap=e.cap,tmprevcap=reve.cap;\n                e.cap =0;reve.cap = 0;\n                 \n                // cerr <<\"!preflow!\"<<endl;\n                // REP(v,G.size())for(Edge& e2:G[v]){\n                //  Edge &reve2 = G[e2.to][e2.rev];\n                //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n                // }\n                // cerr <<endl;\n                // cerr << d <<endl;\n \n                // S <- s <- t <- T のパス\n                // cerr << make_tuple(s,S,d) <<endl;\n                Flow fs = max_flow(s,S,d);\n                Flow ft = max_flow(T,t,d);\n                Flow f = min(fs,ft);\n                // cerr <<\"::f\" <<f <<endl;\n                flow -= f;\n \n                // cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n \n                // 流しすぎ分の除去\n                max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n \n                // 閉路の除去\n                // s -> t -> s\n                // cerr << make_tuple(s,t,d-f)<<endl;\n                Flow floop = max_flow(s,t,d-f);\n \n                // cerr <<make_tuple(floop,t+1,s+1) <<endl;\n                // cerr <<\"!flow!\"<<endl;\n                // REP(v,G.size())for(Edge& e2:G[v]){\n                //  Edge &reve2 = G[e2.to][e2.rev];\n                //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n                // }\n                // cerr <<endl;\n \n                // s <- t d戻す\n                e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n                // 減らす\n                e.cap-=e.icap - c;\n \n                e.icap = c;\n            }\n \n            // REP(v,G.size())for(Edge& e2:G[v])if(e2.ex){ \n            //  assert(e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n            // }\n            // REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex){ \n            //  assert(-e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n            // }\n \n \n            // cerr << s+1 <<\" \" << t+1 <<endl;\n            // cerr <<\"!pre:state!\"<<endl;\n            // REP(v,G.size())for(Edge& e2:G[v]){\n            //  Edge &reve2 = G[e2.to][e2.rev];\n            //  assert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n            //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n            // }\n            // cerr <<endl;\n \n            Flow _f = max_flow(S,T);  // cerr <<\"_f:\"<< _f <<endl; \n            flow += _f;\n \n            // cerr <<\"!post:state!\"<<endl;\n            // REP(v,G.size())for(Edge& e2:G[v]){\n            //  Edge &reve2 = G[e2.to][e2.rev];\n            //  assert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n            //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n            // }\n            // cerr <<endl;\n        }\n \n        // cerr <<\"f:\"<< flow <<endl;\n \n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(true){\n            fill(ALL(iter),0);\n            bfs_dist(s);\n            if(Mf==0 || dist[t] == -1)return flow; //限界\n            Flow f;\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return -1;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)if(s<t){\n    \t    int srev=mf.G[t].size(),trev=mf.G[s].size();\n    \t\tmf.G[s].push_back({t,srev,es[s][t],es[s][t],true});mf.G[t].push_back({s,trev,es[s][t],es[s][t],false});\n        }\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            // cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 21005;\nconst F MAXF = 1<<29;\n\nF cap[2*MAXE], flow[2*MAXE];\nint level[MAXV], edge[MAXV], seen[MAXV], to[2*MAXE];\n\nstruct MaxFlow {\n    int V, E, prev[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        seen[s] = 1;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == 0 && level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            memset(seen, 0, sizeof(seen));\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[to[e]] == -1 && flow[e] > 0) {\n                prev[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        flow[use_edge[v]] = flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[to[e]] == -1 && cap[e] - flow[e] > 0) {\n                prev[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    if (prev[t] == -1) return 0;\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        flow[use_edge[v]]++;\n        flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = edge[s]; e != -1; e = mf.prev[e])\n        if (to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) cap[e] = cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            printf(\"delete\\n\");\n            assert(e >= 0);\n            cap[e] = cap[e^1] = 0;\n            if (flow[e] != 0) {\n                f--;\n                if (flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                flow[e] = flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ツ堕敖嘉パツスツづーツ探ツ催オ\nint dfs(int v,int t,int f){\n  if(v == t)\n    return f;\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    bool b=false;\n    // ツづ慊つセツ古シツつォツつェツ個按づ慊づづつ「ツづ按つ「ツづ按づァツ、ツつアツつアツづ個按津ィ\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ツ債。ツ嘉アツ猟ャツつキツフツδ債ーツづ個古シツつォツづ可可楪つカツづ容ツ療環づーツ逆ツ転\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // ツフツδ債ーツつェツ猟ャツつケツづ按つゥツづつスツ湘ェツ債づ債、ツ個按づ慊づづつ「ツづ按つゥツづつスツつアツづづ可つキツづゥ\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowツつェツ猟ャツつケツづ按つュツづ按づゥツづ慊づ猟ャツつキ\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // ツ個サツ催敖づ慊づづ個催妥・ツ猟ャツ療環づーツ仰づ淞づつィツつュ\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // ツ各ツクツエツδ環づ個古」ツづ個猟ャツ療環づーツ仰づ淞づゥ\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ツづつづ按つョ\n    if(m==1){\n      add_edge(a,b,1);\n      // ツ催猟ャツ出\n      cFlow+=max_flow(1,n);\n    }\n    // ツ静伉断ツつキツづゥ\n    else{\n      if(!isDirected[a][b]){\n\tcout<<cFlow<<endl;\n\tcontinue;\n      }\n      // ツフツδ債ーツつェツつキツづづ可猟ャツづェツづつ「ツつスツ湘ェツ債、\n      // ツ湘ーツ個渉づーツ鳴楪つスツつキツづヲツつ、ツづ可フツδ債ーツづーツ可淞つオツ姪淞つキ\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ツ古シツつォツづ債個按づ慊づづつ「ツづゥツつェツ猟ャツ療\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0)\n\t    ff+=max_flow(a,b);\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0)\n\t    ff+=max_flow(b,a);\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b)\n\t      max_flow(n,b);\n\t    if(a!=1)\n\t      max_flow(a,1);\n\t    cFlow--;\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    if(b!=n)\n\t      max_flow(b,n);\n\t    if(a!=1)\n\t      max_flow(1,a);\n\t    cFlow--;\n\t  }\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a].erase(G[a].begin()+idx);\n      G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\nconst int MAX_V = 1000;\nconst int INF = 1 << 25;\n\nint V;\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, 0, int(G[from].size() - 1) });\n}\n\nvoid add_edge2(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, cap, int(G[from].size() - 1) });\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(edge& e : G[v]) {\n\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim) {\n\tint flow = 0;\n\twhile(1) {\n\t\tfill(used, used + V, false);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0 || flow == lim) return flow;\n\t\tflow += f;\n\t\tlim -= f;\n\t}\n\treturn -1;\n}\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nbool ex[1000][1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tint S = N, T = N + 1;\n\tV = N + 2;\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tadd_edge2(a, b, 1);\n\t\tex[a][b] = ex[b][a] = true;\n\t}\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tif(!ex[A[i]][B[i]]) {\n\t\t\tadd_edge2(A[i], B[i], 0);\n\t\t\tex[A[i]][B[i]] = ex[B[i]][A[i]] = true;\n\t\t}\n\t}\n\tadd_edge(S, 0, 1000000);\n\tadd_edge(N - 1, T, 1000000);\n\n\tint f = max_flow(S, T, INF);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tf += max_flow(S, T, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\tint c = e.cap;\n\n\t\t\t\t\tif(c == 0) {// u -> v\n\t\t\t\t\t\tif(max_flow(u, v, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(u, v, 1) != 0);\n\t\t\t\t\t\t\t//assert(max_flow(u, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, v, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 2) {// v -> u\n\t\t\t\t\t\tif(max_flow(v, u, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(T, S, 1);\n\t\t\t\t\t\t\tassert(max_flow(v, u, 1) != 0);\n\t\t\t\t\t\t\t//assert(max_flow(v, S, 1) == 1);\n\t\t\t\t\t\t\t//assert(max_flow(T, u, 1) == 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\te.cap = G[v][e.rev].cap = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << e.cap << ' ' << re.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\treturn -1 + fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tconst int v;\n\t\tvector<vector<Edge>> G;\n\t\tvector<bool> used;\n\t\tvector<int> level, iter; // s からの距離、どこまで調べ終わったか\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tlevel = vector<int>(v, -1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tFlow(int v) : v(v + 2), G(v + 2) { }\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, cap, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int u, int v){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == v){\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\treturn fordFulkerson(s, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false and \"invalid u, v\");\n\t\t\treturn -INF;\n\t\t}\n\t\tint subCapacity(int s, int t, int u, int V){\n\t\t\tfor(auto& e : G[u]){\n\t\t\t\tif(e.to == V){\n\t\t\t\t\tint d = e.cap;\n\t\t\t\t\te.cap = G[V][e.rev].cap = 0;\n\t\t\t\t\tif(d == 1) return 0;\n\t\t\t\t\tif(d == 2){\n\t\t\t\t\t\tif(fordFulkerson(V, u, 1)) return 0;\n\t\t\t\t\t\tfordFulkerson(t, u, 1);\n\t\t\t\t\t\tfordFulkerson(V, s, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(fordFulkerson(u, V, 1)) return 0;\n\t\t\t\t\t\tfordFulkerson(t, V, 1);\n\t\t\t\t\t\tfordFulkerson(u, s, 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn -INF;\n\t\t}\n\n\t\tint fordFulkerson(int s, int t, int F = INF){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tused = vector<bool>(v,0);\n\t\t\t\tint f = dfs(s, t, F);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\titer = vector<int>(v,0);\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n\nint main(){\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow(n);\n\tvector<vector<bool>> use(n, vector<bool>(n,false));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tflow.addEdge(f, t, 1);\n\t\tuse[t][f] = use[f][t] = true;\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not use[a[i]][b[i]]){\n\t\t\tflow.addEdge(a[i], b[i], 0);\n\t\t\tuse[a[i]][b[i]] = use[b[i]][a[i]] = true;\n\t\t}\n\t}\n\n\tint s = n, t = s + 1;\n\tflow.addEdge(s,0,INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\trep(i,q){\n\t\tif(com[i] == 1) ans += flow.addCapacity(s, t, a[i], b[i]);\n\t\telse ans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\nconst int MAX_V = 1000;\nconst int INF = 1 << 25;\n\nint V;\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, cap, int(G[from].size() - 1) });\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(edge& e : G[v]) {\n\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t, int lim) {\n\tint flow = 0;\n\twhile(1) {\n\t\tfill(used, used + V, false);\n\t\tint f = dfs(s, t, lim);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n\treturn -1;\n}\n\nint M[1000];\nint A[1000];\nint B[1000];\n\nbool ex[1000][1000];\n\ntypedef pair<int, int> Pii;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, Q;\n\tcin >> N >> E >> Q;\n\n\tint S = N, T = N + 1;\n\tV = N + 2;\n\tfor(int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tadd_edge(a, b, 1);\n\t\tex[a][b] = ex[b][a] = true;\n\t}\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> M[i] >> A[i] >> B[i];\n\t\tA[i]--, B[i]--;\n\t\tif(!ex[A[i]][B[i]]) {\n\t\t\tadd_edge(A[i], B[i], 0);\n\t\t\tex[A[i]][B[i]] = ex[B[i]][A[i]] = true;\n\t\t}\n\t}\n\tadd_edge(S, 0, 1000000);\n\tadd_edge(N - 1, T, 1000000);\n\tint f = max_flow(S, T, INF);\n\n\tfor(int i = 0; i < Q; i++) {\n\t\tint m = M[i], u = A[i], v = B[i];\n\t\tif(m == 1) {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\te.cap = G[v][e.rev].cap = 1;\n\t\t\t\t\tf += max_flow(S, T, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(edge& e : G[u]) {\n\t\t\t\tif(e.to == v) {\n\t\t\t\t\tint c = e.cap;\n\t\t\t\t\te.cap = G[v][e.rev].cap = 0;\n\t\t\t\t\tif(c == 0) {// u -> v\n\t\t\t\t\t\tif(max_flow(u, v, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(u, S, 1);\n\t\t\t\t\t\t\tmax_flow(T, v, 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 2) {// v -> u\n\t\t\t\t\t\tif(max_flow(v, u, 1) == 0) {\n\t\t\t\t\t\t\tmax_flow(v, S, 1);\n\t\t\t\t\t\t\tmax_flow(T, u, 1);\n\t\t\t\t\t\t\tf--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=int;\n\nstruct Edge{\n    int from,to;\n    Weight cap;\n    bool rev;\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs){\n    if(lhs.from!=rhs.from) return lhs.from<rhs.from;\n    if(lhs.to!=rhs.to) return lhs.to<rhs.to;\n    if(lhs.cap!=rhs.cap) return lhs.cap<rhs.cap;\n    return lhs.rev<rhs.rev;\n}\nusing Edges=multiset<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    Graph g;\n    Weight nowF=0;\n    const Weight INF=1e9;\n    Weight dfs(int v,int t,stack<int>& st,vector<int> &used){\n        if(used[v]) return 0;\n        if(v==t) return INF;\n        used[v]=true;\n        for(auto &e:g[v]){\n            if(e.cap==0) continue;\n            Weight f=dfs(e.to,t,st,used);\n            if(f>0){\n                st.push(v);\n                return min(f,e.cap);\n            }   \n        }\n        return 0;\n    }\n    Edges::iterator rettf(int fr,int to,int cap,Edges &edges){\n        auto res=edges.find(Edge{fr,to,cap,true});\n        if(res==edges.end()) res=edges.find(Edge{fr,to,cap,false});\n        return res;\n    }\n    public:\n    Flow(int n):g(n){}\n    void addEdge(int from,int to,Weight cap){\n        g[from].insert(Edge{from,to,cap,false});\n        g[to].insert(Edge{to,from,0,true});\n    }\n    Weight maxFlow(int s,int t){\n        Weight res=0;\n        Weight f;\n        vector<int> used(g.size(),false);\n        stack<int> st;\n        while(f=dfs(s,t,st,used)){\n            res+=f;\n            while(!st.empty()){\n                int fr=st.top(); st.pop();\n                int to=(st.empty() ? t : st.top());\n                auto it0=rettf(fr,to,1,g[fr]);\n                auto it1=g[to].find(Edge{to,fr,0,!(it0->rev)});\n                assert(it0!=g[fr].end() && it1!=g[to].end());\n                g[fr].insert(Edge{fr,to,0,it0->rev});\n                g[fr].erase(it0);\n                g[to].insert(Edge{to,fr,1,it1->rev});\n                g[to].erase(it1);\n            }\n            fill(used.begin(),used.end(),false);\n        }\n        return nowF=nowF+res;\n    }\n\n    void decEdge(int fr,int to,int s,int t){\n        if(g[fr].find(Edge{fr,to,0,false})==g[fr].end()){\n            g[fr].erase(Edge{fr,to,1,false});\n            g[to].erase(Edge{to,fr,0,true});\n            return;\n        }\n        g[fr].erase(g[fr].find(Edge{fr,to,0,false}));        \n        g[to].erase(g[to].find(Edge{to,fr,1,true}));\n        nowF--;\n        vector<int> used(g.size(),false);\n        stack<int> st;\n        int f0=dfs(fr,s,st,used);\n        assert(f0>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? s : st.top());\n            auto it0=rettf(frr,too,1,g[frr]);\n            auto it1=g[too].find(Edge{too,frr,0,!(it0->rev)});\n            g[frr].insert(Edge{frr,too,0,it0->rev});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,it1->rev});\n            g[too].erase(it1);\n        }\n        \n        fill(used.begin(),used.end(),0);\n        int f1=dfs(t,to,st,used);        \n        assert(f1>0);\n        while(!st.empty()){\n            int frr=st.top(); st.pop();\n            int too=(st.empty() ? to : st.top());\n            auto it0=rettf(frr,too,1,g[frr]);\n            auto it1=g[too].find(Edge{too,frr,0,!(it0->rev)});\n            assert(it0!=g[frr].end());\n            assert(it1!=g[too].end());\n            g[frr].insert(Edge{frr,too,0,it0->rev});\n            g[frr].erase(it0);\n            g[too].insert(Edge{too,frr,1,it1->rev});\n            g[too].erase(it1);\n        }\n    } \n};\n\nint main(){\n    int n,e,q;\n    cin>>n>>e>>q;\n    Flow flow(n);\n    for(int i=0;i<e;i++){\n        int f,t;\n        cin>>f>>t;\n        f--,t--;\n        flow.addEdge(f,t,1);\n        flow.addEdge(t,f,1);\n    }\n    for(int i=0;i<q;i++){\n        int m,a,b;\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            flow.addEdge(a,b,1);\n            flow.addEdge(b,a,1);\n        }\n        if(m==2){\n            flow.decEdge(a,b,0,n-1);\n            flow.decEdge(b,a,0,n-1);\n        }\n        cout<<flow.maxFlow(0,n-1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, cap, (int)graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return(flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0 && max_flow(from, to, 1) == 0) {\n          max_flow(from, 0, 1);\n          max_flow(graph.size() - 1, to, 1);\n          return(1);\n        } else {\n          return(0);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=1;\n    G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=0;\n    G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        int &c = G[v][i];\n        if(!used[i]&&c>0){\n            int d=dfs(i,t,min(f,c));\n            if(d>0){\n                c-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    cin>>V>>E>>Q;\n    f(i,E){\n        cin>>F>>T;\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n            now+=max_flow(0,V-1);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(b,V-1,1);\n                    now--;\n                }\n            }\n        }\n        cout<<now<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > &G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    //scanf(\"%d%d\",&f,&t);\n    cin >> f >> t;\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b, flow = 0;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      //G[a][2*b + 1].cap = 0;\n      G[b][2*a].cap = 1;\n      //G[b][2*a + 1].cap = 0;\n    }else{\n      G[a][2*b].cap = 0;\n      //G[a][2*b + 1].cap = 0;\n      G[b][2*a].cap = 0;\n      //G[b][2*a + 1].cap = 0;\n    }\n    flow += max_flow(0, N-1, G);\n    printf(\"%d\\n\", flow);\n    flow -= max_flow(N-1, 0, G);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\ntypedef int Weight;\nconst Weight INF=99999999;\nstruct Edge{\n\tint src,dst;\n\tWeight weight;\n\tint rev;\n\tEdge(int f, int t, Weight c,int rev=0):src(f),dst(t),weight(c),rev(rev){}\n};\ntypedef vector< vector<Edge> > Graph;\n\npii add_edge(Graph &G,int s,int t,Weight cap){\n\tG[s].push_back(Edge(s,t,cap,G[t].size()));\n\tG[t].push_back(Edge(t,s,cap,G[s].size()-1));\n\treturn pii(G[s].size()-1, G[t].size()-1);\n}\n\n\nvoid bfs(const Graph &G,vector<int> &level,int s){\n\tlevel[s]=0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();que.pop();\n\t\tREP(i,G[v].size()){\n\t\t\tconst Edge &e=G[v][i];\n\t\t\tif(e.weight>0 && level[e.dst] < 0){\n\t\t\t\tlevel[e.dst] = level[v] +1;\n\t\t\t\tque.push(e.dst);\n\t\t\t}\n\t\t}\n\t}\n}\nWeight dfs(Graph &G,vector<int> &level,vector<int> &iter,int v,int t,Weight flow){\n\tif(v==t)return flow;\n\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\tEdge &e=G[v][i];\n\t\tif(e.weight>0&&level[v]<level[e.dst]){\n\t\t\tWeight d=dfs(G,level,iter,e.dst,t,min(flow,e.weight));\n\t\t\tif(d>0){\n\t\t\t\te.weight-=d;\n\t\t\t\tG[e.dst][e.rev].weight+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\nreturn 0;\n}\n\n// Dinic\n// O(EV^2)\nWeight max_flow(Graph &G,int s,int t,int f=0){\n\tstatic Weight flow = 0;\n\twhile(true){\n\t\tvector<int> level(G.size(),-1);\n\t\tvector<int> iter(G.size(),0);\n\t\tbfs(G,level,s);\n\t\tif(level[t]<0)break; // もう流せない\n\t\tif(f){\n\t\t\tdfs(G,level,iter,s,t,1);\n\t\t\treturn 1;\n\t\t}\n\t\tWeight f=0;\n\t\twhile((f=dfs(G,level,iter,s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\nint N, E, Q;\nint idx[501][501];\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> N >> E >> Q;\n\tmemset(idx, -1, sizeof(idx));\n\tGraph g(N);\n\tREP(i, E){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tif(idx[u][v] < 0){\n\t\t\tpii res = add_edge(g, u, v, 0);\n\t\t\tidx[u][v] = res.first;\n\t\t\tidx[v][u] = res.second;\n\t\t}\n\t\tg[u][idx[u][v]].weight ++;\n\t\tg[v][idx[v][u]].weight ++;\n\t}\n\tint cur = 0;\n\tREP(i, Q){\n\t\tint u, v, f;\n\t\tcin >> f >> u >> v;u--;v--;\n\t\tif(idx[u][v] < 0){\n\t\t\tpii res = add_edge(g, u, v, 0);\n\t\t\tidx[u][v] = res.first;\n\t\t\tidx[v][u] = res.second;\n\t\t}\n\t\tif(f == 1){\n\t\t\tg[u][idx[u][v]].weight ++;\n\t\t\tg[v][idx[v][u]].weight ++;\n\t\t}else{\n\t\t\tREP(j, 2){\n\t\t\t\tif(g[u][idx[u][v]].weight == 0){\n\t\t\t\t\tmax_flow(g, N-1, v, 1);\n\t\t\t\t\tmax_flow(g, u, 0, 1);\n\t\t\t\t\tcur ++;\n\t\t\t\t}else g[u][idx[u][v]].weight --;\n\t\t\t\tswap(u, v);\n\t\t\t}\n\t\t}\n\t\tcout << (max_flow(g, 0, N-1) - cur) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000;\nint cap[1000][1000];\n\nint maximumFlow(int n, int s, int t, bool first = false){\n\tint res = 0;\n\twhile(true) {\n\t\tqueue<int> qu; qu.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile(!qu.empty()&&prev[t]<0){\n\t\t\tint u = qu.front(); qu.pop();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(prev[i]<0&&cap[u][i]>0){\n\t\t\t\t\tprev[i] = u;\n\t\t\t\t\tqu.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(prev[t] < 0) return res;\n\t\tint inc = INF;\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tinc = min(inc, cap[prev[j]][j]);\n\t\tfor(int j=t;prev[j]!=j;j=prev[j])\n\t\t\tcap[prev[j]][j] -= inc, cap[j][prev[j]] += inc;\n\t\tres += inc;\n\t\tif(!first) return res;\n\t}\n\treturn 0;\n}\nint main(){\n\tint N, E, Q;\n\twhile(cin >> N >> E >> Q){\n\t\tmemset(cap, 0, sizeof(cap));\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint F, T; scanf(\"%d %d\", &F, &T);\n\t\t\tcap[F-1][T-1] = 1;\n\t\t\tcap[T-1][F-1] = 1;\n\t\t}\n\t\tint cur = maximumFlow(N, 0, N-1, true);\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint M, A, B; scanf(\"%d %d %d\", &M, &A, &B);\n\t\t\tif(M==1){\n\t\t\t\tcap[A-1][B-1] = 1;\n\t\t\t\tcap[B-1][A-1] = 1;\n\t\t\t\tcur += maximumFlow(N, 0, N-1);\n\t\t\t}\n\t\t\tif(M==2){\n\t\t\t\t// A->B gpÏÝ\n\t\t\t\tif(cap[A-1][B-1] == 0){\n\t\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t\t\tint tmp = maximumFlow(N, A-1, B-1); \n\t\t\t\t\tcur += tmp-1;\n\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\tint c = B-1;\n\t\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = A-1;\n\t\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cap[B-1][A-1] == 0){\n\t\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\t\tint tmp = maximumFlow(N, B-1, A-1);\n\t\t\t\t\tcur += tmp-1;\n\t\t\t\t\tif(tmp==0){\n\t\t\t\t\t\tint c = A-1;\n\t\t\t\t\t\twhile(c!=N-1){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[j][c] == 2){\n\t\t\t\t\t\t\t\t\tcap[j][c] = cap[c][j] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = B-1;\n\t\t\t\t\t\twhile(c!=0){\n\t\t\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\t\t\tif(cap[c][j] == 2){\n\t\t\t\t\t\t\t\t\tcap[c][j] = cap[j][c] = 1, c = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcap[A-1][B-1] = 0;\n\t\t\t\t\tcap[B-1][A-1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << cur << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG1\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG1\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG1\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\trep(j,n)vis[j]=false;\n\tint fordFulkerson(const int n,const int t,int now,int fl);\n\ttmp=fordFulkerson(n,to,from,1);\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,from,s);\n\t  fordFulkerson(n,s,from,1);\n\t  rep(j,n)vis[j]=false;\n\t  //dfs(n,t,to);\n\t  fordFulkerson(n,to,t,1);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tmax_flow(t, to, G[to][x.rev].cap);\n\t\t\tmax_flow(from, s, G[to][x.rev].cap);\n\t\t\tflow = prev - G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor(auto &x:G[from]) {\n\t\t\tif (!x.add || x.cap + G[to][x.rev].cap != cap || x.to != to || x.cost != cost)continue;\n\t\t\tmin_cost_flow(t, to, G[to][x.rev].cap);\n\t\t\tmin_cost_flow(from, s, G[to][x.rev].cap);\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\tFlow flow(n, 1, n);\n\trep(i, e) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tflow.add_edge(f, t, 1);\n\t\tflow.add_edge(t, f, 1);\n\t}\n\tint offset = 0;\n\trep(i, q) {\n\t\tint m, a, b;\n\t\tcin >> m >> a >> b;\n\t\tif (m == 1) {\n\t\t\tflow.add_edge(a, b, 1);\n\t\t\tflow.add_edge(b, a, 1);\n\t\t}\n\t\telse {\n\t\t\tflow.remove_edge_max(a, b, 1);\n\t\t\tflow.remove_edge_max(b, a, 1);\n\t\t}\n\t\tcout << flow.max_flow() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 555;\nconst int INF = 1000000000;\n\nint n,e,q;\n\n\nint flow[N][N];\nint edge[N][N];\n\nbool init(){\n\trep(i,N)rep(j,N)flow[i][j]=edge[i][j]=0;\n\tcin>>n>>e>>q;\n\trep(i,e){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tedge[a][b]=1;\n\t\tedge[b][a]=1;\n\t}\n}\n\nint update_edge(int a,int b,int c){\n\tint ret = 0;\n\tif(a==1){\n\t\tedge[b][c]++;\n\t\tedge[c][b]++;\n\t}\n\tif(a==2){\n\t\tedge[b][c]--;\n\t\tedge[c][b]--;\n\t\tret = max(ret, flow[b][c]-edge[b][c]);\n\t\tret = max(ret, flow[c][b]-edge[c][b]);\n\t\tflow[b][c] = min(flow[b][c], edge[b][c]);\n\t\tflow[c][b] = min(flow[c][b], edge[c][b]);\n\t}\n\treturn ret;\n}\n\nvoid printflow(){\n\tprintf(\"flow:\\n\");\n\trep(i,n+2){\n\t\trep(j,n+2){\n\t\t\tprintf(\"%2d \",flow[i][j]);\n\t\t}puts(\"\");\n\t}\n\tprintf(\"edge\\n\");\n\trep(i,n+2){\n\t\trep(j,n+2){\n\t\t\tif(edge[i][j]==INF)printf(\"oo \");\n\t\t\telse printf(\"%2d \",edge[i][j]);\n\t\t}puts(\"\");\n\t}puts(\"\\n\");\n}\nint visit[N];\nint flowrec(int pos, int en, int f){\n\tif(visit[pos]==1)return 0;\n\tvisit[pos]=1;\n\t\n\tif(pos==en)return f;\n\t\n\trep(i,N){\n\t\tint f1 = edge[pos][i] - flow[pos][i];\n\t\tint f2 = flow[i][pos];\n\t\t\n\t\tif(f1!=0 && f2==0){\n\t\t\tint val = flowrec(i, en, min(f,f1));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"flow %d %d\\n\",pos,i);\n\t\t\t\tflow[pos][i]+=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t\tif(f2!=0){\n\t\t\tint val = flowrec(i, en, min(f,f2));\n\t\t\tif(val!=0){\n\t\t\t\t//printf(\"rflow %d %d\\n\",i,pos);\n\t\t\t\tflow[i][pos]-=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flowing(int st, int en){\n\tint ret = 0;\n\twhile(1){\n\t\trep(i,N)visit[i]=0;\n\t\t\n\t\tint val = flowrec(st, en, INF);\n\t\tif(val==0)break;\n\t\tret += val;\n\t}\n\treturn ret;\n}\n\nint reflowrec(int pos,int en,int f){\n\tif(visit[pos]==1)return 0;\n\tvisit[pos]=1;\n\t\n\tif(pos==en)return f;\n\t\n\trep(i,N){\n\t\tint f1 = flow[i][pos];\n\t\tif(f1!=0){\n\t\t\tint val = reflowrec(i, en, min(f,f1));\n\t\t\tif(val!=0){\n\t\t\t\tflow[i][pos]-=val;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nvoid reflowing(bool bc, int st, int en, int b, int c){\n\tif(bc){\n\t\t//printf(\"flow[%d][%d] %d\\n\",b,c,flow[b][c]);\n\t\tint val = flowing(b,c);\n\t\tif(val==0){\n\t\t\t//printf(\"* val=0\\n\");\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(b, st, 1);\n\t\t\t\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(en, c, 1);\n\t\t}\n\t}else{\n\t\t//printf(\"flow[%d][%d] %d\\n\",c,b,flow[c][b]);\n\t\tint val = flowing(c,b);\n\t\t\n\t\tif(val==0){\n\t\t\t//printf(\"* val=0\\n\");\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(c, st, 1);\n\t\t\t\n\t\t\trep(i,N)visit[i]=0;\n\t\t\treflowrec(en, b, 1);\n\t\t}\n\t}\n}\n\nvoid setflow(){\n\tedge[0][1]=INF;\n\tedge[n][n+1]=INF;\n}\nvoid solve(){\n\t\n\tsetflow();\n\tint st = 0;\n\tint en = n+1;\n\t\n\tint retsum = 0;\n\t\n\tretsum += flowing(st, en);\n\t//printflow();\n\t\n\trep(i,q){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t\n\t\tbool bc = flow[b][c]>0;\n\t\t\n\t\tint dec = update_edge(a,b,c);\n\t\tretsum -= dec;\n\t\t\n\t\tif(a==1){\n\t\t\tretsum += flowing(st, en);\n\t\t}\n\t\tif(a==2){\n\t\t\tif(dec!=0){\n\t\t\t\t//printf(\"dec!=0\\n\");\n\t\t\t\treflowing(bc, st, en, b, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",flow[n][n+1]);\n\t\t//printflow();\n\t}\n}\n\nint main(){\n\tinit();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 0;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 0;\n\t\t\t\tif(!flow(a, 1, 1))return 0;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res, ok[1050][1050];\n\nint dfs(int s, int g, int cp){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(ok[j][i] < cp)continue;\n\t\tif(dfs(i, g, cp)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g, int cp = 0){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g, cp);\n}\n\nvoid color(){\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= n;j++)\n\t\t\tok[i][j] = used[i][j] != used[j][i];\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a, 1))return 1;\n\t\t\t\tif(!flow(b, 1, 1))return 1;\n\t\t\t}\n\t\t\telse if(used[b][a] == 2){\n\t\t\t\tcolor();\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b, 1))return 1;\n\t\t\t\tif(!flow(a, 1, 1))return 1;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n//template <typename Flow>\n//struct FEdge {\n//\tint from, to;\n//\tFlow cap; int rev;\n//\tFEdge(int s, int t, Flow f, int r) : from(s), to(t), cap(f), rev(r) {}\n//};\n//\n//template<typename Flow> using FGraph = vector<vector<FEdge<Flow>>>;\n//\n//template <typename Flow>\n//void add_edge(FGraph<Flow> &g, int from, int to, Flow cap) {\n//\tg[from].emplace_back(from, to, cap, (int)g[to].size());\n//\tg[to].emplace_back(to, from, 0, (int)g[from].size() - 1);\n//}\n//\n//template <typename Flow>\n//Flow augment(FGraph<Flow> &g, vector<Flow> &d, vector<int> &iter,\n//\tint v, int t, const Flow &f) {\n//\tif (v == t) return f;\n//\tfor (int &i = iter[v]; i < (int)g[v].size(); i++) {\n//\t\tauto &e = g[v][i];\n//\t\tif (e.cap > 0 && d[v] < d[e.to]) {\n//\t\t\tFlow ff = augment(g, d, iter, e.to, t, min(f, e.cap));\n//\t\t\tif (ff > 0) {\n//\t\t\t\te.cap -= ff;\n//\t\t\t\tg[e.to][e.rev].cap += ff;\n//\t\t\t\treturn ff;\n//\t\t\t}\n//\t\t}\n//\t}\n//\treturn 0;\n//}\n//\n//template <typename Flow>\n//Flow max_flow(FGraph<Flow> &g, int s, int t, Flow fl = INF, Flow zero = 0) {\n//\tif (s == t) return 0;\n//\tconst int V = g.size();\n//\tFlow flow = zero;\n//\tfor (;;) {\n//\t\tvector<Flow> d(V, -1);\n//\t\tqueue<int> que;\n//\t\td[s] = zero;\n//\t\tque.push(s);\n//\t\twhile (!que.empty()) {\n//\t\t\tint v = que.front(); que.pop();\n//\t\t\tfor (const auto &e : g[v]) {\n//\t\t\t\tif (e.cap <= zero || d[e.to] >= zero) continue;\n//\t\t\t\td[e.to] = d[v] + 1;\n//\t\t\t\tque.push(e.to);\n//\t\t\t}\n//\t\t}\n//\t\tif (d[t] < zero)\n//\t\t{\n//\t\t\treturn flow;\n//\t\t}\n//\t\tvector<int> iter(V, 0);\n//\t\tFlow f;\n//\t\twhile ((f = augment(g, d, iter, s, t, fl)) > 0) flow += f;\n//\t}\n//}\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int t, Flow f, int r) : src(s), dest(t), cap(f), rev(r) {}\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\n\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow max_flow(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nFlow unit_flow(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tvector<bool> used(g.size(), false);\n\tFlow f = dfs(g, used, s, t, 1);\n\tflow += f;\n\treturn flow;\n}\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\t//FGraph<int> g(n);\n\tGraph g(n);\n\tREP(i, n)REP(j, n)\n\t{\n\t\tg[i].emplace_back(i, j, 0, i);\n\t}\n\tREP(i, e)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b].cap++;\n\t\tg[b][a].cap++;\n\t}\n\tint tmp = max_flow(g, 0, n - 1);\n\tREP(i, q)\n\t{\n\t\tint a, b, c;\n\t\tcin >> c >> a >> b;\n\t\ta--; b--;\n\t\tif (c == 1)\n\t\t{\n\t\t\tassert(g[a][b].cap == 0 && g[b][a].cap == 0);\n\t\t\tg[a][b].cap++;\n\t\t\tg[b][a].cap++;\n\t\t\ttmp += unit_flow(g, 0, n - 1);\n\t\t}\n\t\tif (c == 2)\n\t\t{\n\t\t\tassert(g[a][b].cap != 0 || g[b][a].cap != 0);\n\t\t\tif (g[a][b].cap == 1 && g[b][a].cap == 1)\n\t\t\t{\n\t\t\t\tg[a][b].cap--;\n\t\t\t\tg[b][a].cap--;\n\t\t\t}\n\t\t\telse if (g[a][b].cap == 2 && g[b][a].cap == 0)\n\t\t\t{\n\t\t\t\ttmp--;\n\t\t\t\tunit_flow(g, b, 0);\n\t\t\t\tunit_flow(g, n-1, a);\n\t\t\t\ttmp += unit_flow(g, 0, n - 1);\n\t\t\t}\n\t\t\telse if (g[a][b].cap == 0 && g[b][a].cap == 2)\n\t\t\t{\n\t\t\t\ttmp--;\n\t\t\t\tunit_flow(g, a, 0);\n\t\t\t\tunit_flow(g, n - 1, b);\n\t\t\t\ttmp += unit_flow(g, 0, n - 1);\n\t\t\t}\n\t\t\telse assert(false);\n\t\t\tg[a][b].cap = g[b][a].cap = 0;\n\t\t}\n\t\tcout << tmp << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n \n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter, used;\n  int flow;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n \n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge){to, cap, (int)graph[to].size(), true});\n    graph[to].push_back((edge){from, 0, (int)graph[from].size() - 1, true});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front(); que.pop();\n      for(const edge& e : graph[p]) {\n        if(!e.alive) continue;\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return(min_cost[t] != -1);\n  }\n   \n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return(flow);\n    for(int i = iter[idx]; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return(d);\n        }\n      }\n    }\n    return(0);\n  }\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(flow < lim && bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      int f = 0;\n      while((f = dfs(s, t, lim - flow)) > 0) {\n        flow += f;\n      }\n    }\n    return(flow);\n  }\n\n  bool remove_edge(int from, int to)\n  {\n    bool flag = false;\n    for(edge& e : graph[from]) {\n      if(e.to == to && e.alive) {\n        edge& re = graph[e.to][e.rev];\n        if(e.cap == 0) {\n          if(max_flow(from, to, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(from, to, 1);\n            flag = true;\n          }\n        } else if(re.cap == 0) {\n          if(max_flow(to, from, 1) == 0) {\n            max_flow(graph.size() - 1, 0, 1);\n            max_flow(to, from, 1);\n            flag = true;\n          }\n        }\n        e.alive = re.alive = false;\n        return(flag);\n      }\n    }\n  }\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n    graph.add_edge(T, F, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      graph.add_edge(B, A, 1);\n    } else {\n      flow -= graph.remove_edge(A, B);\n    }\n    flow += graph.max_flow(0, N - 1, INF);\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int MAX_N = 510;\n\nint N, E, Q, G[MAX_N][MAX_N];\n\nint dfs(int now, int g, vector<bool> &visited){\n  visited[now] = true;\n  if(now == g) return 1;\n  REP(i, N){\n    if(visited[i] || G[now][i] <= 0) continue;\n    if(dfs(i, g, visited)){\n      ++G[i][now];\n      --G[now][i];\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint flow(int s, int t){\n  vector<bool> visited(N, false);\n  return dfs(s, t, visited);\n}\n\nint main() {\n  int ans = 0;\n  cin >>N >>E >>Q;\n  memset(G, 0, sizeof(G));\n  REP(i, E){\n    int f, t; cin >>f >>t;\n    --f; --t;\n    G[f][t] = G[t][f] = 1;\n  }\n  REP(i, Q){\n    int m, f, t; cin >>m >>f >>t;\n    --f; --t;\n    if(m == 1) G[f][t] = G[t][f] = 1;\n    else {\n      if(G[f][t] == 2) { flow(N - 1, 0); flow(t, f); --ans; }\n      else if(G[t][f] == 2) { flow(N - 1, 0); flow(f, t); --ans; }\n      G[f][t] = G[t][f] = 0;\n    }\n    while(flow(0, N - 1)) ++ans;\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,P> idx;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  idx[P(from,to)].second=G[to].size();\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n  idx[P(from,to)].first=G[from].size()-1;\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int n,e,q,a,b,m;\n  cin>>n>>e>>q;\n  for(int i=0;i<e;i++){\n    cin>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    add_edge(a,b,1);\n  }\n  int ans=max_flow(0,n-1);\n  for(int i=0;i<q;i++){\n    cin>>m>>a>>b; a--; b--;\n    if(a>b)swap(a,b);\n    if(m==1){\n      add_edge(a,b,1);\n      ans+=max_flow(0,n-1);\n    }else{\n      P x=idx[P(a,b)];\n      int s=-1,t=-1;\n      if(!G[a][x.first].cap)s=a,t=b;\n      if(!G[b][x.second].cap)s=b,t=a;\n      G[a][x.first].cap=0;\n      G[b][x.second].cap=0;\n      if(s>=0&&t>=0){\n\tint r=max_flow(s,t);\n\tif(!r){\n\t  ans=max(0,ans-1);\n\t  if(s!=0)max_flow(s,0);\n\t  if(t!=n-1)max_flow(n-1,t);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nclass Flow\n{\npublic:\n    using T = int;\n    struct Edge\n    {\n        int from, to, revind;\n        T capacity, flow;\n        bool reversed;\n    };\n    Flow(const int v) : V{v}, edge(v) {}\n    int addEdge(const int from, const int to, const T capacity) { return edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, 0, false}), edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, capacity, capacity, true}), edge[from].size() - 1; }\n    T FordFulkerson(const int s, const int t, const T limit = INF<T>)\n    {\n        vector<bool> checked(V);\n        auto dfs = fix([&](auto&& self, const int pos, const T& flow) -> T {\n            if (pos == t) { return flow; }\n            checked[pos] = true;\n            for (auto& e : edge[pos]) {\n                if (checked[e.to]) { continue; }\n                const T res = e.capacity - e.flow;\n                if (res == 0) { continue; }\n                const T d = self(self, e.to, min(flow, res));\n                if (d > 0) { return e.flow += min(d, res), edge[e.to][e.revind].flow -= min(d, res), d; }\n            }\n            return 0;\n        });\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) { checked[i] = false; }\n            const T f = dfs(s, limit);\n            flow += f;\n            if (f == 0 or flow >= limit) { break; }\n        }\n        return flow;\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n};\n\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Flow f(N);\n    map<pair<int, int>, pair<int, int>> mp;\n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        F--, T--;\n        if (F > T) { swap(F, T); }\n        mp[{F, T}] = {f.addEdge(F, T, 1), f.addEdge(T, F, 1)};\n    }\n    int flow = f.FordFulkerson(0, N - 1);\n    for (int q = 0; q < Q; q++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A--, B--;\n        if (A > B) { swap(A, B); }\n        if (M == 1) {\n            mp[{A, B}] = {f.addEdge(A, B, 1), f.addEdge(B, A, 1)};\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        } else {\n            const auto es = mp[{A, B}];\n            const int i1 = es.first, i2 = es.second, r1 = f.edge[A][i1].revind, r2 = f.edge[B][i2].revind;\n            auto &e1 = f.edge[A][i1], &e2 = f.edge[B][i2], &e3 = f.edge[A][r2], &e4 = f.edge[B][r1];\n            if (e1.flow + e3.flow == 1) {\n                cout << flow << endl;\n                e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n                continue;\n            }\n            flow--;\n            const bool A_B = e1.flow == 1;\n            const int u = A_B ? A : B, v = A_B ? B : A;\n            e1.capacity = e1.flow = e2.capacity = e2.flow = e3.capacity = e3.flow = e4.capacity = e4.flow = 0;\n            f.FordFulkerson(u, 0, 1), f.FordFulkerson(N - 1, v, 1);\n            cout << (flow += f.FordFulkerson(0, N - 1, 1)) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n  bool flag;\n};\n\nconst int MAX_V = 550;\nconst int INF = 100000000;\n\nbool isDirected[MAX_V][MAX_V];\nint FlowFrom[MAX_V][MAX_V];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  edge e;\n  e.to = to;\n  e.cap = cap;\n  e.rev = G[to].size();\n  e.flag=true;\n  G[from].push_back(e);\n  e.to = from;\n  e.cap = 0;\n  e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n  if(v==t)\n    return f;\n  used[v]=true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    if(!e.flag)continue;\n    bool b=false;\n    // Ü¾ü«ªÜÁÄ¢È¢ÈçA±±Åè\n    if(!isDirected[v][e.to]){\n      b=true;\n      isDirected[v][e.to]=true;\n      isDirected[e.to][v]=true;\n      // ¡ñ¬·t[Ìü«É¶ÄeÊðt]\n      if(e.cap==0){\n\te.cap=1;\n\tG[e.to][e.rev].cap=0;\n      }\n      FlowFrom[v][e.to]=v;\n      FlowFrom[e.to][v]=v;\n    }\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n    // t[ª¬¹È©Á½êÍAÜÁÄ¢È©Á½±ÆÉ·é\n    if(b){\n      isDirected[v][e.to]=false;\n      isDirected[e.to][v]=false;\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow = 0;\n  // flowª¬¹È­ÈéÜÅ¬·\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f=dfs(s,t,INF);\n    if(f==0)\n      return flow;\n    else\n      flow+=f;\n  }\n}\nint one_flow(int s,int t){\n  // flowª¬¹È­ÈéÜÅ¬·\n  fill(used,used+MAX_V,false);\n  int f=dfs(s,t,INF);\n  return f;\n}\n\n\nint n,e,q;\nint main(){\n  memset(isDirected,0,sizeof(isDirected));\n  memset(FlowFrom,0,sizeof(FlowFrom));\n  cin>>n>>e>>q;\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin>>f>>t;\n    add_edge(f,t,1);\n  }\n  // »ÝÜÅÌÅå¬ÊðßÄ¨­\n  int cFlow=max_flow(1,n);\n  //  cout<<cFlow<<endl;\n  // eNGÌãÌ¬Êðßé\n  for(int i = 0; i < q; i++){\n    int m,a,b;\n    cin>>m>>a>>b;\n    int idx;\n    int ridx;\n    // ÂÈ®\n    if(m==1){\n      add_edge(a,b,1);\n      // Ä¬o\n      cFlow+=max_flow(1,n);\n    }\n    // Øf·é\n    else{\n      // ØfÓªÜ¾Êß³êÄ¢È¢ê\n      if(!isDirected[a][b]){\n\t//cout<<cFlow<<endl;\n\tfor(int j = 0; j < G[a].size(); j++){\n\t  if(G[a][j].to==b&&G[a][j].flag){\n\t    edge &e=G[a][j];\n\t    G[a][j].flag=false;\n\t    G[b][e.rev].flag=false;\n\t    // G[a].erase(G[a].begin()+j);\n\t    // G[b].erase(G[b].begin()+e.rev);\n\t    isDirected[a][b]=false;\n\t    isDirected[b][a]=false;\n\t    break;\n\t  }\n\t}\n\tcontinue;\n      }\n      // t[ª·ÅÉ¬êÄ¢½êA\n      // ðð½·æ¤Ét[ðµß·\n      for(int j = 0; j < G[a].size(); j++){\n\tif(G[a][j].to==b&&G[a][j].flag){\n\t  idx=j;\n\t  edge &e=G[a][j];\n\t  ridx=e.rev;\n\t  // ü«ÍÜÁÄ¢éª¬Ê0\n\t  if((FlowFrom[a][b]==a&&e.cap==1)\n\t     ||(FlowFrom[b][a]==b&&G[b][e.rev].cap==1))\n\t    break;\n\t  // Ü¸a,bÔÅÊ[gÅt[ð¬¹é©`FbN\n\t  // ¬¹éÈçÎA»¿çÌ[gÅ¬·\n\t  int ff=0;\n\t  // from a to bÅ¬êÄ¢é\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    //cout<<\"from a to b\"<<endl;\n\t    ff+=one_flow(a,b);\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0)\n\t    ff+=one_flow(b,a);\n\t  // ¬ê½çbreak\n\t  //cFlow+=ff;\n\t  if(ff>=1)\n\t    break;\n\t  // ¬¹È¯êÎ\n\t  // µß·\n\t  int f=0;\n\t  //cout<<\"reverse flow\"<<endl;\n\t  if(FlowFrom[a][b]==a&&e.cap==0){\n\t    if(n!=b){\n\t      f+=one_flow(n,b);\n\t    }\n\t    else\n\t      f++;\n\t    if(a!=1)\n\t      f+=one_flow(a,1);\n\t    else\n\t      f++;\n\t  }\n\t  else if(FlowFrom[b][a]==b&&G[b][e.rev].cap==0){\n\t    //cout<<\"from a to b\"<<endl;\n\t    if(b!=1)\n\t      f+=one_flow(b,1);\n\t    else\n\t      f++;\n\t    //cout<<f<<endl;\n\t    if(a!=n)\n\t      f+=one_flow(n,a);\n\t    else\n\t      f++;\n\t  }\n\t  //cout<<f<<endl;\n\t  if(f>=2)\n\t    cFlow--;\n\t  break;\n\t}\n      }\n      // Øf\n      // from a,idxÌvfðoûüÅí·é\n      G[a][idx].flag=false;\n      G[b][ridx].flag=false;\n      // G[a].erase(G[a].begin()+idx);\n      // G[b].erase(G[b].begin()+ridx);\n      isDirected[a][b]=false;\n      isDirected[b][a]=false;\n    }\n    cout<<cFlow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n  Edge() {}\n};\n\n#define MAX_N 1005\n\nclass Dinic {\n  vector<Edge> g[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n  int flow, n;\n  int st, en;\n  map<P, int> edges;\n\n  void bfs(int s) {\n    rep(i, n) level[i] = -1;\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      rep(i, g[v].size()) {\n        Edge &e = g[v][i];\n        if(e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    for(int &i=iter[v]; i<g[v].size(); ++i) {\n      Edge &e = g[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, t, mind(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          g[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  Dinic(int n, int s, int t) {\n    flow = 0;\n    st = s; en = t;\n    this->n = n;\n  }\n\n  // ??????????????????\n  void add_edge(int from, int to, int cap) {\n    edges[P(from, to)] = g[from].size();\n    g[from].push_back(Edge(to, cap, g[to].size()));\n    edges[P(to, from)] = g[to].size();\n    g[to].push_back(Edge(from, 0, g[from].size()-1));\n  }\n\n  // ??????????????????\n  void add_multi_edge(int v1, int v2, int cap) {\n    edges[P(v1, v2)] = g[v1].size();\n    g[v1].push_back(Edge(v2, cap, g[v2].size()));\n    edges[P(v2, v1)] = g[v2].size();\n    g[v2].push_back(Edge(v1, cap, g[v1].size()-1));\n  }\n\n  // ?????§???????±???????\n  int max_flow(int s = -1, int t = -1, int rest = -1) {\n    if(s == -1) s = st;\n    if(t == -1) t = en;\n    int su = 0;\n    while(rest) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      rep(i, n) iter[i] = 0;\n      int f;\n      while(rest && (f = dfs(s, t, rest == -1 ? INF : rest)) > 0) {\n        if(rest == -1) {\n          flow += f;\n        } else {\n          rest -= f;\n        }\n        su += f;\n      }\n    }\n    return rest == -1 ? flow : su;\n  }\n\n  // ???????¢????\n  void inc_edge(int s, int t, int c) {\n    P key = P(s, t);\n    if(edges.find(key) != edges.end()) {\n      g[s][edges[key]].cap += c;\n    } else {\n      add_edge(s, t, c);\n    }\n  }\n\n  // ??????????°?\n  void dec_edge(int s, int t, int c) {\n    P key = P(s, t);\n    if(edges.find(key) != edges.end()) {\n      int cap = g[s][edges[key]].cap;\n      if(c <= cap) {\n        g[s][edges[key]].cap -= c;\n      } else {\n        int rest = c - cap;\n        // en -> t\n        int f1 = max_flow(en, t, rest);\n        // s -> st\n        int f2 = max_flow(s, st, rest);\n\n        assert(f1 == rest && f2 == rest);\n\n        g[s][edges[key]].cap = 0;\n        g[t][edges[P(t, s)]].cap -= rest;\n        //cout << g[s][edges[key]].cap << endl;\n\n        flow -= c;\n      }\n    }\n  }\n};\n\n\nint main() {\n  int n, e, q;\n  cin >> n >> e >> q;\n  Dinic dinic(n, 0, n-1);\n  rep(i, e) {\n    int f, t;\n    cin >> f >> t; --f; --t;\n    dinic.add_multi_edge(f, t, 1);\n  }\n  //cout << dinic.max_flow() << endl;\n  rep(i, q) {\n    int m, a, b;\n    cin >> m >> a >> b; --a; --b;\n    if(m == 1) {\n      dinic.inc_edge(a, b, 1);\n      dinic.inc_edge(b, a, 1);\n    } else {\n      dinic.dec_edge(a, b, 1);\n      dinic.dec_edge(b, a, 1);\n    }\n    int f = dinic.max_flow();\n    cout << f << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to,rev;Flow icap,cap;bool ex;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[e.to][e.rev];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V);\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        int srev=G[t].size(),trev=G[s].size();\n        G[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,0,0,false});\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Flow flow = 0;\n        for(Edge& e:G[s])if(e.to == t){\n            Edge &reve = G[e.to][e.rev];\n            if(e.icap <= c){// 単純に増やす\n            // cerr <<\"add\"<<endl;\n                e.cap+=c - e.icap;\n                e.icap = c;\n            }else if(c >= e.icap-e.cap){ // 単純に減らす\n            // cerr <<\"del\"<<endl;\n                e.cap-=e.icap - c;\n                e.icap = c;\n            }else{// フローを戻してから減らす\n                // cerr <<\"del2\"<<endl;\n                // cerr << s+1 <<\" \" << t+1 <<endl;\n                Flow d = e.icap - e.cap - c;\n                // cerr << d <<endl;\n \n                Flow tmpcap=e.cap,tmprevcap=reve.cap;\n                e.cap =0;reve.cap = 0;\n                 \n                // cerr <<\"!preflow!\"<<endl;\n                // REP(v,G.size())for(Edge& e2:G[v]){\n                //  Edge &reve2 = G[e2.to][e2.rev];\n                //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n                // }\n                // cerr <<endl;\n                // cerr << d <<endl;\n \n                // S <- s <- t <- T のパス\n                // cerr << make_tuple(s,S,d) <<endl;\n                Flow fs = max_flow(s,S,d);\n                Flow ft = max_flow(T,t,d);\n                Flow f = min(fs,ft);\n                // cerr <<\"::f\" <<f <<endl;\n                flow -= f;\n \n                // cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n \n                // 流しすぎ分の除去\n                max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n \n                // 閉路の除去\n                // s -> t -> s\n                // cerr << make_tuple(s,t,d-f)<<endl;\n                Flow floop = max_flow(s,t,d-f);\n \n                // cerr <<make_tuple(floop,t+1,s+1) <<endl;\n                // cerr <<\"!flow!\"<<endl;\n                // REP(v,G.size())for(Edge& e2:G[v]){\n                //  Edge &reve2 = G[e2.to][e2.rev];\n                //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n                // }\n                // cerr <<endl;\n \n                // s <- t d戻す\n                e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n                // 減らす\n                e.cap-=e.icap - c;\n \n                e.icap = c;\n            }\n \n            // REP(v,G.size())for(Edge& e2:G[v])if(e2.ex){ \n            //  assert(e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n            // }\n            // REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex){ \n            //  assert(-e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n            // }\n \n \n            // cerr << s+1 <<\" \" << t+1 <<endl;\n            // cerr <<\"!pre:state!\"<<endl;\n            // REP(v,G.size())for(Edge& e2:G[v]){\n            //  Edge &reve2 = G[e2.to][e2.rev];\n            //  assert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n            //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n            // }\n            // cerr <<endl;\n \n            Flow _f = max_flow(S,T);  // cerr <<\"_f:\"<< _f <<endl; \n            flow += _f;\n \n            // cerr <<\"!post:state!\"<<endl;\n            // REP(v,G.size())for(Edge& e2:G[v]){\n            //  Edge &reve2 = G[e2.to][e2.rev];\n            //  assert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n            //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n            // }\n            // cerr <<endl;\n        }\n \n        // cerr <<\"f:\"<< flow <<endl;\n \n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(true){\n            fill(ALL(iter),0);\n            bfs_dist(s);\n            if(Mf==0 || dist[t] == -1)return flow; //限界\n            Flow f;\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return -1;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n        REP(i,N)REP(j,N)if(i<j) mf.add_edge(i,j,es[i][j]);\n        \n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            // cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tmap<P,int> m;\n\tint DFS(int v,int t,int f,vi& used){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),used);\n\t\t\t\tif(d>0){\n\t//\t\t\t\tif(t==11) cout<<'A'<<e.to<<endl;\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tm[{s,t}]=g[s].size();\n\t\tg[s].push_back(edge{t,1,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,1,(int)g[s].size()-1});\n\t}\n\tint Max_Flow(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi used(V);\n\t\t\tint f=DFS(s,t,1,used);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n\tint Add(int u,int v){\n\t\tadd_edge(u,v);\n\t\tvi used(V);\n\t\treturn DFS(0,V-1,inf,used);\n\t}\n\tint Erase(int u,int v,int ind){\n\t\tint I=m[{u,v}],J=g[u][I].rev,C=g[u][I].cap;\n//\t\tif(ind==817) cout<<C<<endl;\n//\t\tif(ind==816) cout<<g[1][m[{1,3}]].cap<<endl;\n\t\tif(C==1){\n\t\t\tg[u][I].cap=0;\n\t\t\tg[v][J].cap=0;\n\t\t\treturn 0;\n\t\t}\n\t\tvi used(V);\n\t\tint f=DFS((C?v:u),(C?u:v),1,used);\n\t\tif(f){\n\t\t\tg[u][I].cap=0;\n\t\t\tg[v][J].cap=0;\n\t\t\treturn 0;\n\t\t}\n\t\tused=vi(V);\n\t\tDFS(V-1,0,1,used);\n\t\tg[u][I].cap=0;\n\t\tg[v][J].cap=0;\n\t\tused=vi(V);\n\t\tDFS((C?v:u),(C?u:v),1,used);\n//\t\tcout<<\"!!!!!\"<<f<<endl;\n\t\treturn 1;\n\t}\n\tvoid Open(){\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<g[i].size();j++) if(g[i][j].cap==2) cout<<g[i][j].to<<' '<<i<<endl;\n\t\t}\n\t}\n};\n\nint n,m,q;\n\nint main(){\n\tcin>>n>>m>>q;\n\tNetwork nt(n);\n\tvvi g(n,vi(n));\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tnt.add_edge(u,v);\n\t\tg[u][v]++;\n\t\tg[v][u]++;\n\t}\n\tvi a(q);\n\tint res=nt.Max_Flow(0,n-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t,u,v;\n\t\tcin>>t>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tif(t==1){\n\t\t\tres+=nt.Add(u,v);\n\t\t\tg[u][v]++;\n\t\t\tg[v][u]++;\n\t\t}\n\t\telse{\n\t\t\tres-=nt.Erase(u,v,i);\n\t\t\tg[u][v]--;\n\t\t\tg[v][u]--;\n\t\t}\n\t\ta[i]=res;\n\t\tcout<<res<<endl;\n/*\t\tif(i==1){\n\t\t\tcout<<u<<' '<<v<<endl;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++) cout<<g[j][k]<<' ';\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\tnt.Open();\n\t\t\tcout<<res<<endl;\n\t\t}*/\n\t}\n/*\tfor(int i=0;i<q;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(a[i]!=x){\n\t\t\tcout<<i<<endl;\n\t\t\tcout<<x<<' '<<a[i]<<endl;\n\t\t\tbreak;\n\t\t}\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX_V 500\n#define INF 1e9\n#define f(i,n) for(int i=0;i<n;i++)\n#define memu memset(used,0,sizeof(used))\nint G[MAX_V][MAX_V],V,E,Q,F,T,m,a,b;\nbool used[MAX_V];\nvoid add_edge(int from,int to){\n    G[from][to]=1;\n    G[to][from]=1;\n}\nvoid erase_edge(int from,int to){\n    G[from][to]=0;\n    G[to][from]=0;\n}\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    f(i,V){\n        int &c = G[v][i];\n        if(!used[i]&&c>0){\n            int d=dfs(i,t,min(f,c));\n            if(d>0){\n                c-=d;\n                G[i][v]+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow=0;\n    while(1){\n        memu;\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow += f;\n    }\n}\nint main(){\n    cin>>V>>E>>Q;\n    f(i,E){\n        cin>>F>>T;\n        add_edge(F-1,T-1);\n    }\n    int now=max_flow(0,V-1);\n    f(i,Q){\n        cin>>m>>a>>b;\n        a--,b--;\n        if(m==1){\n            add_edge(a, b);\n        } else {\n            int c=G[a][b];\n            erase_edge(a, b);\n            if(c>1){\n                swap(a,b);\n            }\n            if(c!=1){\n                memu;\n                int f=dfs(a,b,1);\n                if(f==0){\n                    memu;\n                    dfs(a, 0, 1);\n                    memu;\n                    dfs(b,V-1,1);\n                    now--;\n                }\n            }\n        }\n        cout<<now<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T,class T2>\nostream &operator<<(ostream &os,const pair<T,T2> &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T>\nstruct FordFulkerson{\n\tstruct Edge{\n\t\tint to,rev;\n\t\tT cap;\n\t\tEdge(int to,T cap,int rev) : to(to),rev(rev),cap(cap){}\n\t};\n\n\tfriend ostream &operator<<(ostream &os,const Edge *e){ return os << \"(\" << e->to << \",\" << e->cap << \")\"; }\n\n\tvector<vector<Edge>> G;\n\tvector<bool> used;\n\tvector<map<int,int>> ind;\n\n\tFordFulkerson(int n) : G(n),used(n),ind(n){}\n\n\tvoid addEdge(int from,int to,T cap,bool isDirected = true,bool isRef = true){\n\t\tG[from].emplace_back(to,cap,G[to].size());\n\t\tG[to].emplace_back(from,isDirected ? 0 : cap,G[from].size() - 1);\n\t\tif(isRef){\n\t\t\tind[from][to] = G[from].size() - 1;\n\t\t\tind[to][from] = G[to].size() - 1;\n\t\t}\n\t}\n\n\tT dfs(int v,int t,T f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor(auto &e : G[v]){\n\t\t\tif(!used[e.to] && e.cap){\n\t\t\t\tT d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT flow(int s,int t){\n\t\tT ret = 0;\n\t\twhile(1){\n\t\t\tfill(used.begin(),used.end(),0);\n\t\t\tT f = dfs(s,t,numeric_limits<T>::max());\n\t\t\tif(!f) return ret;\n\t\t\tret += f;\n\t\t}\n\t}\n};\n\nsigned main(){\n\tint n,m,q;\n\tcin >> n >> m >> q;\n\tFordFulkerson<int> ff(n);\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v; u--;v--;\n\t\tff.addEdge(u,v,1,false);\n\t}\n\tff.addEdge(0,n - 1,0,true,false);\n\tint tmpind = ff.G[0].size() - 1;\n\tint ans = ff.flow(0,n - 1);\n\tfor(int i = 0;i < q;i++){\n\t\tint t,u,v;\n\t\tcin >> t >> u >> v; u--;v--;\n\t\tif(!ff.ind[u].count(v)) ff.addEdge(u,v,0,false);\n\t\tif(t == 1){\n\t\t\tff.G[u][ff.ind[u][v]].cap = 1;\n\t\t\tff.G[v][ff.ind[v][u]].cap = 1;\n\t\t\tans += ff.flow(0,n - 1);\n\t\t}else{\n\t\t\tint f = ff.G[u][ff.ind[u][v]].cap;\n\t\t\tff.G[u][ff.ind[u][v]].cap = 0;\n\t\t\tff.G[v][ff.ind[v][u]].cap = 0;\n\t\t\tif(f != 1){\n\t\t\t\tif(f == 2) swap(u,v);\n\t\t\t\tff.G[0][tmpind].cap = 1;\n\t\t\t\tfill(ff.used.begin(),ff.used.end(),0);\n\t\t\t\tff.dfs(u,v,1);\n\t\t\t\tf = ff.G[n - 1][ff.G[0][tmpind].rev].cap;\n\t\t\t\tff.G[0][tmpind].cap = 0;\n\t\t\t\tff.G[n - 1][ff.G[0][tmpind].rev].cap = 0;\n\t\t\t\tans += ff.flow(0,n - 1) - f;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n \nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass MaximamFlow{\nprivate:\n\ttypedef int Flow;\n\tstruct Edge{int to,rev;Flow icap,cap;bool ex;};\n\ttypedef vector<vector<Edge>> Graph;\n\n\t//iter　次に調べる時の開始位置 距離\n\tvector<int> iter,dist;\n\n\t//sからのbfs距離の計算\n\tvoid bfs_dist(int s){\n\t\tfill(ALL(dist),-1); dist[s]=0;\n\t\tqueue<int> que; que.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();que.pop();\n\t\t\tfor(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n\t\t\t\tdist[e.to]=dist[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//増加パス\n\tFlow dfs_best_path(int s,int t,Flow f){\n\t\tif(s==t)return f;\n\t\tfor(int &i = iter[s];i < (int)G[s].size();i++){\n\t\t\tEdge &e=G[s][i];Edge &reve = G[e.to][e.rev];\n\t\t\tif(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n\t\t\t//search\n\t\t\tFlow d = dfs_best_path(e.to,t,min(f,e.cap));\n\t\t\tif(d==0)continue;\n\t\t\t//found\n\t\t\te.cap-=d;reve.cap+=d;\n\t\t\t\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tint V;Graph G;\n\tMaximamFlow(int V):V(V){\n\t\tG=Graph(V);\n\t\tdist=vector<int>(V,-1);iter=vector<int>(V);\n\t}\n\n\tvoid add_edge(int s,int t,Flow cap){\n\t\tint srev=G[t].size(),trev=G[s].size();\n\t\tG[s].push_back({t,srev,cap,cap,true});G[t].push_back({s,trev,0,0,false});\n\t}\n\n\tFlow change_cost(int S,int T,int s,int t,int c){\n\t\tFlow flow = 0;\n\t\tfor(Edge& e:G[s])if(e.to == t){\n\t\t\tEdge &reve = G[e.to][e.rev];\n\t\t\tif(e.icap <= c){// 単純に増やす\n\t\t\t// cerr <<\"add\"<<endl;\n\t\t\t\te.cap+=c - e.icap;\n\t\t\t\te.icap = c;\n\t\t\t}else if(c >= e.icap-e.cap){ // 単純に減らす\n\t\t\t// cerr <<\"del\"<<endl;\n\t\t\t\te.cap-=e.icap - c;\n\t\t\t\te.icap = c;\n\t\t\t}else{// フローを戻してから減らす\n\t\t\t\t// cerr <<\"del2\"<<endl;\n\t\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t\tFlow d = e.icap - e.cap - c;\n\t\t\t\t// cerr << d <<endl;\n\n\t\t\t\tFlow tmpcap=e.cap,tmprevcap=reve.cap;\n\t\t\t\te.cap =0;reve.cap = 0;\n\t\t\t\t\n\t\t\t\t// cerr <<\"!preflow!\"<<endl;\n\t\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t\t// }\n\t\t\t\t// cerr <<endl;\n\t\t\t\t// cerr << d <<endl;\n\n\t\t\t\t// S <- s <- t <- T のパス\n\t\t\t\t// cerr << make_tuple(s,S,d) <<endl;\n\t\t\t\tFlow fs = max_flow(s,S,d);\n\t\t\t\tFlow ft = max_flow(T,t,d);\n\t\t\t\tFlow f = min(fs,ft);\n\t\t\t\t// cerr <<\"::f\" <<f <<endl;\n\t\t\t\tflow -= f;\n\n\t\t\t\t// cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n\n\t\t\t\t// 流しすぎ分の除去\n\t\t\t\tmax_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\n\t\t\t\t// 閉路の除去\n\t\t\t\t// s -> t -> s\n\t\t\t\t// cerr << make_tuple(s,t,d-f)<<endl;\n\t\t\t\tFlow floop = max_flow(s,t,d-f);\n\n\t\t\t\t// cerr <<make_tuple(floop,t+1,s+1) <<endl;\n\t\t\t\t// cerr <<\"!flow!\"<<endl;\n\t\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t\t// }\n\t\t\t\t// cerr <<endl;\n\n\t\t\t\t// s <- t d戻す\n\t\t\t\te.cap=tmpcap + d;reve.cap = tmprevcap - d;\n\t\t\t\t// 減らす\n\t\t\t\te.cap-=e.icap - c;\n\n\t\t\t\te.icap = c;\n\t\t\t}\n\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(e2.ex){ \n\t\t\t// \tassert(e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v])if(!e2.ex){ \n\t\t\t// \tassert(-e2.icap == e2.cap + G[e2.to][e2.rev].cap);\n\t\t\t// }\n\n\n\t\t\t// cerr << s+1 <<\" \" << t+1 <<endl;\n\t\t\t// cerr <<\"!pre:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tassert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\n\t\t\tFlow _f = max_flow(S,T);  // cerr <<\"_f:\"<< _f <<endl; \n\t\t\tflow += _f;\n\n\t\t\t// cerr <<\"!post:state!\"<<endl;\n\t\t\t// REP(v,G.size())for(Edge& e2:G[v]){\n\t\t\t// \tEdge &reve2 = G[e2.to][e2.rev];\n\t\t\t// \tassert(e2.cap+reve2.cap ==e2.icap + reve2.icap);\n\t\t\t// \tcerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n\t\t\t// }\n\t\t\t// cerr <<endl;\n\t\t}\n\n\t\t// cerr <<\"f:\"<< flow <<endl;\n\n\t\treturn flow;\n\t}\n\n\tint max_flow(int s,int t,Flow Mf=INF<Flow>()){\n\t\tif(s==t)return Mf;\n\t\tFlow flow=0;\n\t\twhile(true){\n\t\t\tfill(ALL(iter),0);\n\t\t\tbfs_dist(s);\n\t\t\tif(Mf==0 || dist[t] == -1)return flow; //限界\n\t\t\tFlow f;\n\t\t\twhile((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n\t\t}\n\t\treturn -1;\n\t}\n};\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N,E,Q;cin >> N >> E >> Q;\n\n\t\tMaximamFlow mf(N);\n\t\tREP(i,N)REP(j,N)if(i<j){mf.add_edge(i,j,0);}\n\n\t\tll flow=0;\n\t\tREP(e,E){\n\t\t\tint f,t;cin >> f >> t;f--;t--;\n\t\t\tflow+=mf.change_cost(0,N-1,f,t,1);\n\t\t\tflow+=mf.change_cost(0,N-1,t,f,1);\n\t\t}\n\t\t// cerr << flow <<endl;\n\t\tREP(q,Q){\n\t\t\tint t,a,b;cin >> t >> a >> b;a--;b--;\n\t\t\t\n\t\t\t// cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n\t\t\tif(t==1){\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,1);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,1);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}else{\n\t\t\t\tflow+=mf.change_cost(0,N-1,a,b,0);\n\t\t\t\tflow+=mf.change_cost(0,N-1,b,a,0);\n\t\t\t\tcout << flow <<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n \nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 20005;\nconst F MAXF = 1<<29;\n\nstruct MaxFlow {\n    F cap[2*MAXE], flow[2*MAXE];\n    int V, E, level[MAXV], edge[MAXV];\n    int prev[2*MAXE], to[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]] = mf.flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.cap[e] - mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    if (prev[t] == -1) return 0;\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]] = 1;\n        mf.flow[use_edge[v]^1] = -1;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = mf.edge[s]; e != -1; e = mf.prev[e])\n        if (mf.to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) mf.cap[e] = mf.cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            mf.cap[e] = mf.cap[e^1] = 0;\n            if (mf.flow[e] != 0) {\n                f--;\n                if (mf.flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                mf.flow[e] = mf.flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    cin >> f >> t;\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      cout << max_flow(0, N-1, G) << endl;\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      cout << max_flow(0, N-1, G) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_V = 550;\nconstexpr int INF = (1 << 29);\n\nstruct edge {\n    int to;\n    edge(int to) : to{to} {}\n};\n\nint cap[MAX_V][MAX_V];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to)\n{\n    G[from].emplace_back(to);\n    G[to].emplace_back(from);\n    cap[from][to] = cap[to][from] = 1;\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    used[v] = 1;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && cap[v][e.to] > 0) {\n            int d = dfs(e.to, t, min(f, cap[v][e.to]));\n            if (d > 0) {\n                cap[v][e.to] -= d;\n                cap[e.to][v] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint one_flow(int s, int t)\n{\n    memset(used, 0, sizeof(used));\n    return dfs(s, t, INF);\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nvoid remove_edge(int from, int to)\n{\n    cap[from][to] = cap[to][from] = 0;    \n}\n\nint main()\n{\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    for (int i = 0; i < E; i++) {\n        int F, T;\n        cin >> F >> T;\n        add_edge(F - 1, T - 1);\n    }\n    \n    int f = max_flow(0, N - 1);\n    for (int i = 0; i < Q; i++) {\n        int M, A, B;\n        cin >> M >> A >> B;\n        A -= 1; B -= 1;\n        if (M == 1) {\n            add_edge(A, B);\n            f += one_flow(0, N - 1);\n        } else {\n            if (cap[A][B] == 0 && one_flow(A, B) == 0) {\n                one_flow(N - 1, B);\n                one_flow(A, 0);\n                f -= 1;\n            } else if (cap[B][A] == 0 && one_flow(B, A) == 0) {\n                one_flow(N - 1, A);\n                one_flow(B, 0);\n                f -= 1;\n            }                \n            remove_edge(A, B);                                    \n        }\n        \n        cout << f << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n      \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n              \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            e.cap =0;reve.cap = 0;\n            Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) d-f は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f); \n            e.cap=0;reve.cap=c + reve.icap;\n            e.icap = c;\n        }\n        flow += max_flow(S,T);\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n \n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nint cap[500][500] = {0};\nvoid addEdge(int from, int to) {\n\tcap[from][to] = cap[to][from] = 1;\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!used[i] && cap[s][i] > 0) {\n\t\t\tint d = dfs(i, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs2(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!used[i] && cap[s][i] > 1) {\n\t\t\tint d = dfs2(i, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n/*\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tif (s == to && !flag) return false;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (s == from && i != to) continue;\n\t\tbool nf = flag || (s == from && i == to);\n\t\tif (!used2[i][(int)nf] && cap[s][i] > 0) {\n\t\t\tbool f = dfs2(i, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n*/\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tif (cap[a][b] > 1) {\n\t\treturn removeEdge(b, a);\n\t}\n\telse {\n\t\tint c = cap[a][b];\n\t\tcap[a][b] = cap[b][a] = 0;\n\t\tif (c < 1) {\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tif ( !dfs(a, b) ) {\n\t\t\t\tmemset(used, false, sizeof(used)); int x = dfs(N-1, b);\n\t\t\t\tmemset(used, false, sizeof(used)); int y = dfs(a, 0);\n\t\t\t\tif (x + y < 2) {\n\t\t\t\t\tcout << x << \" \" << y << endl;\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tres = -1;\n\t\t\t}\n//\t\t\tfill(&used2[0][0], &used2[0][0]+500*2, false);\n//\t\t\tif ( !dfs2(N-1, 0, b, a, false) ) {\n//\t\t\t\tcout << \"ERROR\" << endl;\n//\t\t\t\twhile (1);\n//\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tmemset(used, false, sizeof(used)); f += dfs(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1) g[a][b]=g[b][a]=1,flow+=max_flow(0,n-1);\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(!check(a,b))flow--,check(a,0),check(n-1,b);\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 21005;\nconst F MAXF = 1<<29;\n\nF cap[2*MAXE], flow[2*MAXE];\nint level[MAXV], edge[MAXV], seen[MAXV], to[2*MAXE], prev[2*MAXE];\n\nstruct MaxFlow {\n    int V, E;\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        seen[s] = 1;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == 0 && level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            memset(seen, 0, sizeof(seen));\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(seen, -1, sizeof(seen)); seen[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == -1 && flow[e] > 0) {\n                seen[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    for (int v = t; v != seen[v]; v = seen[v]) {\n        flow[use_edge[v]] = flow[use_edge[v]^1] = 0;\n    }\n}\n\nF augment_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(seen, -1, sizeof(seen)); seen[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = edge[v]; e != -1; e = prev[e]) {\n            if (seen[to[e]] == -1 && cap[e] - flow[e] > 0) {\n                seen[to[e]] = v;\n                use_edge[to[e]] = e;\n                q.push(to[e]);\n            }\n        }\n    }\n    if (seen[t] == -1) return 0;\n    for (int v = t; v != seen[v]; v = seen[v]) {\n        flow[use_edge[v]]++;\n        flow[use_edge[v]^1]--;\n    }\n    return 1;\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = edge[s]; e != -1; e = prev[e])\n        if (to[e] == t) return e;\n    return -1;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) cap[e] = cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            assert(e >= 0);\n            cap[e] = cap[e^1] = 0;\n            if (flow[e] != 0) {\n                f--;\n                if (flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                flow[e] = flow[e^1] = 0;\n            }\n        }\n        f += augment_path(0, N-1, mf);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint edge[505][505];\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfsBack(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tEdge &re = G[e.to][e.rev];\n\t\t\t\tif(not used[re.to] && re.cap > 0){\n\t\t\t\t\tint d = dfs(re.to, t, min(f, re.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tre.cap -= d;\n\t\t\t\t\t\tG[re.to][re.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tedge[from][to] = G[from].size();\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint addCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1増やす\n\t\t\tEdge &e = G[a][edge[a][b]];\n\t\t\tEdge &re = G[b][edge[b][a]];\n\t\t\te.cap++;\n\t\t\tre.cap++;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\t//cout << re.cap << ' ' << G[a][re.rev].cap << endl;\n\t\t\treturn fordFulkerson(s, t);\n\t\t}\n\t\tint subCapacity(int s, int t, int a, int b){ // a->bの辺の容量を1減らす\n\t\t\tEdge &ab = G[a][edge[a][b]];\n\t\t\tEdge &rab = G[b][ab.rev];\n\t\t\tEdge &ba = G[b][edge[b][a]];\n\t\t\tEdge &rba = G[a][ba.rev];\n\t\t\t//show(\"sub\")\n\t\t\t//cout << ab.cap << ' ' << rab.cap << endl;\n\t\t\t//cout << ba.cap << ' ' << rba.cap << endl;\n\t\t\t//cout << e.cap << ' ' << G[b][e.rev].cap << endl;\n\t\t\tif(rab.cap >= 1){ // use e(a,b)\n\t\t\t\tif(ab.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tif(dfs(a, b, 1)) return 0;\n\n\t\t\t\t\tdfs(t, b, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(a, s, 1);\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}else if(rba.cap >= 1){\n\t\t\t\tif(ba.cap >= 1){\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tba.cap--;\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\trba.cap--;\n\t\t\t\t\tab.cap--;\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tif(dfs(b, a, 1)) return 0;\n\n\t\t\t\t\tdfs(t, a, 1);\n\t\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\t\tdfs(b, s, 1);\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tab.cap--;\n\t\t\t\tba.cap--;\n\t\t\t\t\tfordFulkerson(s,t);\n\t\t\t\treturn 0;\n\t\t\t\t\t//show(fordFulkerson(s,t))\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn fordFulkerson(s, t) ? 0 : - 1;\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nvoid t(){\n\tint s = 3, t = s + 1;\n\tFlow f;\n\tf.addEdge(s,0,2);\n\tf.addEdge(0,1,0);\n\tf.addEdge(0,2,0);\n\tf.addEdge(1,t,1);\n\tf.addEdge(2,t,1);\n\tcout << f.fordFulkerson(s,t) << endl;\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.addCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n\tshow(f.subCapacity(s,t,0,1));\n}\n\nint main(){\n\t//t(); //return 0;\n\tint n, e, q;\n\tcin >> n >> e >> q;\n\n\tFlow flow;\n\tvector<vector<bool>> used(n, vector<bool>(n,0));\n\trep(i,e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\tused[f][t] = true;\n\t\tused[t][f] = true;\n\t\tflow.addEdge(f, t, 1);\n\t\tflow.addEdge(t, f, 1);\n\t}\n\n\tvector<int> com(q), a(q), b(q);\n\trep(i,q){\n\t\tcin >> com[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tif(not used[a[i]][b[i]]) flow.addEdge(a[i], b[i], 0);\n\t\tif(not used[b[i]][a[i]]) flow.addEdge(b[i], a[i], 0);\n\t}\n\n\tint s = 500, t = s + 1;\n\tflow.addEdge(s, 0, INF);\n\tflow.addEdge(n - 1, t, INF);\n\n\tint ans = flow.fordFulkerson(s, t);\n\t//show(ans)\n\trep(i,q){\n\t\tif(com[i] == 1){\n\t\t\tans += flow.addCapacity(s, t, a[i], b[i]);\n\t\t}else{\n\t\t\tans += flow.subCapacity(s, t, a[i], b[i]);\n\t\t}\n\t\tassert(ans >= 0);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n   \ntypedef long long ll;\ntypedef unsigned long long ull;\n   \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n   \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n   \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n   \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n   \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n   \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n   \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n   \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n  \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n  \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n  \n    //sからのbfs距離\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    // s->t 増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n  \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n  \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap += c - e.icap;\n            e.icap = c;\n            flow += max_flow(S,T);\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap -= e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            Flow d = e.icap - e.cap - c;\n            e.cap = 0;reve.cap = 0;\n            //(1) S <- s <- t <- T のフローを戻す。\n            Flow fs = max_flow(s,S,d),ft = max_flow(T,t,d),f = min(fs,ft);\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n            flow -= f;\n            //(2) (1)で流せない分は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n            e.cap = 0;reve.cap = c + reve.icap;\n            e.icap = c;\n\t        flow += max_flow(S,T);\n        }\n        return flow;\n    }\n  \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n  \n  \nclass Main{\n    public:\n  \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n \n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n        }\n  \n        MaximamFlow mf(N);\n        REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n \n        ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n   \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=1100;\nconst int D_v_size=1100;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,cap,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint v[510];\nvoid init(){\n\tfor(int i=0;i<510;i++)v[i]=0;\n}\nint dfs(int a,int b){\n\tv[a]=1;\n\tif(a==b)return 1;\n\tfor(int i=0;i<D_G[a].size();i++){\n\t\tif(!v[D_G[a][i].t]&&D_G[a][i].c){\n\t\t\tint res=dfs(D_G[a][i].t,b);\n\t\t\tif(res){\n\t\t\t\tD_G[a][i].c--;\n\t\t\t\tD_G[D_G[a][i].t][D_G[a][i].r].c++;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);p--;q--;\n\t\tadd_edge(p,q,1);\n\t}\n\tint ret=max_flow(0,a-1);\n\tfor(int i=0;i<c;i++){\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&r,&p,&q);p--;q--;\n\t\tif(r==1){\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<D_G[p].size();j++){\n\t\t\t\tif(D_G[p][j].t==q){\n\t\t\t\t\tok=true;\n\t\t\t\t\tD_G[p][j].c=1;\n\t\t\t\t\tD_G[q][D_G[p][j].r].c=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok)add_edge(p,q,1);\n\t\t\tret+=max_flow(0,a-1);\n\t\t\tprintf(\"%d\\n\",ret);\n\t\t}else{\n\t\t\tfor(int j=0;j<D_G[p].size();j++){\n\t\t\t\tif(D_G[p][j].t==q){\n\t\t\t\t\tif(D_G[p][j].c==1){\n\t\t\t\t\t\tD_G[p][j].c=D_G[q][D_G[p][j].r].c=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(D_G[p][j].c==0){\n\t\t\t\t\t\tD_G[p][j].c=D_G[q][D_G[p][j].r].c=0;\n\t\t\t\t\t\tinit();\n\t\t\t\t\t\tint tmp=dfs(p,q);\n\t\t\t\t\t\tif(!tmp){\n\t\t\t\t\t\t\tret--;\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t\tdfs(a-1,q);\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t\tdfs(p,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tD_G[p][j].c=D_G[q][D_G[p][j].r].c=0;\n\t\t\t\t\t\tinit();\n\t\t\t\t\t\tint tmp=dfs(q,p);\n\t\t\t\t\t\tif(!tmp){\n\t\t\t\t\t\t\tret--;\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t\tdfs(a-1,p);\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t\tdfs(q,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ret);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, a))return 0;\n\t\t\t\tif(!flow(b, 1))return 1;\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tif(!flow(n, b))return 0;\n\t\t\t\tif(!flow(a, 1))return 0;\t\t\n\t\t\t}\t\t\n\t\t\tused[a][b] = used[b][a] = 0;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 1000\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n\nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) cin>>f>>t,add_edge(f,t,1);\n  while(Q--){\n    int m,a,b;\n    cin>>m>>a>>b;\n    if(m==1){\n      add_edge(a,b,1);\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n    }\n    for(int i=0;i<=N;i++) G[i]=G2[i];\n    cout<<max_flow(1,N)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define crear_vec(v,n) v.clear();v.resize(n);\n#define delete_vec(v,n) v.erase(remove(v.begin(),v.end(),n),v.end());\ntypedef pair<int,int> pii;\nint N,E,Q;\nvector<vector<pii> > edge;\nint f;\nvoid flow(int from,int to){\n  for(int i=0;i<edge[from].size();i++){\n    if(edge[from][i].first==to)edge[from][i].second++;\n  }\n  for(int j=0;j<edge[to].size();j++){\n    if(edge[to][j].first == from)edge[to][j].second--;\n  }\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  if(from==to)return 1;\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    if(used[edge[from][i].first]==1)continue;\n    if(edge[from][i].second>=1)continue;\n    if(dfs_(edge[from][i].first,to)==1){\n      flow(from,edge[from][i].first);\n      return 1;\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  crear_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(pii(b,0));\n  edge[b].push_back(pii(a,0));\n  while(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff;\n  for(int i=0;i<edge[a].size();i++){\n    if(edge[a][i].first==b){\n      ff=edge[a][i].second;\n      delete_vec(edge[a],edge[a][i]);\n      break;\n    }\n  }\n  for(int i=0;i<edge[b].size();i++){\n    if(edge[b][i].first==a){\n      delete_vec(edge[b],edge[b][i]);\n      break;\n    }\n  }\n  if(ff<0){\n    swap(a,b);\n  }\n  if(ff!=0){\n    if(!dfs(N,b));//cerr<<\"err\"<<endl;\n    if(!dfs(a,1));//cerr<<\"err\"<<endl;\n    f--;\n  }\n  while(dfs(1,N))f++;\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  crear_vec(edge,N+1);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  while(dfs(1,N));\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  if(m==1){\n    add_edge(a,b);\n  }else if(m==2){\n    cut_edge(a,b);\n  }\n  return f;\n}\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n    \n    /*\n    cout<<\"edge\"<<endl;\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge[i].size();j++){\n        if(edge[i][j].second==1){\n          cout<<i<<\" \"<<edge[i][j].first<<endl;\n        }\n      }\n    }\n    */\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n \nint fordFulkerson(const int n,const int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool dfs(int n,int now,int t){\n  if (now == t)return true;\n  if (vis[now])return true;\n  vis[now]=true;\n  rep(i,n){\n    int &next=i;\n    //if (cap[next][now]-flow[next][now] > 0){\n    if (flow[now][next] < 0){\n      if (dfs(n,next,t)){\n\tflow[now][next]=flow[next][now]=0;\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,e,q;\n  while(cin>>n>>e>>q){\n    //cout << n <<\" \" << e <<\" \" <<q << endl;\n    const int s = 0,t=n-1;\n    rep(i,n)rep(j,n)cap[i][j]=0,flow[i][j]=0;\n    rep(i,e){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n    }\n    int prev=maxFlow(n,s,t);\n    rep(i,q){\n      int a,from,to,tmp;\n      cin>>a>>from>>to;\n      from--;to--;\n      if (a == 1){//add\n\tcap[from][to]=cap[to][from]=1;\n\ttmp = maxFlow(n,s,t);\n#ifdef DEBUG\n\tcout <<\"add:\";\n#endif\n\tcout << prev+tmp << endl;\n\tprev=prev+tmp;\n      }else if (flow[from][to] == 0){\n#ifdef DEBUG\n\tcout <<\"noflow:\";\n#endif\n\tcap[from][to]=cap[to][from]=0;\n\tcout << prev << endl;\n      }else {//delete\n#ifdef DEBUG\n\tcout <<\"del:\";\n#endif\n\tif (flow[from][to] < 0)swap(from,to);\n\tcap[from][to]=cap[to][from]=0;\n\tflow[from][to]=flow[to][from]=0;\n\n\t//tmp = fordFulkerson(n,to,from,1);\n\ttmp=maxFlow(n,from,to);\n\tcout <<\"del \" << tmp <<\":\";\n\tif (tmp != 0){\n\t  cout << prev << endl;\n\t  prev=prev;//keep\n\t}else {\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,from,s);\n\t  rep(j,n)vis[j]=false;\n\t  dfs(n,t,to);\n\t  cout << prev-1 << endl;\n\t  prev=prev-1;\n\t}\n      }\n    }\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        if(e.cap == 0) {\n          max_flow(graph.size() - 1, to, 1);\n          max_flow(from, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n    bool alive;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size(), true});\n    graph[to].push_back((edge) {from, cap, (int) graph[from].size() - 1, true});\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    used[idx] = true;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(!e.alive) continue;\n      if(e.cap > 0 && !used[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t, int lim)\n  {\n    int flow = 0;\n    while(lim > 0) {\n      used.assign(graph.size(), 0);\n      int f = dfs(s, t, lim);\n      if(f == 0) break;\n      flow += f;\n      lim -= f;\n    }\n    return (flow);\n  }\n\n  bool back_edge(int from, int to)\n  {\n    for(edge &e : graph[from]) {\n      if(e.to == to && e.alive) {\n        e.alive = false;\n        graph[e.to][e.rev].alive = false;\n        if(e.cap == 0) {\n          if(to != graph.size() - 1) max_flow(graph.size() - 1, to, 1);\n          if(from != 0) max_flow(from, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else if(graph[e.to][e.rev].cap == 0) {\n          if(from != graph.size() - 1) max_flow(graph.size() - 1, from, 1);\n          if(to != 0) max_flow(to, 0, 1);\n          return (max_flow(0, graph.size() - 1, 1) == 0);\n        } else {\n          return (false);\n        }\n      }\n    }\n  }\n\n};\n\n\nint main()\n{\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  Dinic graph(N);\n  while(E--) {\n    int F, T;\n    cin >> F >> T;\n    --F, --T;\n    graph.add_edge(F, T, 1);\n  }\n  int flow = graph.max_flow(0, N - 1, INF);\n  while(Q--) {\n    int M, A, B;\n    cin >> M >> A >> B;\n    --A, --B;\n    if(M == 1) {\n      graph.add_edge(A, B, 1);\n      flow += graph.max_flow(0, N - 1, 1);\n    } else {\n      flow -= graph.back_edge(A, B);\n      // flow -= graph.back_edge(B, A);\n    }\n    cout << flow << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nint cap[500][500] = {0};\nvoid addEdge(int from, int to) {\n\tcap[from][to] = cap[to][from] = 1;\n}\n\n#define INF 1000000000\n\nint N;\nbool used[500];\nint dfs(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!used[i] && cap[s][i] > 0) {\n\t\t\tint d = dfs(i, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs2(int s, int t) {\n\tif (s == t) return 1;\n\tused[s] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!used[i] && cap[s][i] > 1) {\n\t\t\tint d = dfs2(i, t);\n\t\t\tif (d > 0) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t);\n\t\tif (f > 0) {\n\t\t\tres += f;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n/*\nbool used2[500][2];\nbool dfs2(int s, int t, int from, int to, bool flag) {\n\tif (s == t) return flag;\n\tif (s == to && !flag) return false;\n\tused2[s][(int)flag] = true;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (s == from && i != to) continue;\n\t\tbool nf = flag || (s == from && i == to);\n\t\tif (!used2[i][(int)nf] && cap[s][i] > 0) {\n\t\t\tbool f = dfs2(i, t, from, to, nf);\n\t\t\tif (f) {\n\t\t\t\t--cap[s][i];\n\t\t\t\t++cap[i][s];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n*/\n\nint removeEdge(int a, int b) {\n\tint res = 0;\n\tif (cap[a][b] > 1) {\n\t\treturn removeEdge(b, a);\n\t}\n\telse {\n\t\tint c = cap[a][b];\n\t\tcap[a][b] = cap[b][a] = 0;\n\t\tif (c < 1) {\n\t\t\tmemset(used, false, sizeof(used)); int x = dfs2(N-1, b);\n\t\t\tmemset(used, false, sizeof(used)); int y = dfs2(a, 0);\n//\t\t\tfill(&used2[0][0], &used2[0][0]+500*2, false);\n//\t\t\tif ( !dfs2(N-1, 0, b, a, false) ) {\n//\t\t\t\tcout << \"ERROR\" << endl;\n//\t\t\t\twhile (1);\n//\t\t\t}\n\t\t\tres = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint E, Q; cin >> N >> E >> Q;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint F, T; cin >> F >> T; --F, --T;\n\t\taddEdge(F, T);\n\t}\n\tint f = flow(0, N-1);\n\tfor (int t = 0; t < Q; ++t) {\n\t\tint m, a, b; cin >> m >> a >> b; --a, --b;\n\t\tif (m == 1) {\n\t\t\taddEdge(a, b);\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tf += removeEdge(a, b);\n\t\t}\n\t\tmemset(used, false, sizeof(used)); f += dfs(0, N-1);\n\t\tcout << f << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\nint main(){\n  int N, E, Q;\n  cin >> N >> E >> Q;\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b;\n  for(int i = 0; i < Q; ++i){\n    cin >> m >> a >> b;\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      printf(\"%d\\n\",max_flow(0, N-1, G));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n    \n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int backflow(int v,int t, int f) {\n        if(v==t)return f;\n        vector<bool>used(n,false);\n        used[v]=1;\n        for(int i=0;i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(used[e.to]||e.cap<=0) continue;\n            int d = backflow(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n    }\n    int res = fl.getmaxflow(0,N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            \n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                \n                // edge is not used\n                //   cout << \"false\" << endl;\n                \n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.backflow(N-1, a, 1);\n                    fl.backflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.backflow(N-1, b, 1);\n                    fl.backflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1,INF);\n        cout  << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        \n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n        // cerr <<\"add\"<<endl;\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n        // cerr <<\"del\"<<endl;\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// フローを戻してから減らす\n            // cerr <<\"del2\"<<endl;\n            // cerr << s+1 <<\" \" << t+1 <<endl;\n            Flow d = e.icap - e.cap - c;\n            // cerr << d <<endl;\n\n            Flow tmpcap=e.cap,tmprevcap=reve.cap;\n            e.cap =0;reve.cap = 0;\n             \n            // cerr <<\"!preflow!\"<<endl;\n            // REP(v,G.size())for(Edge& e2:G[v]){\n            //  Edge &reve2 = G[e2.to][e2.rev];\n            //  cerr << v+1 <<\"->\" << e2.to+1 <<\" \" <<e2.icap <<\" \" << e2.cap<<endl;\n            // }\n            // cerr <<endl;\n            // cerr << d <<endl;\n\n            // S <- s <- t <- T のパス\n            // cerr << make_tuple(s,S,d) <<endl;\n            Flow fs = max_flow(s,S,d);\n            Flow ft = max_flow(T,t,d);\n            Flow f = min(fs,ft);\n            // cerr <<\"::f\" <<f <<endl;\n            flow -= f;\n\n            // cerr << f <<\" \" << fs <<\" \" << ft <<endl;\n\n            // 流しすぎ分の除去\n            max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\n            // 閉路の除去\n            // s -> t -> s\n            // cerr << make_tuple(s,t,d-f)<<endl;\n            Flow floop = max_flow(s,t,d-f);\n\n            // s <- t d戻す\n            e.cap=tmpcap + d;reve.cap = tmprevcap - d;\n            // 減らす\n            e.cap-=e.icap - c;\n\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            // cerr <<\"q:\"<< make_tuple(t,a+1,b+1) <<endl;\n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define N 510\n#define MAX_V N\nusing namespace std;\ntypedef map<int,int> M;\nM g[N];\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  \n  for(M::iterator it=g[v].begin();it!=g[v].end() ;it++){\n    int to=it->first;\n    int &cap=it->second;\n    if(!used[to] && cap > 0){\n      int d = dfs(to ,t , min(f,cap));\n      if(d > 0){\n\tcap -= d;\n\tg[to][v]+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool check(int s,int t){\n  memset(used,0,sizeof(used));\n  return dfs(s,t,1);\n}\n\nint main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    g[a][b]=g[b][a]=1;\n  }\n  \n  int flow=max_flow(0,n-1);\n  while(q--){\n    int op,a,b;\n    cin>>op>>a>>b;a--,b--;\n    if(op==1){\n      g[a][b]=g[b][a]=1;\n      flow+=max_flow(0,n-1);\n    }\n    if(op==2){\n      if(!g[a][b]||!g[b][a]){\n\tif(!g[b][a])swap(a,b);\n\tif(check(a,b));\n\telse flow--,check(a,0),check(n-1,b);\n\n      }\n      g[a][b]=g[b][a]=0;\n    }\n    cout <<flow<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 rev;\n\tbool alive;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Dinic_Reverse {\n  int N;\n  vector<int> level;\n  vector<int> itr;\n  Graph G;\n\n  Dinic_Reverse(int n) : G(n) { N = n; }\n\n  void add_edge(int from, int to, i64 cap, i64 rev_cap) {\n    G[from].push_back({to, cap, (int)G[to].size(),true});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1,true});\n  }\n\n  bool g_level(int s, int t) {\n    level.assign(N, -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (auto &e : G[v]) {\n\t\t  if(!e.alive) continue;\n        if (e.cap > 0 && level[e.to] == -1) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] >= 0;\n  }\n\n  i64 dfs(int v, int t, i64 f) {\n    if (v == t)\n      return f;\n\n    for (int &i = itr[v]; i < (int)G[v].size(); i++) {\n      auto &e = G[v][i];\n      if(!e.alive) continue;\n      if (e.cap > 0 && level[e.to] > level[v]) {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0) {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n\n  i64 max_flow(int s, int t , i64 limit = 1e9) {\n    i64 result = 0;\n    i64 flow;\n    while (g_level(s, t) && limit > 0) {\n      itr.assign(N, 0);\n      while ((flow = dfs(s, t, limit)) > 0)\n\t  {\n        result += flow;\n\t\tlimit -= flow;\n\t  }\n    }\n    return result;\n  }\n\n  bool back_edge(int from,int to,int s,int t){\n\t  for(auto& e : G[from]){\n\t\t  if(e.to == to && e.alive){\n\t\t\t  e.alive = false;\n\t\t\t  if(e.cap && max_flow(from, to, 1) == 0){\n\t\t\t\t  max_flow(from, s, 1);\n\t\t\t\t  max_flow(t,to,1);\n\t\t\t\t  return 1;\n\t\t\t  }\n\t\t\t  else{\n\t\t\t\t  return 0;\n\t\t\t  }\n\t\t  }\n\t  }\n  }\n};\n\n/*\n\nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\nint n;\nint e;\nint q;\n\nint main(){\n\tcin >> n >> e >> q;\n\tDinic_Reverse dinic(n);\n\tint s = 0;\n\tint t = n - 1;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;;\n\t\tcin >> a >> b;\n    a--;\n    b--;\n\t\tdinic.add_edge(a, b , 1, 1);\n\t}\n\tint flow = dinic.max_flow(s, t );\n\tfor(int i = 0;i < q;i++){\n\t\tint m,a,b;\n\t\tcin >> m >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tif(m == 1){\n\t\t\tdinic.add_edge(a , b, 1 , 1);\n\t\t\tflow += dinic.max_flow(s , t , 1);\n\t\t}\n\t\telse{\n\t\t\tflow -= dinic.back_edge(a, b , s , t);\n\t\t\tflow -= dinic.back_edge(b, a, s , t);\n\t\t}\n\t\tcout << flow << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool hist[550][550];\n\nint es[550][550];\nvector<int> G[550];\nint N;\n\nbool output;\nint prev[550];\nbool used[550];\nbool findpath(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\n\nbool findpath2(int v,int t){\n\tused[v]=true;\n//\tif(output) printf(\"%d %d\\n\",v,t);\n\tif(v==t) return true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(es[u][v]==2) continue;\n\t\tif(es[u][v]==0&&es[v][u]==0) continue;\n\t\tif(es[u][v]==1&&es[v][u]==1) continue;\n\t\tif(used[u]) continue;\n\t\tes[u][v]++;\n\t\tes[v][u]--;\n\t\tprev[u]=v;\n\t\tbool flg=findpath2(u,t);\n\t\tif(flg) return true;\n\t\telse{\n\t\t\tes[u][v]--;\n\t\t\tes[v][u]++;\n\t\t}\n\t}\n\tused[v]=false;\n\treturn false;\n}\n\nbool add(int u,int v){\n\tes[u][v]=1;\n\tes[v][u]=1;\n\tif(hist[u][v]==false){\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\thist[u][v]=true;\n\thist[v][u]=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool del(int u,int v){\n\tif(es[u][v]==1){\n\t\tes[u][v]=0;\n\t\tes[v][u]=0;\n\t\treturn true;\n\t}\n\tif(es[u][v]==2) swap(u,v);\n\tes[u][v]=0;\n\tes[v][u]=0;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tif(findpath2(u,v)){\n\t\treturn true;\n\t}\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(N-1,v);\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tfindpath2(u,0);\n//\tfor(int i=0;i<N;i++){\n//\t\tfor(int j=0;j<N;j++) printf(\"%d \",es[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\toutput=true;\n\tfor(int i=0;i<N;i++) used[i]=false;\n\tbool flg=findpath(0,N-1);\n\treturn flg;\n}\n\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tint a=0,b=0;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(es[i][j]==0&&es[j][i]==2) a++;\n\t\t\tif(es[i][j]==2&&es[j][i]==0) b++;\n\t\t}\n\t\tif(a!=b&&i!=0&&i!=N-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint E,Q;\n\tscanf(\"%d%d%d\",&N,&E,&Q);\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tes[u][v]=1;\n\t\tes[v][u]=1;\n\t\thist[u][v]=true;\n\t\thist[v][u]=true;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint cur=0;\n\twhile(true){\n\t\tfor(int i=0;i<N;i++) used[i]=false;\n\t\tbool flg=findpath(0,N-1);\n\t\tif(flg==false) break;\n\t\tcur++;\n\t}\n\tfor(int q=0;q<Q;q++){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tif(type==1){\n\t\t\tbool ok=add(u,v);\n\t\t\tif(ok) cur++;\n\t\t}else{\n\t\t\tbool ok=del(u,v);\n\t\t\tif(!ok) cur--;\n\t\t}\n\t\tprintf(\"%d\\n\",cur);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 505;\nconst int MAXE = 20005;\nconst F MAXF = 1<<29;\n\nstruct MaxFlow {\n    F cap[2*MAXE], flow[2*MAXE];\n    int V, E, level[MAXV], edge[MAXV];\n    int prev[2*MAXE], to[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint prev[MAXV], use_edge[MAXV];\nvoid calc_path(int s, int t, MaxFlow &mf) {\n    queue<int> q; q.push(s);\n    memset(prev, -1, sizeof(prev)); prev[s] = s;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for (int e = mf.edge[v]; e != -1; e = mf.prev[e]) {\n            if (prev[mf.to[e]] == -1 && mf.flow[e] > 0) {\n                prev[mf.to[e]] = v;\n                use_edge[mf.to[e]] = e;\n                q.push(mf.to[e]);\n            }\n        }\n    }\n    for (int v = t; v != prev[v]; v = prev[v]) {\n        mf.flow[use_edge[v]] = mf.flow[use_edge[v]^1] = 0;\n    }\n}\n\nint find_edge(int s, int t, const MaxFlow &mf) {\n    for (int e = mf.edge[s]; e != -1; e = mf.prev[e])\n        if (mf.to[e] == t) return e;\n    return -1;\n}\n\nvoid reset(MaxFlow &mf) {\n    for (int i=0; i<mf.E; ++i)\n        mf.flow[i] = 0;\n}\n\nint main() {\n    int N,E,Q,F,T;\n    scanf(\"%d %d %d\", &N, &E, &Q);\n    MaxFlow mf(N);\n    for (int i=0; i<E; ++i) {\n        scanf(\"%d %d\", &F, &T); F--, T--;\n        mf.add_edge(F, T, 1, 1);\n    }\n    int f = mf.max_flow(0, N-1);\n    int M, A, B;\n    for (int i=0; i<Q; ++i) {\n        scanf(\"%d %d %d\", &M, &A, &B); A--, B--;\n        int e = find_edge(A, B, mf);\n        if (M == 1) {\n            if (e >= 0) mf.cap[e] = mf.cap[e^1] = 1;\n            else mf.add_edge(A, B, 1, 1);\n        } else {\n            mf.cap[e] = mf.cap[e^1] = 0;\n            if (mf.flow[e] != 0) {\n                f--;\n                if (mf.flow[e] < 0) swap(A, B);\n                calc_path(0, A, mf);\n                calc_path(B, N-1, mf);\n                mf.flow[e] = mf.flow[e^1] = 0;\n            }\n        }\n        f += mf.max_flow(0, N-1);\n        printf(\"%d\\n\", f);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint G[511][511];\nint rG[511][511];\n\nbool used[511];\n\nint N,E,Q;\n\n#define INF ( 1<<30) \n\nvoid add_edge(int a,int b){\n  G[a][b] = 1; rG[b][a] = 0;\n  G[b][a] = 1; rG[a][b] = 0;\n}\n\nvoid rem_edge(int a,int b){\n  G[a][b] = 0; rG[b][a] = 0;\n  G[b][a] = 0; rG[a][b] = 0;\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<N;i++){\n    if( !used[i] && G[v][i] > 0 ) {\n      int d = dfs(i, t, min( f, G[v][i] ) );\n      if( d > 0 ){\n\tG[v][i] -= d;\n\trG[i][v] += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n  return flow;\n}\n\nvoid rdfs(int s,int t){\n  if( s == t ) return ;\n  for(int i=0;i<N;i++){\n    if( rG[s][i] == 1 ){\n      rG[s][i] = 0;\n      G[i][s] = 1;\n      rdfs(i,t);\n    }\n  }\n}\n\nint main(){\n  cin  >> N >> E >> Q;\n  for(int i=0;i<E;i++){\n    int e,f;\n    cin >> e >> f;\n    --e; --f;\n    add_edge(e,f);\n  }\n  int rflow = max_flow(0,N-1);\n  for(int i=0;i<Q;i++){\n    int m,a,b;\n    cin >>m>> a>> b;\n    --a; --b;\n    if( m == 1 ){\n      add_edge(a,b);\n      cout <<  max_flow(0,N-1) << endl;\n    } else {\n      if( rG[a][b] == 1 ){\n\trem_edge(a,b);\n\tint d = max_flow(b,a);\n\tif( d == 0 ){\n\t  rdfs(N-1,a);\n\t  rdfs(b,0);\n\t  cout <<   max_flow(0,N-1) << endl;\n\t} \n      } else if( rG[b][a] == 1 ){\n\trem_edge(a,b);\n\tint d = max_flow(a,b);\n\tif( d == 0 ){\n\t  rdfs(N-1,b);\n\t  rdfs(a,0);\n\t  cout <<   max_flow(0,N-1) << endl;\n\t}\n      } else {\n\trem_edge(a,b);\n\tcout <<   max_flow(0,N-1) << endl;\n      }      \n    }\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nint level[500];\nint iter[500];\nconst int INF = 1e9;\n\nvoid bfs(int s, vector< vector<edge> > &G){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f, vector< vector<edge> > &G){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap),G);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > G){\n  int flow = 0;\n  for(;;){\n    bfs(s,G);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF,G)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main(){\n  int N, E, Q;\n  scanf(\"%d %d %d\",&N,&E,&Q);\n  vector< vector<edge> > G(N);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      G[i].push_back((edge){j,0,2*i+1});\n      G[i].push_back((edge){j,0,2*i});\n    }\n  }\n  int f, t;\n  for(int i = 0; i < E; ++i){\n    scanf(\"%d%d\",&f,&t);\n    --f,--t;\n    G[f][2*t].cap = 1;\n    G[t][2*f].cap = 1;\n  }\n  int m, a, b, flow = 0;\n  for(int i = 0; i < Q; ++i){\n    scanf(\"%d %d %d\",&m,&a,&b);\n    --a,--b;\n    if(m == 1){\n      G[a][2*b].cap = 1;\n      G[b][2*a].cap = 1;\n      flow = max_flow(0, N-1, G);\n      G[a][2*b + 1].cap = 0;\n      G[b][2*a + 1].cap = 0;\n    }else{\n      G[a][2*b].cap = 0;\n      G[b][2*a].cap = 0;\n      flow = max_flow(0, N-1, G);\n      G[a][2*b + 1].cap = 0;\n      G[b][2*a + 1].cap = 0;\n    }\n    printf(\"%d\\n\", flow);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n, m, q, a, b, come[1050], used[1050][1050], res;\n\nint dfs(int s, int g){\n\tif(s == g)return 1;\n\tcome[s] = 1;\n\tfor(int i = 0;i <= n;i++){\n\t\tif(come[i])continue;\n\t\tif(used[s][i] <= 0)continue;\n\t\tif(dfs(i, g)){\n\t\t\tused[i][s]++;\n\t\t\tused[s][i]--;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(int s, int g){\n\tfill(come, come + 1000, 0);\n\treturn dfs(s, g);\n}\n\nint main(){\n\tcin >> n >> m >> q;\n\twhile(m--){\n\t\tcin >> a >> b;\n\t\tused[a][b] = used[b][a] = 1;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> m >> a >> b;\n\t\tif(m == 1){\n\t\t\tused[a][b] = used[b][a] = 1;\n\t\t}\n\t\telse{\n\t\t\tif(used[a][b] == 2){\n\t\t\t\tres--;\n\t\t\t\tflow(n, a);\n\t\t\t\tflow(b, 1);\n\t\t\t}\n\t\t\tif(used[b][a] == 2){\n\t\t\t\tres--;\n\t\t\t\tflow(n, b);\n\t\t\t\tflow(a, 1);\t\t\n\t\t\t}\n\t\t\tused[a][b] = used[b][a] = -1;\n\t\t}\n\t\twhile(flow(1, n))res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\nstruct Edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nint indexOf[800][800];\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vector<int> level,iter;//[MAX];\n    vector<bool>used;\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        \n        if(indexOf[from][to] != INF){\n            \n            int tot = indexOf[from][to];\n            int tof = indexOf[to][from];\n            G[from][tot].cap = G[to][tof].cap = 1;\n            \n        } else {\n            Edge q={to,cap,int(G[to].size())};\n            indexOf[from][to] = (int)G[from].size();\n            G[from].push_back(q);\n            q={from,cap,int(G[from].size()-1)};\n            indexOf[to][from] = (int)G[to].size();\n            G[to].push_back(q);\n        }\n    }\n    int getmaxflow(int s,int t,int F) {//from s to t,ford_fulkerson\n        int flow=0;\n        if(s == t) return 0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vector<int>(n);\n            int f;\n            while((f=dfs(s,t,F))>0)flow+=f;\n        }\n    }\n    void bfs(int s){\n        level=vector<int>(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n    \n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int backflow(int v,int t,int f){\n        used = vector<bool>(n,false);\n        int res = __backflow(v,t,f);\n        return res;\n    }\n    int __backflow(int v,int t, int f) {\n        if(v==t)return f;\n        used[v]=1;\n        for(int i=0;i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(used[e.to]||e.cap<=0) continue;\n            int d = __backflow(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\nsigned main(){\n    int N, E, Q;\n    cin >> N >> E >> Q;\n    Dinic fl(N);\n    rep(i,800)rep(j,800)indexOf[i][j] = INF;\n    rep(i,E){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        fl.add_edge(a, b, 1);\n    }\n    int res = fl.getmaxflow(0,N-1,INF);\n    rep(i,Q){\n        int M,a,b;\n        cin >> M >> a >> b;\n        --a;--b;\n        if(M == 1){\n            fl.add_edge(a, b, 1);\n        } else {\n            \n            int tob =  indexOf[a][b];\n            int toa = indexOf[b][a];\n            if( fl.G[a][tob].cap == 1 && fl.G[b][toa].cap == 1){\n                \n                // edge is not used\n                //   cout << \"false\" << endl;\n                \n            } else  if(fl.G[a][tob].cap == 2){\n                if(fl.getmaxflow(b, a, 1) == 0){\n                    fl.backflow(N-1, a, 1);\n                    fl.backflow(b, 0, 1);\n                    --res;\n                }\n            }else if(fl.G[b][toa].cap  == 2){\n                if(fl.getmaxflow(a, b, 1) == 0){\n                    fl.backflow(N-1, b, 1);\n                    fl.backflow(a, 0, 1);\n                    --res;\n                }\n            }\n            \n            // erase edge\n            fl.G[a][tob].cap = 0;\n            fl.G[b][toa].cap = 0;\n        }\n        res += fl.getmaxflow(0, N-1,INF);\n        cout  << res << endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\n#define crear_vec(v,n) v.clear();v.resize(n);\n#define delete_vec(v,n) v.erase(remove(v.begin(),v.end(),n),v.end());\ntypedef pair<int,int> pii;\nint N,E,Q;\nvector<vector<pii> > edge;\nint f;\nvoid flow(int from,int to){\n  for(int i=0;i<edge[from].size();i++){\n    if(edge[from][i].first==to)edge[from][i].second++;\n  }\n  for(int j=0;j<edge[to].size();j++){\n    if(edge[to][j].first == from)edge[to][j].second--;\n  }\n}\n\nvector<int> used;\nint dfs_(int from,int to){\n  used[from]=1;\n  for(int i=0;i<edge[from].size();i++){\n    if(used[edge[from][i].first]==1)continue;\n    if(edge[from][i].first == to){\n      if(edge[from][i].second < 1){\n        flow(from,to);\n        return 1;\n      }else{\n        continue;\n      }\n    }else{\n      if(edge[from][i].second<1 && dfs_(edge[from][i].first,to)==1){\n        flow(from,edge[from][i].first);\n        return 1;\n      }else{\n        continue;\n      }\n    }\n  }\n  used[from]=0;\n  return 0;\n}\nint dfs(int from,int to){\n  crear_vec(used,N+1);\n  return dfs_(from,to);\n}\n\nvoid add_edge(int a,int b){\n  edge[a].push_back(pii(b,0));\n  edge[b].push_back(pii(a,0));\n  while(dfs(1,N))f++;\n}\n\nvoid cut_edge(int a,int b){\n  int ff;\n  for(int i=0;i<edge[a].size();i++){\n    if(edge[a][i].first==b){\n      ff=edge[a][i].second;\n      delete_vec(edge[a],edge[a][i]);\n      break;\n    }\n  }\n  for(int i=0;i<edge[b].size();i++){\n    if(edge[b][i].first==a){\n      delete_vec(edge[b],edge[b][i]);\n      break;\n    }\n  }\n  if(ff==1){\n    dfs(N,b);\n    dfs(a,1);\n    f--;\n  }else if(ff==-1){\n    dfs(1,a);\n    dfs(b,N);\n    f--;\n  }\n  while(dfs(1,N))f++;\n}\n\nint input(){\n  f=0;\n  cin>>N>>E>>Q;\n  crear_vec(edge,N+1);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a,b);\n  }\n  while(dfs(1,N));\n  return 0;\n}\n\nint solve(int m,int a,int b){\n  if(m==1){\n    add_edge(a,b);\n  }else if(m==2){\n    cut_edge(a,b);\n  }\n  return f;\n}\n\nvoid some_querys(){\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    cout<<solve(a,b,c)<<endl;\n  }\n}\n\nint main(){\n  input();\n  some_querys();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\n  \n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n  \nclass range{\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n  \n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n  \n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n  \n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n  \ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n  \n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n    T res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n    int d=30;while((1<<d)>n)d--;return d;\n}\n  \ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n \nclass MaximamFlow{\nprivate:\n    typedef int Flow;\n    struct Edge{int to;Flow icap,cap;};\n    typedef vector<vector<Edge>> Graph;\n \n    //iter　次に調べる時の開始位置 距離\n    vector<int> iter,dist;\n \n    //sからのbfs距離の計算\n    void bfs_dist(int s){\n        fill(ALL(dist),-1); dist[s]=0;\n        queue<int> que; que.push(s);\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            for(Edge& e:G[v])if(e.cap > 0 && dist[e.to] == -1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n     \n    //増加パス\n    Flow dfs_best_path(int s,int t,Flow f){\n        if(s==t)return f;\n        for(int &i = iter[s];i < (int)G[s].size();i++){\n            Edge &e=G[s][i];Edge &reve = G[i][s];\n            if(e.cap <= 0 || dist[s]>=dist[e.to])continue;\n            //search\n            Flow d = dfs_best_path(e.to,t,min(f,e.cap));\n            if(d==0)continue;\n            //found\n            e.cap-=d;reve.cap+=d;\n             \n            return d;\n        }\n        return 0;\n    }\npublic:\n    int V;Graph G;\n    MaximamFlow(int V):V(V){\n        G=Graph(V,vector<Edge>(V));\n        REP(s,V)REP(t,V)G[s][t].to=t;\n        dist=vector<int>(V,-1);iter=vector<int>(V);\n    }\n \n    void add_edge(int s,int t,Flow cap){\n        G[s][t].icap+=cap;G[s][t].cap+=cap;\n    }\n \n    Flow change_cost(int S,int T,int s,int t,int c){\n        Edge& e =G[s][t];Edge& reve = G[t][s];\n        Flow flow = 0;\n        if(e.icap <= c){// 単純に増やす\n            e.cap+=c - e.icap;\n            e.icap = c;\n        }else if(c >= e.icap-e.cap){ // 単純に減らす\n            e.cap-=e.icap - c;\n            e.icap = c;\n        }else{// 戻してから減らす\n            Flow d = e.icap - e.cap - c;\n\n            //(1) S <- s <- t <- T の最大パスを求める\n            // e.cap = 0;reve.cap = 0;\n            // Flow fs = max_flow(s,S,d);\n            // Flow ft = max_flow(T,t,d);\n            // Flow f = min(fs,ft);\n            // //(1).1 流しすぎた分戻す\n            // max_flow(S,s,fs-f); max_flow(t,T,ft-f);\n\n           \t//(1) s->t を他のルートで出来るだけまかなう\n            Flow f = max_flow(s,t,d);\n            //(1).1 それでも流せない分は、逆に戻す\n            flow -= d-f;\n            max_flow(T,S,d-f);\n            //(2) 残り(d-f)は t <- s <- t 内で無駄な t <- s 路ができているので除去する\n            assert(max_flow(s,t,d-f)==d-f);\n            e.cap = 0;reve.cap=c + reve.icap;\n            e.icap = c;\n        }\n\t\tflow += max_flow(S,T);\n        return flow;\n    }\n \n    int max_flow(int s,int t,Flow Mf=INF<Flow>()){\n        if(s==t)return Mf;\n        Flow flow=0;\n        while(Mf>0){\n            bfs_dist(s);\n            if(dist[t] == -1)break;\n            Flow f; fill(ALL(iter),0);\n            while((f=dfs_best_path(s,t,Mf))>0)flow+=f,Mf-=f;\n        }\n        return flow;\n    }\n};\n \n \nclass Main{\n    public:\n \n    void run(){\n        int N,E,Q;cin >> N >> E >> Q;\n\n        vector<vector<bool>> es(N,vector<bool>(N));\n        REP(e,E){\n            int f,t;cin >> f >> t;f--;t--;\n            es[f][t]=es[t][f]=true;\n\t\t}\n \n        MaximamFlow mf(N);\n\t    REP(s,N)REP(t,N)mf.add_edge(s,t,es[s][t]);\n\n\t    ll flow= mf.max_flow(0,N-1);\n        REP(q,Q){\n            int t,a,b;cin >> t >> a >> b;a--;b--; \n            if(t==1){\n                flow+=mf.change_cost(0,N-1,a,b,1);\n                flow+=mf.change_cost(0,N-1,b,a,1);\n                cout << flow <<endl;\n            }else{\n                flow+=mf.change_cost(0,N-1,a,b,0);\n                flow+=mf.change_cost(0,N-1,b,a,0);\n                cout << flow <<endl;\n            }\n        }\n    }\n};\n  \nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, cap, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t, ll fr = linf) {\n    ll res = 0;\n    while (fr > 0) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, fr, used);\n        if (f == 0) break;\n        res += f;\n        fr -= f;\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll N, E, Q; cin >> N >> E >> Q;\n    G.resize(N);\n    REP(i, E) {\n        ll F, T; cin >> F >> T; --F, --T;\n        add_edge(F, T, 1);\n    }\n    ll s = 0, t = N-1;\n    ll ans = max_flow(s, t);\n    REP(i, Q) {\n        ll M, A, B; cin >> M >> A >> B; --A, --B;\n        if (M == 1) {\n            add_edge(A, B, 1);\n        }\n        else {\n            ll r = 0;\n            REP(j, G[A].size()) {\n                Edge& e = G[A][j];\n                if (e.to == B) {\n                    r = e.cap == 0 ? 1 : e.cap == 2 ? -1 : 0;\n                    G[B].erase(G[B].begin()+e.rev, G[B].begin()+e.rev+1);\n                    G[A].erase(G[A].begin()+j, G[A].begin()+j+1);\n                    break;\n                }\n            }\n            if (r) {\n                if (r == 1) {\n                    assert( max_flow(t, B, 1) == 1 );\n                    assert( max_flow(A, s, 1) == 1 );\n                }\n                else {\n                    assert( max_flow(t, A, 1) == 1 );\n                    assert( max_flow(B, s, 1) == 1 );\n                }\n                --ans;\n            }\n        }\n        ans += max_flow(s, t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass max_flow {\npublic:\n    struct edge {\n        int to, cap, rev;\n        edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n    };\nprivate:\n    vector<vector<edge>> g;\n    vector<int> lev, itr;\n    vector<unordered_map<int, vector<int>>> mp;\n\n    void bfs(int s) {\n        int n = g.size();\n        lev = vector<int>(n, -1);\n        queue<int> q;\n        lev[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (edge& e : g[v]) {\n                if (e.cap > 0 && lev[e.to] < 0) {\n                    lev[e.to] = lev[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (; itr[v] < (int)g[v].size(); ++itr[v]) {\n            edge &e = g[v][itr[v]];\n            if (e.cap > 0 && lev[v] < lev[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    max_flow(int n) {\n        g = vector<vector<edge>>(n);\n        mp = vector<unordered_map<int, vector<int>>>(n);\n    }\n    void add_edge(int frm, int to, int cap, bool isdir = true) {\n        mp[frm][to].push_back(g[frm].size());\n        g[frm].push_back(edge(to, cap, g[to].size()));\n        mp[to][frm].push_back(g[to].size());\n        g[to].push_back(edge(frm, isdir ? 0 : cap, (int)g[frm].size() - 1));\n    }\n\n    int inc_cap(int s, int t, int frm, int to, int cap, bool isdir = true) {\n        if (!mp[frm].count(to))\n            add_edge(frm, to, cap, isdir);\n        else {\n            int i = mp[frm][to][0];\n            g[frm][i].cap += cap;\n            if (!isdir)\n                g[to][g[frm][i].rev].cap += cap;\n        }\n        return run(s, t);\n    }\n\n    // decrease cap == 1\n    int dec_cap(int s, int t, int frm, int to, bool isdir = true) {\n        int fi = -1, ti = -1;\n        for (int i : mp[frm][to]) {\n            if (g[frm][i].cap > 0) {\n                fi = i;\n                break;\n            }\n        }\n        for (int i : mp[to][frm]) {\n            if (g[to][i].cap > 0) {\n                ti = i;\n                break;\n            }\n        }\n        int u = frm, v = to;\n        if (isdir) {\n            if (fi != -1) {\n                --g[frm][fi].cap;\n                return 0;\n            }\n            --g[to][ti].cap;\n        }\n        else {\n            if (fi != -1 && ti != -1) {\n                --g[frm][fi].cap;\n                --g[to][ti].cap;\n                return 0;\n            }\n            if (fi != -1) {\n                u = to;\n                v = frm;\n                g[frm][fi].cap -= 2;\n            }\n            else if (ti != -1) {\n                g[to][ti].cap -= 2;\n            }\n            else assert(0);\n        }\n        if (run(u, v, 1)) return 0;\n        run(u, s, 1);\n        run(t, v, 1);\n        return -1;\n    }\n\n\n    int run(int s, int t, int lim = INT_MAX) {\n        int ret = 0;\n        bfs(s);\n        while (true) {\n            bfs(s);\n            if (lev[t] < 0) return ret;\n            itr = vector<int>(g.size());\n            int f;\n            while ((f = dfs(s, t, lim - ret)) > 0) ret += f;\n            if (lim == ret) return ret;\n        }\n    }\n\n};\n\n\nint main() {\n    int n, e, q;\n    cin >> n >> e >> q;\n    max_flow mf(n);\n    for (int i = 0; i < e; ++i) {\n        int f, t;\n        cin >> f >> t;\n        --f;\n        --t;\n        mf.add_edge(f, t, 1, false);\n    }\n    int ans = mf.run(0, n - 1);\n    for (int i = 0; i < q; ++i) {\n        int m, f, t;\n        cin >> m >> f >> t;\n        --f;\n        --t;\n        if (m == 1)\n            ans += mf.inc_cap(0, n - 1, f, t, 1, false);\n        else\n            ans += mf.dec_cap(0, n - 1, f, t, false);\n\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct flowGraph{\n\tstruct edge{ int to, cap, rev; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tint add(int s, int t, int cap){\n\t\tG[s].pb((edge){t, cap, G[t].size()});\n\t\tG[t].pb((edge){s, 0, G[s].size() - 1});\n\t\treturn G[s].size() - 1;\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t, int lim = inf){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, lim - flow)) > 0) flow += f;\n\t\t\tif(flow == lim) return flow;\n\t\t}\n\t}\n};\nint n, e, q;\nint m[1000], a[1000], b[1000];\n\nint main(){\n\tcin >> n >> e >> q;\n\tmap<pi, int> id;\n\tflowGraph g(n);\n\trep(i, e){\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--; t--;\n\t\trep(it, 2){\n\t\t\tint j = g.add(f, t, 1);\n\t\t\tif(!id.count(mp(f, t))) id[mp(f, t)] = j;\n\t\t\tswap(f, t);\n\t\t}\n\t}\n\trep(i, q){\n\t\tcin >> m[i] >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\trep(it, 2){\n\t\t\tif(!id.count(mp(a[i], b[i]))){\n\t\t\t\tint j = g.add(a[i], b[i], 0);\n\t\t\t\tid[mp(a[i], b[i])] = j;\n\t\t\t}\n\t\t\tswap(a[i], b[i]);\n\t\t}\n\t}\n\tint ans = g.max_flow(0, n - 1);\n\t\n\trep(i, q){\n\t\tif(m[i] == 1){\n\t\t\tg.G[a[i]][id[mp(a[i], b[i])]].cap++;\n\t\t\tg.G[b[i]][id[mp(b[i], a[i])]].cap++;\n\t\t\tans += g.max_flow(0, n - 1);\n\t\t}\n\t\telse{\n\t\t\tint j = g.G[a[i]][id[mp(a[i], b[i])]].rev;\n\t\t\tif(g.G[b[i]][j].cap == 0){\n\t\t\t\tswap(a[i], b[i]);\n\t\t\t\tj = g.G[a[i]][id[mp(a[i], b[i])]].rev;\n\t\t\t}\n\t\t\tg.G[b[i]][id[mp(b[i], a[i])]].cap = 0;\n\t\t\t\n\t\t\tint t = g.max_flow(a[i], b[i], 1);\n\t\t\tif(!t){\n\t\t\t\tg.max_flow(n - 1, 0, 1);\n\t\t\t\tint u = g.max_flow(a[i], b[i], 1);\n\t\t\t\tassert(u);\n\t\t\t\tans--;\n\t\t\t}\n\t\t\tg.G[b[i]][j].cap = 0;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 510\n\n\nint V,E;\nint capacity[NUM][NUM];\n\nvector<int> G[NUM]; //グラフの隣接リスト表現\nbool used[NUM]; //DFSですでに調べたかのフラグ\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n\tcapacity[from][to] = 1;\n\tcapacity[to][from] = 1;\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tint to = G[node_id][i];\n\t\tif(used[to] == false &&  capacity[node_id][to] > 0){ //エッジの先のノードに未訪問で、かつエッジに流す余裕がある場合\n\t\t\tint tmp_flow = dfs(to,sink,min(flow,capacity[node_id][to])); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\tcapacity[node_id][to] -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tcapacity[to][node_id] += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink,int limit){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(limit > 0){ //増加パスが存在する限り、流量を追加し続ける\n\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\tadd = dfs(source,sink,1);\n\t\tif(add == 0)break;\n\t\tflow += add;\n\t\tlimit--;\n\t}\n\treturn flow;\n}\n\n\nint main(){\n\n\tint N,E,Q;\n\tscanf(\"%d %d %d\",&N,&E,&Q);\n\n\tV = N; //Vは、usedテーブルを初期化する際に使うだけなのでNとして良い\n\n\tint from,to;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(from,to);\n\t}\n\n\tint ans = max_flow(0,N-1,BIG_NUM);\n\n\tint command,A,B;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%d %d %d\",&command,&A,&B);\n\t\tA--;\n\t\tB--;\n\n\t\tif(command == 1){\n\t\t\tadd_edge(A,B);\n\t\t}else{ //削除命令\n\n\t\t\t//printf(\"capacity[A-B]:%d [B-A]:%d\\n\",capacity[A][B],capacity[B][A]);\n\n\t\t\tif(capacity[A][B] == 1 && capacity[B][A] == 1){ //使ってない場合\n\t\t\t\t//Do nothing :削除しても影響なし\n\t\t\t}else if(capacity[A][B] == 2){ //B→Aの方向に流れた場合\n\t\t\t\tif(max_flow(B,A,1) == 1){ //B→Aの別の経路がある場合\n\t\t\t\t\t//経路変更して流量は変わらず\n\n\t\t\t\t}else{ //B→Aに別の経路がない場合\n\t\t\t\t\tmax_flow(N-1,0,1); //sink→sourceに押し戻す\n\t\t\t\t\tif(capacity[B][A] == 1){ //B→Aの流れが押し戻された場合\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmax_flow(B,A,1); //別の経路を探す\n\t\t\t\t\t}\n\t\t\t\t\tans--;\n\t\t\t\t}\n\t\t\t}else{ //capacity[B][A] == 2 A→Bの方向に流れる場合\n\n\t\t\t\t//printf(\"Minhi!\\n\");\n\n\t\t\t\tif(max_flow(A,B,1) == 1){ //A→Bの別の経路がある場合\n\t\t\t\t\t//printf(\"別の経路あり\\n\");\n\t\t\t\t\t//経路変更して流量は変わらず\n\t\t\t\t}else{ //A→Bに別の経路がない場合\n\t\t\t\t\tmax_flow(N-1,0,1); //sink→sourceに押し戻す\n\t\t\t\t\tif(capacity[A][B] == 1){ //A→Bの流れが押し戻された場合\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t//printf(\"押しも度された\\n\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmax_flow(A,B,1); //別の経路を探す\n\t\t\t\t\t\t//printf(\"別のを探す\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tans--;\n\t\t\t\t\t//printf(\"ans:%d\\n\",ans);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcapacity[A][B] = 0;\n\t\t\tcapacity[B][A] = 0;\n\t\t}\n\n\t\tans += max_flow(0,N-1,1); //増加流量は最大1であるはず\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 600\nstruct edge {\n  int to,cap,rev;\n  edge(){}\n  edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n \nvector<edge> G[MAX_V],G2[MAX_V];\nmap<int,int> M[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n \nvoid add_edge(int from,int to,int cap){\n  M[from][to]=G2[from].size();\n  M[to][from]=G2[to].size();\n  G2[from].push_back(edge(to,cap,G2[to].size()));\n  G2[to].push_back(edge(from,cap,G2[from].size()-1));\n}\n \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n \nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n \nint main(){\n  int N,E,Q;\n  cin>>N>>E>>Q;\n  for(int i=0,f,t;i<E;i++) scanf(\"%d%d\",&f,&t),add_edge(f,t,1);\n  int prev=0;\n  for(int i=1;i<=N;i++) G[i]=G2[i];\n  while(Q--){\n    int m,a,b;\n    scanf(\"%d%d%d\",&m,&a,&b);\n    if(m==1){\n      \n      if(M[a].find(b)==M[a].end()) {\n\tadd_edge(a,b,1);\n\t//G[a].push_back(edge(b,1,G[a].size()));\n\t//G[b].push_back(edge(a,1,G[b].size()-1));\n      }else{\n\t//G[a][M[a][b]].cap=G[b][M[b][a]].cap=1;\n\tG2[a][M[a][b]].cap=G2[b][M[b][a]].cap=1;\n      }\n      for(int i=1;i<=N;i++) G[i]=G2[i];\n      prev=0;\n    }else{\n      G2[a][M[a][b]].cap=G2[b][M[b][a]].cap=0;\n      for(int i=1;i<=N;i++) G[i]=G2[i];\n      prev=0;\n    }\n    prev=prev+max_flow(1,N);\n    printf(\"%d\\n\",prev);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2313 Box Witch\n// 2018.3.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// AOJ 2118 Oil Company\n// 2018.3.10 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*******************************************/\n/* Dinic's Max Flow Algorithm \n/*******************************************/\n\n#define INF 0x01010101\n#define VMAX 505\ntypedef struct { int to, cap, rev; char run; } EDGE;\nEDGE  edge[VMAX][VMAX]; int hi[VMAX];\nint   V, source, sink;\nchar  used[VMAX];\nshort tbl[VMAX][VMAX];\n\nvoid add_edge(int from, int to)\n{\n\tint f, t;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = 1, e->rev = t, e->run = 1;\n\te = &edge[to][t], e->to = from, e->cap = 1, e->rev = f, e->run = 1;\n\ttbl[from][to] = f, tbl[to][from] = t;\n}\n\nint dfs(int v, int t, int f)\n{\n\tint i, d;\n\tEDGE *e;\n\t\n\tif (v == t) return f;\n\tused[v] = 1;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\te = &edge[v][i];\n\t\tif (e->run == 0) continue;\n\t\tif (e->cap > 0 && !used[e->to]) {\n\t\t\td = dfs(e->to, t, f <= e->cap? f: e->cap);\n\t\t\tif (d > 0) {\n\t\t\t\te->cap -= d;\n\t\t\t\tedge[e->to][e->rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t, int max)\n{\n\tint f, flow = 0;\n\twhile (max > 0) {\n\t\tmemset(used, 0, V);\n\t\tif (!(f = dfs(s, t, max))) break;\n\t\tflow += f, max -= f;\n\t}\n\treturn flow;\n}\n\nint back_edge(int from, int to)\n{\n\tEDGE *e = &edge[from][tbl[from][to]];\n\tif (e->run) {\n\t\te->run = 0;\n\t\tif (e->cap == 0 && maxFlow(from, to, 1) == 0) {\n\t\t\tmaxFlow(from, source, 1);\n\t\t\tmaxFlow(sink, to, 1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**********************************************/\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint N, E, Q, i, ans;\n\n\tN = in(), E = in(), Q = in();\n\t\n\tsource = 0, sink = N-1, V = sink+1;\n\tfor (i = 0; i < E; i++) {\n\t\tint f = in()-1, t = in()-1;\n\t\tadd_edge(f, t);\n\t}\n\n\tans = maxFlow(source, sink, INF);\n\n\twhile (Q--) {\n\t\tint m = in(), a = in()-1, b = in()-1;\n\t\tif (m == 1) {\n\t\t\tadd_edge(a, b);\n\t\t\tans += maxFlow(source, sink, 1);\n\t\t} else {\n\t\t\tans -= back_edge(a, b);\n\t\t\tans -= back_edge(b, a);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint Flow(int s,int t,int v,int e,int min){\n  while(v--)F[v]=0;\n  return MF(s,t,e,min);\n}\nint maxf(int v,int e,int s,int t){\n  int f,r;\n  for(f=0;r=Flow(s,t,v,e,1e9);f+=r);\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(n+1,e,1,n);//printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[(i+e)%(2*e)]=1;\n      ans+=Flow(1,n,n+1,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      else if(MF(a,b,e,1)==0){\n\tFlow(n,b,n+1,e,1);\n\tFlow(a,1,n+1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint maxf(int v,int e,int s,int t){\n  int i,f,r;\n  for(i=0;i<v;i++)F[i]=0;\n  for(f=0;r=MF(s,t,e,1e9);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n  }\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(n+1,e,1,n);printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[i+e]=1;\n      for(i=0;i<=n;i++)F[i]=0;\n      ans+=MF(1,n,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      for(i=0;i<=n;i++)F[i]=0;\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      //if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      if(co[k]-1&&MF(a,b,e,1)==0){\n\tfor(i=0;i<=n;i++)F[i]=0;\n\tMF(n,b,e,1);\n\tfor(i=0;i<=n;i++)F[i]=0;\n\tMF(a,1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n   \n    }\n    /*for(i=0;i<=n;i++){printf(\"%d:\",i);\n      for(k=ta[i];k+1;k=nt[k])printf(\" %d %d:\",to[k],co[k]);\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2313\nTitle Box Witch\n*/\n#include <stdio.h>\n#include <string.h>\n//Global data section\n#define NUMofNODE 500\nint neighbor[NUMofNODE+1][NUMofNODE+1];\nint connect[NUMofNODE+1];\nint connect_old[NUMofNODE+1];\nint N,E,Q;\nint F,T;\nint M,A,B;\n//\nint can_connect(int start,int end)\n{\n        int i,j;\n        memset(connect,0,NUMofNODE*sizeof(int));\n        connect[start]=-1;\n        \n        while(1)\n        {\n                for(i=1;i<N;i++)\n                {\n                        if(connect[i])\n                                for(j=0;j<N;j++)\n                                        connect[j] |= neighbor[i][j];\n                }\n                if(memcpy(connect_old,connect,N*sizeof(int))||connect[end])\n                        break;\n                memcpy(connect_old,connect,N*sizeof(int));\n        }\n        return(connect[end]);\n}\nint trans_speed()\n{\n        int i,c,can;\n        c=0;\n        for(i=1;i<=N-1;i++)\n                if(neighbor[N][i])\n                {\n                        can=can_connect(1,i);\n                        c += can?1:0;\n                }\n        return(c);\n}\nvoid clear()\n{\n        int i,j;\n        for(i=0;i<NUMofNODE;i++)\n                for(j=0;j<NUMofNODE;j++)\n                        neighbor[i][j]=0;\n}\ndump_neighbor_table()\n{\n        int i,j;\n        for(i=1;i<=N-1;i++)\n        {\n                for(j=i+1;j<=N;j++)\n                        if(neighbor[i][j])\n                                printf(\"(%d-%d)\",i,j);\n        }\n        printf(\"\\n\");\n}\nmain()\n{\n        int i;\n\n        clear();\n\n        scanf(\"%d %d %d\",&N,&E,&Q);\n\n\n        for(i=0;i<E;i++)\n        {\n                scanf(\"%d %d\",&F,&T);\n                neighbor[F][T]=neighbor[T][F]=-1;\n        }\n        for(i=0;i<Q;i++)\n        {\n                scanf(\"%d %d %d\",&M,&A,&B);\n                if(M==1)\n                        neighbor[A][B]=neighbor[B][A]=-1;\n                else if(M==2)\n                        neighbor[A][B]=neighbor[B][A]=0;\n                printf(\"%d\\n\",trans_speed());\n        }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2313\nTitle Box Witch\n13/8/1 WA 6/58\n*/\n#include <stdio.h>\n#include <string.h>\n//Global data section\n#define NUMofNODE 500\nint neighbor[NUMofNODE+1][NUMofNODE+1];\nint connect[NUMofNODE+1];\nint connect_old[NUMofNODE+1];\nint N,E,Q;\nint F,T;\nint M,A,B;\n//\nint can_connect(int start,int end)\n{\n        int i,j;\n        memset(connect,0,NUMofNODE*sizeof(int));\n        connect[start]=-1;\n        \n        while(1)\n        {\n                for(i=1;i<N;i++)\n                {\n                        if(connect[i])\n                                for(j=0;j<N;j++)\n                                        connect[j] |= neighbor[i][j];\n                }\n                if(memcmp(connect_old,connect,N*sizeof(int))||connect[end])\n                        break;\n                memcpy(connect_old,connect,N*sizeof(int));\n        }\n        return(connect[end]);\n}\nint trans_speed()\n{\n        int i,c,can;\n        c=0;\n        for(i=1;i<=N-1;i++)\n                if(neighbor[N][i])\n                {\n                        can=can_connect(1,i);\n                        c += can?1:0;\n                }\n        return(c);\n}\nvoid clear()\n{\n        int i,j;\n        for(i=0;i<NUMofNODE;i++)\n                for(j=0;j<NUMofNODE;j++)\n                        neighbor[i][j]=0;\n}\ndump_neighbor_table()\n{\n        int i,j;\n        for(i=1;i<=N-1;i++)\n        {\n                for(j=i+1;j<=N;j++)\n                        if(neighbor[i][j])\n                                printf(\"(%d-%d)\",i,j);\n        }\n        printf(\"\\n\");\n}\nmain()\n{\n        int i;\n\n        clear();\n\n        scanf(\"%d %d %d\",&N,&E,&Q);\n\n\n        for(i=0;i<E;i++)\n        {\n                scanf(\"%d %d\",&F,&T);\n                neighbor[F][T]=neighbor[T][F]=-1;\n        }\n        for(i=0;i<Q;i++)\n        {\n                scanf(\"%d %d %d\",&M,&A,&B);\n                if(M==1)\n                        neighbor[A][B]=neighbor[B][A]=-1;\n                else if(M==2)\n                        neighbor[A][B]=neighbor[B][A]=0;\n                printf(\"%d\\n\",trans_speed());\n        }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint Flow(int s,int t,int v,int e,int min){\n  while(v--)F[v]=0;\n  return MF(s,t,e,min);\n}\nint maxf(int s,int t,int v,int e){\n  int f,r;\n  for(f=0;r=Flow(s,t,v,e,1e9);f+=r);\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(1,n,n+1,e);//printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[(i+e)%(2*e)]=1;\n      ans+=Flow(1,n,n+1,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      else if(Flow(a,b,n+1,e,1)==0){\n\tFlow(n,b,n+1,e,1);\n\tFlow(a,1,n+1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2313\nTitle Box Witch\n13/8/1 WA 6/58\n*/\n#include <stdio.h>\n#include <string.h>\n//Global data section\n#define NUMofNODE 500\nint neighbor[NUMofNODE+1][NUMofNODE+1];\nint connect[NUMofNODE+1];\nint connect_old[NUMofNODE+1];\nint direct[NUMofNODE+1];\nint N,E,Q;\nint F,T;\nint M,A,B;\n//\nvoid can_reach_from_1()\n{\n        int i,j;\n        memset(connect,0,NUMofNODE*sizeof(int));\n        connect[1]=-1;\n        memcpy(connect_old,connect,(N+1)*sizeof(int));\n\n        while(1)\n        {\n                for(i=1;i<N;i++)\n                {\n                        if(connect[i] && (direct[i]==0 || i==1))\n                        {\n                                for(j=2;j<N;j++)\n                                {\n                                        //if(neighbor[i][j])\n                                        //        printf(\"*:%d %d\\n\",i,j);\n                                        connect[j] |= neighbor[i][j];\n                                }\n                        }\n                }\n                if(0==memcmp(connect_old,connect,(N+1)*sizeof(int)))\n                        break;\n                memcpy(connect_old,connect,(N+1)*sizeof(int));\n        }\n}\nint trans_speed()\n{\n        int i,c,can;\n        c=0;\n\n\n        for(i=1;i<=N-1;i++)\n                if(neighbor[N][i])\n                        direct[i]=-1;\n                else\n                        direct[i]=0;\n        can_reach_from_1();\n        \n        for(i=1;i<=N-1;i++)\n                if(neighbor[N][i])\n                {\n                        c += (can=connect[i]?1:0);\n                        //printf(\"%d - 1:%d\\n\",i,can);\n                }\n\n        //for(i=2;i<=N-1;i++)\n        //        printf(\"%c\",connect[i]?'*':'-');\n        //printf(\"\\n\");\n\n        return(c);\n}\nvoid clear()\n{\n        int i,j;\n        for(i=0;i<NUMofNODE;i++)\n                for(j=0;j<NUMofNODE;j++)\n                        neighbor[i][j]=0;\n}\ndump_neighbor_table()\n{\n        int i,j;\n        for(i=1;i<=N-1;i++)\n        {\n                for(j=i+1;j<=N;j++)\n                        if(neighbor[i][j])\n                                printf(\"(%d-%d)\",i,j);\n        }\n        printf(\"\\n\");\n}\nmain()\n{\n        int i;\n\n        clear();\n\n        scanf(\"%d %d %d\",&N,&E,&Q);\n\n\n        for(i=0;i<E;i++)\n        {\n                scanf(\"%d %d\",&F,&T);\n                neighbor[F][T]=neighbor[T][F]=-1;\n        }\n        for(i=0;i<Q;i++)\n        {\n                scanf(\"%d %d %d\",&M,&A,&B);\n                if(M==1)\n                        neighbor[A][B]=neighbor[B][A]=-1;\n                else if(M==2)\n                        neighbor[A][B]=neighbor[B][A]=0;\n                printf(\"%d\\n\",trans_speed());\n        }\n        //dump_neighbor_table();\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint Flow(int s,int t,int v,int e,int min){\n  while(v--)F[v]=0;\n  return MF(s,t,e,min);\n}\nint maxf(int v,int e,int s,int t){\n  int f,r;\n  for(f=0;r=Flow(s,t,v,e,1e9);f+=r);\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(n+1,e,1,n);//printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[(i+e)%(2*e)]=1;\n      ans+=MF(1,n,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      else if(MF(a,b,e,1)==0){\n\tMF(n,b,e,1);\n\tMF(a,1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2313 Box Witch\n// 2018.3.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// AOJ 2118 Oil Company\n// 2018.3.10 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*******************************************/\n/* Dinic's Max Flow Algorithm \n/*******************************************/\n\n#define INF 0x01010101\n#define VMAX 505\ntypedef struct { int to, cap, rev; char run; } EDGE;\nEDGE edge[VMAX][VMAX]; int hi[VMAX];\nint V, source, sink;\nchar used[VMAX];\n\nvoid add_edge(int from, int to, int cap)\n{\n\tint f, t;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = cap, e->rev = t, e->run = 1; \n\te = &edge[to][t], e->to = from, e->cap = cap, e->rev = f, e->run = 1;\n}\n\nint dfs(int v, int t, int f)\n{\n\tint i, d;\n\tEDGE *e;\n\t\n\tif (v == t) return f;\n\tused[v] = 1;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\te = &edge[v][i];\n\t\tif (e->run == 0) continue;\n\t\tif (e->cap > 0 && !used[e->to]) {\n\t\t\td = dfs(e->to, t, f <= e->cap? f: e->cap);\n\t\t\tif (d > 0) {\n\t\t\t\te->cap -= d;\n\t\t\t\tedge[e->to][e->rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t, int max)\n{\n\tint f, flow = 0;\n\twhile (max > 0) {\n\t\tmemset(used, 0, V);\n\t\tf = dfs(s, t, max);\n\t\tif (!f) break;\n\t\tflow += f;\n\t\tmax -= f;\n\t}\n\treturn flow;\n}\n\nint back_edge(int from, int to)\n{\n\tint i;\n\tEDGE *e;\n\n\tfor (i = 0; i < hi[from]; i++) if (edge[from][i].to == to) {\n\t\te = &edge[from][i];\n\t\tif (e->run) {\n\t\t\te->run = 0;\n\t\t\tif (e->cap == 0 && maxFlow(from, to, 1) == 0) {\n\t\t\t\tmaxFlow(from, source, 1);\n\t\t\t\tmaxFlow(sink, to, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/**********************************************/\n\n\n#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint N, E, Q, i, ans;\n\n\tN = in(), E = in(), Q = in();\n\t\n\tsource = 0, sink = N-1, V = sink+1;\n\tfor (i = 0; i < E; i++) {\n\t\tint f = in()-1, t = in()-1;\n\t\tadd_edge(f, t, 1);\n\t}\n\n\tans = maxFlow(source, sink, INF);\n\n\twhile (Q--) {\n\t\tint m = in(), a = in()-1, b = in()-1;\n\t\tif (m == 1) {\n\t\t\tadd_edge(a, b, 1);\n\t\t\tans += maxFlow(source, sink, 1);\n\t\t} else {\n\t\t\tans -= back_edge(a, b);\n\t\t\tans -= back_edge(b, a);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint Flow(int s,int t,int v,int e,int min){\n  while(v--)F[v]=0;\n  return MF(s,t,e,min);\n}\nint maxf(int v,int e,int s,int t){\n  int f,r;\n  for(f=0;r=Flow(s,t,v,e,1e9);f+=r);\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(n+1,e,1,n);//printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[(i+e)%(2*e)]=1;\n      ans+=Flow(1,n,n+1,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      else if(Flow(a,b,n+1,e,1)==0){\n\tFlow(n,b,n+1,e,1);\n\tFlow(a,1,n+1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint maxf(int v,int e,int s,int t){\n  int i,f,r;\n  for(i=0;i<v;i++)F[i]=0;\n  for(f=0;r=MF(s,t,e,1e9);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n  }\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(n+1,e,1,n);//printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[(i+e)%(2*e)]=1;\n\n      /*for(i=0;i<=n;i++){printf(\"%d:\",i);\n      for(k=ta[i];k+1;k=nt[k])printf(\" %d %d:\",to[k],co[k]);\n      printf(\"\\n\");\n      }//*/\n\n      for(i=0;i<=n;i++)F[i]=0;\n      ans+=MF(1,n,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      for(i=0;i<=n;i++)F[i]=0;\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      else if(MF(a,b,e,1)==0){\n\tfor(i=0;i<=n;i++)F[i]=0;\n\tMF(n,b,e,1);\n\tfor(i=0;i<=n;i++)F[i]=0;\n\tMF(a,1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n   \n    }\n    /*\n      for(i=0;i<=n;i++){printf(\"%d:\",i);\n      for(k=ta[i];k+1;k=nt[k])printf(\" %d %d:\",to[k],co[k]);\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2313\nTitle Box Witch\n13/8/1 WA 6/58\n*/\n#include <stdio.h>\n#include <string.h>\n//Global data section\n#define NUMofNODE 500\nint neighbor[NUMofNODE+1][NUMofNODE+1];\nint connect[NUMofNODE+1];\nint connect_old[NUMofNODE+1];\nint N,E,Q;\nint F,T;\nint M,A,B;\n//\nvoid can_reach_from_1()\n{\n        int i,j;\n        memset(connect,0,NUMofNODE*sizeof(int));\n        connect[1]=-1;\n        memcpy(connect_old,connect,(N+1)*sizeof(int));\n\n        while(1)\n        {\n                for(i=1;i<N;i++)\n                {\n                        if(connect[i])\n                        {\n                                for(j=2;j<N;j++)\n                                {\n                                        //        if(neighbor[i][j])\n                                        //        printf(\"*:%d %d\\n\",i,j);\n                                        connect[j] |= neighbor[i][j];\n                                }\n                        }\n                }\n                if(0==memcmp(connect_old,connect,(N+1)*sizeof(int)))\n                        break;\n                memcpy(connect_old,connect,(N+1)*sizeof(int));\n        }\n}\nint trans_speed()\n{\n        int i,c,can;\n        c=0;\n        can_reach_from_1();\n\n        for(i=1;i<=N-1;i++)\n                if(neighbor[N][i])\n                {\n                        c += (can=connect[i]?1:0);\n                        //printf(\"%d - 1:%d\\n\",i,can);\n                }\n/*\n        for(i=2;i<=N-1;i++)\n                printf(\"%c\",connect[i]?'*':'-');\n        printf(\"\\n\");\n*/\n        return(c);\n}\nvoid clear()\n{\n        int i,j;\n        for(i=0;i<NUMofNODE;i++)\n                for(j=0;j<NUMofNODE;j++)\n                        neighbor[i][j]=0;\n}\ndump_neighbor_table()\n{\n        int i,j;\n        for(i=1;i<=N-1;i++)\n        {\n                for(j=i+1;j<=N;j++)\n                        if(neighbor[i][j])\n                                printf(\"(%d-%d)\",i,j);\n        }\n        printf(\"\\n\");\n}\nmain()\n{\n        int i;\n\n        clear();\n\n        scanf(\"%d %d %d\",&N,&E,&Q);\n\n\n        for(i=0;i<E;i++)\n        {\n                scanf(\"%d %d\",&F,&T);\n                neighbor[F][T]=neighbor[T][F]=-1;\n        }\n        for(i=0;i<Q;i++)\n        {\n                scanf(\"%d %d %d\",&M,&A,&B);\n                if(M==1)\n                        neighbor[A][B]=neighbor[B][A]=-1;\n                else if(M==2)\n                        neighbor[A][B]=neighbor[B][A]=0;\n                printf(\"%d\\n\",trans_speed());\n        }\n        //dump_neighbor_table();\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2313 Box Witch\n// 2018.3.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// AOJ 2118 Oil Company\n// 2018.3.10 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*******************************************/\n/* Dinic's Max Flow Algorithm \n/*******************************************/\n\n#define INF 0x01010101\n#define VMAX 505\ntypedef struct { int to, cap, rev; char run; } EDGE;\nEDGE edge[VMAX][VMAX]; int hi[VMAX];\nint V, source, sink;\nchar used[VMAX];\n\nvoid add_edge(int from, int to, int cap)\n{\n\tint f, t;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = cap, e->rev = t, e->run = 1; \n\te = &edge[to][t], e->to = from, e->cap = cap, e->rev = f, e->run = 1;\n}\n\nint dfs(int v, int t, int f)\n{\n\tint i, d;\n\tEDGE *e;\n\t\n\tif (v == t) return f;\n\tused[v] = 1;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\te = &edge[v][i];\n\t\tif (e->run == 0) continue;\n\t\tif (e->cap > 0 && !used[e->to]) {\n\t\t\td = dfs(e->to, t, f <= e->cap? f: e->cap);\n\t\t\tif (d > 0) {\n\t\t\t\te->cap -= d;\n\t\t\t\tedge[e->to][e->rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t, int max)\n{\n\tint f, flow = 0;\n\twhile (max > 0) {\n\t\tmemset(used, 0, V);\n\t\tf = dfs(s, t, max);\n\t\tif (!f) break;\n\t\tflow += f;\n\t\tmax -= f;\n\t}\n\treturn flow;\n}\n\nint back_edge(int from, int to)\n{\n\tint i;\n\tEDGE *e;\n\n\tfor (i = 0; i < hi[from]; i++) if (edge[from][i].to == to) {\n\t\te = &edge[from][i];\n\t\tif (e->run) {\n\t\t\te->run = 0;\n\t\t\tif (e->cap == 0 && maxFlow(from, to, 1) == 0) {\n\t\t\t\tmaxFlow(from, source, 1);\n\t\t\t\tmaxFlow(sink, to, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/**********************************************/\n\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint N, E, Q, i, ans;\n\n\tN = in(), E = in(), Q = in();\n\t\n\tsource = 0, sink = N-1, V = sink+1;\n\tfor (i = 0; i < E; i++) {\n\t\tint f = in()-1, t = in()-1;\n\t\tadd_edge(f, t, 1);\n\t}\n\n\tans = maxFlow(source, sink, INF);\n\n\twhile (Q--) {\n\t\tint m = in(), a = in()-1, b = in()-1;\n\t\tif (m == 1) {\n\t\t\tadd_edge(a, b, 1);\n\t\t\tans += maxFlow(source, sink, 1);\n\t\t} else {\n\t\t\tans -= back_edge(a, b);\n\t\t\tans -= back_edge(b, a);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[1000010],nt[1000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\nint Flow(int s,int t,int v,int e,int min){\n  while(v--)F[v]=0;\n  return MF(s,t,e,min);\n}\nint maxf(int s,int t,int v,int e){\n  int f=0,r;\n  while(r=Flow(s,t,v,e,1e9))f+=r;\n  return f;\n}\nint main(){\n  int n,m,q,l,ans,e,r=0,i,a,b,k;\n  scanf(\"%d %d %d\",&n,&m,&q);\n  e=m+q;\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d\",&a,&b);\n    nt[r  ]=ta[to[r+e]=a];\n    nt[r+e]=ta[to[r  ]=b];\n    co[ta[b]=r+e]=co[ta[a]=r]=1;\n    r++;\n  }/*printf(\"a\\n\");\n  for(i=0;i<=n;i++){printf(\"%d:\",i);\n    for(k=ta[i];k+1;k=nt[k])printf(\" %d\",to[k]);\n    printf(\"\\n\");\n    }//*/\n  ans=maxf(1,n,n+1,e);//printf(\"%d\\n\",ans);\n  while(q--){\n    scanf(\"%d %d %d\",&k,&a,&b);\n    if(k==1){\n      for(i=ta[a];i+1;i=nt[i]){\n\tif(to[i]==b)break;\n      }\n      if(i==-1){\n\tnt[r  ]=ta[to[r+e]=a];\n\tnt[r+e]=ta[to[r  ]=b];\n\tco[ta[b]=r+e]=co[ta[a]=r]=1;\n\tr++;\n      }\n      else co[i]=co[(i+e)%(2*e)]=1;\n      ans+=Flow(1,n,n+1,e,1);\n    }\n    else{\n      for(k=ta[a];to[k]-b;k=nt[k]);\n      if(co[k]==2){\n\ti=a;\n\ta=b;\n\tb=i;\n\tk=(k+e)%(2*e);\n      }\n      if(co[k]==1);//co[i]=co[(i+e)%(2*e)]=0;\n      else if(Flow(a,b,n+1,e,1)==0){\n\tFlow(n,b,n+1,e,1);\n\tFlow(a,1,n+1,e,1);\n\tans--;\n      }\n      co[k]=co[(k+e)%(2*e)]=0;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joinet\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tif (maxflow == 0) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tArrays.fill(flow[j], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\t\t\tint tmp = A;\n\t\t\t\t\t\t\tA = B;\n\t\t\t\t\t\t\tB = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\t\tflow[B][A] = 0;\n\t\t\t\t\t\tmaxflow--;\n\t\t\t\t\t\tInteger[] prev_v = dfs(B, N - 1, true);\n\t\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v[j]) {\n\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev_v = dfs(0, A, true);\n\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joinet\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\t\tint tmp = A;\n\t\t\t\t\t\tA = B;\n\t\t\t\t\t\tB = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\tflow[B][A] = 0;\n\t\t\t\t\t\n\n\n\t\t\t\t\tif (maxflow == 0) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tArrays.fill(flow[j], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaxflow--;\n\t\t\t\t\t\tInteger[] prev_v = dfs(B, N - 1, true);\n\t\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v[j]) {\n\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev_v = dfs(0, A, true);\n\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joinet\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tif (maxflow == 0) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tArrays.fill(flow[j], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\t\t\tint tmp = A;\n\t\t\t\t\t\t\tA = B;\n\t\t\t\t\t\t\tB = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\t\tflow[B][A] = 0;\n\t\t\t\t\t\tInteger[] prev_v1 = dfs(B, N - 1, true);\n\t\t\t\t\t\tInteger[] prev_v2 = dfs(0, A, true);\n\t\t\t\t\t\tif ((prev_v1[N - 1] != -1 || B == N - 1) && (A == 0 || prev_v2[A] != -1)) {\n\t\t\t\t\t\t\tmaxflow--;\n\t\t\t\t\t\t\tif (B != N - 1) {\n\t\t\t\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v1[j]) {\n\t\t\t\t\t\t\t\t\tset_flow(prev_v1[j], j, -1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (A != 0) {\n\t\t\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v2[j]) {\n\t\t\t\t\t\t\t\t\tset_flow(prev_v2[j], j, -1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(\"!\");\n\t\t\t\t\t\t\tInteger[] prev_v = dfs(B, A, true);\n\t\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\t\t\tif (prev_v[j] == -1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.io.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint n, e, q;\n\n\tLinkedList<Edge>[] g;\n\n\tint flow;\n\n\tboolean used[];\n\n\n\n\tint INF = Integer.MAX_VALUE >> 4;\n\n\n\n\tvoid run() {\n\n\n\n\t\tn = sc.nextInt();\n\n\t\te = sc.nextInt();\n\n\t\tq = sc.nextInt();\n\n\t\tn++;\n\n\n\n\t\tg = new LinkedList[n];\n\n\t\tused = new boolean[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\n\n\t\t\tg[i] = new LinkedList<Edge>();\n\n\t\t}\n\n\n\n\t\tfor (int i = 0; i < e; i++) {\n\n\n\n\t\t\tint a = sc.nextInt();\n\n\t\t\tint b = sc.nextInt();\n\n\t\t\tadd(Math.min(a, b), Math.max(a, b));\n\n\t\t}\n\n\n\n\t\tflow = 0;\n\n\t\tmax_frow(1, n - 1);\n\n\n\n\t\tfor (int i = 0; i < q; i++) {\n\n\n\n\t\t\tif (sc.nextInt() == 1) {\n\n\n\n\t\t\t\tint a = sc.nextInt();\n\n\t\t\t\tint b = sc.nextInt();\n\n\t\t\t\tadd(Math.min(a, b), Math.max(a, b));\n\n\t\t\t\tmax_frow_c1(1, n - 1);\n\n\t\t\t} else {\n\n\n\n\t\t\t\tremove(sc.nextInt(), sc.nextInt());\n\n\t\t\t}\n\n\n\n\t\t\tSystem.out.println(flow);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid remove(int from, int to) {\n\n/*\n\n\t\t{\n\n\t\t\tint pos = Collections.binarySearch(g[from], new Edge(to, 0));\n\n\t\t\tEdge e = g[from].get(pos);\n\n\t\t\tremove(from, to, e);\n\n\t\t\tg[from].remove(pos);\n\n\t\t}\n\n\t\t{\n\n\t\t\tint pos = Collections.binarySearch(g[to], new Edge(from, 0));\n\n\t\t\tEdge e = g[to].get(pos);\n\n\t\t\tremove(to, from, e);\n\n\t\t\tg[to].remove(pos);\n\n\t\t}\n\n\t\t*/\n\n\t\tfor (Edge e : g[from]) {\n\n\n\n\t\t\tif (e.to == to) {\n\n\n\n\t\t\t\tremove(from, to, e);\n\n\t\t\t\tremove(to, from, e.rev);\n\n\n\n\t\t\t\tg[from].remove(e);\n\n\t\t\t\tg[to].remove(e.rev);\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\tvoid remove(int from, int to, Edge e) {\n\n\n\n\t\tif (e.cap == 0) {\n\n\n\n\t\t\tArrays.fill(used, false);\n\n\t\t\tif (dfs(from, to, 1) == 0) {\n\n\t\t\t\tArrays.fill(used, false);\n\n\t\t\t\tdfs(n - 1, 1, 1);\n\n\t\t\t\tif (e.cap == 0) {\n\n\t\t\t\t\tArrays.fill(used, false);\n\n\t\t\t\t\tdfs_desc(from, to, 1);\n\n\t\t\t\t\te.cap = 1;\n\n\t\t\t\t\te.rev.cap = 1;\n\n\t\t\t\t}\n\n\t\t\t\tflow--;\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\n\n\t}\n\n\n\n\tvoid max_frow_c1(int s, int t) {\n\n\n\n\t\tArrays.fill(used, false);\n\n\t\tif (s > t) {\n\n\t\t\tflow += dfs(s, t, INF);\n\n\t\t} else {\n\n\t\t\tflow += dfs_desc(s, t, INF);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid max_frow(int s, int t) {\n\n\n\n\t\tfor (int f = 1; f != 0; flow += f) {\n\n\n\n\t\t\tArrays.fill(used, false);\n\n\t\t\tif (s > t) {\n\n\t\t\t\tf = dfs(s, t, INF);\n\n\t\t\t} else {\n\n\t\t\t\tf = dfs_desc(s, t, INF);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\tint dfs_desc(int v, int t, int f) {\n\n\t\tif (v == t)\n\n\t\t\treturn f;\n\n\t\tused[v] = true;\n\n\t\tEdge e = null;\n\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\n\t\t\te = g[v].get(g[v].size() - i - 1);\n\n\n\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\n\n\n\t\t\t\tint d = 0;\n\n\t\t\t\tif (e.to > t) {\n\n\t\t\t\t\td = dfs(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t} else {\n\n\t\t\t\t\td = dfs_desc(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t}\n\n\n\n\t\t\t\t// int d = dfs(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\tif (d > 0) {\n\n\n\n\t\t\t\t\te.cap -= d;\n\n\t\t\t\t\te.rev.cap += d;\n\n\t\t\t\t\treturn d;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tint dfs(int v, int t, int f) {\n\n\t\tif (v == t)\n\n\t\t\treturn f;\n\n\t\tused[v] = true;\n\n\t\tEdge e = null;\n\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\n\t\t\te = g[v].get(i);\n\n\n\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\n\n\n\t\t\t\tint d = 0;\n\n\t\t\t\tif (e.to > t) {\n\n\t\t\t\t\td = dfs(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t} else {\n\n\t\t\t\t\td = dfs_desc(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t}\n\n\n\n\t\t\t\tif (d > 0) {\n\n\n\n\t\t\t\t\te.cap -= d;\n\n\t\t\t\t\te.rev.cap += d;\n\n\t\t\t\t\treturn d;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tvoid add(int from, int to) {\n\n\t\tEdge e = new Edge(to, 1), rev = new Edge(from, 1);\n\n\n\n\t\te.rev = rev;\n\n\t\trev.rev = e;\n\n\n\n\t\tint pos = Collections.binarySearch(g[from], e);\n\n\t\tg[from].add(~pos, e);\n\n\n\n\t\tpos = Collections.binarySearch(g[to], rev);\n\n\t\tg[to].add(~pos, rev);\n\n\t\t// g[to].addFirst(rev);\n\n\t}\n\n\n\n\tclass Edge implements Comparable<Edge> {\n\n\t\tint to, cap;\n\n\t\tEdge rev;\n\n\n\n\t\tpublic Edge(int to, int cap) {\n\n\n\n\t\t\tthis.to = to;\n\n\t\t\tthis.cap = cap;\n\n\t\t}\n\n\n\n\t\tpublic int compareTo(Edge tar) {\n\n\t\t\treturn this.to - tar.to;\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joinet\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tif (maxflow == 0) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tArrays.fill(flow[j], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\t\t\tint tmp = A;\n\t\t\t\t\t\t\tA = B;\n\t\t\t\t\t\t\tB = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\t\tflow[B][A] = 0;\n\t\t\t\t\t\tInteger[] prev_v1 = dfs(B, N - 1, true);\n\t\t\t\t\t\tInteger[] prev_v2 = dfs(0, A, true);\n\t\t\t\t\t\tif ((prev_v1[N - 1] != -1 || B == N - 1) && (A == 0 || prev_v2[A] != -1)) {\n\t\t\t\t\t\t\tmaxflow--;\n\t\t\t\t\t\t\tif (B != N - 1) {\n\t\t\t\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v1[j]) {\n\t\t\t\t\t\t\t\t\tset_flow(prev_v1[j], j, -1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (A != 0) {\n\t\t\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v2[j]) {\n\t\t\t\t\t\t\t\t\tset_flow(prev_v2[j], j, -1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(\"!\");\n\t\t\t\t\t\t\tInteger[] prev_v = dfs(B, A, true);\n\t\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\t\t\tif (prev_v[j] == -1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joinet\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tif (maxflow == 0) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tArrays.fill(flow[j], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\t\t\tint tmp = A;\n\t\t\t\t\t\t\tA = B;\n\t\t\t\t\t\t\tB = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\t\tflow[B][A] = 0;\n\t\t\t\t\t\t// ?->A->B->? loop??????????????????????????????\n\t\t\t\t\t\tInteger[] prev_v1 = dfs(B, N - 1, true);\n\t\t\t\t\t\tInteger[] prev_v2 = dfs(0, A, true);\n\t\t\t\t\t\tif (prev_v1[N - 1] != -1 && prev_v2[A] != -1) {\n\t\t\t\t\t\t\tmaxflow--;\n\t\t\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v1[j]) {\n\t\t\t\t\t\t\t\tset_flow(prev_v1[j], j, -1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v2[j]) {\n\t\t\t\t\t\t\t\tset_flow(prev_v2[j], j, -1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] prev_v = dfs(B, A, true);\n\t\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\t\t\tif(prev_v[j]==-1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joinet\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\t\tint tmp = A;\n\t\t\t\t\t\tA = B;\n\t\t\t\t\t\tB = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\tflow[B][A] = 0;\n\t\t\t\t\tmaxflow--;\n\n\n\t\t\t\t\tif (maxflow == 0) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tArrays.fill(flow[j], 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tInteger[] prev_v = dfs(B, N - 1, true);\n\t\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v[j]) {\n\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev_v = dfs(0, A, true);\n\t\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint[][] flow;\n\tboolean[][] g;\n\tint N;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tg = new boolean[N][N];\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint F = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\tg[F][T] = true;\n\t\t\tg[T][F] = true;\n\t\t}\n\t\tflow = new int[N][N];\n\n\t\tint maxflow = 0;\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint M = sc.nextInt();\n\t\t\tint A = sc.nextInt() - 1;\n\t\t\tint B = sc.nextInt() - 1;\n\t\t\tif (M == 1) {// joint\n\t\t\t\tg[A][B] = true;\n\t\t\t\tg[B][A] = true;\n\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t} else if (M == 2) { // disjoint\n\t\t\t\tif (flow[A][B] < 0) {\n\t\t\t\t\tint tmp = A;\n\t\t\t\t\tA = B;\n\t\t\t\t\tB = tmp;\n\t\t\t\t}\n\t\t\t\tg[A][B] = false;\n\t\t\t\tg[B][A] = false;\n\t\t\t\tif (flow[A][B] != 0) {\n\t\t\t\t\tflow[A][B] = 0;\n\t\t\t\t\tflow[B][A] = 0;\n\n\t\t\t\t\tmaxflow--;\n\t\t\t\t\tInteger[] prev_v = dfs(B, N - 1, true);\n\t\t\t\t\tfor (int j = N - 1; j != B; j = prev_v[j]) {\n\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t}\n\t\t\t\t\tprev_v = dfs(0, A, true);\n\t\t\t\t\tfor (int j = A; j != 0; j = prev_v[j]) {\n\t\t\t\t\t\tset_flow(prev_v[j], j, -1);\n\t\t\t\t\t}\n\t\t\t\t\tmaxflow = calc_maxflow(maxflow);\n\t\t\t\t} else {\n\t\t\t\t\tg[A][B] = false;\n\t\t\t\t\tg[B][A] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxflow);\n\t\t}\n\n\t}\n\n\tint calc_maxflow(int maxflow) {\n\t\twhile (true) {\n\t\t\tInteger[] prev_v = dfs(0, N - 1, false);\n\t\t\tif (prev_v[N - 1] == -1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tmaxflow++;\n\t\t\t\tfor (int i = N - 1; i != 0; i = prev_v[i]) {\n\t\t\t\t\tset_flow(prev_v[i], i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid set_flow(int src, int dst, int delta) {\n\t\tflow[src][dst] += delta;\n\t\tflow[dst][src] -= delta;\n\t}\n\n\tint residue(int src, int dst) {\n\t\tif (!g[src][dst])\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1 - flow[src][dst];\n\t}\n\n\tInteger[] dfs(int s, int t, boolean onflow) {\n\t\tBoolean[] arrived = new Boolean[N];\n\t\tArrays.fill(arrived, false);\n\t\tInteger[] prev_v = new Integer[N];\n\t\tArrays.fill(prev_v, -1);\n\t\tcalc_dfs(t, s, prev_v, arrived, onflow);\n\t\treturn prev_v;\n\t}\n\n\tboolean calc_dfs(int t, int cur, Integer[] prev_v, Boolean[] arrived, boolean onflow) {\n\t\tarrived[cur] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!arrived[i] && g[cur][i] && ((!onflow && residue(cur, i) > 0) || (onflow && flow[cur][i] > 0))) {\n\t\t\t\tprev_v[i] = cur;\n\t\t\t\tif (i == t)\n\t\t\t\t\treturn true;\n\t\t\t\tif (calc_dfs(t, i, prev_v, arrived, onflow))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.io.*;\n\nimport java.math.*;\n\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint n, e, q;\n\n\tLinkedList<Edge>[] g;\n\n\tint flow;\n\n\tboolean used[];\n\n\n\n\tint INF = Integer.MAX_VALUE >> 4;\n\n\n\n\tvoid run() {\n\n\n\n\t\tn = sc.nextInt();\n\n\t\te = sc.nextInt();\n\n\t\tq = sc.nextInt();\n\n\t\tn++;\n\n\n\n\t\tg = new LinkedList[n];\n\n\t\tused = new boolean[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\n\n\t\t\tg[i] = new LinkedList<Edge>();\n\n\t\t}\n\n\n\n\t\tfor (int i = 0; i < e; i++) {\n\n\n\n\t\t\tint a = sc.nextInt();\n\n\t\t\tint b = sc.nextInt();\n\n\t\t\tadd(Math.min(a, b), Math.max(a, b));\n\n\t\t}\n\n\n\n\t\tflow = 0;\n\n\t\tmax_frow(1, n - 1);\n\n\n\n\t\tfor (int i = 0; i < q; i++) {\n\n\n\n\t\t\tif (sc.nextInt() == 1) {\n\n\n\n\t\t\t\tint a = sc.nextInt();\n\n\t\t\t\tint b = sc.nextInt();\n\n\t\t\t\tadd(Math.min(a, b), Math.max(a, b));\n\n\t\t\t\tmax_frow_c1(1, n - 1);\n\n\t\t\t} else {\n\n\n\n\t\t\t\tremove(sc.nextInt(), sc.nextInt());\n\n\t\t\t}\n\n\n\n\t\t\tSystem.out.println(flow);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid remove(int from, int to) {\n\n/*\n\n\t\t{\n\n\t\t\tint pos = Collections.binarySearch(g[from], new Edge(to, 0));\n\n\t\t\tEdge e = g[from].get(pos);\n\n\t\t\tremove(from, to, e);\n\n\t\t\tg[from].remove(pos);\n\n\t\t}\n\n\t\t{\n\n\t\t\tint pos = Collections.binarySearch(g[to], new Edge(from, 0));\n\n\t\t\tEdge e = g[to].get(pos);\n\n\t\t\tremove(to, from, e);\n\n\t\t\tg[to].remove(pos);\n\n\t\t}\n\n\t\t*/\n\n\t\tfor (Edge e : g[from]) {\n\n\n\n\t\t\tif (e.to == to) {\n\n\n\n\t\t\t\tremove(from, to, e);\n\n\t\t\t\tremove(to, from, e.rev);\n\n\n\n\t\t\t\tg[from].remove(e);\n\n\t\t\t\tg[to].remove(e.rev);\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\tvoid remove(int from, int to, Edge e) {\n\n\n\n\t\tif (e.cap == 0) {\n\n\n\n\t\t\tArrays.fill(used, false);\n\n\t\t\tif (dfs(from, to, 1) == 0) {\n\n\t\t\t\tArrays.fill(used, false);\n\n\t\t\t\tdfs(n - 1, 1, 1);\n\n\t\t\t\tif (e.cap == 0) {\n\n\t\t\t\t\tArrays.fill(used, false);\n\n\t\t\t\t\tdfs_desc(from, to, 1);\n\n\t\t\t\t\te.cap = 1;\n\n\t\t\t\t\te.rev.cap = 1;\n\n\t\t\t\t}\n\n\t\t\t\tflow--;\n\n\t\t\t}\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\n\n\t}\n\n\n\n\tvoid max_frow_c1(int s, int t) {\n\n\n\n\t\tArrays.fill(used, false);\n\n\t\tif (s > t) {\n\n\t\t\tflow += dfs(s, t, INF);\n\n\t\t} else {\n\n\t\t\tflow += dfs_desc(s, t, INF);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid max_frow(int s, int t) {\n\n\n\n\t\tfor (int f = 1; f != 0; flow += f) {\n\n\n\n\t\t\tArrays.fill(used, false);\n\n\t\t\tif (s > t) {\n\n\t\t\t\tf = dfs(s, t, INF);\n\n\t\t\t} else {\n\n\t\t\t\tf = dfs_desc(s, t, INF);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\tint dfs_desc(int v, int t, int f) {\n\n\t\tif (v == t)\n\n\t\t\treturn f;\n\n\t\tused[v] = true;\n\n\t\tEdge e = null;\n\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\n\t\t\te = g[v].get(g[v].size() - i - 1);\n\n\n\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\n\n\n\t\t\t\tint d = 0;\n\n\t\t\t\tif (e.to > t) {\n\n\t\t\t\t\td = dfs(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t} else {\n\n\t\t\t\t\td = dfs_desc(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t}\n\n\n\n\t\t\t\t// int d = dfs(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\tif (d > 0) {\n\n\n\n\t\t\t\t\te.cap -= d;\n\n\t\t\t\t\te.rev.cap += d;\n\n\t\t\t\t\treturn d;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tint dfs(int v, int t, int f) {\n\n\t\tif (v == t)\n\n\t\t\treturn f;\n\n\t\tused[v] = true;\n\n\t\tEdge e = null;\n\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\n\t\t\te = g[v].get(i);\n\n\n\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\n\n\n\t\t\t\tint d = 0;\n\n\t\t\t\tif (e.to > t) {\n\n\t\t\t\t\td = dfs(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t} else {\n\n\t\t\t\t\td = dfs_desc(e.to, t, Math.min(f, e.cap));\n\n\t\t\t\t}\n\n\n\n\t\t\t\tif (d > 0) {\n\n\n\n\t\t\t\t\te.cap -= d;\n\n\t\t\t\t\te.rev.cap += d;\n\n\t\t\t\t\treturn d;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tvoid add(int from, int to) {\n\n\t\tEdge e = new Edge(to, 1), rev = new Edge(from, 1);\n\n\n\n\t\te.rev = rev;\n\n\t\trev.rev = e;\n\n\n\n\t\tint pos = Collections.binarySearch(g[from], e);\n\n\t\tg[from].add(~pos, e);\n\n\n\n\t\tpos = Collections.binarySearch(g[to], rev);\n\n\t\tg[to].add(~pos, rev);\n\n\t\t// g[to].addFirst(rev);\n\n\t}\n\n\n\n\tclass Edge implements Comparable<Edge> {\n\n\t\tint to, cap;\n\n\t\tEdge rev;\n\n\n\n\t\tpublic Edge(int to, int cap) {\n\n\n\n\t\t\tthis.to = to;\n\n\t\t\tthis.cap = cap;\n\n\t\t}\n\n\n\n\t\tpublic int compareTo(Edge tar) {\n\n\t\t\treturn this.to - tar.to;\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var q = sc.Integer();\n            var es = new Pair<int, int>[m + q];\n            var E = new Pair<int, int>[m];\n            var A = new int[q];\n            var Q = new Pair<int, int>[q];\n            for (int i = 0; i < m; i++)\n            {\n                var f = sc.Integer() - 1;\n                var t = sc.Integer() - 1;\n                if (f > t) Swap(ref f, ref t);\n                E[i] = Pair.Create(f, t);\n                es[i] = Pair.Create(f, t);\n\n            }\n            for (int i = 0; i < q; i++)\n            {\n                var a = sc.Integer();\n                var f = sc.Integer() - 1;\n                var t = sc.Integer() - 1;\n                if (f > t) Swap(ref f, ref t);\n                es[m + i] = Pair.Create(f, t);\n                A[i] = a;\n                Q[i] = Pair.Create(f, t);\n            }\n            es = es.Distinct().ToArray();\n            Array.Sort(es);\n            var sz = es.Length;\n            var pos = new int[sz];\n            for (int i = 0; i < sz; i++)\n                pos[i] = -1;\n            var G = Enumerate(n, x => new List<Edge<int>>());\n            for (int i = 0; i < m; i++)\n            {\n                var p = Array.BinarySearch(es, E[i]);\n                pos[p] = G[es[p].x].Count;\n                G.AddUndirectedEdge(es[p].x, es[p].y, 1);\n            }\n            for (int i = 0; i < q; i++)\n            {\n                if (A[i] == 1)\n                {\n                    var p = Array.BinarySearch(es, Q[i]);\n                    if (pos[p] == -1)\n                    {\n                        pos[p] = G[es[p].x].Count;\n                        G.AddUndirectedEdge(es[p].x, es[p].y, 0);\n                    }\n                }\n            }\n            var H = Enumerate(n, x => G[x].ToArray());\n            var flow = Flow.FordFulkerson(H, 0, n - 1);\n            for (int i = 0; i < q; i++)\n            {\n                if (A[i] == 1)\n                {\n                    var p = Array.BinarySearch(es, Q[i]);\n                    var u = Q[i].x;\n                    var v = Q[i].y;\n                    p = pos[p];\n                    Debug.Assert(H[u][p].cap == 0);\n                    H[u][p].cap = 1;\n                    H[v][H[u][p].rev].cap = 1;\n                    flow += Flow.FordFulkerson(H, 0, n - 1);\n                }\n                else\n                {\n                    var p = Array.BinarySearch(es, Q[i]);\n                    p = pos[p];\n                    var u = Q[i].x;\n                    var v = Q[i].y;\n                    if (H[u][p].cap == 2 && Flow.FordFulkerson(H, v, u, 1) == 0)\n                    {\n                        Flow.FordFulkerson(H, n - 1, 0, 1);\n                        Flow.FordFulkerson(H, v, u, 1);\n                        flow--;\n                    }\n                    else if (H[u][p].cap == 0 && Flow.FordFulkerson(H, u, v, 1) == 0)\n                    {\n                        Flow.FordFulkerson(H, n - 1, 0, 1);\n                        Flow.FordFulkerson(H, u, v, 1);\n                        flow--;\n                    }\n                    //Debug.Assert(H[u][p].cap == 1);\n                    H[Q[i].x][p].cap = 0;\n                    H[Q[i].y][H[Q[i].x][p].rev].cap = 0;\n                }\n                IO.Printer.Out.WriteLine(flow);\n            }\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer : StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region Edge\npublic struct Edge<T>\n{\n    public int to, rev;\n    public T cap;\n    public Edge(int t, int r, T _cap) { to = t; rev = r; cap = _cap; }\n    public override string ToString() { return string.Format(\"{0}: Capacity {1}\", to, cap); }\n}\n#endregion\n#region AddEdge\nstatic public partial class Flow\n{\n    static public void AddDirectedEdge(this List<Edge<int>>[] G, int from, int to, int cap)\n    {\n        G[from].Add(new Edge<int>(to, G[to].Count, cap));\n        G[to].Add(new Edge<int>(from, G[from].Count - 1, 0));\n    }\n    static public void AddUndirectedEdge(this List<Edge<int>>[] G, int from, int to, int cap)\n    {\n        G[from].Add(new Edge<int>(to, G[to].Count, cap));\n        G[to].Add(new Edge<int>(from, G[from].Count - 1, cap));\n    }\n    static public void AddDirectedEdge(this List<Edge<long>>[] G, int from, int to, long cap)\n    {\n        G[from].Add(new Edge<long>(to, G[to].Count, cap));\n        G[to].Add(new Edge<long>(from, G[from].Count - 1, 0));\n    }\n    static public void AddUndirectedEdge(this List<Edge<long>>[] G, int from, int to, long cap)\n    {\n        G[from].Add(new Edge<long>(to, G[to].Count, cap));\n        G[to].Add(new Edge<long>(from, G[from].Count - 1, cap));\n    }\n}\n#endregion\n\n#region Compair\nstatic public class Pair\n{\n    static public Pair<FT, ST> Create<FT, ST>(FT f, ST s)\n        where FT : IComparable<FT>\n        where ST : IComparable<ST>\n    { return new Pair<FT, ST>(f, s); }\n    static public Pair<FT, ST> Min<FT, ST>(Pair<FT, ST> p, Pair<FT, ST> q)\n        where FT : IComparable<FT>\n        where ST : IComparable<ST>\n    { return (p.CompareTo(q) <= 0) ? p : q; }\n    static public Pair<FT, ST> Max<FT, ST>(Pair<FT, ST> p, Pair<FT, ST> q)\n        where FT : IComparable<FT>\n        where ST : IComparable<ST>\n    { return (p.CompareTo(q) >= 0) ? p : q; }\n}\npublic struct Pair<FT, ST> : IComparable<Pair<FT, ST>>\n    where FT : IComparable<FT>\n    where ST : IComparable<ST>\n{\n    public FT x;\n    public ST y;\n    public Pair(FT f, ST s) : this() { x = f; y = s; }\n\n    public int CompareTo(Pair<FT, ST> other)\n    {\n        var cmp = x.CompareTo(other.x);\n        return cmp != 0 ? cmp : y.CompareTo(other.y);\n    }\n    public override string ToString() { return string.Format(\"{0} {1}\", x, y); }\n}\n#endregion\n#region Ford-Fulkerson\nstatic public partial class Flow\n{\n    /// <summary>return Max Flow O(|F||E|)</summary>\n    static public int FordFulkerson(Edge<int>[][] G, int s, int t, int INF = -1)\n    {\n        var used = new bool[G.Length];\n        Func<int, int, int, int> dfs = null;\n        dfs = (v, u, f) =>\n        {\n            if (v == u) return f;\n            used[v] = true;\n            for (int i = 0; i < G[v].Length; i++)\n                if (!used[G[v][i].to] && G[v][i].cap > 0)\n                {\n                    var d = dfs(G[v][i].to, u, Math.Min(f, G[v][i].cap));\n                    if (d <= 0) continue;\n                    G[v][i].cap -= d;\n                    G[G[v][i].to][G[v][i].rev].cap += d;\n                    return d;\n                }\n            return 0;\n        };\n        var flow = 0;\n        if (INF == -1)\n        {\n            while (true)\n            {\n                Array.Clear(used, 0, used.Length);\n                var f = dfs(s, t, 1 << 30);\n                if (f == 0) return flow;\n                flow += f;\n            }\n        }\n        else\n        {\n            while (INF > 0)\n            {\n                Array.Clear(used, 0, used.Length);\n                var f = dfs(s, t, INF);\n                if (f == 0) return flow;\n                flow += f;\n                INF -= f;\n\n            }\n            return flow;\n        }\n\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef actual_capacity(from)\n\t\t\tv = @opposite[from]\n\t\t\tcap = @property[:capacity]\n\t\t\tflow = (@property[:flow] ||= 0)\n\t\t\tto = (@property[:flow_to] ||= v)\n\t\t\tto == v ? cap - flow : cap + flow\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_augmenting_path(s, t)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tcomming_edge = {}\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tu.each_edge do |e|\t\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\n\t\t\t\tnext if e.actual_capacity(u) <= 0\n\n\t\t\t\treached << v\n\t\t\t\tcomming_edge[v] = e\n\t\t\t\tqueue << v\n\n\t\t\t\tif v == t\n\t\t\t\t\tqueue = []\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\n\t\tif comming_edge[t]\n\t\t\tpath = [t]\n\t\t\tv = t\n\t\t\tuntil path[-1] == s\n\t\t\t\te = comming_edge[v]\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tpath << e\n\t\t\t\tpath << u\n\t\t\t\tv = u\n\t\t\tend\n\t\t\treturn path.reverse\n\t\tend\n\n\t\treturn nil\n\tend\nend\n\ndef add_flow(df, path)\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\tv = e.opposite[u]\n\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\tend\nend\n\nn, m, q = gets.split.map(&:to_i)\t\ng = Graph.new\nnodes = (0..n).map { g.add_node }\nedges = {}\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1})\n\tedges[[i, j]] = e\nend\n\nflow = 0\nloop do\n\tpath = g.get_augmenting_path(nodes[1], nodes[n])\n\tbreak if !path\n\tadd_flow(1, path)\n\tflow += 1\nend\n\nq.times do\n\tcommand, i, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\tif command == 1\n\t\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1})\n\t\tedges[[i, j]] = e\n\telse\n\t\te = edges[[i, j]]\n\t\tg.del_edge(e)\n\t\tedges.delete([i, j])\n\n\t\tif (e.property[:flow] || 0) != 0\n\t\t\tnodes[i]\n\t\t\tv = e.property[:flow_to]\n\t\t\tif v != nodes[n]\n\t\t\t\tpath = g.get_augmenting_path(nodes[n], v)\n\t\t\t\tadd_flow(1, path)\n\t\t\tend\n\t\t\tu = e.opposite[v]\n\t\t\tif u != nodes[1]\n\t\t\t\tpath = g.get_augmenting_path(u, nodes[1])\n\t\t\t\tadd_flow(1, path)\n\t\t\tend\n\t\t\tflow -= 1\n\t\tend\n\tend\n\n\tif path = g.get_augmenting_path(nodes[1], nodes[n])\n\t\tadd_flow(1, path)\n\t\tflow += 1\n\tend\n\n\tp flow\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef actual_capacity(from)\n\t\t\tv = @opposite[from]\n\t\t\tcap = @property[:capacity]\n\t\t\tflow = @property[:flow]\n\t\t\tto = @property[:flow_to]\n\t\t\tto == v ? cap - flow : cap + flow\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_augmenting_path(s, t)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tcomming_edge = {}\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tu.each_edge do |e|\t\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\n\t\t\t\tnext if e.actual_capacity(u) <= 0\n\n\t\t\t\treached << v\n\t\t\t\tcomming_edge[v] = e\n\t\t\t\tqueue << v\n\n\t\t\t\tif v == t\n\t\t\t\t\tqueue = []\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\n\t\tif comming_edge[t]\n\t\t\tpath = [t]\n\t\t\tv = t\n\t\t\tuntil path[-1] == s\n\t\t\t\te = comming_edge[v]\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tpath << e\n\t\t\t\tpath << u\n\t\t\t\tv = u\n\t\t\tend\n\t\t\treturn path.reverse\n\t\tend\n\n\t\treturn nil\n\tend\nend\n\ndef add_flow(df, path)\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\tv = e.opposite[u]\n\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\tend\nend\n\nn, m, q = gets.split.map(&:to_i)\t\ng = Graph.new\nnodes = (0..n).map { g.add_node }\nedges = {}\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1, :flow => 0, :flow_to => nodes[j]})\n\tedges[[i, j]] = e\nend\n\nflow = 0\nloop do\n\tpath = g.get_augmenting_path(nodes[1], nodes[n])\n\tbreak if !path\n\tadd_flow(1, path)\n\tflow += 1\nend\n\nq.times do\n\tcommand, i, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\tif command == 1\n\t\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1, :flow => 0, :flow_to => nodes[j]})\n\t\tedges[[i, j]] = e\n\telse\n\t\te = edges[[i, j]]\n\t\tif e.property[:flow] > 0\n\t\t\tv = e.property[:flow_to]\n\t\t\tu = e.opposite[v]\n\t\t\tpath = [u, e, v]\n\t\t\tuntil path[-1] == nodes[n]\n\t\t\t\tpath[-1].each_edge do |f|\n\t\t\t\t\tw = f.property[:flow_to]\n\t\t\t\t\tif w != path[-1] && f.property[:flow] > 0\n\t\t\t\t\t\tpath << f\n\t\t\t\t\t\tpath << w\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tuntil path[0] == nodes[1]\n\t\t\t\tpath[0].each_edge do |f|\n\t\t\t\t\tw = f.property[:flow_to]\n\t\t\t\t\tif w == path[0] && f.property[:flow] > 0\n\t\t\t\t\t\tpath.unshift f\n\t\t\t\t\t\tpath.unshift f.opposite[w]\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tadd_flow(1, path.reverse)\n\t\t\tflow -= 1\n\t\t\tg.del_edge(e)\n\t\t\tedges.delete([i, j])\n\t\tend\n\tend\n\n\tif path = g.get_augmenting_path(nodes[1], nodes[n])\n\t\tadd_flow(1, path)\n\t\tflow += 1\n\tend\n\n\tp flow\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef actual_capacity(from)\n\t\t\tv = @opposite[from]\n\t\t\tcap = @property[:capacity]\n\t\t\tflow = @property[:flow]\n\t\t\tto = @property[:flow_to]\n\t\t\tto == v ? cap - flow : cap + flow\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_augmenting_path(s, t)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tcomming_edge = {}\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tu.each_edge do |e|\t\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\n\t\t\t\tnext if e.actual_capacity(u) <= 0\n\n\t\t\t\treached << v\n\t\t\t\tcomming_edge[v] = e\n\t\t\t\tqueue << v\n\n\t\t\t\tif v == t\n\t\t\t\t\tqueue = []\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\n\t\tif comming_edge[t]\n\t\t\tpath = [t]\n\t\t\tv = t\n\t\t\tuntil path[-1] == s\n\t\t\t\te = comming_edge[v]\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tpath << e\n\t\t\t\tpath << u\n\t\t\t\tv = u\n\t\t\tend\n\t\t\treturn path.reverse\n\t\tend\n\n\t\treturn nil\n\tend\nend\n\ndef add_flow(df, path)\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\tv = e.opposite[u]\n\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\tend\nend\n\nn, m, q = gets.split.map(&:to_i)\t\ng = Graph.new\nnodes = (0..n).map { g.add_node }\nedges = {}\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1, :flow => 0, :flow_to => nodes[j]})\n\tedges[[i, j]] = e\nend\n\nflow = 0\nloop do\n\tpath = g.get_augmenting_path(nodes[1], nodes[n])\n\tbreak if !path\n\tadd_flow(1, path)\n\tflow += 1\nend\n\nq.times do\n\tcommand, i, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\tif command == 1\n\t\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1, :flow => 0, :flow_to => nodes[j]})\n\t\tedges[[i, j]] = e\n\telse\n\t\te = edges[[i, j]]\n\t\tif e.property[:flow] > 0\n\t\t\tv = e.property[:flow_to]\n\t\t\tu = e.opposite[v]\n\t\t\tpath = [u, e, v]\n\t\t\tuntil path[-1] == nodes[n]\n\t\t\t\tpath[-1].each_edge do |f|\n\t\t\t\t\tw = f.property[:flow_to]\n\t\t\t\t\tif w != path[-1] && f.property[:flow] > 0\n\t\t\t\t\t\tpath << f\n\t\t\t\t\t\tpath << w\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tuntil path[0] == nodes[1]\n\t\t\t\tpath[0].each_edge do |f|\n\t\t\t\t\tw = f.property[:flow_to]\n\t\t\t\t\tif w == path[0] && f.property[:flow] > 0\n\t\t\t\t\t\tpath.unshift f\n\t\t\t\t\t\tpath.unshift f.opposite[w]\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tadd_flow(1, path.reverse)\n\t\t\tflow -= 1\n\t\tend\n\t\tg.del_edge(e)\n\t\tedges.delete([i, j])\n\tend\n\n\tif path = g.get_augmenting_path(nodes[1], nodes[n])\n\t\tadd_flow(1, path)\n\t\tflow += 1\n\tend\n\n\tp flow\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef actual_capacity(from)\n\t\t\tv = @opposite[from]\n\t\t\tcap = @property[:capacity]\n\t\t\tflow = @property[:flow]\n\t\t\tto = @property[:flow_to]\n\t\t\tto == v ? cap - flow : cap + flow\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_augmenting_path(s, t)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tcomming_edge = {}\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tu.each_edge do |e|\t\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\n\t\t\t\tnext if e.actual_capacity(u) <= 0\n\n\t\t\t\treached << v\n\t\t\t\tcomming_edge[v] = e\n\t\t\t\tqueue << v\n\n\t\t\t\tif v == t\n\t\t\t\t\tqueue = []\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\n\t\tif comming_edge[t]\n\t\t\tpath = [t]\n\t\t\tv = t\n\t\t\tuntil path[-1] == s\n\t\t\t\te = comming_edge[v]\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tpath << e\n\t\t\t\tpath << u\n\t\t\t\tv = u\n\t\t\tend\n\t\t\treturn path.reverse\n\t\tend\n\n\t\treturn nil\n\tend\nend\n\ndef add_flow(df, path)\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\tv = e.opposite[u]\n\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\tend\nend\n\nn, m, q = gets.split.map(&:to_i)\t\ng = Graph.new\nnodes = (0..n).map { g.add_node }\nedges = {}\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1, :flow => 0, :flow_to => nodes[j]})\n\tedges[[i, j]] = e\nend\n\nflow = 0\npaths = []\nloop do\n\tpath = g.get_augmenting_path(nodes[1], nodes[n])\n\tbreak if !path\n\tadd_flow(1, path)\n\tflow += 1\n\tpaths << path\nend\n\nq.times do\n\tcommand, i, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\tif command == 1\n\t\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1, :flow => 0, :flow_to => nodes[j]})\n\t\tedges[[i, j]] = e\n\telse\n\t\te = edges[[i, j]]\n\t\tg.del_edge(e)\n\t\tedges.delete([i, j])\n\n\t\tif (e.property[:flow] || 0) != 0\n\t\t\tnodes[i]\n\t\t\tv = e.property[:flow_to]\n\n\t\t\tcatch(:exit) do\n\t\t\t\tpaths.each do |path|\n\t\t\t\t\tpath[1..-1].each_slice(2) do |f, u|\n\t\t\t\t\t\tif f == e && u == v\n\t\t\t\t\t\t\tadd_flow(1, path.reverse)\n\t\t\t\t\t\t\tpaths.delete(path)\n\t\t\t\t\t\t\tthrow :exit\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tflow -= 1\n\t\tend\n\tend\n\n\tif path = g.get_augmenting_path(nodes[1], nodes[n])\n\t\tadd_flow(1, path)\n\t\tflow += 1\n\t\tpaths << path\n\tend\n\n\tp flow\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef actual_capacity(from)\n\t\t\tv = @opposite[from]\n\t\t\tcap = @property[:capacity]\n\t\t\tflow = (@property[:flow] ||= 0)\n\t\t\tto = (@property[:flow_to] ||= v)\n\t\t\tto == v ? cap - flow : cap + flow\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_augmenting_path(s, t)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tcomming_edge = {}\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tu.each_edge do |e|\t\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\tnext if e.actual_capacity(u) <= 0\n\n\t\t\t\treached << v\n\t\t\t\tcomming_edge[v] = e\n\t\t\t\tqueue << v\n\n\t\t\t\tif v == t\n\t\t\t\t\tqueue = []\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\n\t\tif comming_edge[t]\n\t\t\tpath = [t]\n\t\t\tv = t\n\t\t\tuntil path[0] == s\n\t\t\t\te = comming_edge[v]\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tpath = [u, e, *path]\n\t\t\t\tv = u\n\t\t\tend\n\t\t\treturn path\n\t\tend\n\t\treturn nil\n\tend\nend\n\ndef compute_min(path)\n\tm = Float::INFINITY\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\trest = e.actual_capacity(u)\n\t\tm = rest if rest < m\n\tend\n\tm\nend\n\ndef add_flow(df, path)\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\tv = e.opposite[u]\n\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v \n\t\t\te.property[:flow] += df\n\t\telsif flow >= df\n\t\t\te.property[:flow] -= df\n\t\telse\n\t\t\te.property[:flow_to] = v\n\t\t\te.property[:flow] = df - flow\n\t\tend\n\tend\nend\n\ndef sub_flow(df, path)\n\tpath.each_slice(2) do |u, e|\n\t\tbreak if !e\n\t\tv = e.opposite[u]\n\n\t\tcap = e.property[:capacity]\n\t\tflow = e.property[:flow]\n\t\tto = e.property[:flow_to]\n\n\t\tif to == v && flow >= df\n\t\t\te.property[:flow] -= df\n\t\telsif to == v \n\t\t\te.property[:flow_to] = u\n\t\t\te.property[:flow] = df - flow\n\t\telse\n\t\t\te.property[:flow] += df\n\t\tend\n\tend\nend\n\ndef reachable(s, reached = Set[s])\n\ts.each_edge do |e|\n\t\tv = e.opposite[s]\n\t\tnext if reached.include?(v)\n\t\tnext if e.actual_capacity(s) <= 0\n\n\t\treached << v\n\t\treachable(v, reached)\n\tend\t\n\treached\nend\n\nn, m, q = gets.split.map(&:to_i)\t\ng = Graph.new\nnodes = (0..n).map { g.add_node }\nedges = {}\n\nm.times do\n\ti, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1})\n\tedges[[i, j]] = e\nend\n\npath_through = {}\nflow = 0\nloop do\n\tpath = g.get_augmenting_path(nodes[1], nodes[n])\n\tbreak if !path\n\tpath[1..-1].each_slice(2) do |e, v|\n\t\t(path_through[e] ||= {})[path] = v\n\tend\n\tadd_flow(1, path)\n\tflow += 1\nend\n\nq.times do\n\tcommand, i, j = gets.split.map(&:to_i)\n\ti, j = j, i if j < i\n\tif command == 1\n\t\te = g.add_edge(nodes[i], nodes[j], {:capacity => 1})\n\t\tedges[[i, j]] = e\n\telse\n\t\te = edges[[i, j]]\n\t\tif (e.property[:flow] || 0) != 0\n\t\t\trep = {}\n\t\t\tnum = Hash.new(0)\n\t\t\tpath_through[e].each do |path, to|\n\t\t\t\trep[to] = path\n\t\t\t\tnum[to] += 1\n\t\t\tend\n\t\t\tv = rep.keys.max_by {|k| num[k]}\n\t\t\tsub_flow(1, rep[v])\n\t\t\tflow -= 1\n\t\t\trep[v].each do |f|\n\t\t\t\tnext if f.class == Graph::Node\n\t\t\t\tpath_through[f].delete(rep[v])\n\t\t\tend\n\t\tend\n\t\tg.del_edge(e)\n\t\tedges.delete([i, j])\n\tend\n\n\tif path = g.get_augmenting_path(nodes[1], nodes[n])\n\t\tadd_flow(1, path)\n\t\tflow += 1\n\t\tpath[1..-1].each do |e, v|\n\t\t\t(path_through[e] ||= {})[path] = v\n\t\tend\n\tend\n\n\tp flow\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+9\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Flow():\n    def __init__(self, e, N):\n        self.EE = collections.defaultdict(set)\n        for i in range(N):\n            self.EE[i] |= e[i]\n        self.E = e\n        self.N = N\n        self.nl = list(range(N))\n        self.R = 0\n\n    def max_flow(self, s, t):\n        e = self.E\n        v = None\n\n        def f(c):\n            v[c] = 1\n            if c == t:\n                return 1\n            for i in e[c]:\n                if v[i] is None and f(i):\n                    # print('flow_remove', c, i)\n                    if c in e[i]:\n                        e[c].remove(i)\n                    else:\n                        e[i].add(c)\n                    return 1\n            return\n\n        while True:\n            v = [None] * self.N\n            if f(s) is None:\n                break\n            self.R += 1\n\n        return self.R\n\n    def max_flow_add(self, s, t, u, v):\n        self.E[u].add(v)\n        self.E[v].add(u)\n        self.EE[u].add(v)\n        self.EE[v].add(u)\n        return self.max_flow(s, t)\n\n    def del_path_st(self, u, v, s, t):\n        e = self.E\n        vv = [None] * self.N\n        def f(c):\n            vv[c] = 1\n            if c == v:\n                return 1\n            for i in e[c]:\n                if vv[i] is None and f(i):\n                    # print('flow_remove_st', c, i)\n                    if c in e[i]:\n                        e[c].remove(i)\n                    else:\n                        e[i].add(c)\n                    return 1\n            return\n        if f(u):\n            return\n\n        uu = self.del_path_s(u, s)\n        tt = self.del_path_s(t, v)\n        self.R -= 1\n\n    def del_path_s(self, u, s):\n        e = self.E\n        ee = self.EE\n        v = [None] * self.N\n        def f(c):\n            if v[c]:\n                return\n            v[c] = 1\n            if c == s:\n                return 1\n            for i in e[c]:\n                if c in e[i]:\n                    continue\n                if f(i):\n                    e[i].add(c)\n                    # print('path_s', c, i)\n                    return 1\n            return\n        return f(u)\n\n    def max_flow_del(self, s, t, u, v):\n        e = self.E\n        ee = self.EE\n        ee[u].remove(v)\n        ee[v].remove(u)\n        if v in e[u] and u in e[v]:\n            e[u].remove(v)\n            e[v].remove(u)\n            # print('dele',[sorted(e[i]) for i in range(1,self.N)])\n        elif v in e[u]:\n            e[u].remove(v)\n            self.del_path_st(v, u, s, t)\n            # print('dele',[sorted(e[i]) for i in range(1,self.N)])\n        else:\n            e[v].remove(u)\n            self.del_path_st(u, v, s, t)\n            # print('dele',[sorted(e[i]) for i in range(1,self.N)])\n        return self.max_flow(s, t)\n\n\ndef main():\n    rr = []\n\n    def f(n,e,q):\n        ft = [LI() for _ in range(e)]\n        mab = [LI() for _ in range(q)]\n        e = collections.defaultdict(set)\n        for fi,ti in ft:\n            e[fi].add(ti)\n            e[ti].add(fi)\n        fl = Flow(e, n+1)\n        r = []\n        for m,a,b in mab:\n            # print('mab',m,a,b)\n            if m == 1:\n                r.append(fl.max_flow_add(1,n,a,b))\n            else:\n                r.append(fl.max_flow_del(1,n,a,b))\n            # print('e',[sorted(fl.E[i]) for i in range(1,n+1)])\n            # print('ee',[sorted(fl.EE[i]) for i in range(1,n+1)])\n            # print('r', r[-1])\n        return r\n\n    while 1:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.extend(f(n,m,l))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::{BTreeMap, VecDeque};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nfn set_depth(nodes: &Vec<Vec<i32>>, memo: &mut Vec<i32>) {\n    for i in 1 .. memo.len() {\n        memo[i] = -1;\n    }\n    memo[0] = 0;\n    let mut queue = VecDeque::new();\n    queue.push_back(0);\n    while let Some(c) = queue.pop_front() {\n        if c != nodes.len() - 1 {\n            for next in 0..nodes[c].len() {\n                if nodes[c][next] > 0 && memo[next] == -1 {\n                    memo[next] = memo[c] + 1;\n                    queue.push_back(next);\n                }\n            }\n        }else {\n            break\n        }\n    }\n}\nfn push_flow(current: usize, nodes: &mut Vec<Vec<i32>>, searching: &mut Vec<usize>, depth: &Vec<i32>, min_flow: i32) -> i32 {\n    if current == nodes.len() - 1 {\n        min_flow\n    }else {\n        while searching[current] < nodes[current].len() {\n            if nodes[current][searching[current]] > 0 && depth[searching[current]] != - 1 && depth[searching[current]] > depth[current] {\n                let next = searching[current];\n                let min_flow = min(min_flow, nodes[current][next]);\n                let flow = push_flow(next,  nodes, searching, depth, min_flow);\n                if flow > 0 {\n                    nodes[current][next] -= flow;\n                    nodes[next][current] += flow;\n                    return flow;\n                }\n            }\n            searching[current] += 1;\n        }\n        0\n    }\n}\nfn set_max_flow(nodes: &mut Vec<Vec<i32>>) -> i32 {\n    let mut depth = vec![-1; nodes.len()];\n    let mut searching = vec![0; nodes.len()];\n    let mut has_flow = true;\n    let mut flow = 0;\n    while has_flow {\n        has_flow = false;\n        set_depth(nodes, &mut depth);\n        for i in 0 .. searching.len() {\n            searching[i] = 0;\n        }\n        loop {\n            let f = push_flow(0, nodes, &mut searching, &depth, std::i32::MAX);\n            if f > 0 {\n                flow += f;\n                has_flow = true;\n            }else {\n                break\n            }\n        }\n    }\n    flow\n}\nfn remove_to_goal(current: usize, nodes: &mut Vec<Vec<i32>>) {\n    if current != nodes.len() - 1 {\n        for next in 0..nodes.len() {\n            if nodes[next][current] == 2 {\n                nodes[current][next] = 1;\n                nodes[next][current] = 1;\n                return remove_to_goal(next, nodes)\n            }\n        }\n    }\n}\nfn remove_from_start(current: usize, nodes: &mut Vec<Vec<i32>>) {\n    if current != 0 {\n        for next in 0 .. nodes.len() {\n            if nodes[current][next] == 2 {\n                nodes[current][next] = 1;\n                nodes[next][current] = 1;\n                return remove_from_start(next, nodes);\n            }\n        }\n    }\n}\nfn depth_first_search(current: usize, nodes: &mut Vec<Vec<i32>>, memo: &mut Vec<bool>) -> bool {\n    if current == nodes.len() - 1 {\n        true\n    }else {\n        memo[current] = true;\n        for next in 0 .. nodes.len() {\n            if !memo[next] && nodes[current][next] > 0 && depth_first_search(next, nodes, memo) {\n                nodes[current][next] -= 1;\n                nodes[next][current] += 1;\n                return true\n            }\n        }\n        false\n    }\n}\nfn push_single(nodes: &mut Vec<Vec<i32>>) -> i32 {\n    let mut memo = vec![false; nodes.len()];\n    if depth_first_search(0, nodes, &mut memo) {\n        1\n    }else {\n        0\n    }\n}\nfn remove_flow(nodes: &mut Vec<Vec<i32>>, end_a: usize, end_b: usize) -> i32 {\n    if nodes[end_a][end_b] == 1 && nodes[end_b][end_a] == 1 {\n        nodes[end_a][end_b] = 0;\n        nodes[end_b][end_a] = 0;\n        0\n    }else {\n        if nodes[end_a][end_b] == 2 {\n            nodes[end_a][end_b] = 0;\n            nodes[end_b][end_a] = 0;\n            remove_to_goal(end_a, nodes);\n            remove_from_start(end_b, nodes);\n            push_single(nodes) - 1\n        }else {\n            nodes[end_a][end_b] = 0;\n            nodes[end_b][end_a] = 0;\n            remove_to_goal(end_b, nodes);\n            remove_from_start(end_a, nodes);\n            push_single(nodes) - 1\n        }\n    }\n}\nfn add_flow(nodes: &mut Vec<Vec<i32>>, end_a: usize, end_b: usize) -> i32 {\n    nodes[end_a][end_b] = 1;\n    nodes[end_b][end_a] = 1;\n    push_single(nodes)\n}\nfn main() {\n    let_all!(n: usize, e: usize, q: usize);\n    let mut network = vec![vec![0; n]; n];\n    for _ in 0 .. e {\n        let_all!(f: usize, t: usize);\n        network[f - 1][t - 1] = 1;\n        network[t - 1][f - 1] = 1;\n    }\n    let mut flow = set_max_flow(&mut network);\n    for i in 0 .. q {\n        let_all!(m: usize, a: usize, b: usize);\n        match m {\n            1 => {\n                add_flow(&mut network, a - 1, b - 1)\n            }\n            2 => {\n                remove_flow(&mut network, a - 1, b - 1)\n            }\n            _ => unreachable!()\n        };\n        flow = 0;\n        for i in 0 .. network.len() {\n            if network[n - 1][i] == 2 {\n                flow += 1;\n            }\n        }\n        println!(\"{}\", flow);\n    }\n}\n"
  }
]