[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 100000\n\ntypedef struct {\n    int parent;\n    int size;\n} DSU;\n\nDSU dsu[MAXN + 1];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        dsu[i].parent = i;\n        dsu[i].size = 1;\n    }\n}\n\nint find(int u) {\n    if (dsu[u].parent != u) {\n        dsu[u].parent = find(dsu[u].parent);\n    }\n    return dsu[u].parent;\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (dsu[u].size < dsu[v].size) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    dsu[v].parent = u;\n    dsu[u].size += dsu[v].size;\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    init(N);\n    \n    int video_site = 1;\n    int witch_computer = N;\n    \n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        union_sets(a, b);\n    }\n    \n    int current_speed = dsu[find(video_site)].size == dsu[find(witch_computer)].size ? dsu[find(video_site)].size - 1 : 0;\n    printf(\"%d\\n\", current_speed);\n    \n    for (int i = 0; i < Q; i++) {\n        int c, d;\n        scanf(\"%d %d\", &c, &d);\n        int root_c = find(c);\n        int root_d = find(d);\n        if (root_c != root_d) {\n            int root_video = find(video_site);\n            int root_witch = find(witch_computer);\n            int was_connected = (root_video == root_witch);\n            int video_size = dsu[root_video].size;\n            int witch_size = dsu[root_witch].size;\n            \n            union_sets(c, d);\n            \n            int new_root_video = find(video_site);\n            int new_root_witch = find(witch_computer);\n            int is_connected = (new_root_video == new_root_witch);\n            \n            if (!was_connected && is_connected) {\n                current_speed = dsu[new_root_video].size - 1;\n            } else if (was_connected && is_connected) {\n                if (dsu[new_root_video].size > video_size || dsu[new_root_video].size > witch_size) {\n                    current_speed = dsu[new_root_video].size - 1;\n                }\n            }\n        }\n        printf(\"%d\\n\", current_speed);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> dist;\n\nvoid bfs(int start) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    adj.resize(N);\n    dist.resize(N, -1);\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    bfs(0);\n\n    while (Q--) {\n        int c, d;\n        cin >> c >> d;\n        c--; d--;\n        adj[c].push_back(d);\n        adj[d].push_back(c);\n        if (dist[c] != -1 && (dist[d] == -1 || dist[d] > dist[c] + 1)) {\n            dist[d] = dist[c] + 1;\n            queue<int> q;\n            q.push(d);\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : adj[u]) {\n                    if (dist[v] == -1 || dist[v] > dist[u] + 1) {\n                        dist[v] = dist[u] + 1;\n                        q.push(v);\n                    }\n                }\n            }\n        } else if (dist[d] != -1 && (dist[c] == -1 || dist[c] > dist[d] + 1)) {\n            dist[c] = dist[d] + 1;\n            queue<int> q;\n            q.push(c);\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : adj[u]) {\n                    if (dist[v] == -1 || dist[v] > dist[u] + 1) {\n                        dist[v] = dist[u] + 1;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        cout << dist[N - 1] << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private int[] size;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (size[rootX] < size[rootY]) {\n                parent[rootX] = rootY;\n                size[rootY] += size[rootX];\n            } else {\n                parent[rootY] = rootX;\n                size[rootX] += size[rootY];\n            }\n        }\n    }\n\n    public int getSize(int x) {\n        return size[find(x)];\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int Q = scanner.nextInt();\n\n        UnionFind uf = new UnionFind(N);\n        int videoSite = 0;\n        int witchComputer = N - 1;\n\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            uf.union(a, b);\n        }\n\n        int initialSpeed = uf.find(videoSite) == uf.find(witchComputer) ? uf.getSize(videoSite) - 1 : 0;\n        System.out.println(initialSpeed);\n\n        for (int i = 0; i < Q; i++) {\n            int c = scanner.nextInt() - 1;\n            int d = scanner.nextInt() - 1;\n            uf.union(c, d);\n            int speed = uf.find(videoSite) == uf.find(witchComputer) ? uf.getSize(videoSite) - 1 : 0;\n            System.out.println(speed);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:25:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class MaxFlow {\n    static class Edge {\n        int to, capacity, flow;\n        Edge reverse;\n\n        Edge(int to, int capacity) {\n            this.to = to;\n            this.capacity = capacity;\n            this.flow = 0;\n        }\n    }\n\n    static class Graph {\n        int n;\n        List<List<Edge>> adj;\n\n        Graph(int n) {\n            this.n = n;\n            adj = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                adj.add(new ArrayList<>());\n            }\n        }\n\n        void addEdge(int from, int to, int capacity) {\n            Edge forward = new Edge(to, capacity);\n            Edge backward = new Edge(from, 0);\n            forward.reverse = backward;\n            backward.reverse = forward;\n            adj.get(from).add(forward);\n            adj.get(to).add(backward);\n        }\n\n        int maxFlow(int source, int sink) {\n            int totalFlow = 0;\n            while (true) {\n                int[] parent = new int[n];\n                Edge[] parentEdge = new Edge[n];\n                Arrays.fill(parent, -1);\n                Queue<Integer> queue = new LinkedList<>();\n                queue.offer(source);\n                parent[source] = source;\n\n                while (!queue.isEmpty()) {\n                    int current = queue.poll();\n                    if (current == sink) break;\n\n                    for (Edge edge : adj.get(current)) {\n                        int next = edge.to;\n                        if (parent[next] == -1 && edge.capacity > edge.flow) {\n                            queue.offer(next);\n                            parent[next] = current;\n                            parentEdge[next] = edge;\n                        }\n                    }\n                }\n\n                if (parent[sink] == -1) break;\n\n                int flowAmount = Integer.MAX_VALUE;\n                for (int node = sink; node != source; node = parent[node]) {\n                    flowAmount = Math.min(flowAmount, parentEdge[node].capacity - parentEdge[node].flow);\n                }\n\n                for (int node = sink; node != source; node = parent[node]) {\n                    parentEdge[node].flow += flowAmount;\n                    parentEdge[node].reverse.flow -= flowAmount;\n                }\n\n                totalFlow += flowAmount;\n            }\n            return totalFlow;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        int source = 0;\n        int sink = n - 1;\n\n        Graph graph = new Graph(n);\n\n        for (int i = 0; i < m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken()) - 1;\n            int v = Integer.parseInt(st.nextToken()) - 1;\n            graph.addEdge(u, v, 1);\n        }\n\n        bw.write(String.valueOf(graph.maxFlow(source, sink)));\n        bw.flush();\n    }\n}",
    "timestamp": "2025-08-05 21:26:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_NODES 505\n#define INF 1000000000\n\nint network[MAX_NODES][MAX_NODES];\nint source, sink, parent[MAX_NODES];\nint flow[MAX_NODES][MAX_NODES];\n\nbool bfs(int graph[MAX_NODES][MAX_NODES], int s, int t, int n) {\n    bool visited[MAX_NODES] = {false};\n    memset(parent, -1, sizeof(parent));\n    \n    int queue[MAX_NODES], front = 0, rear = 0;\n    queue[rear++] = s;\n    visited[s] = true;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] > 0) {\n                queue[rear++] = v;\n                parent[v] = u;\n                visited[v] = true;\n                \n                if (v == t) return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint ford_fulkerson(int graph[MAX_NODES][MAX_NODES], int s, int t, int n) {\n    int max_flow = 0;\n    memset(flow, 0, sizeof(flow));\n    \n    while (bfs(graph, s, t, n)) {\n        int path_flow = INF;\n        \n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            path_flow = (path_flow < graph[u][v]) ? path_flow : graph[u][v];\n        }\n        \n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            graph[u][v] -= path_flow;\n            graph[v][u] += path_flow;\n            flow[u][v] += path_flow;\n            flow[v][u] -= path_flow;\n        }\n        \n        max_flow += path_flow;\n    }\n    \n    return max_flow;\n}\n\nint main() {\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    \n    source = 0;\n    sink = n - 1;\n    \n    memset(network, 0, sizeof(network));\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        network[u][v] = 1;\n        network[v][u] = 1;\n    }\n    \n    for (int query = 0; query < q; query++) {\n        int type, u, v;\n        scanf(\"%d %d %d\", &type, &u, &v);\n        u--; v--;\n        \n        if (type == 1) {\n            network[u][v]++;\n            network[v][u]++;\n        } else {\n            network[u][v]--;\n            network[v][u]--;\n        }\n        \n        int max_transfer = ford_fulkerson(network, source, sink, n);\n        printf(\"%d\\n\", max_transfer);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nclass NetworkFlow {\nprivate:\n    int n;\n    vector<vector<int>> graph;\n    vector<vector<int>> residual;\n    vector<int> parent;\n\n    bool bfs(int source, int sink) {\n        fill(parent.begin(), parent.end(), -1);\n        queue<int> q;\n        q.push(source);\n        parent[source] = source;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            for (int v = 0; v < n; v++) {\n                if (parent[v] == -1 && residual[u][v] > 0) {\n                    parent[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n\n        return parent[sink] != -1;\n    }\n\n    int fordFulkerson(int source, int sink) {\n        int max_flow = 0;\n        residual = graph;\n\n        while (bfs(source, sink)) {\n            int path_flow = numeric_limits<int>::max();\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                path_flow = min(path_flow, residual[u][v]);\n            }\n\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                residual[u][v] -= path_flow;\n                residual[v][u] += path_flow;\n            }\n\n            max_flow += path_flow;\n        }\n\n        return max_flow;\n    }\n\npublic:\n    NetworkFlow(int nodes) : n(nodes), graph(nodes, vector<int>(nodes, 0)), parent(nodes) {}\n\n    void addEdge(int u, int v, int capacity) {\n        graph[u][v] += capacity;\n        graph[v][u] += capacity;\n    }\n\n    int getMaxFlow(int source, int sink) {\n        return fordFulkerson(source, sink);\n    }\n};\n\nint main() {\n    int nodes, edges, queries;\n    cin >> nodes >> edges >> queries;\n\n    NetworkFlow network(nodes);\n\n    for (int i = 0; i < edges; i++) {\n        int u, v;\n        cin >> u >> v;\n        network.addEdge(u - 1, v - 1, 1);\n    }\n\n    for (int i = 0; i < queries; i++) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int u, v;\n            cin >> u >> v;\n            network.addEdge(u - 1, v - 1, 1);\n        } else if (type == 2) {\n            int u, v;\n            cin >> u >> v;\n            // Remove edge implementation would depend on specific graph representation\n        }\n\n        int transfer_speed = network.getMaxFlow(0, nodes - 1);\n        cout << transfer_speed << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n\n        if rootX != rootY:\n            if self.rank[rootX] < self.rank[rootY]:\n                self.parent[rootX] = rootY\n                self.size[rootY] += self.size[rootX]\n            elif self.rank[rootX] > self.rank[rootY]:\n                self.parent[rootY] = rootX\n                self.size[rootX] += self.size[rootY]\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n                self.size[rootX] += self.size[rootY]\n\nclass WitchNet:\n    def __init__(self, n, video_site, witch_device):\n        self.uf = UnionFind(n)\n        self.video_site = video_site\n        self.witch_device = witch_device\n    \n    def add_connection(self, u, v):\n        self.uf.union(u, v)\n        \n    def transfer_speed(self):\n        return 1 if self.uf.find(self.video_site) == self.uf.find(self.witch_device) else 0\n\ndef process_queries(n, video_site, witch_device, connections, queries):\n    net = WitchNet(n, video_site, witch_device)\n    \n    for u, v in connections:\n        net.add_connection(u, v)\n    \n    results = []\n    for u, v in queries:\n        net.add_connection(u, v)\n        results.append(net.transfer_speed())\n        \n    return results\n\n# Example usage:\nn = 5\nvideo_site = 0\nwitch_device = 4\nconnections = [(0, 1), (1, 2), (2, 3)]\nqueries = [(3, 4), (0, 4)]\nprint(process_queries(n, video_site, witch_device, connections, queries))  # Output: [1, 1]",
    "timestamp": "2025-08-13 06:21:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class InternetSpeed {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt(); // number of devices\n        int m = scanner.nextInt(); // number of initial connections\n        int q = scanner.nextInt(); // number of queries\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        int videoSite = scanner.nextInt() - 1;\n        int witchComputer = scanner.nextInt() - 1;\n\n        for (int i = 0; i < q; i++) {\n            int op = scanner.nextInt();\n            if (op == 1) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                graph.get(u).add(v);\n                graph.get(v).add(u);\n            } else if (op == 2) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                graph.get(u).remove(Integer.valueOf(v));\n                graph.get(v).remove(Integer.valueOf(u));\n            }\n\n            int transferSpeed = bfsMaxFlow(graph, videoSite, witchComputer);\n            System.out.println(transferSpeed);\n        }\n    }\n\n    private static int bfsMaxFlow(List<List<Integer>> graph, int start, int end) {\n        int n = graph.size();\n        boolean[] visited = new boolean[n];\n        Queue<Integer> queue = new LinkedList<>();\n        int[] dist = new int[n];\n\n        queue.add(start);\n        visited[start] = true;\n        dist[start] = Integer.MAX_VALUE;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            if (current == end) {\n                return dist[end];\n            }\n\n            for (int neighbor : graph.get(current)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    dist[neighbor] = Math.min(dist[current], 1);\n                    queue.add(neighbor);\n                }\n            }\n        }\n\n        return 0;\n    }\n}",
    "timestamp": "2025-08-13 06:21:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 1000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_NODES * 2];\nint head[MAX_NODES];\nint edgeCount;\nint visited[MAX_NODES];\nint maxFlow;\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nvoid dfs(int node, int flow) {\n    if (node == 1) { // 1 is the node for Witch's computer\n        if (flow > maxFlow) maxFlow = flow;\n        return;\n    }\n    visited[node] = 1;\n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int next = edges[i].to;\n        if (!visited[next]) {\n            dfs(next, flow + 1);\n        }\n    }\n    visited[node] = 0;\n}\n\nint main() {\n    int n, m, u, v, q;\n\n    // Initialize\n    memset(head, -1, sizeof(head));\n    edgeCount = 0;\n\n    // Read number of nodes, edges and queries\n    scanf(\"%d %d %d\", &n, &m, &q);\n\n    // Read graph\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n    }\n\n    // Process each query\n    for (int i = 0; i < q; i++) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 1) { // Add connection\n            scanf(\"%d %d\", &u, &v);\n            addEdge(u, v);\n            addEdge(v, u);\n        } else if (type == 2) { // Calculate transfer speed\n            memset(visited, 0, sizeof(visited));\n            maxFlow = 0;\n            dfs(0, 0); // 0 is the node for the video site\n            printf(\"%d\\n\", maxFlow);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:21:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class NetworkFlow:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.flow = [[0] * n for _ in range(n)]\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n    \n    def bfs(self, source, sink, parent):\n        visited = [False] * self.n\n        parent[:] = [-1] * self.n\n        queue = []\n        \n        queue.append(source)\n        visited[source] = True\n        \n        while queue:\n            u = queue.pop(0)\n            \n            for v in self.graph[u]:\n                if not visited[v] and self.flow[u][v] < 1:\n                    queue.append(v)\n                    parent[v] = u\n                    visited[v] = True\n                    \n                    if v == sink:\n                        return True\n        \n        return False\n    \n    def max_flow(self, source, sink):\n        parent = [-1] * self.n\n        max_flow = 0\n        \n        while self.bfs(source, sink, parent):\n            path_flow = float('inf')\n            s = sink\n            \n            while s != source:\n                path_flow = min(path_flow, 1 - self.flow[parent[s]][s])\n                s = parent[s]\n            \n            max_flow += path_flow\n            v = sink\n            \n            while v != source:\n                u = parent[v]\n                self.flow[u][v] += path_flow\n                self.flow[v][u] -= path_flow\n                v = parent[v]\n        \n        return max_flow\n\ndef solve(n, queries):\n    nf = NetworkFlow(n)\n    results = []\n    \n    for q in queries:\n        if q[0] == 1:\n            u, v = q[1]-1, q[2]-1\n            nf.add_edge(u, v)\n        \n        flow = nf.max_flow(0, n-1)\n        results.append(flow)\n    \n    return results\n\ndef main():\n    n, q = map(int, input().split())\n    queries = []\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        queries.append(query)\n    \n    results = solve(n, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:21:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(N + 1)]\n    \n    for _ in range(Q):\n        query = input[ptr]\n        ptr += 1\n        if query == '+':\n            u = int(input[ptr])\n            ptr += 1\n            v = int(input[ptr])\n            ptr += 1\n            adj[u].append(v)\n            adj[v].append(u)\n        elif query == '-':\n            u = int(input[ptr])\n            ptr += 1\n            v = int(input[ptr])\n            ptr += 1\n            adj[u].remove(v)\n            adj[v].remove(u)\n        elif query == '?':\n            pass\n        \n        # BFS to find the shortest path (which is the max speed)\n        visited = [-1] * (N + 1)\n        q = deque()\n        q.append(1)\n        visited[1] = 0\n        \n        found = False\n        while q:\n            current = q.popleft()\n            if current == N:\n                found = True\n                break\n            for neighbor in adj[current]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = visited[current] + 1\n                    q.append(neighbor)\n        \n        if found:\n            print(visited[N])\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 06:21:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n// Disjoint set union (DSU) or union-find data structure\nstruct DSU {\n    vector<int> parent, rank;\n    \n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unionSets(int a, int b) {\n        int rootA = find(a);\n        int rootB = find(b);\n        if (rootA != rootB) {\n            if (rank[rootA] < rank[rootB])\n                parent[rootA] = rootB;\n            else if (rank[rootA] > rank[rootB])\n                parent[rootB] = rootA;\n            else {\n                parent[rootB] = rootA;\n                rank[rootA]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n        edges[i].first--;\n        edges[i].second--;\n    }\n\n    vector<pair<int, int>> queries(q);\n    vector<bool> deleteEdge(m, false);\n    for (int i = 0; i < q; ++i) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].second--;\n        if (queries[i].first == 2)\n            deleteEdge[queries[i].second] = true;\n    }\n\n    DSU dsu(n);\n    for (int i = 0; i < m; ++i) {\n        if (!deleteEdge[i]) {\n            dsu.unionSets(edges[i].first, edges[i].second);\n        }\n    }\n\n    vector<int> result(q);\n    for (int i = q - 1; i >= 0; --i) {\n        if (queries[i].first == 1) {\n            int a, b;\n            a = 0; // Assume the video site is node 0\n            b = queries[i].second;\n            result[i] = (dsu.find(a) == dsu.find(b)) ? 1 : 0;\n        } else if (queries[i].first == 2) {\n            dsu.unionSets(edges[queries[i].second].first, edges[queries[i].second].second);\n        }\n    }\n\n    for (int i = 0; i < q; ++i) {\n        if (queries[i].first == 1) {\n            cout << result[i] << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:33"
  }
]