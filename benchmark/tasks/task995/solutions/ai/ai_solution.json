[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MAX_N 200\n#define MAX_S 1000000\n\nbool is_cubic(long long x) {\n    long long cube_root = round(pow(x, 1.0/3));\n    return cube_root * cube_root * cube_root == x;\n}\n\nbool is_valid_subset(int subset[], int subset_size, int nums[]) {\n    for (int i = 0; i < subset_size; i++) {\n        for (int j = i + 1; j < subset_size; j++) {\n            if (is_cubic((long long)nums[subset[i]] * nums[subset[j]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint max_circled_integers(int nums[], int N) {\n    int max_subset = 0;\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        int subset[MAX_N];\n        int subset_size = 0;\n        \n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                subset[subset_size++] = i;\n            }\n        }\n        \n        if (is_valid_subset(subset, subset_size, nums)) {\n            max_subset = (subset_size > max_subset) ? subset_size : max_subset;\n        }\n    }\n    \n    return max_subset;\n}\n\nint main() {\n    int N;\n    int nums[MAX_N];\n    \n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &nums[i]);\n    }\n    \n    printf(\"%d\\n\", max_circled_integers(nums, N));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\ntypedef long long ll;\n\ntypedef struct {\n    ll key;\n    int value;\n} Pair;\n\nPair* map;\nint mapSize = 0;\nint mapCapacity = 0;\n\nvoid initMap() {\n    mapCapacity = 16;\n    map = (Pair*)malloc(mapCapacity * sizeof(Pair));\n    mapSize = 0;\n}\n\nvoid freeMap() {\n    free(map);\n}\n\nvoid insert(ll key, int value) {\n    for (int i = 0; i < mapSize; i++) {\n        if (map[i].key == key) {\n            map[i].value += value;\n            return;\n        }\n    }\n    if (mapSize == mapCapacity) {\n        mapCapacity *= 2;\n        map = (Pair*)realloc(map, mapCapacity * sizeof(Pair));\n    }\n    map[mapSize].key = key;\n    map[mapSize].value = value;\n    mapSize++;\n}\n\nint getValue(ll key) {\n    for (int i = 0; i < mapSize; i++) {\n        if (map[i].key == key) {\n            return map[i].value;\n        }\n    }\n    return 0;\n}\n\nvoid factorize(ll s, ll* factors, int* exponents) {\n    ll temp = s;\n    int idx = 0;\n    for (ll i = 2; i * i <= temp; i++) {\n        if (temp % i == 0) {\n            int cnt = 0;\n            while (temp % i == 0) {\n                temp /= i;\n                cnt++;\n            }\n            factors[idx] = i;\n            exponents[idx] = cnt % 3;\n            if (exponents[idx] != 0) {\n                idx++;\n            }\n        }\n    }\n    if (temp > 1) {\n        factors[idx] = temp;\n        exponents[idx] = 1 % 3;\n        if (exponents[idx] != 0) {\n            idx++;\n        } else {\n            idx--;\n        }\n    }\n    factors[idx] = -1;\n}\n\nll computeKey(ll* factors, int* exponents) {\n    ll key = 1;\n    for (int i = 0; factors[i] != -1; i++) {\n        for (int j = 0; j < exponents[i]; j++) {\n            key *= factors[i];\n        }\n    }\n    return key;\n}\n\nll computeComplementKey(ll* factors, int* exponents) {\n    ll key = 1;\n    for (int i = 0; factors[i] != -1; i++) {\n        int exp = (3 - exponents[i]) % 3;\n        for (int j = 0; j < exp; j++) {\n            key *= factors[i];\n        }\n    }\n    return key;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    ll s[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &s[i]);\n    }\n\n    initMap();\n\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == 1) {\n            insert(1, 1);\n            continue;\n        }\n        ll factors[100];\n        int exponents[100];\n        factorize(s[i], factors, exponents);\n        ll key = computeKey(factors, exponents);\n        ll compKey = computeComplementKey(factors, exponents);\n        insert(key, 1);\n    }\n\n    for (int i = 0; i < mapSize; i++) {\n        ll key = map[i].key;\n        if (key == 1) {\n            res += 1;\n            continue;\n        }\n        ll compKey = 1;\n        ll temp = key;\n        for (ll j = 2; j * j <= temp; j++) {\n            if (temp % j == 0) {\n                int cnt = 0;\n                while (temp % j == 0) {\n                    temp /= j;\n                    cnt++;\n                }\n                int exp = (3 - (cnt % 3)) % 3;\n                for (int k = 0; k < exp; k++) {\n                    compKey *= j;\n                }\n            }\n        }\n        if (temp > 1) {\n            int exp = (3 - (1 % 3)) % 3;\n            for (int k = 0; k < exp; k++) {\n                compKey *= temp;\n            }\n        }\n        if (key < compKey) {\n            int cnt1 = getValue(key);\n            int cnt2 = getValue(compKey);\n            res += (cnt1 > cnt2) ? cnt1 : cnt2;\n        } else if (key == compKey) {\n            res += 1;\n        }\n    }\n\n    printf(\"%d\\n\", res);\n    freeMap();\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\npair<ll, ll> factorize(ll s) {\n    ll a = 1, b = 1;\n    for (ll p = 2; p * p * p <= s; ++p) {\n        if (s % p != 0) continue;\n        int cnt = 0;\n        while (s % p == 0) {\n            s /= p;\n            ++cnt;\n        }\n        cnt %= 3;\n        if (cnt == 1) {\n            a *= p;\n            b *= p * p;\n        } else if (cnt == 2) {\n            a *= p * p;\n            b *= p;\n        }\n    }\n    ll root = sqrt(s);\n    if (root * root == s && s > 1) {\n        a *= s;\n        b *= root;\n    } else if (s > 1) {\n        a *= s;\n        b *= s * s;\n    }\n    return {a, b};\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<ll> s(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> s[i];\n    }\n\n    map<ll, int> freq;\n    for (ll num : s) {\n        pair<ll, ll> p = factorize(num);\n        freq[p.first]++;\n    }\n\n    int res = 0;\n    map<ll, bool> used;\n    for (auto &entry : freq) {\n        ll a = entry.first;\n        ll b = factorize(a).second;\n        if (a == 1) {\n            res += 1;\n            used[a] = true;\n            continue;\n        }\n        if (used[a] || used[b]) continue;\n        if (freq.find(b) != freq.end()) {\n            res += max(entry.second, freq[b]);\n        } else {\n            res += entry.second;\n        }\n        used[a] = true;\n        used[b] = true;\n    }\n\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    static class Pair {\n        long first, second;\n        Pair(long first, long second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long[] s = new long[N];\n        for (int i = 0; i < N; i++) {\n            s[i] = sc.nextLong();\n        }\n\n        Map<Long, Integer> freq = new HashMap<>();\n        for (long num : s) {\n            Pair p = factorize(num);\n            long key = p.first;\n            long complement = p.second;\n            if (key > complement) {\n                key = p.second;\n                complement = p.first;\n            }\n            freq.put(key, freq.getOrDefault(key, 0) + 1);\n        }\n\n        int res = 0;\n        Set<Long> used = new HashSet<>();\n        for (Map.Entry<Long, Integer> entry : freq.entrySet()) {\n            long key = entry.getKey();\n            if (key == 1) {\n                res += 1;\n                used.add(key);\n                continue;\n            }\n            if (used.contains(key)) continue;\n            long complement = getComplement(key);\n            int cntKey = entry.getValue();\n            int cntComp = freq.getOrDefault(complement, 0);\n            res += Math.max(cntKey, cntComp);\n            used.add(key);\n            used.add(complement);\n        }\n        System.out.println(res);\n    }\n\n    static Pair factorize(long num) {\n        long a = 1, b = 1;\n        for (long p = 2; p * p * p <= num; p++) {\n            if (num % p != 0) continue;\n            int cnt = 0;\n            while (num % p == 0) {\n                num /= p;\n                cnt++;\n            }\n            cnt %= 3;\n            if (cnt == 1) {\n                a *= p;\n                b *= p * p;\n            } else if (cnt == 2) {\n                a *= p * p;\n                b *= p;\n            }\n        }\n        long sqrtNum = (long) Math.sqrt(num);\n        if (sqrtNum * sqrtNum == num && num > 1) {\n            a *= num;\n            b *= sqrtNum;\n        } else if (num > 1) {\n            a *= num;\n            b *= num * num;\n        }\n        return new Pair(a, b);\n    }\n\n    static long getComplement(long key) {\n        long complement = 1;\n        long tmp = key;\n        for (long p = 2; p * p * p <= tmp; p++) {\n            if (tmp % p != 0) continue;\n            int cnt = 0;\n            while (tmp % p == 0) {\n                tmp /= p;\n                cnt++;\n            }\n            cnt %= 3;\n            if (cnt == 1) {\n                complement *= p * p;\n            } else if (cnt == 2) {\n                complement *= p;\n            }\n        }\n        long sqrtTmp = (long) Math.sqrt(tmp);\n        if (sqrtTmp * sqrtTmp == tmp && tmp > 1) {\n            complement *= sqrtTmp;\n        } else if (tmp > 1) {\n            complement *= tmp * tmp;\n        }\n        return complement;\n    }\n}",
    "timestamp": "2025-08-05 23:39:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SnukeCircling {\n    public static int maxCircledIntegers(int[] nums) {\n        int n = nums.length;\n        List<Integer> validNums = new ArrayList<>();\n\n        for (int num : nums) {\n            if (isCubeNumberFree(validNums, num)) {\n                validNums.add(num);\n            }\n        }\n\n        return validNums.size();\n    }\n\n    private static boolean isCubeNumberFree(List<Integer> current, int newNum) {\n        for (int existing : current) {\n            long product = (long) existing * newNum;\n            if (isCubeNumber(product)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isCubeNumber(long num) {\n        long cubeRoot = Math.round(Math.pow(num, 1.0 / 3));\n        return cubeRoot * cubeRoot * cubeRoot == num;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 3, 4, 5};\n        System.out.println(maxCircledIntegers(nums));\n    }\n}",
    "timestamp": "2025-08-05 23:39:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nbool isCube(long long n) {\n    long long root = round(pow(n, 1.0/3));\n    return root * root * root == n;\n}\n\nint maxCircledIntegers(vector<int>& nums) {\n    int n = nums.size();\n    vector<vector<bool>> incompatible(n, vector<bool>(n, false));\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (isCube((long long)nums[i] * nums[j])) {\n                incompatible[i][j] = true;\n                incompatible[j][i] = true;\n            }\n        }\n    }\n    \n    int maxCircled = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        bool valid = true;\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                for (int j = i + 1; j < n; j++) {\n                    if ((mask & (1 << j)) && incompatible[i][j]) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (!valid) break;\n            }\n        }\n        \n        if (valid) {\n            int count = __builtin_popcount(mask);\n            maxCircled = max(maxCircled, count);\n        }\n    }\n    \n    return maxCircled;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> nums(N);\n    for (int i = 0; i < N; i++) {\n        cin >> nums[i];\n    }\n    \n    cout << maxCircledIntegers(nums) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:39:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nfrom math import isqrt\n\ndef is_cubic_free(x):\n    # A number is cubic-free if no cube of a prime divides it\n    factor_count = defaultdict(int)\n    n = x\n    for i in range(2, isqrt(n) + 1):\n        while n % i == 0:\n            factor_count[i] += 1\n            n //= i\n    if n > 1:\n        factor_count[n] += 1\n    for prime, count in factor_count.items():\n        if count >= 3:\n            return False\n    return True\n\ndef largest_cubic_free_subset(s):\n    # Group numbers by their cubic-free core\n    def cubic_free_core(x):\n        factor_count = defaultdict(int)\n        n = x\n        for i in range(2, isqrt(n) + 1):\n            while n % i == 0:\n                factor_count[i] += 1\n                n //= i\n        if n > 1:\n            factor_count[n] += 1\n        core = 1\n        for prime, count in factor_count.items():\n            if count % 3 != 0:\n                core *= prime ** (count % 3)\n        return core\n\n    core_count = defaultdict(int)\n    for number in s:\n        core = cubic_free_core(number)\n        if is_cubic_free(core):\n            core_count[core] += 1\n    \n    # Return the maximum frequency of any cubic-free core\n    return max(core_count.values())\n\n# Example usage: \ns = [1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16]\nmax_circled = largest_cubic_free_subset(s)\nprint(max_circled)",
    "timestamp": "2025-08-13 16:26:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SnukeBirthday {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] s = new int[N];\n        for (int i = 0; i < N; i++) {\n            s[i] = scanner.nextInt();\n        }\n        System.out.println(maxCircle(s));\n    }\n\n    private static int maxCircle(int[] s) {\n        int N = s.length;\n        Map<Long, Integer> frequencyMap = new HashMap<>();\n\n        for (int number : s) {\n            long cubeFree = getCubeFree(number);\n            frequencyMap.put(cubeFree, frequencyMap.getOrDefault(cubeFree, 0) + 1);\n        }\n\n        int maxCircleCount = 0;\n        for (int count : frequencyMap.values()) {\n            maxCircleCount += Math.max(count, 1);\n        }\n        \n        return maxCircleCount;\n    }\n\n    private static long getCubeFree(int number) {\n        long result = 1;\n        for (int i = 2; i * i * i <= number; i++) {\n            int power = 0;\n            while (number % i == 0) {\n                number /= i;\n                power++;\n            }\n            if (power % 3 != 0) {\n                result *= Math.pow(i, power % 3);\n            }\n        }\n        if (number > 1) {\n            result *= number;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 16:26:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n// Helper function to check if a number is a perfect cube\nbool isPerfectCube(int x) {\n    int cubeRoot = round(pow(x, 1.0/3.0));\n    return cubeRoot * cubeRoot * cubeRoot == x;\n}\n\n// Function to find maximum number of integers that can be circled\nint findMaxCircled(int* s, int N) {\n    int maxCircle = 0;\n    bool canCircle[N];\n    \n    // Initialize the canCircle array with false\n    for (int i = 0; i < N; i++) {\n        canCircle[i] = true;\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        if (!canCircle[i]) continue;\n        for (int j = i + 1; j < N; ++j) {\n            if (!canCircle[j]) continue;\n            int product = s[i] * s[j];\n            if (isPerfectCube(product)) {\n                canCircle[j] = false;\n            }\n        }\n        maxCircle++;\n    }\n    \n    return maxCircle;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int s[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &s[i]);\n    }\n    \n    int result = findMaxCircled(s, N);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 16:26:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Function to get the canonical representation of a number\nint canonical_rep(int n) {\n    unordered_map<int, int> prime_count;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            prime_count[i]++;\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        prime_count[n]++;\n    }\n    int result = 1;\n    for (auto &[prime, count] : prime_count) {\n        if (count % 3 != 0) {\n            result *= pow(prime, count % 3);\n        }\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> s(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> s[i];\n    }\n\n    unordered_map<int, int> freq;\n    vector<int> keys;\n    for (int i = 0; i < N; ++i) {\n        int rep = canonical_rep(s[i]);\n        if (freq[rep] == 0) {\n            keys.push_back(rep);\n        }\n        freq[rep]++;\n    }\n\n    int max_count = 0;\n    for (auto &key : keys) {\n        max_count = max(max_count, freq[key]);\n    }\n\n    cout << max_count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 16:26:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_cubic(n):\n    cube_root = round(n**(1/3))\n    return cube_root**3 == n\n\ndef max_circled_integers(nums):\n    N = len(nums)\n    \n    def can_circle(subset):\n        for i in range(len(subset)):\n            for j in range(i+1, len(subset)):\n                if is_cubic(subset[i] * subset[j]):\n                    return False\n        return True\n    \n    max_count = 0\n    for mask in range(1, 1 << N):\n        subset = [nums[i] for i in range(N) if mask & (1 << i)]\n        if can_circle(subset):\n            max_count = max(max_count, len(subset))\n    \n    return max_count\n\n# Example usage\nN = int(input())\nnums = list(map(int, input().split()))\nresult = max_circled_integers(nums)\nprint(result)",
    "timestamp": "2025-08-13 16:26:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef factorize(x):\n    factors = {}\n    if x == 1:\n        return factors\n    # Factor out 2s\n    while x % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        x = x // 2\n    # Check odd divisors up to sqrt(x)\n    i = 3\n    max_factor = math.sqrt(x) + 1\n    while i <= max_factor:\n        while x % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            x = x // i\n            max_factor = math.sqrt(x) + 1\n        i += 2\n    if x > 1:\n        factors[x] = factors.get(x, 0) + 1\n    return factors\n\ndef get_key(factors):\n    key = 1\n    complement = 1\n    for p, cnt in factors.items():\n        mod = cnt % 3\n        if mod != 0:\n            key *= p ** mod\n            complement *= p ** (3 - mod)\n    return (key, complement)\n\ndef solve():\n    N = int(sys.stdin.readline())\n    numbers = list(map(int, sys.stdin.readline().split()))\n    count = defaultdict(int)\n    key_map = {}\n    zero_case = False\n    zero_count = 0\n\n    for num in numbers:\n        if num == 1:\n            key = (1, 1)\n            count[key] += 1\n            continue\n        factors = factorize(num)\n        key, complement = get_key(factors)\n        if key == 1 and complement == 1:\n            zero_case = True\n        else:\n            count[key] += 1\n            key_map[key] = complement\n\n    used = set()\n    res = 0\n\n    for key in count:\n        if key in used:\n            continue\n        complement = key_map.get(key, None)\n        if complement is None:\n            res += count[key]\n            used.add(key)\n        else:\n            if complement == key:\n                res += 1\n                used.add(key)\n            else:\n                if complement in count:\n                    res += max(count[key], count[complement])\n                    used.add(key)\n                    used.add(complement)\n                else:\n                    res += count[key]\n                    used.add(key)\n    \n    if zero_case:\n        res += 1\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 16:26:45"
  }
]