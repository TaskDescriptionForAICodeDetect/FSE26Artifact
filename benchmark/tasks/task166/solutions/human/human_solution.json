[
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\ncase class Input(as: List[Int]) {\n  def heightMap = Input.heightMap(this.as)\n  def heightRegions = this.heightMap.toList.sortWith({ case (a, b) => a._1 < b._1 })\n  def solved: Output = {\n    val n = as.length\n    var hasSinked = Array.fill(n)(false)\n    def updateSinked(regions: List[(Int, Int)]): Int = {\n      var d = 0\n      for ((from, to) <- regions) {\n        var k = 1\n        if ((from == 0) || hasSinked(from-1)) k -= 1\n        if ((to == n-1) || hasSinked(to+1)) k -= 1\n        d += k\n        (from to to).foreach(hasSinked(_) = true)\n      }\n      d\n    }\n    var hr = this.heightRegions\n    var m = 1\n    if (hr.head._1 == 0) {\n      m += updateSinked(hr.head._2)\n      hr = hr.tail\n    }\n    var max = m\n    for ((_, rs) <- hr) {\n      val d = updateSinked(rs)\n      m += d\n      max = math.max(m, max)\n    }\n    Output(max)\n  }\n}\n\nobject Input {\n  def mapAux(as: List[Int]): Map[Int, List[Int]] = {\n    val m = scala.collection.mutable.Map[Int,List[Int]]()\n      .withDefaultValue(List())\n    as.zipWithIndex.foreach({ case (a, i) => m(a) = i :: m(a) })\n    m.map({ case (a, l) => (a, l.reverse) }).toMap\n  }\n  def split(l: List[Int]): List[(Int, Int)] = {\n    def aux(prev: Int, from: Int, acc: List[(Int, Int)], l: List[Int]): List[(Int, Int)] = l match {\n      case Nil => (from, prev) :: acc\n      case hd :: tl => if (prev+1 == hd) aux(hd, from, acc, tl)\n                       else aux(hd, hd, (from, prev)::acc, tl)\n    }\n    aux(l.head-1, l.head, Nil, l).reverse\n  }\n  def heightMap(as: List[Int]): Map[Int, List[(Int, Int)]] = {\n    val h2l = mapAux(as)\n    h2l.map({ case (a, l) => (a -> split(l)) })\n  }\n  def fromStdin(): Input = {\n    val sc = new Scanner(System.in)\n    Input(List.fill(sc.nextInt())(sc.nextInt))\n  }\n}\n\ncase class Output(v: Int) {\n  override def toString(): String = {\n    v.toString()\n  }\n\n  def print() = println(this.toString())\n}\n\nobject Main extends App {\n  Input.fromStdin().solved.print()\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P ,ll> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = 998244353;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct UnionFindTree{\n    int N;\n    vector<int> par, rank, siz;\n\n    void init(int n){\n        N = n;\n        par.resize(N);\n        rank.resize(N, 0);\n        siz.resize(N, 1);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    int find(int i){\n        if(par[i] == i) return i;\n        else return par[i] = find(par[i]);\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return ;\n        if(rank[x] < rank[y]) swap(x, y);\n        if(rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y){\n        return find(x) == find(y);\n    }\n    int size(int x){\n        x = find(x);\n        return siz[x];\n    }\n};\n\nll n, a[MAX_N], ans = 0, cnt = 0;\nbool used[MAX_N]{};\n\nint main() {\n    vector<pair<ll,ll> > v;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> a[i];\n        v.push_back({a[i], i+1});\n    }\n    v.push_back({-IINF/2,n+1});\n    sort(v.rbegin(), v.rend());\n    //UnionFindTree g;\n    //g.init(n+5);\n    for(int i=0;i<n;i++){\n        if(v[i].first == 0) break;\n        ll id = v[i].second;\n        used[id] = true;\n        cnt++;\n        if(used[id] && used[id-1]){\n            //g.unite(id, id-1);\n            cnt--;\n        }\n        if(used[id] && used[id+1]){\n            //g.unite(id, id+1);\n            cnt--;\n        }\n        if(v[i].first > v[i+1].first){\n            ans = max(ans, cnt);\n        }\n    }\n    \n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tstd::vector<int> height;\n\tint max = 0;\n\tfor (int count = 0; num > count; ++count)\n\t{\n\t\tstd::cin >> buff;\n\t\theight.emplace_back(buff);\n\t\tif (max < height.back())\n\t\t{\n\t\t\tmax = height.back();\n\t\t}\n\t}\n\tstd::vector<int> count(max, 0);\n\tfor (int index = 0; height.size() - 1 > index; ++index)\n\t{\n\t\tif (height[index] > height[index + 1])\n\t\t{\n\t\t\tfor (int h = height[index + 1]; h < height[index]; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int h = height.back(); h > 0; --h)\n\t{\n\t\tcount[h - 1] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (int line = 0; max > line; ++line)\n\t{\n\t\tif (max_num < count[line])\n\t\t{\n\t\t\tmax_num = count[line];\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<pair<int, int>> v;\n    for(int i = 0; i < n; i++)\n    {\n        int x; cin >> x;\n        v.push_back(make_pair(x, i + 1));\n    }\n    sort(v.begin(), v.end(), greater<pair<int, int>>());\n    vector<int> used(n + 2, 0);\n    int ans = 0, cnt = 0;\n    for(int i = 0; i < n; i++)\n    {\n        int pos = i;\n        while(v[pos].first == v[i].first)\n        {\n            int u = v[pos].second;\n            if(used[u]) break;\n            used[u] = true;\n            cnt++;\n            if(used[u + 1]) cnt--;\n            if(used[u - 1]) cnt--;\n            pos++;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int>P;\nint main(void)\n{\n\tP box[100001];\n\tint n,a[100001],MAX,i,sima,flg,i1,cnt,i2;\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\ta[n+1]=-1;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tcnt=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(i>i2){\n\t\ti1=i+1;\n\t\ti2=i;\n\t\t while(a[i]==a[i1]){\n\t\t\t i1++;\n\t\t\t i2++;\n\t\t   }\n\t\tbox[cnt].first=a[i];\n\t\tflg=0;\n\t\tif(a[i]>a[i-1]&&a[i]>a[i1]){\n\t\t\tbox[cnt].second=-1;\n\t\t\tflg=1;\n\t\t}\n\t\tif(a[i]<a[i-1]&&a[i]<a[i1]){\n\t\t\tbox[cnt].second=1;\n\t\t\tflg=1;\n\t\t}\n\t\tif(flg==0){\n\t\t\tbox[cnt].second=0;\n\t\t}\n\t\tcnt++;\n\t}\n\t}\n\tsort(box,box+cnt+1);\n\tsima=1;\n\tMAX=0;\n\tfor(i=0;i<=cnt;i++){\n\t\tsima=sima+box[i].second;\n\t\tif(sima>MAX){\n\t\t\tMAX=sima;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",MAX);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define LEN 100010\nint n;\ntypedef struct{\n    int hei;\n    int pos;\n    int sank;\n}RIKU;\nRIKU R[LEN];\nint PosToIndex[LEN] = {0};\nint allzero = 0;\n\nint cmp(RIKU x,RIKU y) {\n    return x.hei<y.hei   ; \n}\n\nint main(void)\n{\n    //------------\n    cin >> n;\n\n    // 両端\n    R[0].hei = 0;\n    R[0].pos = 0;\n    R[0].sank = 1;\n    R[n+1].hei = 0;\n    R[n+1].pos = n+1;\n    R[n+1].sank = 1;\n\n    for(int i = 1 ; i <= n ; i++){\n        cin >> R[i].hei;\n        allzero += R[i].hei;\n        R[i].pos = i;\n        R[i].sank = -1;\n    }\n    sort(R+1, R+n+1, cmp);\n\n    // posとindexの変換テーブル\n    for(int i=0;i<=n+1;i++){\n        PosToIndex[R[i].pos] = i;\n    }\n    //------------\n \n    int now_hight = R[1].hei;\n    int shima_max = 0;\n    int shima_count = 1;\n    if(allzero == 0) shima_count = 0;\n    \n/*\n    if(R[PosToIndex[1]].hei != now_hight && R[PosToIndex[n]].hei != now_hight){\n        shima_count++;\n    }\n*/\n    for(int i=1;i<=n;i++){\n\n        //std::cout << \"index : \" << i << \"-----\" << endl;\n\n        if(now_hight != R[i].hei || i == n){\n            if(shima_max < shima_count) shima_max = shima_count;\n            now_hight = R[i].hei;\n        }\n        // しまをカウント\n        shima_count++;\n        R[i].sank = 1;\n\n        if(R[PosToIndex[R[i].pos-1]].sank != -1){ //隣が沈んでいれは\n            shima_count--;\n        }\n        if(R[PosToIndex[R[i].pos+1]].sank != -1){ //隣が沈んでいれは\n            shima_count--;\n        }\n\n        //std::cout << now_hight << \":\";\n        //std::cout << shima_count << endl;\n\n\n        /*\n        if(R[i].pos == 1){\n            hajis++;\n        }\n        if(R[i].pos == n){\n            hajis++;\n        }\n        \n        if(haji_1 == haji_n && 1 != n){   // 両端が沈む対象なら\n            hajis++;\n        } \n        */     \n    }\n\n    std::cout << shima_max << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll N; \nll A[100005];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N;\n\n    ll tmp[100005];\n    for (int i = 0;i < N;i++){\n        cin >> tmp[i];\n    }\n\n    map<ll,vector<ll> > memo;\n    for (int i = 0;i < N;i++){\n        memo[tmp[i]].push_back(i);\n    }\n\n    ll h = 1;\n    for(auto&& itr:memo){\n        for (int i = 0;i < itr.second.size();i++){\n            A[itr.second[i]] = h;\n            if(tmp[itr.second[i]] == 0) A[itr.second[i]] = 0;\n        }\n        h++;\n    }\n\n    ll dif1[100005];\n    memset(dif1,0,sizeof(dif1));\n\n    dif1[0]++;\n    dif1[A[0]]--;\n\n    for (int i = 0;i < N-1;i++){\n        if(A[i] < A[i+1]){\n            dif1[A[i]]++;\n            dif1[A[i+1]]--;\n        }else{\n            dif1[A[i]]--;\n            dif1[A[i+1]]++;\n        }\n    }\n\n    dif1[A[N-1]]--;\n    dif1[0]++;\n\n    ll dif2[100005];\n    memset(dif2,0,sizeof(dif2));\n\n    ll ans = 0;\n    ll t = 0;\n\n    for (int i = 0;i < N+5;i++){\n        t += dif1[i];\n        dif2[i] = t;\n        ans = max(ans,t);\n    }\n\n    cout << ans/2 << endl;\n\n    /*for (int i = 0;i < N;i++){\n        cout << A[i] << \" \";\n    }\n\n    cout << endl;*/\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n\tint long long n,a,ans=1,unans=1,v,h=0;\n\tcin>>n;\n\tbool sea[n+2]={};\n\tmap<int long long, vector<int>> m;\n\tfor(int p=1;p<n+1;p++){\n\t\tcin>>a;\n\t\tm[a].push_back(p);\n\t\tsea[p]=true;\n\t\tif(a==0){\n\t\t\th++;\n\t\t}\n\t}\n\tif(h==n){\n\t\tans=0;\n\t}\n\t//陸はtrue海はfalse\n\tfor(const auto p : m){\n\t\t//cout<<\"a\"<<endl;\n\t\tfor(int long long v: p.second){\n\t\t\t//cout<<v<<\"second\"<<endl;\n\t\t\tif(!sea[v-1]&&!sea[v+1]){\n\t\t\t\tunans--;\n\t\t\t}\n\t\t\tif(sea[v-1]&&sea[v+1]){\n\t\t\t\tunans++;\n\t\t\t}\n\t\t\tsea[v]=false;\n\t\t}\n\t\tans=max(ans,unans);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  cin.tie(0);\n \tios::sync_with_stdio(false);\n  int N;\n  cin >> N;\n  int A[N];\n  for(int i = 0; i < N; i++){\n    cin >> A[i];\n  }\n\n  vector<int> B;\n  B.push_back(0);\n  bool flag = true;\n  for(int i = 0; i < N; i++){\n    int idx = B.size() - 1;\n    if(B[idx] == A[i]) continue;\n    if(flag){\n      if(B[idx] > A[i]) B[idx] = A[i];\n      else{\n        B.push_back(A[i]);\n        flag = false;\n      }\n    }else{\n      if(B[idx] < A[i]) B[idx] = A[i];\n      else{\n        B.push_back(A[i]);\n        flag = true;\n      }\n    }\n  }\n  if(B.size() == 1){\n    cout << \"0\\n\";\n    return 0;\n  }\n  if(B.size() <= 3){\n    cout << \"1\\n\";\n    return 0;\n  }\n  if(B[B.size() - 1] != 0){\n    if(B.size() % 2 == 0){\n      B.push_back(0);\n    }else{\n      B[B.size() - 1] = 0;\n    }\n    \n  }\n\n  // for(int i : B){\n  //   cout << i << \" \";\n  // }\n  // cout << \"\\n\";\n  \n \n  vector<pair<int, int>> v;\n  for(int i = 1; i < B.size(); i += 2){\n    v.push_back(make_pair(B[i - 1], B[i]));\n    if(i + 1 < B.size()){\n      v.push_back(make_pair(B[i + 1], B[i]));\n    }\n  }\n\n  map<int, int> m;\n  for(int i = 0; i < v.size(); i++){\n    if(v[i].first != 0){\n      if(m.count(v[i].first) == 0){\n        m.insert(make_pair(v[i].first, 1));\n      }else{\n        m[v[i].first]++;\n      }\n    }\n  }\n\n  map<int, int> m2;\n  for(int i = 0; i < v.size(); i++){\n    if(v[i].first != 0){\n      if(m2.count(v[i].first) == 0){\n        m2.insert(make_pair(v[i].first, 1));\n      }else{\n        m2[v[i].first]++;\n      }\n    }\n    if(m2.count(v[i].second) == 0){\n      m2.insert(make_pair(v[i].second, 1));\n    }else{\n      m2[v[i].second]++;\n    }\n  }\n\n  sort(v.begin(), v.end());\n  \n  // for(int i = 0; i < v.size(); i++){\n  //   cout << v[i].first << \" \" << v[i].second << \"\\n\";\n  // }\n  \n  int n = v.size();\n  priority_queue<int, vector<int>, greater<int>>qr;\n  int g = 1;\n  qr.push(v[0].second);\n  int k;\n  for(int i = 1; i < n; i++){\n    k = v[i].first;\n    qr.push(v[i].second);\n    // cout << qr.top() << \"\\n\";\n    if(k > qr.top()){\n     while(!qr.empty()){\n        if(k <= qr.top()){\n          break;\n        }else{\n          qr.pop();\n        }\n      }\n    }\n    int t = 0;\n    if(m2.count(k) != 0){\n      t = m2.at(k);\n    }\n    if(m.count(k) != 0){\n      t -= m.at(k);\n    }\n    g = max(g, (int)qr.size() - t);\n  }\n  cout << g / 2<< \"\\n\";\n  // cout << m2[2] << \"\\n\";\n  // cout << m.size() << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tint N=0;\n\tcin>>N;//区画の数\n\tvector<int> A(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>A[i];//\n\t}\n\tvector<bool> sea(N+2);\n\tsea[0]=sea[N+1]=true;\n\tfor(int i=0;i<N;i++){\n\t\tsea[i+1]=(A[i]<=0);\n\t}\n\tint current=0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!sea[i]&&sea[i-1]){\n\t\t\tcurrent++;\n\t\t}\n\t}\n\tvector<pair<int,int>>AandID;\n\tfor(int i=0;i<N;i++){\n\t\tif(A[i]>0){\n\t\t\tAandID.push_back(make_pair(A[i],i+1));\n\t\t}\n\t}\n\tsort(AandID.begin(),AandID.end());\n\tint answer=current;\n\tfor(int t=0;t<AandID.size();t++){\n\t\tint i=AandID[t].second;\n\t\tsea[i]=true;\n\t\tif(sea[i-1]&&sea[i+1]){\n\t\t\tcurrent--;\n\t\t}\n\t\telse if(!sea[i-1]&&![i+1]){\n\t\t\tcurrent++;\n\t\t}\n\t\tif(t+1=AandID.size()||AandID[t].first<AandID[t+1].first){\n\t\t\tanswer=max(answer,current);\n\t\t}\n\t}\n\tcout<<answer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define N_MAX 100000 \n\nusing namespace std;\n\nint main(void)\n{\n  int N;\n  cin >> N;\n  int A[N_MAX+1];\n  A[0] = 0;\n  vector<vector<int>> B;\n  int n = 1;\n  for(int i = 0; i < N; i++) {\n    int a;\n    cin >> a;\n    if(A[n-1] != a) {\n      A[n] = a;\n      vector<int> bi;\n      bi.push_back(A[n]);\n      bi.push_back(n);\n      B.push_back(bi);\n      n++;\n    }\n  }\n  A[n] = 0;\n  vector<int> prv = { 0, 0 };\n  B.push_back(prv);\n\n  sort(B.begin(), B.end());\n\n  int max_island = 0;\n  for(int j = 1; j <= n; j++) {\n    if(A[j-1] <= 0 && A[j] > 0) max_island++;\n  }\n\n  int island = max_island;\n  for (int i = 0; i < n; i++) {\n\t  int idx = B[i][1];\n\t  if (B[i][0] == 0) continue;\n\t  else if (B[i][0] > A[idx - 1] && B[i][0] > A[idx + 1]) island--;\n\t  else if (B[i][0] < A[idx - 1] && B[i][0] < A[idx + 1]) island++;\n\t  if (island > max_island && B[i+1][0] != B[i][0]) max_island = island;\n  }\n\n  cout << max_island << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nbool used[200000];\n\nint calcInitial(int n, vector<int> & vec) {\n  rep(i,n) if( !vec[i] ) used[i] = true;\n  int cnt = 0;\n  rep(i,n) {\n    if( used[i] ) continue;\n    ++cnt;\n    while( i + 1 < n && !used[i+1] ) {\n      ++i;\n    }\n  }\n  return cnt;\n}\n\nvoid compute(int n,vector<int> &vec) {\n  map<int,deque<int>> mp;\n  rep(i,n) mp[vec[i]].push_back(i);\n  int cnt = calcInitial(n, vec);\n  vector<int> st = vec;\n  sort(ALL(st));\n  st.erase(unique(ALL(st)),st.end());\n  int maxi = cnt;\n  rep(i,(int)st.size()) {\n    int v = st[i];\n    if( v == 0 ) continue;\n    deque<int> &deq = mp[v];\n    while( !deq.empty() ) {\n      int p = deq.front(); deq.pop_front();\n      used[p] = true;\n      if( p-1 >= 0 && p + 1 < n && !used[p-1] && !used[p+1] && vec[p+1] > vec[p] && vec[p-1] > vec[p] ) {\n\t++cnt;\n      }\n      if( ( ( p-1 >= 0 && used[p-1] ) || p-1 < 0 ) && ( ( p + 1 < n && used[p+1] ) || p+1 >= n ) ) {\n\t--cnt;\n      }\n    }\n    maxi = max(maxi,cnt);\n  }\n  cout << maxi << endl;\n  assert( cnt == 0 );\n}\n\nvector<int> compress(int n, vector<int> &vec) {\n  vector<int> wec;\n  rep(i,n) if( i-1 < 0 || vec[i-1] != vec[i] ) wec.push_back(vec[i]);\n  return wec;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> vec(n);\n  rep(i,n) cin >> vec[i];\n  vector<int> wec = compress(n,vec);\n  compute((int)wec.size(), wec);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m == n ){n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    int max;\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){max = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n\n    }\n    }\n    cout << max << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n\nusing namespace std;\n\nlong long inf=1000000007;\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pair<int,int>> hoge;\n\n\tint pre=inf;\n\tint j=0;\n\tfor(int i=0;i<n;i++){\n\t\tint tmp;\n\t\tcin>>tmp;\n\t\tif(tmp!=pre){\n\t\t\thoge.push_back(make_pair(tmp,j));\n\t\t\tj++;\n\t\t}\n\t\tpre=tmp;\n\t}\n\n\tif(hoge.size()==1){\n\t\tif(hoge.at(0).first>0) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t\treturn 0;\n\t}\n\n\tvector<pair<int,int>> fuga=hoge;\n\tsort(fuga.begin(),fuga.end());\n\treverse(fuga.begin(),fuga.end());\n\n\tint ans=-1;\n\tint cnt=0;\n\tint bef=inf;\n\n\tfor(auto a:fuga){\n\t\tif(a.first==0) break;\n\t\tif(a.first!=bef) ans=max(ans,cnt);\n\t\tbef=a.first;\n\n\t\tif(a.second>0 && a.second<j-1){\n\t\t\tif(a.first>hoge.at(a.second-1).first && a.first>hoge.at(a.second+1).first) cnt++;\n\t\t\telse if(a.first<hoge.at(a.second-1).first && a.first<hoge.at(a.second+1).first) cnt--;\n\t\t}else if(a.second==0){\n\t\t\tif(a.first>hoge.at(a.second+1).first) cnt++;\n\t\t}else if(a.second==j-1){\n\t\t\tif(a.first>hoge.at(a.second-1).first) cnt++;\n\t\t}\n\t}\n\n\tans=max(ans,cnt);\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tmap<int, vector<int>>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tm[v[i]].push_back(i);\n\t}\n\tvector<int>l(N);\n\tvector<int>r(N);\n\tvector<int>w(N);\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (v[i]) {\n\t\t\tans = 1;\n\t\t\tw[i] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)l[i] = i - 1;\n\tfor (int i = 0; i < N; i++)r[i] = i + 1;\n\tint box = ans;\n\tfor (auto i : m) {\n\t\tfor (auto j : i.second) {\n\t\t\tif (l[j] >= 0)r[l[j]] = r[j];\n\t\t\tif (r[j] < N) {\n\t\t\t\tl[r[j]] = l[j];\n\t\t\t\tbox += 1 - w[r[j]];\n\t\t\t\tw[r[j]] = 1;\n\t\t\t}\n\t\t\tbox -= w[j];\n\t\t\tw[j] = 0;\n\t\t}\n\t\tans = max(ans, box);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 1000000007;\nusing ll = int64_t;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> v(n+2);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &v[i+1]);\n    }\n    vector<int> z = v;\n    sort(z.begin(), z.end());\n    z.erase(unique(z.begin(), z.end()), z.end());\n    auto f = [&](int x){ return lower_bound(z.begin(), z.end(), x) - z.begin(); };\n    vector<int> s(z.size()+1, 0);\n    for (int i = 0; i < n+1; ++i) {\n        int a = f(min(v[i], v[i+1])), b = f(max(v[i], v[i+1]));\n        s[a]++; s[b]--;\n    }\n    for (int i = 0; i < z.size(); ++i) {\n        s[i+1] += s[i];\n    }\n    cout << *max_element(s.begin(), s.end()) /2 << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define pint pair<int, int>\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nint N;\nvector<pint> b;\nbool co[100005] = {};\n\nint main() {\n\tcin >> N;\n\trep(i, N) {\n\t\tint a;\n\t\tcin >> a;\n\t\tb.push_back(mp(a, i + 1));\n\t}\n\n\tsort(b.begin(), b.end(), greater<pint>());\n\n\tint ret = 0, cnt = 0;\n\trep(i, N) {\n\t\tif (b[i].first == 0) break;\n\n\t\tint tmp = b[i].second;\n\t\t\n\t\tco[tmp] = true;\n\n\t\tcnt++;\n\t\tif (co[tmp + 1]) cnt--;\n\t\tif (co[tmp - 1]) cnt--;\n\n\t\tif (i == N-1 || b[i].first != b[i + 1].first) {\n\t\t\tret = max(ret, cnt);\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// 2019/07/09 Tazoe\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\n\tint A[100002];\n\tA[0] = 0;\n\tfor(int i=1; i<=N; i++){\n\t\tcin >> A[i];\n\t}\n\tA[N+1] = 0;\n\tN = N+2;\n\n\tint i2 = 1;\n\tfor(int i=1; i<N; i++){\n\t\tif(A[i]==A[i2-1])\n\t\t\tcontinue;\n\n\t\tA[i2++] = A[i];\n\t}\n\tN = i2;\n\n\tif(N==1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\ti2 = 0;\n\tfor(int i=1; i<N-1; i++){\n\t\tif(A[i]-A[i-1]>0 && A[i+1]-A[i]>0)\n\t\t\tcontinue;\n\t\tif(A[i]-A[i-1]<0 && A[i+1]-A[i]<0)\n\t\t\tcontinue;\n\n\t\tA[i2++] = A[i];\n\t}\n\tN = i2;\n\n\tif(N==1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n/*\n\tfor(int i=0; i<N; i++){\n\t\tcout << A[i] << ' ';\n\t}\n\tcout << endl;\n*/\n\tint N1 = 0;\n\tint N2 = 0;\n\tint A1[50000], A2[50000];\n\tfor(int i=0; i<N; i++){\n\t\tif(i%2==0){\n\t\t\tA1[N1++] = A[i];\n\t\t}\n\t\telse{\n\t\t\tA2[N2++] = A[i];\n\t\t}\n\t}\n\tsort(A1, A1+N1);\n\tsort(A2, A2+N2);\n/*\n\tfor(int i=0; i<N1; i++){\n\t\tcout << A1[i] << ' ';\n\t}\n\tcout << endl;\n\tfor(int i=0; i<N2; i++){\n\t\tcout << A2[i] << ' ';\n\t}\n\tcout << endl;\n*/\n\tint I = 0;\n\tint I2 = 1;\n\n\tfor(int i1=0, i2=0; i2<N2; ){\n\t\tif(A1[i1]<=A2[i2]){\n\t\t\tI2--;\n\t\t\ti1++;\n\t\t}\n\t\telse{\n\t\t\tI2++;\n\t\t\ti2++;\n\t\t}\n\n\t\tI = max(I, I2);\n\t}\n\n\tcout << I << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint a[114514];\nint numcheck(int h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n\n    }\n    int max = numcheck(0);\n    int n = numcheck(1);\n    int m = 1;\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(m);\n    }\n    cout << max　<< endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m / n < 1){n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    int max;\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){max = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n\n    }\n    }\n    cout << max << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define Would\n#define you\n#define all(n)  n.begin(),n.end()\n#define rall(n) n.rbegin(),n.rend()\ntypedef long long ll;\nconst ll INF = 2147483647;\nconst ll MOD = 1e9 + 7;\nconst double EPS = 1e-10;\nconst double pi = acos(-1);//3.1415926535897932384626433832795028...\nconst ll SIZE = 1 << 17;\nint dx[] = { 1,0,-1,0 }, dy[] = { 0,1,0,-1 }, alp[30];\nll fac[200005], finv[200005], inv[200005];\nvector<ll>dij;\nstruct edge { ll to, cost; };\nvector<vector<edge> >G;\n\nll mod_pow(ll a, ll b) {\n\tll res = 1, mul = a;\n\tfor (int i = 0; i < 31; ++i) {\n\t\tif (b >> i & 1) {\n\t\t\tres *= mul;\n\t\t\tres %= MOD;\n\t\t}\n\t\tmul = (mul * mul) % MOD;\n\t}\n\treturn res;\n}\n\nvoid addedge(int from, int to, int cost) {\n\tG[from].push_back({ to,cost });\n\tG[to].push_back({ from,cost });\n}\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\n\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type\nfill_v(T & t, const V & v) { t = v; }\n\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type\nfill_v(T & t, const V & v) {\n\tfor (auto& e : t) fill_v(e, v);\n}\n\ntemplate<typename T>\nvoid outp(vector<T>v) {\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcout << v[i];\n\t\tif (i != v.size() - 1) { cout << \" \"; }\n\t}\n}\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) { return 0; }\n\treturn a + b;\n}\n\nll n, in, ans, mon = 1;\nbool uku[100005];\nint main() {\n\tcin >> n;\n\tvector<pair<ll, ll>>v;\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> in;\n\t\tuku[i] = 1;\n\t\tv.push_back(make_pair(in, i));\n\t}\n\n\tsort(all(v));\n\tans = ((v[0].first == 0) ? 0 : 1);\n\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tauto ushi = v[i].second;\n\t\tuku[ushi] = 0;\n\t\t--mon;\n\t\tif (uku[ushi - 1]) { ++mon; }\n\t\tif (uku[ushi + 1]) { ++mon; }\n\t\tif (i == v.size() - 1 || v[i].first != v[i + 1].first) { ans = max(ans, mon); }\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<unordered_map>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tint pre = 0;\n\tstd::unordered_map<int, int> count;\n\tstd::cin >> pre;\n\tfor (int c = 0; num - 1 > c; ++c)\n\t{\n\t\tstd::cin >> buff;\n\t\tif (pre > buff)\n\t\t{\n\t\t\tfor (int h = buff; h < pre; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t\tpre = buff;\n\t}\n\tfor (int h = buff - 1; h >= 0; --h)\n\t{\n\t\tcount[h] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (auto itr = count.begin(); count.end() != itr; ++itr)\n\t{\n\t\tif (max_num < itr->second)\n\t\t{\n\t\t\tmax_num = itr->second;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define PK push_back\nusing namespace std;\ntypedef pair<int,int>P;\nint a[100002];\nint main(void){\n\tint n;\n\tint i,j;\n\tvector<P>v;\n\tcin>>n;\n\tint flg=0;\n\tP pp;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(a[i]!=0)\t\tflg=1;\n\t}\n\ta[0]=-1;\n\ta[n+1]=-1;\n\ti=1;\n\t//cout<<\"check\"<<endl;\n\twhile(i<=n){\n\t\tj=i-1;\n\t//cout<<\"I=\"<<i<<endl;\n\t//cout<<\"J=\"<<j<<endl;\n\t\twhile(a[i]==a[j])\tj--;\n\t//cout<<\"J=\"<<j<<endl;\n\t//cout<<\"a[i]=\"<<a[i]<<\" \"<<\"a[j]=\"<<a[j]<<endl;\n\t\tif(a[j]>a[i]){\n\t\t\tj=i+1;\n\t\t\twhile(a[i]==a[j])\tj++;\n\t//cout<<\"a[i]1=\"<<a[i]<<\" \"<<\"a[j]1=\"<<a[j]<<endl;\n\t\t\tif(a[i]<a[j]){\n\t\t\t\tpp.F=a[i];\n\t\t\t\tpp.S=1;\n\t//cout<<\"PP.F1=\"<<pp.F<<\" \"<<\"PP.S1=\"<<pp.S<<endl;\n\t\t\t\tv.PK(pp);\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tif(a[j]<a[i]){\n\t\t\tj=i+1;\n\t\t\twhile(a[i]==a[j])\tj++;\n\t//cout<<\"a[i]2=\"<<a[i]<<\" \"<<\"a[j]2=\"<<a[j]<<endl;\n\t\t\tif(a[i]>a[j]){\n\t\t\t\tpp.F=a[i];\n\t\t\t\tpp.S=-1;\n\t//cout<<\"PP.F2=\"<<pp.F<<\" \"<<\"PP.S2=\"<<pp.S<<endl;\n\t\t\t\tv.PK(pp);\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\t//for(i=0;i<v.size();i++)\t\tcout<<v[i].F<<\" \"<<v[i].S<<endl;\n\tint island=1;\n\tint MAX=1;\n\tfor(i=0;i<v.size();i++){\n\t\tisland+=v[i].S;\n\t\tif(v[i].F!=v[i+1].F&&i!=v.size()-1){\n\t\t\tMAX=max(MAX,island);\n\t\t}\n\t}\n\tMAX=max(MAX,island);\n\tif(flg==0)\tMAX=0;\n\tcout<<MAX<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint a[114514];\nint numcheck(int h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n\n    }\n    int max = numcheck(0);\n    int n = numcheck(1);\n    int m = 1;\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(m);\n    }\n    cout << max << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main(void){\n\tint N;\n\tcin>>N;\n\tvector<int> A(N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>A[i];\n\t}\n\tvector<bool> sea(N+2);\n\tsea[0]=sea[N+1]=true;\n\tfor(int i=0;i<N;i++){\n\t\tsea[i+1]=(A[i]<=0);\n\t}\n\tint current=0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!sea[i]&&sea[i-1])\n\t\t{\n\t\t\tcurrent++;\n\t\t}\n\t}\n\tvector<pair<int,int> > AandID;\n\tfor(int i=0;i<N;i++){\n\t\tif(A[i]>0){\n\t\t\tAandID.push_back(make_pair(A[i],i+1));\n\t\t}\n\t}\n\tsort(AandID.begin(),AandID.end());\n\tint answer=current;\n\tfor(int t=0;t<AandID.size();t++){\n\t\tint i=AandID[t].second;\n\t\tsea[i]=true;\n\t\tif(sea[i-1]&&sea[i+1]){\n\t\t\tcurrent--;\n\t\t}\n\t\telse if(!sea[i-1]&&!sea[i+1]){\n\t\t\tcurrent++;\n\t\t}\n\t\tif(t+1==AandID.size()||AandID[t].first<AandID[t+1].first){\n\t\t\tanswer=max(answer,current);\n\t\t}\n\t}\n\tcout<<answer<<endl;\n\treturn 0;\n}*/\n/*\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint main(void){\n\tlong long N,M;\n\tcin>>N>>M;\n\tvector<long long> A(N+2);\n\t\n\treturn 0;\n}*/\n\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nint main(void)\n{\n\tlong long N=0;\n\tcin>>N;\n\tvector<long long> A(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>A[i];\n\t}\n\tvector<bool> sea(N+2);\n\tsea[0]=sea[N+1]=true;\n\tfor(int i=0;i<N;i++){\n\t\tsea[i+1]=(A[i]<=0);\n\t}\n\tlong long current=0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(sea[i-1]&&!sea[i]){\n\t\t\tcurrent++;\n\t\t}\n\t}\n\tvector<pair<long long,long long> > V;\n\tfor(int i=0;i<N;i++){\n\t\tif(A[i]>0){\n\t\t\tV.push_back(make_pair(A[i],i+1));\n\t\t}\n\t}\n\tsort(V.begin(),V.end());\n\tlong long answer=current;\n\tfor(int t=0;t<V.size();t++){\n\t\tint a=V[t].second;\n\t\tsea[a]=true;\n\t\tif(!sea[a-1]&&!sea[a+1])\n\t\t{\n\t\t\tcurrent++;\n\t\t}\n\t\tif(sea[a-1]&&sea[a+1])\n\t\t{\n\t\t\tcurrent--;\n\t\t}\n\t\tif(t==V.size()-1||V[t].first<V[t+1].first){\n\t\t\tanswer=max(answer,current);\n\t\t}\n\t}\n\tcout<<answer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin>>N;\n\t\n\tmap<int64_t,vector<int>> ai;\n\t\n\tbool sea[N+2]={};\n\t\n\tsea[0]=sea[N+1]=true;\n\n\tint ans = 0;\n\n\tfor(int i=1; i<=N; ++i){\n\t\tint64_t a;\n\t\tcin>>a;\n\t\tai[a].push_back(i);\n\t\tif( a > 0 ){\n\t\t\tans = 1;\n\t\t}\n\t}\n\t\n\tint n = 1;\n\tfor(const auto & p : ai){\n\t\tfor(const int i : p.second){\n\t\t\tsea[i] = true;\n\t\t\tif( !sea[i-1] && !sea[i+1]){ \n\t\t\t\t++n;\n\t\t\t}\n\t\t\tif( sea[i-1] && sea[i+1]){\n\t\t\t\t--n;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, n);\n\t}\n\t\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    vector<bool> sea(N+2);\n    sea[0] = true;\n    sea[N+1] = true;\n    vector<pair<int, int>> AandNum;\n\n    /*初期状態での陸地と海を調べる*/\n    for(int i = 0; i < N; i++) {\n        if(A[i] == 0) {\n            sea[i+1] = true;\n        }\n        else {\n            /*陸地の場合は高さと配列のインデックスを記録*/\n            AandNum.push_back(make_pair(A[i], i+1)); \n            sea[i+1] = false;\n        }\n    }\n    \n    /*陸地の高さの順にソート*/\n    sort(AandNum.begin(), AandNum.end());\n\n    int temp = 0;\n    int ans = 0;\n    /*島の数の初期状態をカウント*/\n    for(int i = 0; i < N+1; i++) {\n        if(sea[i] && !sea[i+1]) {\n            temp += 1;\n        }\n    }\n    ans = temp;\n    /*陸地が一つ沈んだ場合の島の増減*/\n    for(int i = 0; i < AandNum.size(); i++) {\n        int j = AandNum[i].second;\n        sea[j] = true;\n        /*両方が陸地なら島が1つ増える*/\n        if(!sea[j-1] && !sea[j+1]) {\n            temp += 1;\n        }\n        /*両方が海なら島が1つ減る*/\n        else if(sea[j-1] && sea[j+1]) {\n            temp -= 1;\n        }\n        if(i+1 == AandNum.size() || AandNum[i].first < AandNum[i+1].first) {\n            ans = max(ans, temp);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> a(N+2);\n\ta[0] = 0;\n\tint a_num = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint b;\n\t\tcin >> b;\n\t\tif(a[a_num] != b){\n\t\t\ta_num++;\n\t\t\ta[a_num] = b;\n\t\t}\n\t}\n\ta.push_back(0);\n\tvector<int> kado;\n\tkado.push_back(0);\n\tfor (int i = 1; i < a.size()-1; i++)\n\t\tif ((a[i] > a[i-1] && a[i] > a[i+1]) ||\n\t\t\t(a[i] < a[i-1] && a[i] < a[i+1]))\n\t\t\tkado.push_back(a[i]);\n\tvector<int> mountain;\n\tvector<int> valley;\n\tfor (int i = 0; i < kado.size(); i++)\n\t\tif (i%2 == 1)\n\t\t\tmountain.push_back(kado[i]);\n\t\telse\n\t\t\tvalley.push_back(kado[i]);\n\tsort(kado.begin(), kado.end());\n\tsort(mountain.begin(), mountain.end());\n\tsort(valley.begin(),valley.end());\n\tint ans = 0, max = 0;\n\tif(kado.size() == 1){\n\t\tmax = 0;\n\t\tcout << max << endl;\n\t\treturn 0;\n\t}\n\tint m = 0, b = 0;\n\tfor(int i = 0; i < kado.size(); i ++){\n\t\tif (mountain[m] == kado[i]){\n\t\t\tm++;\n\t\t\tans--;\n\t\t}\n\t\tif (valley[b] == kado[i]){\n\t\t\tb++;\n\t\t\tans++;\n\t\t}\n\t\tif (kado[i] < kado[i+1])\n\t\t\tif (ans > max)max = ans;\n\t}\n\tcout << max << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    int max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        //cout << c[m] <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m / n < 2){n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    int max;\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){max = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n\n    }\n    }\n    cout << max << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    int max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << c[m] <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing pint = pair<int,int>;\nvoid Main(){\n    int N; cin >> N;\n    vector<pint> B;\n    vector<int> A;\n\n    int prev = -1;\n    for (int i = 0; i < N; i++){\n        int a; cin >> a;\n        if (a != prev){\n            B.push_back(pint(a, B.size()));\n            A.push_back(a);\n            prev = a;\n        }\n    }\n    sort(B.begin(), B.end(), greater<pint>());\n    if (A.size() == 1){\n        if (A[0] > 0){\n            cout << 1 << endl;\n        }\n        else{\n            cout << 0 << endl;\n        }\n    }\n    else{\n        int res = 1;\n        int cur = 0;\n        for (int i = 0; i < B.size(); i++){\n            int id = B[i].second;\n            if (id == 0){\n                if (A[id] > A[id+1]){\n                    ++cur;\n                }\n            }\n            else if (id == A.size()-1){\n                if (A[id-1] < A[id]){\n                    ++cur;\n                }\n            }\n            else{\n                if (A[id-1] < A[id] && A[id] > A[id+1]){\n                    ++cur;\n                }\n                else if (A[id-1] > A[id] && A[id] < A[id+1]){\n                    --cur;\n                }\n            }\n            if (i == (int)B.size() - 1 || B[i].first != B[i+1].first){\n                res = max(res,cur);\n            }\n        }\n        cout << res << endl;\n    }\n}\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=10007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint p[110000];\npair<int,int>ev[110000];\nint v[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tev[i]=make_pair(p[i],i);\n\t}\n\tstd::sort(ev,ev+a);\n\treverse(ev,ev+a);\n\tint ret=0;\n\tint cur=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(ev[i].first==0)break;\n\t\tint at=ev[i].second;\n\t\tv[at]=1;\n\t\tcur++;\n\t\tif(at&&v[at-1])cur--;\n\t\tif(at+1<a&&v[at+1])cur--;\n\t\tif(i==a-1||ev[i].first!=ev[i+1].first){\n\t\t\tret=max(ret,cur);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    unique (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<bool> sink(n+2, 0);\n    sink[0] = sink[n+1] = true; // centinel\n    vector<pair<int,int>> vp;\n    for(int i = 0; i < n; i++){\n        int x;  cin >> x;\n        vp.push_back({x, i+1});\n    }\n    vp.push_back({0, 0});  // centinel\n    sort(vp.begin(), vp.end());\n    int ans = 0, tmp = 1;\n    for(int i = 1; i < vp.size(); i++){\n        if(vp[i].first != vp[i-1].first)    ans = max(ans, tmp);\n        int pos = vp[i].second;\n        sink[pos] = true;\n        if(sink[pos-1]+sink[pos+1] == 0)        tmp++;\n        else if(sink[pos-1]+sink[pos+1] == 2)   tmp--;\n    }\n    cout << max(ans, tmp) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<int> a;\n    map<int,vector<int>> idx;\n    a.pb(-1);\n    rep(i,n){\n        int t;\n        scanf(\" %d\", &t);\n        a.pb(t);\n        idx[t].pb(i+1);\n    }\n    a.pb(-1);\n\n    n += 2;\n    vector<bool> sink(n);\n    sink[0] = sink[n-1] = true;\n\n    int now = 1;\n    if(idx.count(0)){\n        for(int i:idx[0]){\n            sink[i] = true;\n            if(sink[i-1] && sink[i+1]) --now;\n            if(!sink[i-1] && !sink[i+1]) ++now;\n        }\n    }\n\n    int ans = now;\n    for(const auto &p:idx){\n        if(p.fi == 0) continue;\n        for(int i:p.se){\n            sink[i] = true;\n            if(sink[i-1] && sink[i+1]) --now;\n            if(!sink[i-1] && !sink[i+1]) ++now;\n        }\n        ans = max(ans,now);\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n\nint main(){\n    ll n;\n    cin >> n;\n    vector<ll> a(n);\n    vector<pair<ll, ll>> b(n);\n    REP(i, n) {\n        cin >> a.at(i);\n        b.at(i) = make_pair(a.at(i), i);\n    }\n    sort(b.begin(), b.end());\n    if(b.back().first == 0){\n        cout << 0 << endl;\n        return 0;\n    }\n    ll ans = 1;\n    ll num = 1;\n    vector<bool> is_sink(n, false);\n    REP(i, b.size()){\n        const ll j = b.at(i).second;\n        if(j == 0 && j + 1 < n && is_sink.at(j + 1)){\n            num--;\n        }\n        if(j == n - 1 && j > 0 && is_sink.at(j - 1)){\n            num--;\n        }\n        if(0 < j && j + 1 < n){\n            if(is_sink.at(j - 1) && is_sink.at(j + 1)){\n                num--;\n            }else if(!is_sink.at(j - 1) && !is_sink.at(j + 1)){\n                num++;\n            }\n        }\n        is_sink.at(j) = true;\n\n        if(i + 1 == n || b.at(i).first != b.at(i + 1).first){\n            ans = max(ans, num);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tint N=0;\n\tcin>>N;//区画の数\n\tvector<int> A(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>A[i];//\n\t}\n\tvector<bool> sea(N+2);\n\tsea[0]=sea[N+1]=true;\n\tfor(int i=0;i<N;i++){\n\t\tsea[i+1]=(A[i]<=0);\n\t}\n\tint current=0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!sea[i]&&sea[i-1]){\n\t\t\tcurrent++;\n\t\t}\n\t}\n\tvector<pair<int,int> >AandID;\n\tfor(int i=0;i<N;i++){\n\t\tif(A[i]>0){\n\t\t\tAandID.push_back(make_pair(A[i],i+1));\n\t\t}\n\t}\n\tsort(AandID.begin(),AandID.end());\n\tint answer=current;\n\tfor(int t=0;t<AandID.size();t++){\n\t\tint i=AandID[t].second;\n\t\tsea[i]=true;\n\t\tif(sea[i-1]&&sea[i+1]){\n\t\t\tcurrent--;\n\t\t}\n\t\telse if(!sea[i-1]&&!sea[i+1]){\n\t\t\tcurrent++;\n\t\t}\n\t\tif(t+1=AandID.size()||AandID[t].first<AandID[t+1].first){\n\t\t\tanswer=max(answer,current);\n\t\t}\n\t}\n\tcout<<answer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\n int max;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m == n){max=n;n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){max = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n\n    }\n    }\n    cout << max << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tstd::vector<int> height;\n\tint max = 0;\n\tfor (int count = 0; num > count; ++count)\n\t{\n\t\tstd::cin >> buff;\n\t\theight.emplace_back(buff);\n\t\tif (max < height.back())\n\t\t{\n\t\t\tmax = height.back();\n\t\t}\n\t}\n\tstd::vector<int> count(max, 0);\n\tfor (int index = 0; height.size() - 1 > index; ++index)\n\t{\n\t\tif (height[index] > height[index + 1])\n\t\t{\n\t\t\tfor (int h = height[index + 1]; h < height[index]; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int h = height.back(); h >= 0; --h)\n\t{\n\t\tcount[h] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (int line = 0; max > line; ++line)\n\t{\n\t\tif (max_num < count[line])\n\t\t{\n\t\t\tmax_num = count[line];\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\n\nsigned main(void) {\n    int i,j;\n    int n;\n    cin >> n;\n    vi a(n);\n    rep(i,n) cin >> a[i];\n    vector<pii> p(n);\n    rep(i,n)p[i] = pii(a[i],i);\n    sort(all(p));\n    set<pii> land;\n    rep(i,n)if(a[i]){\n        int j = 0;\n        while(i+j < n && a[i+j])j++;\n        land.insert(pii(i, i+j-1));//[i,i+j-1]\n        i += j;\n    }\n    int ans = land.size();\n    rep(i,n)if(p[i].first){\n        int q = p[i].second;\n        auto itr = land.lower_bound(pii(q+1,q));\n        itr--;\n        int l = itr->first;\n        int r = itr->second;\n        //cout << \"!\" << q << \" \" << l << \" \" << r << endl;\n        land.erase(itr);\n        if(q == l){\n            if(l != r)land.insert(pii(q+1,r));\n        }else if(q == r){\n            if(l != r)land.insert(pii(l,q-1));\n        }else{\n            land.insert(pii(l,q-1));\n            land.insert(pii(q+1,r));\n        }\n        if(i < n && p[i].first == p[i+1].first)continue;\n        /*\n        cout << p[i].first << endl;\n        for(set<pii>::iterator itr = land.begin(); itr != land.end(); ++itr){\n            cout << (itr->first) << \" \" << (itr->second) << endl;\n        }\n        */\n        ans = max(ans, (ll)land.size());\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<unordered_map>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tint pre = 0;\n\tstd::unordered_map<int, short> count;\n\tstd::cin >> pre;\n\tfor (int c = 0; num - 1 > c; ++c)\n\t{\n\t\tstd::cin >> buff;\n\t\tif (pre > buff)\n\t\t{\n\t\t\tfor (int h = buff; h < pre; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t\tpre = buff;\n\t}\n\tfor (int h = buff; h > 0; --h)\n\t{\n\t\tcount[h - 1] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (auto itr = count.begin(); count.end() != itr; ++itr)\n\t{\n\t\tif (max_num < itr->second)\n\t\t{\n\t\t\tmax_num = itr->second;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\n\nint a[100010]={};\nset<int>se;\nmap<int,int>ma;\n\nvector<int> ve[100020];\nbool b[100020]={};\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tcin>>n;\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>a[i];\n \t\tse.insert(a[i]);\n \t\t\n \t}\n \tint cn=0;\n \tif(*se.begin())cn++;\n \tfor(auto it=se.begin();it!=se.end();it++){\n \t\tma[*it]=cn;\n \t\tcn++;\n \t}\n \tma[0]=0;\n \tfor(int i=1;i<=n;i++){\n \t\ta[i]=ma[a[i]];\n \t\tve[a[i]].pb(i);\n \t}\n \tint ans=0;\n \tcn--;\n \tint ima=0;\n \tfor(int i=cn;i>0;i--){\n \t\t\n \t\tfor(auto v:ve[i]){\n \t\t\tb[v]=1;\n \t\t\tif(b[v-1] && b[v+1])ima--;\n \t\t\telse if(b[v-1]^b[v+1])ima=ima;\n \t\t\telse ima++;\n \t\t\t\n \t\t}\n \t\tans=max(ans,ima);\n \t}\n \tcout<<ans<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<pair<int, int>> v;\n    for(int i = 0; i < n; i++)\n    {\n        int x; cin >> x;\n        v.push_back(make_pair(x, i + 1));\n    }\n    sort(v.begin(), v.end(), greater<pair<int, int>>());\n    vector<int> used(n + 2, 0);\n    int ans = 0, cnt = 0;\n    for(int i = 0; i < n; i++)\n    {\n        int pos = i;\n        while(v[pos].first == v[i].first)\n        {\n            int u = v[i].second;\n            used[u] = true;\n            cnt++;\n            if(used[u + 1]) cnt--;\n            if(used[u - 1]) cnt--;\n            i++;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    int max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 1){\n        //cout << c[m] <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint a[114514];\nint numcheck(int h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n\n    }\n    int max = numcheck(0);\n    int n = numcheck(1);\n    int m = 1;\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(m);\n    }\n    cout << max << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define abs(x) (x >= 0 ? x : -(x))\n#define ceil(a, b) a / b + !!(a % b)\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\ntemplate<typename T> T pow(T a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\n\n\n\n\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pii> a;\n    vector<int> sink(n);\n    \n    int cnt = 0;\n    rep(i, n) {\n        int tmp;\n        cin >> tmp;\n        if (sz(a) == 0 || tmp != a.back().F) { a.eb(pii(tmp, cnt++)); }\n    }\n    n = sz(a);\n    sort(all(a));\n    if (a[n - 1].F == 0) { cout << 0 << endl; return 0; }\n    // rep(i, n) cout << a[i].F << \" \" << a[i].S << endl;\n    \n    int ans = 1; // x = 0\n    int tmp = 1;\n    \n    rep(i, n) { // 海面の高さはaから\n        rep3(j, i, n) { // 同じ高さのすべて見る\n            if (a[j].F > a[i].F) { i = j - 1; break; }\n            \n            sink[a[j].S] = 1;\n            \n            // 両隣が沈んでたら減る\n            // 両隣が生きてたら増える\n            if (a[j].S == 0) {\n                if (sink[a[j].S + 1] == 1) {\n                    tmp--;\n                    \n                }\n                continue;\n            } else if (a[j].S == n - 1) {\n                if (sink[a[j].S - 1] == 1) {\n                    tmp--;\n                    \n                }\n                continue;\n            }\n            \n            if (sink[a[j].S - 1] == 1 && sink[a[j].S + 1] == 1) {\n                tmp--;\n            }\n            else if (sink[a[j].S - 1] == 0 && sink[a[j].S + 1] == 0) {\n                \n                tmp++;\n            }\n        }\n        // rep(_, n) cout << sink[_] << \" \"; cout << endl;\n        chmax(ans, tmp);\n        // cout << ans << endl;\n    }\n    \n    \n    cout << ans << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint a[114514];\nint numcheck(int h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n\n    }\n    int max = numcheck(0);\n    int n = numcheck(1);\n    int m = 1;\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(m);\n    }\n    cout << max;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nstruct Info{\n\tInfo(int arg_left,int arg_right){\n\t\tleft = arg_left;\n\t\tright = arg_right;\n\t}\n\tint left,right;\n};\n\nint N;\nint table[NUM];\nbool is_sea[NUM];\nvector<int> V;\nvector<Info> POS[NUM];\nmap<int,int> MAP;\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tint count = 0; //島の数\n\n\t//ダミー\n\tis_sea[0] = true;\n\tis_sea[N+1] = true;\n\ttable[0] = 0;\n\ttable[N+1] = 0;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tscanf(\"%d\",&table[i]);\n\n\t\tif(table[i] == 0){\n\n\t\t\tis_sea[i] = true;\n\n\t\t}else{\n\n\t\t\tis_sea[i] = false;\n\t\t\tV.push_back(table[i]);\n\t\t\tif(is_sea[i-1]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\t//座標圧縮\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tMAP[V[i]] = i;\n\t}\n\n\t//同じ高さを区間にまとめる\n\tint left,right,index = 1;\n\n\twhile(index <= N){\n\n\t\tleft = index;\n\t\tright = left;\n\t\twhile(right <= N && table[left] == table[right])right++;\n\n\t\tindex = right;\n\n\t\tright--;\n\t\tif(table[left] != 0){\n\t\t\tPOS[MAP[table[left]]].push_back(Info(left,right));\n\t\t}\n\t}\n\n\tint ans = count;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tfor(int k = 0; k < POS[i].size(); k++){\n\n\t\t\tif(is_sea[POS[i][k].left-1] == true && is_sea[POS[i][k].right+1] == true){ //左右が海なら島減\n\n\t\t\t\tcount--;\n\t\t\t}else if(table[POS[i][k].left] < table[POS[i][k].left-1] &&\n\t\t\t\t\ttable[POS[i][k].right] < table[POS[i][k].right+1]){ //左右が今回沈まない陸地なら島増\n\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < POS[i].size(); k++){\n\t\t\tfor(int p = POS[i][k].left; p <= POS[i][k].right; p++){\n\n\t\t\t\tis_sea[p] = true;\n\t\t\t}\n\t\t}\n\n\t\tans = max(ans,count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n    int N = 0;\n    cin >> N;\n\n    vector<pair<int, int>> nihon;\n    vector<bool> isShima(N + 2);\n    int count = 0;\n    int maxCount = 0;\n    \n    for (int i = 1; i <= N; ++i) {\n        int num = 0;\n        cin >> num;\n        nihon.push_back(make_pair(-num, i));\n    }\n    \n    stable_sort(nihon.begin(), nihon.end());\n    \n    if (nihon[0].first != 0) {\n        for (int i = 0; i < N; ++i) {\n            isShima[nihon[i].second] = true;\n            if (!isShima[nihon[i].second - 1] && !isShima[nihon[i].second + 1]) {\n                count++;\n            }\n            else if (isShima[nihon[i].second - 1] && isShima[nihon[i].second + 1]) {\n                count--;\n            }\n            if (nihon[i].first != nihon[i + 1].first) maxCount = max(maxCount, count);\n        }\n    }\n    \n    cout << maxCount << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(10000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    int max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << c[m] <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\n int ma;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m == n){\n        if (h == 0){\n            ma = n;\n        }\n        n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){ma = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    ma = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(ma < n){\n            ma = n;\n            \n        }\n        m ++;\n        //cout <<ma<<endl;\n        n = numcheck(c[m]);\n\n\n    }\n    }\n    cout << ma << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define int long long\nint n, a[123456], ans = 1, p = 1; bool b[123456], flag=0;\nvector<pair<int,int>>v;\nsigned main() {\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i]; b[i] = 1;\n\t\tv.push_back(make_pair(a[i], i));\n\t\tif(a[i] > 0) flag = 1;\n\t}\n\tif(!flag) {cout << \"0\\n\"; return 0;}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < n; i++){\n\t\tif(i && v[i].first != v[i-1].first)\tans = max(ans, p);\n\t\tb[v[i].second] = 0;\n\t\tif(b[v[i].second-1] && b[v[i].second+1]) p++;\n\t\telse if(!b[v[i].second-1] && !b[v[i].second+1]) p--;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\n int max;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m == n){max=n;n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){max = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n\n    }\n    }\n    cout << max << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, A[1 << 18], cnt = 1, maxn = 1;\nbool used[1 << 18];\nvector<pair<int, int>> vec;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i];\n\t\tused[i] = true;\n\t\tvec.push_back(make_pair(A[i], i));\n\t}\n\tsort(vec.begin(), vec.end());\n\n\tif (vec[0].first == 0) maxn = 0;\n\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tint pos = vec[i].second;\n\t\tused[pos] = false; cnt--;\n\t\tif (used[pos - 1] == true) cnt++;\n\t\tif (used[pos + 1] == true) cnt++;\n\t\tif (i + 1 == vec.size() || vec[i].first != vec[i + 1].first) {\n\t\t\tmaxn = max(maxn, cnt);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tint N=0;\n\tcin>>N;//区画の数\n\tvector<int> A(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>A[i];//\n\t}\n\tvector<bool> sea(N+2);\n\tsea[0]=sea[N+1]=true;\n\tfor(int i=0;i<N;i++){\n\t\tsea[i+1]=(A[i]<=0);\n\t}\n\tint current=0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!sea[i]&&sea[i-1]){\n\t\t\tcurrent++;\n\t\t}\n\t}\n\tvector<pair<int,int> >AandID;\n\tfor(int i=0;i<N;i++){\n\t\tif(A[i]>0){\n\t\t\tAandID.push_back(make_pair(A[i],i+1));\n\t\t}\n\t}\n\tsort(AandID.begin(),AandID.end());\n\tint answer=current;\n\tfor(int t=0;t<AandID.size();t++){\n\t\tint i=AandID[t].second;\n\t\tsea[i]=true;\n\t\tif(sea[i-1]&&sea[i+1]){\n\t\t\tcurrent--;\n\t\t}\n\t\telse if(!sea[i-1]&&!sea[i+1]){\n\t\t\tcurrent++;\n\t\t}\n\t\tif(t+1==AandID.size()||AandID[t].first<AandID[t+1].first){\n\t\t\tanswer=max(answer,current);\n\t\t}\n\t}\n\tcout<<answer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint n , rk[123456];\n\nstruct base {\n    int w ;\n    bool used ;\n    int pos ; \n} rt[123456] ; \n\nint cmp(base x,base y) {\n    return x.w<y.w ; \n}\n\nint main() {\n    scanf( \"%d\" , &n ) ;\n    bool all0 = 0 ; \n    for ( int i = 1 ; i <= n ; i++ ) {\n\tscanf( \"%d\" , &rt[i].w ) ;\n\trt[i].pos = i ;\n\tall0 |= rt[i].w > 0 ;\n    }\n    \n    sort( rt+1 , rt+n+1 , cmp ) ;\n\n    for ( int i = 0 ; i <= n+1 ; i++ ) {\n\trt[i].used = false ;\n\trk[rt[i].pos] = i ;\n    }  \n\n    int ans = 0 , answer = all0 , getMore = 0 ; \n    \n    for ( int i = 1 ; i <= n ; i++ ) {\n\trt[i].used = true ; ans++ ;\n\tif ( rt[i].pos == 1 ) getMore++ ;\n\tif ( rt[i].pos == n ) getMore++ ; \t\n\tif ( rt[rk[rt[i].pos-1]].used ) {\n\t    ans-- ; \n\t}\n\tif ( rt[rk[rt[i].pos+1]].used ) {\n\t    ans-- ; \n\t}\n\tif ( rt[i+1].w > rt[i].w || i == n ) answer = max( answer , 1+ans-getMore ) ;\n    }\n\n    printf( \"%d\\n\" , answer ) ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> a(N+2);\n\ta[0] = 0;\n\tint a_num = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint b;\n\t\tcin >> b;\n\t\tif(a[a_num] != b){\n\t\t\ta_num++;\n\t\t\ta[a_num] = b;\n\t\t}\n\t}\n\ta.push_back(0);\n\tvector<int> kado;\n\tkado.push_back(0);\n\tfor (int i = 1; i < a.size()-1; i++)\n\t\tif ((a[i] > a[i-1] && a[i] > a[i+1]) ||\n\t\t\t(a[i] < a[i-1] && a[i] < a[i+1]))\n\t\t\tkado.push_back(a[i]);\n\tvector<int> mountain;\n\tvector<int> valley;\n\tfor (int i = 0; i < kado.size(); i++)\n\t\tif (i%2 == 1)\n\t\t\tmountain.push_back(kado[i]);\n\t\telse\n\t\t\tvalley.push_back(kado[i]);\n\tsort(kado.begin(), kado.end());\n\tsort(mountain.begin(), mountain.end());\n\tsort(valley.begin(),valley.end());\n\tint ans = 0, max = 0;\n\tif(kado.size() == 1){\n\t\tmax = 0;\n\t\tcout << max << endl;\n\t\treturn 0;\n\t}\n\tint m = 0, b = 0;\n\tfor(int i = 0; i < kado.size(); i ++){\n\t\tif (mountain[m] == kado[i]){\n\t\t\tm++;\n\t\t\tans--;\n\t\t}\n\t\tif (valley[b] == kado[i]){\n\t\t\tb++;\n\t\t\tans++;\n\t\t}\n\t\tif (kado[i] < kado[i+1])\n\t\t\tif (ans > max)max = ans;\n\t}\n\tcout << max << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n        ll n;\n        scanf(\"%lld\", &n);\n        vector<P> a(n);\n\n        ll prev = -1;\n        for(ll i=0; i<n; i++){\n                ll tmp;\n                scanf(\"%lld\", &tmp);\n                if(prev==tmp) n--, i--;\n                else a[i] = {tmp, 0};\n                prev = tmp;\n        }\n\n        if(n==1){\n                if(a[0].first==0)printf(\"%d\\n\", 0);\n                else printf(\"%d\\n\", 1);\n                return 0;\n        }\n\n        if(a[0]>a[1]) a[0].second = 1;\n        for(ll i=1; i<n-1; i++){\n                if(a[i-1]>a[i] && a[i]<a[i+1]) a[i].second = -1;\n                else if(a[i-1]<a[i] && a[i]>a[i+1]) a[i].second = 1;\n        }\n        if(a[n-2]<a[n-1]) a[n-1].second = 1;\n        sort(a.begin(), a.end(), greater<P>());\n\n        ll ans = 1, land = 0;\n        for(ll i=0; i<n; i++){\n                land += a[i].second;\n                if(i==n-1 || a[i].first!=a[i+1].first) ans = max(ans, land);\n        }\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint a[114514];\nint numcheck(int h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n   \n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n\n    }\n     if(N=1){\n        cout << 1 <<endl;\n    }\n    else{\n    int max = numcheck(0);\n    int n = numcheck(1);\n    int m = 1;\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(m);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <windows.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\ntypedef vector<vector<pair<int, int> > > vvp;\ntypedef vector<pair<int, int> > vp;\ntypedef vector<vector<int> > vvi;\ntypedef vector<int> vi;\ntypedef vector<vector<ll> > vvl;\ntypedef vector<ll> vl;\ntypedef vector<vector<double> > vvd;\ntypedef vector<double> vd;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef pair<string, int> psi;\ntypedef pair<int, int> pii;\n//#define unix ((unsigned int)time(NULL))\n#define rep(i,s,n) for(int i = (s); i < (n); i++)\n#define inputv(v) for(int i = 0; i < (v.size()); i++)cin>>v[i];\n#define inputvv(v) for(int i = 0; i < (v.size()); i++)for(int j=0;j<(v[0].size());j++)cin>>v[i][j];\n#define all(x) (x).begin(), (x).end()\n#define yn(f) cout <<(f?\"yes\":\"no\")<< endl\n#define YN(f) cout <<(f?\"YES\":\"NO\")<< endl\n#define Yn(f) cout <<(f?\"Yes\":\"No\")<< endl\n#define POSSIBLE(f) cout << ((f) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(f) cout << ((f) ? \"Possible\" : \"Impossible\"  ) << endl\n#define nil -1\n\nconst int inf8 = 1e8;\nconst int inf = 1e9+7;\nconst ll inf18 = 1e18;\nvoid puts() {\n\tcout << endl;\n}\ntemplate <class T>\nvoid puts(T a) {\n\tcout << (a) << endl;\n}\n/*\ntemplate <class Head, class... Tail>\nvoid puts(Head&& head, Tail&& ... tail) {\n\tcout << head;\n\tif (sizeof...(tail) == 0) {\n\t\tputs();\n\t}\n\telse {\n\t\tcout << \" \";\n\t\tputs(forward<Tail>(tail)...);\n\t}\n\n}\n*/\nvoid puts(pair<int, int> A) {\n\tcout << \"(\" << A.first << \",\" << A.second << \")\" << endl;;\n}\nvoid puts(vector<pair<int, int> >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tcout << \"(\" << A[i].first << \",\" << A[i].second << \")\";\n\t\tif (A.size() - 1 == i) {\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n}\nvoid puts(vector<vector<pair<int, int> > >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tputs(A[i]);\n\t}\n}\ntemplate <class T>\nvoid puts(vector<T>& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tcout << A[i];\n\t\tif (A.size() - 1 == i) {\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n}\ntemplate <class T>\nvoid puts(const vector<T>& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tcout << A[i];\n\t\tif (A.size() - 1 == i) {\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n}\ntemplate<class T>\nvoid puts(vector<vector<T> >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tputs(A[i]);\n\t}\n}\ntemplate<class T>\nvoid puts(const vector<vector<T> >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tputs(A[i]);\n\t}\n}\nclass disjoint_set {\npublic:\n\tvi p, rank;\n\tdisjoint_set(int size) {\n\t\tp.resize(size, 0);\n\t\trank.resize(size, 0);\n\t\tfor (int i = 0; i < size; i++)makeSet(i);\n\t}\n\tvoid makeSet(int x) {\n\t\tp[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y) {\n\t\treturn findSet(x) == findSet(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tlink(findSet(x), findSet(y));\n\t}\n\tvoid link(int x, int y) {\n\t\tif (rank[x] < rank[y]) {\n\t\t\tp[x] = y;\n\t\t}\n\t\telse {\n\t\t\tp[y] = x;\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tint findSet(int x) {\n\t\tif (x != p[x]) {\n\t\t\tp[x] = findSet(p[x]);\n\t\t}\n\t\treturn p[x];\n\t}\n};\nclass rmq {\npublic:\n\tint n, inf_, max_n;\n\tvi A;\n\trmq(int n_) {\n\t\tn = 1;\n\t\tinf_ = INT_MAX;\n\t\tmax_n = (1 << 18);\n\t\twhile (n < n_)n *= 2;\n\t\tA.resize(max_n * 2 - 1);\n\t\tfor (int i = 0; i < n * 2 - 1; i++)A[i] = inf_;\n\t}\n\tvoid update(int i, int x) {\n\t\ti += n - 1;\n\t\tA[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tA[i] = min(A[i * 2 + 1], A[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int left, int right, int i = 0, int left2 = 0, int right2 = -1) {\n\t\tif (right2 == -1)right2 = n;\n\t\tif (right2 <= left || right <= left2) {\n\t\t\treturn inf_;\n\t\t}\n\t\tif (left <= left2 && right2 <= right) {\n\t\t\treturn A[i];\n\t\t}\n\t\telse {\n\t\t\tint mid = (left2 + right2) / 2;\n\t\t\treturn min(query(left, right, i * 2 + 1, left2, mid), query(left, right, i * 2 + 2, mid, right2));\n\t\t}\n\t}\n};\nclass rsq {//遅延セグ木\npublic:\n\tint n, max_n;\n\tvl A, Lazy;\n\trsq(int n_) {\n\t\tn = 1;\n\t\tmax_n = (1 << 18);\n\t\twhile (n < n_)n *= 2;\n\t\tA.resize(max_n * 2 - 1);\n\t\tLazy.resize(max_n * 2 - 1);\n\t}\n\tvoid propagate(int i, int left, int right) {\n\t\tif (Lazy[i] != 0) {\n\t\t\tA[i] += Lazy[i];\n\t\t\tif (right - left > 1) {\n\t\t\t\tLazy[i * 2 + 1] += Lazy[i] / 2;\n\t\t\t\tLazy[i * 2 + 2] += Lazy[i] / 2;\n\t\t\t}\n\t\t\tLazy[i] = 0;\n\t\t}\n\t}\n\tvoid add(int left, int right, int x, int i = 0, int left2 = 0, int right2 = -1) {\n\t\tif (right2 == -1)right2 = n;\n\t\tpropagate(i, left2, right2);\n\t\tif (right <= left2 || right2 <= left) return;\n\n\t\tif (left <= left2 && right2 <= right) {\n\t\t\tLazy[i] += (right2 - left2) * x;\n\t\t\tpropagate(i, left2, right2);\n\n\t\t}\n\t\telse {\n\t\t\tint mid = (left2 + right2) / 2;\n\t\t\tadd(left, right, x, i * 2 + 1, left2, mid);\n\t\t\tadd(left, right, x, i * 2 + 2, mid, right2);\n\t\t\tA[i] = A[i * 2 + 1] + A[i * 2 + 2];\n\t\t}\n\n\t}\n\tll sum(int left, int right, int i = 0, int left2 = 0, int right2 = -1) {\n\t\tif (right2 == -1)right2 = n;\n\t\tif (right2 <= left || right <= left2) return 0;\n\t\tpropagate(i, left2, right2);\n\t\tif (left <= left2 && right2 <= right) {\n\t\t\treturn A[i];\n\t\t}\n\t\telse {\n\t\t\tint mid = (left2 + right2) / 2;\n\t\t\tll res = 0;\n\t\t\tres += sum(left, right, i * 2 + 1, left2, mid);\n\t\t\tres += sum(left, right, i * 2 + 2, mid, right2);\n\t\t\treturn res;\n\t\t}\n\t}\n};\nclass binary_indexed_tree {//1-indexed\npublic:\n\tint n;\n\tvl A;\n\tbinary_indexed_tree(int n_) {\n\t\tn = n_;\n\t\tA.resize(n + 1);//1-indexed\n\t}\n\tll sum(int i) {//[0,i]の和を返す\n\t\tll res = 0;\n\t\twhile (i > 0) {\n\t\t\tres += A[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn res;\n\t}\n\tvoid add(int i, int x) {\n\t\twhile (0 < i && i <= n) {\n\t\t\tA[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\nvoid dedupe(vi& A) {\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n}\nint gcd(int a, int b) {//log N\n\treturn (b == 0) ? a : gcd(b, a % b);\n}\nll gcd(ll a, ll b) {//log N\n\treturn (b == 0) ? a : gcd(b, a % b);\n}\nint lcm(int a, int b) {//log N\n\treturn (a * b) / gcd(a, b);\n}\nll lcm(ll a, ll b) {//log N\n\treturn (a * b) / gcd(a, b);\n}\nint extgcd(int a, int b, int& x, int& y) {// log N\n\tint d = a;\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\telse {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n\treturn d;\n}\nvi get_primes(int limit) {//N log N\n\tvb A(limit + 1, true);\n\tfor (int i = 2; i < A.size(); i++) {\n\t\tif (!A[i])continue;\n\t\tfor (int j = i * 2; j < A.size(); j += i)A[j] = false;\n\t}\n\tvi B;\n\tfor (int i = 2; i < A.size(); i++)\n\t{\n\t\tif (A[i])B.push_back(i);\n\t}\n\treturn B;\n}\ntemplate <class T>\nbool is_prime(T num) {// sqrt(N)\n\tif (num < 2)return false;\n\tfor (ll i = 2; i <= sqrt(num); i++)\n\t{\n\t\tif (num % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nll merge_count(vi & A) {//N log N\n\tconst int inf = 1000000007;\n\tint n = A.size();\n\tif (n <= 1)return 0;\n\tlong long count = 0;\n\tint mid = n / 2;\n\tvector<int> B(A.begin(), A.begin() + mid);\n\tvector<int> C(A.begin() + mid, A.end());\n\tcount += merge_count(B);\n\tcount += merge_count(C);\n\tB.push_back(inf);\n\tC.push_back(inf);\n\tint B_i = 0;\n\tint C_i = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (B[B_i] <= C[C_i]) {\n\t\t\tA[i] = B[B_i++];\n\t\t}\n\t\telse {\n\t\t\tcount += (n / 2) - B_i;\n\t\t\tA[i] = C[C_i++];\n\t\t}\n\t}\n\treturn count;\n}\nvi bit(int num, int size) {\n\tvi A;\n\tfor (int j = 0; j < size; j++)\n\t{\n\t\tif ((num & (1 << (size - j - 1))) > 0) {\n\t\t\tA.push_back(1);\n\t\t}\n\t\telse {\n\t\t\tA.push_back(0);\n\t\t}\n\t}\n\treturn A;\n}\nvvi bit_z(int size) {//2**N\n\tvvi A;\n\tfor (int i = 0; i < (1 << size); i++)\n\t{\n\t\tvi temp = bit(i, size);\n\t\tA.push_back(temp);\n\t}\n\treturn A;\n}\nvvi bit_z(int size, int n) {\n\tvvi A;\n\tint s = (1 << n) - 1;\n\tA.push_back(bit(s, size));\n\twhile (true) {\n\t\tint x = s & (-s);\n\t\tint y = s + x;\n\t\tint z = s & (~y);\n\n\t\tz /= x;\n\t\tz = z >> 1;\n\t\ts = (y | z);\n\t\tif (s >= (1 << size))break;\n\t\tA.push_back(bit(s, size));\n\t}\n\treturn A;\n}\nvvi bit_z(int size, int min, int max) {\n\tvvi A;\n\tfor (int i = min; i <= max; i++)\n\t{\n\t\tvvi B = bit_z(size, i);\n\t\tA.insert(A.end(), B.begin(), B.end());\n\t}\n\treturn A;\n}\nint random(int min, int max) {\n\tint r = rand() % (max + 1 - min) + min;\n\treturn r;\n}\nvector< pair < ll, int > > factorize(ll n) {\n\tll count = 0;\n\tvector< pair< ll, int > > res;\n\tfor (ll i = 2; i * i <= n; i++)\n\t{\n\t\tif (n % i)continue;\n\t\tres.push_back(make_pair(i, 0));\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tres.back().second++;\n\t\t}\n\t}\n\tif (n != 1)res.push_back(make_pair(n, 1));\n\treturn res;\n}\n\n\nsigned main() {\n\tint n; cin >> n;\n\tvi A(n); inputv(A);\n\tvi C;\n\trep(i, 0, n) {\n\t\tif (i == 0)C.push_back(A[i]);\n\t\telse {\n\t\t\tif (A[i - 1] == A[i])continue;\n\t\t\telse C.push_back(A[i]);\n\t\t}\n\t}\n\tn = C.size();\n\tvb B(n,false);//陸false 海true\n\tint len = 0;\n\trep(i, 0, n) {\n\t\tif (A[i] != 0)len = 1;\n\t}\n\tint ans = len;\n\tpriority_queue<pair<int,int> > P;\n\trep(i, 0, n) P.push(make_pair(-C[i],i));\n\t\n\trep(i, 0, n) {\n\t\tpii now = P.top();\n\t\tP.pop();\n\t\tB[now.second] = true;\n\t\tbool left = now.second > 0 ? B[now.second - 1] : true;\n\t\tbool right = now.second <n-1 ? B[now.second + 1] : true;\n\t\tif (left&&right) {\n\t\t\tlen--;\n\t\t}\n\t\telse if (!(left||right)) {\n\t\t\tlen++;\n\t\t}\n\t\tif (!(P.empty())&&P.top().first == now.first)continue;\n\t\tans = max(ans,len);\n\t}\n\tputs(ans);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nint N;\nint table[NUM];\nbool is_sea[NUM];\nvector<int> V,POS[NUM];\nmap<int,int> MAP;\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tint count = 0; //島の数\n\n\t//ダミー\n\tis_sea[0] = true;\n\tis_sea[N+1] = true;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tscanf(\"%d\",&table[i]);\n\n\t\tif(table[i] == 0){\n\n\t\t\tis_sea[i] = true;\n\n\t\t}else{\n\n\t\t\tis_sea[i] = false;\n\t\t\tV.push_back(table[i]);\n\t\t\tif(is_sea[i-1]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\t//座標圧縮\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tMAP[V[i]] = i;\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(table[i] == 0)continue;\n\n\t\tPOS[MAP[table[i]]].push_back(i); //陸地の場所をpushする\n\t}\n\n\tint ans = count;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tfor(int k = 0; k < POS[i].size(); k++){\n\n\t\t\tis_sea[POS[i][k]] = true;\n\t\t}\n\n\t\tfor(int k = 0; k < POS[i].size(); k++){ //該当する高さが海に沈む\n\n\t\t\tif(is_sea[POS[i][k]-1] == true && is_sea[POS[i][k]+1] == true){ //左右が既に海なら島減\n\n\t\t\t\tcount--;\n\t\t\t}else if(is_sea[POS[i][k]-1] == false && is_sea[POS[i][k]+1] == false){ //左右が島なら島増\n\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tans = max(ans,count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nこのコード、と～おれ!\nBe accepted!\n∧＿∧　\n（｡･ω･｡)つ━☆・*。\n⊂　　 ノ 　　　・゜+.\n　しーＪ　　　°。+ *´¨)\n 　　　　　　　　　.· ´¸.·*´¨) ¸.·*¨)\n\t\t  　　　　　　　　　　(¸.·´ (¸.·'* ☆\n\t\t\t\t\t*/\n\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <regex>\n#include <functional>\n#include <complex>\n#include <list>\n#include <cassert>\n#include <iomanip>\n#include <set>\n/*多倍長整数/cpp_intで宣言\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace boost::multiprecision;\n*/\n\n//#pragma gcc target (\"avx2\")\n//#pragma gcc optimization (\"o3\")\n//#pragma gcc optimization (\"unroll-loops\")\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, n) for(int i = 1; i <= (n); ++i)\n#define rep2(i, n) for(int i = 2; i < (n); ++i)\n#define repr(i, n) for(int i = n; i >= 0; --i)\n#define reprm(i, n) for(int i = n - 1; i >= 0; --i)\n#define printynl(a) printf(a ? \"yes\\n\" : \"no\\n\")\n#define printyn(a) printf(a ? \"Yes\\n\" : \"No\\n\")\n#define printYN(a) printf(a ? \"YES\\n\" : \"NO\\n\")\n#define printim(a) printf(a ? \"possible\\n\" : \"imposible\\n\")\n#define printdb(a) printf(\"%.50lf\\n\", a)//少数出力\n#define printdbd(a) printf(\"%.16lf\\n\", a)//少数出力(桁少なめ)\n#define prints(s) printf(\"%s\\n\", s.c_str())//string出力\n#define all(x) (x).begin(), (x).end()\n#define allsum(a, b, c) ((a + b) * c / 2)//等差数列の和、初項,末項,項数\n#define pb push_back\n#define priq priority_queue\n#define rpriq priq<int, vector<int>, greater<int>>\n#define deg_to_rad(deg) (((deg)/360.0)*2.0*PI)\n#define rad_to_deg(rad) (((rad)/2.0/PI)*360.0)\n#define Please return\n#define AC 0\n#define addf(T) [](T a, T b){return (a + b);}\n#define minf(T) [](T a, T b){return min(a, b);}\n#define maxf(T) [](T a, T b){return max(a, b);}\n\n\nusing ll = long long;\n\nconstexpr int INF = 1073741823;\nconstexpr int MINF = -1073741823;\nconstexpr ll LINF = ll(4661686018427387903);\nconstexpr ll MOD = 1000000007;\nconst long double PI = acos(-1.0L);\n\nusing namespace std;\n\nvoid scans(string& str) {\n\tchar c;\n\tstr = \"\";\n\tscanf(\"%c\", &c);\n\tif (c == '\\n')scanf(\"%c\", &c);\n\twhile (c != '\\n' && c != -1) {\n\t\tstr += c;\n\t\tscanf(\"%c\", &c);\n\t}\n}\n\nvoid scanc(char& str) {\n\tchar c;\n\tscanf(\"%c\", &c);\n\tif (c == -1)return;\n\twhile (c == '\\n') {\n\t\tscanf(\"%c\", &c);\n\t}\n\tstr = c;\n}\n\ndouble acot(double x) {\n\treturn PI / 2 - atan(x);\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll number1, ll number2) {\n\treturn number1 / gcd(number1, number2) * number2;\n}\n\nll LSB(ll n) { return (n & (-n)); }\n\n/*-----------------------------------------ここからコード-----------------------------------------*/\n\n\n\nint main() {\n\n\tll n;\n\tscanf(\"%lld\", &n);\n\tvector<ll> a(n + 100), b, c;\n\ta[0] = a[n + 2] = 0;\n\trep(i, n)scanf(\"%lld\", &a[i + 1]);\n\trep(i, n) {\n\t\tif ((a[i] <= a[i + 1] && a[i + 1] >= a[i + 2]) || (a[i] >= a[i + 1] && a[i + 1] <= a[i + 2]))c.pb(a[i + 1]);\n\t}\n\tif (c.empty()) {\n\t\tprintf(\"%d\\n\", !!a[1]);\n\t\tPlease AC;\n\t}\n\tif (c.back() != 0)c.pb(0);\n\tif(c[0] != 0)c.insert(c.begin(), 0);\n\tll siz = c.size();\n\tb = c;\n\tsort(all(b));\n\tb.erase(unique(all(b)), b.end());\n\trep(i, siz) {\n\t\tc[i] = distance(b.begin(), lower_bound(all(b), c[i]));\n\t}\n\t//ここまで座圧\n\tvector<ll> s(b.size());\n\trep(i, siz - 1) {\n\t\tll p = min(c[i], c[i + 1]), q = max(c[i], c[i + 1]);\n\t\tif (p == q)continue;\n\t\twhile (p < q) {\n\t\t\t++s[p];\n\t\t\t++p;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", (ll)*max_element(all(s)) >> 1LL);\n\n\tPlease AC;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repi(i,a,b) for(int i=int(a);i<(b);i++)\n#define all(x) x.begin(),x.end()\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tvector<int> a;\n\tint prev=0;\n\ta.push_back(1);\n\ta.push_back(0);\n\trep(i,n){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(x==prev)continue;\n\t\tprev=x;\n\t\ta.push_back(x);\n\t}\n\n\ta.push_back(0);\n\tn=a.size();\n\tvector<P> h;\n\trepi(i,1,n-1) h.push_back(P(a[i],i));\n\tsort(all(h));\n\n\tint ans=0,cnt=0,height=-1;\n\trep(i,n){\n\t\tif(h[i].first!=height){\n\t\t\tans=max(ans,cnt);\n\t\t\theight=h[i].first;\n\t\t}\n\t\tint pos=h[i].second;\n\t\tif(a[pos-1]>height && height < a[pos+1]) cnt++;\n\t\tif(a[pos-1]<height && height > a[pos+1]) cnt--;\n\t\ta[pos]=-1;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;i<(n);i++)\n#define rrep(i,n) for(int (i)=1;i<=(n);i++)\n#define REP(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define MOD 1000000007\n#define INF 1e18\n#define int long long\n#define endl \"\\n\"\n#define yorn(f) puts((f)?\"Yes\":\"No\")\n#define YORN(f) puts((f)?\"YES\":\"NO\")\ntypedef long long ll;\ntypedef pair<int, int> P;\nint gcd(int a,int b){return b?gcd(b,a%b):a;};\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nint mod(int a,int b){return (a+b-1)/b;};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N],const T &val){std::fill((T*)array,(T*)(array+N),val);}\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;};\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;};\n\nint n;\nvector<int> a;\nvector<P> b;\n\nsigned main() {\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\t\n\tcin >> n;\n\tint prev = -1;\n\trep(i, n) {\n\t\tint A;\n\t\tcin >> A;\n\t\tif(A != prev) {\n\t\t\ta.push_back(A);\n\t\t\tb.push_back(P(A, b.size()));\n\t\t\tprev = A;\n\t\t}\n\t}\n\tsort(all(b), greater<>());\n\tif(a.size() == 1) {\n\t\tif(a[0] == 0) cout << 0 << endl;\n\t\telse cout << 1 << endl;\n\t\treturn 0;\n\t} \n\n\tint ans = 1;\n\tint now = 0;\n\t\n\trep(i, b.size()) {\n\t\tint id = b[i].second;\n\t\tif(id == 0) {\n\t\t\tif(a[id] > a[id + 1]) now++;\n\t\t} else if(id == a.size() - 1) {\n\t\t\tif(a[id - 1] < a[id]) now++;\n\t\t} else {\n\t\t\tif(a[id - 1] < a[id] && a[id] > a[id + 1]) now++;\n\t\t\tif(a[id - 1] > a[id] && a[id] < a[id + 1]) now--;\n\t\t}\n\t\tif(i == b.size() - 1 || b[i].first != b[i + 1].first) {\n\t\t\tchmax(ans, now);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\n int ma;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m == n){\n        if (h == 0){\n            ma = n;\n        }\n        n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){ma = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    ma = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(ma < n){\n            ma = n;\n            \n        }\n        m ++;\n        cout <<ma<<endl;\n        n = numcheck(c[m]);\n\n\n    }\n    }\n    cout << ma << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nbool A[100000 + 10];\n\nint main()\n{\n\tint N;\n\tstd::multimap<int, std::vector<int>, std::greater<int>> M;\n\n\tstd::cin >> N;\n\n\tint h;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tstd::cin >> h;\n\t\tif (M.count(h) == 0)\n\t\t{\n\t\t\tM.insert(std::make_pair(h, std::vector<int>()));\n\t\t}\n\t\tauto it = M.find(h);\n\t\t(it->second).push_back(i + 1);\n\t}\n\n\t\n\tint ans = 0;\n\tif (M.size() > 1 || M.count(0) == 0)\n\t{\n\t\tint count = 0;\n\n\t\tfor (auto it : M)\n\t\t{\n\t\t\tfor (auto p : it.second)\n\t\t\t{\n\t\t\t\tA[p] = true;\n\t\t\t\tif (!A[p - 1] && !A[p + 1]) ++count;\n\t\t\t\telse if (A[p - 1] && A[p + 1]) --count;\n\t\t\t}\n\t\t\tans = std::max(ans, count);\n\t\t}\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n    int N = 0;\n    cin >> N;\n\n    vector<pair<int, int>> nihon;\n    vector<bool> isShima(N + 2);\n    int count = 0;\n    int maxCount = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        int num = 0;\n        cin >> num;\n        nihon.push_back(make_pair(-num, i));\n    }\n\n    stable_sort(nihon.begin(), nihon.end());\n\n    if (nihon[0].first != 0) {\n        for (int i = 0; i < N; ++i) {\n            isShima[nihon[i].second] = true;\n            if (!isShima[nihon[i].second - 1] && !isShima[nihon[i].second + 1]) {\n                count++;\n            }\n            else if (isShima[nihon[i].second - 1] && isShima[nihon[i].second + 1]) {\n                count--;\n            }\n            if (nihon[i].first != nihon[i + 1].first) maxCount = max(maxCount, count);\n        }\n    }\n\n    cout << maxCount << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n\nint GetMinMax(const int line, const std::vector<int>& height)\n{\n\tint result = 0;\n\tfor (int index = 0; height.size() - 1 > index; ++index)\n\t{\n\t\tif (height[index] > line && height[index + 1] <= line)\n\t\t{\n\t\t\tresult += 1;\n\t\t}\n\t}\n\tif (line < height.back())\n\t{\n\t\tresult += 1;\n\t}\n\treturn result;\n}\n\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tstd::vector<int> height;\n\tint max = 0;\n\tfor (int count = 0; num > count; ++count)\n\t{\n\t\tstd::cin >> buff;\n\t\theight.emplace_back(buff);\n\t\tif (max < height.back())\n\t\t{\n\t\t\tmax = height.back();\n\t\t}\n\t}\n\tint max_num = 0;\n\tfor (int line = 0; max > line; ++line)\n\t{\n\t\tint result = GetMinMax(line, height);\n\t\tif (max_num < result)\n\t\t{\n\t\t\tmax_num = result;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<unordered_map>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tint pre = 0;\n\tstd::unordered_map<int, short> count;\n\tstd::cin >> pre;\n\tfor (int c = 0; num - 1 > c; ++c)\n\t{\n\t\tstd::cin >> buff;\n\t\tif (pre > buff)\n\t\t{\n\t\t\tfor (int h = buff; h < pre; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t\tpre = buff;\n\t}\n\tfor (int h = buff - 1; h > 0; --h)\n\t{\n\t\tcount[h] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (auto itr = count.begin(); count.end() != itr; ++itr)\n\t{\n\t\tif (max_num < itr->second)\n\t\t{\n\t\t\tmax_num = itr->second;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> B;\n    vector<int> A;\n\n    int prev = -1;\n    for (int i = 0; i < N; ++i) {\n        int a; cin >> a;\n        if (a != prev) {\n            B.push_back(make_pair(a, B.size())); // B は index も付け加える\n            A.push_back(a);\n            prev = a;\n        }\n    }\n\n    sort(B.begin(), B.end(), greater<pair<int, int>>());\n    \n    if(A.size() == 1) {\n        if(A[0] > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    else {\n        int res = 1;\n        int cur = 0;\n        int prev = 0;\n        for(int i = 0; i < B.size(); i++) {\n            int id = B[i].second;\n\n            if(id == 0) {\n                if(A[id] > A[id+1]) cur++;\n            }\n            else if(id == A.size() -1) {\n                if(A[id-1] < A[id]) cur++;\n            }\n            else {\n                if(A[id-1] <= A[id] && A[id] > A[id+1]) cur++;\n                else if(A[id-1] > A[id] && A[id] <= A[id+1]) cur--;\n            }\n            if(i == (int)B.size() - 1 || B[i].first != B[i+1].first) {\n                res = max(res, cur);\n                prev = B[i].first;\n            }\n        }\n        cout << res << endl;\n    }\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> xs(n);\n    for (auto& x : xs) std::cin >> x;\n    xs.insert(xs.begin(), 0);\n    xs.push_back(0);\n\n    int m;\n    {\n        auto nxs = xs;\n        std::sort(nxs.begin(), nxs.end());\n        nxs.erase(std::unique(nxs.begin(), nxs.end()), nxs.end());\n        m = nxs.size();\n\n        std::map<int, int> revx;\n        for (int i = 0; i < m; ++i) {\n            revx[nxs[i]] = i;\n        }\n\n        for (auto& x : xs) x = revx[x];\n    }\n\n    std::vector<bool> fall(n + 2, false);\n    std::vector<std::vector<int>> pos(m);\n    for (int i = 0; i <= n + 1; ++i) {\n        pos[xs[i]].push_back(i);\n    }\n\n    int ans = 0, sum = 0;\n    for (const auto& v : pos) {\n        for (auto i : v) {\n            fall[i] = true;\n            if (i + 1 <= n + 1 && !fall[i + 1]) ++sum;\n            if (i - 1 >= 0 && fall[i - 1]) --sum;\n        }\n\n        ans = std::max(ans, sum);\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nP pp[100000];\nint main(void)\n{\n\tint n,a[100002],i,j,cnt,mx,p1,flg,x,y;\n\tscanf(\"%d\",&n);\n\ta[0]=0;\ta[n+1]=0;\n\tfor(i=1;i<=n;i++)\tscanf(\"%d\",&a[i]);\n\tflg=0;\n\tfor(i=0;i<=n+1;i++)\t{\n\t\tif(a[i]!=0)\t{\n\t\t\tflg=1;\tbreak;\n\t\t}\n\t}\n\tx=0;\n\twhile(a[x]==0)\tx++;\n\ty=n+1;\n\twhile(a[y]==0)\ty--;\n//\tprintf(\"%d %d\\n\",x,y);\n\ti=x;\tp1=0;\n\twhile(i<=y)\t{\n\t\tj=i+1;\n\t\twhile(a[j]==a[i])\tj++;\n\t\tif(a[i-1]>a[i] && a[j]>a[i])\t{\n\t\t\tpp[p1].first=a[i];\t\n\t\t\tpp[p1].second=1;\n\t\t\tp1++;\n//\t\t\tprintf(\"%d 1\\n\",i);\n\t\t}\n\t\tif(a[i-1]<a[i] && a[j]<a[i])\t{\n\t\t\tpp[p1].first=a[i];\n\t\t\tpp[p1].second=-1;\n\t\t\tp1++;\n//\t\t\tprintf(\"%d -1\\n\",i);\n\t\t}\n\t\ti=j;\n\t}\n\tsort(pp,pp+p1);\n//\tfor(i=0;i<p1;i++)\tprintf(\" %d %d\\n\",pp[i].first,pp[i].second);\n\tcnt=1;\tmx=cnt;\n\tfor(i=0;i<p1;i++)\t{\n\t\tcnt+=pp[i].second;\n\t\tif(i!=p1-1 && pp[i+1].first!=pp[i].first)\t{\n\t\t\tmx=max(mx,cnt);\n\t\t}\n\t}\n\tif(flg==0)\tmx=0;\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<map>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tint pre = 0;\n\tstd::map<int, int> count;\n\tstd::cin >> pre;\n\tfor (int c = 0; num - 1 > c; ++c)\n\t{\n\t\tstd::cin >> buff;\n\t\tif (pre > buff)\n\t\t{\n\t\t\tcount[pre] -= 1;\n\t\t\tcount[buff] += 1;\n\t\t}\n\t\tpre = buff;\n\t}\n\tcount[pre] -= 1;\n\tcount[0] += 1;\n\t\n\tint max_num = 0;\n\tint current_num = 0;\n\tfor (auto itr = count.begin(); count.end() != itr; ++itr)\n\t{\n\t\tcurrent_num += itr->second;\n\t\tif (max_num < current_num)\n\t\t{\n\t\t\tmax_num = current_num;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint a[114514];\nint numcheck(int h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n   \n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n\n    }\n     if(N==1){\n        cout << 1 <<endl;\n    }\n    else{\n    int max = numcheck(0);\n    int n = numcheck(1);\n    int m = 1;\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(m);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, x) for(ll i = 0; i < x; i++)\n#define all(a) (a).begin(),(a).end()\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nconst ll INF = 1000000000000000000;\nconst ll mod = 1000000007;\nconst ld pi = 3.141592653589793238;\n\nll test[1234567], imos[12345678];\nsigned main() {\n\tll n, ans = 0; cin >> n; map<ll, ll> m;\n\tvector<ll> high, v;\n\tll cnt = 0;\n\trep(i, n) {\n\t\tcin >> test[i];\n\t\tif (test[i] != 0) { cnt++; }\n\t}\n\tif (cnt == 0) { cout << 0 << endl; return 0; }\n\trep(i, n) {\n\t\tcnt = 0;\n\t\tif (i != 0 && i != n - 1) {\n\t\t\tif (test[i - 1] != test[i] && test[i] != test[i + 1]) {\n\t\t\t\tif (max(test[i - 1], max(test[i], test[i + 1])) == test[i]) {\n\t\t\t\t\thigh.push_back(test[i]); v.push_back(test[i]); cnt++;\n\t\t\t\t}\n\t\t\t\telse if (min(test[i - 1], min(test[i], test[i + 1])) == test[i]) {\n\t\t\t\t\thigh.push_back(test[i]); v.push_back(test[i]); cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\thigh.push_back(test[i]); v.push_back(test[i]); cnt++;\n\t\t}\n\t\tif (cnt == 0) {//選ばれてない\n\t\t\ttest[i] = test[i - 1];\n\t\t}\n\t}\n\tsort(all(v)); n = high.size();\n\tll z = 1;\n\trep(i, n) {\n\t\tif (m[v[i]] == 0) {\n\t\t\tm[v[i]] = z; z += 2;\n\t\t}\n\t}\n\trep(i, n) {\n\t\thigh[i] = m[high[i]];\n\t\t//cout << high[i] << ' ';\n\t}\n\t//cout << endl;\n\trep(i, n) {\n\t\tif (i != 0 && i != n - 1) {\n\t\t\tif (high[i - 1] > high[i] && high[i] < high[i + 1]) {\n\t\t\t\timos[high[i]] += 2; imos[high[i - 1]]--; imos[high[i + 1]]--;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1000000) {\n\t\tif (i != 0) { imos[i] += imos[i - 1]; ans = max(ans, (imos[i] / 2) + 1); }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    int N;\n\tcin >> N;\n\tint A[100000];\n\tA[0] = 0;\n\tA[N+1] = 0;\n\tfor(int i=1; i<N+1; i++){\n\t\tcin >> A[i];\n\t}\n\tvector<pair<int,bool>> delta;\n\tint tmp = 0;\n\tbool downup = true;\n\tfor(int i=1; i<N+1; i++){\n\t\tif(downup == false && tmp < A[i]){//下がってる最中なのにA[i]のほうが大きい\n\t\t\tdelta.push_back(MP(tmp, false));\n\t\t\tdownup = true;\t\t\t\n\t\t}\n\t\telse if(downup == true && tmp > A[i]){\n\t\t\tdelta.push_back(MP(tmp, true));\n\t\t\tdownup = false;\n\t\t}\n\t\ttmp = A[i];\n\t}\n\tif(downup==true) delta.push_back(MP(tmp, true));\n\tdelta.push_back(MP(0, false));\n\tsort(delta.begin(), delta.end());\n\treverse(delta.begin(), delta.end());\n\n\tint ans = 0;\n\tint now = 0;\n\tfor(int i=0; i<delta.size(); i++){\n\t\tif(delta[i].second == true) now++;\n\t\telse now--;\n\t\tif(i==delta.size()-1 || delta[i].first!=delta[i+1].first) ans = max(ans, now);\n\t}\n\tcout << ans << endl;\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL=unsigned int;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nint main(){\n UL N; scanf(\"%u\",&N);\n UL A[100000]; rep(i,N) scanf(\"%u\",&A[i]);\n vector<pair<UL,int>> Q;\n Q.push_back({0,2});\n Q.push_back({A[0],-1});\n Q.push_back({A[N-1],-1});\n rep(i,N-1){\n  UL a=A[i], b=A[i+1];\n  if(a>b) swap(a,b);\n  Q.push_back({a,1});\n  Q.push_back({b,-1});\n }\n sort(Q.begin(),Q.end());\n int ans=0;\n int sim=0;\n for(auto q:Q){\n  sim += q.second;\n  ans = max(ans,sim);\n }\n printf(\"%d\\n\",ans/2);\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> a(N);\n    for(int i = 0;i < N;i++){\n        cin >> a[i];\n    }\n    vector<pair<int, int>> all;\n    for(int i = 0;i < N;i++){\n        all.emplace_back(-a[i], i);\n    }\n    sort(all.begin(), all.end());\n    vector<bool> used(N);\n    int cnt = 0, res = 0;\n    for(int i = 0;i < N;){\n        int v = all[i].first;\n        if(v == 0) break;\n        while(all[i].first == v){\n            int id = all[i].second;\n            ++i;\n            ++cnt;\n            cnt -= (id + 1 < N && used[id + 1]);\n            cnt -= (0 <= id - 1 && used[id - 1]);\n            used[id] = true;\n        }\n        res = max(res, cnt);\n    }\n    cout << res << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<pair<int, int>> v;\n    for(int i = 0; i < n; i++)\n    {\n        int x; cin >> x;\n        v.push_back(make_pair(x, i + 1));\n    }\n    sort(v.begin(), v.end(), greater<pair<int, int>>());\n    vector<int> used(n + 2, 0);\n    int ans, cnt = 0;\n    for(int i = 0; i < n; i++)\n    {\n        int pos = i;\n        while(v[pos].first == v[i].first)\n        {\n            int u = v[i].second;\n            used[u] = true;\n            cnt++;\n            if(used[u + 1]) cnt--;\n            if(used[u - 1]) cnt--;\n            i++;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> a(N+2);\n    a[0] = 0;\n    int anum = 0;\n    for (int i = 1; i <= N; i++)\n      {\n\tlong long int b;\n        cin >> b;\n\tif(a[anum] != b){\n\t  anum++;\n\t  a[anum] = b;\n\t}\n\n      }\n   a.push_back(0);\n    vector<long long int> kado;\n    kado.push_back(0);\n    for (int i = 1; i < a.size()-1; i++)\n        if ((a[i] > a[i-1] && a[i] > a[i+1]) ||\n            (a[i] < a[i-1] && a[i] < a[i+1]))\n            kado.push_back(a[i]);\n    // for(int i =0 ; i < kado.size(); i++)cout << kado[i] << endl;\n    vector<long long int> mountain;\n    vector<long long int> valley;\n    for (int i = 0; i < kado.size(); i++)\n        if (i%2 == 1)\n            mountain.push_back(kado[i]);\n        else\n            valley.push_back(kado[i]);\n    sort(kado.begin(), kado.end());\n    sort(mountain.begin(), mountain.end());\n    sort(valley.begin(),valley.end());\n    int ans = 0, max = 0;\n    if(kado.size() == 1){\n      max = 0;\n      cout << max << endl;\n      return 0;\n    }\n    int m = 0, b= 0;\n    for(int i = 0; i < kado.size(); i ++){\n      if(mountain[m] == kado[i]){\n\tm++;\n\tans--;\n      }\n      if(valley[b] == kado[i]){\n\tb++;\n\tans++;\n      }\n      if(kado[i] < kado[i+1]){\n\tif(ans > max)max = ans;\n      }\n    }\n    cout << max << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\nint main(void){\n    int A[100001];\n    int tani[50001], ts[50001];\n    int yama[50001], ys[50001];\n    int jjj[100001][4];\n    int poy[50001][2];\n    int pot[50001][2];\n    int N, i, l, j=0, t=0, w = 0, f = 0, lt, ly, llt, lly, a;\n    char m = 'L';\n    int hw = 0, lh = 1000000000,wl,wh,vmax;\n\n    cin >> N;\n    for(l=0; l < N; l++) {\n        cin >> i;\n        if (i < t) {\n            if(m == 'H') {\n                A[j++] = t;\n                m = 'L';\n                t = i;\n            } else t = i;\n        } else if(i > t) {\n            if(m == 'L') {\n                A[j++] = t;\n                m = 'H';\n                t = i;\n            } else t = i;\n        } else {    ;   }\n    }\n    if(m == 'H') {\n        A[j++] = i;     // last one write\n        A[j++] = 0;     // last sea write\n    } else {\n        A[j++] = 0;     // last sea write\n    }\n    for(i = 0, lt=0;i < j; i += 2,lt++){\n        if(hw < A[i]) hw = A[i]; \n        ts[lt] = tani[lt] = A[i];\n//        cout << \"ts : \" << ts[lt] << endl; \n    }\n    for(i = 1, ly=0;i < j; i += 2,ly++){\n        if(lh > A[i]) lh = A[i];\n        ys[ly] = yama[ly] = A[i]; \n//        cout << \"ys : \" << ys[ly] << endl; \n    }\n    A[j++] = 0;\n    sort(ys, ys+ly);\n    sort(ts, ts+lt);\n// uniq\n    lly = ly - 1, llt = lt -1;\n    wl = i = 0;\n    poy[i][1] = 1; poy[i][0] = wl = ys[lly--]; \n    while(lly >= 0) {\n        if (wl == ys[lly]) {\n            poy[i][1]++;\n            lly--;\n//            cout << \"poy : \" << poy[i][1] << endl; \n        } else {\n            i++;\n            poy[i][1] = 1;\n            poy[i][0] = wl = ys[lly--];\n        }\n    }\n    i++;\n    poy[i][0] = poy[i][1] = 0;\n    lly = i;\n    wl = i = 0;\n    pot[i][1] = 1; pot[i][0] = wl = ts[llt--];\n    while(llt >= 0) {\n        if (wl == ts[llt]) {\n            pot[i][1]++;\n            llt--;\n//            cout << \"pot : \" << pot[i][1] << endl; \n        } else {\n            i++;\n            pot[i][1] = 1;\n            pot[i][0] = wl = ts[llt--];\n        }\n    }\n    i++;\n    pot[i][0] = pot[i][1] = 0;\n    llt = i;\n//marge + count\n    i = l = a = 0;\n    int sums = 0;\n    while(poy[i][0] != 0) {\n        if(poy[i][0] == pot[l][0]) {\n            jjj[a][0] = poy[i][0];\n            jjj[a][1] = poy[i++][1];\n            jjj[a][2] = pot[l++][1];\n        } else if(poy[i][0] < pot[l][0]) {\n            jjj[a][0] = pot[l][0];\n            jjj[a][1] = 0;\n            jjj[a][2] = pot[l++][1];\n        } else if(poy[i][0] > pot[l][0]) {\n            jjj[a][0] = poy[i][0];\n            jjj[a][1] = poy[i++][1];\n            jjj[a][2] = 0;\n        }\n        jjj[a][3] = sums += (jjj[a][1] - jjj[a][2]);\n//        cout << jjj[a][0] << \" \" << jjj[a][3] << \" \" << jjj[a][1] << \" \" << jjj[a][2] <<endl;\n        a++;\n    }\n    vmax = 0;\n    while(a > 0) {\n        a--;\n        if (vmax < jjj[a][3]) vmax = jjj[a][3];\n//        cout << jjj[a][0] << \" \" << jjj[a][3] << \" \" << jjj[a][1] << \" \" << jjj[a][2] <<endl;\n    }\n    cout << vmax << endl;\n\n/*\n    wh = max(lh, hw) + 1;\n    w = wl = min(lh, hw) -1;\n    while(1) {\n        int e = 0, c = j, s = 1000000000;\n        while(c > 0) {\n            c--;\n            if(A[c] > w) {\n                if(A[c] < s) s = A[c];\n                if(A[c+1] <= w) e++;\n            }\n        }\n        if(e > f) f = e;\n        if(w > wh) break;\n\n        w = s;\n    }\n    cout << f << endl;\n*/\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    if(N == 1){cout << 1 << endl}else{\n    sort (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\tvector<int> a(n + 2, 0);\n\tvector<pair<int, int> > cnt(n, { 0,0 });\n\tbool flag = false;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t\tif (a[i]) flag = true;\n\t}\n\tif (flag) {\n\t\tint tmp = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (a[i - 1] > a[i]) {\n\t\t\t\twhile (i != n && a[i] == a[i + 1]) i++;\n\t\t\t\tif (i != n + 1 && a[i] < a[i + 1]) cnt[tmp++] = make_pair(a[i], 1);\n\t\t\t}\n\t\t\tif (a[i - 1] < a[i]) {\n\t\t\t\t//if (a[i - 1] == 0) cnt[tmp++] = make_pair(0, 1);\n\t\t\t\twhile (i != n && a[i] == a[i + 1]) i++;\n\t\t\t\tif (a[i] > a[i + 1]) cnt[tmp++] = make_pair(a[i], -1);\n\t\t\t}\n\t\t}\n\t\tsort(cnt.begin(), cnt.end());\n\t\tint sum = 1, ans = 1;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tsum += cnt[i].second;\n\t\t\tans = max(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t} else cout << 0 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nint main(){\n\tll n, i, e, k, j, ans, isl, d;\n\t\n\tcin>>n;\n\t\n\tvector <pair <ll, ll> > b(n+1);\n\tvector <bool> sink(n+2);\n\t\n\tb[0].first=0;\n\tb[0].second=0;\n\tsink[0]=true;\n\tisl=0;\n\tfor(i=1; i<=n; i++){\n\t\tcin>>b[i].first;\n\t\tb[i].second=i;\n\t\tsink[i]=false;\n\t\tif(b[i].first>0) isl=1;\n\t}\n\tsink[n+1]=true;\n\t\n\tsort(b.begin(), b.end());\n\t\n\tans=0;\n\tfor(i=1;i<b.size();i++){\n\t\tif(b[i].first!=b[i-1].first) ans=max(ans, isl);\n\t\td=b[i].second;\n\t\tsink[d]=true;\n\t\tif(sink[d-1]+sink[d+1]==0) isl++;\n\t\t\telse if(sink[d+1]+sink[d-1]==2) isl--;\n\t}\n\t\n\tcout<<max(ans, isl)<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){cout << 1 << endl;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    int max = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << c[m] <<endl;\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<unordered_map>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tint pre = 0;\n\tstd::unordered_map<int, int> count;\n\tstd::cin >> pre;\n\tfor (int c = 0; num - 1 > c; ++c)\n\t{\n\t\tstd::cin >> buff;\n\t\tif (pre > buff)\n\t\t{\n\t\t\tfor (int h = buff; h < pre; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t\tpre = buff;\n\t}\n\tfor (int h = pre - 1; h >= 0; --h)\n\t{\n\t\tcount[h] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (auto itr = count.begin(); count.end() != itr; ++itr)\n\t{\n\t\tif (max_num < itr->second)\n\t\t{\n\t\t\tmax_num = itr->second;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<unordered_map>\nint main(int, char**)\n{\n\tint num = 0;\n\tstd::cin >> num;\n\tint buff = 0;\n\tint pre = 0;\n\tstd::unordered_map<int, int> count;\n\tstd::cin >> pre;\n\tfor (int c = 0; num - 1 > c; ++c)\n\t{\n\t\tstd::cin >> buff;\n\t\tif (pre > buff)\n\t\t{\n\t\t\tfor (int h = buff; h < pre; ++h)\n\t\t\t{\n\t\t\t\tcount[h] += 1;\n\t\t\t}\n\t\t}\n\t\tpre = buff;\n\t}\n\tfor (int h = buff - 1; h > 0; --h)\n\t{\n\t\tcount[h] += 1;\n\t}\n\t\n\tint max_num = 0;\n\tfor (auto itr = count.begin(); count.end() != itr; ++itr)\n\t{\n\t\tif (max_num < itr->second)\n\t\t{\n\t\t\tmax_num = itr->second;\n\t\t}\n\t}\n\tstd::cout << max_num << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint n , rk[123456];\n\nstruct base {\n    int w ;\n    int used ;\n    int pos ; \n} rt[123456] ; \n\nint cmp(base x,base y) {\n    return x.w<y.w ; \n}\n\nint main() {\n    scanf( \"%d\" , &n ) ;\n    bool all0 = 0 ; \n    for ( int i = 1 ; i <= n ; i++ ) {\n\tscanf( \"%d\" , &rt[i].w ) ;\n\trt[i].pos = i ;\n\tall0 |= rt[i].w > 0 ;\n    }\n    \n    sort( rt+1 , rt+n+1 , cmp ) ;\n\n    for ( int i = 0 ; i <= n+1 ; i++ ) {\n\trt[i].used = -1 ;\n\trk[rt[i].pos] = i ;\n    }  \n\n    int ans = 0 , answer = all0 , getMore = 0 ; \n    \n    for ( int i = 1 ; i <= n ; i++ ) {\n\trt[i].used = i ; ans++ ;\n\tif ( rt[i].pos == 1 ) getMore++ ;\n\tif ( rt[i].pos == n ) getMore++ ; \t\n\tif ( rt[rk[rt[i].pos-1]].used != -1 ) {\n\t    ans-- ; \n\t}\n\tif ( rt[rk[rt[i].pos+1]].used != -1 ) {\n\t    ans-- ; \n\t}\n\tif ( rt[i+1].w > rt[i].w || i == n ) answer = max( answer , 1+ans-getMore ) ;\n    }\n\n    printf( \"%d\\n\" , answer ) ;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int(i) = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int(i) = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define pb push_back\n#define MP(a, b) make_pair((a), (b))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N, 0);\n    rep(i, N) cin >> A[i];\n    vector<int> B;\n    B.pb(0);\n    rep(i, A.size() - 1) {\n        if(A[i] != A[i + 1])\n            B.pb(A[i]);\n    }\n    B.pb(A[N - 1]);\n    B.pb(0);\n    N = B.size() - 2;\n    map<int, vector<int>> idx;\n    rep(i, N) { idx[B[i + 1]].pb(i + 1); }\n    int cnt = 0;\n    rep(i, N) {\n        if(B[i + 1] > 0 && B[i + 2] == 0)\n            cnt++;\n    }\n    int res = cnt;\n    for(auto x : idx) {\n        if(x.first == 0)\n            continue;\n        for(auto y : x.second) {\n            if(B[y] < B[y + 1] && B[y] < B[y - 1])\n                cnt++;\n            else if(B[y] > B[y + 1] && B[y] > B[y - 1])\n                cnt--;\n        }\n        res = max(res, cnt);\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\n int ma;\nvector<long> a(100000);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        int m = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n                m++;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n            \n        }\n    if(m == n){ma=n;n = 0;}\n    //cout << m <<\" \"<<n << \" \";\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    //cout << \"runnning\" << endl;\n    if(N == 1){ma = 1;}else{\n    sort (c.begin() , c.end());\n    c.erase(unique(c.begin(), c.end()), c.end());\n    /*\n    for(auto it = c.begin(); it != c.end(); it++){\n        cout << *it;\n    };\n    cout << endl;\n    */\n    ma = numcheck(0);\n    int m = 0;\n    int n = numcheck(c[m]);\n    while(n > 0){\n        //cout << n << \" \" << max <<endl;\n        if(ma < n){\n            ma = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n\n    }\n    }\n    cout << ma << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef pair<long, int>P;\n\nint main(void){\n    int num;    cin >> num;\n    long sectionHeight[num];\n    \n    int count = 1;\n    cin >> sectionHeight[0];\n    int prev;\n    for(int i = 1; i < num; i++){\n        cin >> prev;\n        if(sectionHeight[count - 1] != prev){\n            sectionHeight[count] = prev;\n            count++;\n        }\n    }\n    num = count;\n    P p[num];\n    for(int i = 0; i < num; i++){\n        p[i].first = sectionHeight[i];\n        p[i].second = i;\n    }\n    sort(p, p + num);\n    int cnt = 0;\n    int ans = 0;\n    if(num > 1){\n        for(int i = num-1; i >= 0; i--){\n            if(p[i].second == 0){\n                if(sectionHeight[p[i].second + 1]<sectionHeight[p[i].second])   cnt++;\n            }else if(p[i].second == num - 1){\n                if(sectionHeight[p[i].second - 1]<sectionHeight[p[i].second])   cnt++;\n            }else{\n                if(sectionHeight[p[i].second - 1]>sectionHeight[p[i].second] && sectionHeight[p[i].second + 1]>sectionHeight[p[i].second])  cnt--;\n                else if(sectionHeight[p[i].second - 1]<sectionHeight[p[i].second] && sectionHeight[p[i].second + 1]<sectionHeight[p[i].second]) cnt++;\n            }\n            \n            if(i != 0){\n                if(p[i - 1].first != p[i].first)    ans = (ans >= cnt) ? ans : cnt;\n            }else ans = (ans >= cnt) ? ans : cnt;\n        }\n    }\n    else{\n        if(p[0].first > 0)  ans++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing pint = pair<int, int>;\n\nint main() {\n    int N; cin >> N;\n    vector<pint> B;\n    vector<int> A;\n    \n    // A[i] = A[i+1] みたいなところは 1 つの点に圧縮する\n    int prev = -1;\n    for (int i = 0; i < N; ++i) {\n        int a; cin >> a;\n        if (a != prev) {\n            B.push_back(pint(a, B.size())); // B は index も付け加える\n            A.push_back(a);\n            prev = a;\n        }\n    }\n    sort(B.begin(), B.end(), greater<pint>());\n    \n    // 折れ線の折れ曲がりがない場合は例外\n    if (A.size() == 1) {\n        if (A[0] > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    else {\n        // 上から順番に走査していく\n        int res = 1;\n        int cur = 0;\n        for (int i = 0; i < B.size(); ++i) {\n            int id = B[i].second;\n            \n            if (id == 0) {\n                if (A[id] > A[id+1]) ++cur;\n            }\n            else if (id == A.size() - 1) {\n                if (A[id-1] < A[id]) ++cur;\n            }\n            else {\n                if (A[id-1] < A[id] && A[id] > A[id+1]) ++cur;\n                else if (A[id-1] > A[id] && A[id] < A[id+1]) --cur;\n            }\n\n            // 同一高さに複数の「山頂」や「谷底」がある場合は、その高さの処理をすべて終えてから更新する\n            if (i == (int)B.size() - 1 || B[i].first != B[i+1].first) {\n                res = max(res, cur);\n                prev = B[i].first;\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<long> a(114514);\nint numcheck(long h){\n    //島の数を水位によって出力します\n        vector<int> b(N);\n        int n = 0;\n        for(int i = 0;i < N;i++){\n            if (a[i] - h > 0){\n                b[i] = 1;\n            }\n            else{\n                b[i] = 0;\n            }\n        }\n        if (b[0] == 1) n++;\n        for(int i = 1;i<N;i++){\n            if (b[i] == 1 && b[i-1] == 0){\n                n++;\n            }\n        }\n    return n;\n}\nint main(){\n    cin >> N;\n    vector <long> c(N);\n    for(int i = 0;i < N ;i++){\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    \n    sort (c.begin() , c.end());\n    int max = numcheck(0);\n    int m = 1;\n    int n = numcheck(c[m]);\n    while(n != 0){\n        if(max < n){\n            max = n;\n        }\n        m ++;\n        n = numcheck(c[m]);\n    }\n    cout << max << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst long long INF = numeric_limits<long long>::max();\ntypedef long long ll;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    vector<pair<int, int>> memo(n);\n    rep(i,n){\n        cin >> a[i];\n        memo[i] = make_pair(a[i], i);\n    }\n    sort(memo.begin(), memo.end());\n    bool land_flag = false;\n    int cnt = 0;\n    rep(i,n){\n        if (a[i] != 0){\n            if (!land_flag){\n                cnt++;\n                land_flag = true;\n            }\n        }\n        else land_flag = false;\n    }\n    int ans = cnt;\n    rep(i,n-1){\n        int sec_no = memo[i].second;\n        a[sec_no] = 0;\n        if (memo[i].first == 0) continue;\n\n        /* 左端の場合 */\n        if (sec_no == 0){\n            if (a[sec_no+1] == 0) cnt--;\n        }\n        /* 右端の場合 */\n        else if (sec_no == n-1){\n            if (a[sec_no-1] == 0) cnt--;\n        }\n        /* それ以外 */\n        else{\n            if ( (a[sec_no-1] == 0) && (a[sec_no+1] == 0) ) cnt--; \n            else if ( (a[sec_no-1] > 0) && (a[sec_no+1] > 0) ) cnt++; \n        }\n        if (memo[i].first != memo[i+1].first)\n            ans = max(cnt, ans);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<pair<int, int>> v;\n    for(int i = 0; i < n; i++)\n    {\n        int x; cin >> x;\n        v.push_back(make_pair(x, i + 1));\n    }\n    sort(v.begin(), v.end(), greater<pair<int, int>>());\n    vector<int> used(n + 2, 0);\n    int ans = 0, cnt = 0;\n    for(int i = 0; i < n; i++)\n    {\n        int pos = i;\n        if(v[i].first == 0) break;\n        while(v[pos].first == v[i].first)\n        {\n            int u = v[pos].second;\n            if(used[u]) break;\n            used[u] = true;\n            cnt++;\n            if(used[u + 1]) cnt--;\n            if(used[u - 1]) cnt--;\n            pos++;\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN=1e5+10;\nint N;\nbool visited[MAXN];\nint heights[MAXN];\nint indices[MAXN];\n\nint dx[]={1,-1};\n\nint main(){\n    scanf(\"%d\",&N);\n    for(int i=1;i<=N;i++){\n        scanf(\"%d\",heights+i);\n        indices[i]=i;\n    }\n\n    sort(\n        indices+1,\n        indices+N+1,\n        [](auto fst,auto snd){return heights[fst]<heights[snd];}\n    );\n\n    int top=N;\n    int ans=0;\n    int islandcount=0;\n\n    while(top>=1&&heights[indices[top]]!=0){\n        int oldtop=top;\n        while(top>=1&&heights[indices[top]]==heights[indices[oldtop]]) top--;\n\n        for(int i=top+1;i<=oldtop;i++){\n            int cur=indices[i];\n\n            int neighborcount=0;\n            visited[cur]=true;\n            for(int j=0;j<2;j++){\n                int next=cur+dx[j];\n                if (next<1||next>N||!visited[next]) continue;\n                neighborcount++;\n            }\n\n            if (neighborcount==0) islandcount++;\n            else if (neighborcount==2) islandcount--; \n\n        }\n\n        ans=max(ans,islandcount);\n\n    }\n\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, A[101010];\nint up[101010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i];\n\n\tmap<int, vector<int>> buf;\n\trep(i, 0, N) if(0 < A[i]) buf[A[i]].push_back(i);\n\n\tint ans = 0;\n\tint tot = 0;\n\tfor (auto ite = buf.rbegin(); ite != buf.rend(); ite++)\n\t{\n\t\tauto v = ite->second;\n\n\t\tfore(i, v) {\n\t\t\tup[i] = true;\n\n\t\t\tint yoko = 0;\n\t\t\tif (0 < i and up[i - 1]) yoko++;\n\t\t\tif (i + 1 < N and up[i + 1]) yoko++;\n\n\t\t\tif (yoko == 0) tot++;\n\t\t\telse if (yoko == 2) tot--;\n\t\t}\n\n\t\tchmax(ans, tot);\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n// Union-Find\nstruct UF {\n\tint n, c;\n\tvector<int> p;\n\n\tUF(int n): n(n), c(n), p(n, -1) {}\n\n\t// xが属する集合とyが属する集合の併合\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (p[x] > p[y]) swap(x, y);\n\t\tp[x] += p[y];\n\t\tp[y] = x;\n\t\tc--;\n\t\treturn true;\n\t}\n\t\n\t// xが属する集合の親\n\tint find(int x) { return (p[x] < 0 ? x : p[x] = find(p[x])); }\n\n\t// xとyが同一の集合に属するか判定\n\tbool same(int x, int y) { return find(x) == find(y); }\n\n\t// xが属する集合の大きさ\n\tint size(int x) { return -p[find(x)]; }\n\t\n\t// 連結成分の個数\n\tint count() { return c; }\n};\n\nint N;\nint A[100010];\npair<int, int> ps[100010];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N;\n    bool zero = true;\n    REP(i, N) {\n        cin >> A[i];\n        ps[i] = {A[i], i};\n        zero &= (A[i] == 0);\n    }\n    sort(ps, ps + N);\n    reverse(ps, ps + N);\n    int h = -1;\n    UF uf(N);\n    int ans = 0;\n    REP(i, N) {\n        if (ps[i].first != h) {\n            ans = max(ans, uf.count() - N + i);\n            h = ps[i].first;\n        }\n        int p = ps[i].second;\n        if (p - 1 >= 0 && A[p - 1] >= ps[i].first) uf.unite(p - 1, p);\n        if (p + 1 < N && A[p + 1] >= ps[i].first) uf.unite(p + 1, p);\n    }\n    if (ps[N - 1].first > 0) ans = max(ans, uf.count());\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define Max(a,b) a>b?a:b\n\nint main(int argc, char *argv[]){\n\n\tint i;\n\tint count=0;\n\tint max_count=0;\n\tint n;\n\tint *a;\n\n\tscanf(\"%d\",&n);\n\ta=calloc(n,sizeof(int));\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\n\tdo{\n\t\tcount=0;\n\t\t//if(a[0]>0)a[0]--;\n\t\tfor(i=1;i<n-1;i++){\n\t\t\t//if(a[i]>0)a[i]--;\n\t\t\tif(a[i]==0 && a[i-1]!=0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t//if(a[n-1]>0)a[n-1]--;\n\t\tif(a[n-1]>0 || (a[n-1]==0 && a[n-2]!=0))count++;\n\t\tmax_count=Max(max_count,count);\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(a[i]>0)a[i]--;\n\t\t}\n\t}while(count>0);\n\n\tprintf(\"%d\\n\",max_count);\n\texit(0);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include \"stdlib.h\"\n\n#define MAXN 100000\n\ntypedef uint bool;\n\ntypedef struct{\n    uint height;//海拔\n    uint index;//序号\n    bool hasProbed;//记录其是否被检查过\n}area,*areaptr;\n\n\ntypedef struct {\n    areaptr *content;\n    size_t len;\n}max_heap;\n\nstatic area input[MAXN];\nstatic size_t N;\n\nvoid new_max_heap(size_t len,area input[len],max_heap* out){\n    out->content=(areaptr*)malloc(sizeof(areaptr)*len);\n    out->len=len;\n\n    for (uint i=0;i<len;i++) out->content[i]=input+i;\n\n    for (uint i=len;i>=1;i--){\n\n        //TODO 修正健堆\n        for(uint cur=i;cur<=len;){\n            uint cur_height=out->content[cur-1]->height;\n            uint left_child=cur*2,right_child=left_child+1;\n\n            if(right_child<=len){\n                uint max_index=out->content[left_child-1]->height>out->content[right_child-1]->height?left_child:right_child;\n                if(out->content[max_index-1]->height>=out->content[cur-1]->height){\n                    areaptr temp=out->content[cur-1];\n                    out->content[cur-1]=out->content[max_index-1];\n                    out->content[max_index-1]=temp;\n                    cur=max_index;\n                }else{\n                    break;\n                }\n            }else if (left_child<=len){\n                //若左子节点海拔高\n                if(out->content[left_child-1]->height>=out->content[cur-1]->height){\n                    areaptr temp=out->content[cur-1];\n                    out->content[cur-1]=out->content[left_child-1];\n                    out->content[left_child-1]=temp;\n                    cur=left_child;\n                }else{\n                    break;\n                }\n            }else\n                break;\n        }\n    }\n}\n\nareaptr get_max(max_heap* self){\n    return self->content[0];\n}\n\nareaptr extract_max(max_heap* self){\n    areaptr ret=self->content[0];\n\n    //交换首位\n    self->content[0]=self->content[--self->len];\n\n    uint cur=1;\n    while(cur<self->len){\n        uint left_child=cur*2,right_child=left_child+1;\n\n        if(right_child<=self->len){\n            uint max_index=self->content[left_child-1]->height>self->content[right_child-1]->height?left_child:right_child;\n            if(self->content[max_index-1]->height>=self->content[cur-1]->height){\n                areaptr temp=self->content[cur-1];\n                self->content[cur-1]=self->content[max_index-1];\n                self->content[max_index-1]=temp;\n                cur=max_index;\n            }else{\n                break;\n            }\n        }else if (left_child<=self->len){\n            //若左子节点海拔高\n            if(self->content[left_child-1]->height>=self->content[cur-1]->height){\n                   areaptr temp=self->content[cur-1];\n                   self->content[cur-1]=self->content[left_child-1];\n                   self->content[left_child-1]=temp;\n                   cur=left_child;\n            }else{\n                break;\n            }\n        }else{\n            break;//当前节点没有子节点时则结束\n        }\n\n\n    }\n\n    return ret;\n}\n\nvoid show_heap(max_heap* self){\n    for (int i=0;i<self->len;i++)\n        printf(\"%d \",self->content[i]->height);\n}\n\nbool is_empty(max_heap* self){\n    return self->len==0;\n}\n\n//TODO:处理全岛均在海平线之下的情况\nint main() {\n    max_heap heap;\n    uint max_island_num=0,cur_island_num=max_island_num;\n\n    //获得输入，并初始化堆\n    scanf(\"%lu\",&N);\n\n    for(uint i=0;i<N;i++) {\n        uint height;\n        scanf(\"%u\",&height);\n        input[i].height=height;\n        input[i].index=i;\n        input[i].hasProbed=0;\n    }\n\n    if(N==1){\n        if(input[0].height==0)\n            puts(\"0\");\n        else\n            puts(\"1\");\n        return 0;\n    }\n\n    //以下均建立在N不为1的基础上\n    new_max_heap(N,input,&heap);\n\n    //根据海拔从高到低扫描扫描各区域\n    while(!is_empty(&heap)){\n        //当前拓展的登高线高度\n        uint current_height=get_max(&heap)->height;\n\n        if (current_height==0)\n            break;\n\n        //对当前等高线进行扫描,以更新岛屿数\n        while(!is_empty(&heap)&&current_height==get_max(&heap)->height){\n            areaptr cur_area=extract_max(&heap);\n            uint cur_index=cur_area->index;\n\n            //printf(\"%d \",cur_index);\n\n            //若当前区域在最左侧\n            if(cur_index==0){\n                if(!input[cur_index+1].hasProbed)\n                    cur_island_num++;\n            }else if(cur_index==N-1){\n                if(!input[cur_index-1].hasProbed)\n                    cur_island_num++;\n            }else{\n                if(input[cur_index+1].hasProbed==input[cur_index-1].hasProbed)\n                    if(input[cur_index+1].hasProbed)//若两侧均检查过\n                        cur_island_num--;\n                    else\n                        cur_island_num++;\n            }\n\n            cur_area->hasProbed=1;\n        }\n\n        max_island_num=max_island_num<cur_island_num?cur_island_num:max_island_num;\n\n    }\n\n    printf(\"%u\\n\",max_island_num);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define max(X, Y) ((X) > (Y) ? (X) : (Y))\n \ntypedef long long ll;\ntypedef struct {\n    ll indx, height;\n} Pair;\n \nint cmp(const Pair *x, const Pair *y);\n \nll n;\nll is_island[100005];\nPair p[100005];\n \nint main()\n{\n    ll island_nums;\n    ll ans;\n    ll i;\n \n    scanf(\"%lld\", &n);\n    for (i = 1; i <= n; i++) {\n        scanf(\"%lld\", &p[i].height);\n        p[i].indx = i;\n    }\n \n    qsort(p + 1, n, sizeof(Pair), (int (*)(const void *, const void *))cmp);\n \n    p[0].height = -1;\n    p[n + 1].height = -1;\n     \n \n    island_nums = 0;\n    ans = 0;\n    i = 1;\n    while (i <= n) {\n \n        do {\n            if (p[i].height > 0) {\n                ll indx = p[i].indx;\n                is_island[indx] = 1;\n \n                if (is_island[indx - 1] && is_island[indx + 1]) {\n                    island_nums--;\n                } else if (!is_island[indx - 1] && !is_island[indx + 1]) {\n                    island_nums++;\n                }\n            }\n \n            i++;\n        } while(p[i].height == p[i - 1].height);\n \n        ans = max(island_nums, ans);\n    }\n \n    printf(\"%lld\\n\", ans);\n \n    return 0;\n}\n \nint cmp(const Pair *x, const Pair *y)\n{\n    if (x->height > y->height) {\n        return -1;\n    } else if (x->height == y->height) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct asumikana {\n\tint idx, value;\n};\n\nint cmp(const void* x, const void* y) {\n\tint a = ((const struct asumikana*)x)->value;\n\tint b = ((const struct asumikana*)y)->value;\n\treturn a < b ? -1 : a > b;\n}\n\nint N;\nint A[114514];\n\nint recCount;\nint rec[114514];\nstruct asumikana tomatu[114514];\n\nint main(void) {\n\tint i;\n\tint answer = 0, current;\n\tint pos;\n\tif (scanf(\"%d\", &N) != 1) return 1;\n\tfor (i = 0; i < N; i++) {\n\t\tif (scanf(\"%d\", &A[i]) != 1) return 1;\n\t}\n\trecCount = 1;\n\trec[0] = 0;\n\ttomatu[0].idx = 0;\n\ttomatu[0].value = 0;\n\tfor (i = 0; i < N; i++) {\n\t\tif (A[i] != rec[recCount - 1]) {\n\t\t\trec[recCount] = A[i];\n\t\t\ttomatu[recCount].idx = recCount;\n\t\t\ttomatu[recCount].value = A[i];\n\t\t\trecCount++;\n\t\t}\n\t}\n\tif (rec[recCount - 1] != 0) {\n\t\trec[recCount] = 0;\n\t\ttomatu[recCount].idx = recCount;\n\t\ttomatu[recCount].value = 0;\n\t\trecCount++;\n\t}\n\tqsort(tomatu, recCount, sizeof(*tomatu), cmp);\n\tcurrent = recCount > 1 ? 1 : 0;\n\tpos = 0;\n\twhile (pos < recCount && tomatu[pos].value == 0) {\n\t\tif (tomatu[pos].idx != 0 && tomatu[pos].idx != recCount - 1) current++;\n\t\tpos++;\n\t}\n\tanswer = current;\n\tfor (i = pos; i < recCount; ) {\n\t\tint sumipe = tomatu[i].value;\n\t\twhile (i < recCount && tomatu[i].value == sumipe) {\n\t\t\t\n\t\t\tif (rec[tomatu[i].idx - 1] > sumipe && sumipe < rec[tomatu[i].idx + 1]) current++;\n\t\t\telse if (rec[tomatu[i].idx - 1] < sumipe && sumipe > rec[tomatu[i].idx + 1]) current--;\n\t\t\ti++;\n\t\t}\n\t\tif (current > answer) answer = current;\n\t}\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0655 Japan Sinks\n// 2019.3.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//// 入力の高速化\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()  // 非負整数の入力\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n\n//// セグメント木\n#define MAX (1<<17) //セグメント木のサイズ。2のべき乗にすべし\n#define MIN(a, b)  ((a)<=(b)?(a):(b))\n#define INF  0x7fffffff\n\nint segMin[2 * MAX], segAdd[2 * MAX];\n\n// 区間[a, b)に値xを加算する\n// int k = 0, int l = 0, int r = MAX\nvoid add(int a, int b, int x, int k, int l, int r)\n{\n\tif (r <= a || b <= l) return;\n\n\tif (a <= l && r <= b) {\n\t\tsegAdd[k] += x;\n\t\treturn;\n\t}\n\tadd(a, b, x, (k << 1) + 1, l, (l + r) >> 1);\n\tadd(a, b, x, (k << 1) + 2, (l + r) >> 1, r);\n\tsegMin[k] = MIN(segMin[(k << 1) + 1] + segAdd[(k << 1) + 1], segMin[(k << 1) + 2] + segAdd[(k << 1) + 2]);\n}\n\n//  int k = 0, int l = 0, int r = MAX\nint getMin(int a, int b, int k, int l, int r)\n{\n\tint le, ri;\n\n\tif (r <= a || b <= l) return INF;\n\tif (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n\tle = getMin(a, b, (k << 1) + 1, l, (l + r) >> 1);\n\tri = getMin(a, b, (k << 1) + 2, (l + r) >> 1, r);\n\treturn MIN(le, ri) + segAdd[k];\n}\n\n\n//// 座標圧縮\n// ソート済データのユニーク化（=重複データを取り除く）\n//　　　データの個数、ソート済データ配列\nint uniq(int n, int *a)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i + 1;\t// ユニーク化後のデータ個数。データは元の配列に格納\n}\n\n// バイナリサーチ\n//    ソート済データ配列、探したいデータ、上限位置（わからなければ、データ配列の大きさでOK）\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n\twhile (l < r) {\n\t\tm = (l + r) >> 1;\n\t\tif (a[m] < x) l = m + 1; else r = m;\n\t}\n\treturn l;        // データ配列での位置\n}\n\n// C言語標準装備のクイックソート用比較関数。整数(int)配列を昇順にソート\nint cmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n\n// 座標圧縮の本体\n// 　　圧縮した新しいデータ、データ数、１次元データ配列\nint compact(int n, int *a)\n{\n\tint i, j, k;\n\tint *memo;\n\n\tif ((memo = malloc(sizeof(int)*n)) == NULL) return 0;    // メモリ確保に失敗\n\tmemcpy(memo, a, sizeof(int)*n);\n\tqsort(memo, n, sizeof(int), cmp);\n\tk = uniq(n, memo);\n\tfor (i = 0; i < n; i++) {\n\t\tj = bsch(memo, a[i], k);\n\t\ta[i] = j;\n\t}\n\tfree(memo);\n\treturn 1;    // 正常終了時\n}\n\n\n//// 本問題関連\nint A[100005]; int N;         // 入力データ\nint stack[100005]; int top;   // スタック\n\nint main()\n{\n\tint i;\n\n\tN = in();\n\tfor (i = 1; i <= N; i++) A[i] = in();\n\tA[0] = A[N + 1] = 0;     // 両側の外に0をつけて、余計なことを考えずに済む\n\tN += 2;\n\n\tcompact(N, A);   // 座標が大きすぎるので、圧縮しておく。最大値が10万以下になる。\n//for (i = 0; i < N; i++) printf(\"%d \", A[i]); printf(\"\\n\");\n\n\t// 定番のスタックを使い、上下の変化を記録。\n\t// 上がったところの高さをスタックにしまい、下がったところでスタックのトップにある\n\t// 高さとの空間をセグメント木に -1 として追加する。\n\t// -1とした理由は最大値を取るため。用意したセグメント木は最小値にしか対応していないので。\n\ttop = 0; for (i = 1; i < N; i++) {\n\t\tif (A[i - 1] > A[i]) add(A[i], stack[--top], -1, 0, 0, N);\n\t\tif (A[i-1] != A[i]) stack[top++] = A[i];\n\t}\n\n\tprintf(\"%d\\n\", -getMin(0, N, 0, 0, N));  // 最小値を最大値に変える\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define Max(a,b) a>b?a:b\n\nint main(int argc, char *argv[]){\n\n\tint i;\n\tint count=0;\n\tint max_count=0;\n\tint n;\n\tint *a;\n\n\tscanf(\"%d\",&n);\n\ta=calloc(n,sizeof(int));\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\n\tdo{\n\t\tcount=0;\n\t\tif(a[0]>0)a[0]--;\n\t\tfor(i=1;i<n-1;i++){\n\t\t\tif(a[i]>0)a[i]--;\n\t\t\tif(a[i]==0 && a[i-1]!=0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(a[n-1]>0)a[n-1]--;\n\t\tif(a[n-1]>0)count++;\n\t\tmax_count=Max(max_count,count);\n\t}while(count>0);\n\n\tprintf(\"%d\\n\",max_count);\n\texit(0);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define Max(a,b) a>b?a:b\n\nint main(int argc, char *argv[]){\n\n\tint i;\n\tint count=0;\n\tint max_count=0;\n\tint n;\n\tint *a;\n\n\tscanf(\"%d\",&n);\n\ta=calloc(n,sizeof(int));\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\n\tdo{\n\t\tcount=0;\n\t\tif(a[0]>0)a[0]--;\n\t\tfor(i=1;i<n-1;i++){\n\t\t\tif(a[i]>0)a[i]--;\n\t\t\tif(a[i]==0 && a[i-1]!=0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(a[n-1]>0)a[n-1]--;\n\t\tif(a[n-1]>0)count++;\n\t\tmax_count=Max(max_count,count);\n\t}while(count>0);\n\n\tprintf(\"%d\\n\",max_count);\n\texit(0);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define Max(a,b) a>b?a:b\n\nint main(int argc, char *argv[]){\n\n\tint i;\n\tint count=0;\n\tint max_count=0;\n\tint n;\n\tint *a;\n\n\tscanf(\"%d\",&n);\n\ta=calloc(n,sizeof(int));\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\n\tdo{\n\t\tcount=0;\n\t\tif(a[0]>0)a[0]--;\n\t\tfor(i=1;i<n-1;i++){\n\t\t\tif(a[i]>0)a[i]--;\n\t\t\tif(a[i]==0 && a[i-1]!=0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(a[n-1]>0)a[n-1]--;\n\t\tif(a[n-1]>0 || (a[n-1]==0 && a[n-2]!=0))count++;\n\t\tmax_count=Max(max_count,count);\n\t}while(count>0);\n\n\tprintf(\"%d\\n\",max_count);\n\texit(0);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define max(X, Y) ((X) > (Y) ? (X) : (Y))\n\ntypedef long long ll;\ntypedef struct {\n\tll indx, height;\n} Pair;\n\nint cmp(const Pair *x, const Pair *y);\n\nll n;\nll is_island[100005];\nPair p[100005];\n\nint main()\n{\n\tll island_nums;\n\tll ans;\n\tll i;\n\n\tscanf(\"%lld\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &p[i].height);\n\t\tp[i].indx = i;\n\t}\n\n\tqsort(p + 1, n, sizeof(Pair), (int (*)(const void *, const void *))cmp);\n\n\tp[0].height = -1;\n\tp[n + 1].height = -1;\n\t\n\n\tisland_nums = 0;\n\tans = 0;\n\ti = 1;\n\twhile (i <= n) {\n\n\t\tdo {\n\t\t\tif (p[i].height > 0) {\n\t\t\t\tll indx = p[i].indx;\n\t\t\t\tis_island[indx] = 1;\n\n\t\t\t\tif (is_island[indx - 1] && is_island[indx + 1]) {\n\t\t\t\t\tisland_nums--;\n\t\t\t\t} else if (!is_island[indx - 1] && !is_island[indx + 1]) {\n\t\t\t\t\tisland_nums++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t} while(p[i].height == p[i - 1].height);\n\n\t\tans = max(island_nums, ans);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n\nint cmp(const Pair *x, const Pair *y)\n{\n\tif (x->height > y->height) {\n\t\treturn -1;\n\t} else if (x->height == y->height) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "\n\nclass UnionFind(val size: Int) {\n    private val vec = IntArray(size){-1}\n    fun find(a: Int): Int {\n        return if (vec[a] < 0) a else find(vec[a]).also{vec[a] = it}\n    }\n    fun same(a: Int, b: Int): Boolean {\n        return find(a) == find(b)\n    }\n    fun unite(a: Int, b: Int): Unit {\n        val ar = find(a)\n        val br = find(b)\n        if (ar == br) return\n        if (vec[ar] < vec[br]) {\n            vec[ar] += vec[br]\n            vec[br] = ar\n        }else {\n            vec[br] += vec[ar]\n            vec[ar] = br\n        }\n    }\n}\n\nfun main(args: Array<String>?) {\n    val n = readLine()!!.toInt()\n    val values = readLine()!!.trim().split(' ').map(String::toInt) + 0\n    val sorted = values.indices.sortedByDescending(values::get)\n    val uft = UnionFind(n)\n    var prev = -1\n    var current = 0\n    var max = 0\n    for (i in sorted) {\n        if (prev != values[i])\n            max = java.lang.Math.max(max, current)\n        if (values[i] == 0) break\n        ++current\n        if (i - 1 >= 0 && values[i - 1] >= values[i] && !uft.same(i, i - 1)) {\n            --current\n            uft.unite(i, i - 1)\n        }\n        if (i + 1 < n && values[i + 1] >= values[i] && !uft.same(i, i + 1)) {\n            --current\n            uft.unite(i, i + 1)\n        }\n        prev = values[i]\n    }\n    println(max)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n    private static class Pair implements Comparable<Pair> {\n        int first, second;\n        private Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        @Override\n        public int compareTo(Pair p) {\n            if (first == p.first) {\n                return second - p.second;\n            } else {\n                return first - p.first;\n            }\n        }\n    }\n\n    private final static int MAXN = 100000;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        ArrayList<Pair> pairs = new ArrayList<>();\n        boolean[] flag = new boolean[n + 2];\n\n        flag[0] = flag[n + 1] = false;\n        for (int i = 1; i <= n; ++i) {\n            flag[i] = true;\n        }\n\n        boolean zero = true;\n        for (int i = 0; i < n; ++i) {\n            int a = scanner.nextInt();\n            pairs.add(new Pair(a, i + 1));\n            if (a != 0) {\n                zero = false;\n            }\n        }\n\n        if (zero) {\n            System.out.println(0);\n            return;\n        }\n\n        Collections.sort(pairs);\n\n        int max = 1, count = 1, iter = 0;\n        for (Pair p: pairs) {\n            if (p.first != iter) {\n                max = Math.max(max, count);\n                iter = p.first;\n            }\n\n            flag[p.second] = false;\n            if (flag[p.second - 1] && flag[p.second + 1]) {\n                ++count;\n            } else if (!flag[p.second - 1] && !flag[p.second + 1]) {\n                --count;\n            }\n        }\n        max = Math.max(max, count);\n\n        System.out.println(max);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {  //含まれていない場合\n\t\t\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);  //位置を記録\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\t\tSystem.out.println(l);\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\t\t\n\t\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tList<Long> o = new LinkedList<>(orthometric);\n\t\tint count = 1;\n\t\tfor (long s : sea) {\n\t\t\tfor (int i : seaLevel.get(s)) {\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=o.size()-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((o.get(i-1)!=-1)&&(o.get(i+1)!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((o.get(i-1)==-1)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(i!=o.size()-1)) {\n\t\t\t\t\tif (o.get(i+1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i!=0)&&(i==o.size()-1)) {\n\t\t\t\t\tif (o.get(i-1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t}\n\t\t\t\to.set(i, -1l);\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\nclass Main {\n\n\tstatic List<Long> orthometric = new LinkedList<Long>();\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {\n\t\t\t\t\torthometric.add(a);\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {\n\t\t\t\t\t\tList<Integer> list = new LinkedList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tLong[] oArray = new Long[orthometric.size()];\n\t\torthometric.toArray(oArray);\n\t\tint count = 1;\n\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\tfor (int i : l) {\n\t\t\t\tif ((i!=0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif ((oArray[i-1]!=-1)&&(oArray[i+1]!=-1)) count++;\n\t\t\t\t\telse if ((oArray[i-1]==-1)&&(oArray[i+1]==-1)) count--;\n\t\t\t\t} else if ((i==0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif (oArray[i+1]==-1) count--;\n\t\t\t\t} else if ((i!=0)&&(i==oArray.length-1)) {\n\t\t\t\t\tif (oArray[i-1]==-1) count--; \n\t\t\t\t}\n\t\t\t\toArray[i] = -1l;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\tlong[] orthometric = new long[len];  //海抜\n\t\t\tSet<Long> sea = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tsea.add(0l);  //最初は0から始まる\n\t\t\tint pointer = 0;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[pointer] = a;  //海抜を読み込み\n\t\t\t\t\tsea.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tint first = 0;\n\t\t\tboolean first_flag = false;\n\t\t\tfor (long i : sea) {\n\t\t\t\tint count = 0;\n\t\t\t\tboolean landflag = false;\n\t\t\t\tfor (int j=first; j<pointer; j++) {\n\t\t\t\t\tif (orthometric[j]>i) {  //陸地であれば\n\t\t\t\t\t\tif (!first_flag) {\n\t\t\t\t\t\t\t first = j;  //先頭が沈没した場合次からスキップできる\n\t\t\t\t\t\t\t first_flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlandflag = true;  //flag起動\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (landflag) {  //ここまでが一つの島\n\t\t\t\t\t\t\tlandflag = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (landflag) count++;  //最後まで島だったら+1\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {  //含まれていない場合\n\t\t\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);  //位置を記録\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for (List<Integer> l : seaLevel.values()) System.out.println(l);\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\n\t\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\t//List<Long> o = new LinkedList<>(orthometric);\n\t\tLong[] oArray = new Long[orthometric.size()];\n\t\torthometric.toArray(oArray);\n\t\tint count = 1;\n\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\t//Integer[] array = new Integer[l.size()];\n\t\t\t//l.toArray(array);\n\t\t\tfor (int i : l) {\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=oArray.length-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((oArray[i-1]!=-1)&&(oArray[i+1]!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((oArray[i-1]==-1)&&(oArray[i+1]==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif (oArray[i+1]==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i!=0)&&(i==oArray.length-1)) {\n\t\t\t\t\tif (oArray[i-1]==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t}\n\t\t\t\toArray[i] = -1l;  //沈没させる\n\t\t\t}\n\t\t\t//System.out.println(\"count: \" + count);\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {  //含まれていない場合\n\t\t\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);  //位置を記録\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\t\t\n\t\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tList<Long> o = new LinkedList<>(orthometric);\n\t\tint count = 1;\n\t\tfor (long s : sea) {\n\t\t\tfor (int i : seaLevel.get(s)) {\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=o.size()-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((o.get(i-1)!=-1)&&(o.get(i+1)!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((o.get(i-1)==-1)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(i!=o.size()-1)) {\n\t\t\t\t\tif (o.get(i+1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i!=0)&&(i==o.size()-1)) {\n\t\t\t\t\tif (o.get(i-1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t}\n\t\t\t\to.set(i, -1l);\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\tstatic List<Long> orthometric = new LinkedList<Long>();\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {\n\t\t\t\t\torthometric.add(a);\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {\n\t\t\t\t\t\tList<Integer> list = new LinkedList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tLong[] oArray = new Long[orthometric.size()];\n\t\torthometric.toArray(oArray);\n\t\tint count = 1;\n\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\tfor (int i : l) {\n\t\t\t\tif ((i!=0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif ((oArray[i-1]!=-1)&&(oArray[i+1]!=-1)) count++;\n\t\t\t\t\telse if ((oArray[i-1]==-1)&&(oArray[i+1]==-1)) count--;\n\t\t\t\t} else if ((i==0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif (oArray[i+1]==-1) count--;\n\t\t\t\t} else if ((i!=0)&&(i==oArray.length-1)) {\n\t\t\t\t\tif (oArray[i-1]==-1) count--; \n\t\t\t\t}\n\t\t\t\toArray[i] = -1l;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num>0) {\n\t\t\t\t//System.out.println();\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\t\tint max = findLand(0, land);\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\n\t\t\tint count = 0;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\tnewLand[0] = j[0];\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]==sea[pointer]) {  //沈んだら\n\t\t\t\t\t\tif ((k!=j[0])) {  //最初ではなかったら\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLand[0] = k+1;  //新しい島がスタート\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (orthometric[j[1]-1]!=sea[pointer]) { //最後まで島だったら\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\t//static int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\t//System.out.println();\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tList<Long> o = new LinkedList<>(orthometric);\n\t\tint count = 1;\n\t\tfor (long s : sea) {\n\t\t\t//System.out.println(\"SeaLevel:   \" + s);\n\t\t\twhile (o.contains(s)) {\n\t\t\t\tint i = o.indexOf(s);\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=o.size()-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((o.get(i-1)!=-1)&&(o.get(i+1)!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((o.get(i-1)==-1)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\telse if ((i==o.size()-1)&&(o.get(i-1)==-1)) count++;  //島はこのエリアしかない場合count-1\n\t\t\t\to.set(i, -1l);\n\t\t\t}\n\t\t\t//System.out.println(\"count:   \" + count);\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for (int i=0; i<num; i++) System.out.print(i +\"  : \"+orthometric[i]+\"      \");\n\t\t\t//System.out.println();\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t//for (int i=0; i<num; i++)System.out.println(orthometric[i]);\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\n\t\t\tint count = 0;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\t//System.out.println(\"land-----\"+land.size()+\"SEA:\"+sea[pointer]);\n\t\t\t\tnewLand[0] = j[0];\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\t//System.out.println(\"start/end:::::\"+j[0]+\"/\"+j[1]+\"  now:::::\"+k);\n\t\t\t\t\tif (orthometric[k]==sea[pointer]) {  //沈んだら\n\t\t\t\t\t\tif ((k!=j[0])) {  //最初ではなかったら\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\" / \"+newLand[1]+\" : \"+orthometric[newLand[0]]+\" / \"+orthometric[newLand[1]-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLand[0] = k+1;  //新しい島がスタート\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (orthometric[j[1]-1]!=sea[pointer]) { //最後まで島だったら\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\" / \"+newLand[1]+\" : \"+orthometric[newLand[0]]+\" / \"+orthometric[newLand[1]-1]);\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"count:\" + count);\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {  //含まれていない場合\n\t\t\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);  //位置を記録\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for (List<Integer> l : seaLevel.values()) System.out.println(l);\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\n\t\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tList<Long> o = new LinkedList<>(orthometric);\n\t\tint count = 1;\n\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\tfor (int i : l) {\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=o.size()-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((o.get(i-1)!=-1)&&(o.get(i+1)!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((o.get(i-1)==-1)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(i!=o.size()-1)) {\n\t\t\t\t\tif (o.get(i+1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i!=0)&&(i==o.size()-1)) {\n\t\t\t\t\tif (o.get(i-1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t}\n\t\t\t\to.set(i, -1l);\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\t\t\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n\tpublic static void main(String args[]) throws IOException {\n\t\tint Ans = 0;\n\t\tint ans = 0;\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s1 = new String(in.readLine());\n\n\t\tint N = Integer.parseInt(s1);\n\n\t\tString s2 = new String(in.readLine());\n\t\tString[] a = s2.split(\" +\");\n\n\t\tList<Integer> A = new ArrayList<Integer>();\n\n\t\tA.add(0);\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tif( i == 0 || A.get(A.size() - 1) != Integer.parseInt(a[i])) {\n\t\t\t\tA.add(Integer.parseInt(a[i]));\n\t\t\t}\n\t\t}\n\t\tA.add(0);\n\n\t\tList<St> li = new ArrayList<St>();\n\n\t\tfor(int i = 0;i < A.size() ;i++) {\n\t\t\tli.add(new Main().new St(A.get(i),i));\n\t\t}\n\n\t\tli.sort((e1,e2)-> e1.getNum() - e2.getNum()\t);\n\n\t\t//初期状態での島の数の確認\n\t\t//マイナスからプラスへの境目を見る\n\t\tfor (int j = 0; j < A.size() - 1 ; j++) {\n\t\t\tif (A.get(j) == 0 && A.get(j + 1) > 0) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tAns = ans;\n\n\t\tint countNum = 0;\n\t\tint incNum = 0;\n\t\tint decNum = 0;\n\t\t//System.out.println(\"初期島数 = \" + Ans);\n\t\t\n\t\t//島の最大数を確認する\n\t\t//見る数値がリストの数値の中で最大値になった場合、終了する。\n\t\tfor (int i = 0; li.get(i).getNum() != li.get(li.size() - 1).getNum();i++) {\n\t\t\tSt st = li.get(i);\n\t\t\tSt nextst = li.get(i + 1);\n\n\t\t\t//初期状態は確認しているのでスキップ\n\t\t\tif (st.getNum() <= 0 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcountNum++;\n\n\t\t\t//沈む陸地に対しその左右の陸地をみて\n\t\t\t//ansを操作する。\n\t\t\tint nl_num = A.get(st.getIndex() - 1) ;\n\t\t\tint nr_num = A.get(st.getIndex() + 1) ;\n\n\n\t\t\tif (nl_num - st.getNum() > 0 && nr_num - st.getNum() > 0) {\n\t\t\t\tans++;\n\t\t\t\tincNum++;\n\t\t\t\t//System.out.print(\"[in]:\");\n\t\t\t}\n\t\t\tif (nl_num - st.getNum() <= 0 && nr_num - st.getNum() <= 0) {\n\t\t\t\tans--;\n\t\t\t\tdecNum++;\n\t\t\t\t//System.out.print(\"[de]:\");\n\t\t\t}\n\t\t\n\n\t\t\t//System.out.println(\"getNum = \" + String.format(\"%2d\",st.getNum()) +\",i = \" + String.format(\"%4d\",i) + \",index = \" + String.format(\"%4d\",st.getIndex()) + \",left = \" + String.format(\"%2d\",(rnum + st.getNum())) + \",right = \" + String.format(\"%2d\",(nnum + st.getNum())) + \",ans = \" + String.format(\"%3d\",ans));\n\n\t\t\t//海面の高さが変化するタイミングで\n\t\t\t//ansの判定を行う。\n\t\t\tif (st.getNum() != nextst.getNum() ) {\n\t\t\t\tif (ans > Ans) {\n\t\t\t\t\tAns = ans;\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"浸水 = \" +  String.format(\"%2d\",st.getNum()) + \",対象 = \" + String.format(\"%4d\",countNum) + \",inc = \" + String.format(\"%4d\",incNum) + \",dec = \" + String.format(\"%4d\",decNum) + \",ans = \" + String.format(\"%4d\",ans) + \",Ans = \" + String.format(\"%4d\",Ans));\n\t\t\t\tcountNum = 0;\n\t\t\t}\n\t\t\t//if(i > 1000) {\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\n\t\tSystem.out.println(Ans);\n\t}\n\tpublic class St{\n\t\tprivate int num;\n\t\tprivate int index;\n\n\t\tpublic St(int num , int index) {\n\t\t\tthis.num = num;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\tpublic int getNum() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "//36#5.12s\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\t//static int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\t//System.out.println();\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tList<Long> o = new LinkedList<>(orthometric);\n\t\tint count = 1;\n\t\tfor (long s : sea) {\n\t\t\t//System.out.println(\"SeaLevel:   \" + s);\n\t\t\twhile (o.contains(s)) {\n\t\t\t\tint i = o.indexOf(s);\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=o.size()-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((o.get(i-1)!=-1)&&(o.get(i+1)!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((o.get(i-1)==-1)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(i!=o.size()-1)) {\n\t\t\t\t\tif (o.get(i+1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i!=0)&&(i==o.size()-1)) {\n\t\t\t\t\tif (o.get(i-1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t}\n\t\t\t\to.set(i, -1l);\n\t\t\t}\n\t\t\t//System.out.println(\"count:   \" + count);\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\n/**\n * AIZU ONLINE JUDGE\n * 0654\n *  2020/5/5\n */\npublic class Main {\n\n\n    class Mnt {\n        int a;\n        int m; // 1山 0谷\n        public Mnt(int a, int m) {\n            this.a = a;\n            this.m = m;\n        }\n    }\n\n\n    boolean main() throws IOException {\n\n        Scanner sc = new Scanner(systemin);\n\n        int N = sc.nextInt();\n        boolean up = true;\n        int old = -1;\n        boolean all0 = true;\n        List<Mnt> list = new ArrayList<>();\n        for(int i = 0;i <= N; i++) {\n            int A;\n            if (N == i)\n                A = 0; // 最後\n            else\n                A = sc.nextInt();\n            if (A != 0)\n                all0 = false;\n            if (up && A < old) {\n                list.add(new Mnt(old, 1)); // 山\n                up = false;\n            }\n            else if (!up && A > old) {\n                list.add(new Mnt(old, 0)); // 谷\n                up = true;\n            }\n            old = A;\n        }\n        \n        list.sort((a, b) -> a.a - b.a);\n\n        int max = 1;\n        int sima = 1;\n        old = -1;\n        for(int i = 0; i < list.size(); i++) {\n            Mnt m = list.get(i);\n            if (m.a != old) {\n                max = Math.max(max,  sima);\n            }\n            if (m.m > 0)\n                sima--;\n            else sima++;\n            log.printf(\"list a = %d m = %d sima = %d max = %d\\n\", m.a, m.m, sima, max);\n            old = m.a;\n        }\n\n        if (all0)\n            max = 0;\n        \n        result.printf(\"%d\\n\",  max);\n\n        sc.close();\n        return false;\n    }\n\n\n\n    PrintStream log;\n    PrintStream result = System.out;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        instance.main();\n        instance.systemin.close();\n    }\n\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land, int pointer) {\n\t\tif (pointer>=sea.length) {\n\t\t\treturn max;\n\t\t} else {\n\t\t\tint count = 0;\n\t\t\tboolean landflag = false;\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tint[] newLand = new int[2];\n\t\t\tfor (int[] j : land) {\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]>sea[pointer]) {  //陸地であれば\n\t\t\t\t\t\tlandflag = true;  //flag起動\n\t\t\t\t\t\tnewLand[0] = k;  //新しい島のスタート\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (landflag) {  //ここまでが一つの島\n\t\t\t\t\t\t\tlandflag = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tl.add(newLand);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (landflag) { //最後まで島だったら\n\t\t\t\t\t count++;\n\t\t\t\t\t newLand[1] = num;\n\t\t\t\t\t l.add(newLand);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t\tmax = findLand(max, land, pointer+1);\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn max;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic List<Long> orthometric;  //海抜\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new LinkedList<Long>();  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric.add(a);  //海抜を読み込み\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {  //含まれていない場合\n\t\t\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);  //位置を記録\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for (List<Integer> l : seaLevel.values()) System.out.println(l);\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,orthometric.size()-1});  //最初は全部\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");  //全部0だったら\n\n\t\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tList<Long> o = new LinkedList<>(orthometric);\n\t\tint count = 1;\n\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\tfor (int i : l) {\n\t\t\t\t//System.out.println(\"i-----------\" + i);\n\t\t\t\tif ((i!=0)&&(i!=o.size()-1)) {  //最初と最後ではない場合\n\t\t\t\t\tif ((o.get(i-1)!=-1)&&(o.get(i+1)!=-1)) count++;  //島の真ん中であればcount+1\n\t\t\t\t\telse if ((o.get(i-1)==-1)&&(o.get(i+1)==-1)) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i==0)&&(i!=o.size()-1)) {\n\t\t\t\t\tif (o.get(i+1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t} else if ((i!=0)&&(i==o.size()-1)) {\n\t\t\t\t\tif (o.get(i-1)==-1) count--;  //島はこのエリアしかない場合count-1\n\t\t\t\t}\n\t\t\t\to.set(i, -1l);\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\t\t\t\n\t\t\tint count = 0;\n\t\t\tboolean landflag = false;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\t//System.out.println(\"land-----\"+land.size());\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\t//System.out.println(pointer+\"-----\"+j[0]+\"/\"+j[1]);\n\t\t\t\t\tif (orthometric[k]>sea[pointer]) {  //陸地であれば\n\t\t\t\t\t\tif (!landflag) {\n\t\t\t\t\t\t\tlandflag = true;  //flag起動\n\t\t\t\t\t\t\tnewLand[0] = k;  //新しい島のスタート\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (landflag) {  //ここまでが一つの島\n\t\t\t\t\t\t\tlandflag = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tl.add(newLand);\n\t\t\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\"/\"+newLand[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (landflag) { //最後まで島だったら\n\t\t\t\t\t count++;\n\t\t\t\t\t newLand[1] = num;\n\t\t\t\t\t l.add(newLand);\n\t\t\t\t\t// System.out.println(\"added:\" + newLand[0]+\"/\"+newLand[1]);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t\tland = new ArrayList<int[]>(l);\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\t//System.out.println();\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\t\tint max = findLand(0, land);\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"1\");\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\n\t\t\tint count = 0;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\tnewLand[0] = j[0];\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]==sea[pointer]) {  //沈んだら\n\t\t\t\t\t\tif ((k!=j[0])) {  //最初ではなかったら\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLand[0] = k+1;  //新しい島がスタート\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (orthometric[j[1]-1]!=sea[pointer]) { //最後まで島だったら\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int prev = 0;\n        boolean isDown = true;\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            if (isDown && prev < x) {\n                if (map.containsKey(prev)) {\n                    map.put(prev, map.get(prev) + 1);\n                } else {\n                    map.put(prev, 1);\n                }\n                isDown = false;\n            } else if (!isDown && prev > x) {\n                if (map.containsKey(prev)) {\n                    map.put(prev, map.get(prev) - 1);\n                } else {\n                    map.put(prev, -1);\n                }\n                isDown = true;\n            }\n            prev = x;\n        }\n        if (!isDown) {\n            if (map.containsKey(prev)) {\n                map.put(prev, map.get(prev) - 1);\n            } else {\n                map.put(prev, -1);\n            }\n        }\n        int max = 0;\n        int current = 0;\n        for (int x : map.values()) {\n            current += x;\n            max = Math.max(max, current);\n        }\n       System.out.println(max);\n     }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();  //領域の数\n\t\tint region[] = new int[n];\n\n\t\tint heightMax = 0;\n\t\tint islandMax = 0;  //島の数の最大値\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tregion[i] = sc.nextInt();\n\t\t\tif(heightMax < region[i]) heightMax = region[i];\n\t\t}\n\n\t\tfor(int i = 0; i < heightMax; i++) {  //海面の高さのループ\n\t\t    int count1 = 0;  //島の数\n\t\t\tboolean flag = false;  //海面ならばfalse、陸地ならばtrue\n\n\t\t\tfor(int j = 0; j < n; j++) {  //領域のループ\n\t\t\t\tif(!flag) {\n\t\t\t\t\tif(region[j] - i > 0) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(region[j] - i <= 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tcount1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j == n - 1) {  //最後の領域判定時にtrueだったらcountを1増やす\n\t\t\t\t\tif(flag) count1++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(islandMax < count1) islandMax = count1;\n\t\t}\n\n\t\tSystem.out.println(islandMax);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\tstatic List<Long> orthometric = new LinkedList<Long>();\n\tstatic Map<Long,List<Integer>> seaLevel = new TreeMap<Long,List<Integer>>();\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\tlong now = 0l;\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tif (a != now) {\n\t\t\t\t\torthometric.add(a);\n\t\t\t\t\tif (!seaLevel.containsKey(a)) {\n\t\t\t\t\t\tList<Integer> list = new LinkedList<Integer>();\n\t\t\t\t\t\tlist.add(orthometric.size()-1);\n\t\t\t\t\t\tseaLevel.put(a, list);\n\t\t\t\t\t} else seaLevel.get(a).add(orthometric.size()-1);\n\t\t\t\t\tnow = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.size()>0) {\n\t\t\t\tint max = findLand();\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"0\");\n\t\t}\n\t}\n\n\tpublic static int findLand() {\n\t\tint max = 0;\n\t\tLong[] oArray = new Long[orthometric.size()];\n\t\torthometric.toArray(oArray);\n\t\tint count = 1;\n\t\tfor (List<Integer> l : seaLevel.values()) {\n\t\t\tfor (int i : l) {\n\t\t\t\tif ((i!=0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif ((oArray[i-1]!=-1)&&(oArray[i+1]!=-1)) count++;\n\t\t\t\t\telse if ((oArray[i-1]==-1)&&(oArray[i+1]==-1)) count--;\n\t\t\t\t} else if ((i==0)&&(i!=oArray.length-1)) {\n\t\t\t\t\tif (oArray[i+1]==-1) count--;\n\t\t\t\t} else if ((i!=0)&&(i==oArray.length-1)) {\n\t\t\t\t\tif (oArray[i-1]==-1) count--; \n\t\t\t\t}\n\t\t\t\toArray[i] = -1l;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = -1l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for (int i=0; i<num; i++) System.out.print(i +\"  : \"+orthometric[i]+\"      \");\n\t\t\t//System.out.println();\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t//for (int i=0; i<num; i++)System.out.println(orthometric[i]);\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\n\t\t\tint count = 0;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\t//System.out.println(\"land-----\"+land.size()+\"SEA:\"+sea[pointer]);\n\t\t\t\tnewLand[0] = j[0];\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\t//System.out.println(\"start/end:::::\"+j[0]+\"/\"+j[1]+\"  now:::::\"+k);\n\t\t\t\t\tif (orthometric[k]==sea[pointer]) {  //沈んだら\n\t\t\t\t\t\tif ((k!=j[0])) {  //最初ではなかったら\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\" / \"+newLand[1]+\" : \"+orthometric[newLand[0]]+\" / \"+orthometric[newLand[1]-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLand[0] = k+1;  //新しい島がスタート\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (orthometric[j[1]-1]!=sea[pointer]) { //最後まで島だったら\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\" / \"+newLand[1]+\" : \"+orthometric[newLand[0]]+\" / \"+orthometric[newLand[1]-1]);\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"count:\" + count);\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land, int pointer) {\n\t\tif (pointer>=sea.length) {\n\t\t\treturn max;\n\t\t} else {\n\t\t\tint count = 0;\n\t\t\tboolean landflag = false;\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tint[] newLand = new int[2];\n\t\t\tfor (int[] j : land) {\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]>sea[pointer]) {  //陸地であれば\n\t\t\t\t\t\tlandflag = true;  //flag起動\n\t\t\t\t\t\tnewLand[0] = k;  //新しい島のスタート\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (landflag) {  //ここまでが一つの島\n\t\t\t\t\t\t\tlandflag = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tl.add(newLand);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (landflag) { //最後まで島だったら\n\t\t\t\t\t count++;\n\t\t\t\t\t newLand[1] = num;\n\t\t\t\t\t l.add(newLand);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t\tmax = findLand(max, land, pointer+1);\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn max;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n\tpublic static void main(String args[]) throws IOException {\n\t\tint Ans = 0;\n\t\tint ans = 0;\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s1 = new String(in.readLine());\n\n\t\tint N = Integer.parseInt(s1);\n\n\t\tString s2 = new String(in.readLine());\n\t\tString[] a = s2.split(\" +\");\n\n\t\tList<Integer> A = new ArrayList<Integer>();\n\n\t\tA.add(0);\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tif( i == 0 || A.get(A.size() - 1) != Integer.parseInt(a[i])) {\n\t\t\t\tA.add(Integer.parseInt(a[i]));\n\t\t\t}\n\t\t}\n\t\tA.add(0);\n\n\t\tList<St> li = new ArrayList<St>();\n\n\t\tfor(int i = 0;i < A.size() ;i++) {\n\t\t\tli.add(new Main().new St(A.get(i),i));\n\t\t}\n\n\t\tli.sort((e1,e2)-> e1.getNum() - e2.getNum()\t);\n\n\t\t//初期状態での島の数の確認\n\t\t//マイナスからプラスへの境目を見る\n\t\tfor (int j = 0; j < A.size() - 1 ; j++) {\n\t\t\tif (A.get(j) == 0 && A.get(j + 1) > 0) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tAns = ans;\n\n\t\tint countNum = 0;\n\t\tint incNum = 0;\n\t\tint decNum = 0;\n\t\t//System.out.println(\"初期島数 = \" + Ans);\n\t\t\n\t\t//島の最大数を確認する\n\t\t//見る数値がリストの数値の中で最大値になった場合、終了する。\n\t\tfor (int i = 0; li.get(i).getNum() != li.get(li.size() - 1).getNum();i++) {\n\t\t\tSt st = li.get(i);\n\t\t\tSt nextst = li.get(i + 1);\n\n\t\t\t//初期状態は確認しているのでスキップ\n\t\t\tif (st.getNum() <= 0 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcountNum++;\n\n\t\t\t//沈む陸地に対しその左右の陸地をみて\n\t\t\t//ansを操作する。\n\t\t\tint nl_num = A.get(st.getIndex() - 1) ;\n\t\t\tint nr_num = A.get(st.getIndex() + 1) ;\n\n\n\t\t\tif (nl_num - st.getNum() > 0 && nr_num - st.getNum() > 0) {\n\t\t\t\tans++;\n\t\t\t\tincNum++;\n\t\t\t\t//System.out.print(\"[in]:\");\n\t\t\t}\n\t\t\tif (nl_num - st.getNum() <= 0 && nr_num - st.getNum() <= 0) {\n\t\t\t\tans--;\n\t\t\t\tdecNum++;\n\t\t\t\t//System.out.print(\"[de]:\");\n\t\t\t}\n\t\t\n\n\t\t\t//System.out.println(\"getNum = \" + String.format(\"%2d\",st.getNum()) +\",i = \" + String.format(\"%4d\",i) + \",index = \" + String.format(\"%4d\",st.getIndex()) + \",left = \" + String.format(\"%2d\",(rnum + st.getNum())) + \",right = \" + String.format(\"%2d\",(nnum + st.getNum())) + \",ans = \" + String.format(\"%3d\",ans));\n\n\t\t\t//海面の高さが変化するタイミングで\n\t\t\t//ansの判定を行う。\n\t\t\tif (st.getNum() != nextst.getNum() ) {\n\t\t\t\tif (ans > Ans) {\n\t\t\t\t\tAns = ans;\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"浸水 = \" +  String.format(\"%2d\",st.getNum()) + \",対象 = \" + String.format(\"%4d\",countNum) + \",inc = \" + String.format(\"%4d\",incNum) + \",dec = \" + String.format(\"%4d\",decNum) + \",ans = \" + String.format(\"%4d\",ans) + \",Ans = \" + String.format(\"%4d\",Ans));\n\t\t\t\tcountNum = 0;\n\t\t\t}\n\t\t\t//if(i > 1000) {\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\n\t\tSystem.out.println(Ans);\n\t}\n\tpublic class St{\n\t\tprivate int num;\n\t\tprivate int index;\n\n\t\tpublic St(int num , int index) {\n\t\t\tthis.num = num;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\tpublic int getNum() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (orthometric.length>0) {\n\t\t\t\t//System.out.println();\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\t\tint max = findLand(0, land);\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"1\");\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\n\t\t\tint count = 0;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\tnewLand[0] = j[0];\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]==sea[pointer]) {  //沈んだら\n\t\t\t\t\t\tif ((k!=j[0])) {  //最初ではなかったら\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLand[0] = k+1;  //新しい島がスタート\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (orthometric[j[1]-1]!=sea[pointer]) { //最後まで島だったら\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num>0) {\n\t\t\t\t//System.out.println();\n\t\t\t\tsea = new Long[seas.size()];\n\t\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\t\tint max = findLand(0, land);\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else System.out.println(\"1\");\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\n\t\t\tint count = 0;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\tnewLand[0] = j[0];\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]==sea[pointer]) {  //沈んだら\n\t\t\t\t\t\tif ((k!=j[0])) {  //最初ではなかったら\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLand[0] = k+1;  //新しい島がスタート\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (orthometric[j[1]-1]!=sea[pointer]) { //最後まで島だったら\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t//for (int i=0; i<num; i++)System.out.println(orthometric[i]);\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\t\t\t\n\t\t\tint count = 0;\n\t\t\tboolean landflag = false;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\tif (orthometric[k]>sea[pointer]) {  //陸地であれば\n\t\t\t\t\t\tif (!landflag) {\n\t\t\t\t\t\t\tlandflag = true;  //flag起動\n\t\t\t\t\t\t\tnewLand[0] = k;  //新しい島のスタート\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (landflag) {  //ここまでが一つの島\n\t\t\t\t\t\t\tlandflag = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (landflag) { //最後まで島だったら\n\t\t\t\t\tlandflag = false;\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tstatic long[] orthometric;  //海抜\n\tstatic Long[] sea;  //海の変化\n\tstatic int num = 0;  //配列の長さ\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint len = sc.nextInt();\n\t\t\torthometric = new long[len];  //海抜\n\t\t\tTreeSet<Long> seas = new TreeSet<Long>();\n\t\t\tlong now = 0l;\n\t\t\tseas.add(0l);  //最初は0から始まる\n\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\tlong a = sc.nextLong();  //海抜を読み込み\n\t\t\t\tif (a != now) {  //隣が同じ高さだと無視\n\t\t\t\t\torthometric[num] = a;  //海抜を読み込み\n\t\t\t\t\tseas.add(a);  //海の変化を読み込み\n\t\t\t\t\tnow = a;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsea = new Long[seas.size()];\n\t\t\tseas.toArray(sea);  //配列にする\n\t\t\t//for (int i=0; i<num; i++)System.out.println(orthometric[i]);\n\t\t\tList<int[]> land = new ArrayList<int[]>();\n\t\t\tland.add(new int[]{0,num});  //最初は全部\n\t\t\tint max = findLand(0, land);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static int findLand(int max, List<int[]> land) {\n\t\tint pointer = 0;\n\t\twhile (pointer<sea.length) {\t\t\t\n\t\t\tint count = 0;\n\t\t\tboolean landflag = false;\n\t\t\tint[] newLand = new int[2];\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tfor (int[] j : land) {\n\t\t\t\t//System.out.println(\"land-----\"+land.size()+\"SEA:\"+sea[pointer]);\n\t\t\t\tfor (int k=j[0]; k<j[1]; k++) {\n\t\t\t\t\t//System.out.println(\"start/end:::::\"+j[0]+\"/\"+j[1]+\"  now:::::\"+k);\n\t\t\t\t\tif (orthometric[k]>sea[pointer]) {  //陸地であれば\n\t\t\t\t\t\tif (!landflag) {\n\t\t\t\t\t\t\tlandflag = true;  //flag起動\n\t\t\t\t\t\t\tnewLand[0] = k;  //新しい島のスタート\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (landflag) {  //ここまでが一つの島\n\t\t\t\t\t\t\tlandflag = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnewLand[1] = k;  //新しい島のエンド\n\t\t\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\t\t\tl.add(copy);\n\t\t\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\" / \"+newLand[1]+\" : \"+orthometric[newLand[0]]+\" / \"+orthometric[newLand[1]-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (landflag) { //最後まで島だったら\n\t\t\t\t\tlandflag = false;\n\t\t\t\t\tcount++;\n\t\t\t\t\tnewLand[1] = j[1];  //最後を島にする\n\t\t\t\t\tint[] copy = new int[] {newLand[0],newLand[1]};\n\t\t\t\t\tl.add(copy);\n\t\t\t\t\t//System.out.println(\"added:\" + newLand[0]+\" / \"+newLand[1]+\" : \"+orthometric[newLand[0]]+\" / \"+orthometric[newLand[1]-1]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tland = new ArrayList<int[]>(l);\n\t\t\tpointer++;\n\t\t}\n\t\treturn max;\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace joi2019_yo_d\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n            bool[] land = new bool[n + 2];\n            for (int i = 0; i < n; i++) \n                if (x[i] > 0) \n                    land[i + 1] = true;\n\n            int now = 0;\n            for (int i = 1; i <= n + 1; i++) \n                if (land[i - 1] == false && land[i] == true) \n                    now++;\n            int ans = now;\n\n            int[] count = new int[n]; \n            for (int i = 0; i < n; i++) \n                count[i] = i + 1;\n                \n            Array.Sort(x, count);\n            \n            for (int i = 0; i < n; i++)\n            {\n                if (x[i] == 0) \n                    continue;\n                int idx = count[i]; \n                land[idx] = false;\n                if (land[idx - 1] && land[idx + 1]) \n                    now++;\n                else if (!land[idx - 1] && !land[idx + 1]) \n                    now--;\n                if (i == n - 1 || x[i] != x[i + 1]) \n                    ans = Math.Max(ans, now);\n            }\n            Console.WriteLine(ans);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace joi2019_yo_d\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n            bool[] land = new bool[n + 2];//浮いているならtrue\n            for (int i = 0; i < n; i++) if (x[i] > 0) land[i + 1] = true;\n\n            int now = 0;\n            for (int i = 1; i <= n + 1; i++) if (land[i - 1] != land[i]) { now++; }\n            int ret = now / 2; now /= 2;//初期状態での島の数\n\n            int[] count = new int[n]; for (int i = 0; i < n; i++) count[i] = i + 1;\n            Array.Sort(x, count);\n            for (int i = 0; i < n; i++)\n            {\n                if (x[i] == 0) continue;\n                int where = count[i]; land[where] = false;\n                if (land[where - 1] && land[where + 1]) now++;\n                else if (!land[where - 1] && !land[where + 1]) now--;\n                if (i == n - 1 || x[i] != x[i + 1]) ret = Math.Max(ret, now);\n            }\n            Console.WriteLine(ret);\n        }\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\na = gets.chomp.split.map(&:to_i) + [0]\nb = [0]\na.each{|x| b << x if x != b.last}\n\nh = Hash.new{|h, k| h[k] = [0, 0]}\nfor x in 1...(b.length - 1)\n    if b[x] > b[x - 1] && b[x] > b[x + 1]\n        h[b[x]][0] += 1\n    elsif b[x] < b[x - 1] && b[x] < b[x + 1]\n        h[b[x]][1] += 1\n    end\nend\nh.delete(0)\n\ncount, max = 0, 0\nh.keys.sort.reverse_each{|k|\n    count += h[k][0] - h[k][1]\n    max = count if max < count\n}\nputs max\n"
  },
  {
    "language": "Ruby",
    "code": "_ = gets\nheights = [0] + gets.split.map(&:to_i) + [0]\nevents = []\nheights.each_cons(2) do |h1, h2|\n  events << [h1, h2 <=> h1]\n  events << [h2, h1 <=> h2]\nend\nevents.sort_by!(&:first)\nbest = k = 0\n(heights.uniq - [0]).sort.each do |level|\n  k += events.shift[1] while events[0][0] < level\n  best = k / 2 if k / 2 > best\nend\np best\n"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=gets.split.map &:to_i\nsea=[true]+a.map{|e|e<=0}+[true]\ncur=0\n1.upto(n){|i|cur+=1 if !sea[i]&&sea[i-1]}\nr=cur\no=n.times.select{|i|a[i]>0}.map{|i|[a[i],i+1]}.sort\no.each_with_index{|(x,y),i|\n    sea[y]=true\n    if sea[y-1]&&sea[y+1]\n        cur-=1\n    elsif !sea[y-1]&&!sea[y+1]\n        cur+=1\n    end\n    if i+1==o.size||x<o[i+1][0]\n        r=[r,cur].max\n    end\n}\np r\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, \"%d\", $target_count);\n$heights = array_map(\"intval\", explode(\" \", trim(fgets(STDIN))));\n\n$target_tmp = [0];\n$prev = 0;\nfor ($i = 0; $i < count($heights); ++$i) {\n    if ($heights[$i] != $prev) $target_tmp[] = $heights[$i];\n    $prev = $heights[$i];\n}\narray_push($target_tmp, 0);\n//メモリ解放\n$heights = [];\n\n$target = [0];\n$prev = 0;\nfor ($i = 1; $i < count($target_tmp)-1; ++$i) {\n    if (($prev < $target_tmp[$i] && $target_tmp[$i] > $target_tmp[$i+1]) || ($prev > $target_tmp[$i] && $target_tmp[$i] < $target_tmp[$i+1])) $target[] = $target_tmp[$i];\n    \n    $prev = $target_tmp[$i];\n\n}\n//メモリ解放\n$target_tmp = [];\n\n$mountain = [];\n$valley = [];\n\nfor ($i = 0; $i < count($target); ++$i){\n\tif ($i%2 == 1) {\n\t\t$mountain[] = $target[$i];\n\t} else {\n\t\t$valley[] = $target[$i];\n\t}\n}\n\nsort ($target);\nsort ($mountain);\nsort ($valley);\narray_push($target, 0);\narray_push($mountain, 0);\narray_push($valley, 0);\n\n$ans = 0;\n$max = 0;\n\nif(count($target) == 1){\n    echo $max, \"\\n\";\n\treturn ;\n}\n\n$m = 0;\n$b = 0;\n\nfor ($i = 0; $i < count($target)-1; ++$i) {\n    if ($mountain[$m] == $target[$i]) {\n        ++$m;\n        --$ans;\n    } \n    if ($valley[$b] == $target[$i]) {\n        ++$b;\n        ++$ans;\n    }\n    \n    if ($target[$i] < $target[$i+1]) {\n        if ($ans > $max) $max = $ans;\n    }\n\n}\n\n\necho $max, \"\\n\";\n\n"
  },
  {
    "language": "Python",
    "code": "# 区画数\nsection_count = int(input())\n# チェック済みチェック\nchecked = [False] * section_count\n# 区画毎の高さ\nsection_list = list(map(int, input().split()))\nsorted_section_list = sorted(zip(section_list, range(section_count)))\n\n# 海面の高さ(前)\npre_sea_level = 10 ** 9\n\ncount = 0\nans = 0\nwhile sorted_section_list:\n    # 海面の高さ、ソート前の要素番号を取得\n    sea_level, number = sorted_section_list.pop()\n    if sea_level != pre_sea_level:\n        ans = max(ans, count)\n    if sea_level <= 0:\n        break\n\n    count += 1\n    checked[number] = True\n    \n    # 隣の区画が海面より上かをチェック。隣合っていれば地続きとしてカウントダウン\n    if number > 0 and checked[number - 1]:\n        count -= 1\n    if number < section_count - 1 and checked[number + 1]:\n        count -= 1\n    \n    pre_sea_level = sea_level\n\nans = max(ans, count)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\ndef solve():\n    N = int(input())\n    A = [0] + [int(i) for i in input().split()] + [0]\n    A_edge = []\n    # 頂点と底辺のみにデータを絞る\n    up_flg = True\n    for i in range(1, len(A) - 1):\n        if up_flg:\n            if A[i] > A[i + 1]:\n                A_edge.append([A[i], up_flg])\n                up_flg = not up_flg\n        else:\n            if A[i] < A[i + 1]:\n                A_edge.append([A[i], up_flg])\n                up_flg = not up_flg\n    A_edge.sort()  # 沈んでいく順に並べ替え\n    # 島を数える\n    island_count = 1\n    max_island_count = 1\n    for i in range(len(A_edge) - 1):\n        if A_edge[i][1]:\n            island_count -= 1\n        else:\n            island_count += 1\n        if A_edge[i][0] < A_edge[i + 1][0]:\n            max_island_count = max(max_island_count, island_count)\n    # 島の高さがすべて0の時の考慮\n    if max(A) <= 0:\n        max_island_count = 0\n    print(max_island_count)\n\n\nif __name__ == '__main__':\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "#17D8104010B 宮本拓輝 再提出10/31 Prolem D AOJ0655 Japan Sinks python3\n\n\nimport sys\n\n\nn=int(input())\nA=list(map(int,input().split()))\n\nif max(A)==0:\n  print(0)\n  sys.exit()\n\nA.insert(0,0)\nA.append(0)\n\ntop_valley=[] #[i][0]に標高,[i][1]は1なら頂点,0なら谷\nup_down=True #登りならTrue,下りならfalse\n\nfor i in range(1,len(A)-1):\n  #頂点\n  if up_down==True:\n    if A[i]>A[i+1]:\n      top_valley.append([A[i],1])\n      up_down=False\n  #谷\n  elif up_down==False:\n    if A[i]<A[i+1]:\n      top_valley.append([A[i],0])\n      up_down=True\n\n\ntop_valley.sort()\n\n\ncnt=1\nmax_cnt=1\nfor i in range(len(top_valley)-1):\n  if top_valley[i][1]==1:\n    cnt-=1\n  elif top_valley[i][1]==0:\n    cnt+=1\n\n  if top_valley[i][0]<top_valley[i+1][0]:\n    max_cnt=max(max_cnt,cnt)\n\nprint(max_cnt)\n\n\"\"\"\n6\n3 2 3 0 2 0\n2\n\"\"\"\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput() # no use\nlst = list(map(int, input().split()))\n# print(lst)\n# すべて同じ数の場合は 0 or 1\nif len(lst) == 1 or set(lst) == 1:\n    if lst[0] == 0:\n        print(0)\n    else:\n        print(1)\n    sys.exit()\n   \n# 同じ数字の並びは不要なため削除する\ntmp = []\nprev = -1\nfor now in lst:\n    if now != prev:\n        tmp += [now]\n        prev = now\nlst = tmp\n\n# 両端が０でない場合、0を追加\nif lst[0] != 0:\n    lst = [0] + lst\nif lst[-1] != 0:\n    lst = lst + [0]\n\n# 頂点と底以外は不要なため削除する\ntmp = []\nfor i in range(1, len(lst) -1):\n    prev = lst[i-1]\n    now = lst[i]\n    next = lst[i+1]\n    if prev < now and now < next:\n        continue # 右上がりの途中\n    if prev > now and now > next:\n        continue # 右下がりの途中\n    tmp += [now]\n\nlst = tmp\n\n# この時点で以下のようなリストになる\n# 島海島(奇数) or 島海島海(偶数)\n\ntop = lst[0::2]\nbot = lst[1::2]\n\n# top.sort(reverse=True)\n# bot.sort(reverse=True)\ntop.sort()\nbot.sort()\n\n# 両端に0を追加\nlst = [0] + lst + [0]\n\n# print(top, bot, lst)\n\njpHeightList = lst\nseaHeightList = set(jpHeightList)\nmaxCount = 0\n\ntopLen = len(top)\nbotLen = len(bot)\ntopNext = 0\nbotNext = 0\n\n# 島の数＝海面上の頂点ー海面上の底面の最大値を求める\nfor i, seaHeight in enumerate(sorted(list(seaHeightList))):\n    # 海面上の頂点\n    # topCount = topLen - i -1\n    # topCount = sum(list(map(lambda x:1 if x-seaHeight>0 else 0, top)))\n    for j in range(topNext, topLen): # 一回沈んだ底はみなくてよい\n        if top[j] > seaHeight:\n            topNext = j  # j → 沈んだ島の数。\n            break\n        elif j == topLen -1:\n            topNext = topLen\n    topCount = topLen - topNext \n    \n    # 海面上の底面 \n    for j in range(botNext, botLen): # 一回沈んだ底はみなくてよい\n        if bot[j] > seaHeight:\n            botNext = j  # j → 沈んだ島の数。\n            break\n        elif j == botLen -1:\n            botNext = botLen\n    botCount = botLen - botNext \n\n    tmpCount = topCount - botCount\n    if tmpCount > maxCount:\n        maxCount = tmpCount\n\nprint(maxCount)\n\n\n"
  },
  {
    "language": "Python",
    "code": "def merge_unit(array1, array2, n1, n2):\n    n = n1 + n2\n    ret = [0] # outofindexを避けるため便宜上入れるが、たまたま呼び出し側で最初に0が必要なのでこのままにしとく\n    csr1 = 0\n    csr2 = 0\n    for i in range(n):\n        if csr1 >= n1:\n            if not ret[-1] == array2[csr2]:\n                ret.append(array2[csr2])\n            csr2 += 1\n        elif csr2 >= n2:\n            if not ret[-1] == array1[csr1]:\n                ret.append(array1[csr1])\n            csr1 += 1\n        else:\n            if array1[csr1] < array2[csr2]:\n                if not ret[-1] == array1[csr1]:\n                    ret.append(array1[csr1])\n                csr1 += 1\n            else:\n                if not ret[-1] == array2[csr2]:\n                    ret.append(array2[csr2])\n                csr2 += 1\n    return ret\n\ndef main():\n    N = int(input())\n    A = [int(v) for v in input().split()]\n\n    if all([v == 0 for v in A]):\n        print(0)\n        return\n\n    tyou_t = []\n    tyou_b = []\n    next = 0 # ダウン 1 -> アップ\n    for i in range(1, N):\n        if next == 0 and A[i] - A[i - 1] < 0:\n            tyou_t.append(A[i - 1])\n            next = 1\n        elif next == 1 and A[i] - A[i - 1] > 0:\n            tyou_b.append(A[i - 1])\n            next = 0\n\n    if next == 0:\n        tyou_t.append(A[-1])\n\n    tyou_t.sort()\n    tyou_b.sort()\n    len_t = len(tyou_t)\n    len_b = len(tyou_b)\n    tyou = merge_unit(tyou_t, tyou_b, len_t, len_b)\n\n    cnt_t = 0\n    cnt_b = 0\n    max_island = 1\n    for x in tyou:\n        while cnt_b < len_b and tyou_b[cnt_b] <= x:\n            cnt_b += 1\n        while cnt_t < len_t and tyou_t[cnt_t] <= x:\n            cnt_t += 1\n        island = 1 + cnt_b - cnt_t\n        if max_island < island:\n            max_island = island\n\n    print(max_island)\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "#\n# 　　  ⋀_⋀　 \n#　　  (･ω･)  \n# .／ Ｕ ∽ Ｕ＼\n#  │＊　合　＊│\n#  │＊　格　＊│ \n#  │＊　祈　＊│ \n#  │＊　願　＊│ \n#  │＊　　　＊│ \n#      ￣\n#\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nfrom math import floor,ceil,sqrt,factorial,log #log2ないｙｐ\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\ninf=float('inf')\nmod = 10**9+7\ndef pprint(*A): \n    for a in A:     print(*a,sep='\\n')\ndef INT_(n): return int(n)-1\ndef MI(): return map(int,input().split())\ndef MF(): return map(float, input().split())\ndef MI_(): return map(INT_,input().split())\ndef LI(): return list(MI())\ndef LI_(): return [int(x) - 1 for x in input().split()]\ndef LF(): return list(MF())\ndef LIN(n:int): return [I() for _ in range(n)]\ndef LLIN(n: int): return [LI() for _ in range(n)]\ndef LLIN_(n: int): return [LI_() for _ in range(n)]\ndef LLI(): return [list(map(int, l.split() )) for l in input()]\ndef I(): return int(input())\ndef F(): return float(input())\ndef ST(): return input().replace('\\n', '')\n# UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.nodes=[-1] * n  # nodes[x]: 負なら、絶対値が木の要素数\n\n    def get_root(self, x):\n        # nodes[x]が負ならxが根\n        if self.nodes[x] < 0:\n            return x\n        # 根に直接つなぎ直しつつ、親を再帰的に探す\n        else:\n            self.nodes[x]=self.get_root(self.nodes[x])\n            return self.nodes[x]\n\n    def unite(self, x, y):\n        root_x=self.get_root(x)\n        root_y=self.get_root(y)\n        # 根が同じなら変わらない\n        # if root_x == root_y:\n        # pass\n        if root_x != root_y:\n            # 大きい木の方につないだほうが計算量が減る\n            if self.nodes[root_x] < self.nodes[root_y]:\n                big_root=root_x\n                small_root=root_y\n            else:\n                small_root=root_x\n                big_root=root_y\n            self.nodes[big_root] += self.nodes[small_root]\n            self.nodes[small_root]=big_root\n\ndef main():\n    N=I()\n    A=LI()\n    timing = list(set(A))\n    timing.sort(reverse=True)\n    appear = defaultdict(list)\n    for i,a in enumerate(A):\n        appear[a].append(i)\n    \n    exist=set()\n\n    ans = 0\n    num = 0\n    for t in timing:\n        if t <= 0:\n            break\n        for land in appear[t]:\n            exist.add(land)\n            # if land == 0:\n            #     if land+1 in exist:\n            #         pass\n            #     else:\n            #         num += 1\n            # elif land == N-1:\n            #     if land-1 in exist:\n            #         pass\n            #     else:\n            #         num+=1\n            # else:\n            left = land-1 in exist\n            right = land+1 in exist\n            if left and right:\n                num-=1\n            elif left or right:\n                pass\n            else:\n                num+=1\n        # print(t, num)\n        ans = max(ans, num)\n\n    print(ans)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#  corutopiさんとkuwaaaaaaaaaaaaaaaaaさんの解答を参考にした。\n#\nn = int(input())\nheight_list = [0] + list(map(int, input().split())) + [0]\n\n# 山と谷のみに制限する\nuse_list = []\n\n# 高度が上昇中が下降中かのフラグ\n# True: 上昇中\n# False: 加工中\n# 左→右で探索する\nup_flag = True\nfor i in range(len(height_list)-1):\n    if up_flag:\n        if height_list[i] > height_list[i+1]:\n            # 山を検出した。山の高さを登録\n            use_list.append(height_list[i])\n            up_flag = False\n    else:\n        if height_list[i] < height_list[i+1]:\n            # 谷を検出した。谷の高さを登録\n            use_list.append(height_list[i])\n            up_flag = True\n\n            \n# ソートしたリスト\nlen_list = len(use_list)\nuse_list2 = sorted(zip(use_list, range(len_list)))\n\n\n# 沈んだかの判定\nsink_list = [False] * len_list\n\n# 島の最大値\nmax_count=0\n# 島の数\ncount=1\n\n# リストの前回使った高さ\npre_height = -1\n\nif len_list == 1:\n    max_count = 1\nelse:\n# 低いところから沈んでいく\n    for height, location in use_list2:\n    \n    \n        if pre_height != height:\n            max_count = max(max_count, count)\n    \n\n        sink_list[location] = True\n    \n        # 両隅が海\n        if (location > 0 and not sink_list[location - 1]) and (location < (len_list - 1) and not sink_list[location + 1]):\n            count += 1\n        # 両隅が陸\n        if (location > 0 and sink_list[location - 1]) and (location < (len_list - 1) and sink_list[location + 1]):\n            count -= 1\n        #  隅が沈んだ\n        elif location == 0 and sink_list[1]:\n            count -= 1\n        elif location == (len_list - 1) and sink_list[len_list-1]:\n            count -= 1\n        \n        pre_height = height\n    \n        # print(max_count, \"height = \", height, \",location = \", location, \", count =\" , count)\n        # print(sink_list)\n    \nprint(max_count)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    N = read_int()\n    A = read_ints()\n    print(solve(N, A))\n\n\ndef solve(N, A):\n    height_map = {}\n    for i, a in enumerate(A):\n        if a not in height_map:\n            height_map[a] = []\n        height_map[a].append(i + 1)\n\n    heights = list(height_map)\n    heights.sort(reverse=True)\n\n    landscape = [0] * (N + 2)\n    count = 0\n    best = 0\n    for h in heights:\n        if h == 0:\n            break\n        for i in height_map[h]:\n            l, r = landscape[i - 1], landscape[i + 1]\n            if l == 0 and r == 0:\n                count += 1\n            elif l == 1 and r == 1:\n                count -= 1\n            landscape[i] = 1\n\n        best = max(best, count)\n\n    return best\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nn,*h=map(int,open(0).read().split())\nh=[y for x,y in zip([-1]+h,h) if x!=y]\nd=defaultdict(list)\nfor i,x in enumerate(h):d[x].append(i+1)\nt=ans=int(h!=[0])\nh=[-1]+h+[-1]\nfor y,l in sorted(d.items()):\n\tfor i in l:\n\t\tif h[i-1]<y>h[i+1]:t-=1\n\t\telif (h[i-1]>y)^(h[i+1]>y):pass\n\t\telse:t+=1\n\tans=max(t,ans)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nalst = list(map(int, input().split()))\nraised = [False] * n\ncount = 0\nans = 0\npre_height = 10 ** 10\nsorted_alst = sorted(zip(alst, range(n)))\n\nwhile sorted_alst:\n    height, number = sorted_alst.pop()\n    if height != pre_height:\n        ans = max(ans, count)\n    if height <= 0:\n        break\n\n    count += 1\n    raised[number] = True\n    \n    if number > 0 and raised[number - 1]:\n        count -= 1\n    if number < n - 1 and raised[number + 1]:\n        count -= 1\n    \n    pre_height = height\n\nans = max(ans, count)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\na = map(int, raw_input().split())\nfield = []\nfor i in range(0, N):\n\tfield.append(a[i])\na.sort()\nheightlist = [a[0]]\nfor i in range(1, N):\n\tif heightlist[-1] != a[i]:\n\t\theightlist.append(a[i])\nisland = []\nlst = [-1, -1]\nfor i in range(0, N):\n\tif lst[0] == -1:\n\t\tif field[i] != 0:\n\t\t\tlst[0] = i\n\telse:\n\t\tif field[i] == 0:\n\t\t\tlst[1] = i-1\n\t\t\tisland.append(lst)\n\t\t\tlst = [-1, -1]\n\tif i == N-1 and lst[0] != -1:\n\t\tlst[1] = N-1\n\t\tisland.append(lst)\nmax = len(island)\nfor i in range(0, len(heightlist)):\n\tnewisland = []\n\tfor j in range(0, len(island)):\n\t\tnewlst = [-1, -1]\n\t\tfor k in range(island[j][0], island[j][1]+1):\n\t\t\tif newlst[0] == -1:\n\t\t\t\tif field[k] != heightlist[i]:\n\t\t\t\t\tnewlst[0] = k\n\t\t\telse:\n\t\t\t\tif field[k] == heightlist[i]:\n\t\t\t\t\tnewlst[1] = k-1\n\t\t\t\t\tnewisland.append(newlst)\n\t\t\t\t\tnewlst = [-1, -1]\n\t\t\tif k == island[j][1] and newlst[0] != -1:\n\t\t\t\tnewlst[1] = k\n\t\t\t\tnewisland.append(newlst)\n\tif max < len(newisland): max = len(newisland)\n\tisland = newisland\n\nprint max\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    pre_A = [int(i) for i in input().split()]\n    A = []\n    for i in range(N):\n        if i != 0 and pre_A[i-1] == pre_A[i]:\n            continue\n        A.append(pre_A[i])\n    N = len(A)\n    A = [(int(i), idx) for idx, i in enumerate(A)]\n    cur = 0\n    for i in range(N):\n        sea_level = 0\n        if (i == 0 or A[i-1][0] <= sea_level) and A[i][0] > sea_level:\n            cur += 1\n\n    B = sorted(A)\n    ans = 0\n    pre_h = 0\n    for h, idx in B:\n        if h == 0:\n            continue\n        if pre_h != h:\n            ans = max(cur, ans)\n        # 高さがhになったときの、島の数の増減を考える\n        if (idx != 0 and A[idx - 1][0] > h) and (idx != N-1 and A[idx + 1][0] > h):\n            cur += 1\n        elif (idx == 0 or A[idx - 1][0] < h) and (idx == N-1 or A[idx + 1][0] < h):\n            cur -= 1\n        pre_h = h\n    print(max(cur, ans))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nR = {}\n*A, = map(int, input().split())\nfor i, a in enumerate(A):\n    R.setdefault(a, []).append(i)\n\nif N == 1:\n    print(+(min(A) > 0))\nelse:\n    res = 1; ans = +(min(A) > 0)\n    for k in sorted(R):\n        for i in R[k]:\n            if 0 < i < N-1:\n                if A[i-1] <= A[i] > A[i+1]:\n                    res -= 1\n                if A[i-1] > A[i] <= A[i+1]:\n                    res += 1\n            elif i == 0:\n                if A[i] > A[i+1]:\n                    res -= 1\n            else:\n                if A[i-1] <= A[i]:\n                    res -= 1\n        ans = max(ans, res)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def sort_key(end):\n    if end[1]:\n        return end[0]*2+1\n    return end[0]*2\n\nn = int(input())\na = [int(i) for i in input().split()]\na.append(0)\n\nends = []\ntop = 0\nup = True\nfor i in range(0, n+1):\n    if not up and (i == n or a[i+1] > a[i]):\n        ends.append((a[i], True))\n        ends.append((top, False))\n        up = True\n    elif i != n and up and a[i+1] < a[i]:\n        top = a[i]\n        up = False\nends.sort(key=sort_key)\nmax_overlaps = 0\noverlaps = 0\nfor end in ends:\n    if end[1]:\n        overlaps += 1\n        if overlaps > max_overlaps:\n            max_overlaps = overlaps\n    else:\n        overlaps -= 1\nprint(max_overlaps)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    _ = int(input())\n    A = list(map(int, input().split()))\n\n    A.append(-1)\n    A = [a for a, b in zip(A, A[1:]) if a != b]\n    A.insert(0, -1)\n    A.append(-1)\n    A = [b for a, b, c in zip(A, A[1:], A[2:]) if (a < b) != (b < c)]\n\n    A.append(-1)\n    A = sorted((a, (1 if a < b else -1)) for a, b in zip(A, A[1:]))\n\n    n = 1\n    n_max = 0\n    prev = 0\n    for a, s in A:\n        if prev < a:\n            if n_max < n:\n                n_max = n\n            prev = a\n        n += s\n    print(n_max)\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nA = [int(a) for a in input().split()]\n\nfor i in range(N):\n    A[i] = (A[i], i)\n\nL = [0]*N\nA.sort(reverse=True)\ncnt = 0\nans = 0\nfor i in range(N):\n    cnt += 1\n    L[A[i][1]] = 1\n    if A[i][1] > 0 and L[A[i][1]-1] == 1:\n        cnt -= 1\n    if A[i][1] < N-1 and L[A[i][1]+1] == 1:\n        cnt -= 1\n\n    if i < N-1 and A[i][0] == A[i+1][0]:\n        continue\n    if A[i][0] == 0:\n        break\n    ans = max(ans, cnt)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n \nN = int(input())\nA = list(map(int, input().split()))\nif all(a == 0 for a in A):\n    print(0)\n    exit()\n \nposition = defaultdict(list)\nfor i, a in enumerate(A):\n    position[a].append(i)\n \nans = 0\nuse = 0\nlink = 0\nfor a in sorted(set(A), reverse=True):\n    use += len(position[a])\n    for i in position[a]:\n        if i > 0 and A[i] < A[i - 1]:\n            link += 1\n        if i < N - 1 and A[i] <= A[i + 1]:\n            link += 1\n    ans = max(ans, use - link)\nprint(ans)\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::io;\nuse std::io::prelude::*;\nuse std::collections::BTreeMap;\nuse std::iter;\n\nfn main() {\n    let mut buf = String::new();\n    let stdin = io::stdin();\n    let mut lock = stdin.lock();\n\n    lock.read_to_string(&mut buf);\n\n    let mut iter = buf.split_whitespace();\n    let n: usize = iter.next().unwrap().parse().unwrap();\n    let mut a = Vec::new();\n    let mut map: BTreeMap<usize, Vec<usize>> = BTreeMap::new();\n\n    for (i, h) in iter.map(|s| s.parse::<usize>().unwrap()).enumerate() {\n        a.push(h);\n        if map.contains_key(&h) {\n            map.get_mut(&h).unwrap().push(i);\n        } else {\n            map.insert(h, vec![i]);\n        }\n    }\n\n    if map.len() == 1 && map.contains_key(&0) {\n        println!(\"0\");\n        return;\n    }\n\n    let mut sunk = iter::repeat(false).take(n).collect();\n    let mut answer = 1;\n    let mut lands = 1;\n\n    for (&h, is) in map.iter() {\n        for &i in is.iter() {\n            fn connecting(v: &Vec<bool>, i: usize) -> isize {\n                let left = i == 0 || v[i-1];\n                let right = i == v.len() - 1 || v[i+1];\n\n                match (left, right) {\n                    (true, true) => -1,\n                    (false, false) => 1,\n                    _ => 0,\n                }\n            }\n\n            lands += connecting(&sunk, i);\n            sunk[i] = true;\n        }\n\n        answer = cmp::max(answer, lands);\n    }\n\n    println!(\"{}\", answer);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::cmp::Ordering;\n\nfn cmp(e1: &(usize, bool), e2: &(usize, bool)) -> std::cmp::Ordering {\n    if e1.0 < e2.0 {\n        Ordering::Less\n    } else if e1.0 > e2.0 {\n        Ordering::Greater\n    } else if e1.1 && !e2.1 {\n        Ordering::Greater\n    } else if !e1.1 && e2.1 {\n        Ordering::Less\n    } else {\n        Ordering::Equal\n    }\n}\nfn main() {\n    let n: usize = {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim().parse::<usize>().unwrap()\n    };\n    let mut a: Vec<usize> = {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim().split_whitespace().map(|c| usize::from_str(c).unwrap()).collect()\n    };\n    a.push(0);\n    \n    let mut ends: Vec<(usize, bool)> = Vec::new();\n    let mut top: usize = 0;\n    let mut up: bool = true;\n    for i in 0..n+1 {\n        if !up && (i == n || a[i+1] > a[i]) {\n            ends.push((a[i], true));\n            ends.push((top, false));\n            up = true;\n        } else if i != n && up && a[i+1] < a[i] {\n            top = a[i];\n            up = false;\n        }\n    }\n    \n    ends.sort_by(cmp);\n    \n    let mut max_overlaps = 0;\n    let mut overlaps = 0;\n    for end in ends {\n        if end.1 {\n            overlaps += 1;\n            if overlaps > max_overlaps {\n                max_overlaps = overlaps;\n            }\n        }\n        else {\n            overlaps -= 1;\n        }\n    }\n    println!(\"{}\", max_overlaps);\n}\n"
  }
]