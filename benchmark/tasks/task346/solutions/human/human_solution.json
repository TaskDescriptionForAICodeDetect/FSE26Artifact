[
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator < (const DD &a)const{ return mp>a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1599999],res;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp); \n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tif(tmp.mp>=res)continue;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tif(SP[i].Dam==0)continue;\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint dp[2][100010];\n\nint main(){\n\n  int n,m,hp[101];\n  while(cin>>n,n){\n  for(int i=0;i<n;i++) cin>>hp[i];\n\n  vector <P> mg[2];  \n  cin>>m;\n  for(int i=0,cost,dam;i<m;i++){\n    string name,type;\n    cin>>name>>cost>>type>>dam;\n    mg[type==\"All\"].push_back(P(dam,cost));\n  }\n\n  for(int i=0;i<2;i++)for(int j=1;j<100010;j++)dp[i][j]=INF;\n \n  for(int k=0;k<2;k++)\n    for(int i=0;i<(int)mg[k].size();i++)\n      for(int j=mg[k][i].f;j<=100000+mg[k][i].f;j++){\n\t\tdp[k][min(100000,j)]=min(dp[k][min(100000,j)],dp[k][min(100000,j-mg[k][i].f)]+mg[k][i].s);\n      }\n  \n  for(int i=0;i<2;i++)\n    for(int j=100000;j>=0;j--)\n      dp[i][j]=min(dp[i][j],dp[i][j+1]);\n\n  int ans=INF;\n  for(int i=0;i<100000;i++){\n    int cost=dp[1][i];\n    for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n    ans=min(ans,cost);\n }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint n,hp[N],m,mp[N],damage[N],minc;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nll ans;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    minc=INF;\n    for(int i=D-1;i>=0;i--){\n      minc=min(minc,dpSin[i]);\n      dpSin[i]=minc;\n    }\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      ll cnt=dpAll[i];\n      for(int j=0;j<n;j++){\n\tint k=hp[j]-i;\n\tif(k<0)k=0;\n\tcnt+=dpSin[k];\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        if(n==0){break;}\n    vector<ll> a(n);\n    for(auto &i:a){cin>>i;}\n    ll m;\n    cin>>m;\n    vector<pll> Sg,Ml;\n        ll mx=300000;\n        ll mx2=100000;\n    for(int i=0;i<m;i++){\n        string N,T;\n        ll M,D;\n        cin>>N>>M>>T>>D;\n        if(D>=mx2){D=mx2;}\n        if(T==\"Single\"){Sg.push_back({D,M});}\n        else if(T==\"All\"){Ml.push_back({D,M});}\n    }\n    vector<ll> dp1(mx,E),dp2(mx,E);\n    dp1[0]=dp2[0]=0;\n    for(auto &i:Sg){\n        for(int t=0;t+i.F<mx;t++){\n            dp1[t+i.F]=min(dp1[t+i.F],dp1[t]+i.S);\n        }\n        for(ll i=mx-2;i>=0;i--){\n            dp1[i]=min(dp1[i],dp1[i+1]);\n        }\n    }\n    for(auto &i:Ml){\n        for(int t=0;t+i.F<mx;t++){\n            dp2[t+i.F]=min(dp2[t+i.F],dp2[t]+i.S);\n        }\n        for(ll i=mx-2;i>=0;i--){\n            dp2[i]=min(dp2[i],dp2[i+1]);\n        }\n    }\n    ll ans=E;\n    for(int i=0;i<mx;i++){\n        ll count=dp2[i];\n        for(int t=0;t<n;t++){\n            if(a[t]>i){count+=dp1[a[t]-i];}\n        }\n        ans=min(ans,count);\n    }\n    cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 50000000;\nint single[101][SIZE+1];\nint all[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n  \n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){    \n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n}\n\n\n\nvoid calc_all(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)all[i][j]=INF;\n  all[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( all[i][j] >=INF)continue;\n      if ( j+damage[i] <=maxhp){\n\tall[i][j+damage[i]]=min(all[i][j+damage[i]],all[i][j]+mp[i]);\n\tall[i+1][j+damage[i]]=min(all[i+1][j+damage[i]],all[i][j]+mp[i]);\n      }else all[i+1][maxhp]=min(all[i+1][maxhp],all[i][j]+mp[i]);\n    }\n  }\n  \n  int tmp=all[n][maxhp];\n  for(int i=maxhp;i>=0;i--){    \n    if ( tmp > all[n][i])tmp=all[n][i];\n    res_all[i]=tmp;\n  }\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF;\n  calc_single(maxhp,mpsingle,damagesingle);\n  calc_all(maxhp,mpall,damageall);\n  \n\n\n\n  rep(i,maxhp){\n    if ( res_all[i]>=INF)continue;\n    int tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n; if(n==0) break;\n        vector<ll> hp(n);\n        for(ll& in:hp) cin >> in;\n        cin >> m;\n        vector<ll> consume(m),damage(m);\n        vector<string> type(m);\n        rep(i,0,m){\n            string s;\n            cin >> s >> consume[i] >> type[i] >> damage[i];\n        }\n\n        const ll sup=100001;\n        ll ans=inf,dp1[sup],dp2[sup];\n        fill_n((ll*)dp1,sup,inf);\n        fill_n((ll*)dp2,sup,inf);\n        dp1[0]=dp2[0]=0;\n        rep(i,0,m){\n            ll* dp;\n            if(type[i]==\"Single\") dp=dp1;\n            else dp=dp2;\n            rep(j,0,sup) dp[j]=min(dp[j],dp[max(j-damage[i],0LL)]+consume[i]);\n        }\n        rep(i,0,sup){\n            ll tmp=dp2[i];\n            rep(j,0,n) if(hp[j]-i>=0) tmp+=dp1[hp[j]-i];\n            ans=min(ans,tmp);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 100020\n#define inf 1<<22\nusing namespace std;\n\nint main()\n{\n  int n,m,hp[101],p,d;\n  string name,s;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    vector<pair<int,int> > all,single; \n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>name>>p>>s>>d;\n      if(s==\"Single\")single.push_back(mp(p,d));\n      else all.push_back(mp(p,d));\n    }\n    \n    int All[MAX],Single[MAX];\n    for(int i=0;i<MAX;i++){\n      All[i]=inf;\n      Single[i]=inf;\n    }\n    All[0]=0;\n    Single[0]=0;\n\n    for(int i=0;i<all.size();i++){\n      for(int j=0;j<MAX;j++){\n\tAll[min(j+all[i].s,MAX-1)]=min(All[min(j+all[i].s,MAX-1)],\n\t\t\t\t       All[j]+all[i].f);\n      }\n    }\n   \n    for(int i=0;i<single.size();i++){\n      for(int j=0;j<MAX;j++){\n\tSingle[min(j+single[i].s,MAX-1)]=min(Single[min(j+single[i].s,MAX-1)],\n\t\t\t\t\t     Single[j]+single[i].f);\n      }\n    }\n\n    int mina=inf,minb=inf;\n    for(int i=MAX-1;i>0;i--){\n      All[i]=min(mina,All[i]);\n      mina=min(All[i],mina);\n      Single[i]=min(minb,Single[i]);\n      minb=min(minb,Single[i]);\n    }\n\n    int ans=inf;\n    for(int i=0;i<MAX;i++){\n      if(All[i]==inf)continue;\n      int sum=All[i];\n      for(int j=0;j<n;j++){\n\tsum+=Single[max(hp[j]-i,0)];\n      }\n      ans=min(ans,sum);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\n#define N 100005\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n&&n){\n    int hp[100],m,mp[100],tg[100],dm[100];\n    string s;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>s>>mp[i]>>s>>dm[i];\n      tg[i]=s[0]=='A';\n    }\n    int dp[2][N];\n\n    for(int i=0;i<N;i++)dp[0][i]=dp[1][i]=inf;\n    dp[0][0]=dp[1][0]=0;\n    for(int i=0;i<m;i++)\n      for(int j=0;j<=N;j++)\n\tdp[tg[i]][min(N-1,j+dm[i])]=min(dp[tg[i]][min(N-1,j+dm[i])],dp[tg[i]][j]+mp[i]);\n\n    for(int i=N-1;i>0;i--){\n      dp[0][i-1]=min(dp[0][i-1],dp[0][i]);\n      dp[1][i-1]=min(dp[1][i-1],dp[1][i]);\n    }\n\n    int mn=inf;\n    for(int i=0;i<N;i++){\n      int s=dp[1][i];\n      for(int j=0;j<n;j++)\n\ts+=dp[0][max(0,hp[j]-i)];\n      mn=min(mn,s);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1e15;\nll single[1000010];\nll all[1000010];\nll HP[124];\n\nint main() {\n\tint N, M;\n\twhile(cin >> N, N) {\n\t\tll mxhp = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> HP[i];\n\t\t\tmxhp = max(mxhp, HP[i]);\n\t\t}\n\n\t\tmxhp += 10;\n\t\tfor(int i = 0; i < mxhp; i++) {\n\t\t\tsingle[i] = all[i] = INF;\n\t\t}\n\t\tsingle[0] = all[0] = 0;\n\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring name, type;\n\t\t\tll mp, dam;\n\t\t\tcin >> name >> mp >> type >> dam;\n\t\t//\tcout << mp << endl;\n\t\t\tif(type == \"Single\") {\n\t\t\t\tfor(int j = 0; j < mxhp; j++) {\n\t\t\t\t\tif(dam > j)\n\t\t\t\t\t\tsingle[j] = min(single[j], mp);\n\t\t\t\t\telse\n\t\t\t\t\t\tsingle[j] = min(single[j], single[j-dam] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(type == \"All\") {\n\t\t\t\tfor(int j = 0; j < mxhp; j++) {\n\t\t\t\t\tif(dam > j)\n\t\t\t\t\t\tall[j] = min(all[j], mp);\n\t\t\t\t\telse\n\t\t\t\t\t\tall[j] = min(all[j], all[j-dam] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < 100; i++)\n\t\t\tcout << single[i] << \" \";\n\t\tcout << endl;\n\t\tfor(int i = 0; i < 100; i++)\n\t\t\tcout << all[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\n\t\tll res = INF;\n\t\tfor(int i = 0; i < mxhp; i++) {\n\t\t\tll tmp = 0;\n\t\t\ttmp += all[i];\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\ttmp += single[max(0ll, HP[j] - i)];\n\t\t\t}\n\t\t\tres = min(res,tmp);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INFTY=1ll<<40;\n\nstruct Spell{\n\tint m,d;\n\tSpell(){}\n\tSpell(int m,int d):m(m),d(d){}\n};\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n,n;){\n\t\tvector<int> hs(n);\n\t\tfor(int& h:hs) cin>>h;\n\t\tcin>>m;\n\t\tvector<Spell> ss,as; // single,all\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring n,t; int m,d;\n\t\t\tcin>>n>>m>>t>>d; chmin(d,100000);\n\t\t\tif(t==\"Single\") ss.emplace_back(m,d);\n\t\t\telse            as.emplace_back(m,d);\n\t\t}\n\t\t\n\t\tvector<ll> sdp(100001,INFTY); sdp[0]=0;\n\t\tfor(int i=0;i<ss.size();i++){\n\t\t\tfor(int j=1;j<ss[i].d;j++)\n\t\t\t\tchmin<ll>(sdp[j],ss[i].m);\n\t\t\tfor(int j=ss[i].d;j<sdp.size();j++)\n\t\t\t\tchmin<ll>(sdp[j],sdp[j-ss[i].d]+ss[i].m);\n\t\t}\n\t\tvector<ll> adp(100001,INFTY); adp[0]=0;\n\t\tfor(int i=0;i<as.size();i++){\n\t\t\tfor(int j=1;j<as[i].d;j++)\n\t\t\t\tchmin<ll>(adp[j],as[i].m);\n\t\t\tfor(int j=as[i].d;j<adp.size();j++)\n\t\t\t\tchmin<ll>(adp[j],adp[j-as[i].d]+as[i].m);\n\t\t}\n\t\t\n\t\tll res=INFTY;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tll temp=adp[i];\n\t\t\tfor(int& h:hs)\n\t\t\t\ttemp+=sdp[max(h-i,0)];\n\t\t\tchmin(res,temp);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n \nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    int h[n];\n    for(int i=0; i<n; i++) cin >> h[i];\n    cin >> m;\n    vector<P> a,b;\n    string name,t;\n    for(int i=0; i<m; i++) {\n      P c;\n      cin >> name >> c.first >> t >> c.second;\n      if(t==\"All\") a.push_back(c);\n      else b.push_back(c);\n    }\n    sort(a.begin(),a.end());\n    sort(b.begin(),b.end());\n    int da[100001],db[100001];\n    fill(da,da+100001,1<<29);\n    fill(db,db+100001,1<<29);\n    da[0]=db[0]=0;\n    for(int i=0; i<a.size(); i++) {\n      for(int j=0; j<100001; j++) da[min(100000,j+a[i].second)]=min(da[min(100000,j+a[i].second)],da[j]+a[i].first);\n    }\n    for(int i=0; i<b.size(); i++) {\n      for(int j=0; j<100001; j++) db[min(100000,j+b[i].second)]=min(db[min(100000,j+b[i].second)],db[j]+b[i].first);\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    int ans=1<<29;\n    for(int i=0; i<=100000; i++) {\n      int d=da[i];\n      if(d==1<<29) continue;\n      bool f=1;\n      for(int j=0; j<n; j++) {\n        int x=max(0,h[j]-i);\n\tif(db[x]>=1<<29) f=0;\n        d+=db[x];\n      }\n      if(f) ans=min(ans,d);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\nint dp1[100101];\nint dp2[100101];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint HP[100] = {};\n\t\tfor (int i = 0; i < N; i++) cin >> HP[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<P> single;\n\t\tvector<P> all;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tif (target == \"Single\") {\n\t\t\t\tsingle.emplace_back(mp, damage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tall.emplace_back(mp, damage);\n\t\t\t}\n\t\t}\n\t\tfill(dp1, dp1 + 100101, 1 << 30);\n\t\tdp1[0] = 0;\n\t\tfor (int i = 1; i <= 100100; i++) {\n\t\t\tfor (int j = 0; j < single.size(); j++) {\n\t\t\t\tif (single[j].second > i) continue;\n\t\t\t\tif (dp1[i - single[j].second] == 1 << 30) continue;\n\t\t\t\tdp1[i] = min(dp1[i], dp1[i - single[j].second] + single[j].first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100100; i > 0; i--) {\n\t\t\tdp1[i - 1] = min(dp1[i - 1], dp1[i]);\n\t\t}\n\t\tfill(dp2, dp2 + 100101, 1 << 30);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 1; i <= 100100; i++) {\n\t\t\tfor (int j = 0; j < all.size(); j++) {\n\t\t\t\tif (all[j].second > i) continue;\n\t\t\t\tif (dp2[i - all[j].second] == 1 << 30) continue;\n\t\t\t\tdp2[i] = min(dp2[i], dp2[i - all[j].second] + all[j].first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100100; i > 0; i--) {\n\t\t\tdp2[i - 1] = min(dp2[i - 1], dp2[i]);\n\t\t}\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 0; i <= 100100; i++) {\n\t\t\tint cost = 0;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (HP[j] <= i) continue;\n\t\t\t\tcost += dp1[HP[j] - i];\n\t\t\t}\n\t\t\tcost += dp2[i];\n\t\t\tans = min(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\nint dp1[100101];\nint dp2[100101];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint HP[100] = {};\n\t\tfor (int i = 0; i < N; i++) cin >> HP[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<P> single;\n\t\tvector<P> all;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tif (target == \"Single\") {\n\t\t\t\tsingle.emplace_back(mp, damage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tall.emplace_back(mp, damage);\n\t\t\t}\n\t\t}\n\t\tfill(dp1, dp1 + 100101, 1 << 28);\n\t\tdp1[0] = 0;\n\t\tfor (int i = 1; i <= 100100; i++) {\n\t\t\tfor (int j = 0; j < single.size(); j++) {\n\t\t\t\tif (single[j].second > i) continue;\n\t\t\t\tdp1[i] = min(dp1[i], dp1[i - single[j].second] + single[j].first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100100; i > 0; i--) {\n\t\t\tdp1[i - 1] = min(dp1[i - 1], dp1[i]);\n\t\t}\n\t\tfill(dp2, dp2 + 100101, 1 << 28);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 1; i <= 100100; i++) {\n\t\t\tfor (int j = 0; j < all.size(); j++) {\n\t\t\t\tif (all[j].second > i) continue;\n\t\t\t\tdp2[i] = min(dp2[i], dp2[i - all[j].second] + all[j].first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100100; i > 0; i--) {\n\t\t\tdp2[i - 1] = min(dp2[i - 1], dp2[i]);\n\t\t}\n\t\tint ans = 1 << 28;\n\t\tfor (int i = 0; i <= 100100; i++) {\n\t\t\tint cost = 0;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (HP[j] <= i) continue;\n\t\t\t\tcost += dp1[HP[j] - i];\n\t\t\t}\n\t\t\tcost += dp2[i];\n\t\t\tans = min(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint single[100001];\nint all[100001];\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int hp[n];\n    int maxhp = 0;\n    REP(i,n) {\n      cin >> hp[i];\n      maxhp = max(maxhp, hp[i]);\n    }\n    int m;\n    cin >> m;\n    REP(i,maxhp+1)\n      single[i] = all[i] = INF;\n    single[0] = all[0] = 0;\n    REP(i,m) {\n      string s;\n      int mp,damage;\n      cin >> s>>mp>>s>>damage;\n      REP(j,maxhp+1) {\n        if (s == \"Single\")\n          single[j] = min(single[j], ((j>=damage)?single[j-damage]:0) + mp);\n        else\n          all[j] = min(all[j], ((j>=damage)?all[j-damage]:0) + mp);\n      }\n    }\n    // REP(i,maxhp) {\n    //   printf(\"%d : %d, %d\\n\", i, single[i], all[i]);\n    // }\n    int ans = INF;\n    REP(i, maxhp+1) {\n      int smp = 0;\n      REP(j,n) {\n        if (hp[j]>i)\n          smp += single[hp[j]-i];\n      }\n      ans = min(ans, all[i] + smp);\n    }\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll dp[10][1001000];\nll n, m;\nll hp[110];\nvector<ll> mp[2];\nvector<ll> d[2];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tmp[0].clear();\n\t\tmp[1].clear();\n\t\td[0].clear();\n\t\td[1].clear();\n\t\trep(i, n)cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tll mpp, dd;\n\t\t\tcin >> s >> mpp >> s >> dd;\n\t\t\tif (s == \"All\") {\n\t\t\t\tmp[0].push_back(mpp);\n\t\t\t\td[0].push_back(dd);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[1].push_back(mpp);\n\t\t\t\td[1].push_back(dd);\n\t\t\t}\n\t\t}\n\t\trep(i, 1001000) {\n\t\t\tdp[0][i] = INF;\n\t\t\tdp[1][i] = INF;\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp[1][0] = 0;\n\t\trep(i, mp[0].size()) {\n\t\t\trep(j, 1001000) {\n\t\t\t\tif (j + d[0][i] < 1001000) {\n\t\t\t\t\tdp[0][j + d[0][i]] = min(dp[0][j + d[0][i]], dp[0][j] + mp[0][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, mp[1].size()) {\n\t\t\trep(j, 1001000) {\n\t\t\t\tif (j + d[1][i] < 1001000) {\n\t\t\t\t\tdp[1][j + d[1][i]] = min(dp[1][j + d[1][i]], dp[1][j] + mp[1][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 2) {\n\t\t\tfor (int j = 1000000; j >= 0; j--) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t\t//rep(i, 2) {\n\t\t//\trep(j, 50) {\n\t\t//\t\tif (dp[i][j] == INF)cout << -1 << \" \";\n\t\t//\t\telse cout << dp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tll ans = INF;\n\t\trep(i, 1001000) {\n\t\t\tll sum = dp[0][i];\n\t\t\trep(j, n) {\n\t\t\t\tif (hp[j] - i >= 0)sum += dp[1][hp[j] - i];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst ll INF=100000000000000LL;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nll dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nll dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tll minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp*1LL);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tll res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tll res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp*1LL);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tll cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<28\n#define MAX_HP 100001\n\nusing namespace std;\n\nstruct monster{\n\tint hp;\n};\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n};\n\nvoid min_mp(int *min, int max_hp, const vector<magic> &vmag){\n\tint m = vmag.size();\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tmin[i] = INFTY;\n\t}\n\n\tif( m == 0 )\n\t\treturn ;\n\n\tint **dp = new int*[m];\n\tfor(int i = 0; i < m; ++i){\n\t\tdp[i] = new int[max_hp];\n\t}\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tdp[i][j] = INFTY;\n\t\t}\n\t}\n\t\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < m; ++i){\n\t\tint mp = vmag[i].mp;\n\t\tint damage = vmag[i].damage;\n\t\t\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tif( dp[i][j] < INFTY ){\n\t\t\t\tif( i + 1 < m )\n\t\t\t\t\tdp[i+1][j] = std::min( dp[i][j], dp[i+1][j] );\n\t\t\t\tint &a = dp[i][std::min(j+damage,max_hp-1)];\n\t\t\t\ta = std::min( a, dp[i][j] + mp );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = max_hp-1; i >= 0; --i){\n\t\tmin[i] = dp[m-1][i] == INFTY ? min[i+1] : std::min( min[i+1<max_hp?i+1:i], dp[m-1][i] );\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tdelete [] dp[i];\n\t}\n\tdelete [] dp;\n}\nint MagicSlayer(const vector<monster> &vmon, const vector<magic> &vmag){\n\tint ret = INFTY;\n\tvector<magic> vmag_single;\n\tvector<magic> vmag_all;\n\tint max_hp = 0;\n\tint min_mp_single[MAX_HP]={0,};\n\tint min_mp_all[MAX_HP]={0,};\n\n\tfor(unsigned int i = 0; i < vmon.size(); ++i){\n\t\tmax_hp = max( max_hp, vmon[i].hp );\n\t}\n\t++max_hp;\n\n\tfor(unsigned int i = 0; i < vmag.size(); ++i){\n\t\tif( vmag[i].type == ALL )\n\t\t\tvmag_all.push_back( vmag[i] );\n\t\telse\n\t\t\tvmag_single.push_back( vmag[i] );\n\t}\n\n\tmin_mp( min_mp_single, max_hp, vmag_single );\n\tmin_mp( min_mp_all, max_hp, vmag_all );\n\n\t/*for(int i = 0; i < max_hp; ++i){\n\t\tif( i % 500 == 0 )\n\t\t\tcout << \"DAMAGE: \" << i << \" MP: \" << min_mp_single[i] << endl;\n\t}*/\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tint dam;\n\t\tint t;\n\n\t\tif( min_mp_all[i] >= INFTY ){\n\t\t\tdam = 0;\n\t\t\tt = 0;\n\t\t}else{\n\t\t\tdam = i;\n\t\t\tt = min_mp_all[i];\n\t\t}\n\n\t\tfor(unsigned int j = 0; j < vmon.size(); ++j){\n\t\t\tif( vmon[j].hp - dam > 0 ){\n\t\t\t\tif( min_mp_single[ vmon[j].hp - dam ] >= INFTY )\n\t\t\t\t\tt = INFTY;\n\t\t\t\telse\n\t\t\t\t\tt += min_mp_single[ vmon[j].hp - dam ];\n\t\t\t}\n\t\t}\n\n\t\tret = min( ret, t );\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tvector<monster> vmonster;\n\t\tvector<magic> vmagic;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmonster t;\n\t\t\t\n\t\t\tscanf(\"%d\", &t.hp);\n\t\t\tvmonster.push_back( t );\n\t\t}\n\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar stype[17]=\"\";\n\t\t\tmagic mag;\n\n\t\t\tscanf(\"%*s%d%s%d\", &mag.mp, stype, &mag.damage);\n\t\t\tif(strcmp(stype,\"All\")==0)mag.type=ALL;\n\t\t\telse mag.type=SINGLE;\n\t\t\tvmagic.push_back( mag );\n\t\t}\n\n\t\tprintf(\"%d\\n\", MagicSlayer( vmonster, vmagic ) );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define MAX_H 100000\n#define INF (1<<29)\ntypedef long long ll;\n\nint main(){\n    ll N,M;\n    string in;\n    while(cin >> N, N){\n        ll MHP = 0;\n        vector<ll> HP(N);\n        for(ll i = 0 ; i < N ; i++){\n            cin >> HP[i];\n            MHP = max(MHP,HP[i]);\n        }\n        cin >> M;\n        vector<ll> MP(M),t(M),d(M);\n        for(ll i = 0 ; i < M ; i++){\n            cin >> in >> MP[i] >> in >> d[i];\n            t[i] = (in == \"All\");\n        }\n        ll dp[2][MAX_H+1];\n        fill(dp[0],dp[0]+2*(MAX_H+1),INF);\n        dp[0][0] = dp[1][0] = 0;\n        for(ll i = 0 ; i < M ; i++){\n            for(ll j = 0 ; j <= MHP ; j++){\n                ll nt = t[i],nhp = min(MHP,j+d[i]);\n                dp[nt][nhp] = min(dp[nt][nhp],dp[nt][j]+MP[i]);\n            }\n        }\n        for(ll i = MHP ; i > 0 ; i--){\n            dp[0][i-1] = min(dp[0][i-1],dp[0][i]);\n            dp[1][i-1] = min(dp[1][i-1],dp[1][i]);\n        }\n        ll res = INF;\n        for(ll i = 0 ; i <= MHP ; i++){\n            ll mp = dp[1][i],mp2 = 0;\n            if(mp == INF) continue;\n            for(ll j = 0 ; j < N ; j++){\n                ll rest = max(HP[j]-i,0LL);\n                if(rest == 0) continue;\n                mp2 += dp[0][rest];\n            }\n            res = min(res,mp+mp2);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int MAX_HP = 100000;\nint enemy[110];\nint dp[2][MAX_HP + 10];\n\nvoid calc(int idx, vector<int> cst, vector<int> dmg) {\n    int N = cst.size();\n    fill(dp[idx], dp[idx] + MAX_HP + 1, INF);\n    dp[idx][0] = 0;\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=MAX_HP; j++) {\n            int nj = min(MAX_HP, j+dmg[i]);\n            dp[idx][nj] = min(dp[idx][nj], dp[idx][j] + cst[i]);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    while(cin >> N) {\n        if(N == 0) break;\n        for(int i=0; i<N; i++) cin >> enemy[i];\n        cin >> M;\n\n        vector<int> cst1, cst2, dmg1, dmg2;\n        for(int i=0; i<M; i++) {\n            string s, target;\n            int cost, damage;\n            cin >> s >> cost >> target >> damage;\n            damage = min(damage, MAX_HP);\n            if(target == \"Single\") {\n                cst1.push_back(cost);\n                dmg1.push_back(damage);\n            }\n            else {\n                cst2.push_back(cost);\n                dmg2.push_back(damage);\n            }\n        }\n\n        calc(0, cst1, dmg1);\n        calc(1, cst2, dmg2);\n        for(int j=MAX_HP-1; j>=0; j--) {\n            dp[0][j] = min(dp[0][j], dp[0][j+1]);\n        }\n\n        int ans = INF;\n        // 全体攻撃によるダメージ\n        for(int dmg=0; dmg<=MAX_HP; dmg++) {\n            int tmp = dp[1][dmg];\n            if(tmp == INF) continue;\n            for(int i=0; i<N; i++) {\n                if(enemy[i] <= dmg) continue;\n                tmp += dp[0][enemy[i] - dmg];\n            }\n            ans = min(ans, tmp);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nint dp1[100010];\nint dp2[100010];\nvoid mainmain(){\n\tint n;\n\tint m;\n\twhile(scanf(\"%d\",&n),n){\n\t\tvint hp(n);\n\t\trep(i,n) scanf(\"%d\",&hp[i]);\n\t\tscanf(\"%d\",&m);\n\t\tvector<pii> one,all;\n\t\tbool f=false;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint a,b;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tcin>>s;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(a==0&&b!=0){\n\t\t\t\tf=true;\n\t\t\t}\n\t\t\tif(s==\"Single\"){\n\t\t\t\tone.PB(mkp(a,b));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tall.PB(mkp(a,b));\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,100010){\n\t\t\tdp1[i]=INF;\n\t\t\tdp2[i]=INF;\n\t\t}\n\t\tdp1[0]=0;\n\t\trep(i,one.size()){\n\t\t\tint t=INF;\n\t\t\trep(j,100010){\n\t\t\t\tif(j+one[i].S>=100010){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tt=0;\n\t\t\t\t\t}\n\t\t\t\t\tdp1[100009]=min(dp1[100009],t+one[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp1[j]==INF) continue;\n\t\t\t\tdp1[j+one[i].S]=min(dp1[j+one[i].S],dp1[j]+one[i].F);\n\t\t\t\tif(j+one[i].S*2>=100010) t=min(t,dp1[j+one[i].S]);\n\t\t\t}\n\t\t}\n\t\tint M=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],M);\n\t\t\tM=min(dp1[i],M);\n\t\t}\n\t\tdp2[0]=0;\n\t\trep(i,all.size()){\n\t\t\tint t=INF;\n\t\t\trep(j,100010){\n\t\t\t\tif(j+all[i].S>=100010){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tt=0;\n\t\t\t\t\t}\n\t\t\t\t\tdp2[100009]=min(dp2[100009],t+all[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp2[j]==INF) continue;\n\t\t\t\tdp2[j+all[i].S]=min(dp2[j+all[i].S],dp2[j]+all[i].F);\n\t\t\t\tif(j+all[i].S*2>=100010) t=min(t,dp2[j+all[i].S]);\n\t\t\t}\n\t\t}\n\t\tM=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\tdp2[i]=min(dp2[i],M);\n\t\t\tM=min(dp2[i],M);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,100010){\n\t\t\tint tmp=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tif(hp[j]<=i) continue;\n\t\t\t\ttmp+=dp1[hp[j]-i];\n\t\t\t}\n\t\t\tans=min(ans,tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst long long INF = 1LL << 60;\nusing namespace std;\n\nconst int MAX_D = 1000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tif(i + a[j].second >= MAX_D) continue;\n\t\t\tres[i + a[j].second] = min(res[i + a[j].second], res[i] + a[j].first);\n\t\t}\n\t}\n\n\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\tif(res[i - 1] == INF) res[i - 1] = res[i];\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\n\t\tlong long ans = INF;\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) break;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\nint N,M,HP[105],A,SDP[100005],ADP[100005],res,tmp;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tmemset(ADP,0x7f,sizeof(ADP));\n\t\tSDP[0]=ADP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tSDP[np]=min(SDP[np],SDP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tfor(int i=100000;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\n\t\tfor(int i=A-1;i<M;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\t\tif(np>100000)np=100000;\n\t\t\t\t\tADP[np]=min(ADP[np],ADP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=100000;i++)\n\t\t{\n\t\t\ttmp=ADP[i];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tif(HP[k]-i>=0)\n\t\t\t\t\ttmp+=SDP[HP[k]-i];\n\t\t\t}\n\t\t\tres=min(res,tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n\tmpA.push_back(mp);\n\tdmA.push_back(dm);\t\n      }else{\n\tmpS.push_back(mp);\n\tdmS.push_back(dm);\t\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) ;//+ 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    /*\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n\tint tmp = i - dmA[j];\n\tif(tmp < 0) tmp = 0;\n\ttA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n\tint tmp = i - dmS[j];\n\tif(tmp < 0) tmp = 0;\n\ttS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n    memset(dpS, -1, sizeof(int)*h+1);\n    memset(dpA, -1, sizeof(int)*h+1);\n\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(dpS[dm] != -1) continue;\n      dpS[dm] = mp;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n\tint mm = mp + mpS[i];\n\tint dd = dm + dmS[i];\n\n\tif(dd > h) dd = h;\n\tif(dpS[dd] == -1)\n\t  q.push(mpi(mm,dd));\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(dpA[dm] != -1) continue;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n\tint mm = mp + mpA[i];\n\tint dd = dm + dmA[i];\n\n\tif(dd > h) dd = h;\n\tif(dpA[dd] == -1)\n\t  q.push(mpi(mm,dd));\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      if(dpA[i] == -1) dpA[i] = dpA[i+1];\n      else             dpA[i] = min(dpA[i+1], dpA[i]);\n\n      if(dpS[i] == -1) dpS[i] = dpS[i+1];\n      else             dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    REP(i,h){\n      int mp = dpA[i];\n      int dm = i;\n\n      REP(j,n)\n\tif(hp[j] > dm)\n\t  mp += dpS[hp[j] - dm];\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n\n#define HP_MAX 100005\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint N; cin >> N;\n\t\tif (N == 0) return 0;\n\t\tvi HP(N); rep(i, 0, N) cin >> HP[i];\n\n\t\tint M; cin >> M;\n\t\tvector<pii> single, all;\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring a, b; int mp, da;\n\t\t\tcin >> a >> mp >> b >> da;\n\t\t\tif (b == \"Single\")\n\t\t\t\tsingle.push_back(pii(mp, da));\n\t\t\telse\n\t\t\t\tall.push_back(pii(mp, da));\n\t\t}\n\n\t\tvi sdp(HP_MAX, INF);\n\t\tsdp[0] = 0;\n\t\trep(i, 0, HP_MAX)\n\t\t{\n\t\t\tif (sdp[i] == INF) continue;\n\t\t\tfor (auto p : single)\n\t\t\t{\n\t\t\t\tint mp = p.first;\n\t\t\t\tint da = p.second;\n\n\t\t\t\tint ni = i + da;\n\n\t\t\t\tif (HP_MAX <= ni) ni = HP_MAX - 1;\n\t\t\t\tsdp[ni] = min(sdp[ni], sdp[i] + mp);\n\t\t\t}\n\t\t}\n\t\tint _min = sdp[HP_MAX - 1];\n\t\trrep(i, HP_MAX - 2, 0)\n\t\t{\n\t\t\t_min = min(_min, sdp[i]);\n\t\t\tsdp[i] = _min;\n\t\t}\n\n\t\tvi adp(HP_MAX, INF);\n\t\tadp[0] = 0;\n\t\trep(i, 0, HP_MAX)\n\t\t{\n\t\t\tif (adp[i] == INF) continue;\n\t\t\tfor (auto p : all)\n\t\t\t{\n\t\t\t\tint mp = p.first;\n\t\t\t\tint da = p.second;\n\n\t\t\t\tint ni = i + da;\n\n\t\t\t\tif (HP_MAX <= ni) ni = HP_MAX - 1;\n\t\t\t\tadp[ni] = min(adp[ni], adp[i] + mp);\n\t\t\t}\n\t\t}\n\t\t_min = adp[HP_MAX - 1];\n\t\trrep(i, HP_MAX - 2, 0)\n\t\t{\n\t\t\t_min = min(_min, adp[i]);\n\t\t\tadp[i] = _min;\n\t\t}\n\n\t\tll ans = INF;\n\t\trep(i, 0, HP_MAX)\n\t\t{\n\t\t\tll mp = adp[i];\n\t\t\trep(j, 0, N)\n\t\t\t{\n\t\t\t\tint d = HP[j] - i;\n\t\t\t\tif (d < 0) continue;\n\t\t\t\tmp += sdp[d];\n\t\t\t}\n\t\t\tans = min(ans, mp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint h[100];\nvector<pair<int, int>> s, a;\nlong long dp[100010];\nlong long dp2[100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring na, ta;\n\t\t\tint mp, da;\n\t\t\tcin >> na >> mp >> ta >> da;\n\t\t\t(ta == \"Single\" ? s : a).emplace_back(mp, da);\n\t\t}\n\n\t\tfill_n(dp, 100010, 1ll << 60);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < s.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < s[i].second ? 0 : dp[j - s[i].second];\n\t\t\t\tdp[j] = min<long long>(dp[j], t + s[i].first);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp2, 100010, 1ll << 60);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < a.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < a[i].second ? 0 : dp2[j - a[i].second];\n\t\t\t\tdp2[j] = min<long long>(dp2[j], t + a[i].first);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long res = 1ll << 60;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long sum = dp2[i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i <= h[j]) sum += dp[h[j] - i];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\n#define N 100002\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n&&n){\n    int hp[100],m,mp[100],tg[100]={},dm[100];\n    string s;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>s>>mp[i]>>s>>dm[i];\n      if(s[0]=='A')tg[i]=1;\n    }\n    int dp[2][N];\n    for(int i=0;i<N;i++)dp[0][i]=dp[1][i]=inf;\n    dp[0][0]=dp[1][0]=0;\n    for(int i=0;i<m;i++)\n      for(int j=0;j<N;j++)\n\tdp[tg[i]][min(N,j+dm[i])]=min(dp[tg[i]][min(N,j+dm[i])],dp[tg[i]][j]+mp[i]);\n    for(int i=N-1;i>0;i--){\n      dp[0][i-1]=min(dp[0][i-1],dp[0][i]);\n      dp[1][i-1]=min(dp[1][i-1],dp[1][i]);\n    }\n    int mn=inf;\n    for(int i=0;i<N;i++){\n      int s=dp[1][i];\n      for(int j=0;j<n;j++)\n\ts+=dp[0][max(0,hp[j]-i)];\n      mn=min(mn,s);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100001;\nconst int INF = (1<<29);\nstruct Spell{\n  string name,tar;\n  int MP,Dam;\n  Spell(){}\n  Spell(string n, int m, string t, int d):name(n),MP(m),tar(t),Dam(d){}\n};\n\nint dp[2][MAX];\nvector<int> Enemy;\nvector<Spell> V[2];\nint N;\n\nvoid init(){\n  fill(dp[0],dp[0]+2*MAX,INF);\n\n  //for(int i = 0; i < 2; i++) for(int j = 0; j < MAX; j++) dp[i][j] = INF;\n  V[0].clear();\n  V[1].clear();\n  Enemy.clear();\n}\n\nvoid input(){\n\n  while(N--){\n    int in;\n    cin >> in;\n    Enemy.push_back(in);\n  }\n\n  int m;\n  cin >> m;\n  while(m--){\n    Spell s;\n    cin >> s.name >> s.MP >> s.tar >> s.Dam;\n    if(s.tar == \"All\") V[0].push_back(s);\n    else V[1].push_back(s);\n  }\n\n}\n\n\nvoid make(){\n\n  dp[0][0] = dp[1][0] = 0;\n\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < MAX; i++){\n      if(dp[x][i] == INF) continue;\n      for(int j = 0; j < V[x].size(); j++){\n        int nex = min(i+V[x][j].Dam,100000);\n        int cos = dp[x][i]+V[x][j].MP;\n        dp[x][nex] = min(dp[x][nex],cos);\n      }\n    }\n  }\n  \n  int mincos[2];\n  mincos[0] = dp[0][MAX-1];\n  mincos[1] = dp[1][MAX-1];\n  \n  for(int i = MAX-1; i >= 0; i--){\n    mincos[0] = min(mincos[0],dp[0][i]);\n    mincos[1] = min(mincos[1],dp[1][i]);\n    dp[0][i] = min(dp[0][i],mincos[0]);\n    dp[1][i] = min(dp[1][i],mincos[1]);\n  }\n}\n\nvoid solve(){\n\n  int ans = INF;\n\n  for(int i = 0; i < MAX; i++){\n\n    int cos = dp[0][i];\n    for(int j = 0; j < Enemy.size(); j++){\n      int need = max(Enemy[j]-i,0);\n      cos+=dp[1][need];\n\n      //    cout << \"cos \" << dp[1][need] << endl;\n    }\n    ans = min(ans,cos);\n  }\n  cout << ans << endl;\n}\n\n\nint main(){\n\n  while(cin >> N && N){\n    init();\n    input();\n    make();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nconst int INF = 1000000000;\n\nvector<int> solve_dp(\n\tint max_damage, const vector<int> &mp, const vector<int> &damage)\n{\n\tvector<int> dp(max_damage, -1);\n\tdp[0] = 0;\n\tfor(int i = 0; i < mp.size(); ++i){\n\t\tfor(int j = 0; j < max_damage; ++j){\n\t\t\tif(dp[j] < 0){ continue; }\n\t\t\tint idx = j + damage[i];\n\t\t\tif(idx >= max_damage){ break; }\n\t\t\tif(dp[idx] < 0){\n\t\t\t\tdp[idx] = dp[j] + mp[i];\n\t\t\t}else{\n\t\t\t\tdp[idx] = min(dp[idx], dp[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = max_damage - 2; i >= 0; --i){\n\t\tif(dp[i + 1] < 0){ continue; }\n\t\tif(dp[i] < 0){\n\t\t\tdp[i] = dp[i + 1];\n\t\t}else{\n\t\t\tdp[i] = min(dp[i], dp[i + 1]);\n\t\t}\n\t}\n\treturn dp;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<int> hp(n);\n\t\tint max_hp = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> hp[i];\n\t\t\tmax_hp = max(max_hp, hp[i]);\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<int> all_mp, all_damage;\n\t\tvector<int> single_mp, single_damage;\n\t\tint max_damage = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tmax_damage = max(max_damage, damage);\n\t\t\tif(target == \"All\"){\n\t\t\t\tall_mp.push_back(mp);\n\t\t\t\tall_damage.push_back(damage);\n\t\t\t}else{\n\t\t\t\tsingle_mp.push_back(mp);\n\t\t\t\tsingle_damage.push_back(damage);\n\t\t\t}\n\t\t}\n\t\tint am = all_mp.size(), sm = single_mp.size();\n\t\tmax_damage = max(max_damage, max_hp) + max_damage + 1;\n\t\tvector<int> all_dp = solve_dp(max_damage, all_mp, all_damage);\n\t\tvector<int> single_dp = solve_dp(max_damage, single_mp, single_damage);\n\t\tint answer = INF;\n\t\tfor(int i = 0; i < max_damage; ++i){\n\t\t\tint sum = all_dp[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(hp[j] <= i){ continue; }\n\t\t\t\tsum += single_dp[hp[j] - i];\n\t\t\t}\n\t\t\tanswer = min(answer, sum);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\t\tif(all.empty()){\n\t\t\tfor(r=j=0;j<monster.size();j++)r+=single[monster[j]];\n\t\t//}else if(single.empty()){\n\t\t//\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;\n\t\t\tfor(i=0;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\nusing P = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<int> hp(N);\n        int max_hp = 0;\n        for(int i=0; i<N; ++i) {\n            cin >> hp[i];\n            max_hp = max(max_hp, hp[i]);\n        }\n        int M;\n        cin >> M;\n        vector<vector<P>> s(2);\n        for(int i=0; i<M; ++i) {\n            string name, target;\n            int mp, dam;\n            cin >> name >> mp >> target >> dam;\n            if(dam == 0) {\n                continue;\n            }\n            s[target == \"All\"].emplace_back(mp, dam);\n        }\n        vector<vector<int>> cost(2, vector<int>(max_hp+1, INF));\n        cost[0][0] = cost[1][0] = 0;\n        for(int k=0; k<2; ++k) {\n            for(int i=0; i<s[k].size(); ++i) {\n                for(int j=0; j<=max_hp; ++j) {\n                    int t = min(max_hp, j+s[k][i].second);\n                    cost[k][t] = min(cost[k][t], cost[k][j] + s[k][i].first);\n                }\n            }\n        }\n        for(int j=max_hp; j>=1; --j) {\n            cost[0][j-1] = min(cost[0][j-1], cost[0][j]);\n        }\n        if(s[0].size() == 0) {\n            cout << cost[1][max_hp] << endl;\n        } else {\n            int res = INF;\n            for(int i=0; i<=max_hp; ++i) {\n                if(cost[1][i] == INF) {\n                    continue;\n                }\n                int t = cost[1][i];\n                for(int j=0; j<N; ++j) {\n                    int rest_hp = hp[j] - i;\n                    if(rest_hp <= 0 || cost[0][rest_hp] == INF) {\n                        continue;\n                    }\n                    t += cost[0][rest_hp];\n                }\n                res = min(res, t);\n            }\n            cout << res << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Magic{ int cost,damage; };\nvector<Magic> s,a;\n\nconst int N=200000;\n\nconst int INF=123456789;\nint dp[2][N+1];\nvoid calc(const vector<Magic> &v, int dst[])\n{\n    int V=v.size();\n\n    fill(dp[0],dp[2],INF);\n    dp[0][0]=0;\n    rep(i,V)rep(j,N+2)\n    {\n        if(j-v[i].damage<0) dp[(i+1)&1][j]=dp[i&1][j];\n        else dp[(i+1)&1][j]=min(dp[i&1][j],dp[(i+1)&1][j-v[i].damage]+v[i].cost);\n    }\n\n    rep(i,N+1) dst[i]=dp[V&1][i];\n\n    int min_cost=INF;\n    for(int i=N; i>=0; --i)\n    {\n        min_cost=min(min_cost,dst[i]);\n        dst[i]=min_cost;\n    }\n}\n\nint main()\n{\n    int ds[N+1],da[N+1];\n\n    int n;\n    while(cin >>n,n)\n    {\n        s.clear();\n        a.clear();\n\n        vector<int> hp(n);\n        rep(i,n) cin >>hp[i];\n\n        int m;\n        cin >>m;\n        rep(i,m)\n        {\n            string M,sa;\n            int mp,d;\n            cin >>M >>mp >>sa >>d;\n\n            if(d==0) continue;\n            if(d>=N) d=N;\n\n            if(sa==\"All\") a.pb(Magic{mp,d});\n            else s.pb(Magic{mp,d});\n        }\n\n        calc(s,ds);\n        calc(a,da);\n\n        int ans=INF;\n\n        rep(i,100001)\n        {\n            bool valid=true;\n            int tmp=da[i];\n            rep(j,n)\n            {\n                int rem=hp[j]-i;\n                if(rem<=0) continue;\n                if(ds[rem]==INF)\n                {\n                    valid=false;\n                    break;\n                }\n                tmp+=ds[rem];\n            }\n\n            if(!valid) continue;\n            ans=min(ans,tmp);\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nint HP[101];\n\nint M;\n\nvector< tuple<int, int, int> > magic;\n\nint dp[2][1000001]; // Single/All???just i???????????????????????????????°????MP\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    magic.clear();\n\n    int mxhp = 0;\n    rep(i, N) cin >> HP[i], mxhp = max(mxhp, HP[i]);\n\n    cin >> M;\n    rep(i, M) {\n      string na, tar;\n      int mp, dam;\n      cin >> na >> mp >> tar >> dam;\n      magic.emplace_back(mp, (tar == \"All\"), dam);\n    }\n\n    fill(dp[0], dp[2], inf);\n    dp[0][0] = dp[1][0] = 0;\n    for(auto m : magic) {\n      int mp, tar, dam;\n      tie(mp, tar, dam) = m;\n      rep(i, mxhp+1) {\n\tdp[tar][min(mxhp, i+dam)] = min(dp[tar][min(mxhp, i+dam)], dp[tar][i] + mp);\n      }\n    }\n\n    int ans = inf;\n    rep(i, mxhp+1) if(dp[1][i] != inf) {\n      int sum = dp[1][i];\n      rep(j, N) sum += dp[0][max(HP[j]-i, 0LL)];\n      ans = min(ans, sum);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\n#define inf 1<<60\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        for(int i=1;i<=10000;i++)dp2[i]=inf;\n        memset(dp1,0,sizeof dp1);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=1ll<<60,sum;\n        for(int i=0; i<10001; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n//            ll tmp=sum;\n            if(dp2[i]<0)continue;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 2e5+10;\n\nint dp_s[N];\nint dp_a[N];\n\nint mons[110];\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = 1e9;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tv = min(v, 100000);\n\t\t\tint *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\tfor (int i = 0; i + v < N; ++i){\n\t\t\t\tdp[i + v] = min(dp[i + v], dp[i] + w);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = N - 5; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tint ans = 1e9;\n\t\trep(i, N){\n\t\t\tint tmp = dp_a[i];\n\t\t\tif (tmp == 1e9) continue;\n\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nstruct Magic{ int cost,dmg; };\n\nint main(){\n\tfor(int n,m;scanf(\"%d\",&n),n;){\n\t\tint hp[100],hp_max=-1;\n\t\trep(i,n) scanf(\"%d\",hp+i), hp_max=max(hp_max,hp[i]);\n\n\t\tscanf(\"%d\",&m);\n\t\tint ms=0,ma=0; // s:single, a:all\n\t\tMagic magic_s[100],magic_a[100];\n\t\trep(i,m){\n\t\t\tint cost,dmg;\n\t\t\tchar s[7];\n\t\t\tscanf(\"%*s%d%s%d\",&cost,s,&dmg), dmg=min(dmg,hp_max);\n\t\t\tif(dmg>0){\n\t\t\t\tif(s[0]=='S') magic_s[ms++]=(Magic){cost,dmg};\n\t\t\t\telse          magic_a[ma++]=(Magic){cost,dmg};\n\t\t\t}\n\t\t}\n\n\t\tstatic int dp_a[100001];\n\t\trep(j,hp_max+1) dp_a[j]=(j==0?0:INF);\n\t\trep(i,ma){\n\t\t\tint cost=magic_a[i].cost,dmg=magic_a[i].dmg;\n\t\t\trep(j,hp_max-dmg+1) dp_a[j+dmg]=min(dp_a[j+dmg],dp_a[j]+cost);\n\t\t}\n\n\t\tstatic int dp_s[200001];\n\t\trep(j,2*hp_max+1) dp_s[j]=(j==0?0:INF);\n\t\trep(i,ms){\n\t\t\tint cost=magic_s[i].cost,dmg=magic_s[i].dmg;\n\t\t\trep(j,2*hp_max-dmg+1) dp_s[j+dmg]=min(dp_s[j+dmg],dp_s[j]+cost);\n\t\t}\n\t\tfor(int j=2*hp_max;j>0;j--) dp_s[j-1]=min(dp_s[j-1],dp_s[j]);\n\n\t\tint ans=INF;\n\t\trep(j,hp_max+1){\n\t\t\tint cost=dp_a[j];\n\t\t\trep(i,n) cost+=dp_s[max(hp[i]-j,0)];\n\t\t\tans=min(ans,cost);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 1e5+10;\n\nint dp_s[N];\nint dp_a[N];\n\nint mons[110];\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = 1e9;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tv = min(v, N - 5);\n\t\t\tint *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\tfor (int i = 0; i + v < N; ++i){\n\t\t\t\tdp[i + v] = min(dp[i + v], dp[i] + w);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = N - 5; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tint ans = 1e9;\n\t\trep(i, N){\n\t\t\tint tmp = dp_a[i];\n\t\t\tif (tmp == 1e9) continue;\n\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    int hp[100];\n    REP(i, N) cin>>hp[i];\n    int M; cin>>M;\n    int mp[100], pow[100], type[100];\n    REP(i, M){\n      string s; cin>>s;\n      cin>>mp[i];\n      cin>>s;\n      if(s == \"Single\") type[i] = 0;\n      else type[i] = 1;\n      cin>>pow[i];\n    }\n    ll dp[2][100001];\n    REP(i, 2) fill(dp[i], dp[i] + 100001, 1e16);\n    dp[0][0] = 0, dp[1][0] = 0;\n    REP(from, 100000){\n      REP(i, M){\n        int to = from + pow[i];\n        if(to > 100000) to = 100000;\n        dp[type[i]][to] = min(dp[type[i]][to], dp[type[i]][from] + mp[i]);\n      }\n    }\n    REP(i, 2) for(int j = 100000; j > 0; j--) dp[i][j - 1] = min(dp[i][j - 1], dp[i][j]);\n    ll ans = 1e16;\n    REP(all, 100001){\n      ll sub_ans = dp[1][all];\n      REP(i, N){\n        if(hp[i] - all > 0){\n          sub_ans += dp[0][hp[i] - all];\n        }\n      }\n      ans = min(ans, sub_ans);\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n, n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 100000 + 1;\n    const int inf = 100000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          for(int k = 1; j + k * damage < MAX; k++){\n            memo[j + k * damage] = min(memo[j + k * damage], memo[j] + k * mp);\n          }\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      if(cc == 1){\n        for(int j = MAX - 1; j > 0; j--){\n          memo[j - 1] = min(memo[j - 1], memo[j]);\n        }\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      if(mp >= ans) goto next;\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n          if(mp >= ans) goto next;\n        }\n      }\n      ans = mp;\n    next:;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#define INF (1<<21)\nusing namespace std;\n\nclass Enemy{\npublic:\n  int hp[100];\n  int mp,a;\n  bool operator < (const Enemy &p)const{\n    return mp > p.mp;\n  }\n  Enemy (int mp = 0,int a = 0): mp(mp),a(a){}\n};\n\nclass Actor{\npublic:\n  int mp,damage;\n  string name;\n  bool all;\n};\n\nint main(){\n  int i,j,k,n,m,ans;\n  string str;\n  while(1){\n    Enemy u,v;\n    Actor p[100];\n    priority_queue<Enemy> Q;\n    cin >> n;\n    if(n == 0) break;\n    for(i=0;i<n;i++){\n      cin >> u.hp[i];\n    }\n    cin >> m;\n    for(i=0;i<m;i++){\n      cin >> p[i].name >> p[i].mp >> str >> p[i].damage;\n      if(str == \"Single\") p[i].all = false;\n      else p[i].all = true;\n    }\n\n    ans = INF;\n    Q.push(u);\n    bool f = false;\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      if(ans != INF) break;\n      /*if(u.a >= n){\n\tans = min(ans,u.mp);\n\tbreak;\n\t}*/\n\n      for(i=0;i<m;i++){\n\tif(p[i].damage <= 0) continue;\n\tv = u;\n\tv.mp += p[i].mp;\n\tif(v.mp >= ans) continue;\n\n\tif(p[i].all){\n\t  for(j=0;j<n;j++){\n\t    if(v.hp[j] > 0 && v.hp[j] - p[i].damage <= 0) v.a++;\n\t    v.hp[j] -= min(v.hp[j],p[i].damage);\n\t  }\n\t  if(v.a >= n){\n\t    ans = min(ans,v.mp);\n\t    f = true;\n\t  }\n\t  else Q.push(v);\n\t}\n\n\telse{\n\t  for(j=0;j<n;j++){\n\t    v = u;\n\t    v.mp += p[i].mp;\n\t    if(v.mp >= ans) continue;\n\n\t    if(v.hp[j] > 0 && v.hp[j] - p[i].damage <= 0) v.a++;\n\t    v.hp[j] -= min(v.hp[j],p[i].damage);\n\t    if(v.a >= n){\n\t      ans = min(ans,v.mp);\n\t      f = true;\n\t    }\n\t    else Q.push(v);\n\t  }\n\t}\n      }\n      if(f) break;\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int64_t INF = 1e+8;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<int> hp(n);\n    REP(i,n)cin>>hp[i];\n    int m;\n    cin>>m;\n    vector<tuple<int64_t,int64_t>> sg;\n    vector<tuple<int64_t,int64_t>> al;\n    REP(i,m){\n      string name,tg;\n      int mp,dm;\n      cin>>name>>mp>>tg>>dm;\n      if(tg==\"Single\")\n        sg.emplace_back(mp,dm);\n      else\n        al.emplace_back(mp,dm);\n    }\n    int a=sg.size();\n    int b=al.size();\n    vector<vector<int64_t>> dps(a+1, vector<int64_t>(100001, INF));\n    vector<vector<int64_t>> dpa(b+1, vector<int64_t>(100001, INF));\n    dps[0][0] = 0;\n    dpa[0][0] = 0;\n    REP(i,a) {\n      REP(j,100001) {\n        dps[i+1][j] = dps[i][j];\n        if (j >= get<1>(sg[i]))\n          dps[i+1][j] = min(dps[i+1][j], dps[i+1][j-get<1>(sg[i])] + get<0>(sg[i]));\n        else\n          dps[i+1][j] = min(dps[i+1][j], get<0>(sg[i]));\n      }\n    }\n    REP(i,b) {\n      REP(j,100001) {\n        dpa[i+1][j] = dpa[i][j];\n        if (j >= get<1>(al[i]))\n          dpa[i+1][j] = min(dpa[i+1][j], dpa[i+1][j-get<1>(al[i])] + get<0>(al[i]));\n        else\n          dpa[i+1][j] = min(dpa[i+1][j], get<0>(al[i]));\n      }\n    }\n    vector<int64_t> costs(100001);\n    REP(i,n){\n      REP(j,hp[i]) {\n        costs[j] += dps[a][hp[i] - j];\n      }\n    }\n    int64_t mcos = INF;\n    REP(i,100001) mcos = min(mcos, dpa[b][i] + costs[i]);\n    cout << mcos << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        if(n==0){break;}\n    vector<ll> a(n);\n    for(auto &i:a){cin>>i;}\n    ll m;\n    cin>>m;\n    vector<pll> Sg,Ml;\n    for(int i=0;i<m;i++){\n        string N,T;\n        ll M,D;\n        cin>>N>>M>>T>>D;\n        if(T==\"Single\"){Sg.push_back({D,M});}\n        else if(T==\"All\"){Ml.push_back({D,M});}\n    }\n    ll mx=100001;\n    vector<ll> dp1(mx,E),dp2(mx,E);\n    dp1[0]=dp2[0]=0;\n    for(auto &i:Sg){\n        for(int t=0;t+i.F<mx;t++){\n            dp1[t+i.F]=min(dp1[t+i.F],dp1[t]+i.S);\n        }\n        for(ll i=mx-2;i>=0;i--){\n            dp1[i]=min(dp1[i],dp1[i+1]);\n        }\n    }\n    for(auto &i:Ml){\n        for(int t=0;t+i.F<mx;t++){\n            dp2[t+i.F]=min(dp2[t+i.F],dp2[t]+i.S);\n        }\n        for(ll i=mx-2;i>=0;i--){\n            dp2[i]=min(dp2[i],dp2[i+1]);\n        }\n    }\n    ll ans=E;\n    for(int i=0;i<mx;i++){\n        ll count=dp2[i];\n        for(int t=0;t<n;t++){\n            if(a[t]>i){count+=dp1[a[t]-i];}\n        }\n        ans=min(ans,count);\n    }\n    cout<<ans<<endl;\n    \n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint multi[100010], single[100010], hp[110];\n\n\nint main(){\n\tint N;\n\twhile (cin >> N && N){\n\t\tfor (int i = 0; i < 100010; i++){\n\t\t\tmulti[i] = 1e9; single[i] = 1e9;\n\t\t}\n????????????????????????multi[0]=0;single[0]=0;\n\t\tfor (int i = 0; i < N; i++)cin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring command;\n\t\t\tint dmp;\n\t\t\tcin >> name >> mp >> command >> dmp;\n\t\t\tif (command == \"Single\"){\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tsingle[s] = min(single[s], single[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tmulti[s] = min(multi[s], multi[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tfor (int i = 100000; i >= 0; i--){\n\t\t\t\tmulti[i] = min(multi[i], multi[i + 1]);\n\t\t\t\tsingle[i] = min(single[i], single[i + 1]);\n\t\t\t}\n\t\t\tlong long ans = 1e9;\n\t\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\t\tlong long u = multi[i];\n\t\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\t\tint v = min(0, hp[j] - i);\n\t\t\t\t\tu += single[v];\n\t\t\t\t}\n\t\t\t\tans = min(u, ans);\n\t\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 999999\n\nint *dp_single,*dp_all;\nint N,monster[100];\n\nvoid func(){\n\n\tint max_hp = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&monster[i]);\n\t\tmax_hp = max(max_hp,monster[i]);\n\t}\n\n\tfor(int i = 1; i <= NUM; i++){\n\t\tdp_single[i] = BIG_NUM;\n\t\tdp_all[i] = BIG_NUM;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint mp,damage,single_count = 0,all_count = 0;\n\tchar buf[17],target[7];\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s %d %s %d\",buf,&mp,target,&damage);\n\t\tif(damage == 0)continue;\n\n\t\tif(target[0] == 'S'){\n\t\t\tsingle_count++;\n\t\t\tfor(int i = damage; i <= NUM; i++){\n\t\t\t\tif(dp_single[i-damage] != BIG_NUM){\n\t\t\t\t\tdp_single[i] = min(dp_single[i],dp_single[i-damage]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tall_count++;\n\t\t\tfor(int i = damage; i <= NUM; i++){\n\t\t\t\tif(dp_all[i-damage] != BIG_NUM){\n\t\t\t\t\tdp_all[i] = min(dp_all[i],dp_all[i-damage]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = NUM-1; i >= 1; i--){\n\t\tdp_single[i] = min(dp_single[i],dp_single[i+1]);\n\t\tdp_all[i] = min(dp_all[i],dp_all[i+1]);\n\t}\n\n\tint minimum = BIG_NUM,tmp_hp,tmp_minimum;\n\n\tif(single_count > 0 && all_count > 0){\n\n\t\tfor(int all_damage = 0; all_damage <= max_hp; all_damage++){\n\t\t\ttmp_minimum = dp_all[all_damage];\n\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\ttmp_hp = monster[i] - all_damage;\n\t\t\t\tif(tmp_hp > 0){\n\t\t\t\t\ttmp_minimum += dp_single[tmp_hp];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminimum = min(minimum,tmp_minimum);\n\t\t}\n\n\t}else if(single_count == 0){\n\t\tminimum = dp_all[max_hp];\n\t}else{ //all_count = 0;\n\t\tminimum = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tminimum += dp_single[monster[i]];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",minimum);\n}\n\nint main(){\n\n\tdp_single = new int[NUM+1];\n\tdp_all = new int[NUM+1];\n\n\tdp_single[0] = 0;\n\tdp_all[0] = 0;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,cnt;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nvector<P> v;\n\nint bynary_search(int x){\n  int L=0,R=v.size();\n  while(L<R){\n    int M=(L+R)/2;\n    if(v[M].first>x)R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++)\n      if(dpSin[i]!=INF)v.push_back(P(i,dpSin[i]));\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      cnt=dpAll[i];\n      for(int j=0;j<n;j++){\n\tint k=hp[j]-i;\n\tcnt+=v[bynary_search(k)].second;\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100000;\nint n, h[100], dp[MX], dp2[MX];\nint m, w[100], v[100];\nbool single[100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> h[i];\n\t\tcin >> m;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s >> w[i] >> s >> v[i];\n\t\t\tsingle[i] = s == \"Single\";\n\t\t}\n\t\t\n\t\trep(i, MX) dp[i] = dp2[i] = inf;\n\t\tdp[0] = dp2[0] = 0;\n\t\trep(i, m) if(!single[i]) rep(j, MX){\n\t\t\tint nj = min(MX - 1, j + v[i]);\n\t\t\tdp[nj] = min(dp[nj], dp[j] + w[i]);\n\t\t}\n\t\trep(i, m) if(single[i]) rep(j, MX){\n\t\t\tint nj = min(MX - 1, j + v[i]);\n\t\t\tdp2[nj] = min(dp[nj], dp2[j] + w[i]);\n\t\t}\n\t\tfor(int i = MX - 2; i >= 0; i--) dp2[i] = min(dp2[i], dp2[i + 1]);\n\t\t\n\t\tll ans = inf;\n\t\trep(i, MX){\n\t\t\tll tmp = dp[i];\n\t\t\trep(j, n) if(h[j] > i) tmp += dp2[h[j] - i];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tauto HP = read<int>(N);\n\n\t\tint maxHP = *max_element(allof(HP));\n\t\tvector<int> tableS(maxHP + 1, INF); // tableS[x] = 単体魔法でxダメージ与えるのに必要なMP\n\t\tvector<int> tableA(maxHP + 1, INF); // tableA[x] = 全体魔法でxダメージ与えるのに必要なMP\n\t\ttableS[0] = tableA[0] = 0;\n\n\t\tREAD(int, M);\n\t\tREP(_, M)\n\t\t{\n\t\t\tstring name, type;\n\t\t\tint mp, dmg;\n\t\t\tcin >> name >> mp >> type >> dmg;\n\t\t\tvector<int> &tg = type[0] == 'A' ? tableA : tableS;\n\t\t\tFOR(d, 1, maxHP + 1) { tg[d] = min(tg[d], tg[max(0, d - dmg)] + mp); }\n\t\t}\n\n\t\t// 全体魔法でd与えてから、単体魔法で倒してみることにしよう。\n\t\tlong result = LINF;\n\t\tREP(d, maxHP + 1)\n\t\t{\n\t\t\tlong cost = tableA[d];\n\t\t\tREP(i, HP.size())\n\t\t\t{\n\t\t\t\tcost += tableS[max(HP[i] - d, 0)];\n\t\t\t}\n\t\t\tresult = min(result, cost);\n\t\t\t//WRITE(\"d:\", d, \" MP:\", cost);\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\n#define inf 1<<60\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        for(int i=1;i<=10000;i++)dp2[i]=-inf;\n        memset(dp1,0,sizeof dp1);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=1ll<<60,sum;\n        for(int i=0; i<10001; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n//            ll tmp=sum;\n            if(dp2[i]<0)continue;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nll dp1[2][100010], dp2[2][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >> target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 30;\n    }\n    for(int i = 1; i <= m; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(damage[i-1] == 0){\n          dp1[i%2][j] = dp1[(i-1)%2][j];\n          dp2[i%2][j] = dp2[(i-1)%2][j];\n        }\n        else if(target[i-1] == \"All\"){\n            dp1[i%2][j] = min(dp1[(i-1)%2][j], dp1[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i%2][j] = dp2[(i-1)%2][j];          \n        }\n        else{\n            dp2[i%2][j] = min(dp2[(i-1)%2][j], dp2[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i%2][j] = dp1[(i-1)%2][j];\n        }\n      }\n    }\n    \n    \n    ll ans = 1LL << 50;\n    for(int i = 0; i <= 100000; i++){\n      ll sum = dp1[m%2][i];\n      //cout << i << \" \" << dp1[n][i] << endl;\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[m%2][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m;\nvector<int> h;\nvector<P> m1, m2; \nint dp[100010], dp2[100010];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin >> n, n){\n        h.resize(n);\n        rep(i, 0, n){\n            cin >> h[i];\n        }\n        cin >> m;\n        rep(i, 0, m){\n            string s1;\n            int mp, damage;\n            cin >> s1 >> mp >> s1 >> damage;\n            if(s1 == \"Single\"){\n                m1.push_back(P(mp, damage));\n            }else if(s1 == \"All\"){  \n                m2.push_back(P(mp, damage));\n            }\n        }\n        rep(i, 0, 100010){\n            dp[i] = dp2[i] = INF;\n        }\n        dp[0] = dp2[0] = 0;\n        rep(i, 0, m1.size()){\n            rep(j, 0, 100000){\n                if(dp[j] == INF) continue;\n                int next = j + m1[i].second;\n                if(next > 100000) next = 100001;\n                chmin(dp[next], dp[j] + m1[i].first);\n            }\n        }\n        rep(i, 0, m2.size()){\n            rep(j, 0, 100000){\n                if(dp2[j] == INF) continue;\n                int next = j + m2[i].second;\n                if(next > 100000) next = 100001;\n                chmin(dp2[next], dp2[j] + m2[i].first);\n            }\n        }\n        int MIN = INF;\n        repb(i, 100001, 0){\n            chmin(MIN, dp[i]);\n            dp[i] = MIN;\n        }\n        MIN = INF;\n        repb(i, 100001, 0){\n            chmin(MIN, dp2[i]);\n            dp2[i] = MIN;\n        }\n        int ans = 1e18;\n        rep(i, 0, 100001){\n            int sum = dp2[i];\n            rep(j, 0, n){\n                sum += dp[max(0LL, h[j] - i)];\n            }\n            chmin(ans, sum);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[200],b[200],d[200];vector<int>v1,v2,w1,w2,dp1,dp2;\nvector<int>knapsack(int W,vector<int>v,vector<int>w){\n\tvector<int>dp(W+1000,999999999);\n\tfor(int i=0;i<dp.size();i++){dp[i]=999999999;}\n\tdp[0]=0;\n\tfor(int i=0;i<(int)min(v.size(),w.size());i++){\n\t\tfor(int j=v[i];j<=W;j++)dp[j]=min(dp[j],dp[j-v[i]]+w[i]);\n\t}\n\tfor(int i=W-1;i>=0;i--){\n\t\tdp[i]=min(dp[i],dp[i+1]);\n\t}\n\treturn dp;\n}\nint main(){\n\twhile(true){\n\t\tv1.clear();v2.clear();w1.clear();w2.clear();dp1.clear();dp2.clear();\n\t\tfor(int i=0;i<200;i++){a[i]=0;b[i]=0;d[i]=0;}\n\t\tcin>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];cin>>m;\n\t\tbool OK=false;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring S,T;cin>>S>>b[i]>>T>>d[i];if(d[i]>=200000)d[i]=200000;\n\t\t\tif(d[i]==0)continue;if(b[i]==0){OK=true;continue;}\n\t\t\tif(T==\"Single\"){v1.push_back(d[i]);w1.push_back(b[i]);}\n\t\t\tif(T==\"All\"){v2.push_back(d[i]);w2.push_back(b[i]);}\n\t\t}\n\t\tif(OK==true){cout<<\"0\"<<endl;continue;}\n\t\tdp1=knapsack(400000,v1,w1);\n\t\tdp2=knapsack(400000,v2,w2);\n\t\tint maxn=999999999;\n\t\tfor(int i=0;i<=300000;i++){\n\t\t\tint sum=dp2[i];bool H=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(a[j]>i && dp1[a[j]-i]<=1e8){\n\t\t\t\t\tsum+=dp1[a[j]-i];H=false;\n\t\t\t\t}\n\t\t\t\tif(a[j]<=i)H=false;\n\t\t\t}\n\t\t\tif(H==true)continue;\n\t\t\tmaxn=min(maxn,sum);\n\t\t}\n\t\tif(maxn==0)cout<<\"WARNING\"<<endl;\n\t\tcout<<maxn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 105\n#define HP 100010\n\n\nvoid calc(int n){\n  int hp[SIZE],m,mp[SIZE],damage[SIZE],target[SIZE];\n  int max_hp = 0;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",hp+i);\n    max_hp = max(max_hp,hp[i]);\n  }\n\n  scanf(\"%d\",&m);\n\n  for(int i=0;i<m;i++){\n    char target_c[SIZE];\n    scanf(\"%*s%d%s%d\",mp+i,target_c,damage+i);\n\n    target[i] = target_c[0] == 'A';\n  }\n\n  int dp_a[HP],dp_s[HP];\n  \n  for(int i=0;i<=HP;i++){\n    dp_a[i] = dp_s[i] = INF;\n  }\n\n  dp_a[0] = dp_s[0] = 0;\n\n  for(int i=0;i<max_hp;i++){\n    for(int j=0;j<m;j++){\n      int p = min(i+damage[j],max_hp);\n      if(target[j]){ //ALL\n        dp_a[p] = min(dp_a[p], dp_a[i]+mp[j]);\n      }else{\n        dp_s[p] = min(dp_s[p], dp_s[i]+mp[j]);\n      }   \n    }\n  }\n\n  for(int i=max_hp;i>0;i--){\n    dp_a[i-1] = min(dp_a[i-1],dp_a[i]);\n    dp_s[i-1] = min(dp_s[i-1],dp_s[i]);\n  }\n\n  int ans = INF;\n  \n  for(int i=0;i<=max_hp;i++){\n    int sum = dp_a[i];\n\n    for(int j=0;j<n;j++){\n      sum += dp_s[max(0,hp[j]-i)];\n    }\n\n    ans = min(ans, sum);\n  }\n\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n  int x;\n  \n  while(1){\n    scanf(\"%d\",&x);\n\n    if(x == 0) break;\n\n    calc(x);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<int> mons(n);\n        for(auto &&i : mons) cin >> i;\n        int maxhp = *max_element(mons.begin(),mons.end());\n        vector<pair<int, int>> v, u;\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; ++i) {\n            string s, t; int mp, damage;\n            cin >> s >> mp >> t >> damage;\n            if(t == \"All\") v.emplace_back(mp, damage);\n            else u.emplace_back(mp, damage);\n        }\n        vector<ll> dp(maxhp+1, MOD), dq(maxhp+1, MOD);\n        dp[0] = 0;\n        for (int i = 1; i <= maxhp; ++i) {\n            for (const auto & j : v){\n                dp[i] = min(dp[i], j.first+dp[max(0, i-j.second)]);\n            }\n        }\n        dq[0] = 0;\n        for (int i = 1; i <= maxhp; ++i) {\n            for (const auto & j : u){\n                dq[i] = min(dq[i], j.first+dq[max(0, i-j.second)]);\n            }\n        }\n        for (int k = maxhp-1; k >= 0; --k) {\n            dp[k] = min(dp[k], dp[k+1]);\n            dq[k] = min(dq[k], dq[k+1]);\n        }\n        ll ans = INF<ll>/1000;\n        for (int i = 0; i <= maxhp; ++i) { // 単体でiまで減らす\n            ll x = dp[i];\n            for (int j = 0; j < n; ++j) {\n                x += dq[max(0, mons[j]-i)];\n            }\n            ans = min(ans, x);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\nusing namespace std;\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\nvoid solve(int n, int hp[N], int m, magic mag[M], int now, int &ans){\n\tbool bSolved=true;\n\t/*for(int i=0;i<n;++i){\n\t\tcout<<hp[i]<<' ';\n\t}\n\tcout<<endl;*/\n\tfor(int i=0;i<n;++i){\n\t\tif(hp[i]>0){\n\t\t\tbSolved=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( bSolved ){\n\t\tans=min(ans,now);\n\t\treturn ;\n\t}\n\n\tfor(int i=0;i<m;++i){\n\t\tint nx_hp[N];\n\t\tfor(int j=0;j<n;++j){\n\t\t\tnx_hp[j]=hp[j];\n\t\t}\n\t\tif(mag[i].type==ALL){\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t}\n\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,ans );\n\t\t}else{\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif(nx_hp[j]>0){\n\t\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,ans );\n\t\t\t\t\tnx_hp[j]+=mag[i].damage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint ans=INFTY;\n\t\tint n,m;\n\t\tint minmp=INFTY;\n\t\tint magsz=0;\n\t\tint hp[N]={0,};\n\t\tmagic mag[M];\n\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar type[17]=\"\";\n\t\t\tscanf(\"%*s%d%s%d\", &mag[magsz].mp, type, &mag[magsz].damage);\n\t\t\tif(strcmp(type,\"All\")==0)mag[magsz].type=ALL;\n\t\t\telse mag[magsz].type=SINGLE;\n\t\t\tif(mag[magsz].damage>0)\n\t\t\t\t++magsz;\n\t\t\telse{\n\t\t\t\tminmp=min(minmp,mag[magsz].mp);\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<magsz;++i){\n\t\t\tcout << \"MP: \" << mag[i].mp <<\" TYPE: \" << mag[i].type << \" DAMAGE: \" << mag[i].damage << endl;\n\t\t}*/\n\t\tsort(mag,mag+magsz);\n\t\tsolve(n,hp,magsz,mag,0,ans);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nint HP[101];\n\nint M;\n\nvector< tuple<int, int, int> > magic;\n\nint dp[2][1000001]; // Single/All???just i???????????????????????????????°????MP\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    magic.clear();\n\n    int mxhp = 0;\n    rep(i, N) cin >> HP[i], mxhp = max(mxhp, HP[i]);\n\n    cin >> M;\n    rep(i, M) {\n      string na, tar;\n      int mp, dam;\n      cin >> na >> mp >> tar >> dam;\n      magic.emplace_back(mp, (tar == \"All\"), dam);\n    }\n\n    fill(dp[0], dp[2], inf);\n    dp[0][0] = dp[1][0] = 0;\n    for(auto m : magic) {\n      int mp, tar, dam;\n      tie(mp, tar, dam) = m;\n      rep(i, mxhp+1) {\n\tdp[tar][min(mxhp, i+dam)] = min(dp[tar][min(mxhp, i+dam)], dp[tar][i] + mp);\n      }\n    }\n\n    for(int i = mxhp; i > 0; i--) {\n      if(dp[0][i] < dp[0][i-1]) dp[0][i-1] = dp[0][i];\n    }\n\n    int ans = inf;\n    rep(i, mxhp+1) if(dp[1][i] != inf) {\n      int sum = dp[1][i];\n      rep(j, N) sum += dp[0][max(HP[j]-i, 0LL)];\n      ans = min(ans, sum);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100\n#define MAX_H 100000\n#define INF (1<<29)\ntypedef long long ll;\n \nint main(){\n    ll N,M;\n    string in;\n    while(cin >> N, N){\n        ll MHP = 0;\n        vector<ll> HP(N);\n        for(ll i = 0 ; i < N ; i++){\n            cin >> HP[i];\n            MHP = max(MHP,HP[i]);\n        }\n        cin >> M;\n        vector<ll> MP(M),t(M),d(M);\n        for(ll i = 0 ; i < M ; i++){\n            cin >> in >> MP[i] >> in >> d[i];\n            t[i] = (in == \"All\");\n        }\n        ll dp[2][MAX_H+1];\n        fill(dp[0],dp[0]+2*(MAX_H+1),INF);\n        dp[0][0] = dp[1][0] = 0;\n        for(ll i = 0 ; i < M ; i++){\n            for(ll j = 0 ; j <= MHP ; j++){\n                ll nt = t[i],nhp = min(MHP,j+d[i]);\n                dp[nt][nhp] = min(dp[nt][nhp],dp[nt][j]+MP[i]);\n            }\n        }\n        for(ll i = MHP ; i > 0 ; i--){\n            dp[0][i-1] = min(dp[0][i-1],dp[0][i]);\n            dp[1][i-1] = min(dp[1][i-1],dp[1][i]);\n        }\n        ll res = INF;\n        for(ll i = 0 ; i <= MHP ; i++){\n            ll mp = dp[1][i],mp2 = 0;\n            if(mp == INF) continue;\n            for(ll j = 0 ; j < N ; j++){\n                ll rest = max(HP[j]-i,0LL);\n                if(rest == 0) continue;\n                mp2 += dp[0][rest];\n            }\n            res = min(res,mp+mp2);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll MAX = 1000000, INF = 1LL << 50;\n\nvector<ll> solve(vector<pll> &data) {\n  ll n = data.size();\n  vector<ll> cost(n), damage(n);\n  REP(i, 0, n) cost[i] = data[i].first;\n  REP(i, 0, n) damage[i] = data[i].second;\n\n  vector<ll> dp(MAX + 1, INF);\n  dp[0] = 0;\n  REP(k, 0, n) REP(i, 0, MAX) {\n    if(i + damage[k] <= MAX) {\n      dp[i + damage[k]] = min(dp[i + damage[k]], dp[i] + cost[k]);\n    }\n  }\n  return dp;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N != 0) {\n    vector<ll> H(N);\n    REP(i, 0, N) cin >> H[i];\n    cin >> M;\n    vector<pll> S, A;\n    REP(i, 0, M) {\n      string name, target;\n      ll cost, damage;\n      cin >> name >> cost >> target >> damage;\n      if(target == \"Single\") S.push_back(pll(cost, damage));\n      if(target == \"All\") A.push_back(pll(cost, damage));\n    }\n\n    vector<ll> acost = solve(A);\n\n    vector<ll> scost = solve(S);\n    for(ll i = MAX - 1; i >= 0; i--) scost[i] = min(scost[i], scost[i + 1]);\n\n    ll ans = INF;\n    REP(i, 0, MAX + 1) {\n      ll d = acost[i];\n      REP(j, 0, N) d += scost[max(H[j] - i, 0LL)];\n      ans = min(ans, d);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint N, M, HP[111];\nvector< int > singleMP, allMP;\nvector< int > singleDM, allDM;\n\nint singleDP[111][100010], allDP[111][100010];\nconst int INF = (int)1e9;\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> HP[i];\n\t\n\tstring dumy, type;\n\tcin >> M;\n\t\n\tfor_(i,0,M) {\n\t\tint MP, DM;\n\t\tcin >> dumy >> MP >> type >> DM;\n\t\t\n\t\tif (type == \"All\") {\n\t\t\tallMP.push_back(MP);\n\t\t\tallDM.push_back(DM);\n\t\t} else {\n\t\t\tsingleMP.push_back(MP);\n\t\t\tsingleDM.push_back(DM);\n\t\t}\n\t}\n\t\n\t// single DP\n\tint S = singleMP.size();\n\tfor_(i,0,S+1) fill(singleDP[i], singleDP[i] + 100010, INF);\n\t\n\tfor_(i,0,S+1) singleDP[i][0] = 0;\n\t\n\tfor_(i,0,S) {\n\t\tint DM = singleDM[i], MP = singleMP[i];\n\t\t\n\t\tfor_(j,0,100010) {\n\t\t\tif (j < DM) {\n\t\t\t\tsingleDP[i + 1][j] = singleDP[i][j];\n\t\t\t} else {\n\t\t\t\tsingleDP[i + 1][j] = min(singleDP[i][j], singleDP[i + 1][j - DM] + MP);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< int > smp(100010, INF);\n\tfor_rev(d,100001,0) smp[d] = min(smp[d + 1], singleDP[S][d]);\n\t\t\n\t// all DP\n\tint A = allMP.size();\n\tfor_(i,0,A+1) fill(allDP[i], allDP[i] + 100010, INF);\n\t\n\tfor_(i,0,A+1) allDP[i][0] = 0;\n\t\n\tfor_(i,0,A) {\n\t\tint DM = allDM[i], MP = allMP[i];\n\t\t\n\t\tfor_(j,0,100010) {\n\t\t\tif (j < DM) {\n\t\t\t\tallDP[i + 1][j] = allDP[i][j];\n\t\t\t} else {\n\t\t\t\tallDP[i + 1][j] = min(allDP[i][j], allDP[i + 1][j - DM] + MP);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< int > amp(100010, INF);\n\tfor_rev(d,100001,0) amp[d] = min(amp[d + 1], allDP[A][d]);\n\t\n\tint ans = INF;\n\t\n\tfor_(d,0,100010) {\n\t\tint sum = amp[d];\n\t\tfor_(i,0,N) if (HP[i] - d > 0) sum += smp[HP[i] - d];\n\t\tans = min(ans, sum);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    /*\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<=h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n        int tmp = i - dmA[j];\n        if(tmp < 0) tmp = 0;\n        tA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n        int tmp = i - dmS[j];\n        if(tmp < 0) tmp = 0;\n        tS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n    memset(dpS, -1, sizeof(int)*(h+1));\n    memset(dpA, -1, sizeof(int)*(h+1));\n\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(dpS[dm] != -1) continue;\n      dpS[dm] = mp;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] == -1)\n          q.push(mpi(mm,dd));\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(dpA[dm] != -1) continue;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] == -1)\n          q.push(mpi(mm,dd));\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      if(dpA[i] == -1) dpA[i] = dpA[i+1];\n      else             dpA[i] = min(dpA[i+1], dpA[i]);\n\n      if(dpS[i] == -1) dpS[i] = dpS[i+1];\n      else             dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    REP(i,h+1){\n      int mp = dpA[i];\n      int dm = i;\n\n      REP(j,n)\n        if(hp[j] > dm)\n          mp += dpS[hp[j] - dm];\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <fstream>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\nvector<magic> all;\nvector<magic> single;\nvector<magic> crit;\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tmemset(mon, 0, sizeof(mon));\n\t\tmemset(mag, 0, sizeof(mag));\n\t\tall.clear();\n\t\tsingle.clear();\n\t\tcrit.clear();\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tdp[0] = 0;\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\t\t\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tint mon2[120];\n\t\t\tmemcpy(mon2, mon, sizeof(mon));\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tmon2[j] -= i;\n\t\t\t\tif(mon2[j] > 0) prev += dp2[mon2[j]];\n\t\t\t}\n\t\t\t\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll dp[10][1001000];\nll n, m;\nll hp[110];\nvector<ll> mp[2];\nvector<ll> d[2];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tmp[0].clear();\n\t\tmp[1].clear();\n\t\td[0].clear();\n\t\td[1].clear();\n\t\trep(i, n)cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tll mpp, dd;\n\t\t\tcin >> s >> mpp >> s >> dd;\n\t\t\tif (s == \"All\") {\n\t\t\t\tmp[0].push_back(mpp);\n\t\t\t\td[0].push_back(dd);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[1].push_back(mpp);\n\t\t\t\td[1].push_back(dd);\n\t\t\t}\n\t\t}\n\t\trep(i, 1001000) {\n\t\t\tdp[0][i] = INF;\n\t\t\tdp[1][i] = INF;\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp[1][0] = 0;\n\t\trep(i, mp[0].size()) {\n\t\t\trep(j, 1001000) {\n\t\t\t\tif (j + d[0][i] < 1001000) {\n\t\t\t\t\tdp[0][j + d[0][i]] = min(dp[0][j + d[0][i]], dp[0][j] + mp[0][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, mp[1].size()) {\n\t\t\trep(j, 1001000) {\n\t\t\t\tif (j + d[1][i] < 1001000) {\n\t\t\t\t\tdp[1][j + d[1][i]] = min(dp[1][j + d[1][i]], dp[1][j] + mp[1][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 2) {\n\t\t\tfor (int j = 1000000; j >= 0; j--) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t\t//rep(i, 2) {\n\t\t//\trep(j, 50) {\n\t\t//\t\tif (dp[i][j] == INF)cout << -1 << \" \";\n\t\t//\t\telse cout << dp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tll ans = INF;\n\t\trep(i, 1001000) {\n\t\t\tll sum = dp[0][i];\n\t\t\trep(j, n) {\n\t\t\t\tif (hp[j] - i >= 0)sum += dp[1][hp[j] - i];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        const ll E=1e10;\n        if(n==0){break;}\n        vector<ll> a(n);\n        for(auto &i:a){cin>>i;}\n        ll m;\n        cin>>m;\n        vector<pll> Sg,Ml;\n        const ll mx=100001;\n        const ll mx2=100000;\n        for(int i=0;i<m;i++){\n            string N,T;\n            ll M,D;\n            cin>>N>>M>>T>>D;\n            if(D>mx2){D=mx2;}\n            if(T==\"Single\"){Sg.push_back({D,M});}\n            else if(T==\"All\"){Ml.push_back({D,M});}\n        }\n        vector<ll> dp1(mx,E),dp2(mx,E);\n        dp1[0]=dp2[0]=0;\n        for(auto &i:Sg){\n            for(int t=0;t+i.F<mx;t++){\n                dp1[t+i.F]=min(dp1[t+i.F],dp1[t]+i.S);\n            }\n            for(ll i=mx-2;i>=0;i--){\n                dp1[i]=min(dp1[i],dp1[i+1]);\n            }\n        }\n        for(auto &i:Ml){\n            for(int t=0;t+i.F<mx;t++){\n                dp2[t+i.F]=min(dp2[t+i.F],dp2[t]+i.S);\n            }\n            for(ll i=mx-2;i>=0;i--){\n                dp2[i]=min(dp2[i],dp2[i+1]);\n            }\n        }\n        ll ans=E;\n        for(int i=0;i<=mx2;i++){\n            ll count=dp2[i];\n            for(int t=0;t<n;t++){\n                if(a[t]>i){count+=dp1[a[t]-i];}\n            }\n            ans=min(ans,count);\n        }\n        cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 111111\n#define INF 100000000\nint dp[N+1],dp2[N+1],cost[N+1],cost2[N+1];\ntypedef pair<int,int> P;\nint getcost(int x){\n  if(x<=0) return 0;\n  return cost2[x];\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    int hp[n];\n    for(int i=0;i<n;i++) cin>>hp[i];\n    sort(hp,hp+n,greater<int>());\n    int m;cin>>m;\n    vector<P> single,all;\n    for(int i=0;i<m;i++){\n      string name,target;\n      int mp,damage;\n      cin>>name>>mp>>target>>damage;\n      if(target==\"All\") all.push_back(P(mp,damage));\n      else single.push_back(P(mp,damage));\n    }\n    for(int i=0;i<=N;i++) cost[i]=cost2[i]=dp[i]=dp2[i]=INF;\n    cost[0]=dp[0]=0;\n    for(int i=0;i<N;i++){\n      if(cost[i]==INF) continue;\n      for(int j=0;j<(int)single.size();j++){\n\tint u=single[j].first,v=single[j].second;\n\tif(i+v<N) cost[i+v]=min(cost[i+v],cost[i]+u);\n\telse cost[N]=min(cost[N],cost[i]+u);\n      }\n    }\n    for(int i=N-1;i>=0;i--) cost2[i]=min(cost2[i+1],cost[i]);\n    for(int i=0;i<N;i++){\n      if(dp[i]==INF) continue;\n      for(int j=0;j<(int)all.size();j++){\n\tint u=all[j].first,v=all[j].second;\n\tif(i+v<N) dp[i+v]=min(dp[i+v],dp[i]+u);\n\telse dp[N]=min(dp[N],dp[i]+u);\n      }\n    }\n    for(int i=N-1;i>=0;i--) dp2[i]=min(dp2[i+1],dp[i]);\n    int ans=INF;\n    for(int i=0;i<N;i++){\n      if(dp2[i]==INF) continue;\n      int tmp=0;\n      for(int j=0;j<n;j++) tmp+=getcost(hp[j]-i);\n      ans=min(ans,dp2[i]+tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nll dp1[200010],dp2[200010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint m,d;\n\t\t\tcin>>s>>m>>t>>d;\n\t\t\td=min(d,100000);\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=m;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=m;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+200001,INF);\n\t\tfill(dp2,dp2+200001,INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,200001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=199999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,200001){\n\t\t\tint res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tint rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n; if(n==0) break;\n        vector<ll> hp(n);\n        for(ll& in:hp) cin >> in;\n        cin >> m;\n        vector<ll> consume(m),damage(m);\n        vector<string> type(m);\n        rep(i,0,m){\n            string s;\n            cin >> s >> consume[i] >> type[i] >> damage[i];\n        }\n\n        const ll sup=200001;\n        ll ans=inf,dp1[sup],dp2[sup];\n        fill_n((ll*)dp1,sup,inf);\n        fill_n((ll*)dp2,sup,inf);\n        dp1[0]=dp2[0]=0;\n        rep(i,0,m){\n            ll* dp;\n            if(type[i]==\"Single\") dp=dp1;\n            else dp=dp2;\n            rep(j,0,sup) dp[j]=min(dp[j],dp[max(j-damage[i],0LL)]+consume[i]);\n        }\n        rep(i,0,sup){\n            ll tmp=dp2[i];\n            rep(j,0,n) if(hp[j]-i>=0) tmp+=dp1[hp[j]-i];\n            ans=min(ans,tmp);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nvector<P>v1,v2;\nint a[101],dp1[100001],dp2[100001],n,t1,t2,t;\nstring s;\nmain(){\n\twhile(cin>>n,n){\n\t\tint ans=1e8;\n\t\tr(i,100001)dp1[i]=dp2[i]=1e6;\n\t\tdp1[0]=dp2[0]=0;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tr(i,n)cin>>a[i];\n\t\tcin>>t;\n\t\tr(i,t){\n\t\t\tcin>>s>>t1>>s>>t2;\n\t\t\tif(t2>100000)t2=100000;\n\t\t\tif(s==\"All\")v1.push_back(P(t1,t2));\n\t\t\telse v2.push_back(P(t1,t2));\n\t\t}\n\t\tr(i,v1.size())r(j,100001)if(j+v1[i].S<=100001)\n\t\t  dp1[j+v1[i].S]=min(dp1[j+v1[i].S],dp1[j]+v1[i].F);\n\t\t  else dp1[100000]=min(dp1[100000],dp1[j]+v1[i].F);\n\t\tr(i,v2.size())r(j,100001)if(j+v2[i].S<=100001)\n\t\t  dp2[j+v2[i].S]=min(dp2[j+v2[i].S],dp2[j]+v2[i].F);\n\t\t  else dp2[100000]=min(dp2[100000],dp2[j]+v2[i].F);\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tr(i,100001)if(dp1[i]!=1e8){\n\t\t\tint sum=0;\n\t\t\tr(j,n)if(a[j]-i>0)sum+=dp2[a[j]-i];\n\t\t\tans=min(ans,sum+dp1[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\nbool ok[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    /*\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<=h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n        int tmp = i - dmA[j];\n        if(tmp < 0) tmp = 0;\n        tA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n        int tmp = i - dmS[j];\n        if(tmp < 0) tmp = 0;\n        tS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    REP(i,h+1) dpS[i] = INT_MAX;\n    REP(i,h+1) dpA[i] = INT_MAX;\n\n    q.push(mpi(0,0));\n    REP(i,h+1) ok[i] = false;\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] > mm){\n          dpS[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n\n    REP(i,h+1) ok[i] = false;\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] > mm){\n          dpA[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    for(int i=h; i>=0; i--){\n      if(!ok[i]) continue;\n      int mp = dpA[i];\n      int dm = i;\n      if(ans <= mp) continue;\n\n      REP(j,n)\n        if(hp[j] > dm){\n          mp += dpS[hp[j] - dm];\n          if(mp >= ans) break;\n        }\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 2000000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\t//\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp = INF;\n  for(int i=maxhp;i>=0;i--){\n    if ( single[n][i] >=INF){res_all[i]=INF;continue;}\n    //if (tmp>single[n][i])tmp=single[n][i];\n    else res_all[i]=single[n][i];\n  } \n\n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nint n, m;\nint hp[102];\nint mp[102], isAll[102], dam[102];\nint minMp[100002], minAllMp[100002];\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> hp[i];\n    }\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >> s >> dam[i];\n      isAll[i] = (s == \"All\");\n    }\n\n    fill(minMp, minMp + 100002, INT_MAX);\n    fill(minAllMp, minAllMp + 100002, INT_MAX);\n    minMp[0] = 0;\n    minAllMp[0] = 0;\n\n    for(int i = 0; i < 100000; i++){\n      if(minMp[i] != INT_MAX){\n        for(int j = 0; j < m; j++){\n          if(isAll[j]) continue;\n          int ni = min(100000, i + dam[j]);\n          minMp[ni] = min(minMp[ni], minMp[i] + mp[j]);\n        }\n      }\n\n      if(minAllMp[i] != INT_MAX){\n        for(int j = 0; j < m; j++){\n          if(!isAll[j]) continue;\n          int ni = min(100000, i + dam[j]);\n          minAllMp[ni] = min(minAllMp[ni], minAllMp[i] + mp[j]);\n        }\n      }\n    }\n\n    for(int i = 99999; i >= 0; i--){\n      minMp[i] = min(minMp[i], minMp[i + 1]);\n      minAllMp[i] = min(minAllMp[i], minAllMp[i + 1]);\n    }\n\n    int ans = INT_MAX;\n\n    for(int i = 0; i <= 100000; i++){\n      int sum = minAllMp[i];\n\n      for(int j = 0; j < n; j++){\n        int remHp = max(0, hp[j] - i);\n        sum += minMp[remHp];\n      }\n\n      ans = min(ans, sum);\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef struct magic{\n  int mp, damage;\n}magic;\n\n\nint main(int argc, char *argv[]){\n  int n, m;\n  while(std::cin >> n, n){\n    vector<int> hp(n);\n    int max_hp = 0;\n    for (int i = 0; i < n; i++) {\n      std::cin >> hp[i];\n      max_hp = max(max_hp, hp[i]);\n    }\n    std::cin >> m;\n    string s;\n    vector<magic> single, all;\n    for (int i = 0; i < m; i++) {\n      int mp, damage;\n      std::cin >> s >> mp >> s >> damage;\n      if(damage == 0)continue;\n      if(s == \"All\"){\n        all.push_back(magic{mp, damage});\n      }else{\n        single.push_back(magic{mp, damage});\n      }\n    }\n    int dp_all[all.size() + 1][max_hp + 1],\n      dp_single[single.size() + 1][max_hp + 1];\n    for (int i = 0; i <= all.size(); i++) {\n      for (int j = 0; j <= max_hp; j++) {\n        dp_all[i][j] = 1e9;\n      }\n    }\n    for (int i = 0; i <= single.size(); i++) {\n      for (int j = 0; j <= max_hp; j++) {\n        dp_single[i][j] = 1e9;\n      }\n    }\n    for (int i = 0; i < all.size(); i++) {\n      dp_all[i][0] = 0;\n    }\n    for (int i = 0; i < single.size(); i++) {\n      dp_single[i][0] = 0;      \n    }\n    for (int i = 0; i < all.size(); i++) {\n      int &mp = all[i].mp, &damage = all[i].damage;\n      for (int j = 0; j <= max_hp; j++) {\n        if(j < damage){\n          dp_all[i + 1][j] = min(mp, dp_all[i][j]);\n        }else{\n          dp_all[i + 1][j] = min(dp_all[i][j],\n                                 dp_all[i + 1][j - damage] +\n                                 mp);\n        }\n      }\n    }\n    for (int i = 0; i < single.size(); i++) {\n      int &mp = single[i].mp, &damage = single[i].damage;\n      for (int j = 0; j <= max_hp; j++) {\n        if(j < damage){\n          dp_single[i + 1][j] = min(mp, dp_single[i][j]);\n        }else{\n          dp_single[i + 1][j] = min(dp_single[i][j],\n                                    dp_single[i + 1][j - damage]\n                                    + mp);\n        }\n      }\n    }\n    long long int ans = 1e10;\n    int size_all = all.size(), size_single = single.size();\n    for (int i = 0; i <= max_hp; i++) {\n      long long int sum = dp_all[size_all][i];\n      for (int j = 0; j < hp.size(); j++) {\n        if(hp[j] - i <= 0)continue;\n        sum += dp_single[size_single][hp[j] - i];\n      }\n      ans = min(ans, sum);\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100000;\nint n, h[100], dp[MX], dp2[MX];\nint m, w[100], v[100];\nbool single[100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> h[i];\n\t\tcin >> m;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s >> w[i] >> s >> v[i];\n\t\t\tsingle[i] = s == \"Single\";\n\t\t}\n\t\t\n\t\trep(i, MX) dp[i] = dp2[i] = inf;\n\t\tdp[0] = dp2[0] = 0;\n\t\trep(i, m) if(!single[i]) rep(j, MX){\n\t\t\tint nj = min(MX - 1, j + v[i]);\n\t\t\tdp[nj] = min(dp[nj], dp[j] + w[i]);\n\t\t}\n\t\trep(i, m) if(single[i]) rep(j, MX){\n\t\t\tint nj = min(MX - 1, j + v[i]);\n\t\t\tdp2[nj] = min(dp2[nj], dp2[j] + w[i]);\n\t\t}\n\t\tfor(int i = MX - 2; i >= 0; i--) dp2[i] = min(dp2[i], dp2[i + 1]);\n\t\t\n\t\tll ans = inf;\n\t\trep(i, MX){\n\t\t\tll tmp = dp[i];\n\t\t\trep(j, n) if(h[j] > i) tmp += dp2[h[j] - i];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<LL> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int m;cin >> m;\n        vector<LL> mpa,da,mpb,db;\n        for (int i = 0; i < m; i++) {\n            int x,y;\n            string s;cin >> s >> x >> s >> y;\n            if(s==\"Single\") mpa.pb(x),da.pb(y);\n            else mpb.pb(x),db.pb(y);\n        }\n        vector<LL> dpa(1<<17,INF),dpb(1<<17,INF);\n        dpa[0] = 0,dpb[0] = 0;\n        for (int i = 0; i < mpa.size(); i++) {\n            for (int j = 0; j <= 100000; j++) {\n                if(dpa[j] == INF) continue;\n                int nx = j + da[i];\n                if(nx >= 100000) nx = 100000;\n                dpa[nx] = min(dpa[nx], dpa[j] + mpa[i]);\n            }\n        }\n        for (int i = 0; i < mpb.size(); i++) {\n            for (int j = 0; j <= 100000; j++) {\n                if(dpb[j] == INF) continue;\n                int nx = j + db[i];\n                if(nx >= 100000) nx = 100000;\n                dpb[nx] = min(dpb[nx], dpb[j] + mpb[i]);\n            }\n        }\n        LL ma=INF,mb=INF;\n        for (int i = 100000; i > 0; i--) {\n            ma = min(ma,dpa[i]);\n            dpa[i] = ma;\n            if(dpb[i]!=INF){\n                mb = min(mb,dpb[i]);\n                dpb[i] = mb;\n            }\n        }\n        LL ans = INF;\n        for (int i = 0; i <= 100000; i++) {\n            if(dpb[i]==INF) continue;\n            LL tmp = dpb[i];\n            for (int j = 0; j < n; j++) {\n                if(a[j] - i <= 0) continue;\n                tmp += dpa[a[j] - i];\n            }\n            ans = min(ans, tmp);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nconst int inf = 3e18;\n\nint dp1[100010], dp2[100010];\n\nsigned main()\n{\n    int N;\n\n    while (cin >> N, N) {\n        vector<int> hp(N);\n\n        rep(i, N) {\n            cin >> hp[i];\n        }\n\n        int M;\n\n        cin >> M;\n\n        vector<pair<int,int>> S, A;\n\n        rep(i, M) {\n            string s;\n            int mp, dmg;\n            cin >> s >> mp >> s >> dmg;\n            if (s == \"Single\") S.push_back(make_pair(mp, dmg));\n            else A.push_back(make_pair(mp, dmg));\n        }\n\n        fill_n(dp1, 100010, inf);\n        dp1[0] = 0;\n\n        for (int i = 0; i < S.size(); ++i) {\n            int mp = S[i].first, dmg = S[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0 && dp1[j - dmg] != inf) {\n                    dp1[j] = min(dp1[j], dp1[j - dmg] + mp);\n                }\n            }\n        }\n\n        for (int i = 100000; i >= 1; --i) dp1[i - 1] = min(dp1[i - 1], dp1[i]);\n\n        fill_n(dp2, 100010, inf);\n        dp2[0] = 0;\n\n        for (int i = 0; i < A.size(); ++i) {\n            int mp = A[i].first, dmg = A[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0 && dp2[j - dmg] != inf) {\n                    dp2[j] = min(dp2[j], dp2[j - dmg] + mp);\n                }\n            }\n        }\n\n        for (int i = 100000; i >= 1; --i) dp2[i - 1] = min(dp2[i - 1], dp2[i]);\n\n        int mi = inf;\n\n        for (int a = 0; a <= 100000; ++a) {\n            int sum = dp2[a];\n            for (int i = 0; i < N; ++i) {\n                if (hp[i] - a > 0) {\n                    sum += dp1[hp[i] - a];\n                }\n            }\n\n            mi = min(mi, sum);\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\nll hp[110];\nll mp[2][100010];\nchar str1[1000];\nchar str2[1000];\npair<ll, ll> magic[2][110];\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    REP(i, n) { scanf(\"%lld\", &hp[i]); }\n    scanf(\"%d\", &m);\n    int single = 0;\n    int all = 0;\n    REP(i, m) {\n      int mpower, damage;\n      scanf(\"%s %d %s %d\", str1, &mpower, str2, &damage);\n      if (damage == 0) { continue; }\n      if (str2[0] == 'S') {\n        magic[0][single++] = make_pair(mpower, damage);\n      } else {\n        magic[1][all++] = make_pair(mpower, damage);\n      }\n    }\n    int cnt[2] = { single, all };\n    MEMSET(mp, 0x0f);\n    REP(iter, 2) {\n      mp[iter][0] = 0;\n      REP(i, 100001) {\n        REP(j, cnt[iter]) {\n          ll ndamage = i + magic[iter][j].second;\n          ll nmpower = mp[iter][i] + magic[iter][j].first;\n          ndamage = min(ndamage, 100000LL);\n          mp[iter][ndamage] = min(mp[iter][ndamage], nmpower);\n        }\n      }\n      for (int i = 100000; i > 0; i--) {\n        if (mp[iter][i] > mp[iter][i + 1]) { mp[iter][i] = mp[iter][i + 1]; }\n      }\n    }\n    ll ans = 1LL << 60;\n    REP(a, 100001) {\n      ll lsum = mp[1][a];\n      REP(e, n) {\n        if (hp[e] - a <= 0) { continue; }\n        if (mp[0][hp[e] - a] > 10000000000LL) { goto next; }\n        lsum += mp[0][hp[e] - a];\n      }\n      ans = min(ans, lsum);\nnext:;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 105\n#define HP 100010\n\n\nvoid calc(int n){\n  int hp[SIZE],m,mp[SIZE],damage[SIZE],target[SIZE];\n  int max_hp = 0;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",hp+i);\n    max_hp = max(max_hp,hp[i]);\n  }\n\n  scanf(\"%d\",&m);\n\n  for(int i=0;i<m;i++){\n    char target_c[SIZE];\n    scanf(\"%*s%d%s%d\",mp+i,target_c,damage+i);\n\n    target[i] = target_c[0] == 'A';\n  }\n\n  int dp_a[HP],dp_s[HP];\n  \n  for(int i=0;i<HP;i++){\n    dp_a[i] = dp_s[i] = INF;\n  }\n\n  dp_a[0] = dp_s[0] = 0;\n\n  for(int i=0;i<max_hp;i++){\n    for(int j=0;j<m;j++){\n      int p = min(i+damage[j],max_hp);\n      if(target[j]){ //ALL\n        dp_a[p] = min(dp_a[p], dp_a[i]+mp[j]);\n      }else{\n        dp_s[p] = min(dp_s[p], dp_s[i]+mp[j]);\n      }   \n    }\n  }\n\n  for(int i=max_hp;i>0;i--){\n    dp_a[i-1] = min(dp_a[i-1],dp_a[i]);\n    dp_s[i-1] = min(dp_s[i-1],dp_s[i]);\n  }\n\n  int ans = INF;\n  \n  for(int i=0;i<=max_hp;i++){\n    int sum = dp_a[i];\n\n    for(int j=0;j<n;j++){\n      sum += dp_s[max(0,hp[j]-i)];\n    }\n\n    ans = min(ans, sum);\n  }\n\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n  int x;\n  \n  while(1){\n    scanf(\"%d\",&x);\n\n    if(x == 0) break;\n\n    calc(x);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator < (const DD &a)const{ return mp<a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1199999],res;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tif(SP[i].Dam==0)continue;\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        const ll E=1e10;\n        if(n==0){break;}\n        vector<ll> a(n);\n        for(auto &i:a){cin>>i;}\n        ll m;\n        cin>>m;\n        vector<pll> Sg,Ml;\n            const ll mx=300000;\n            const ll mx2=100000;\n        for(int i=0;i<m;i++){\n            string N,T;\n            ll M,D;\n            cin>>N>>M>>T>>D;\n            if(D>mx2){D=mx2;}\n            if(T==\"Single\"){Sg.push_back({D,M});}\n            else if(T==\"All\"){Ml.push_back({D,M});}\n        }\n        vector<ll> dp1(mx,E),dp2(mx,E);\n        dp1[0]=dp2[0]=0;\n        for(auto &i:Sg){\n            for(int t=0;t+i.F<mx;t++){\n                dp1[t+i.F]=min(dp1[t+i.F],dp1[t]+i.S);\n            }\n            for(ll i=mx-2;i>=0;i--){\n                dp1[i]=min(dp1[i],dp1[i+1]);\n            }\n        }\n        for(auto &i:Ml){\n            for(int t=0;t+i.F<mx;t++){\n                dp2[t+i.F]=min(dp2[t+i.F],dp2[t]+i.S);\n            }\n            for(ll i=mx-2;i>=0;i--){\n                dp2[i]=min(dp2[i],dp2[i+1]);\n            }\n        }\n        ll ans=E;\n        for(int i=0;i<=mx2;i++){\n            ll count=dp2[i];\n            for(int t=0;t<n;t++){\n                if(a[t]>i){count+=dp1[a[t]-i];}\n            }\n            ans=min(ans,count);\n        }\n        cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define MAX_H 100000\n#define INF (1<<29)\n\nint main(){\n    int N,M;\n    string in;\n    while(cin >> N, N){\n        int MHP = 0;\n        vector<int> HP(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> HP[i];\n            MHP = max(MHP,HP[i]);\n        }\n        cin >> M;\n        vector<int> MP(M),t(M),d(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> in >> MP[i] >> in >> d[i];\n            t[i] = (in == \"All\");\n        }\n        int dp[2][MAX_H+1];\n        fill(dp[0],dp[0]+2*(MAX_H+1),INF);\n        dp[0][0] = dp[1][0] = 0;\n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j <= MHP ; j++){\n                int nt = t[i],nhp = min(MHP,j+d[i]);\n                dp[nt][nhp] = min(dp[nt][nhp],dp[nt][j]+MP[i]);\n            }\n        }\n        for(int i = MHP ; i > 0 ; i--){\n            dp[0][i-1] = min(dp[0][i-1],dp[0][i]);\n            dp[1][i-1] = min(dp[1][i-1],dp[1][i]);\n        }\n        int res = INF;\n        for(int i = 0 ; i <= MHP ; i++){\n            int mp = dp[1][i],mp2 = 0;\n            bool ok = true;\n            if(mp == INF) continue;\n            for(int j = 0 ; j < N ; j++){\n                int rest = max(HP[j]-i,0);\n                if(rest == 0) continue;\n                if(dp[0][rest] == INF){\n                    ok = false;\n                }\n                mp2 += dp[0][rest];\n            }\n            if(!ok) continue;\n            res = min(res,mp+mp2);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "(allDP[i] == INF) {\n                continue;\n            }\n\n            int cost = allDP[i];\n\n            for(auto itr = hps.begin(); itr != hps.end(); itr++) {\n                if(*itr - i > 0) {\n                    cost += singleDP[*itr - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 1e5+1;\nconst int inf = 1e9;\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<int> hp(n);\n        for(int i=0; i<n; i++) cin >> hp[i];\n        \n        int m;\n        cin >> m;\n        vector<int> mp(m), range(m), damage(m);\n        for(int i=0; i<m; i++){\n            string name, r;\n            cin >> name >> mp[i] >> r >> damage[i];\n            if(r==\"Single\"){\n                range[i] = 0;\n            }else{\n                range[i] = 1;\n            }\n        }\n        \n        vector<vector<int> > dp(2, vector<int>(MAX, inf));\n        for(int d=0; d<2; d++){\n            for(int i=0; i<m; i++){\n                if(range[i]!=d) continue;\n                for(int j=0; j<MAX; j++){\n                    dp[d][j] = min(dp[d][j], (j+damage[i]-1)/damage[i]*mp[i]);\n                    if(j-damage[i]>0){\n                        dp[d][j] = min(dp[d][j], dp[d][j-damage[i]] +mp[i]);\n                    }\n                }\n            }\n        }\n\n        int ans = inf;\n        for(int i=0; i<MAX; i++){\n            int cost = dp[1][i];\n            for(int j=0; j<n; j++){\n                if(hp[j]-i > 0){\n                    cost += dp[0][hp[j]-i];\n                }\n            }\n            ans = min(ans, cost);\n        }\n        cout << ans << endl;   \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    bool f;\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n      f|=s==0&&d;\n    }\n    long long as[2][100001]={};\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    long long mp=1LL<<62;\n    for(int i=0;i<mp;i++){\n      long long cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<(f?0:mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid fillDP(const vector< pair<int, long int> >& skills, vector<int>& dp, long int size) {\n    dp.resize(size + 1);\n    fill(dp.begin(), dp.end(), INF);\n    dp[0] = 0;\n    for(auto itr = skills.begin(); itr != skills.end(); itr++) {\n        for(long int i = 0; i <= size; i++) {\n            if(dp[i] == INF) {\n                continue;\n            }\n            long int damage = min(i + itr->second, size);\n            dp[damage] = min(dp[damage], dp[i] + itr->first);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        int enemyNumber, skillNumber;\n        long int maxHP;\n        vector<int> allDP, singleDP;\n        vector<long int> hps;\n        vector< pair<int, long int> > allSkills, singleSkills;\n\n        cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            long int hp;\n            cin >> hp;\n            hps.push_back(hp);\n        }\n\n        cin >> skillNumber;\n        for(int i = 0; i < skillNumber; i++) {\n            int mp;\n            long int damage;\n            string name, target;\n            cin >> name >> mp >> target >> damage;\n            if(target == \"All\") {\n                allSkills.push_back(make_pair(mp, damage));\n            } else {\n                singleSkills.push_back(make_pair(mp, damage));\n            }\n        }\n\n        maxHP = *max_element(hps.begin(), hps.end());\n        fillDP(allSkills, allDP, maxHP);\n        fillDP(singleSkills, singleDP, maxHP);\n\n        int minimum = INF;\n        for(long int i = maxHP; i > 0; i--) {\n            minimum = min(minimum, singleDP[i]);\n            singleDP[i] = minimum;\n        }\n\n        long int answer = (long int) INF;\n\n        for(long int i = 0; i <= maxHP; i++) {\n            if(allDP[i] == INF) {\n                continue;\n            }\n\n            long int cost = allDP[i];\n\n            for(int j = 0; j < enemyNumber; j++) {\n                if(hps[j] - i > 0) {\n                    cost += singleDP[hps[j] - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nvoid solve(const vector<pair<int, int> >& attack, vector<int>& cost)\n{\n    cost.assign(100001, INF);\n    cost[0] = 0;\n\n    int n = attack.size();\n    for(int i=0; i<100000; ++i){\n        for(int j=0; j<n; ++j){\n            int k = i + attack[j].second;\n            if(k <= 100000)\n                cost[k] = min(cost[k], cost[i] + attack[j].first);\n        }\n    }\n\n    for(int i=100000; i>0; --i)\n        cost[i-1] = min(cost[i-1], cost[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> hp(n);\n        for(int i=0; i<n; ++i)\n            cin >> hp[i];\n\n        int m;\n        cin >> m;\n        vector<pair<int, int> > a; // 単体攻撃\n        vector<pair<int, int> > b; // 全体攻撃\n        for(int i=0; i<m; ++i){\n            string s, target;\n            int mp, damage;\n            cin >> s >> mp >> target >> damage;\n            if(target == \"Single\")\n                a.push_back(make_pair(mp, damage));\n            else\n                b.push_back(make_pair(mp, damage));\n        }\n\n        vector<int> cost1, cost2;\n        solve(a, cost1);\n        solve(b, cost2);\n\n        long long ret = INF;\n        for(int i=0; i<=100000; ++i){\n            long long tmp = cost2[i];\n            for(int j=0; j<n; ++j)\n                tmp += cost1[max(0, hp[j] - i)];\n            ret = min(ret, tmp);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\nint hp[110];\n\nconst int hpmax=100000;\n\nint single[100010];\nint all[100010];\n\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n) cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i,hpmax+10) single[i]=inf,all[i]=inf;\n\t\tsingle[0]=all[0]=0;\n\t\trep(i,m){\n\t\t\tstring _,type;\n\t\t\tint mp,damage;\n\t\t\tcin >> _ >> mp >> type >> damage;\n\t\t\tdamage=min(damage,hpmax);\n\t\t\tif(type==\"Single\"){\n\t\t\t\trep(j,hpmax) if(j+damage<=hpmax) single[j+damage]=min(single[j+damage],single[j]+mp);\n\t\t\t}else{\n\t\t\t\trep(j,hpmax) if(j+damage<=hpmax) all[j+damage]=min(all[j+damage],all[j]+mp);\n\t\t\t}\n\t\t}\n\t\tfor(int i=hpmax;i>=0;i--){\n\t\t\tsingle[i]=min(single[i],single[i+1]);\n\t\t\tall[i]=min(all[i],all[i+1]);\n\t\t}\n\t\tint ans=all[hpmax];\n\t\trep(i,hpmax+1){\n\t\t\tint cur=all[i];\n\t\t\trep(j,n){\n\t\t\t\tint index=max(0,hp[j]-i);\n\t\t\t\tcur+=single[index];\n\t\t\t}\n\t\t\tans=min(ans,cur);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\n\nusing namespace std;\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\n\nstruct state{\n\tstate():sum_mp(0),rest(0){}\n\tvector<int> vhp;\n\tint sum_mp;\n\tint rest;\n\tbool bComp()const{\n\t\tif(rest<=0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tbool operator<(const state &t)const{\n\t\treturn sum_mp<t.sum_mp;\n\t}\n\tint getHeuristic(double best_rate)const{\n\t\treturn (int)( rest / best_rate + 0.5 );\n\t}\n};\nostream &operator <<(ostream &os, const state &t){\n\tos<<\"HP: \";\n\tfor(unsigned int i=0;i<t.vhp.size();++i){\n\t\tos<<t.vhp[i]<<' ';\n\t}\n\tos<<\"\\nSUM MP: \"<<t.sum_mp<<\" REST HP: \" << t.rest;\n\treturn os;\n}\n\nvoid solve(const state &ini, const vector<magic> &vmag, double best_rate, int &best_ans){\n\tint n=ini.vhp.size();\n\tpriority_queue< state > qs;\n\n\tqs.push( ini );\n\n\twhile( !qs.empty() ){\n\t\tstate st = qs.top();\n\t\tqs.pop();\n\n\t\tif( st.sum_mp >= best_ans )\n\t\t\tbreak;\n\n\t\tif( st.bComp() ){\n\t\t\tbest_ans=min(best_ans,st.sum_mp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(unsigned int i=0;i<vmag.size();++i){\n\t\t\tif( st.sum_mp+vmag[i].mp >= best_ans )\n\t\t\t\tcontinue;\n\t\t\tif(vmag[i].type==ALL){\n\t\t\t\tstate t = st;\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( t.vhp[j] > 0 ){\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\tqs.push( t );\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( st.vhp[j]>0 ){\n\t\t\t\t\t\tstate t = st;\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\t\t\tqs.push( t );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tint ans=INFTY;\n\t\tdouble best_rate=0.0;\n\t\tvector<magic> vmagic;\n\t\tstate init;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tinit.rest+=t;\n\t\t\tinit.vhp.push_back(t);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint mp,type,damage;\n\t\t\tchar stype[17]=\"\";\n\n\t\t\tscanf(\"%*s%d%s%d\", &mp, stype, &damage);\n\n\t\t\tif(strcmp(stype,\"All\")==0)type=ALL;\n\t\t\telse type=SINGLE;\n\n\t\t\tif(damage>0&&mp==0){\n\t\t\t\tbest_rate=-2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(damage>0&&mp>0){\n\t\t\t\tmagic tm;\n\t\t\t\tbest_rate=max(best_rate,(double)damage*( type==ALL?n:1 ) /mp);\n\t\t\t\ttm.damage=damage;tm.mp=mp;tm.type=type;\n\t\t\t\tvmagic.push_back( tm );\n\t\t\t}\n\t\t}\n\n\t\tif( best_rate<0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsolve(init,vmagic,best_rate,ans);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INF 99990000\n\nint main()\n{\n\tint N,M,HP[100];\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> HP[i];\n\t\t\t\n\t\tcin >> M;\n\t\tint ss[100], as[100],sd[100],ad[100],sn=0,an=0;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tstring n,t;\n\t\t\tint m,d;\n\t\t\tcin >> n >> m >> t >> d;\n\t\t\tif(d==0) continue;\n\t\t\t\n\t\t\tif(t==\"All\")\n\t\t\t{\n\t\t\t\tas[an]=m;\n\t\t\t\tad[an]=d;\n\t\t\t\tan++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss[sn]=m;\n\t\t\t\tsd[sn]=d;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shp[100001], ahp[100001];\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tshp[i]=INF;\n\t\t\tahp[i]=INF;\n\t\t}\n\t\tshp[0]=0; ahp[0]=0;\n\t\tfor(int i=0; i<sn; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(shp[j]==INF) continue;\n\t\t\tif(j+sd[i]>100000)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tshp[100000]=min(shp[100000], shp[j]+ss[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tshp[j+sd[i]]=min(shp[j+sd[i]], shp[j]+ss[i]);\n\t\t}\n\t\t\n\t\tfor(int i=100000-1; i>=0; i--)\n\t\t\tshp[i]=min(shp[i+1], shp[i]);\n\t\t\n\t\tfor(int i=0; i<an; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(ahp[j]==INF) continue;\n\t\t\tif(j+ad[i]>100000) \n\t\t\t{\n\t\t\t\tif(ahp[j]==INF) continue;\n\t\t\t\tahp[100000]=min(ahp[100000], ahp[j]+as[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tahp[j+ad[i]]=min(ahp[j+ad[i]], ahp[j]+as[i]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tif(ahp[i]==INF) continue;\n\t\t\tint tmp=ahp[i];\n\t\t\t\n\t\t\tbool g=true;\n\t\t\t\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(i>=HP[j]) continue;\n\t\t\t\tif(shp[HP[j]-i]==INF) g=false;\n\t\t\t\ttmp+=shp[HP[j]-i];\n\t\t\t}\n\t\t\tif(!g) continue;\n\t\t\t\n\t\t\tans=min(ans, tmp);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#define INF 1e8\nusing namespace std;\n\nint n,m;\nint hp[101];\nint dp[2][100001];\nint mp[101],t[101],d[101];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&hp[i]);\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str,st2;\n\t\t\tcin >> str >> mp[i] >> st2 >> d[i];\n\t\t\tif(st2==\"Single\")t[i]=0;\n\t\t\telse t[i]=1;\n\t\t}\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tdp[0][i]=dp[1][i]=INF;\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tdp[i][0]=0;\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tif(dp[i][j]<INF){\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(t[k]==i){\n\t\t\t\t\t\t\tdp[i][min(j+d[k],100000)]=min(dp[i][min(j+d[k],100000)],dp[i][j]+mp[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=100000;j>=1;j--){\n\t\t\t\tif(dp[i][j]<dp[i][j-1])dp[i][j-1]=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint cost=dp[1][i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(hp[j]>i)cost+=dp[0][hp[j]-i];\n\t\t\t}\n\t\t\tres=min(res,cost);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 101;\nconst int MAXD = 200001;\nconst int INF = 1<<28;\nint N, A, S;\nint HP[MAXN];\nint aMP[MAXN], aDM[MAXN];\nint sMP[MAXN], sDM[MAXN];\nint aDP[MAXD], sDP[MAXD];\n\nvoid calc(int n, int w[MAXN], int cost[MAXN], int dp[MAXD]) {\n  fill(dp, dp+MAXD, INF);\n  dp[0] = 0;\n  for(int i = 0; i < n; ++i) {\n    for(int j = w[i]; j < MAXD; ++j) {\n      dp[j] = min(dp[j], dp[j-w[i]] + cost[i]);\n    }\n  }\n  for(int j = MAXD-1; j-1 >= 0; --j) {\n    dp[j-1] = min(dp[j-1], dp[j]);\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) cin >> HP[i];\n    int M; cin >> M;\n    A = S = 0;\n    for(int i = 0; i < M; ++i) {\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      damage = min(damage, 100000);\n      if(target == \"All\") {\n        aMP[A] = mp;\n        aDM[A] = damage;\n        ++A;\n      } else {\n        sMP[S] = mp;\n        sDM[S] = damage;\n        ++S;\n      }\n    }\n    calc(A, aDM, aMP, aDP);\n    calc(S, sDM, sMP, sDP);\n    int res = INF;\n    for(int i = 0; i < MAXD; ++i) {\n      int sum = aDP[i];\n      for(int j = 0; j < N; ++j) {\n        sum += sDP[max(0, HP[j]-i)];\n      }\n      res = min(res, sum);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    int hp[100];\n    REP(i, N) cin>>hp[i];\n    int M; cin>>M;\n    int mp[100], pow[100], type[100];\n    REP(i, M){\n      string s; cin>>s;\n      cin>>mp[i];\n      cin>>s;\n      if(s == \"Single\") type[i] = 0;\n      else type[i] = 1;\n      cin>>pow[i];\n    }\n    ll dp[2][100001];\n    REP(i, 2) fill(dp[i], dp[i] + 100001, 1e16);\n    dp[0][0] = 0, dp[1][0] = 0;\n    REP(from, 100000){\n      REP(i, M){\n        int to = from + pow[i];\n        if(to > 100000) to = 100000;\n        dp[type[i]][to] = min(dp[type[i]][to], dp[type[i]][from] + mp[i]);\n      }\n    }\n    for(int j = 100000; j > 0; j--) dp[0][j - 1] = min(dp[0][j - 1], dp[0][j]);\n    ll ans = 1e16;\n    REP(all, 100001){\n      ll sub_ans = dp[1][all];\n      if(sub_ans == 1e16) continue;\n      REP(i, N){\n        if(hp[i] - all > 0){\n          sub_ans += dp[0][hp[i] - all];\n        }\n      }\n      ans = min(ans, sub_ans);\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n  \nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    int h[n];\n    for(int i=0; i<n; i++) cin >> h[i];\n    cin >> m;\n    vector<P> a,b;\n    string name,t;\n    for(int i=0; i<m; i++) {\n      P c;\n      cin >> name >> c.first >> t >> c.second;\n      if(t==\"All\") a.push_back(c);\n      else b.push_back(c);\n    }\n    sort(a.begin(),a.end());\n    sort(b.begin(),b.end());\n    int da[100001],db[100001];\n    fill(da,da+100001,1<<29);\n    fill(db,db+100001,1<<29);\n    da[0]=db[0]=0;\n    for(int i=0; i<a.size(); i++) {\n      for(int j=0; j<100001; j++) da[min(100000,j+a[i].second)]=min(da[min(100000,j+a[i].second)],da[j]+a[i].first);\n    }\n    for(int i=0; i<b.size(); i++) {\n      for(int j=0; j<100001; j++) db[min(100000,j+b[i].second)]=min(db[min(100000,j+b[i].second)],db[j]+b[i].first);\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    int ans=1<<29;\n    for(int i=0; i<=100000; i++) {\n      int d=da[i];\n      if(d==1<<29) continue;\n      bool f=1;\n      for(int j=0; j<n; j++) {\n        int x=max(0,h[j]-i);\n    if(db[x]>=1<<29) f=0;\n        d+=db[x];\n      }\n      if(f) ans=min(ans,d);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,cnt;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nvector<P> v;\nvector<int> minv;\n\nint bynary_search(int x){\n  int L=0,R=v.size();\n  while(L<R){\n    int M=(L+R)/2;\n    if(v[M].first>=x)R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++)\n      if(dpSin[i]!=INF)v.push_back(P(i,dpSin[i])),minv.push_back(0);\n    int a=INF;\n    for(int i=(int)v.size()-1;i>=0;i--){\n      a=min(a,v[i].second);\n      minv[i]=a;\n    }\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      cnt=dpAll[i];\n      for(int j=0;j<n;j++){\n\tint k=hp[j]-i;\n\tcnt+=minv[bynary_search(k)];\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n    minv.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n && n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 200000 + 1;\n    const int inf = 1000000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          if(j + damage < MAX)\n            memo[j + damage] = min(memo[j + damage], memo[j] + mp);\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      for(int j = MAX - 1; j > 0; j--){\n        memo[j - 1] = min(memo[j - 1], memo[j]);\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      if(mp >= ans) goto next;\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n          if(mp >= ans) goto next;\n        }\n      }\n      ans = mp;\n    next:;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nint dp1[100010],dp2[100010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint m,d;\n\t\t\tcin>>s>>m>>t>>d;\n\t\t\td=min(d,100000);\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=m;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=m;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+100001,INF);\n\t\tfill(dp2,dp2+100001,INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,100001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,100001){\n\t\t\tint res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tint rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint single[100001];\nint all[100001];\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int hp[n];\n    int maxhp = 0;\n    REP(i,n) {\n      cin >> hp[i];\n      maxhp = max(maxhp, hp[i]);\n    }\n    int m;\n    cin >> m;\n    REP(i,maxhp+1)\n      single[i] = all[i] = INF;\n    single[0] = all[0] = 0;\n    REP(i,m) {\n      string s;\n      int mp,damage;\n      cin >> s>>mp>>s>>damage;\n      REP(j,maxhp+1) {\n        if (s == \"Single\")\n          single[j] = min(single[j], ((j>=damage)?single[j-damage]:0) + mp);\n        else\n          all[j] = min(all[j], ((j>=damage)?all[j-damage]:0) + mp);\n      }\n    }\n    // REP(i,maxhp+1) {\n    //   printf(\"%d : %d, %d\\n\", i, single[i], all[i]);\n    // }\n    int ans = INF;\n    REP(i, maxhp+1) {\n      int smp = 0;\n      bool f = 0;\n      REP(j,n) {\n        if (hp[j]>=i) {\n          if (single[hp[j]-i] == INF) {\n            f = 1;\n            break;\n          }\n          smp += single[hp[j]-i];\n        }\n      }\n      if (f) continue;\n      ans = min(ans, all[i] + smp);\n    }\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 50000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n  \n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n}\n\n\n\nvoid calc_all(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n  \n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){    \n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  }\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF;\n  calc_single(maxhp,mpsingle,damagesingle);\n  calc_all(maxhp,mpall,damageall);\n  \n\n\n\n  rep(i,maxhp){\n    if ( res_all[i]>=INF)continue;\n    int tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nconst int MAX_D = 2000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tsi[i - 1] = min(si[i - 1], si[i]);\n\t\t}\n\n\t\tlong long ans = al[*max_element(all(h))];\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,HP[111],M;\nint dpa[100001],dps[100001];\nvector<P> ds,da;\nint MAX;\nconst int INF = (1<<29);\n\nvoid init(const vector<P> &D,int *dp){\n  for(int j=0;j<=MAX;j++){\n    for(int i=0;i<(int)D.size();i++){\n      int np = j + D[i].first;\n      np = min( np, MAX );\n      dp[np] = min( dp[j] + D[i].second, dp[np] );\n    }\n  }\n  for(int i=MAX-1;i>=0;i--){\n    dp[i] = min( dp[i+1], dp[i] );\n  }\n}\n\nint main(){\n  while( cin >> N && N ){\n    MAX = 0;\n    for(int i=0;i<N;i++) {\n      cin >> HP[i]; MAX = max( MAX, HP[i] );\n    }\n    cin >> M;\n    ds.clear(); da.clear();\n    for(int i=0;i<M;i++){\n      string s,ta;int mp,dm;\n      cin >> s >> mp >> ta >> dm;\n      if( ta == \"Single\" )\n\tds.push_back( P(dm,mp) );\n      else\n\tda.push_back( P(dm,mp) );\n    }\n    fill(dps,dps+MAX+1,INF);\n    fill(dpa,dpa+MAX+1,INF);\n    dps[0] = dpa[0] = 0;\n    init(da,dpa);\n    init(ds,dps);\n    int res = INF;\n    for(int i=0;i<=MAX;i++){\n      int ret = dpa[i];\n      for(int j=0;j<N;j++){\n\tint hp = HP[j] - i;\n\thp = max(hp,0);\n\tret += dps[hp];\n\tif( ret > INF ) ret = INF;\n      }\n      res = min( res, ret );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define chmin(a, b) (a = min(a, b))\n\nint n, m;\nint a[100];\nvector<pair<int, int>> v[2];\nlong long dp[2][100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tv[0].clear(), v[1].clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s, t;\n\t\t\tint p, d;\n\t\t\tcin >> s >> p >> t >> d;\n\t\t\tv[t == \"Single\"].emplace_back(p, d);\n\t\t}\n\t\tfill_n(*dp, 2 * 100010, 1ll << 60);\n\t\tdp[0][0] = dp[1][0] = 0;\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < v[i].size(); j++){\n\t\t\t\tfor (int k = 1; k <= 100000; k++){\n\t\t\t\t\tchmin(dp[i][k], dp[i][max(0, k - v[i][j].second)] + v[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = 1ll << 60;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long sum = dp[0][i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tsum += dp[1][max(0, a[j] - i)];\n\t\t\t}\n\t\t\tchmin(res, sum);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nconst int inf = 3e18;\n\nsigned main()\n{\n    int N;\n\n    while (cin >> N, N) {\n        vector<int> hp(N);\n\n        rep(i, N) {\n            cin >> hp[i];\n        }\n\n        int M;\n\n        cin >> M;\n\n        vector<pair<int,int>> S, A;\n\n        rep(i, M) {\n            string s;\n            int mp, dmg;\n            cin >> s >> mp >> s >> dmg;\n            if (dmg == 0) continue;\n            if (s == \"Single\") S.push_back(make_pair(mp, dmg));\n            else A.push_back(make_pair(mp, dmg));\n        }\n\n        vector<int> dp1(100010, inf), dp2(100010, inf);\n        dp1[0] = dp2[0] = 0;\n\n        for (int i = 0; i < S.size(); ++i) {\n            int mp = S[i].first, dmg = S[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0) {\n                    if (dp1[j - dmg] != inf) {\n                        dp1[j] = min(dp1[j], dp1[j - dmg] + mp);\n                    };\n                } else {\n                    dp1[j] = min(dp1[j], mp);\n                }\n            }\n        }\n\n        for (int i = 100001; i >= 1; --i) dp1[i - 1] = min(dp1[i - 1], dp1[i]);\n\n        for (int i = 0; i < A.size(); ++i) {\n            int mp = A[i].first, dmg = A[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0) {\n                    if (dp2[j - dmg] != inf) {\n                        dp2[j] = min(dp2[j], dp2[j - dmg] + mp);\n                    }\n                } else {\n                    dp2[j] = min(dp2[j], mp);\n                }\n            }\n        }\n\n        for (int i = 100001; i >= 1; --i) dp2[i - 1] = min(dp2[i - 1], dp2[i]);\n\n        int mi = inf;\n\n        dp1[0] = dp2[0] = 0;\n\n        for (int a = 0; a <= 100000; ++a) {\n            int sum = dp2[a];\n\n            if (sum == inf) continue;\n\n            for (int i = 0; i < N; ++i) {\n                if (hp[i] - a >= 0) {\n                    sum += dp1[hp[i] - a];\n                    if (dp1[hp[i] - a] == inf) goto nxt;\n                }\n            }\n\n            mi = min(mi, sum);\n            nxt:;\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INFTY=1<<29;\n\nstruct Spell{\n\tint m,d;\n\tSpell(){}\n\tSpell(int m,int d):m(m),d(d){}\n};\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n,n;){\n\t\tvector<int> hs(n);\n\t\tfor(int& h:hs) cin>>h;\n\t\tcin>>m;\n\t\tvector<Spell> ss,as; // single,all\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring n,t; int m,d;\n\t\t\tcin>>n>>m>>t>>d; chmin(d,100000);\n\t\t\tif(t==\"Single\") ss.emplace_back(m,d);\n\t\t\telse            as.emplace_back(m,d);\n\t\t}\n\t\t\n\t\tvector<int> sdp(100001,INFTY); sdp[0]=0;\n\t\tfor(int i=0;i<ss.size();i++){\n\t\t\tfor(int j=1;j<ss[i].d;j++)\n\t\t\t\tchmin(sdp[j],ss[i].m);\n\t\t\tfor(int j=ss[i].d;j<sdp.size();j++)\n\t\t\t\tchmin(sdp[j],sdp[j-ss[i].d]+ss[i].m);\n\t\t}\n\t\tvector<int> adp(100001,INFTY); adp[0]=0;\n\t\tfor(int i=0;i<as.size();i++){\n\t\t\tfor(int j=1;j<as[i].d;j++)\n\t\t\t\tchmin(adp[j],as[i].m);\n\t\t\tfor(int j=as[i].d;j<adp.size();j++)\n\t\t\t\tchmin(adp[j],adp[j-as[i].d]+as[i].m);\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint temp=adp[i];\n\t\t\tfor(int& h:hs)\n\t\t\t\ttemp+=sdp[max(h-i,0)];\n\t\t\tchmin(res,temp);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint n,m,hp[101];\n\nint dp[2][200010];\n\nint main(){\n\n  while(cin>>n,n){\n  for(int i=0;i<n;i++) cin>>hp[i];\n\n  vector <P> mg[2];\n  cin>>m;\n  for(int i=0,cost,dam;i<m;i++){\n    string name,type;\n    cin>>name>>cost>>type>>dam;\n    mg[type==\"All\"].push_back(P(dam,cost));\n  }\n\n  dp[0][0]=dp[1][0]=0;\n  for(int i=0;i<2;i++) \n    for(int j=1;j<200010;j++)dp[i][j]=INF;\n \n  for(int k=0;k<2;k++)\n    for(int i=0;i<(int)mg[k].size();i++)\n      for(int j=mg[k][i].f;j<=100000+mg[k][i].f;j++)\n\tdp[k][j]=min(dp[k][j],dp[k][j-mg[k][i].f]+mg[k][i].s);\n    \n  for(int i=0;i<2;i++)\n    for(int j=200000;j>=0;j--)\n      dp[i][j]=min(dp[i][j],dp[i][j+1]);\n\n  int ans=INF;\n  for(int i=0;i<200000;i++){\n    int cost=dp[1][i];\n    for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n    ans=min(ans,cost);\n }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 1e5+10;\n\nint dp_s[N];\nint dp_a[N];\n\nint mons[110];\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\tcin >> n;\n\trep(i, n) cin >> mons[i];\n\n\tint m;\n\tcin >> m;\n\tFOR(i, 1, N) dp_s[i] = dp_a[i] = 1e9;\n\trep(i, m){\n\t\tstring s;\n\t\tint w, v;\n\t\tcin >> s >> w >> s >> v;\n\t\tv = min(v, N-5);\n\t\tint *dp;\n\t\tif (s[0] == 'S') dp = dp_s; \n\t\telse dp = dp_a;\n\n\t\tfor (int i = 0; i + v < N; ++i){\n\t\t\tdp[i + v] = min(dp[i + v], dp[i] + w);\n\t\t}\n\t}\n\n\tfor (int i = N - 5; i >= 0; --i){\n\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t}\n\t\n\tint ans = 1e9;\n\trep(i, N){\n\t\tint tmp = dp_a[i];\n\t\tif (tmp == 1e9) continue;\n\n\t\trep(j, n) tmp += dp_s[max(mons[j]-i, 0)];\n\t\tans = min(ans, tmp);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint HP[100], M;\nlong long dp1[100001], dp2[100001];\n\nint solve(int N)\n{\n  memset(dp1, 0, sizeof(dp1));\n  memset(dp2, 0, sizeof(dp2));\n    \n  for(int i = 0; i < N; i++) {\n    cin >> HP[i];\n  }\n  cin >> M;\n\n  bool end = false;\n  while(M--) {\n    string Name, Target;\n    int MP, Damage;\n    cin >> Name >> MP >> Target >> Damage;\n    if(MP == 0) {\n      if(Damage > 0) end = true;\n      continue;\n    }\n    for(int i = MP; i <= 100000; i++) {\n      dp2[i] = max(dp2[i], dp2[i - MP] + Damage);\n    }\n    if(Target.size() == 6) continue;\n    for(int i = MP; i <= 100000; i++) {\n      dp1[i] = max(dp1[i], dp1[i - MP] + Damage);\n    }\n  }\n  if(end) return(0);\n  \n  int best = 1 << 30;\n  for(int i = 0; i <= 100000; i++) {\n    int ret = 0;\n    for(int j = 0; j < N; j++) {\n      ret += lower_bound(dp2, dp2 + 100001, HP[j] - dp1[i]) - dp2;\n    }\n    best = min(best, i + ret);\n  }\n  return(best);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\tif(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> HP(N);\n    for(int i = 0; i < N; ++i){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<int> single_d, single_mp, all_d, all_mp;\n    string name, target;\n    int mp, damege;\n    for(int i = 0; i < M; ++i){\n      cin >> name >> mp >> target >> damege;\n      if(target == \"Single\"){\n        single_d.push_back(damege);\n        single_mp.push_back(mp);\n      }else{\n        all_d.push_back(damege);\n        all_mp.push_back(mp);\n      }\n    }\n    int INF = 1e9, n = 2e5;\n    vector<int> dp1(n,INF), dp2(n,INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < single_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp1[j] >= INF) continue;\n        if(j + single_d[i] < n)\n          dp1[j + single_d[i]] = min(dp1[j + single_d[i]], dp1[j] + single_mp[i]);\n      }\n    }\n    for(int i = n-2; i >= 0; --i) dp1[i] = min(dp1[i], dp1[i+1]);\n    for(int i = n-2; i >= 0; --i) dp2[i] = min(dp2[i], dp2[i+1]);\n    \n    for(int i = 0; i < all_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp2[j] >= INF) continue;\n        if(j + all_d[i] < n)\n          dp2[j + all_d[i]] = min(dp2[j + all_d[i]], dp2[j] + all_mp[i]);\n      }\n    }\n    long long int ans = 1e15;\n    for(int i = 0; i < n; ++i){\n      if(dp2[i] >= INF) continue;\n      long long int t = dp2[i];\n      for(int j = 0; j < N; ++j){\n        t += dp1[max(0,HP[j] - i)];\n      }\n      ans = min(ans,t);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;//first : MP, second : Damage\nvoid set_cost(vector<int>& cost, const vector<pint>& attack){\n    cost[0] = 0;\n    REP(i, 1, cost.size()){\n        for(pint k : attack){\n            int temp = k.first;\n            if(i - k.second >= 0) temp += cost[i - k.second];\n            cost[i] = min(cost[i], temp);\n        }\n    }\n    return;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        int HP_MAX = -INF;\n        vector<int> HP(N);\n        rep(i, N){\n            cin >> HP[i];\n            HP_MAX = max(HP_MAX, HP[i]);\n        }\n        int M; cin >> M;\n        vector<pint> single, all;\n        rep(i, M){\n            string a, b;\n            int c, d;\n            cin >> a >> c >> b >> d;\n            if(b == \"All\")\n              all.push_back(pint(c, d));\n            else\n              single.push_back(pint(c, d));\n        }\n        vector<int> scost(HP_MAX + 1, INF), acost(HP_MAX + 1, INF);\n        set_cost(scost, single);\n        set_cost(acost, all);\n        int ans = INF;\n        rep(d, HP_MAX + 1){\n            int sum = acost[d];\n            for(int k : HP){\n                int need = max(0, k - d);\n                sum += scost[need];\n            }\n            ans = min(sum, ans);\n        }\n        /*\n        while(true){\n            int hit = INF, enemies = 0;\n            for(int k : HP)\n              if(k > 0) {\n                  enemies++;\n                  hit = min(k, hit);\n              }\n            if(enemies == 0) break;\n            int cost, damage;\n            if(acost[hit] > scost[hit] * enemies){\n                cost = scost[hit];\n                REP(i, hit, HP_MAX + 1) if(scost[i] != cost){ damage = i - 1; break;}\n                cost *= enemies;\n            }else{\n                cost = acost[hit];\n                REP(i, hit, HP_MAX + 1) if(acost[i] != cost){ damage = i - 1; break;}\n            }\n            for(int& k : HP) k -= damage;\n            ans += cost;\n        }*/\n        \n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstruct edge {\n\tint from;\n\tint to;\n\tlong double time;\n};\nstruct aa {\n\tint now;\n\tlong double time;\n\tbitset<8>tickets;\n};\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint fizznum[15] = { 0,0,1,1,1,2,2,2,3,3,3,4,4,4,4 };\nint buzznum[15] = { 0,0,0,0,1,1,1,1,1,2,2,2,2,2,2 };\nint fibunum[15] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 };\nlong long int memo[18];\n\nstring makefb(long long int num) {\n\tstring st;\n\tif (!(num % 3)) {\n\t\tst+=(\"Fizz\");\n\t}\n\tif (!(num % 5)) {\n\t\tst+=(\"Buzz\");\n\t}\n\tif (st.size() == 0) {\n\t\tst = to_string(num);\n\t}\n\treturn st;\n}\n\nstring getans(long long int rest, long long int from) {\n\tstring ans;\n\tlong long int now(from);\n\twhile (1) {\n\t\tstring ast(makefb(now));\n\t\tif (rest <= ast.size()) {\n\t\t\tans+=(ast.substr(rest, int(ast.size() - rest)));\n\t\t\trest = 0;\n\t\t}\n\t\telse {\n\t\t\trest -= ast.size();\n\t\t}\n\t\tnow++;\n\t\tif (ans.size() >= 20) {\n\t\t\treturn ans.substr(0, 20);\n\t\t}\n\t}\n}\n\n\nvector<pair<int, int>>smag, amag;\nvector<int>hps;\n\nlong long int sdp[100001];\nlong long int adp[100001];\n\n\nlong long int getmp(int damage) {\n\tlong long int ans = 0;\n\tfor (auto i : hps) {\n\t\tif (i - damage <= 0) {\n\n\t\t}\n\t\telse {\n\t\t\tans += sdp[i - damage];\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\thps.clear();\n\t\tsmag.clear();\n\t\tamag.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\thps.emplace_back(a);\n\t\t}\n\t\tconst int max_hp = *max_element(hps.begin(), hps.end());\n\t\tint M; cin >> M;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tint mp; cin >> mp;\n\t\t\tcin >> st;\n\t\t\tint dam; cin >> dam;\n\t\t\tif (st == \"Single\") {\n\t\t\t\tsmag.push_back({ mp,dam });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamag.push_back({ mp,dam });\n\t\t\t}\n\t\t}\n\n\t\tmemset(sdp, 9999999,sizeof(sdp));\n\t\tmemset(adp, 9999999, sizeof(adp));\n\t\tsdp[0] = 0; adp[0] = 0;\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tfor (auto mag : smag) {\n\t\t\t\tsdp[min(100000,i + mag.second)] = min(sdp[min(100000, i + mag.second)], sdp[i] + mag.first);\n\t\t\t}\n\t\t\tfor (auto mag : amag) {\n\t\t\t\tadp[min(100000, i + mag.second)] = min(adp[min(100000, i + mag.second)], adp[i] + mag.first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\t\n\t\t\tsdp[100000-i-1] = min(sdp[100000-i], sdp[100000 - i - 1]);\n\t\t\t\n\t\t\t\n\t\t\tadp[100000-i-1] = min(adp[100000-i], adp[100000 - i - 1]);\n\t\t\t\n\t\t}\n\n\t\tlong long int ans = 9999999999999999;\n\t\tif (adp[1] > 1000) {\n\t\t\tans = getmp(0);\n\t\t}\n\t\telse if (sdp[1] > 1000) {\n\t\t\tans = adp[max_hp];\n\t\t}\n\t\t\n\t\tfor (int alldamage = 0; alldamage <= max_hp; ++alldamage) {\n\t\t\tans = min(ans, adp[alldamage] + getmp(alldamage));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nconst int inf = 1e9;\n\nsigned main()\n{\n    int N;\n\n    while (cin >> N, N) {\n        vector<int> hp(N);\n\n        rep(i, N) {\n            cin >> hp[i];\n        }\n\n        int M;\n\n        cin >> M;\n\n        vector<pair<int,int>> S, A;\n\n        rep(i, M) {\n            string s;\n            int mp, dmg;\n            cin >> s >> mp >> s >> dmg;\n            if (s == \"Single\") S.push_back(make_pair(mp, dmg));\n            else A.push_back(make_pair(mp, dmg));\n        }\n\n        vector<int> dp1(100010, inf), dp2(100010, inf);\n        dp1[0] = dp2[0] = 0;\n\n        for (int i = 0; i < S.size(); ++i) {\n            int mp = S[i].first, dmg = S[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0) {\n                    dp1[j] = min(dp1[j], dp1[j - dmg] + mp);\n                } else {\n                    dp1[j] = min(dp1[j], mp);\n                }\n            }\n        }\n\n        for (int i = 0; i < A.size(); ++i) {\n            int mp = A[i].first, dmg = A[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0) {\n                    dp2[j] = min(dp2[j], dp2[j - dmg] + mp);\n                } else {\n                    dp2[j] = min(dp2[j], mp);\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int a = 0; a <= 100000; ++a) {\n            int sum = dp2[a];\n\n            for (int i = 0; i < N; ++i) {\n                if (hp[i] - a >= 0) {\n                    sum += dp1[hp[i] - a];\n                }\n            }\n\n            mi = min(mi, sum);\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<28\n#define MAX_HP 100001\n\nusing namespace std;\n\nstruct monster{\n\tint hp;\n};\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\n\nvoid min_mp(int *min, int max_hp, const vector<magic> &vmag){\n\tint m = vmag.size();\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tmin[i] = INFTY;\n\t}\n\n\tif( m == 0 )\n\t\treturn ;\n\n\tint **dp = new int*[m];\n\tfor(int i = 0; i < m; ++i){\n\t\tdp[i] = new int[max_hp];\n\t}\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tdp[i][j] = INFTY;\n\t\t}\n\t}\n\t\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < m; ++i){\n\t\tint mp = vmag[i].mp;\n\t\tint damage = vmag[i].damage;\n\t\t\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tif( dp[i][j] < INFTY ){\n\t\t\t\tif( i + 1 < m )\n\t\t\t\t\tdp[i+1][j] = std::min( dp[i][j], dp[i+1][j] );\n\t\t\t\tint &a = dp[i][std::min(j+damage,max_hp-1)];\n\t\t\t\ta = std::min( a, dp[i][j] + mp );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = max_hp-1; i >= 0; --i){\n\t\tmin[i] = dp[m-1][i] == INFTY ? min[i+1] : dp[m-1][i];\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tdelete [] dp[i];\n\t}\n\tdelete [] dp;\n}\nint MagicSlayer(const vector<monster> &vmon, const vector<magic> &vmag){\n\tint ret = INFTY;\n\tvector<magic> vmag_single;\n\tvector<magic> vmag_all;\n\tint max_hp = 0;\n\tint min_mp_single[MAX_HP]={0,};\n\tint min_mp_all[MAX_HP]={0,};\n\n\tfor(unsigned int i = 0; i < vmon.size(); ++i){\n\t\tmax_hp = max( max_hp, vmon[i].hp );\n\t}\n\t++max_hp;\n\n\tfor(unsigned int i = 0; i < vmag.size(); ++i){\n\t\tif( vmag[i].type == ALL )\n\t\t\tvmag_all.push_back( vmag[i] );\n\t\telse\n\t\t\tvmag_single.push_back( vmag[i] );\n\t}\n\n\tmin_mp( min_mp_single, max_hp, vmag_single );\n\tmin_mp( min_mp_all, max_hp, vmag_all );\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tint dam;\n\t\tint t;\n\n\t\tif( min_mp_all[i] >= INFTY ){\n\t\t\tdam = 0;\n\t\t\tt = 0;\n\t\t}else{\n\t\t\tdam = i;\n\t\t\tt = min_mp_all[i];\n\t\t}\n\n\t\tfor(unsigned int j = 0; j < vmon.size(); ++j){\n\t\t\tif( vmon[j].hp - dam > 0 ){\n\t\t\t\tif( min_mp_single[ vmon[j].hp - dam ] >= INFTY )\n\t\t\t\t\tt = INFTY;\n\t\t\t\telse\n\t\t\t\t\tt += min_mp_single[ vmon[j].hp - dam ];\n\t\t\t}\n\t\t}\n\n\t\tret = min( ret, t );\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tvector<monster> vmonster;\n\t\tvector<magic> vmagic;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmonster t;\n\t\t\t\n\t\t\tscanf(\"%d\", &t.hp);\n\t\t\tvmonster.push_back( t );\n\t\t}\n\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar stype[17]=\"\";\n\t\t\tmagic mag;\n\n\t\t\tscanf(\"%*s%d%s%d\", &mag.mp, stype, &mag.damage);\n\t\t\tif(strcmp(stype,\"All\")==0)mag.type=ALL;\n\t\t\telse mag.type=SINGLE;\n\t\t\tvmagic.push_back( mag );\n\t\t}\n\n\t\tprintf(\"%d\\n\", MagicSlayer( vmonster, vmagic ) );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> HP(N);\n    for(int i = 0; i < N; ++i){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<int> single_d, single_mp, all_d, all_mp;\n    string name, target;\n    int mp, damege;\n    for(int i = 0; i < M; ++i){\n      cin >> name >> mp >> target >> damege;\n      if(target == \"Single\"){\n        single_d.push_back(damege);\n        single_mp.push_back(mp);\n      }else{\n        all_d.push_back(damege);\n        all_mp.push_back(mp);\n      }\n    }\n    long long int INF = 1e10, n = 2e5;\n    vector<int> dp1(n,INF), dp2(n,INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < single_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp1[j] >= INF) continue;\n        if(j + single_d[i] < n)\n          dp1[j + single_d[i]] = min(dp1[j + single_d[i]], dp1[j] + single_mp[i]);\n        else\n          dp1[n-1] = min(dp1[n-1], dp1[j] + single_mp[i]);\n      }\n    }\n    for(int i = n-2; i >= 0; --i) dp1[i] = min(dp1[i], dp1[i+1]);\n    for(int i = n-2; i >= 0; --i) dp2[i] = min(dp2[i], dp2[i+1]);\n    \n    for(int i = 0; i < all_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp2[j] >= INF) continue;\n        if(j + all_d[i] < n)\n          dp2[j + all_d[i]] = min(dp2[j + all_d[i]], dp2[j] + all_mp[i]);\n        else\n          dp2[n-1] = min(dp2[n-1], dp2[j] + all_mp[i]);\n      }\n    }\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      if(dp2[i] >= INF) continue;\n      long long int t = dp2[i];\n      for(int j = 0; j < N; ++j){\n        t += dp1[max(0,HP[j] - i)];\n      }\n      ans = min(ans,t);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nint dp1[2][100010], dp2[2][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >> target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 30;\n    }\n    for(int i = 1; i <= m; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(damage[i-1] == 0){\n          dp1[i%2][j] = dp1[(i-1)%2][j];\n          dp2[i%2][j] = dp2[(i-1)%2][j];   \n        }\n        else if(target[i-1] == \"All\"){\n            dp1[i%2][j] = min(dp1[(i-1)%2][j], dp1[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i%2][j] = dp2[(i-1)%2][j];          \n        }\n        else{\n            dp2[i%2][j] = min(dp2[(i-1)%2][j], dp2[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i%2][j] = dp1[(i-1)%2][j];\n        }\n      }\n    }\n    \n    \n    for(int i = 5000; i <= 10000; i++){\n      //cout << i << \" \" << dp2[n][i] <<endl;\n    }\n    \n    int ans = 1 << 30;\n    for(int i = 0; i <= 100000; i++){\n      int sum = dp1[m%2][i];\n      //cout << i << \" \" << dp1[n][i] << endl;\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[m%2][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n\tif(was_output)cout << \" \";\n\tcout << a;\n\twas_output = true;\n}\nvoid outendl(){\n\twas_output = false;\n\tcout << endl;\n}\n\n\nll func(int n){\n\tll MAX_HP = 0;\n\tvector<ll> hps(n);\n\tforeach(i, hps)cin>>i;\n\tforeach(i, hps)chmax(MAX_HP, i);\n\tint m;\n\tcin >> m;\n\tvector<pll> single_magic;\n\tvector<pll> wide_magic;\n\trep(i, m){\n\t\tstring name;\n\t\tll mp, damage;\n\t\tcin >> name >> mp >> name >> damage;\n\t\tif(name==\"All\"){\n\t\t\twide_magic.emplace_back(mp, damage);\n\t\t}else{\n\t\t\tsingle_magic.emplace_back(mp, damage);\n\t\t}\n\t}\n\tvector<ll> dp(MAX_HP+1, INFLL);\n\tdp[0] = 0;\n\trep(i, MAX_HP){\n\t\trep(j, single_magic.size()){\n\t\t\tint next_damage = min(MAX_HP, i + single_magic[j].second);\n\t\t\tll next_mp = dp[i] + single_magic[j].first;\n\t\t\tchmin(dp[next_damage], next_mp);\n\t\t}\n\t}\n\tvector<pll> mins;\n\t//damage mp\n\tmins.emplace_back(INFLL, INFLL);\n\tper(i, MAX_HP+1){\n\t\tif(mins.back().second>dp[i]){\n\t\t\tmins.emplace_back(i, dp[i]);\n\t\t}\n\t}\n\treverse(all(mins));\n\tdp.assign(MAX_HP+1, INFLL);\n\tdp[0] = 0;\n\trep(i, MAX_HP){\n\t\trep(j, wide_magic.size()){\n\t\t\tint next_damage = min(MAX_HP, i + wide_magic[j].second);\n\t\t\tll next_mp = dp[i] + wide_magic[j].first;\n\t\t\tchmin(dp[next_damage], next_mp);\n\t\t}\n\t}\n\t\n\tll res = INFLL;\n\trep(wide, MAX_HP+1){\n\t\tll sum = dp[wide];\n\t\trep(i, n){\n\t\t\tint now_hp = hps[i] - wide;\n\t\t\tsum += lower_bound(all(mins), pll(now_hp, 0))->second;\n\t\t\tchmin(sum, INFLL);\n\t\t}\n\t\tchmin(res, sum);\n\t}\n\n\treturn res;\n\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tcout << func(n) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator < (const DD &a)const{ return mp<a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1199999],res;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<M;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;//(h+_all[0].second-1)/_all[0].second*_all[0].first;\n\t\t\tsingle[i]=9999999;//(h+_single[0].second-1)/_single[0].second*_single[0].first;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\t\tif(all.empty()){\n\t\t\tfor(r=j=0;j<monster.size();j++)r+=single[monster[j]];\n\t\t}else if(single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;//(h+all[h]-1)/all[h];\n\t\t\tfor(i=1;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\t//cout<<i<<' '<<s<<' '<<all[i]<<endl;\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst ll HSIZE=100001;\nconst ll INF=1e15;\n\nll solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<ll> smp,sdmg;\n    vector<ll> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<ll> sdp;\n    {\n        vector<vector<ll>> tmp(2,vector<ll>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                tmp[to][min(j+sdmg[i],HSIZE-1)]=min(tmp[to][min(j+sdmg[i],HSIZE-1)],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<ll> adp;\n    {\n        vector<vector<ll>> tmp(2,vector<ll>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                tmp[to][min(j+admg[i],HSIZE-1)]=min(tmp[to][min(j+admg[i],HSIZE-1)],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    ll res=ll(1e15);\n    for(int i=0;i<HSIZE;i++){\n        ll sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc+=sdp[max(h[j]-i,0)];\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\nbool ok[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(dm == 0) continue;\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n\n    /*\n    REP(i,h+1) dpS[i] =dpA[i] = INT_MAX;\n    dpA[0] = dpS[0] = 0;\n    REP(i,h+1){\n      if(dpA[i] != INT_MAX){\n        REP(j,a){\n          int dd = min(h, i + dmA[j]);\n          dpA[dd] = min(dpA[dd], dpA[dd]);\n        }\n      }\n\n      if(dpS[i] != INT_MAX){\n        REP(j,s){\n          int tmp = i - dmS[j];\n          if(tmp < 0) tmp = 0;\n          tS = min(tS, dpS[tmp] + mpS[j]);\n        }\n      }\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    REP(i,h+1) dpS[i] = INT_MAX;\n    REP(i,h+1) dpA[i] = INT_MAX;\n\n    q.push(mpi(0,0));\n    REP(i,h+1) ok[i] = false;\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] > mm){\n          dpS[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n\n    REP(i,h+1) ok[i] = false;\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] > mm){\n          dpA[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    for(int i=h; i>=0; i--){\n      if(!ok[i]) continue;\n      int mp = dpA[i];\n      int dm = i;\n      if(ans <= mp) continue;\n\n      REP(j,n)\n        if(hp[j] > dm){\n          mp += dpS[hp[j] - dm];\n          if(mp >= ans) break;\n        }\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,am,sm,hp[110],maxhp;\nll amp[110],adm[110],smp[110],sdm[110];\nll dpa[100100], dps[100100];\nstring name;\nll tmp;\nconst ll INF = (ll)(1e15);\n\nint main(){\n  while(cin >> n,n){\n    maxhp = 0;\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n      maxhp = max(maxhp,hp[i]);\n    }\n\n    cin >> m;\n    am = sm = 0;\n\n    for(int i=0;i<m;i++){\n      cin >> name >> tmp;\n      cin >> name;\n      if(name == \"All\")amp[am] = tmp;\n      else smp[sm] = tmp;\n      cin >> tmp;\n      if(name == \"All\")adm[am++] = tmp;\n      else sdm[sm++] = tmp;\n    }\n\n\n    for(int i=0;i<=maxhp;i++)dpa[i] = INF;\n    dpa[0] = 0;\n\n    for(int i=0;i<am;i++){\n      for(int j=0;j<=maxhp;j++){\n\tif(dpa[j]<INF){\n\t  if(j+adm[i]<=maxhp){\n\t    dpa[j+adm[i]] = min(dpa[j+adm[i]],dpa[j] + amp[i]);\n\t  }else{\n\t    dpa[maxhp] = min(dpa[maxhp],dpa[j]+amp[i]);\n\t  }\n\t}\n      }\n    }\n\n    tmp = INF;\n    for(int i=maxhp;i>=0;i--){\n      if(tmp<dpa[i])dpa[i] = tmp;\n      else tmp = dpa[i];\n    }\n\n    for(int i=0;i<=maxhp;i++)dps[i] = INF;\n    dps[0] = 0;\n\n    for(int i=0;i<sm;i++){\n      for(int j=0;j<=maxhp;j++){\n\tif(dps[j]<INF){\n\t  if(j+sdm[i]<=maxhp){\n\t    dps[j+sdm[i]] = min(dps[j+sdm[i]],dps[j] + smp[i]);\n\t  }else{\n\t    dps[maxhp] = min(dps[maxhp],dps[j]+smp[i]);\n\t  }\n\t}\n      }\n    }\n\n    tmp = INF;\n    for(int i=maxhp;i>=0;i--){\n      if(tmp<dps[i])dps[i] = tmp;\n      else tmp = dps[i];\n    }\n\n    ll ans = INF;\n    for(int i=0;i<=maxhp;i++){\n      tmp = dpa[i];\n      for(int j=0;j<n;j++){\n\tint rem = hp[j] - i;\n\tif(rem<=0)continue;\n\ttmp += dps[rem];\n      }\n      ans = min(ans,tmp);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tmap<int,int>all_iter;\n\t\tall_iter[0]=0;\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t\tall_iter[all[i]]=i;\n\t\t}\n\n\t\tif(_single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;\n\t\t\tfor(map<int,int>::iterator it=all_iter.begin();it!=all_iter.end();it++){\n\t\t\t\th=it->first;\n\t\t\t\tfor(j=0;j<monster.size();j++)h+=single[max(0,monster[j]-it->second)];\n\t\t\t\tif(r>h)r=h;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#define INF 100000\nusing namespace std;\n\nstruct spell{\n    string name;\n    long long int mp;\n    string target;\n    long long int damage;\n};\nlong long int max(long long int n,long long int m){\n    if (n<m) {\n        return m;\n    }else{\n        return n;\n    }\n}\n\nint main() {\n    for (; ;) {\n        long long int n;\n        cin >> n;\n        if (n==0) break;\n        vector<long long int> hp(n);\n        long long int max_hp=0;\n        for (int i=0; i<n; i++) {\n            cin >> hp[i];\n            max_hp = max(max_hp,hp[i]);\n        }\n        int m;\n        cin >> m;\n        vector<spell> sp(m);\n        for (int i=0; i<m; i++) {\n            cin >> sp[i].name>> sp[i].mp>> sp[i].target >> sp[i].damage;\n        }\n        int smp=1000,amp=1000,sdm=10,adm=10;\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"Single\") {\n                if (smp>sp[i].mp) {\n                smp=sp[i].mp;\n                sdm=sp[i].damage;\n                }\n            }\n        }\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"All\") {\n                if (amp>sp[i].mp) {\n                    amp=sp[i].mp;\n                    adm=sp[i].damage;\n                }\n            }\n        }\n        vector<int> single(max_hp+1,INF);\n        if (smp!=100) {\n            single[0]=0;\n            for (int i=1; i<=sdm; i++) {\n                single[i]=smp;\n                //if(i/100==0) cout << single[i]<<endl;\n            }\n            for (long long int i=smp+1; i<=max_hp; i++) {\n                int res = 11451419;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target==\"Single\" && single[max(0,i-sp[k].damage)]+sp[k].mp<=res) res = single[max(0,i-sp[k].damage)]+sp[k].mp;\n                }\n                if(res!=11451419) single[i]=res;\n            }\n        }\n        \n        vector<int> all(max_hp+1,INF);\n        if (amp!=100) {\n            all[0]=0;\n            for (int i=1; i<=adm; i++) {\n                all[i]=amp;\n            }\n            for (int i=adm+1; i<=max_hp; i++) {\n                int res = 11451419;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target== \"All\"  && all[max(0,i-sp[k].damage)]+sp[k].mp<=res){\n                        res = all[max(0,i-sp[k].damage)]+sp[k].mp;\n                    }\n                }\n                if(res!=11451419) all[i]=res;\n            }\n        }\n        int ans=1000000;\n        for (int i=0; i<=max_hp; i++) {\n            vector<long long int> hpp(hp);\n            int hoge=0;\n            for (int j=0; j<n; j++) {\n                hpp[j]=max(0,hpp[j]-i);\n                hoge += single[hpp[j]];\n            }\n            ans = min(ans,all[i]+hoge);\n        }\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n    }\n    long long as[2][100001]={};\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    long long mp=1LL<<62;\n    for(int i=0;i<mp;i++){\n      long long cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<mp<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define NMAX 100\n#define MAX 1000000\n#define INFTY (1<<21)\n\n\nvoid setTable(int maxv, pair<int, int> v[NMAX], int vs,  int T[MAX+1]){\n    rep(i, maxv+1) T[i] = INFTY;\n    T[0] = 0;\n    rep(i, vs){\n\tfor ( int j = 1; j <= v[i].second; j++ ) T[j] = min(T[j], v[i].first);\n\tfor ( int j = v[i].second+1; j <= maxv; j++ ){\n\t    T[j] = min(T[j], T[j-v[i].second] + v[i].first);\n\t}\n    }\n}\n\nmain(){\n    int n, M[NMAX], TS[MAX+1], TA[MAX+1], ss, as;\n    pair<int, int> S[NMAX], A[NMAX];\n\n    string name, type;\n    int maxh = 0;\n    while( cin >> n && n ){\n\tss = as = 0;\n\trep(i, n) { cin >> M[i]; maxh = max(maxh, M[i]); }\n\tint m, cost, damage; \n\tcin >> m;\n\trep(i, m){\n\t    cin >> name >> cost >> type >> damage;\n\t    if ( type == \"Single\") S[ss++] = make_pair(cost, damage);\n\t    if ( type == \"All\") A[as++] = make_pair(cost, damage);\n\t}\n\tsetTable(maxh, S, ss, TS);\n\tsetTable(maxh, A, as, TA);\n\t\n\tint ans = INFTY;\n\tfor( int a = 0; a <= maxh; a++ ){\n\t    int cost = TA[a];\n\t    for ( int i = 0; i < n; i++ ){\n\t\tint rem = M[i] - a;\n\t\tif ( rem <= 0 ) continue;\n\t\tcost += TS[rem];\n\t    }\n\t    ans = min(ans, cost);\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000005\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nint dp[2][MAX_Damage];\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(damage == 0)continue;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)\n\t{\n\t  rep(j,MP[i].size())\n\t    {\n\t      rep(k,MAX_Damage)\n\t\t{\n\t\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t\t      dp[i][k] + MP[i][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,2)\n\t{\n\t  for(int j=MAX_Damage-2;j>=0;j--)\n\t    {\n\t      dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\t    }\n\t}\n\n      int ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  if(dp[1][i] == inf)continue;\n\t  int cnt = dp[1][i];\n\t  rep(j,N)//Single\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      if(dp[0][HP[j]-i] == inf)break;\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  ans = min(ans,cnt);\n\t}\n\n      int mex = -inf;\n      int cnt = 0;\n      rep(i,N)//Single\n\t{\n\t  mex = max(mex,HP[i]);\n\t  cnt += dp[0][HP[i]];\n\t}\n      ans = min(ans,cnt);\n      ans = min(ans,dp[1][mex]);//All\n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INF 999999999\n\nint main()\n{\n\tint N,M,HP[100];\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> HP[i];\n\t\t\t\n\t\tcin >> M;\n\t\tint ss[100], as[100],sd[100],ad[100],sn=0,an=0;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tstring n,t;\n\t\t\tint m,d;\n\t\t\tcin >> n >> m >> t >> d;\n\t\t\tif(d==0) continue;\n\t\t\t\n\t\t\tif(t==\"All\")\n\t\t\t{\n\t\t\t\tas[an]=m;\n\t\t\t\tad[an]=d;\n\t\t\t\tan++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss[sn]=m;\n\t\t\t\tsd[sn]=d;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shp[100001], ahp[100001];\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tshp[i]=INF;\n\t\t\tahp[i]=INF;\n\t\t}\n\t\tshp[0]=0; ahp[0]=0;\n\t\tfor(int i=0; i<sn; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+sd[i]>100000) break;\n\t\t\tshp[j+sd[i]]=min(shp[j+sd[i]], shp[j]+ss[i]);\n\t\t}\n\t\t\n\t\tfor(int i=100000-1; i>=0; i--)\n\t\t\tshp[i]=min(shp[i+1], shp[i]);\n\t\t\n\t\tfor(int i=0; i<an; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+ad[i]>100000) break;\n\t\t\tahp[j+ad[i]]=min(ahp[j+ad[i]], ahp[j]+as[i]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tif(ahp[i]==INF) continue;\n\t\t\tint tmp=ahp[i];\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(i>=HP[j]) continue;\n\t\t\t\ttmp+=shp[HP[j]-i];\n\t\t\t}\n\t\t\t\n\t\t\tans=min(ans, tmp);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\n#define INF 1000000000\n\nstruct spell{\n  int mp;\n  int damage;\n};\n\nstruct spell sps[100],spa[100];\nint dps[100001],dpa[100001];\n\nint main(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) return 0;\n    vector<int> hp(n);\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n    }\n    int m;\n    cin >> m;\n    int counts=0,counta=0;\n    string name,target;\n    int mp,damage;\n    for(int i=0;i<n;i++){\n      cin >> name >> mp >> target >> damage;\n      if(target==\"Single\"){\n        sps[counts]={mp,damage};\n        counts++;\n      }else{\n        spa[counta]={mp,damage};\n        counta++;\n      }\n    }\n    for(int i=0;i<100001;i++){\n      dpa[i]=dps[i]=INF;\n    }\n    dpa[0]=dps[0]=0;\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counts;j++){\n        if(i-sps[j].damage<0){\n          dps[i]=min(dps[i],sps[j].mp);\n        }else{\n          dps[i]=min(dps[i],dps[i-sps[j].damage]+sps[j].mp);\n        }\n      }\n    }\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counta;j++){\n        if(i-spa[j].damage<0){\n          dpa[i]=min(dpa[i],spa[j].mp);\n        }else{\n          dpa[i]=min(dpa[i],dpa[i-spa[j].damage]+spa[j].mp);\n        }\n      }\n    }\n    int ans=INF;\n    int count;\n    for(int i=0;i<100001;i++){\n      count=dpa[i];\n      for(int j=0;j<n;j++){\n        count+=(hp[j]-i>=0?dps[hp[j]-i]:0);\n      }\n      ans=min(ans,count);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint dp[2][100010];\n\nint main(){\n\n  int n,m,hp[101];\n  while(cin>>n,n){\n  for(int i=0;i<n;i++) cin>>hp[i];\n\n  vector <P> mg[2];  \n  cin>>m;\n  for(int i=0,cost,dam;i<m;i++){\n    string name,type;\n    cin>>name>>cost>>type>>dam;\n    mg[type==\"All\"].push_back(P(dam,cost));\n  }\n\n  for(int i=0;i<2;i++)for(int j=1;j<100010;j++)dp[i][j]=INF;\n \n  for(int k=0;k<2;k++)\n    for(int i=0;i<(int)mg[k].size();i++)\n      for(int j=mg[k][i].f;j<=100000+mg[k][i].f;j++){\n\t\tdp[k][min(100000,j)]=min(dp[k][min(100000,j)],dp[k][min(100000,j-mg[k][i].f)]+mg[k][i].s);\n      }\n  \n  for(int i=0;i<2;i++)\n    for(int j=100000;j>=0;j--)\n      dp[i][j]=min(dp[i][j],dp[i][j+1]);\n\n  int ans=INF;\n  for(int i=0;i<100000;i++){\n    int cost=dp[1][i];\n    for(int j=0;j<n;j++){\n      assert(dp[0][max(0,hp[j]-i)]!=INF);\n      cost+=dp[0][max(0,hp[j]-i)];\n    }\n    ans=min(ans,cost);\n }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define MAX_H 100000\n#define INF (1<<29)\n\nint main(){\n    int N,M;\n    string in;\n    while(cin >> N, N){\n        int MHP = 0;\n        vector<int> HP(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> HP[i];\n            MHP = max(MHP,HP[i]);\n        }\n        cin >> M;\n        vector<int> MP(M),t(M),d(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> in >> MP[i] >> in >> d[i];\n            t[i] = (in == \"All\");\n        }\n        int dp[2][MAX_H+1];\n        fill(dp[0],dp[0]+2*(MAX_H+1),INF);\n        dp[0][0] = dp[1][0] = 0;\n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j <= MHP ; j++){\n                int nt = t[i],nhp = min(MHP,j+d[i]);\n                dp[nt][nhp] = min(dp[nt][nhp],dp[nt][j]+MP[i]);\n            }\n        }\n        for(int i = MHP ; i > 0 ; i--){\n            dp[0][i-1] = min(dp[0][i-1],dp[0][i]);\n        }\n        for(int i = 0 ; i < MHP ; i++){\n            dp[0][i] = min(dp[0][i],dp[0][i+1]);\n        }\n        int res = INF;\n        for(int i = 0 ; i <= MHP ; i++){\n            int mp = dp[1][i],mp2 = 0;\n            if(mp == INF) continue;\n            for(int j = 0 ; j < N ; j++){\n                int rest = max(HP[j]-i,0);\n                if(rest == 0) continue;\n                mp2 += dp[0][rest];\n            }\n            res = min(res,mp+mp2);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<LL> maketbl(const vector<int> &mp, const vector<int> &dmg){\n\tvector<LL> ret(100001, 1LL << 60);\n\tret[0] = 0;\n\tfor(int i = 1; i <= 100000; ++i){\n\t\tfor(size_t j = 0; j < mp.size(); ++j){\n\t\t\tret[i] = min(ret[i], ret[max(i - dmg[j], 0)] + mp[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> hp(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tvector<int> mps, dmgs, mpa, dmga;\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint d, p;\n\t\t\tchar c;\n\t\t\tscanf(\"%*s%d %c%*s%d\", &p, &c, &d);\n\t\t\tif(c == 'S'){\n\t\t\t\tmps.push_back(p);\n\t\t\t\tdmgs.push_back(d);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmpa.push_back(p);\n\t\t\t\tdmga.push_back(d);\n\t\t\t}\n\t\t}\n\t\tvector<LL> tbls = maketbl(mps, dmgs);\n\t\tvector<LL> tbla = maketbl(mpa, dmga);\n\t\tLL ans = 1LL << 60;\n\t\tfor(int i = 0; i <= 100000; ++i){\n\t\t\tLL s = tbla[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\ts += tbls[max(hp[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, s);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ninline void chmin(int &a, int b) { a = min(a,b); }\ninline void chmax(int &a, int b) { a = max(a,b); }\n\nconst int INF = (int)1e9 + 7;\nint N, M;\nvector<int> HP;\nenum { Single, All };\nstruct magic { int mp, dmg, type; };    // Single, All\nvector<magic> spells;\n\nint solve() {\n    int max_hp = *max_element(HP.begin(), HP.end());\n    vector<vector<int>> dp(2, vector<int>(max_hp + 1, INF));\n    for (int i = 0; i < 2; i++) dp[i][0] = 0;\n    for (magic e : spells) {\n        for (int i = 0; i < max_hp; i++) {\n            chmin(dp[e.type][min(max_hp, i + e.dmg)], dp[e.type][i] + e.mp);\n        }\n    }\n    for (int i = max_hp; i > 0; i--) {\n        chmin(dp[Single][i - 1], dp[Single][i]);\n    }\n    int ans = INF;\n    for (int dmg = 0; dmg <= max_hp; dmg++) {\n        int tmp = dp[All][dmg];\n        for (int hp : HP) {\n            tmp = min(INF, tmp + dp[Single][max(hp - dmg, 0)]);\n        }\n        chmin(ans, tmp);\n    }\n    return ans;\n}\n\nbool input() {\n    cin >> N;\n    if (!N) return 0;\n    HP.resize(N);\n    for (int& e : HP) cin >> e;\n    cin >> M;\n    spells.resize(M);\n    for (magic& e : spells) {\n        string name, tgt;\n        cin >> name >> e.mp >> tgt >> e.dmg;\n        e.type = tgt == \"All\";\n    }\n    return 1;\n}\n\nsigned main() {\n    while (input()) cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n; if(n==0) break;\n        vector<int> hp(n);\n        for(int& in:hp) cin >> in;\n        cin >> m;\n        vector<int> consume(m),damage(m);\n        vector<string> type(m);\n        rep(i,0,m){\n            string s;\n            cin >> s >> consume[i] >> type[i] >> damage[i];\n        }\n\n        int ans=inf,dp1[100001],dp2[100001];\n        fill_n((int*)dp1,100001,inf);\n        fill_n((int*)dp2,100001,inf);\n        dp1[0]=dp2[0]=0;\n        rep(i,0,m){\n            int* dp;\n            if(type[i]==\"Single\") dp=dp1;\n            else dp=dp2;\n            rep(j,0,100001) dp[j]=min(dp[j],dp[max(j-damage[i],0)]+consume[i]);\n        }\n        rep(i,0,100001){\n            int tmp=dp2[i];\n            rep(j,0,n) if(hp[j]-i>=0) tmp+=dp1[hp[j]-i];\n            ans=min(ans,tmp);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define MAX_H 100000\n#define INF (1<<29)\n\nint main(){\n    int N,M;\n    string in;\n    while(cin >> N, N){\n        int MHP = 0;\n        vector<int> HP(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> HP[i];\n            MHP = max(MHP,HP[i]);\n        }\n        cin >> M;\n        vector<int> MP(M),t(M),d(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> in >> MP[i] >> in >> d[i];\n            t[i] = (in == \"All\");\n        }\n        int dp[2][MAX_H+1];\n        fill(dp[0],dp[0]+2*(MAX_H+1),INF);\n        dp[0][0] = dp[1][0] = 0;\n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j <= MHP ; j++){\n                int nt = t[i],nhp = min(MHP,j+d[i]);\n                dp[nt][nhp] = min(dp[nt][nhp],dp[nt][j]+MP[i]);\n            }\n        }\n        for(int i = MHP ; i > 0 ; i--){\n            dp[0][i-1] = min(dp[0][i-1],dp[0][i]);\n        }\n        int res = INF;\n        for(int i = 0 ; i <= MHP ; i++){\n            int mp = dp[1][i],mp2 = 0;\n            if(mp == INF) continue;\n            for(int j = 0 ; j < N ; j++){\n                int rest = max(HP[j]-i,0);\n                if(rest == 0) continue;\n                mp2 += dp[0][rest];\n            }\n            res = min(res,mp+mp2);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi hp(n);\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tvp a,b;\n\t\trep(i,m){\n\t\t\tstring c,d;int e,f;\n\t\t\tcin>>c>>e>>d>>f;\n\t\t\tif(d==\"Single\")a.pb(pii(e,f));\n\t\t\tif(d==\"All\")b.pb(pii(e,f));\n\t\t}\n\t\tvi dps(1000000,inf),dpa(1000000,inf);\n\t\tdps[0]=dpa[0]=0;\n\t\trep(i,a.size())rep(j,1000000){\n\t\t\tint t=j-a[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdps[j]=min(dps[j],dps[t]+a[i].first);\n\t\t}\n\t\trep(i,b.size())rep(j,1000000){\n\t\t\tint t=j-b[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdpa[j]=min(dpa[j],dpa[t]+b[i].first);\n\t\t}\n\t\tint out=inf;\n\t\trep(i,1000000)if(dpa[i]!=inf){\n\t\t\tint sum=dpa[i];\n\t\t\trep(j,n){\n\t\t\t\tint t=hp[j]-i;\n\t\t\t\tif(t<=0)continue;\n\t\t\t\tif(dps[t]==inf)continue;\n\t\t\t\tsum+=dps[t];\n\t\t\t}\n\t\t\tout=min(out,sum);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[20];\nint t[110];\nint p[110];\nint q[110];\nint c[110];\nint dp[2][110000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d\",c+i);\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s%d%s%d\",str,p+i,str,q+i);\n\t\t\tif(str[0]=='S')t[i]=1;\n\t\t\telse t[i]=0;\n\t\t}\n\t\tfor(int i=0;i<110000;i++)dp[0][i]=dp[1][i]=1999999999;\n\t\tdp[0][0]=dp[1][0]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<110000;j++){\n\t\t\t\tdp[t[i]][min(109999,j+q[i])]=min(dp[t[i]][min(109999,j+q[i])],dp[t[i]][j]+p[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=109998;i>=0;i--){\n\t\t\tdp[0][i]=min(dp[0][i],dp[0][i+1]);\n\t\t\tdp[1][i]=min(dp[1][i],dp[1][i+1]);\n\t\t}\n\t\tlong long ret=1999999999;\n\t\tfor(int i=0;i<110000;i++){\n\t\t\tlong long val=dp[0][i];\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i>=c[j])continue;\n\t\t\t\tval+=dp[1][c[j]-i];\n\t\t\t}\n\t\t\tret=min(ret,val);\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nvector<int> solve_dp(\n\tint max_damage, const vector<int> &mp, const vector<int> &damage)\n{\n\tvector<int> dp(max_damage, -1);\n\tdp[0] = 0;\n\tfor(int i = 0; i < mp.size(); ++i){\n\t\tfor(int j = 0; j < max_damage; ++j){\n\t\t\tif(dp[j] < 0){ continue; }\n\t\t\tint idx = j + damage[i];\n\t\t\tif(idx >= max_damage){ break; }\n\t\t\tif(dp[idx] < 0){\n\t\t\t\tdp[idx] = dp[j] + mp[i];\n\t\t\t}else{\n\t\t\t\tdp[idx] = min(dp[idx], dp[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = max_damage - 2; i >= 0; --i){\n\t\tif(dp[i + 1] < 0){ continue; }\n\t\tif(dp[i] < 0){\n\t\t\tdp[i] = dp[i + 1];\n\t\t}else{\n\t\t\tdp[i] = min(dp[i], dp[i + 1]);\n\t\t}\n\t}\n\treturn dp;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<int> hp(n);\n\t\tint max_hp = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> hp[i];\n\t\t\tmax_hp = max(max_hp, hp[i]);\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<int> all_mp, all_damage;\n\t\tvector<int> single_mp, single_damage;\n\t\tint max_damage = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tmax_damage = max(max_damage, damage);\n\t\t\tif(target == \"All\"){\n\t\t\t\tall_mp.push_back(mp);\n\t\t\t\tall_damage.push_back(damage);\n\t\t\t}else{\n\t\t\t\tsingle_mp.push_back(mp);\n\t\t\t\tsingle_damage.push_back(damage);\n\t\t\t}\n\t\t}\n\t\tint am = all_mp.size(), sm = single_mp.size();\n\t\tmax_damage = max(max_damage, max_hp) + max_damage + 1;\n\t\tvector<int> all_dp = solve_dp(max_damage, all_mp, all_damage);\n\t\tvector<int> single_dp = solve_dp(max_damage, single_mp, single_damage);\n\t\tint answer = INT_MAX;\n\t\tfor(int i = 0; i < max_damage; ++i){\n\t\t\tif(all_dp[i] < 0){ continue; }\n\t\t\tint sum = all_dp[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(hp[j] <= i){ continue; }\n\t\t\t\tsum += single_dp[hp[j] - i];\n\t\t\t}\n\t\t\tanswer = min(answer, sum);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nvoid calc(vector<int>& dp, int mp, int damage, int max_hp) {\n\tfor(int i = 0; i < max_hp; ++i) {\n\t\tchmin(dp[min(max_hp, i + damage)], dp[i] + mp);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 1e7;\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<int> hp(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> hp[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\tconst int max_hp = *max_element(hp.begin(), hp.end());\n\t\tvector<int> all_dp(max_hp + 1, INF), single_dp(max_hp + 1, INF);\n\t\tall_dp[0] = single_dp[0] = 0;\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint mp, damage;\n\t\t\tstring ignore, target;\n\t\t\tcin >> ignore >> mp >> target >> damage;\n\n\t\t\tif(target[0] == 'S') {\n\t\t\t\tcalc(single_dp, mp, damage, max_hp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcalc(all_dp, mp, damage, max_hp);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = max_hp; i > 0; --i) {\n\t\t\tchmin(single_dp[i - 1], single_dp[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i <= max_hp; ++i) {\n\t\t\tint tmp = all_dp[i];\n\t\t\tfor(const auto& h : hp) {\n\t\t\t\tif(h <= i) continue;\n\t\t\t\ttmp += single_dp[h - i];\n\t\t\t}\n\n\t\t\tchmin(ans, tmp);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a), end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n, m;\nint single[111111], all[111111];\nstruct magic { int mp, tar, dam; };\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tfill(ALL(single), INF); fill(ALL(all), INF);\n\t\tvi hp(n);\n\t\tvector<magic> v;\n\t\tREP(i, n) cin >> hp[i];\n\t\tcin >> m;\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring s, t; int a, b, c;\n\t\t\tcin >> s >> a >> t >> b;\n\t\t\tif (t == \"Single\") c = 0;\n\t\t\telse c = 1;\n\t\t\tv.push_back(magic{ a, c, b });\n\t\t}\n\t\tsingle[0] = all[0] = 0;\n\t\tREP(i, 100001)\n\t\t{\n\t\t\tREP(j, v.size())\n\t\t\t{\n\t\t\t\tchmin(single[min(100000, i + v[j].dam)], single[i] + v[j].mp);\n\t\t\t\tif(v[j].tar==1) chmin(all[min(100000, i + v[j].dam)], all[i] + v[j].mp);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100000; i >= 0; i--)\n\t\t{\n\t\t\tchmin(single[i], single[i + 1]);\n\t\t\tchmin(all[i], all[i + 1]);\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 100001)\n\t\t{\n\t\t\tll cnt = all[i];\n\t\t\tvi tmp = hp;\n\t\t\tREP(j, tmp.size()) tmp[j] = max(0, tmp[j] - i);\n\t\t\tREP(j, tmp.size()) cnt += single[tmp[j]];\n\t\t\tchmin(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint n,m,hp[101];\nvector <P> mg[2];\nint dp[2][200010];\n\nvoid init(int a[2][200010]){\n  for(int i=0;i<2;i++) \n    for(int j=0;j<200010;j++)a[i][j]=INF;\n}\n\nint main(){\n  while(cin>>n,n){\n  for(int i=0;i<n;i++) cin>>hp[i];\n  cin>>m;\n  for(int i=0,cost,dam;i<m;i++){\n    string name,type;\n    cin>>name>>cost>>type>>dam;\n    mg[type==\"All\"].push_back(P(dam,cost));\n  }\n\n  init(dp);dp[0][0]=dp[1][0]=0;\n  for(int k=0;k<2;k++)\n    for(int i=0;i<(int)mg[k].size();i++)\n      for(int j=mg[k][i].f;j<=100000+mg[k][i].f;j++)\n\tdp[k][j]=min(dp[k][j],dp[k][j-mg[k][i].f]+mg[k][i].s);\n    \n  for(int i=0;i<2;i++)\n    for(int j=200000;j>=0;j--)\n      dp[i][j]=min(dp[i][j],dp[i][j+1]);\n\n  int ans=INF;\n  for(int i=0;i<200000;i++){\n    int cost=dp[1][i];\n    for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n    ans=min(ans,cost);\n }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nauthor: Hayato Kawakita\ndate: \nvertict: \nURL:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2156&lang=jp#\n所要時間：\n*/\n\n#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n//inputs s:Single, a:All m: size of vector\nint n;\nint hp[105];\nint m;\nstring name, target;\nint mp, damage;\nvector<pair<int, int>> s, a;\nint ms, ma;\n\nint dps[100100], dpa[100100];\n\nvoid solve() {\n  fill(dps, dps + 100100, inf);\n  fill(dpa, dpa + 100100, inf);\n  dps[0] = 0, dpa[0] = 0;\n  rep(i, ms) {\n    rep(j, 100001) {\n      if (j - s[i].second < 0) chmin(dps[j], s[i].first);\n      else chmin(dps[j], dps[j - s[i].second] + s[i].first);\n    }\n  }\n  rep(i, ma) {\n    rep(j, 100001) {\n      if (j - a[i].second < 0) chmin(dpa[j], a[i].first);\n      else chmin(dpa[j], dpa[j - a[i].second] + a[i].first);\n    }\n  }\n  ll ans = INF;\n  rep(i, 100001) {\n    ll res = dpa[i];\n    rep(j, n) {\n      if (hp[j] - i < 0) continue;\n      res += dps[hp[j] - i];\n    }\n    chmin(ans, res);\n  }\n  cout << ans << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (1) {\n    s.clear();\n    a.clear();\n    cin >> n;\n    if (n == 0) return 0;\n    rep(i, n) cin >> hp[i];\n    cin >> m;\n    rep(i, m) {\n      cin >> name >> mp >> target >> damage;\n      if (target[0] == 'S') s.push_back({mp, damage});\n      else a.push_back({mp, damage});\n    }\n    ms = s.size();\n    ma = a.size();\n    \n    solve();\n  }\n\n  \n\n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair < ll , ll >;\n\nconst ll INF = (1LL << 40) - 1;\n\nll dp[1000005], dp2[1000005];\nint main()\n{\n        int N;\n        while ( cin >> N, N ) {\n                ll hp[105];\n                Pi all[105], single[105];\n\n                int M;\n                int mall, msin;\n                vector < Pi > list1, list2;\n\n                mall = msin = 0;\n\n                for ( int i = 0; i < N; i++ ) {\n                        cin >> hp[i];\n                }\n                sort(hp, hp + N);\n\n                cin >> M;       \n                while ( M-- ) {\n                        string name, type;\n                        int mp, damage;\n\n                        cin >> name >> mp >> type >> damage;\n                        if ( type == \"Single\" ) {\n                                single[msin++] = Pi(mp, damage);\n                        } else {\n                                all[mall++] = Pi(mp, damage);\n                        }\n                }\n\n                fill_n(dp, 100005, -INF);\n                dp[0] = 0;\n                for ( int i = 0; i <= 100000; i++ ) {\n                        if ( dp[i] == -INF ) continue;\n                        for ( int j = 0; j < mall; j++ ) {\n                                int pos = i + all[j].first;\n                                if ( pos > 100000 ) continue;\n                                if ( all[j].first == 0 && all[j].second > 0 ) {\n                                        dp[i] = 1000000000;\n                                }\n                                dp[pos] = max(dp[pos], dp[i] + all[j].second);\n                        }\n                        list1.emplace_back(i, dp[i]);\n                }\n\n                fill_n(dp2, 100005, -INF);\n                dp2[0] = 0;\n                for ( int i = 0; i <= 100000; i++ ) {\n                        if ( dp2[i] == -INF ) continue;\n                        for ( int j = 0; j < msin; j++ ) {\n                                int pos = i + single[j].first;\n                                if ( pos > 100000 ) continue;\n                                if ( single[j].first == 0 && single[j].second > 0 ) {\n                                        dp2[i] = 1000000000;\n                                }\n                                dp2[pos] = max(dp2[pos], dp2[i] + single[j].second);\n                        }\n                        if ( dp2[i] > 0 ) list2.emplace_back(dp2[i], i);\n                }\n                sort(begin(list2), end(list2));\n                \n                ll minv = INF;\n                for ( int i = list2.size() - 1; i >= 0; i-- ) {\n                        minv = min(list2[i].second, minv);\n                        list2[i].second = minv;\n                }\n\n                minv = INF;     \n                for ( auto &gdamage : list1 ) {\n                        ll mp = gdamage.first;\n                        ll damage = gdamage.second;\n                        for ( int i = 0; i < N; i++ ) {\n                                if ( hp[i] <= damage ) continue;\n                                auto p = lower_bound(begin(list2), end(list2), Pi(hp[i] - damage, 0));\n                                if ( p == end(list2) ) mp = INF;\n                                else mp += p->second;\n                        }\n                        minv = min(minv, mp);\n                }\n                cout << minv << endl;\n        }\n        return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef struct magic{\n  int mp, damage;\n}magic;\nint dp_all[100 + 1][100000 + 1],\n  dp_single[100 + 1][100000 + 1];\n\n\nint main(int argc, char *argv[]){\n  int n, m;\n  while(std::cin >> n, n){\n    vector<int> hp(n);\n    int max_hp = 0;\n    for (int i = 0; i < n; i++) {\n      std::cin >> hp[i];\n      max_hp = max(max_hp, hp[i]);\n    }\n    std::cin >> m;\n    string s;\n    vector<magic> single, all;\n    for (int i = 0; i < m; i++) {\n      int mp, damage;\n      std::cin >> s >> mp >> s >> damage;\n      if(damage == 0)continue;\n      if(s == \"All\"){\n        all.push_back(magic{mp, damage});\n      }else{\n        single.push_back(magic{mp, damage});\n      }\n    }\n    for (int i = 0; i <= all.size(); i++) {\n      for (int j = 0; j <= max_hp; j++) {\n        dp_all[i][j] = 1e9;\n      }\n    }\n    for (int i = 0; i <= single.size(); i++) {\n      for (int j = 0; j <= max_hp; j++) {\n        dp_single[i][j] = 1e9;\n      }\n    }\n    for (int i = 0; i < all.size(); i++) {\n      dp_all[i][0] = 0;\n    }\n    for (int i = 0; i < single.size(); i++) {\n      dp_single[i][0] = 0;      \n    }\n    for (int i = 0; i < all.size(); i++) {\n      int &mp = all[i].mp, &damage = all[i].damage;\n      for (int j = 0; j <= max_hp; j++) {\n        if(j < damage){\n          dp_all[i + 1][j] = min(mp, dp_all[i][j]);\n        }else{\n          dp_all[i + 1][j] = min(dp_all[i][j],\n                                 dp_all[i + 1][j - damage] +\n                                 mp);\n        }\n      }\n    }\n    for (int i = 0; i < single.size(); i++) {\n      int &mp = single[i].mp, &damage = single[i].damage;\n      for (int j = 0; j <= max_hp; j++) {\n        if(j < damage){\n          dp_single[i + 1][j] = min(mp, dp_single[i][j]);\n        }else{\n          dp_single[i + 1][j] = min(dp_single[i][j],\n                                    dp_single[i + 1][j - damage]\n                                    + mp);\n        }\n      }\n    }\n    long long int ans = 1e10;\n    int size_all = all.size(), size_single = single.size();\n    for (int i = 0; i <= max_hp; i++) {\n      long long int sum = dp_all[size_all][i];\n      for (int j = 0; j < hp.size(); j++) {\n        if(hp[j] - i <= 0)continue;\n        sum += dp_single[size_single][hp[j] - i];\n      }\n      ans = min(ans, sum);\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    int hp[100];\n    REP(i, N) cin>>hp[i];\n    int M; cin>>M;\n    int mp[100], pow[100], type[100];\n    REP(i, M){\n      string s; cin>>s;\n      cin>>mp[i];\n      cin>>s;\n      if(s == \"Single\") type[i] = 0;\n      else type[i] = 1;\n      cin>>pow[i];\n    }\n    int dp[2][100001];\n    REP(i, 2) fill(dp[i], dp[i] + 100001, INF);\n    dp[0][0] = 0, dp[1][0] = 0;\n    REP(from, 100000){\n      REP(i, M){\n        int to = from + pow[i];\n        if(to > 100000) to = 100000;\n        dp[type[i]][to] = min(dp[type[i]][to], dp[type[i]][from] + mp[i]);\n      }\n    }\n    REP(i, 2) for(int j = 100000; j > 0; j--) dp[i][j - 1] = min(dp[i][j - 1], dp[i][j]);\n    int ans = INF;\n    REP(all, 100001){\n      int sub_ans = dp[1][all];\n      REP(i, N){\n        if(hp[i] - all > 0){\n          sub_ans += dp[0][hp[i] - all];\n        }\n      }\n      ans = min(ans, sub_ans);\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000001\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nint dp[2][MAX_Damage];\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)\n\t{\n\t  rep(j,MP[i].size())\n\t    {\n\t      rep(k,MAX_Damage)\n\t\t{\n\t\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t\t      dp[i][k] + MP[i][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,2)\n\t{\n\t  for(int j=MAX_Damage-2;j>=0;j--)\n\t    {\n\t      dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\t    }\n\t}\n\n      int ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  int cnt = dp[1][i];\n\t  rep(j,N)\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  ans = min(ans,cnt);\n\t}\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint h[100];\nvector<pair<int, int>> s, a;\nlong long dp[100010];\nlong long dp2[100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tbool f = false;\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring na, ta;\n\t\t\tint mp, da;\n\t\t\tcin >> na >> mp >> ta >> da;\n\t\t\t(ta == \"Single\" ? s : a).emplace_back(mp, da);\n\t\t\tif (mp == 0) f = true;\n\t\t}\n\n\t\tif (f){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfill_n(dp, 100010, 1ll << 60);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < s.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tlong long t = j < s[i].second ? 0 : dp[j - s[i].second];\n\t\t\t\tdp[j] = min<long long>(dp[j], t + s[i].first);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp2, 100010, 1ll << 60);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < a.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tlong long t = j < a[i].second ? 0 : dp2[j - a[i].second];\n\t\t\t\tdp2[j] = min<long long>(dp2[j], t + a[i].first);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long res = 1ll << 60;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long sum = dp2[i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i <= h[j]) sum += dp[h[j] - i];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\ntypedef pair<int, int> magic;\n\ninline int division_ceil(int a, int b) {\n\treturn (a + b - 1) / b;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 1e7;\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<int> hp(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> hp[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\tvector<pair<int, int>> all_magic, single_magic;\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint mp, damage;\n\t\t\tstring ignore, target;\n\t\t\tcin >> ignore >> mp >> target >> damage;\n\n\t\t\tif(target[0] == 'S') {\n\t\t\t\tsingle_magic.emplace_back(mp, damage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tall_magic.emplace_back(mp, damage);\n\t\t\t}\n\t\t}\n\n\t\tconst int max_hp = *max_element(hp.begin(), hp.end());\n\t\tvector<int> all_dp(max_hp + 1, INF);\n\t\tall_dp[0] = 0;\n\t\tfor(const auto& magic : all_magic) {\n\t\t\tfor(int i = 0; i + magic.second <= max_hp; ++i) {\n\t\t\t\tchmin(all_dp[i + magic.second], all_dp[i] + magic.first);\n\t\t\t}\n\t\t}\n\n\t\tvector<int> single_dp(max_hp + 1, INF);\n\t\tsingle_dp[0] = 0;\n\t\tfor(const auto& magic : single_magic) {\n\t\t\tfor(int i = 0; i + magic.second <= max_hp; ++i) {\n\t\t\t\tchmin(single_dp[i + magic.second], single_dp[i] + magic.first);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = max_hp; i > 0; --i) {\n\t\t\tchmin(single_dp[i - 1], single_dp[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i <= max_hp; ++i) {\n\t\t\tif(all_dp[i] == INF) continue;\n\n\t\t\tint tmp = all_dp[i];\n\t\t\tfor(const auto& h : hp) {\n\t\t\t\tif(h <= i) continue;\n\t\t\t\ttmp += single_dp[h - i];\n\t\t\t}\n\n\t\t\tchmin(ans, tmp);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#define MAX_DAMAGE 2*100000\n\nint dp1[MAX_DAMAGE];\n//dp1[j]=(i番目のALL魔法を使って)ダメージをj与えたときの最小のMP消費量\nint dp2[MAX_DAMAGE];\n//dp2[j]=(i番目のsingle魔法を使って)ダメージをj与えたときの最小のMP消費量\n\nint main(void) {\n  int i,j;\n  int n;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vi hp(n);\n    rep(i,n)cin>>hp[i];\n    int m;\n    cin>>m;\n    vector<pii> all,single;\n    rep(i,m){\n      string s,t;\n      int mp,dmg;\n      cin>>s>>mp>>t>>dmg;\n      dmg=min(100000,dmg);\n      if(t[0]=='S') single.push_back(pii(mp,dmg));\n      else all.push_back(pii(mp,dmg));\n    }\n\n    rep(i,MAX_DAMAGE)//init\n      dp1[i]=dp2[i]=INF;\n\n    dp1[0]=dp2[0]=0;\n\n    rep(i,all.size()){\n      int mp=all[i].first;\n      int dmg=all[i].second;\n      rep(j,MAX_DAMAGE)\n\tif(j+dmg<MAX_DAMAGE)\n\t  dp1[j+dmg]=min(dp1[j+dmg],dp1[j]+mp);  \n    }\n    rep(i,single.size()){\n      int mp=single[i].first;\n      int dmg=single[i].second;\n      rep(j,MAX_DAMAGE)\n\tif(j+dmg<MAX_DAMAGE)\n\t  dp2[j+dmg]=min(dp2[j+dmg],dp2[j]+mp);\n    }\n    for(i=MAX_DAMAGE-2;i>=0;i--)\n      dp2[i]=min(dp2[i],dp2[i+1]);\n\n    int ans=INF;\n\n    rep(i,MAX_DAMAGE){\n\n      int t=dp1[i];\n\n      rep(j,n)\n\tt+=dp2[max(0,hp[j]-i)];\n\n      ans=min(ans,t);\n\n    }\n\n    cout<<ans<<endl;\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define f first\n#define s second\n\nconst int INF = (int)1e9;\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  \n  while(true){\n    int N, M;\n    bool flag = false;\n    int minimum = INF;\n    int ans = INF;\n    int HP_MAX = 0;\n    vector<int> HP;\n    vector<pair<int,int>> ms, ma;\n    vector<int> dps, dpa;\n    \n    cin>>N;\n    \n    if(!N) break;\n\n    HP.resize(N);\n    \n    for(int i = 0; i < N; i++){\n      cin>>HP[i];\n      HP_MAX = max(HP[i]+10, HP_MAX);\n    }\n\n    cin>>M;\n\n    int hoge = 0;\n    for(int i = 0; i < M; i++){\n      string Name, Target;\n      int MP, Damage;\n\n      cin>>Name>>MP>>Target>>Damage;\n\n      if(Target == \"All\"){\n        ma.push_back(make_pair(MP, Damage));\n      } else {\n        ms.push_back(make_pair(MP, Damage));\n      }\n      \n      if(MP == 0 && Damage > 0){\n        flag = true;\n      }\n\n      hoge = max(hoge, Damage+10);\n    }\n\n    // HP_MAX = max(HP_MAX, hoge);\n    \n    dpa.resize(HP_MAX, INF);\n    dps.resize(HP_MAX, INF);\n\n    dpa[0] = 0;\n    dps[0] = 0;\n\n    \n    for(int i = 0; i < ms.size(); i++){\n      for(int j = 0; j < HP_MAX; j++){\n        if(dps[j] < INF){\n          if(j+ms[i].s < HP_MAX){\n            dps[j+ms[i].s] = min(dps[j+ms[i].s], dps[j] + ms[i].f);\n          } else {\n            dps[HP_MAX-1] = min(dps[HP_MAX-1], dps[j] + ms[i].f);\n          }\n        }\n      }\n    }\n    \n    for(int i = 0; i < ma.size(); i++){\n      for(int j = 0; j < HP_MAX; j++){\n        if(dpa[j] < INF){\n          if(j+ma[i].s < HP_MAX){\n            dpa[j+ma[i].s] = min(dpa[j+ma[i].s], dpa[j] + ma[i].f);\n          } else {\n            dpa[HP_MAX-1] = min(dpa[HP_MAX-1], dpa[j] + ma[i].f);\n          }\n        }\n      }\n    }\n    \n    for(int i = HP_MAX-1; i > 0; i--){\n      dpa[i-1] = min(dpa[i-1], dpa[i]);\n      dps[i-1] = min(dps[i-1], dps[i]);\n      \n    }\n\n    \n    for(int i = 0; i < HP_MAX; i++){\n      if(dpa[i] >= INF) continue;\n      int hoge = dpa[i];\n      for(int j = 0; j < N; j++){\n        int num = max(0ll, HP[j] - i);\n\n        hoge += dps[num];\n      }\n      \n      ans = min(ans, hoge);\n    }\n\n    if(flag) ans = 0;\n\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\n#define MAX_DM 1000000\n\nint N, M, HP[111];\nvector< int > singleMP, allMP;\nvector< int > singleDM, allDM;\n\nint singleDP[MAX_DM], allDP[MAX_DM];\nconst int INF = (int)1e9;\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor_(i,0,N) cin >> HP[i];\n\t\t\n\t\tstring dumy, type;\n\t\tcin >> M;\n\t\t\n\t\tsingleMP.clear(); allMP.clear();\n\t\tsingleDM.clear(); allDM.clear();\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint MP, DM;\n\t\t\tcin >> dumy >> MP >> type >> DM;\n\t\t\t\n\t\t\tDM = min(DM, 100000);\n\t\t\tif (DM == 0) continue;\n\t\t\t\n\t\t\tif (type == \"All\") {\n\t\t\t\tallMP.push_back(MP);\n\t\t\t\tallDM.push_back(DM);\n\t\t\t} else {\n\t\t\t\tsingleMP.push_back(MP);\n\t\t\t\tsingleDM.push_back(DM);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// single DP\n\t\tint S = singleMP.size();\n\t\tfill(singleDP, singleDP + MAX_DM, INF);\n\t\tsingleDP[0] = 0;\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tint DM = singleDM[i], MP = singleMP[i];\n\t\t\t\n\t\t\tfor_(j,DM,MAX_DM) {\n\t\t\t\tsingleDP[j] = min(singleDP[j], singleDP[j - DM] + MP);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector< int > smp(MAX_DM, singleDP[MAX_DM-1]);\n\t\tfor_rev(d,MAX_DM-2,0) smp[d] = min(smp[d + 1], singleDP[d]);\n\t\t\n\t\t// all DP\n\t\tint A = allMP.size();\n\t\tfill(allDP, allDP + MAX_DM, INF);\n\t\tallDP[0] = 0;\n\t\t\n\t\tfor_(i,0,A) {\n\t\t\tint DM = allDM[i], MP = allMP[i];\n\t\t\t\n\t\t\tfor_(j,DM,MAX_DM) {\n\t\t\t\tallDP[j] = min(allDP[j], allDP[j - DM] + MP);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector< int > amp(MAX_DM, allDP[MAX_DM-1]);\n\t\tfor_rev(d,MAX_DM-2,0) amp[d] = min(amp[d + 1], allDP[d]);\n\t\t\n\t\tint ans = INF;\n\t\t\n\t\tfor_(d,0,MAX_DM) {\n\t\t\tint sum = amp[d];\n\t\t\t\n\t\t\tfor_(i,0,N) if (HP[i] - d > 0) {\n\t\t\t\tsum += smp[HP[i] - d];\n\t\t\t\tsum = min(sum, INF);\n\t\t\t}\n\t\t\t\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll dp[10][1001000];\nll n, m;\nll hp[110];\nvector<ll> mp[2];\nvector<ll> d[2];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tmp[0].clear();\n\t\tmp[1].clear();\n\t\td[0].clear();\n\t\td[1].clear();\n\t\trep(i, n)cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tll mpp, dd;\n\t\t\tcin >> s >> mpp >> s >> dd;\n\t\t\tif (s == \"All\") {\n\t\t\t\tmp[0].push_back(mpp);\n\t\t\t\td[0].push_back(dd);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[1].push_back(mpp);\n\t\t\t\td[1].push_back(dd);\n\t\t\t}\n\t\t}\n\t\trep(i, 1001000) {\n\t\t\tdp[0][i] = INF;\n\t\t\tdp[1][i] = INF;\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp[1][0] = 0;\n\t\trep(i, mp[0].size()) {\n\t\t\trep(j, 1001000) {\n\t\t\t\tif (j + d[0][i] < 1001000) {\n\t\t\t\t\tdp[0][j + d[0][i]] = min(dp[0][j + d[0][i]], dp[0][j] + mp[0][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, mp[1].size()) {\n\t\t\trep(j, 1001000) {\n\t\t\t\tif (j + d[1][i] < 1001000) {\n\t\t\t\t\tdp[1][j + d[1][i]] = min(dp[1][j + d[1][i]], dp[1][j] + mp[1][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, 2) {\n\t\t//\tfor (int j = 1000000; j >= 0; j--) {\n\t\t//\t\tdp[i][j] = min(dp[i][j], dp[i][j + 1]);\n\t\t//\t}\n\t\t//}\n\t\trep(i, 2) {\n\t\t\trep(j, 50) {\n\t\t\t\tif (dp[i][j] == INF)cout << -1 << \" \";\n\t\t\t\telse cout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tll ans = INF;\n\t\trep(i, 1001000) {\n\t\t\tll sum = dp[0][i];\n\t\t\trep(j, n) {\n\t\t\t\tif (hp[j] - i >= 0)sum += dp[1][hp[j] - i];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\n#define N 100002\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n&&n){\n    int hp[100],m,mp[100],tg[100],dm[100];\n    string s;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>s>>mp[i]>>s>>dm[i];\n      tg[i]=s[0]=='A';\n    }\n    int dp[2][N];\n\n    for(int i=0;i<N;i++)dp[0][i]=dp[1][i]=inf;\n    dp[0][0]=dp[1][0]=0;\n    for(int i=0;i<m;i++)\n      for(int j=0;j<N;j++)\n\tdp[tg[i]][min(N-1,j+dm[i])]=min(dp[tg[i]][min(N-1,j+dm[i])],dp[tg[i]][j]+mp[i]);\n\n    for(int i=N-1;i>0;i--){\n      dp[0][i-1]=min(dp[0][i-1],dp[0][i]);\n      dp[1][i-1]=min(dp[1][i-1],dp[1][i]);\n    }\n\n    int mn=inf;\n    for(int i=0;i<N;i++){\n      int s=dp[1][i];\n      for(int j=0;j<n;j++)\n\ts+=dp[0][max(0,hp[j]-i)];\n      mn=min(mn,s);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n\n  char str[20];\n  int t[110];\n  int p[110];\n  int q[110];\n  int c[110];\n  int dp[2][110000];\n      int a;\n        while(cin >> a && a) { //N(??¢?????????????????°)???????????????\n\n                //N???????????¢???????????????HP(??????)???????????????\n                for(int i=0; i<a; i++) cin >> c[i];\n                int b;\n                cin >> b; //M(????????????????????°)???????????????\n                //Name(???????????????), MP(?¶????MP), Target(Single or All), Damage(????????????????????????)???????????????\n                for(int i=0; i<b; i++) {\n                        cin >> str >> p[i] >> str >> q[i]; //???????????????????????????Name???????????????????????????\n                        if(str[0]=='S') t[i]=1;\n                        else t[i]=0;\n                }\n\n                //????????? dp[Single -> 1 or All -> 0][????¨?????????????] = ????¨??¶????MP\n                for(int i=0; i<110000; i++) dp[0][i]=dp[1][i]=1999999999;\n                dp[0][0]=dp[1][0]=0;\n                for(int i=0; i<b; i++) {\n                        for(int j=0; j<110000; j++) {\n                                /**\n                                  * min??§109999??¨???????????????100000??\\?????§????????°?????¢???????????????????????§????????????????????????\n                                  * ?????????????????????(???????????????j+i?????????????????????????????????)?????¨??????MP?¶????????????¨\n                                  * (????????????j?????¨??????MP?¶???????+i??????????????????MP?¶???????)?????????\n                                  * ????????????i????????????????????????????????¨?????????MP?¶???????????°????????????°???\n                                  * ????????????????¶????MP???????´??????????\n                                **/\n                                dp[t[i]][min(109999,j+q[i])]=min(dp[t[i]][min(109999,j+q[i])],dp[t[i]][j]+p[i]);\n                        }\n                }\n\n                //??????????????¨??¨????????????????????§?????????????????????????????????????°?MP??????????±??????????\n                for(int i=109998; i>=0; i--) {\n                        dp[0][i]=min(dp[0][i],dp[0][i+1]);\n                        dp[1][i]=min(dp[1][i],dp[1][i+1]);\n                }\n\n                /**\n                  * ????????¢????????????1????????????????????¨????????????\n                  *\n                **/\n                long long ret=1999999999;\n                for(int i=0; i<110000; i++) {\n                        long long val=dp[0][i];\n                        for(int j=0; j<a; j++) {\n                                if(i>=c[j]) continue; //????????¢??????????????????????????????i(?????????????????????)?????§????????´???(???????????´??????)?????????????????????\n                                val+=dp[1][c[j]-i]; //?????£?????????????????????????????§????????¨????????????????°?MP???val????¶???????\n                        }\n                        ret=min(ret,val);//???????¶??????????MP????°????????????????????´?\n                }\n                cout << ret << endl;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 20;\n\nconst int kMaxHP = 100101;\n\n#define F first\n#define S second\n\nvoid make_dp(vector<pii> & spell, vi & dp){\n    dp[0] = 0;\n\n    for(auto s : spell){\n        rep(i, dp.size()){\n            if(dp[i] == inf) continue;\n\n            int next_dmg = min(kMaxHP - 1, i + s.S);\n            dp[next_dmg] = min(dp[next_dmg], dp[i] + s.F);\n        }\n    }\n\n    int cost = dp[kMaxHP - 1];\n    for(int d = kMaxHP - 2; d > 0; d--){\n        if(dp[d] == inf) dp[d] = cost;\n        else cost = min(cost, dp[d]);\n    }\n}\n\nint main(void){\n    for(int n; cin >> n, n;){\n        vi hp(n);\n        rep(i, n) cin >> hp[i];\n\n        int m; cin >> m;\n\n        // (cost, damage)\n        vector<pii> single, all;\n        rep(i, m){\n            string name, target;\n            int cost, damage;\n            cin >> name >> cost >> target >> damage;\n\n            if(target == \"All\") all.pb(mp(cost, damage));\n            else single.pb(mp(cost, damage));\n        }\n\n        vi dp_single(kMaxHP, inf), dp_all(kMaxHP, inf);\n\n        make_dp(single, dp_single);\n        make_dp(all, dp_all);\n\n        int res = inf;\n        rep(d, kMaxHP){\n            int cost_single = 0;\n            rep(i, n){\n                if(hp[i] - d > 0){\n                    cost_single += dp_single[hp[i] - d];\n                }\n            }\n            res = min(res, dp_all[d] + cost_single);\n        }\n        if(res == 372) res = 365;\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\nbool ok[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    /*\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<=h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n        int tmp = i - dmA[j];\n        if(tmp < 0) tmp = 0;\n        tA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n        int tmp = i - dmS[j];\n        if(tmp < 0) tmp = 0;\n        tS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    REP(i,h+1) dpS[i] = INT_MAX;\n    REP(i,h+1) dpA[i] = INT_MAX;\n\n    q.push(mpi(0,0));\n    REP(i,h+1) ok[i] = false;\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] > mm){\n          dpS[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n\n    REP(i,h+1) ok[i] = false;\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] > mm){\n          dpA[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    puts(\"1\");\n    continue;\n\n    for(int i=h; i>=0; i--){\n      if(!ok[i]) continue;\n      int mp = dpA[i];\n      int dm = i;\n      if(ans <= mp) continue;\n\n      REP(j,n)\n        if(hp[j] > dm){\n          mp += dpS[hp[j] - dm];\n          if(mp >= ans) break;\n        }\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    bool f=false;\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n      f|=m==0&&d;\n    }\n    long long as[2][100001]={};\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    long long mp=1LL<<62;\n    for(int i=0;i<mp;i++){\n      long long cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<(f?0:mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n#define int long long\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=LLONG_MAX;\n\nint dp1[100010];\nint dp2[100010];\nvoid mainmain(){\n\tint n;\n\tint m;\n\tcin>>n;\n\tvint hp(n);\n\trep(i,n) cin>>hp[i];\n\tcin>>m;\n\tvector<pii> one,all;\n\trep(i,m){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint a,b;\n\t\tcin>>a>>s>>b;\n\t\tif(s==\"Single\"){\n\t\t\tone.PB(mkp(a,b));\n\t\t}\n\t\telse{\n\t\t\tall.PB(mkp(a,b));\n\t\t}\n\t}\n\t// cout<<\"aaa\\n\";\n\trep(i,100010){\n\t\tdp1[i]=INF;\n\t\tdp2[i]=INF;\n\t}\n\tdp1[0]=0;\n\t// cout<<\"size \"<<(int)one.size()<<endl;\n\trep(i,one.size()){\n\t\trep(j,100010){\n\t\t\tif(j+one[i].S>=100010) break;\n\t\t\tif(dp1[j]==INF) continue;\n\t\t\tdp1[j+one[i].S]=min(dp1[j+one[i].S],dp1[j]+one[i].F);\n\t\t}\n\t}\n\tint M=INF;\n\tfor(int i=100009;i>=0;i--){\n\t\tdp1[i]=min(dp1[i],M);\n\t\tM=min(dp1[i],M);\n\t}\n\tdp2[0]=0;\n\trep(i,all.size()){\n\t\trep(j,100010){\n\t\t\tif(j+all[i].S>=100010) break;\n\t\t\tif(dp2[j]==INF) continue;\n\t\t\tdp2[j+all[i].S]=min(dp2[j+all[i].S],dp2[j]+all[i].F);\n\t\t}\n\t}\n\tM=INF;\n\tfor(int i=100009;i>=0;i--){\n\t\tdp2[i]=min(dp2[i],M);\n\t\tM=min(dp2[i],M);\n\t\t// if(i<100) cout<<\"dp2 \"<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t// cout<<\"M \"<<M<<endl;\n\t// cout<<\"hoge\\n\";\n\tint ans=INF;\n\trep(i,100010){\n\t\tint tmp=dp2[i];\n\t\trep(j,n){\n\t\t\tif(hp[j]<=i) continue;\n\t\t\ttmp+=dp1[hp[j]-i];\n\t\t}\n\t\tif(ans>tmp){\n\t\t\tans=min(ans,tmp);\n\t\t\t// cout<<i<<endl;\n\t\t}\n\t}\n\t// cout<<\"dp1\\n\";\n\t// rep(i,50){\n\t\t// cout<<i<<\" \"<<dp1[i]<<endl;\n\t// }\n\t// cout<<\"dp2\"<<endl;\n\t// rep(i,50){\n\t\t// cout<<i<<\" \"<<dp2[i]<<endl;\n\t// }\n\tcout<<ans<<endl;\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nconst int INF = 1000000000;\n\nvector<int> solve_dp(\n\tint max_damage, const vector<int> &mp, const vector<int> &damage)\n{\n\tvector<int> dp(max_damage, -1);\n\tdp[0] = 0;\n\tfor(int i = 0; i < mp.size(); ++i){\n\t\tfor(int j = 0; j < max_damage; ++j){\n\t\t\tif(dp[j] < 0){ continue; }\n\t\t\tint idx = j + damage[i];\n\t\t\tif(idx >= max_damage){ break; }\n\t\t\tif(dp[idx] < 0){\n\t\t\t\tdp[idx] = dp[j] + mp[i];\n\t\t\t}else{\n\t\t\t\tdp[idx] = min(dp[idx], dp[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = max_damage - 2; i >= 0; --i){\n\t\tif(dp[i + 1] < 0){ continue; }\n\t\tif(dp[i] < 0){\n\t\t\tdp[i] = dp[i + 1];\n\t\t}else{\n\t\t\tdp[i] = min(dp[i], dp[i + 1]);\n\t\t}\n\t}\n\treturn dp;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<int> hp(n);\n\t\tint max_hp = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> hp[i];\n\t\t\tmax_hp = max(max_hp, hp[i]);\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<int> all_mp, all_damage;\n\t\tvector<int> single_mp, single_damage;\n\t\tint max_damage = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tmax_damage = max(max_damage, damage);\n\t\t\tif(target == \"All\"){\n\t\t\t\tall_mp.push_back(mp);\n\t\t\t\tall_damage.push_back(damage);\n\t\t\t}else{\n\t\t\t\tsingle_mp.push_back(mp);\n\t\t\t\tsingle_damage.push_back(damage);\n\t\t\t}\n\t\t}\n\t\tint am = all_mp.size(), sm = single_mp.size();\n\t\tmax_damage = max(max_damage, max_hp) + max_damage + 1;\n\t\tvector<int> all_dp = solve_dp(max_damage, all_mp, all_damage);\n\t\tvector<int> single_dp = solve_dp(max_damage, single_mp, single_damage);\n\t\tint answer = INF;\n\t\tfor(int i = 0; i < max_damage; ++i){\n\t\t\tif(all_dp[i] < 0){ continue; }\n\t\t\tint sum = all_dp[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(hp[j] <= i){ continue; }\n\t\t\t\tsum += single_dp[hp[j] - i];\n\t\t\t}\n\t\t\tanswer = min(answer, sum);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    int h[n];\n    for(int i=0; i<n; i++) cin >> h[i];\n    cin >> m;\n    vector<P> a,b;\n    string name,t;\n    for(int i=0; i<m; i++) {\n      P c;\n      cin >> name >> c.first >> t >> c.second;\n      if(t==\"All\") a.push_back(c);\n      else b.push_back(c);\n    }\n    sort(a.begin(),a.end());\n    sort(b.begin(),b.end());\n    int da[100001],db[100001];\n    fill(da,da+100001,1<<29);\n    fill(db,db+100001,1<<29);\n    da[0]=db[0]=0;\n    for(int i=0; i<a.size(); i++) {\n      for(int j=0; j<100001; j++) da[min(100000,j+a[i].second)]=min(da[min(100000,j+a[i].second)],da[j]+a[i].first);\n    }\n    for(int i=0; i<b.size(); i++) {\n      for(int j=0; j<100001; j++) db[min(100000,j+b[i].second)]=min(db[min(100000,j+b[i].second)],db[j]+b[i].first);\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    int ans=1<<29;\n    for(int i=0; i<=100000; i++) {\n      int d=da[i];\n      for(int j=0; j<n; j++) {\n\tint x=max(0,h[j]-i);\n\td+=db[x];\n      }\n      ans=min(ans,d);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,cnt;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nvector<P> v;\n\nint bynary_search(int x){\n  int L=0,R=v.size();\n  while(L<R){\n    int M=(L+R)/2;\n    if(v[M].first>=x)R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++)\n      if(dpSin[i]!=INF)v.push_back(P(i,dpSin[i]));\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      cnt=dpAll[i];\n      for(int j=0;j<n;j++){\n\tint k=hp[j]-i;\n\tcnt+=v[bynary_search(k)].second;\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi hp(n);\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tvp a,b;\n\t\trep(i,m){\n\t\t\tstring c,d;int e,f;\n\t\t\tcin>>c>>e>>d>>f;\n\t\t\tif(d==\"Single\")a.pb(pii(e,f));\n\t\t\tif(d==\"All\")b.pb(pii(e,f));\n\t\t}\n\t\tvi dps(1000000,inf),dpa(1000000,inf);\n\t\tdps[0]=dpa[0]=0;\n\t\trep(i,a.size())rep(j,1000000){\n\t\t\tint t=j-a[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdps[j]=min(dps[j],dps[t]+a[i].first);\n\t\t}\n\t\trep(i,b.size())rep(j,1000000){\n\t\t\tint t=j-b[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdpa[j]=min(dpa[j],dpa[t]+b[i].first);\n\t\t}\n\t\tint out=inf;\n\t\trep(i,1000000)if(dpa[i]!=inf){\n//\t\t\tcout<<i<<\" \"<<dpa[i]<<endl;\n\t\t\tint sum=dpa[i];\n\t\t\tbool h=true;\n\t\t\trep(j,n){\n\t\t\t\tint t=hp[j]-i;\n\t\t\t\tif(t<=0)continue;\n\t\t\t\tif(dps[t]==inf)h=false;\n\t\t\t\tsum+=dps[t];\n\t\t\t}\n\t\t\tif(h)out=min(out,sum);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint multi[100010], single[100010], hp[110];\n\n\nint main(){\n\tint N;\n\twhile (cin >> N && N){\n\t\tfor (int i = 0; i < 100010; i++){\n\t\t\tmulti[i] = 1e9; single[i] = 1e9;\n\t\t}\n\t\tfor (int i = 0; i < N; i++)cin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring command;\n\t\t\tint dmp;\n\t\t\tcin >> name >> mp >> command >> dmp;\n\t\t\tif (command == \"Single\"){\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tsingle[s] = min(single[s], single[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tmulti[s] = min(multi[s], multi[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tfor (int i = 100000; i >= 0; i--){\n\t\t\t\tmulti[i] = min(multi[i], multi[i + 1]);\n\t\t\t\tsingle[i] = min(single[i], single[i + 1]);\n\t\t\t}\n\t\t\tlong long ans = 1e9;\n\t\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\t\tlong long u = multi[i];\n\t\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\t\tint v = min(0, hp[j] - i);\n\t\t\t\t\tu += single[v];\n\t\t\t\t}\n\t\t\t\tans = min(u, ans);\n\t\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct Spell {\n    int mp;\n    int damage;\n    bool target;\n};\n\nstruct P {\n    int cost;\n    vi monster;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nbool is_defeated(vi& monster) {\n    REP(i, SZ(monster)) {\n        if (monster[i] > 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N;\n    vi monster(N);\n    REP(i, N) cin >> monster[i];\n    cin >> M;\n    vector<Spell> spell(M);\n    REP(i, M) {\n        string name, target;\n        int mp, damage;\n        cin >> name >> mp >> target >> damage;\n        spell[i] = {mp, damage, target == \"All\"};\n    }\n\n    set<vi> G;\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({0, monster});\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (is_defeated(p.monster)) {\n            cout << p.cost << endl;\n            break;\n        }\n\n        REP(i, M) {\n            int cost = p.cost + spell[i].mp;\n            if (spell[i].target) {\n                vi monster = p.monster;\n                REP(j, M) {\n                    if (p.monster[j] > 0) {\n                        monster[j] -= spell[i].damage;\n                    }\n                }\n                if (!EXIST(G, monster)) {\n                    G.insert(monster);\n                    que.push({cost, monster});\n                }\n            } else {\n                REP(j, N) {\n                    if (p.monster[j] > 0) {\n                        vi monster = p.monster;\n                        monster[j] -= spell[i].damage;\n                        if (!EXIST(G, monster)) {\n                            G.insert(monster);\n                            que.push({cost, monster});\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n    }\n    int as[2][100001];\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    int mp=1<<30;\n    for(int i=0;i<mp;i++){\n      int cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<mp<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 100002\n#define inf 1<<29\nusing namespace std;\n\nint main()\n{\n  int n,m,hp[101],p,d;\n  string name,s;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    vector<pair<int,int> > all,single; \n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>name>>p>>s>>d;\n      if(s==\"Single\")single.push_back(mp(p,d));\n      else all.push_back(mp(p,d));\n    }\n    \n    int All[MAX],Single[MAX];\n    for(int i=0;i<MAX;i++){\n      All[i]=inf;\n      Single[i]=inf;\n    }\n    All[0]=0;\n    Single[0]=0;\n\n    for(int i=0;i<all.size();i++){\n      for(int j=0;j<MAX;j++){\n\tAll[min(j+all[i].s,MAX-1)]=min(All[min(j+all[i].s,MAX-1)],\n\t\t\t\t       All[j]+all[i].f);\n      }\n    }\n   \n    for(int i=0;i<single.size();i++){\n      for(int j=0;j<MAX;j++){\n\tSingle[min(j+single[i].s,MAX-1)]=min(Single[min(j+single[i].s,MAX-1)],\n\t\t\t\t\t     Single[j]+single[i].f);\n      }\n    }\n\n    for(int i=MAX-2;i>0;i--){\n      All[i]=min(All[i+1],All[i]);\n      Single[i]=min(Single[i+1],Single[i]);\n    }\n\n    int ans=inf;\n    for(int i=0;i<MAX;i++){\n      if(All[i]==inf)continue;\n      int sum=All[i];\n      for(int j=0;j<n;j++){\n\tsum+=Single[max(hp[j]-i,0)];\n      }\n      ans=min(ans,sum);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint HP[100], M;\nlong long dp1[100001], dp2[100001];\n\nint solve(int N)\n{\n  memset(dp1, 0, sizeof(dp1));\n  memset(dp2, 0, sizeof(dp2));\n    \n  for(int i = 0; i < N; i++) {\n    cin >> HP[i];\n  }\n  cin >> M;\n\n  bool end = false;\n  while(M--) {\n    string Name, Target;\n    int MP, Damage;\n    cin >> Name >> MP >> Target >> Damage;\n    if(MP == 0) {\n      if(Damage > 0) end = true;\n      continue;\n    }\n    long long *dp = Target.size() == 3 ? dp1 : dp2;\n    for(int i = MP; i <= 100000; i++) {\n      dp[i] = max(dp[i], dp[i - MP] + Damage);\n    }\n  }\n  if(end) return(0);\n  \n  int best = 1 << 30, pos = *max_element(HP, HP + N);\n  for(int i = 0; i <= 100000 && HP[i] <= pos; i++) {\n    int ret = 0;\n    for(int j = 0; j < N; j++) {\n      ret += lower_bound(dp2, dp2 + 100001, HP[j] - dp1[i]) - dp2;\n    }\n    best = min(best, i + ret);\n  }\n  return(best);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INF 99999999\n\nint main()\n{\n\tint N,M,HP[100];\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> HP[i];\n\t\t\t\n\t\tcin >> M;\n\t\tint ss[100], as[100],sd[100],ad[100],sn=0,an=0;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tstring n,t;\n\t\t\tint m,d;\n\t\t\tcin >> n >> m >> t >> d;\n\t\t\tif(d==0) continue;\n\t\t\t\n\t\t\tif(t==\"All\")\n\t\t\t{\n\t\t\t\tas[an]=m;\n\t\t\t\tad[an]=d;\n\t\t\t\tan++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss[sn]=m;\n\t\t\t\tsd[sn]=d;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shp[100001], ahp[100001];\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tshp[i]=INF;\n\t\t\tahp[i]=INF;\n\t\t}\n\t\tshp[0]=0; ahp[0]=0;\n\t\tfor(int i=0; i<sn; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+sd[i]>100000)\n\t\t\t{\n\t\t\t\tshp[100000]=min(shp[100000], shp[j]+ss[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tshp[j+sd[i]]=min(shp[j+sd[i]], shp[j]+ss[i]);\n\t\t}\n\t\t\n\t\tfor(int i=100000-1; i>=0; i--)\n\t\t\tshp[i]=min(shp[i+1], shp[i]);\n\t\t\n\t\tfor(int i=0; i<an; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+ad[i]>100000) \n\t\t\t{\n\t\t\t\tahp[100000]=min(ahp[100000], ahp[j]+as[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tahp[j+ad[i]]=min(ahp[j+ad[i]], ahp[j]+as[i]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tif(ahp[i]==INF) continue;\n\t\t\tint tmp=ahp[i];\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(i>=HP[j]) continue;\n\t\t\t\ttmp+=shp[HP[j]-i];\n\t\t\t}\n\t\t\t\n\t\t\tans=min(ans, tmp);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Magic{\npublic:\n  string name;\n  int mp;\n  string target;\n  int damage;\n};\nclass Monster{\npublic:\n  bool live;\n  int hp;\n  bool operator<(const Monster &s)const{\n    return hp<s.hp;\n  }\n};\n\nint n;\nMonster mons[100];\nint m;\nMagic magic[100];\nmain(){\n  while(1){\n    cin >> n;\n    if(n==0) break;\n\n    for(int i=0;i<n;i++){\n      cin >> mons[i].hp;\n      mons[i].live=true;\n    }\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> magic[i].name;\n      cin >> magic[i].mp;\n      cin >> magic[i].target;\n      cin >> magic[i].damage;\n    }\n    int monster=n;\n    int ans=0;\n    while(monster>0){\n      sort(mons, mons+n);\n      reverse(mons, mons+n);\n      int nmax;\n      double max=-1.0;\n      int t;\n      for(int i=0;i<m;i++){\n\tif(magic[i].target==\"Single\"){\n\t  for(int j=0;j<n;j++){\n\t    if(!mons[j].live) continue;\n\t    double tmp;\n\t    if(mons[j].hp>=magic[i].damage) tmp=(double)magic[i].damage;\n\t    else{\n\t      tmp=(double)mons[j].hp;\n\t      tmp+=(double)mons[j].hp-magic[i].damage;\n\t    }\n\t    tmp/=magic[i].mp;\n\t    if(max<tmp){\n\t      max=tmp;\n\t      nmax=i;\n\t    }\n\t    t=j;\n\t    break;\n\t  }\n\t}else{\n\t  double sum=0.0;\n\t  for(int j=0;j<n;j++){\n\t    if(!mons[j].live){\n\t      sum-=(double)magic[i].damage;\n\t    }\n\t    else if(mons[j].hp>=magic[i].damage) sum+=(double)magic[i].damage;\n\t    else{\n\t      sum+=(double)mons[j].hp;\n\t    }\n\t  }\n\t  sum/=magic[i].mp;\n\t  if(max<sum){\n\t    max=sum;\n\t    nmax=i;\n\t  }\n\t}\n      }\n      if(magic[nmax].target==\"Single\"){\n\tans+=magic[nmax].mp;\n\tmons[t].hp-=magic[nmax].damage;\n\tif(mons[t].hp<=0){\n\t  mons[t].live=false;\n\t  monster--;\n\t}\n      }else{\n\tans+=magic[nmax].mp;\n\tfor(int i=0;i<n;i++){\n\t  mons[i].hp-=magic[nmax].damage;\n\t  if(!mons[i].live) continue;\n\t  if(mons[i].hp<=0){\n\t    mons[i].live=false;\n\t    monster--;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n    }\n    int as[2][100001]={};\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    int mp=1<<30;\n    for(int i=0;i<mp;i++){\n      int cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<mp<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#define INF 100000\nusing namespace std;\n\nstruct spell{\n    string name;\n    long long int mp;\n    string target;\n    long long int damage;\n};\nlong long int max(long long int n,long long int m){\n    if (n<m) {\n        return m;\n    }else{\n        return n;\n    }\n}\n\nlong long int min(long long int n, long long int m){\n    if (n<m) {\n        return n;\n    }else{\n        return m;\n    }\n}\n\nint main() {\n    for (; ;) {\n        int n;\n        cin >> n;\n        if (n==0) break;\n        vector<long long int> hp(n);\n        long long int max_hp=0;\n        for (int i=0; i<n; i++) {\n            cin >> hp[i];\n            max_hp = max(max_hp,hp[i]);\n        }\n        int m;\n        cin >> m;\n        vector<spell> sp(m);\n        for (int i=0; i<m; i++) {\n            cin >> sp[i].name>> sp[i].mp>> sp[i].target >> sp[i].damage;\n        }\n        long long int smp=1000,amp=1000,sdm=10,adm=10;\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"Single\") {\n                if (smp>sp[i].mp) {\n                smp=sp[i].mp;\n                sdm=sp[i].damage;\n                }\n            }\n        }\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"All\") {\n                if (amp>sp[i].mp) {\n                    amp=sp[i].mp;\n                    adm=sp[i].damage;\n                }\n            }\n        }\n        vector<long long int> single(max_hp+1,INF);\n        if (smp!=100) {\n            single[0]=0;\n            for (int i=1; i<=sdm && i<=max_hp; i++) {\n                single[i]=smp;\n                //if(i/100==0) cout << single[i]<<endl;\n            }\n            for (long long int i=smp+1; i<=max_hp; i++) {\n                long long int res = 114514;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target==\"Single\" && single[max(0,i-sp[k].damage)]+sp[k].mp<=res) res = single[max(0,i-sp[k].damage)]+sp[k].mp;\n                }\n                if(res!=114514) single[i]=res;\n            }\n        }\n        \n        vector<long long int> all(max_hp+1,INF);\n        if (amp!=100) {\n            all[0]=0;\n            for (int i=1; i<=adm && i<=max_hp; i++) {\n                all[i]=amp;\n            }\n            for (long long int i=adm+1; i<=max_hp; i++) {\n                long long int res = 114514;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target== \"All\"  && all[max(0,i-sp[k].damage)]+sp[k].mp<=res){\n                        res = all[max(0,i-sp[k].damage)]+sp[k].mp;\n                    }\n                }\n                if(res!=114514) all[i]=res;\n            }\n        }\n        long long int ans=100000;\n        for (int i=0; i<=max_hp; i++) {\n            vector<long long int> hpp(hp);\n            int hoge=0;\n            for (int j=0; j<n; j++) {\n                hpp[j]=max(0,hpp[j]-i);\n                hoge += single[hpp[j]];\n            }\n            ans = min(ans,all[i]+hoge);\n        }\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n  \nint mon[120];\ntypedef struct magic{\n    int mp;\n    int t;\n    int d;\n}magic;\n  \nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n  \nint dp[200001];\nint dp2[200001];\nvector<magic> all;\nvector<magic> single;\nvector<magic> crit;\n  \nint main(void){\n    int i, j;\n    while(cin >> n, n){\n        ans = 0;\n        all.clear();\n        single.clear();\n        crit.clear();\n        for(i = 0; i < n; i++) cin >> mon[i];\n        cin >> m;\n        for(i = 0; i < m; i++){\n            string name;\n            cin >> name;\n            cin >> mag[i].mp;\n            if(cin >> name, name == \"All\") mag[i].t = 1;\n            if(cin >> mag[i].d, !mag[i].d) continue;\n            else if(mag[i].t){\n                if(mag[i].d >= 100000) crit.push_back(mag[i]);\n                else all.push_back(mag[i]);\n            }\n            else single.push_back(mag[i]);\n        }\n  \n        int ans = INF;\n        for(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n        for(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n          \n        //dp(ALL_Magic)\n        dp[0] = 0;\n        for(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n        for(i = 0; i < 200001; i++){\n            if(dp[i] == INF) continue;\n            for(j = i; j + i < 200001; j++){\n                if(dp[j] == INF) continue;\n                dp[j + i] = min(dp[i] + dp[j], dp[j + i]);\n            }\n        }\n  \n        //dp(SINGLE_Magic)\n        dp2[0] = 0;\n        for(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n        for(i = 0; i < 200001; i++){\n            if(dp2[i] == INF) continue;\n            for(j = i; j + i < 200001; j++){\n                if(dp2[j] == INF) continue;\n                dp2[j + i] = min(dp2[i] + dp2[j], dp2[j + i]);\n            }\n        }\n        for(i = 200000; dp2[i] == INF && i >= 0; i--);\n        for(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n  \n  \n        for(i = 200000; i >= 0; i--){\n            if(dp[i] == INF) continue;\n            prev = dp[i];\n            for(j = 0; j < n; j++){\n                if(mon[j] <= i) continue;\n                prev += dp2[mon[j] - i];\n            }\n            if(prev < 0) continue;\n            ans = min(prev, ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\nconstexpr int INF = 1000000000LL;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return std::vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return std::vector<decltype(inner)>(x, inner); }\ntemplate<typename T = int, typename... Args> T in(Args &&... args) { T x(args...); std::cin >> x; return x; }\nusing namespace std;\n// clang-format on\n\nsigned main() {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    auto h = in<vector<int>>(n);\n    int m = in();\n    int maxH = *max_element(all(h));\n    auto dp = vectors(2, maxH + 1, INF);\n    dp[0][0] = dp[1][0] = 0;\n    rep(_, m) {\n      auto name = in<string>();\n      int p = in();\n      auto t = in<string>();\n      int d = in();\n      if (d == 0) continue;\n      rep(i, maxH + 1) cmin(dp[t[0] == 'A'][min(i + d, maxH)], dp[t[0] == 'A'][i] + p);\n    }\n    for (int i = maxH - 1; i >= 0; i--) cmin(dp[0][i], dp[0][i + 1]);\n    int ans = INF;\n    rep(i, maxH + 1) {\n      if (dp[1][i] == INF) continue;\n      int s = dp[1][i];\n      rep(j, n) s += dp[0][max(0LL, h[j] - i)];\n      cmin(ans, s);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint h[100];\nvector<pair<int, int>> s, a;\nlong long dp[100010];\nlong long dp2[100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring na, ta;\n\t\t\tint mp, da;\n\t\t\tcin >> na >> mp >> ta >> da;\n\t\t\t(ta == \"Single\" ? s : a).emplace_back(mp, da);\n\t\t}\n\n\t\tfill_n(dp, 100010, 1ll << 60);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < s.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < s[i].second ? 0 : dp[j - s[i].second];\n\t\t\t\tdp[j] = min<long long>(dp[j], t + s[i].first);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp2, 100010, 1ll << 60);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < a.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < a[i].second ? 0 : dp2[j - a[i].second];\n\t\t\t\tdp2[j] = min<long long>(dp2[j], t + a[i].first);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long res = 1 << 28;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long sum = dp2[i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i <= h[j]) sum += dp[h[j] - i];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint H[100];\n\nvint calc(vpint a){\n    vector<int>dp(100000+1,INT_MAX);\n    dp[0]=0;\n    for(int i=0;i<a.size();i++){\n        for(int j=0;j+a[i].se<=100000;j++){\n            chmin(dp[j+a[i].se],dp[j]+a[i].fi);\n        }\n    }\n\n    for(int i=100000;i>0;i--)chmin(dp[i-1],dp[i]);\n    return dp;\n}\n\nvoid solve(){\n    rep(i,N)cin>>H[i];\n    cin>>M;\n\n    vector<pint>s,a;\n\n    rep(i,M){\n        string str;\n        int m,d;\n        cin>>str>>m>>str>>d;\n        if(str==\"Single\")s.pb({m,d});\n        else a.pb({m,d});\n    }\n\n    vector<int>ss,aa;\n    ss=calc(s);\n    aa=calc(a);\n\n    int ans=LLONG_MAX;\n    for(int i=0;i<=100000;i++){\n        int sum=0;\n        sum+=aa[i];\n        for(int j=0;j<N;j++){\n            if(H[j]>i)sum+=ss[H[j]-i];\n        }\n        chmin(ans,sum);\n    }\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N,N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\n#define inf 999999999999\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        for(int i=1;i<=10000;i++)dp2[i]=-inf;\n        memset(dp1,0,sizeof dp1);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=1ll<<60,sum;\n        for(int i=0; i<10001; i++)\n        {\n            if(dp2[i]<0)continue;\n            sum=i;\n            for(int j=0; j<n; j++)\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint H[100];\n\nvint calc(vpint a){\n    vector<int>dp(100000+1,INT_MAX);\n    dp[0]=0;\n    for(int i=0;i<a.size();i++){\n        for(int j=0;j<=100000;j++){\n            chmin(dp[min(100000ll,j+a[i].se)],dp[j]+a[i].fi);\n        }\n    }\n\n    for(int i=100000;i>0;i--)chmin(dp[i-1],dp[i]);\n    return dp;\n}\n\nvoid solve(){\n    rep(i,N)cin>>H[i];\n    cin>>M;\n\n    vector<pint>s,a;\n\n    rep(i,M){\n        string str;\n        int m,d;\n        cin>>str>>m>>str>>d;\n        if(str==\"Single\")s.pb({m,d});\n        else a.pb({m,d});\n    }\n\n    vector<int>ss,aa;\n    ss=calc(s);\n    aa=calc(a);\n\n    int ans=LLONG_MAX;\n    for(int i=0;i<=100000;i++){\n        int sum=0;\n        sum+=aa[i];\n        for(int j=0;j<N;j++){\n            if(H[j]>i)sum+=ss[H[j]-i];\n        }\n        chmin(ans,sum);\n    }\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N,N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 2000000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\t//\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp = INF;\n  for(int i=maxhp;i>=0;i--){\n    if ( single[n][i] >=INF){res_all[i]=INF;continue;}\n    //if (tmp>single[n][i])tmp=single[n][i];\n    //res_all[i]=tmp;\n  } \n\n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nint dp1[2][100010], dp2[2][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >> target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 30;\n    }\n    for(int i = 1; i <= m; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(damage[i-1] == 0){\n          dp1[i%2][j] = dp1[(i-1)%2][j]\n          dp2[i%2][j] = dp2[(i-1)%2][j];   \n        }\n        else if(target[i-1] == \"All\"){\n            dp1[i%2][j] = min(dp1[(i-1)%2][j], dp1[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i%2][j] = dp2[(i-1)%2][j];          \n        }\n        else{\n            dp2[i%2][j] = min(dp2[(i-1)%2][j], dp2[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i%2][j] = dp1[(i-1)%2][j];\n        }\n      }\n    }\n    \n    \n    for(int i = 5000; i <= 10000; i++){\n      //cout << i << \" \" << dp2[n][i] <<endl;\n    }\n    \n    int ans = 1 << 30;\n    for(int i = 0; i <= 100000; i++){\n      int sum = dp1[m%2][i];\n      //cout << i << \" \" << dp1[n][i] << endl;\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[m%2][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N)\n    {\n\n        vector<ll> HP(N);\n        for (int i = 0; i < N; i++)\n        {\n            cin >> HP[i];\n        }\n        int M;\n        cin >> M;\n        vector<P> single, all;\n        for (int i = 0; i < M; i++)\n        {\n            string name, target;\n            int mp, damage;\n            cin >> name >> mp >> target >> damage;\n            if (target == \"All\")\n                all.push_back(P(mp, damage));\n            else\n                single.push_back(P(mp, damage));\n        }\n        // dp1[i] := All で i ダメージ与える最小コスト\n        // dp2[i] := Single で i ダメージ与える最小コスト\n        vector<ll> dp1(111111, INF), dp2(111111, INF);\n        dp1[0] = 0;\n        dp2[0] = 0;\n        for (int i = 0; i < (int)all.size(); i++)\n        {\n            int mp = all[i].first, d = all[i].second;\n            for (int j = 0; j <= 100000; j++)\n            {\n                if (j + d > 100000)\n                {\n                    dp1[100001] = min(dp1[100001], dp1[j] + mp);\n                }\n                else\n                {\n                    dp1[j + d] = min(dp1[j + d], dp1[j] + mp);\n                }\n            }\n        }\n        for (int i = 0; i < (int)single.size(); i++)\n        {\n            int mp = single[i].first, d = single[i].second;\n            for (int j = 0; j <= 100000; j++)\n            {\n                if (j + d > 100000)\n                {\n                    dp2[100001] = min(dp2[100001], dp2[j] + mp);\n                }\n                else\n                {\n                    dp2[j + d] = min(dp2[j + d], dp2[j] + mp);\n                }\n            }\n        }\n        for (int i = 100000; i >= 0; i--)\n        {\n            dp1[i] = min(dp1[i], dp1[i + 1]);\n            dp2[i] = min(dp2[i], dp2[i + 1]);\n            // assert(dp1[i] != INF);\n            // assert(dp2[i] != INF);\n        }\n        ll res = INF;\n        for (int i = 0; i <= 100000; i++)\n        {\n            ll tmp = dp1[i];\n            for (int j = 0; j < N; j++)\n            {\n                if (HP[j] <= i)\n                    continue;\n                tmp += dp2[HP[j] - i];\n            }\n            res = min(res, tmp);\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1e10;\n\nconst int MAX_D = 1000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tsi[i - 1] = min(si[i - 1], si[i]);\n\t\t}\n\n\t\tlong long ans = al[*max_element(all(h))];\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 1e5+1;\nconst long long int inf = 1e16;\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<int> hp(n);\n        for(int i=0; i<n; i++) cin >> hp[i];\n        \n        int m;\n        cin >> m;\n        vector<long long int> mp(m), range(m), damage(m);\n        for(int i=0; i<m; i++){\n            string name, r;\n            cin >> name >> mp[i] >> r >> damage[i];\n            if(r==\"Single\"){\n                range[i] = 0;\n            }else{\n                range[i] = 1;\n            }\n        }\n        \n        vector<vector<long long int> > dp(2, vector<long long int>(MAX, inf));\n        for(int d=0; d<2; d++){\n            dp[d][0] = 0;\n            for(int i=0; i<m; i++){\n                if(range[i]!=d || damage[i]==0) continue;\n                for(int j=0; j<MAX; j++){\n                    dp[d][j] = min(dp[d][j], (j+damage[i]-1)/damage[i]*mp[i]);\n                    if(j-damage[i]>0){\n                        dp[d][j] = min(dp[d][j], dp[d][j-damage[i]] +mp[i]);\n                    }\n                }\n            }\n        }\n\n        long long int ans = inf;\n        for(int i=0; i<MAX; i++){\n            long long int cost = dp[1][i];\n            for(int j=0; j<n; j++){\n                if(hp[j]-i > 0){\n                    cost += dp[0][hp[j]-i];\n                }\n            }\n            ans = min(ans, cost);\n        }\n        cout << ans << endl;   \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 100009\nusing namespace std;\n\nint dp1[10009];\nint dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        int ans=1<<28,sum;\n        for(int i=0; i<n; i++)\n        {\n            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            int tmp=sum;\n//        printf(\"%d\\n\",tmp);\n            for(int j=i+1; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[tmp])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\n#define MAX_DM 5000000\n\nint N, M, HP[111];\nvector< int > singleMP, allMP;\nvector< int > singleDM, allDM;\n\nint singleDP[MAX_DM], allDP[MAX_DM];\nconst int INF = (int)1e9;\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> HP[i];\n\t\n\tstring dumy, type;\n\tcin >> M;\n\t\n\tfor_(i,0,M) {\n\t\tint MP, DM;\n\t\tcin >> dumy >> MP >> type >> DM;\n\t\t\n\t\tif (type == \"All\") {\n\t\t\tallMP.push_back(MP);\n\t\t\tallDM.push_back(DM);\n\t\t} else {\n\t\t\tsingleMP.push_back(MP);\n\t\t\tsingleDM.push_back(DM);\n\t\t}\n\t}\n\t\n\t// single DP\n\tint S = singleMP.size();\n\tfill(singleDP, singleDP + MAX_DM, INF);\n\tsingleDP[0] = 0;\n\t\n\tfor_(i,0,S) {\n\t\tint DM = singleDM[i], MP = singleMP[i];\n\t\t\n\t\tfor_(j,DM,MAX_DM) {\n\t\t\tsingleDP[j] = min(singleDP[j], singleDP[j - DM] + MP);\n\t\t}\n\t}\n\t\n\tvector< int > smp(MAX_DM, singleDP[MAX_DM-1]);\n\tfor_rev(d,MAX_DM-2,0) smp[d] = min(smp[d + 1], singleDP[d]);\n\t\n\t// all DP\n\tint A = allMP.size();\n\tfill(allDP, allDP + MAX_DM, INF);\n\tallDP[0] = 0;\n\t\n\tfor_(i,0,A) {\n\t\tint DM = allDM[i], MP = allMP[i];\n\t\t\n\t\tfor_(j,DM,MAX_DM) {\n\t\t\tallDP[j] = min(allDP[j], allDP[j - DM] + MP);\n\t\t}\n\t}\n\t\n\tvector< int > amp(MAX_DM, allDP[MAX_DM-1]);\n\tfor_rev(d,MAX_DM-2,0) amp[d] = min(amp[d + 1], allDP[d]);\n\t\n\tint ans = INF;\n\t\n\tfor_(d,0,MAX_DM) {\n\t\tint sum = amp[d];\n\t\tfor_(i,0,N) if (HP[i] - d > 0) sum += smp[HP[i] - d];\n\t\tans = min(ans, sum);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nclass Magic {\npublic:\n    int mp;\n    int damage;\n    bool isAll;\n};\n\nint calcMP(std::vector<Magic> magics, std::vector<int> enemyHPs) {\n    int totalMP = std::numeric_limits<int>::max();\n    if(magics.empty()) {\n        return totalMP;\n    }\n\n    bool defeated = true;\n    for(auto itr = enemyHPs.begin(); itr != enemyHPs.end(); itr++) {\n        if(*itr > 0) {\n            defeated = false;\n            break;\n        }\n    }\n    if(defeated) {\n        return 0;\n    }\n\n    if(!magics.back().isAll) {\n        for(int i = 0; i < (int) enemyHPs.size(); i++) {\n            if(enemyHPs[i] <= 0) {\n                continue;\n            }\n            std::vector<int> tempEnemyHPs = enemyHPs;\n            tempEnemyHPs[i] -= magics.back().damage;\n            totalMP = std::min(totalMP, calcMP(magics, tempEnemyHPs) + magics.back().mp);\n        }\n    } else {\n        std::vector<int> tempEnemyHPs = enemyHPs;\n        for(auto itr = tempEnemyHPs.begin(); itr != tempEnemyHPs.end(); itr++) {\n            *itr -= magics.back().damage;\n        }\n        totalMP = std::min(totalMP, calcMP(magics, tempEnemyHPs) + magics.back().mp);\n    }\n\n    magics.pop_back();\n    totalMP = std::min(totalMP, calcMP(magics, enemyHPs));\n\n    return totalMP;\n}\n\nint main() {\n    while(1) {\n        std::vector<int> enemyVector;\n        std::vector<Magic> magicVector;\n        int enemyNumber, magicNumber;\n\n        std::cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            int hp;\n            std::cin >> hp;\n            enemyVector.push_back(hp);\n        }\n\n        std::cin >> magicNumber;\n        for(int i = 0; i < magicNumber; i++) {\n            std::string name, target;\n            Magic magic;\n            std::cin >> name >> magic.mp >> target >> magic.damage;\n            if(target == \"All\") {\n                magic.isAll = true;\n            } else {\n                magic.isAll = false;\n            }\n            magicVector.push_back(magic);\n        }\n\n        std::cout << calcMP(magicVector, enemyVector) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#define INF (1<<21)\nusing namespace std;\n\nclass Enemy{\npublic:\n  int hp[100],mp,a;\n  bool f[100];\n  bool operator < (const Enemy &p)const{\n    return mp > p.mp;\n  }\n  Enemy (int mp = 0,int a = 0): mp(mp),a(a){}\n};\n\nclass Actor{\npublic:\n  int mp,damage;\n  string name;\n  bool all;\n};\n\nint main(){\n  int i,j,k,n,m,ans;\n  string str;\n  while(1){\n    Enemy u,v;\n    Actor p[100];\n    priority_queue<Enemy> Q;\n    cin >> n;\n    if(n == 0) break;\n    for(i=0;i<n;i++){\n      cin >> u.hp[i];\n      u.f[i] = false;\n    }\n    cin >> m;\n    for(i=0;i<m;i++){\n      cin >> p[i].name >> p[i].mp >> str >> p[i].damage;\n      if(str == \"Single\") p[i].all = false;\n      else p[i].all = true;\n    }\n\n    ans = INF;\n    Q.push(u);\n    bool f = false;\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      if(u.a >= n){\n\tans = min(ans,u.mp);\n\tbreak;\n      }\n\n      for(i=0;i<m;i++){\n\tv = u;\n\tv.mp += p[i].mp;\n\tif(p[i].all){\n\t  for(j=0;j<n;j++){\n\t    v.hp[j] -= p[i].damage;\n\t    if(v.hp[j] <= 0 && !v.f[j]){\n\t      v.a++;\n\t      v.f[j] = true;\n\t    }\n\t  }\n\t  if(v.a >= n){\n\t    ans = min(ans,v.mp);\n\t    f = true;\n\t  }\n\t  else Q.push(v);\n\t}\n\n\telse{\n\t  for(j=0;j<n;j++){\n\t    v = u;\n\t    v.mp += p[i].mp;\n\t    v.hp[j] -= p[i].damage;\n\t    if(v.hp[j] <= 0 && !v.f[j]){\n\t      v.a++;\n\t      v.f[j] = true;\n\t    }\n\t    if(v.a >= n){\n\t      ans = min(ans,v.mp);\n\t      f = true;\n\t    }\n\t    else Q.push(v);\n\t  }\n\t}\n      }\n      if(f) break;\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nll dp1[200010],dp2[200010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint m,d;\n\t\t\tcin>>s>>m>>t>>d;\n\t\t\td=min(d,100000);\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=m;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=m;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+200001,INF*INF);\n\t\tfill(dp2,dp2+200001,INF*INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,200001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=199999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tll ans=INF*INF;\n\t\trep(i,200001){\n\t\t\tll res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tll rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\n\nusing namespace std;\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\n\nstruct state{\n\tstate():sum_mp(0),rest(0){}\n\tvector<int> vhp;\n\tint sum_mp;\n\tint rest;\n\tbool bComp()const{\n\t\tif(rest<=0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tbool operator<(const state &t)const{\n\t\treturn sum_mp<t.sum_mp;\n\t}\n\tint getHeuristic(double best_rate)const{\n\t\treturn (int)( rest / best_rate + 0.5 );\n\t}\n};\nostream &operator <<(ostream &os, const state &t){\n\tos<<\"HP: \";\n\tfor(unsigned int i=0;i<t.vhp.size();++i){\n\t\tos<<t.vhp[i]<<' ';\n\t}\n\tos<<\"\\nSUM MP: \"<<t.sum_mp<<\" REST HP: \" << t.rest;\n\treturn os;\n}\n\nvoid solve(const state &ini, const vector<magic> &vmag, double best_rate, int &best_ans){\n\tint n=ini.vhp.size();\n\tpriority_queue< state > qs;\n\n\tqs.push( ini );\n\n\twhile( !qs.empty() ){\n\t\tstate st = qs.top();\n\t\tqs.pop();\n\n\t\tif( st.sum_mp >= best_ans )\n\t\t\tbreak;\n\n\t\tif( st.bComp() ){\n\t\t\tbest_ans=min(best_ans,st.sum_mp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(unsigned int i=0;i<vmag.size();++i){\n\t\t\tif( st.sum_mp+vmag[i].mp >= best_ans )\n\t\t\t\tcontinue;\n\t\t\tif(vmag[i].type==ALL){\n\t\t\t\tstate t = st;\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( t.vhp[j] > 0 ){\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\tqs.push( t );\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( st.vhp[j]>0 ){\n\t\t\t\t\t\tstate t = st;\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\t\t\tqs.push( t );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tint ans=INFTY;\n\t\tdouble best_rate=0.0;\n\t\tvector<magic> vmagic;\n\t\tmagic magic_for_greedy;\n\t\tstate init;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tinit.rest+=t;\n\t\t\tinit.vhp.push_back(t);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint mp,type,damage;\n\t\t\tchar stype[17]=\"\";\n\n\t\t\tscanf(\"%*s%d%s%d\", &mp, stype, &damage);\n\n\t\t\tif(strcmp(stype,\"All\")==0)type=ALL;\n\t\t\telse type=SINGLE;\n\n\t\t\tif(damage>0&&mp==0){\n\t\t\t\tbest_rate=-2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(damage>0&&mp>0){\n\t\t\t\tmagic tm;\n\t\t\t\tif( best_rate < (double)damage*( type==ALL?n:1 )/mp ){\n\t\t\t\t\tbest_rate=(double)damage*( type==ALL?n:1 )/mp;\n\t\t\t\t\tmagic_for_greedy.damage=damage;\n\t\t\t\t\tmagic_for_greedy.mp=mp;\n\t\t\t\t\tmagic_for_greedy.type=type;\n\t\t\t\t}\n\t\t\t\ttm.damage=damage;tm.mp=mp;tm.type=type;\n\t\t\t\tvmagic.push_back( tm );\n\t\t\t}\n\t\t}\n\n\t\tif( magic_for_greedy.type == ALL ){\n\t\t\tint hp_max = 0;\n\t\t\tfor(unsigned int i = 0; i < init.vhp.size(); ++i){\n\t\t\t\thp_max = max( hp_max, init.vhp[i] );\n\t\t\t}\n\t\t\tans=magic_for_greedy.mp * ((hp_max%magic_for_greedy.damage?1:0)+hp_max/magic_for_greedy.damage);\n\t\t}else{\n\t\t\tans=0;\n\t\t\tfor(unsigned int i = 0; i < init.vhp.size(); ++i){\n\t\t\t\tans+=magic_for_greedy.mp * ((init.vhp[i]%magic_for_greedy.damage?1:0)+init.vhp[i]/magic_for_greedy.damage);\n\t\t\t}\n\t\t}\n\n\t\tif( best_rate<0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsolve(init,vmagic,best_rate,ans);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nint MAX = 100000;\nint cost_all[200020];\nint cost_single[200020];\n\nusing pii = pair<int, int>;\n\nvoid init() {}\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    vector<int> H(N);\n    REP(i, N) cin >> H[i];\n    vector<pii> vs, va;\n    int M;\n    cin >> M;\n    REP(i, M) {\n        string s;\n        cin >> s;\n        int cost;\n        cin >> cost;\n        cin >> s;\n        int d;\n        cin >> d;\n        if (s == \"Single\") {\n            vs.push_back({cost, d});\n        } else\n            va.push_back({cost, d});\n    }\n    REP(i, MAX + 100) {\n        cost_single[i] = 1e9;\n        cost_all[i] = 1e9;\n    }\n    cost_all[0] = cost_single[0] = 0;\n    REP(i, MAX) {\n        for (auto p : vs) {\n            int cost = p.first;\n            int d = p.second;\n            int nxt = min(MAX, i + d);\n            if (cost_single[nxt] > cost_single[i] + cost) {\n                cost_single[nxt] = cost_single[i] + cost;\n            }\n        }\n        for (auto p : va) {\n            int cost = p.first;\n            int d = p.second;\n            int nxt = min(MAX, i + d);\n            if (cost_all[nxt] > cost_all[i] + cost) {\n                cost_all[nxt] = cost_all[i] + cost;\n            }\n        }\n    }\n    for (int i = MAX; i >= 0; i--) {\n        cost_single[i] = min(cost_single[i], cost_single[i + 1]);\n        cost_all[i] = min(cost_all[i], cost_all[i + 1]);\n    }\n    int ans = 1e9;\n    REP(d, MAX + 1) {\n        int res = cost_all[d];\n        REP(i, N) {\n            int rem = max(0LL, H[i] - d);\n            res += cost_single[rem];\n        }\n        // if (res < ans) cout << d << \" \" << res << endl;\n        ans = min(ans, res);\n    }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    init();\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n, n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 100000 + 1;\n    const int inf = 100000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          if(j + damage < MAX)\n            memo[j + damage] = min(memo[j + damage], memo[j] + mp);\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      if(cc == 1){\n        for(int j = MAX - 1; j > 0; j--){\n          memo[j - 1] = min(memo[j - 1], memo[j]);\n        }\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      if(mp >= ans) goto next;\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n          if(mp >= ans) goto next;\n        }\n      }\n      ans = mp;\n    next:;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[200],b[200],d[200];vector<int>v1,v2,w1,w2,dp1,dp2;\nvector<int>knapsack(int W,vector<int>v,vector<int>w){\n\tvector<int>dp(W+1000,999999999);\n\tfor(int i=0;i<dp.size();i++){dp[i]=999999999;}\n\tdp[0]=0;\n\tfor(int i=0;i<(int)v.size();i++){\n\t\tfor(int j=v[i];j<=W;j++)dp[j]=min(dp[j],dp[j-v[i]]+w[i]);\n\t}\n\tfor(int i=W-1;i>=0;i--){\n\t\tdp[i]=min(dp[i],dp[i+1]);\n\t}\n\treturn dp;\n}\nint main(){\n\twhile(true){\n\t\tv1.clear();v2.clear();w1.clear();w2.clear();dp1.clear();dp2.clear();\n\t\tfor(int i=0;i<200;i++){a[i]=0;b[i]=0;d[i]=0;}\n\t\tcin>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];cin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring S,T;cin>>S>>b[i]>>T>>d[i];if(d[i]>=200000)d[i]=200000;\n\t\t\tif(T==\"Single\"){v1.push_back(d[i]);w1.push_back(b[i]);}\n\t\t\tif(T==\"All\"){v2.push_back(d[i]);w2.push_back(b[i]);}\n\t\t}\n\t\tdp1=knapsack(400000,v1,w1);\n\t\tdp2=knapsack(400000,v2,w2);\n\t\tint maxn=999999999;\n\t\tfor(int i=0;i<=300000;i++){\n\t\t\tint sum=dp2[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint P=0;if(a[j]>i)P=dp1[a[j]-i];\n\t\t\t\tsum+=dp1[P];\n\t\t\t}\n\t\t\tmaxn=min(maxn,sum);\n\t\t}\n\t\tcout<<maxn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 2e5+10;\n\nint dp_s[N];\nint dp_a[N];\n\nint mons[110];\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = 1e9;\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tv = min(v, 100000);\n\t\t\tint *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\trep(j, N-v) dp[j + v] = min(dp[j + v], dp[j] + w);\n\t\t}\n\n\t\tfor (int i = N - 5; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tint ans = 1e9;\n\t\trep(i, N){\n\t\t\tint tmp = dp_a[i];\n\t\t\tif (tmp == 1e9) continue;\n\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\nint N,M,HP[105],A,SDP[100005],ADP[100005],res,tmp;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tmemset(ADP,0x7f,sizeof(ADP));\n\t\tSDP[0]=ADP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tSDP[np]=min(SDP[np],SDP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tfor(int i=100000;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\n\t\tfor(int i=M-A;i<M;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tADP[np]=min(ADP[np],ADP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tif(A==M)\n\t\t{\n\t\t\tint mh=0;\n\t\t\tfor(int i=0;i<N;i++)mh=max(mh,HP[i]);\n\t\t\tfor(int i=mh;i<=100000;i++)\n\t\t\t\tres=min(res,ADP[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<=100000;i++)\n\t\t\t{\n\t\t\t\ttmp=ADP[i];\n\t\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\t{\n\t\t\t\t\tif(HP[k]-i>=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint np=HP[k]-i;\n\t\t\t\t\t\tif(np<0)np=0;\n\t\t\t\t\t\ttmp+=SDP[np];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres=min(res,tmp);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\nint n,m,hp[100],dp[100001],dp2[100001],inf=1e9;\nvector<P> al,one;\nint dfs(int h){\n\tif(dp[h]!=inf) return dp[h];\n\trep(i,one.size()){\n\t\tint mp=one[i].fs,dam=one[i].sc;\n\t\tif(dam>=h) dp[h]=min(dp[h],mp);\n\t\telse dp[h]=min(dp[h],dfs(h-dam)+mp);\n\t}\n\treturn dp[h];\n}\nint dfs2(int h){\n\tif(dp2[h]!=inf) return dp2[h];\n\trep(i,al.size()){\n\t\tint mp=al[i].fs,dam=al[i].sc;\n\t\tif(dam>=h) dp2[h]=min(dp2[h],mp);\n\t\telse dp2[h]=min(dp2[h],dfs2(h-dam)+mp);\n\t}\n\treturn dp2[h];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tal.clear();\n\t\tone.clear();\n\t\trep(i,n) cin>>hp[i];\n\t\trep1(i,100000) dp[i]=inf,dp2[i]=inf;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring name,tar;\n\t\t\tint mp,dam;\n\t\t\tcin>>name>>mp>>tar>>dam;\n\t\t\tif(dam==0) continue;\n\t\t\tif(tar[0]=='A') al.pb(P(mp,dam));\n\t\t\telse one.pb(P(mp,dam));\n\t\t}\n\t\trep1(i,100000) dfs(i),dfs2(i);\n\t\tint ans=inf;\n\t\tif(al.size()==0){\n\t\t\tint now=0;\n\t\t\trep(i,n) now+=dp[hp[i]];\n\t\t\tans=min(ans,now);\n\t\t}else if(one.size()==0){\n\t\t\tint mx=0;\n\t\t\trep(i,n) mx=max(mx,hp[i]);\n\t\t\tans=dp2[mx];\n\t\t}else{\n\t\t\trep(damal,100001){\n\t\t\t\tint now=dp2[damal];\n\t\t\t\trep(i,n) if(hp[i]>damal) now+=dp[hp[i]-damal];\n\t\t\t\tans=min(ans,now);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint HP[100], M;\nlong long dp1[100001], dp2[100001];\n\nint solve(int N)\n{\n  memset(dp1, 0, sizeof(dp1));\n  memset(dp2, 0, sizeof(dp2));\n    \n  for(int i = 0; i < N; i++) {\n    cin >> HP[i];\n  }\n  cin >> M;\n\n  bool end = false;\n  while(M--) {\n    string Name, Target;\n    int MP, Damage;\n    cin >> Name >> MP >> Target >> Damage;\n    if(MP == 0) {\n      if(Damage > 0) end = true;\n      continue;\n    }\n    for(int i = MP; i <= 100000; i++) {\n      dp2[i] = max(dp2[i], dp2[i - MP] + Damage);\n    }\n    if(Target.size() == 6) MP *= N;\n    for(int i = MP; i <= 100000; i++) {\n      dp1[i] = max(dp1[i], dp1[i - MP] + Damage);\n    }\n  }\n  if(end) return(0);\n  \n  int best = 1 << 30;\n  for(int i = 0; i <= 100000; i++) {\n    int ret = 0;\n    for(int j = 0; j < N; j++) {\n      ret += lower_bound(dp2, dp2 + 100001, HP[j] - dp1[i]) - dp2;\n    }\n    best = min(best, i + ret);\n  }\n  return(best);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\nusing namespace std;\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\nvoid solve(int n, int hp[N], int m, magic mag[M], int now, int &ans){\n\tbool bSolved=true;\n\t/*for(int i=0;i<n;++i){\n\t\tcout<<hp[i]<<' ';\n\t}\n\tcout<<endl;*/\n\tfor(int i=0;i<n;++i){\n\t\tif(hp[i]>0){\n\t\t\tbSolved=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( bSolved ){\n\t\tans=min(ans,now);\n\t\treturn ;\n\t}\n\n\tfor(int i=0;i<m;++i){\n\t\tint nx_hp[N];\n\t\tfor(int j=0;j<n;++j){\n\t\t\tnx_hp[j]=hp[j];\n\t\t}\n\t\tif(mag[i].type==ALL){\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t}\n\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,ans );\n\t\t}else{\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif(nx_hp[j]>0){\n\t\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,ans );\n\t\t\t\t\tnx_hp[j]+=mag[i].damage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint ans=INFTY;\n\t\tint n,m;\n\t\tint minmp=INFTY;\n\t\tint magsz=0;\n\t\tint hp[N]={0,};\n\t\tmagic mag[M];\n\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar type[17]=\"\";\n\t\t\tscanf(\"%*s%d%s%d\", &mag[magsz].mp, type, &mag[magsz].damage);\n\t\t\tif(strcmp(type,\"All\")==0)mag[magsz].type=ALL;\n\t\t\telse mag[magsz].type=SINGLE;\n\t\t\tif(mag[magsz].damage>0)\n\t\t\t\t++magsz;\n\t\t\telse{\n\t\t\t\tminmp=min(minmp,mag[magsz].mp);\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<magsz;++i){\n\t\t\tcout << \"MP: \" << mag[i].mp <<\" TYPE: \" << mag[i].type << \" DAMAGE: \" << mag[i].damage << endl;\n\t\t}*/\n\t\tsort(mag,mag+magsz);\n\t\tsolve(n,hp,magsz,mag,0,ans);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;//first : MP, second : Damage\nvoid set_cost(vector<int>& cost, const vector<pint>& attack){\n    cost[0] = 0;\n    REP(i, 1, cost.size()){\n        for(pint k : attack){\n            int temp = k.first;\n            if(i - k.second >= 0) temp += cost[i - k.second];\n            cost[i] = min(cost[i], temp);\n        }\n    }\n    return;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        int HP_MAX = -INF;\n        vector<int> HP(N);\n        rep(i, N){\n            cin >> HP[i];\n            HP_MAX = max(HP_MAX, HP[i]);\n        }\n        int M; cin >> M;\n        vector<pint> single, all;\n        rep(i, M){\n            string a, b;\n            int c, d;\n            cin >> a >> c >> b >> d;\n            if(b == \"All\")\n              all.push_back(pint(c, d));\n            else\n              single.push_back(pint(c, d));\n        }\n        vector<int> scost(HP_MAX + 1, INF), acost(HP_MAX + 1, INF);\n        set_cost(scost, single);\n        set_cost(acost, all);\n        int ans = 0;\n        while(true){\n            int hit = INF, enemies = 0;\n            for(int k : HP)\n              if(k > 0) {\n                  enemies++;\n                  hit = min(k, hit);\n              }\n            if(enemies == 0) break;\n            int cost, damage;\n            if(acost[hit] > scost[hit] * enemies){\n                cost = scost[hit];\n                REP(i, hit, HP_MAX + 1) if(scost[i] != cost){ damage = i - 1; break;}\n                cost *= enemies;\n            }else{\n                cost = acost[hit];\n                REP(i, hit, HP_MAX + 1) if(acost[i] != cost){ damage = i - 1; break;}\n            }\n            for(int& k : HP) k -= damage;\n            ans += cost;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid fillDP(const vector< pair<int, long int> >& skills, vector<int>& dp, long int size) {\n    dp.resize(size + 1);\n    fill(dp.begin(), dp.end(), INF);\n    dp[0] = 0;\n    for(auto itr = skills.begin(); itr != skills.end(); itr++) {\n        for(long int i = 0; i <= size; i++) {\n            if(dp[i] == INF) {\n                continue;\n            }\n            long int damage = min(i + itr->second, size);\n            dp[damage] = min(dp[damage], dp[i] + itr->first);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        int enemyNumber, skillNumber;\n        long int maxHP;\n        vector<int> allDP, singleDP;\n        vector<long int> hps;\n        vector< pair<int, long int> > allSkills, singleSkills;\n\n        cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            long int hp;\n            cin >> hp;\n            hps.push_back(hp);\n        }\n\n        cin >> skillNumber;\n        for(int i = 0; i < skillNumber; i++) {\n            int mp;\n            long int damage;\n            string name, target;\n            cin >> name >> mp >> target >> damage;\n            if(target == \"All\") {\n                allSkills.push_back(make_pair(mp, damage));\n            } else {\n                singleSkills.push_back(make_pair(mp, damage));\n            }\n        }\n\n        maxHP = *max_element(hps.begin(), hps.end());\n        fillDP(allSkills, allDP, maxHP);\n        fillDP(singleSkills, singleDP, maxHP);\n\n        int minimum = INF;\n        for(long int i = maxHP; i > 0; i--) {\n            minimum = min(minimum, singleDP[i]);\n            singleDP[i] = minimum;\n        }\n\n        int answer = INF;\n\n        for(long int i = 0; i <= maxHP; i++) {\n            if(allDP[i] == INF) {\n                continue;\n            }\n\n            int cost = allDP[i];\n\n            for(int j = 0; j < enemyNumber; j++) {\n                if(hps[j] - i > 0) {\n                    cost += singleDP[hps[j] - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef struct magic{\n  int mp, damage;\n}magic;\nint dp_all[2][100000 + 1],\n  dp_single[2][100000 + 1];\n\nint main(int argc, char *argv[]){\n  int n, m;\n  while(std::cin >> n, n){\n    int hp[n];\n    int max_hp = 0;\n    for (int i = 0; i < n; i++) {\n      std::cin >> hp[i];\n      max_hp = max(max_hp, hp[i]);\n    }\n    std::cin >> m;\n    string s;\n    vector<magic> single, all;\n    for (int i = 0; i < m; i++) {\n      int mp, damage;\n      std::cin >> s >> mp >> s >> damage;\n      if(damage == 0)continue;\n      if(s == \"All\"){\n        all.push_back(magic{mp, damage});\n      }else{\n        single.push_back(magic{mp, damage});\n      }\n    }\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j <= max_hp; j++) {\n        dp_all[i][j] = 1e9;\n      }\n    }\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j <= max_hp; j++) {\n        dp_single[i][j] = 1e9;\n      }\n    }\n    for (int i = 0; i < 2; i++) {\n      dp_all[i][0] = 0;\n    }\n    for (int i = 0; i < 2; i++) {\n      dp_single[i][0] = 0;      \n    }\n    for (int i = 0; i < all.size(); i++) {\n      int &mp = all[i].mp, &damage = all[i].damage;\n      for (int j = 0; j <= max_hp; j++) {\n        if(j < damage){\n          dp_all[((i + 1)&1)][j] = min(mp, dp_all[(i&1)][j]);\n        }else{\n          dp_all[((i + 1)&1)][j] =\n            min(dp_all[(i&1)][j],\n                dp_all[((i + 1)&1)][j - damage] + mp);\n        }\n      }\n    }\n    for (int i = 0; i < single.size(); i++) {\n      int &mp = single[i].mp, &damage = single[i].damage;\n      for (int j = 0; j <= max_hp; j++) {\n        if(j < damage){\n          dp_single[((i + 1)&1)][j] =\n            min(mp, dp_single[(i&1)][j]);\n        }else{\n          dp_single[((i + 1)&1)][j] =\n            min(dp_single[(i&1)][j],\n                dp_single[(i + 1)&1][j - damage] + mp);\n                \n        }\n      }\n    }\n    long long int ans = 1e10;\n    int size_all = all.size(), size_single = single.size();\n    for (int i = 0; i <= max_hp; i++) {\n      long long int sum = dp_all[size_all&1][i];\n      for (int j = 0; j < n; j++) {\n        if(hp[j] - i <= 0)continue;\n        sum += dp_single[size_single&1][hp[j] - i];\n      }\n      ans = min(ans, sum);\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define int ll\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#define MAX_DAMAGE 2*100000\n\nint dp1[MAX_DAMAGE];\n//dp1[j]=(i番目のALL魔法を使って)ダメージをj与えたときの最小のMP消費量\nint dp2[MAX_DAMAGE];\n//dp2[j]=(i番目のsingle魔法を使って)ダメージをj与えたときの最小のMP消費量\n\nsigned main(void) {\n  int i,j;\n  int n;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vi hp(n);\n    rep(i,n)cin>>hp[i];\n    int m;\n    cin>>m;\n    vector<pii> all,single;\n    rep(i,m){\n      string s,t;\n      int mp,dmg;\n      cin>>s>>mp>>t>>dmg;\n      dmg=min(100000LL,dmg);\n      if(t[0]=='S') single.push_back(pii(mp,dmg));\n      else all.push_back(pii(mp,dmg));\n    }\n\n    rep(i,MAX_DAMAGE)//init\n      dp1[i]=dp2[i]=INF;\n\n    dp1[0]=dp2[0]=0;\n\n    rep(i,all.size()){\n      int mp=all[i].first;\n      int dmg=all[i].second;\n      rep(j,MAX_DAMAGE)\n\tif(j+dmg<MAX_DAMAGE)\n\t  dp1[j+dmg]=min(dp1[j+dmg],dp1[j]+mp);  \n    }\n    rep(i,single.size()){\n      int mp=single[i].first;\n      int dmg=single[i].second;\n      rep(j,MAX_DAMAGE)\n\tif(j+dmg<MAX_DAMAGE)\n\t  dp2[j+dmg]=min(dp2[j+dmg],dp2[j]+mp);\n    }\n    for(i=MAX_DAMAGE-2;i>=0;i--)\n      dp2[i]=min(dp2[i],dp2[i+1]);\n\n    int ans=INF;\n\n    rep(i,MAX_DAMAGE){\n\n      int t=dp1[i];\n\n      rep(j,n)\n\tt+=dp2[max(0LL,hp[j]-i)];\n\n      ans=min(ans,t);\n\n    }\n\n    cout<<ans<<endl;\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vi HP(n); REP(i, n) cin >> HP[i];\n        const int HPMAX = *max_element(ALL(HP));\n\n        int m; cin >> m;\n        vi allMP, allDamage, singleMP, singleDamage;\n        REP(i, m) {\n            string name, target;\n            int mp, damage;\n            cin >> name >> mp >> target >> damage;\n            if (target == \"All\") {\n                allMP.push_back(mp);\n                allDamage.push_back(damage);\n            }\n            if (target == \"Single\") {\n                singleMP.push_back(mp);\n                singleDamage.push_back(damage);\n            }\n        }\n\n        vi allDP(HPMAX+1, INF), singleDP(HPMAX+1, INF);\n        allDP[0] = singleDP[0] = 0;\n        REP(i, SZ(allMP)) {\n            REP(d, HPMAX+1) {\n                if (allDP[d] == INF) continue;\n                chmin(allDP[min(d + allDamage[i], HPMAX)], allDP[d] + allMP[i]);\n            }\n        }\n        REP(i, SZ(singleMP)) {\n            REP(d, HPMAX+1) {\n                if (singleDP[d] == INF) continue;\n                chmin(singleDP[min(d + singleDamage[i], HPMAX)], singleDP[d] + singleMP[i]);\n            }\n        }\n\n        RREP(d, HPMAX) {\n            chmin(allDP[d], allDP[d+1]);\n            chmin(singleDP[d], singleDP[d+1]);\n        }\n\n        int ans = INF;\n\n        REP(a, HPMAX+1) {\n            bool valid = 1;\n            if (allDP[a] == INF) valid = 0;\n            int sum = allDP[a];\n            REP(i, n) {\n                if (singleDP[max(HP[i] - a, 0)] == INF) valid = 0;\n                sum += singleDP[max(HP[i] - a, 0)];\n            }\n            if (valid) chmin(ans, sum);\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nclass Magic {\npublic:\n    int mp;\n    int damage;\n    bool isAll;\n};\n\nint calcMP(std::vector<Magic> magics, std::vector<int> enemyHPs) {\n    int totalMP = std::numeric_limits<int>::max();\n    if(magics.empty()) {\n        return totalMP;\n    }\n\n    bool defeated = true;\n    for(auto itr = enemyHPs.begin(); itr != enemyHPs.end(); itr++) {\n        if(*itr > 0) {\n            defeated = false;\n            break;\n        }\n    }\n    if(defeated) {\n        return 0;\n    }\n\n    if(!magics.back().isAll) {\n        for(int i = 0; i < (int) enemyHPs.size(); i++) {\n            if(enemyHPs[i] <= 0) {\n                continue;\n            }\n            std::vector<int> tempEnemyHPs = enemyHPs;\n            tempEnemyHPs[i] -= magics.back().damage;\n            totalMP = std::min(totalMP, calcMP(magics, tempEnemyHPs) + magics.back().mp);\n        }\n    } else {\n        std::vector<int> tempEnemyHPs = enemyHPs;\n        for(auto itr = tempEnemyHPs.begin(); itr != tempEnemyHPs.end(); itr++) {\n            *itr -= magics.back().damage;\n        }\n        totalMP = std::min(totalMP, calcMP(magics, tempEnemyHPs) + magics.back().mp);\n    }\n\n    magics.pop_back();\n    totalMP = std::min(totalMP, calcMP(magics, enemyHPs));\n\n    return totalMP;\n}\n\nint main() {\n    while(1) {\n        std::vector<int> enemyVector;\n        std::vector<Magic> magicVector;\n        int enemyNumber, magicNumber;\n\n        std::cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            int hp;\n            std::cin >> hp;\n            enemyVector.push_back(hp);\n        }\n\n        std::cin >> magicNumber;\n        for(int i = 0; i < magicNumber; i++) {\n            std::string name, target;\n            Magic magic;\n            std::cin >> name >> magic.mp >> target >> magic.damage;\n            if(target == \"All\") {\n                magic.isAll = true;\n            } else {\n                magic.isAll = false;\n            }\n            magicVector.push_back(magic);\n        }\n\n        std::cout << calcMP(magicVector, enemyVector) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nll dp1[200010],dp2[200010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint mp,d;\n\t\t\tcin>>s>>mp>>t>>d;\n\t\t\td=min(d,100000);\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=mp;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=mp;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+200001,INF);\n\t\tfill(dp2,dp2+200001,INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,200001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=199999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tll ans=INF*INF;\n\t\trep(i,200001){\n\t\t\tll res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tll rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n\n\n#define N_MAX 100\n#define M_MAX 100\n#define HP_MAX 100000\nusing namespace std;\n\nint N,M;\nint HP[N_MAX];\nint dp[2][HP_MAX+1];\nint A_dp[HP_MAX+1];//HP??????????????????MP???????°?????????????\nint S_dp[HP_MAX+1];\n\ntypedef pair<int,int> P;\n\nint main(){\n    string s;\n    vector<P> A,S;//<MP,Damage>\n    while(cin>>N,N!=0){\n        A.clear();\n        S.clear();\n        for(int i=0;i<N;i++)cin>>HP[i];\n        cin>>M;\n\n        for(int i=0;i<M;i++){\n            int m,d;\n            cin>>s>>m>>s>>d;\n            if(s[0]=='A'){\n                A.emplace_back(m,d);\n            }else{\n                S.emplace_back(m,d);\n            }\n        }\n        \n        fill_n(dp[0],HP_MAX+1,0);\n        fill_n(dp[1],HP_MAX+1,INT_MAX);\n        for(int i=0;i<A.size();i++){\n            for(int hp=0;hp<=HP_MAX;hp++){\n                if(i==0){\n                    dp[0][hp]=A[0].first+(hp-A[0].second>=0?dp[0][hp-A[0].second]:0);\n                }else{\n                    dp[i%2][hp]=min(dp[(i+1)%2][hp],hp-A[i].second>=0?dp[i%2][hp-A[i].second]+A[i].first:A[i].first);\n                }\n            }\n        }\n        for(int i=0;i<=HP_MAX;i++) A_dp[i]=dp[(A.size()-1)%2][i];\n\n        fill_n(dp[0],HP_MAX+1,0);\n        fill_n(dp[1],HP_MAX+1,INT_MAX);\n        for(int i=0;i<S.size();i++){\n            for(int hp=0;hp<=HP_MAX;hp++){\n                if(i==0){\n                    dp[0][hp]=S[0].first+(hp-S[0].second>=0?dp[0][hp-S[0].second]:0);\n                }else{\n                    dp[i%2][hp]=min(dp[(i+1)%2][hp],hp-S[i].second>=0?dp[i%2][hp-S[i].second]+S[i].first:S[i].first);\n                }\n            }\n        }\n        for(int i=0;i<=HP_MAX;i++) S_dp[i]=dp[(S.size()-1)%2][i];\n\n        int MP_min=INT_MAX;\n\n        for(int alldamage=0;alldamage<=HP_MAX;alldamage++){\n            int mp=A_dp[alldamage];\n            for(int i=0;i<N;i++){\n                int hp=HP[i];\n                hp-=alldamage;\n                if(hp>0){\n                    mp+=S_dp[hp];\n                }\n            }\n            MP_min=min(MP_min,mp);\n        }\n        cout << MP_min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst ll HSIZE=100001;\nconst ll INF=1e15;\n\nll solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<ll> smp,sdmg;\n    vector<ll> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<ll> sdp;\n    {\n        vector<vector<ll>> tmp(2,vector<ll>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+sdmg[i]<HSIZE) tmp[to][j+sdmg[i]]=min(tmp[to][j+sdmg[i]],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<ll> adp;\n    {\n        vector<vector<ll>> tmp(2,vector<ll>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                tmp[to][min(j+admg[i],HSIZE-1)]=min(tmp[to][min(j+admg[i],HSIZE-1)],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    ll res=ll(1e15);\n    for(int i=0;i<HSIZE;i++){\n        ll sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc+=sdp[max(h[j]-i,0)];\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 100009\nusing namespace std;\n\nint dp1[10009];\nint dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)&&n!=0)\n    {\n        int ma=-1;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        long long ans=1(long long)<<62,sum;\n        for(int i=0; i<ans; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][100001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][100001];\nvector<Magic> allMagics;\nvector<Magic> singleMagics;\n\n// all\nint dfs(int pos,int dmg){\n\tif(dmg<0)return INF;\n\telse if(pos==(int)allMagics.size()){\n\t\t// ¿å¤Ç0ÉÈêÎ\n\t\tif(dmg==0)return 0;\n\t\telse return INF;\n\t}\n\tif(dp[pos][dmg]!=-1)return dp[pos][dmg];\n\tint res=INF;\n\tres=min(res,dfs(pos+1,dmg));\n\tres=min(res,dfs(pos,dmg-allMagics[pos].dmg)+allMagics[pos].mp);\n\treturn dp[pos][dmg]=res;\n}\n// single\nint dfs2(int pos,int dmg){\n\tif(dmg<=0)return 0;\n\telse if(pos==(int)singleMagics.size()){\n\t\t// dmgª0ÈºÈçÎok\n\t\tif(dmg<=0)return 0;\n\t\telse return INF;\n\t}\n\tif(dp2[pos][dmg]!=-1)return dp2[pos][dmg];\n\tint res=INF;\n\tres=min(res,dfs2(pos+1,dmg));\n\tres=min(res,dfs2(pos,dmg-singleMagics[pos].dmg)+singleMagics[pos].mp);\n\treturn dp2[pos][dmg]=res;\n}\n\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tvector<Magic> crit;\n\t\tallMagics.clear();\n\t\tsingleMagics.clear();\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tmemset(dp2,-1,sizeof(dp2));\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\tif(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>100000)\n\t\t\t\t\tcrit.push_back(magics[i]);\n\t\t\t\telse\n\t\t\t\t\tallMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\tfor(int i=0;i<crit.size();i++)\n\t\t\tminMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=100000;j++)dp[i][j]=INF;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=100000;j++)dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<LL> maketbl(const vector<int> &mp, const vector<int> &dmg, int mh){\n\tvector<LL> ret(mh + 1, 1LL << 60);\n\tret[0] = 0;\n\tfor(int i = 1; i <= mh; ++i){\n\t\tfor(size_t j = 0; j < mp.size(); ++j){\n\t\t\tret[i] = min(ret[i], ret[max(i - dmg[j], 0)] + mp[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> hp(n);\n\t\tint mh = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t\tmh = max(mh, hp[i]);\n\t\t}\n\t\tvector<int> mps, dmgs, mpa, dmga;\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint d, p;\n\t\t\tchar c;\n\t\t\tif(scanf(\"%*s%d %c%*s%d\", &p, &c, &d) != 3){ throw 0; }\n\t\t\tif(d){\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\tmps.push_back(p);\n\t\t\t\t\tdmgs.push_back(d);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmpa.push_back(p);\n\t\t\t\t\tdmga.push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<LL> tbls = maketbl(mps, dmgs, mh);\n\t\tvector<LL> tbla = maketbl(mpa, dmga, mh);\n\t\tLL ans = 1LL << 60;\n\t\tfor(int i = 0; i <= mh; ++i){\n\t\t\tLL s = tbla[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\ts += tbls[max(hp[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, s);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\nll M = 10000;\n\nint main(){\nwhile(1){\n    ll n;\n    cin>>n;\n    if(n==0)break;\n    vector<ll> hp(n);\n    for(ll i=0;i<n;i++)cin>>hp[i];\n    vector<mp> da,ds;\n    ll m;\n    cin>>m;\n    bool f = false;\n    for(ll i=0;i<m;i++){\n\tstring s;\n\tcin>>s;\n\tll cost,damage;\n\tcin>>cost>>s>>damage;\n\tif( s == \"All\" ){\n\t    da.push_back( mp( cost , damage ) );\n\t}else{\n\t    ds.push_back( mp( cost , damage ) );\n\t}\n\tif( cost == 0 && damage != 0 ) f = true;\n    }\n    if( f ){\n\tcout<<0<<endl;\n\tcontinue;\n    }\n    ll n1 = da.size(),n2 = ds.size();\n    vector<vector<ll> > dpa(n1+1,vector<ll>( M + 1 , 0 ) );//cost に関するdamage maximize\n    vector<vector<ll> > dps(n2+1,vector<ll>( M + 1 , 0 ) );\n    /*cout<<\"all\"<<endl;\n    for(auto i:da){\n\tcout<<i.first<<' '<<i.second<<endl;\n    }*/\n    for(ll i=0;i<n1;i++){\n\tfor(ll j=0;j<=M;j++){\n\t    if( da[i].first <= j ){\n\t\t//cout<<j<<':'<<dpa[i+1][j-da[i].first]<<endl;\n\t\tdpa[i+1][j] = max( dpa[i][j] , dpa[i+1][j-da[i].first] + da[i].second );\n\t//\tcout<<dpa[i+1][j]<<endl;\n\t    }else{\n\t\tdpa[i+1][j] = dpa[i][j];\n\t    }\n\t}\n    }\n    for(ll i=0;i<n2;i++){\n\tfor(ll j=0;j<=M;j++){\n\t    if( ds[i].first <= j ){\n\t\tdps[i+1][j] = max( dps[i][j] , dps[i+1][j-ds[i].first] + ds[i].second );\n\t    }else{\n\t\tdps[i+1][j] = dps[i][j];\n\t    }\n\t}\n    }\n    //for(ll i=0;i<100;i++)cout<<i<<' '<<dpa[n][i]<<endl;\n    ll res = inf;\n    for(ll i=0;i<=M;i++){\n    //for(ll i=0;i<=80;i++){\n\tll D = dpa[n1][i];\n\tll cost = i;\n\t//cout<<cost<<' '<<D<<endl;\n\tfor(ll j=0;j<n;j++){\n\t    if( hp[j] - D > 0 ){\n\t\tauto it = lower_bound( dps[n2].begin() , dps[n2].end() , hp[j]-D );\n\t\tcost += (it-dps[n2].begin() );\n\t    }\n\t}\n\tres = min( cost, res );\n    }\n    cout<<res<<endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\n#define inf 999999999999\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        for(int i=1;i<=10000;i++)dp2[i]=-inf;\n        dp2[0]=0;\n        memset(dp1,0,sizeof dp1);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=1ll<<60,sum;\n        for(int i=0; i<10001; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n//            ll tmp=sum;\n            if(dp2[i]<0)continue;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 100009\nusing namespace std;\n\nint dp1[10009];\nint dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)&&n!=0)\n    {\n        int ma=-1;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        int ans=1<<28,sum;\n        for(int i=0; i<ans; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\nvector<magic> all;\nvector<magic> single;\nvector<magic> crit;\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tmemset(mon, 0, sizeof(mon));\n\t\tmemset(mag, 0, sizeof(mag));\n\t\tall.clear();\n\t\tsingle.clear();\n\t\tcrit.clear();\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tdp[0] = 0;\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF && i >= 0; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\t\t\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tint mon2[120];\n\t\t\tmemcpy(mon2, mon, sizeof(mon));\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tif(mon2[j] <= i) continue;\n\t\t\t\tprev += dp2[mon2[j] - i];\n\t\t\t}\n\t\t\tif(prev < 0) continue;\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000005\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nint dp[2][MAX_Damage];\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)\n\t{\n\t  rep(j,MP[i].size())\n\t    {\n\t      rep(k,MAX_Damage)\n\t\t{\n\t\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t\t      dp[i][k] + MP[i][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,2)\n\t{\n\t  for(int j=MAX_Damage-2;j>=0;j--)\n\t    {\n\t      dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\t    }\n\t}\n\n      int ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  if(dp[1][i] == inf)continue;\n\t  int cnt = dp[1][i];\n\t  rep(j,N)//Single\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      if(dp[0][HP[j]-i] == inf)break;\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  ans = min(ans,cnt);\n\t}\n\n      int mex = -inf;\n      int cnt = 0;\n      rep(i,N)//Single\n\t{\n\t  mex = max(mex,HP[i]);\n\t  cnt += dp[0][HP[i]];\n\t}\n      ans = min(ans,cnt);\n      ans = min(ans,dp[1][mex]);//All\n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\n#define INF 1000000000\n\nstruct spell{\n  int mp;\n  int damage;\n};\n\nstruct spell sps[100],spa[100];\nLL dps[100001],dpa[100001];\n\nint main(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) return 0;\n    vector<int> hp(n);\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n    }\n    int m;\n    cin >> m;\n    int counts=0,counta=0;\n    string name,target;\n    int mp,damage;\n    for(int i=0;i<m;i++){\n      cin >> name >> mp >> target >> damage;\n      if(target==\"Single\"){\n        sps[counts]={mp,damage};\n        counts++;\n      }else{\n        spa[counta]={mp,damage};\n        counta++;\n      }\n    }\n    for(int i=0;i<100001;i++){\n      dpa[i]=dps[i]=INF;\n    }\n    dpa[0]=dps[0]=0;\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counts;j++){\n        if(i-sps[j].damage<0){\n          dps[i]=min(dps[i],sps[j].mp);\n        }else{\n          dps[i]=min(dps[i],dps[i-sps[j].damage]+sps[j].mp);\n        }\n      }\n    }\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counta;j++){\n        if(i-spa[j].damage<0){\n          dpa[i]=min(dpa[i],spa[j].mp);\n        }else{\n          dpa[i]=min(dpa[i],dpa[i-spa[j].damage]+spa[j].mp);\n        }\n      }\n    }\n    LL ans=INF;\n    int count;\n    for(int i=0;i<100001;i++){\n      count=dpa[i];\n      for(int j=0;j<n;j++){\n        count+=(hp[j]-i>=0?dps[hp[j]-i]:0);\n      }\n      ans=min(ans,count);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 111111\n#define INF 10000000000\n#define int long long\nint dp[N+1],dp2[N+1],cost[N+1],cost2[N+1];\ntypedef pair<int,int> P;\nint getcost(int x){\n  if(x<=0) return 0;\n  return cost2[x];\n}\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int hp[n];\n    for(int i=0;i<n;i++) cin>>hp[i];\n    int m;cin>>m;\n    vector<P> single,all;\n    bool f=0;\n    for(int i=0;i<m;i++){\n      string name,target;\n      int mp,damage;\n      cin>>name>>mp>>target>>damage;\n      if(damage){\n\tif(target==\"All\") all.push_back(P(mp,damage));\n\telse single.push_back(P(mp,damage));\n\tf|=!mp;\n      }\n    }\n    \n    for(int i=0;i<=N;i++) cost[i]=cost2[i]=dp[i]=dp2[i]=INF;\n    cost[0]=dp[0]=0;\n    for(int i=0;i<=N;i++){\n      if(cost[i]==INF) continue;\n      //cout<<i<<\":\"<<cost[i]<<endl;\n      for(int j=0;j<(int)single.size();j++){\n\tint u=single[j].first,v=single[j].second;\n\t//cout<<u<<\":\"<<v<<endl;\n\tif(i+v<N) cost[i+v]=min(cost[i+v],cost[i]+u);\n\telse cost[N]=min(cost[N],cost[i]+u);\n      }\n    }\n    cost2[N]=cost[N];\n    for(int i=N-1;i>=0;i--) cost2[i]=min(cost2[i+1],cost[i]);\n    for(int i=0;i<N;i++){\n      if(dp[i]==INF) continue;\n      for(int j=0;j<(int)all.size();j++){\n\tint u=all[j].first,v=all[j].second;\n\tif(i+v<N) dp[i+v]=min(dp[i+v],dp[i]+u);\n\telse dp[N]=min(dp[N],dp[i]+u);\n      }\n    }\n    dp2[N]=dp[N];\n    for(int i=N-1;i>=0;i--) dp2[i]=min(dp2[i+1],dp[i]);\n    int ans=INF;\n    for(int i=0;i<N;i++){\n      if(dp2[i]==INF) continue;\n      int tmp=0;\n      for(int j=0;j<n;j++) tmp+=getcost(hp[j]-i);\n      //cout<<i<<\";\"<<dp2[i]<<\":\"<<tmp<<endl;\n      ans=min(ans,dp2[i]+tmp);\n    }\n    cout<<!f*ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MAX = 100001;\nconst ll INF = (1LL<<50);\nstruct Spell{\n  string name,tar;\n  ll MP,Dam;\n  Spell(){}\n  Spell(string n, ll m, string t, ll d):name(n),MP(m),tar(t),Dam(d){}\n};\n\nll dp[2][MAX];\nvector<ll> Enemy;\nvector<Spell> V[2];\nll N;\n\nvoid init(){\n  fill(dp[0],dp[0]+2*MAX,INF);\n\n  //for(ll i = 0; i < 2; i++) for(ll j = 0; j < MAX; j++) dp[i][j] = INF;\n  V[0].clear();\n  V[1].clear();\n  Enemy.clear();\n}\n\nvoid input(){\n\n  while(N--){\n    ll in;\n    cin >> in;\n    Enemy.push_back(in);\n  }\n\n  ll m;\n  cin >> m;\n  while(m--){\n    Spell s;\n    cin >> s.name >> s.MP >> s.tar >> s.Dam;\n    if(s.tar == \"All\") V[0].push_back(s);\n    else V[1].push_back(s);\n  }\n\n}\n\n\nvoid make(){\n\n  dp[0][0] = dp[1][0] = 0;\n\n  for(ll x = 0; x < 2; x++){\n    for(ll i = 0; i < MAX; i++){\n      if(dp[x][i] == INF) continue;\n      for(ll j = 0; j < V[x].size(); j++){\n        ll nex = min(i+V[x][j].Dam,100000LL);\n        ll cos = dp[x][i]+V[x][j].MP;\n        dp[x][nex] = min(dp[x][nex],cos);\n      }\n    }\n  }\n  \n  ll mincos[2];\n  mincos[0] = dp[0][MAX-1];\n  mincos[1] = dp[1][MAX-1];\n  \n  for(ll i = MAX-1; i >= 0; i--){\n    mincos[0] = min(mincos[0],dp[0][i]);\n    mincos[1] = min(mincos[1],dp[1][i]);\n    dp[0][i] = min(dp[0][i],mincos[0]);\n    dp[1][i] = min(dp[1][i],mincos[1]);\n  }\n}\n\nvoid solve(){\n\n  ll ans = INF;\n\n  for(ll i = 0; i < MAX; i++){\n\n    ll cos = dp[0][i];\n    for(ll j = 0; j < Enemy.size(); j++){\n      ll need = max(Enemy[j]-i,0LL);\n      cos+=dp[1][need];\n\n      //    cout << \"cos \" << dp[1][need] << endl;\n    }\n    ans = min(ans,cos);\n  }\n  cout << ans << endl;\n}\n\n\nint main(){\n\n  while(cin >> N && N){\n    init();\n    input();\n    make();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\nint dp1[100101];\nint dp2[100101];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint HP[100] = {};\n\t\tfor (int i = 0; i < N; i++) cin >> HP[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<P> single;\n\t\tvector<P> all;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tif (target == \"Single\") {\n\t\t\t\tsingle.emplace_back(mp, damage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tall.emplace_back(mp, damage);\n\t\t\t}\n\t\t}\n\t\tfill(dp1, dp1 + 100101, 1 << 30);\n\t\tdp1[0] = 0;\n\t\tfor (int i = 0; i < single.size(); i++) {\n\t\t\tfor (int j = 0; j <= 100100; j++) {\n\t\t\t\tif (j <= single[i].second) {\n\t\t\t\t\tdp1[j] = min(dp1[j], single[i].first);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp1[j] = min(dp1[j], dp1[j - single[i].second] + single[i].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dp2, dp2 + 100101, 1 << 30);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < all.size(); i++) {\n\t\t\tfor (int j = 0; j <= 100100; j++) {\n\t\t\t\tif (j <= all[i].second) {\n\t\t\t\t\tdp2[j] = min(dp2[j], all[i].first);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp2[j] = min(dp2[j], dp2[j - all[i].second] + all[i].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 0; i <= 100100; i++) {\n\t\t\tint cost = 0;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (HP[j] <= i) continue;\n\t\t\t\tcost += dp1[HP[j] - i];\n\t\t\t}\n\t\t\tcost += dp2[i];\n\t\t\tans = min(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\nconstexpr int INF = 1000000000;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return std::vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return std::vector<decltype(inner)>(x, inner); }\ntemplate<typename T = int, typename... Args> T in(Args &&... args) { T x(args...); std::cin >> x; return x; }\nusing namespace std;\n// clang-format on\n\nint main() {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    auto h = in<vector<int>>(n);\n    int m = in();\n    int maxH = *max_element(all(h));\n    auto dp = vectors(2, maxH + 1, INF);\n    dp[0][0] = dp[1][0] = 0;\n    rep(_, m) {\n      auto name = in<string>();\n      int p = in();\n      auto t = in<string>();\n      int d = in();\n      if (d == 0) continue;\n      loop(i, d, maxH + 1) cmin(dp[t[0] == 'A'][i], dp[t[0] == 'A'][i - d] + p);\n    }\n    rep(k, 2) for (int i = maxH - 1; i >= 0; i--) cmin(dp[k][i], dp[k][i + 1]);\n    int ans = INF;\n    rep(i, maxH + 1) {\n      if (dp[1][i] == INF) continue;\n      int c = dp[1][i];\n      rep(j, m) c += dp[0][max(0, h[j] - i)];\n      cmin(ans, c);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\n#define INF 1000000000\n\nstruct spell{\n  int mp;\n  int damage;\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<int> hp(n);\n  for(int i=0;i<n;i++){\n    cin >> hp[i];\n  }\n  int m;\n  cin >> m;\n  vector<struct spell> sps(m),spa(m);\n  int counts=0,counta=0;\n  string name,target;\n  int mp,damage;\n  for(int i=0;i<n;i++){\n    cin >> name >> mp >> target >> damage;\n    if(target==\"Single\"){\n      sps[counts]={mp,damage};\n      counts++;\n    }else{\n      spa[counta]={mp,damage};\n      counta++;\n    }\n  }\n  vector<int> dps(100001,INF),dpa(100001,INF);\n  dpa[0]=dps[0]=0;\n  for(int i=1;i<100001;i++){\n    for(int j=0;j<counts;j++){\n      if(i-sps[j].damage<0){\n        dps[i]=min(dps[i],sps[j].mp);\n      }else{\n        dps[i]=min(dps[i],dps[i-sps[j].damage]+sps[j].mp);\n      }\n    }\n  }\n  for(int i=1;i<100001;i++){\n    for(int j=0;j<counta;j++){\n      if(i-spa[j].damage<0){\n        dpa[i]=min(dpa[i],spa[j].mp);\n      }else{\n        dpa[i]=min(dpa[i],dpa[i-spa[j].damage]+spa[j].mp);\n      }\n    }\n  }\n  int ans=INF;\n  int count;\n  for(int i=0;i<100001;i++){\n    count=dpa[i];\n    for(int j=0;j<n;j++){\n      count+=(hp[j]-i>=0?dps[hp[j]-i]:0);\n    }\n    ans=min(ans,count);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;//first : MP, second : Damage\nvoid set_cost(vector<int>& cost, const vector<pint>& attack){\n    cost[0] = 0;\n    REP(i, 1, cost.size()){\n        for(pint k : attack){\n            int temp = k.first;\n            if(i - k.second >= 0) temp += cost[i - k.second];\n            cost[i] = min(cost[i], temp);\n        }\n    }\n    return;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        int HP_MAX = -INF;\n        vector<int> HP(N);\n        rep(i, N){\n            cin >> HP[i];\n            HP_MAX = max(HP_MAX, HP[i]);\n        }\n        int M; cin >> M;\n        vector<pint> single, all;\n        rep(i, M){\n            string a, b;\n            int c, d;\n            cin >> a >> c >> b >> d;\n            if(b == \"All\")\n              all.push_back(pint(c, d));\n            else\n              single.push_back(pint(c, d));\n        }\n        vector<int> scost(HP_MAX + 1, INF), acost(HP_MAX + 1, INF);\n        set_cost(scost, single);\n        set_cost(acost, all);\n        ll ans = INF;\n        rep(d, HP_MAX + 1){\n            ll sum = acost[d];\n            for(int k : HP){\n                int need = max(0, k - d);\n                sum += scost[need];\n            }\n            ans = min(sum, ans);\n        }\n        /*\n        while(true){\n            int hit = INF, enemies = 0;\n            for(int k : HP)\n              if(k > 0) {\n                  enemies++;\n                  hit = min(k, hit);\n              }\n            if(enemies == 0) break;\n            int cost, damage;\n            if(acost[hit] > scost[hit] * enemies){\n                cost = scost[hit];\n                REP(i, hit, HP_MAX + 1) if(scost[i] != cost){ damage = i - 1; break;}\n                cost *= enemies;\n            }else{\n                cost = acost[hit];\n                REP(i, hit, HP_MAX + 1) if(acost[i] != cost){ damage = i - 1; break;}\n            }\n            for(int& k : HP) k -= damage;\n            ans += cost;\n        }*/\n        \n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint h[100];\nvector<pair<int, int>> s, a;\nint dp[100010];\nint dp2[100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring na, ta;\n\t\t\tint mp, da;\n\t\t\tcin >> na >> mp >> ta >> da;\n\t\t\t(ta == \"Single\" ? s : a).emplace_back(mp, da);\n\t\t}\n\n\t\tfill_n(dp, 100010, 1 << 28);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < s.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < s[i].second ? 0 : dp[j - s[i].second];\n\t\t\t\tdp[j] = min(dp[j], t + s[i].first);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp2, 100010, 1 << 28);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < a.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < a[i].second ? 0 : dp2[j - a[i].second];\n\t\t\t\tdp2[j] = min(dp2[j], t + a[i].first);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 1 << 28;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tint sum = dp2[i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i <= h[j]) sum += dp[h[j] - i];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli N = 100;\nconst lli M = 100000;\nconst lli INF = 1 << 28;\n\ntypedef pair<lli, lli> P;\n\nlli n, m, hp[N], sm[M+1], am[M+1];\nvector<P> s, a;\n\nint main(){\n\twhile(cin >> n && n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor(lli i=0;i<n;i++) cin >> hp[i];\n\t\tcin >> m;\n\t\tfor(lli i=0;i<m;i++){\n\t\t\tstring ran;\n\t\t\tlli mp, da;\n\t\t\tcin >> ran >> mp >> ran >> da;\n\t\t\tif(ran == \"All\") a.push_back(P(da, mp));\n\t\t\telse s.push_back(P(da, mp));\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\tsort(a.begin(), a.end());\n\t\tfill(sm, sm+M+1, INF);\n\t\tfill(am, am+M+1, INF);\n\t\tsm[0] = am[0] = 0;\n\t\tfor(lli i=0;i<M;i++){\n\t\t\tfor(lli j=0;j<(lli)s.size();j++){\n\t\t\t\tlli nx = min(M, i + s[j].first);\n\t\t\t\tsm[nx] = min(sm[nx], sm[i] + s[j].second);\n\t\t\t}\n\t\t\tfor(lli j=0;j<(lli)a.size();j++){\n\t\t\t\tlli nx = min(M, i + a[j].first);\n\t\t\t\tam[nx] = min(am[nx], am[i] + a[j].second);\n\t\t\t}\n\t\t}\n\t\tlli valm[2] = {sm[M], am[M]};\n\t\tfor(lli i=M;i>=0;i--){\n\t\t\tvalm[0] = min(valm[0], sm[i]);\n\t\t\tvalm[1] = min(valm[1], am[i]);\n\t\t\tsm[i] = valm[0];\n\t\t\tam[i] = valm[1];\n\t\t}\n\t\tlli ans = INF;\n\t\tfor(lli i=0;i<=M;i++){\n\t\t\tlli tmp = am[i];\n\t\t\tfor(lli j=0;j<n;j++) tmp += sm[max(0LL, hp[j] - i)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n\n\n#define N_MAX 100\n#define M_MAX 100\n#define HP_MAX 100000\nusing namespace std;\n\nint N,M;\nint HP[N_MAX];\nint dp[2][HP_MAX+1];\nint A_dp[HP_MAX+1];//HP??????????????????MP???????°?????????????\nint S_dp[HP_MAX+1];\n\ntypedef pair<int,int> P;\n\nint main(){\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>HP[i];\n    cin>>M;\n    string s;\n    vector<P> A,S;//<MP,Damage>\n\n    for(int i=0;i<M;i++){\n        int m,d;\n        cin>>s>>m>>s>>d;\n        if(s[0]=='A'){\n            A.emplace_back(m,d);\n        }else{\n            S.emplace_back(m,d);\n        }\n    }\n    \n    fill_n(dp[0],HP_MAX+1,0);\n    fill_n(dp[1],HP_MAX+1,INT_MAX);\n    for(int i=0;i<A.size();i++){\n        for(int hp=0;hp<=HP_MAX;hp++){\n            if(i==0){\n                dp[0][hp]=A[0].first+(hp-A[0].second>=0?dp[0][hp-A[0].second]:0);\n            }else{\n                dp[i%2][hp]=min(dp[(i+1)%2][hp],hp-A[i].second>=0?dp[i%2][hp-A[i].second]+A[i].first:INT_MAX);\n            }\n        }\n    }\n    for(int i=0;i<=HP_MAX;i++) A_dp[i]=dp[(A.size()-1)%2][i];\n\n    fill_n(dp[0],HP_MAX+1,0);\n    fill_n(dp[1],HP_MAX+1,INT_MAX);\n    for(int i=0;i<S.size();i++){\n        for(int hp=0;hp<=HP_MAX;hp++){\n            if(i==0){\n                dp[0][hp]=S[0].first+(hp-S[0].second>=0?dp[0][hp-S[0].second]:0);\n            }else{\n                dp[i%2][hp]=min(dp[(i+1)%2][hp],hp-S[i].second>=0?dp[i%2][hp-S[i].second]+S[i].first:INT_MAX);\n            }\n        }\n    }\n    for(int i=0;i<=HP_MAX;i++) S_dp[i]=dp[(S.size()-1)%2][i];\n\n    int MP_min=INT_MAX;\n\n    for(int alldamage=0;alldamage<=HP_MAX;alldamage++){\n        int mp=A_dp[alldamage];\n        for(int i=0;i<N;i++){\n            int hp=HP[i];\n            hp-=alldamage;\n            if(hp>0){\n                mp+=S_dp[hp];\n            }\n        }\n        MP_min=min(MP_min,mp);\n    }\n    cout << MP_min << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int HSIZE=100001;\nconst int INF=1e9;\nusing ll = long long;\nll solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<int> smp,sdmg;\n    vector<int> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<int> sdp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+sdmg[i]<HSIZE) tmp[to][j+sdmg[i]]=min(tmp[to][j+sdmg[i]],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<int> adp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+admg[i]<HSIZE) tmp[to][j+admg[i]]=min(tmp[to][j+admg[i]],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    ll res=ll(1e15);\n    for(int i=0;i<HSIZE;i++){\n        ll sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc+=sdp[max(h[j]-i,0)];\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][100001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][100001];\nvector<Magic> allMagics;\nvector<Magic> singleMagics;\n\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tallMagics.clear();\n\t\tsingleMagics.clear();\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tmemset(dp2,-1,sizeof(dp2));\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\tif(magics[i].isAll)allMagics.push_back(magics[i]);\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=100000;j++)dp[i][j]=INF;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=100000;j++)dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<=h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n        int tmp = i - dmA[j];\n        if(tmp < 0) tmp = 0;\n        tA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n        int tmp = i - dmS[j];\n        if(tmp < 0) tmp = 0;\n        tS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n\n    /*\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n    memset(dpS, -1, sizeof(int)*h+1);\n    memset(dpA, -1, sizeof(int)*h+1);\n\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(dpS[dm] != -1) continue;\n      dpS[dm] = mp;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] == -1)\n          q.push(mpi(mm,dd));\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(dpA[dm] != -1) continue;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] == -1)\n          q.push(mpi(mm,dd));\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      if(dpA[i] == -1) dpA[i] = dpA[i+1];\n      else             dpA[i] = min(dpA[i+1], dpA[i]);\n\n      if(dpS[i] == -1) dpS[i] = dpS[i+1];\n      else             dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    */\n\n    int ans = INT_MAX;\n\n    REP(i,h+1){\n      int mp = dpA[i];\n      int dm = i;\n\n      REP(j,n)\n        if(hp[j] > dm)\n          mp += dpS[hp[j] - dm];\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nstruct magic { ll dam; ll cost; };\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tll h[100]; ll ma=0;\n\t\tvector<magic> m1, m2;\n\t\trep(i, n) {\n\t\t\tcin >> h[i]; ma = max(ma, h[i]);\n\t\t}\n\t\tint m; cin >> m;\n\t\trep(i, m) {\n\t\t\tstring x; ll c; string y; ll d;\n\t\t\tcin >> x >> c >> y >> d;\n\t\t\tif (y == \"Single\") {\n\t\t\t\tm1.push_back({ d,c });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm2.push_back({ d,c });\n\t\t\t}\n\t\t}\n\t\tll dp1[1000000], dp2[1000000];\n\t\tfill(dp1, dp1 + 1000000, INF);\n\t\tfill(dp2, dp2 + 1000000, INF);\n\t\tdp1[0] = dp2[0] = 0;\n\t\tint len1 = m1.size();\n\t\tint len2 = m2.size();\n\t\trep(i, len1) {\n\t\t\trep(j, 1000000) {\n\t\t\t\tint nex = j + (int)m1[i].dam;\n\t\t\t\tif (nex < 1000000) {\n\t\t\t\t\tdp1[nex] = min(dp1[nex], dp1[j] + m1[i].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, len2) {\n\t\t\trep(j, 1000000) {\n\t\t\t\tint nex = j + (int)m2[i].dam;\n\t\t\t\tif (nex < 1000000) {\n\t\t\t\t\tdp2[nex] = min(dp2[nex], dp2[j] + m2[i].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tper(i, 1000000) {\n\t\t\tif (i > 0) {\n\t\t\t\tdp1[i - 1] = min(dp1[i - 1], dp1[i]);\n\t\t\t\tdp2[i - 1] = min(dp2[i - 1], dp2[i]);\n\t\t\t}\n\t\t}\n\t\tll out = INF;\n\t\trep(i, 1000000) {\n\t\t\tll sum = dp2[i];\n\t\t\tif (sum == INF)continue;\n\t\t\trep(j, n) {\n\t\t\t\tll rest = h[j] - i;\n\t\t\t\tif (rest < 0)continue;\n\t\t\t\tsum += dp1[rest];\n\t\t\t}\n\t\t\tout = min(out, sum);\n\t\t}\n\t\tif (dp1[1] == INF) {\n\t\t\tout = dp2[ma];\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define INF (1e9)\n#define HP 30001\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;//mpcost,N,HP,Alldamage\ntypedef pair<int,P> P2;\n\nint n,hp[N],m,mp[N],damage[N];\nstring name,target[N];\nmap<P2,int> pam;\n\nint dijkstra(){\n  int r;\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  q.push(P1(P(0,0),P(0,0)));\n  pam[P2(0,P(0,0))]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int mpcost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int alldamage=t.second.second;\n    int d;\n    if(pam.find(P2(y,P(x,alldamage)))==pam.end())d=INF;\n    else d=pam[P2(y,P(x,alldamage))];\n    if(d<mpcost)continue;\n    if(y==n-1&&x>=hp[y]){\n      r=mpcost;\n      break;\n    }\n    if(x>=hp[y]){\n      if(pam.find(P2(y+1,P(alldamage,alldamage)))==pam.end())d=INF;\n      else d=pam[P2(y+1,P(alldamage,alldamage))];\n      if(d>mpcost){\n\tpam[P2(y+1,P(alldamage,alldamage))]=mpcost;\n\tq.push(P1(P(mpcost,y+1),P(alldamage,alldamage)));\n      }\n      continue;\n    }\n    for(int i=0;i<=m;i++){\n      int nmpcost=mpcost+mp[i];\n      int ny=y,nx=x+damage[i];\n      int nalldamage=alldamage;\n      if(target[i]==\"All\")nalldamage+=damage[i];\n      if(nx>hp[ny])nx=hp[ny];\n      if(pam.find(P2(ny,P(nx,nalldamage)))==pam.end())d=INF;\n      else d=pam[P2(ny,P(nx,nalldamage))];\n      if(d>nmpcost){\n\tpam[P2(ny,P(nx,nalldamage))]=nmpcost;\n\tq.push(P1(P(nmpcost,ny),P(nx,nalldamage)));\n      }\n    }\n  }\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    cout<<dijkstra()<<endl;\n    pam.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll MAX = 100001;\nconst ll INF = (1LL<<50);\nstruct Spell{\n  string name,tar;\n  ll MP,Dam;\n  Spell(){}\n  Spell(string n, ll m, string t, ll d):name(n),MP(m),tar(t),Dam(d){}\n};\n \nll dp[2][MAX];\nvector<ll> Enemy;\nvector<Spell> V[2];\nll N;\n \nvoid init(){\n  fill(dp[0],dp[0]+2*MAX,INF);\n \n  //for(ll i = 0; i < 2; i++) for(ll j = 0; j < MAX; j++) dp[i][j] = INF;\n  V[0].clear();\n  V[1].clear();\n  Enemy.clear();\n}\n \nvoid input(){\n \n  while(N--){\n    ll in;\n    cin >> in;\n    Enemy.push_back(in);\n  }\n \n  ll m;\n  cin >> m;\n  while(m--){\n    Spell s;\n    cin >> s.name >> s.MP >> s.tar >> s.Dam;\n    if(s.tar == \"All\") V[0].push_back(s);\n    else V[1].push_back(s);\n  }\n \n}\n \n \nvoid make(){\n \n  dp[0][0] = dp[1][0] = 0;\n \n  for(ll x = 0; x < 2; x++){\n    for(ll i = 0; i < MAX; i++){\n      if(dp[x][i] == INF) continue;\n      for(ll j = 0; j < V[x].size(); j++){\n        ll nex = min(i+V[x][j].Dam,100000LL);\n        ll cos = dp[x][i]+V[x][j].MP;\n        dp[x][nex] = min(dp[x][nex],cos);\n      }\n    }\n  }\n   \n  ll mincos[2];\n  mincos[0] = dp[0][MAX-1];\n  mincos[1] = dp[1][MAX-1];\n   \n  for(ll i = MAX-1; i >= 0; i--){\n    mincos[0] = min(mincos[0],dp[0][i]);\n    mincos[1] = min(mincos[1],dp[1][i]);\n    dp[0][i] = min(dp[0][i],mincos[0]);\n    dp[1][i] = min(dp[1][i],mincos[1]);\n  }\n}\n \nvoid solve(){\n \n  ll ans = INF;\n \n  for(ll i = 0; i < MAX; i++){\n \n    ll cos = dp[0][i];\n    for(ll j = 0; j < Enemy.size(); j++){\n      ll need = max(Enemy[j]-i,0LL);\n      cos+=dp[1][need];\n \n      //    cout << \"cos \" << dp[1][need] << endl;\n    }\n    ans = min(ans,cos);\n  }\n  cout << ans << endl;\n}\n \n \nint main(){\n \n  while(cin >> N && N){\n    init();\n    input();\n    make();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi hp(n);\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tvp a,b;\n\t\trep(i,m){\n\t\t\tstring c,d;int e,f;\n\t\t\tcin>>c>>e>>d>>f;\n\t\t\tif(d==\"Single\")a.pb(pii(e,f));\n\t\t\tif(d==\"All\")b.pb(pii(e,f));\n\t\t}\n\t\tvi dps(200000,inf),dpa(200000,inf);\n\t\tdps[0]=dpa[0]=0;\n\t\trep(i,a.size())rep(j,200000){\n\t\t\tint t=j-a[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdps[j]=min(dps[j],dps[t]+a[i].first);\n\t\t}\n\t\trep(i,b.size())rep(j,200000){\n\t\t\tint t=j-b[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdpa[j]=min(dpa[j],dpa[t]+b[i].first);\n\t\t}\n\t\tint out=inf;\n\t\trep(i,200000)if(dpa[i]!=inf){\n\t\t\tint sum=dpa[i];\n\t\t\trep(j,n){\n\t\t\t\tint t=hp[j]-i;\n\t\t\t\tif(t<=0)continue;\n\t\t\t\twhile(dps[t]==inf)t++;\n\t\t\t\tsum+=dps[t];\n\t\t\t}\n\t\t\tout=min(out,sum);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\nvector<magic> all;\nvector<magic> single;\nvector<magic> crit;\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tall.clear();\n\t\tsingle.clear();\n\t\tcrit.clear();\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tdp[0] = 0;\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF && i >= 0; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tif(mon[j] <= i) continue;\n\t\t\t\tprev += dp2[mon[j] - i];\n\t\t\t}\n\t\t\tif(prev < 0) continue;\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 1e5+10;\n\nint dp_s[N], dp_a[N];\n\nint mons[110];\n\nconst int INF = 1e9;\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = INF;\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tint *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\trep(j, N) dp[min(j + v, 100000)] = min(dp[min(j + v, 100000)], dp[j] + w);\n\t\t}\n\n\t\tfor (int i = N - 2; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, N){\n\t\t\tint tmp = dp_a[i];\n\t\t\tif (tmp == INF) continue;\n\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int MAX_N = 101;\nconst int MAX_DMG = 100001;\nconst int INF = 1<<24;\n\nint N;\nint hp[MAX_N];\nvector<P> ms, ma;\nint Ts[MAX_DMG], Ta[MAX_DMG];\n\nint solve() {\n  Ts[0] = Ta[0] = 0;\n  for(int d = 1; d < MAX_DMG; ++d) {\n    Ts[d] = Ta[d] = INF;\n    for(int i = 0; i < ms.size(); ++i) {\n      int t = max(0, d - ms[i].first);\n      Ts[d] = min(Ts[d], Ts[t] + ms[i].second);\n    }\n    for(int i = 0; i < ma.size(); ++i) {\n      if(d - ma[i].first < 0) continue;\n      int t = max(0, d - ma[i].first);\n      Ta[d] = min(Ta[d], Ta[t] + ma[i].second);\n    }\n  }\n\n  int res = INF;\n  for(int d = 0; d < MAX_DMG; ++d) {\n    if(Ta[d] == INF) continue;\n    int value = Ta[d];\n    for(int i = 0; i < N; ++i) {\n      value += Ts[max(0, hp[i]-d)];\n    }\n    res = min(res, value);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) cin >> hp[i];\n    int M;\n    cin >> M;\n    ms.clear(); ma.clear();\n    for(int i = 0; i < M; ++i) {\n      string name, target;\n      int mp, dmg;\n      cin >> name >> mp >> target >> dmg;\n      dmg = min(dmg, 100000);\n      if(target == \"Single\") {\n\tms.push_back(P(dmg, mp));\n      } else {\n\tma.push_back(P(dmg, mp));\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nvector<P>v1,v2;\nint a[101],dp1[100001],dp2[100001],n,t1,t2,t;\nstring s;\nmain(){\n\twhile(cin>>n,n){\n\t\tint ans=1e8;\n\t\tr(i,100001)dp1[i]=dp2[i]=1e6;\n\t\tdp1[0]=dp2[0]=0;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tr(i,n)cin>>a[i];\n\t\tcin>>t;\n\t\tr(i,t){\n\t\t\tcin>>s>>t1>>s>>t2;\n\t\t\tif(t2>100000)t2=100000;\n\t\t\tif(s==\"All\")v1.push_back(P(t1,t2));\n\t\t\telse v2.push_back(P(t1,t2));\n\t\t}\n\t\tr(i,v1.size())r(j,100001)if(j+v1[i].S<=100001)\n\t\t  dp1[j+v1[i].S]=min(dp1[j+v1[i].S],dp1[j]+v1[i].F);\n\t\t  else dp1[100000]=min(dp1[100000],dp1[j]+v1[i].F);\n\t\tr(i,v2.size())r(j,100001)if(j+v2[i].S<=100001)\n\t\t  dp2[j+v2[i].S]=min(dp2[j+v2[i].S],dp2[j]+v2[i].F);\n\t\t  else dp2[100000]=min(dp2[100000],dp2[j]+v1[i].F);\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tr(i,100001)if(dp1[i]!=1e8){\n\t\t\tint sum=0;\n\t\t\tr(j,n)if(a[j]-i>0)sum+=dp2[a[j]-i];\n\t\t\tans=min(ans,sum+dp1[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Spell {\n    int mp,target,damage;\n    Spell(int mp=0,int target=0,int damage=0) :\n        mp(mp),target(target),damage(damage){}\n\n};\n\nstruct State {\n    ll cost;\n    vector<int> HP;\n    State(int cost=0,const vector<int> &HP=vector<int>()):\n        cost(cost),HP(HP){}\n    bool operator<(const State& rhs) const {\n        return cost>rhs.cost;\n    }\n};\n\nint N;\nvector<int> HP;\nint M;\nSpell spells[102];\nll dijk() {\n    map<vector<int>,ll> d;\n    priority_queue<State> que;\n    que.push(State(0,HP));\n    d[HP]=0;\n    ll ans=1e18;\n    while(que.size()) {\n        State s=que.top(); que.pop();\n        if(s.HP.size()==0) {\n            ans=min(ans,s.cost);\n            break;\n        }\n        //cout<<s.cost<<\", \"<<s.HP.size()<<endl;\n        //if(d.count(s)) continue;\n\n        rep(i,M) {\n            vector<int> vec=s.HP;\n\n            if(spells[i].target==0) {\n                vec[0]-=spells[i].damage;\n            }\n            else {\n                rep(j,vec.size()) vec[j]-=spells[i].damage;\n            }\n            auto it=vec.begin();\n            while(it!=vec.end()) {\n                if(*it<=0) it=vec.erase(it);\n                else ++it;\n            }\n\n            State next(s.cost+spells[i].mp,vec);\n            if(!d.count(vec)||d[vec]>d[s.HP]+spells[i].mp) {\n                d[vec]=d[s.HP]+spells[i].mp;\n                que.push(next);\n            }\n        }\n    }\n\n    return ans;\n}\nint main() {\n    while(cin>>N) {\n        HP.clear();\n        if(!N) break;\n        HP.resize(N);\n        rep(i,N) cin>>HP[i];\n        cin>>M;\n        rep(i,M) {\n            string s1,s2;\n            int mp,damage;\n            cin>>s1>>mp>>s2>>damage;\n            int t=0;\n            if(s2==\"All\") t=1;\n            spells[i]=Spell(mp,t,damage);\n        }\n        cout<<dijk()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\nbool ok[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    /*\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<=h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n        int tmp = i - dmA[j];\n        if(tmp < 0) tmp = 0;\n        tA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n        int tmp = i - dmS[j];\n        if(tmp < 0) tmp = 0;\n        tS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    REP(i,h+1) dpS[i] = INT_MAX;\n    REP(i,h+1) dpA[i] = INT_MAX;\n\n    q.push(mpi(0,0));\n    REP(i,h+1) ok[i] = false;\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] > mm){\n          dpS[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n\n    REP(i,h+1) ok[i] = false;\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] > mm){\n          dpA[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    REP(i,h+1){\n      if(!ok[i]) continue;\n      int mp = dpA[i];\n      int dm = i;\n\n      REP(j,n)\n        if(hp[j] > dm)\n          mp += dpS[hp[j] - dm];\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m;\nll h[1111];\nmap<ll,ll> dpa,dpb;\nll na,nb;\nll ma[1111],mb[1111],da[1111],db[1111];\n\nll dfsa(ll i){\n  if(dpa.find(i)!=dpa.end())return dpa[i];\n  if(i==0)return 0;\n  ll res=INF;\n  rep(j,na){\n    minch(res,ma[j]+dfsa(mmax(i-da[j],0)));\n  }\n  return dpa[i]=res;\n}\n\nll dfsb(ll i){\n  if(dpb.find(i)!=dpb.end())return dpb[i];\n  if(i==0)return 0;\n  ll res=INF;\n  rep(j,nb){\n    minch(res,mb[j]+dfsb(mmax(i-db[j],0)));\n  }\n  return dpb[i]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    ll maxh=0;\n    rep(i,n){\n      cin>>h[i];\n      maxch(maxh,h[i]);\n    }\n    cin>>m;\n    na=0; nb=0;\n    rep(i,m){\n      string name,target;\n      ll mp,dmg;\n      cin>>name>>mp>>target>>dmg;\n      if(target==\"All\"){\n        ma[na]=mp; da[na]=dmg; na++;\n      }else{\n        mb[nb]=mp; db[nb]=dmg; nb++;\n      }\n    }\n    dpa.clear(); dpb.clear();\n    ll res=INF;\n    rep(ah,maxh+1){\n      ll sum=0;\n      rep(i,n){\n        sum+=dfsb(mmax(h[i]-ah,0LL));\n      }\n      minch(res,sum+dfsa(ah));\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n\n  char str[20];\n  int t[110];\n  int p[110];\n  int q[110];\n  int c[110];\n  int dp[2][110000];\n      int a;\n        while(cin >> a && a) { //N(??¢?????????????????°)???????????????\n\n                //N???????????¢???????????????HP(??????)???????????????\n                for(int i=0; i<a; i++) cin >> c[i];\n                int b;\n                cin >> b; //M(????????????????????°)???????????????\n                //Name(???????????????), MP(?¶????MP), Target(Single or All), Damage(????????????????????????)???????????????\n                for(int i=0; i<b; i++) {\n                        cin >> str >> p[i] >> str >> q[i]; //???????????????????????????Name???????????????????????????\n                        if(str[0]=='S') t[i]=1;\n                        else t[i]=0;\n                }\n\n                //????????? dp[Single -> 1 or All -> 0][????¨?????????????] = ????¨??¶????MP\n                for(int i=0; i<110000; i++) dp[0][i]=dp[1][i]=1999999999;\n                dp[0][0]=dp[1][0]=0;\n                for(int i=0; i<b; i++) {\n                        for(int j=0; j<110000; j++) {\n                                /**\n                                  * min??§109999??¨???????????????100000??\\?????§????????°?????¢???????????????????????§????????????????????????\n                                  * ?????????????????????(???????????????j+i?????????????????????????????????)?????¨??????MP?¶????????????¨\n                                  * (????????????j?????¨??????MP?¶???????+i??????????????????MP?¶???????)?????????\n                                  * ????????????i????????????????????????????????¨?????????MP?¶???????????°????????????°???\n                                  * ????????????????¶????MP???????´??????????\n                                **/\n                                dp[t[i]][min(109999,j+q[i])]=min(???dp[t[i]][min(109999,???j+q[i])],???dp[t[i]][j]+p[i]???);\n                        }\n                }\n\n                //??????????????¨??¨????????????????????§?????????????????????????????????????°?MP??????????±??????????\n                for(int i=109998; i>=0; i--) {\n                        dp[0][i]=min(dp[0][i],dp[0][i+1]);\n                        dp[1][i]=min(dp[1][i],dp[1][i+1]);\n                }\n\n                /**\n                  * ????????¢????????????1????????????????????¨????????????\n                  *\n                **/\n                long long ret=1999999999;\n                for(int i=0; i<110000; i++) {\n                        long long val=dp[0][i];\n                        for(int j=0; j<a; j++) {\n                                if(i>=c[j]) continue; //????????¢??????????????????????????????i(?????????????????????)?????§????????´???(???????????´??????)?????????????????????\n                                val+=dp[1][c[j]-i]; //?????£?????????????????????????????§????????¨????????????????°?MP???val????¶???????\n                        }\n                        ret=min(ret,val);???//???????¶??????????MP????°????????????????????´?\n                }\n                cout << ret << endl;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,cnt;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nvector<P> v;\n\nint bynary_search(int x){\n  int L=0,R=v.size();\n  while(L<R){\n    int M=(L+R)/2;\n    if(v[M].first>=x)R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++)\n      if(dpSin[i]!=INF)v.push_back(P(i,dpSin[i]));\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      cnt=dpAll[i];\n      for(int j=0;j<m;j++){\n\tint k=hp[j]-i;\n\tcnt+=v[bynary_search(k)].second;\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tmemset(mon, 0, sizeof(mon));\n\t\tmemset(mag, 0, sizeof(mag));\n\t\tvector<magic> all;\n\t\tvector<magic> single;\n\t\tvector<magic> crit;\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\t\t\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tint mon2[120];\n\t\t\tmemcpy(mon2, mon, sizeof(mon));\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tmon2[j] -= i;\n\t\t\t\tif(mon2[j] > 0) prev += dp2[mon2[j]];\n\t\t\t}\n\t\t\t\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid fillDP(const vector< pair<int, int> >& skills, vector<int>& dp, int size) {\n    dp.resize(size + 1);\n    fill(dp.begin(), dp.end(), INF);\n    dp[0] = 0;\n    for(auto itr = skills.begin(); itr != skills.end(); itr++) {\n        for(int i = 0; i <= size; i++) {\n            if(dp[i] == INF) {\n                continue;\n            }\n            int damage = min(i + itr->second, size);\n            dp[damage] = min(dp[damage], dp[i] + itr->first);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        int enemyNumber, skillNumber, maxHP;\n        vector<int> allDP, singleDP, hps;\n        vector< pair<int, int> > allSkills, singleSkills;\n\n        cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            int hp;\n            cin >> hp;\n            hps.push_back(hp);\n        }\n\n        cin >> skillNumber;\n        for(int i = 0; i < skillNumber; i++) {\n            int mp, damage;\n            string name, target;\n            cin >> name >> mp >> target >> damage;\n            if(target == \"All\") {\n                allSkills.push_back(make_pair(mp, damage));\n            } else {\n                singleSkills.push_back(make_pair(mp, damage));\n            }\n        }\n\n        maxHP = *max_element(hps.begin(), hps.end());\n        fillDP(allSkills, allDP, maxHP);\n        fillDP(singleSkills, singleDP, maxHP);\n\n        for(int i = maxHP; i > 0; i--) {\n            if(singleDP[i - 1] == INF) {\n                singleDP[i - 1] = singleDP[i];\n            }\n        }\n\n        int answer = INF;\n\n        for(int i = 0; i <= maxHP; i++) {\n            if(allDP[i] == INF) {\n                continue;\n            }\n\n            int cost = allDP[i];\n\n            for(auto itr = hps.begin(); itr != hps.end(); itr++) {\n                if(*itr - i > 0) {\n                    cost += singleDP[*itr - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n#define int long long\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=INT_MAX;\n\nint dp1[100010];\nint dp2[100010];\nvoid mainmain(){\n\tint n;\n\tint m;\n\twhile(cin>>n,n){\n\t\tvint hp(n);\n\t\trep(i,n) cin>>hp[i];\n\t\tcin>>m;\n\t\tvector<pii> one,all;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint a,b;\n\t\t\tcin>>a>>s>>b;\n\t\t\tif(s==\"Single\"){\n\t\t\t\tone.PB(mkp(a,b));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tall.PB(mkp(a,b));\n\t\t\t}\n\t\t}\n\t\t// cout<<\"aaa\\n\";\n\t\trep(i,100010){\n\t\t\tdp1[i]=INF;\n\t\t\tdp2[i]=INF;\n\t\t}\n\t\tdp1[0]=0;\n\t\t// cout<<\"size \"<<(int)one.size()<<endl;\n\t\trep(i,one.size()){\n\t\t\tint t=INF;\n\t\t\trep(j,100010){\n\t\t\t\tif(j+one[i].S>=100010){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tt=0;\n\t\t\t\t\t}\n\t\t\t\t\tdp1[100009]=min(dp1[100009],t+one[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp1[j]==INF) continue;\n\t\t\t\t// if(dp1[j]+one[i].F<0) continue;\n\t\t\t\tdp1[j+one[i].S]=min(dp1[j+one[i].S],dp1[j]+one[i].F);\n\t\t\t\tif(j+one[i].S*2>=100010) t=min(t,dp1[j+one[i].S]);\n\t\t\t}\n\t\t}\n\t\tint M=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\t// if(dp1[i]!=INF) cout<<\"dp1\"<<\" \"<<i<<\" \"<<dp1[i]<<endl;\n\t\t\tdp1[i]=min(dp1[i],M);\n\t\t\tM=min(dp1[i],M);\n\t\t}\n\t\tdp2[0]=0;\n\t\trep(i,all.size()){\n\t\t\t// cout<<i<<endl;\n\t\t\tint t=INF;\n\t\t\trep(j,100010){\n\t\t\t\tif(j+all[i].S>=100010){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tt=0;\n\t\t\t\t\t}\n\t\t\t\t\tdp2[100009]=min(dp2[100009],t+all[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp2[j]==INF) continue;\n\t\t\t\t// if(dp2[j]+all[i].F<0) continue;\n\t\t\t\tdp2[j+all[i].S]=min(dp2[j+all[i].S],dp2[j]+all[i].F);\n\t\t\t\tif(j+all[i].S*2>=100010) t=min(t,dp2[j+all[i].S]);\n\t\t\t}\n\t\t\t// cout<<t<<endl;\n\t\t}\n\t\tM=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\tdp2[i]=min(dp2[i],M);\n\t\t\tM=min(dp2[i],M);\n\t\t\t// if(i<100) cout<<\"dp2 \"<<i<<\" \"<<dp2[i]<<endl;\n\t\t}\n\t\t// cout<<\"M \"<<M<<endl;\n\t\t// cout<<\"hoge\\n\";\n\t\tint ans=INF;\n\t\trep(i,100010){\n\t\t\tint tmp=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tif(hp[j]<=i) continue;\n\t\t\t\ttmp+=dp1[hp[j]-i];\n\t\t\t}\n\t\t\tans=min(ans,tmp);\n\t\t}\n\t\t// cout<<\"dp1\\n\";\n\t\t// rep(i,50){\n\t\t\t// cout<<i<<\" \"<<dp1[i]<<endl;\n\t\t// }\n\t\t// cout<<\"dp2\"<<endl;\n\t\t// rep(i,50){\n\t\t\t// cout<<i<<\" \"<<dp2[i]<<endl;\n\t\t// }\n\t\t// cout<<ans<<endl;\n\t\t// cout<<dp1[100000]<<endl;\n\t\t// rep(i,n){\n\t\t\t// if(hp[i]-40221*3>0) cout<<hp[i]-40221*3<<endl;\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n\n}\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Magic{\npublic:\n  string name;\n  int mp;\n  string target;\n  int damage;\n};\nclass Monster{\npublic:\n  bool live;\n  int hp;\n  bool operator<(const Monster &s)const{\n    return hp<s.hp;\n  }\n};\n\nint n;\nMonster mons[100];\nint m;\nMagic magic[100];\nmain(){\n  while(1){\n    cin >> n;\n    if(n==0) break;\n\n    for(int i=0;i<n;i++){\n      cin >> mons[i].hp;\n      mons[i].live=true;\n    }\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> magic[i].name;\n      cin >> magic[i].mp;\n      cin >> magic[i].target;\n      cin >> magic[i].damage;\n    }\n    int monster=n;\n    int ans=0;\n    while(monster>0){\n      sort(mons, mons+n);\n      reverse(mons, mons+n);\n      int nmax;\n      double max=-1.0;\n      int t;\n      for(int i=0;i<m;i++){\n\tif(magic[i].target==\"Single\"){\n\t  for(int j=0;j<n;j++){\n\t    if(!mons[j].live) continue;\n\t    double tmp;\n\t    if(mons[j].hp>=magic[i].damage) tmp=(double)magic[i].damage;\n\t    else{\n\t      tmp=(double)mons[j].hp;\n\t      tmp+=(double)mons[j].hp-magic[i].damage;\n\t    }\n\t    tmp/=magic[i].mp;\n\t    if(max<tmp){\n\t      max=tmp;\n\t      nmax=i;\n\t    }\n\t    t=j;\n\t    break;\n\t  }\n\t}else{\n\t  double sum=0.0;\n\t  for(int j=0;j<n;j++){\n\t    if(!mons[j].live){\n\t      sum-=(double)magic[i].damage;\n\t    }\n\t    else if(mons[j].hp>=magic[i].damage) sum+=(double)magic[i].damage;\n\t    else{\n\t      sum+=(double)mons[j].hp;\n\t    }\n\t  }\n\t  sum/=magic[i].mp;\n\t  if(max<sum){\n\t    max=sum;\n\t    nmax=i;\n\t  }\n\t}\n      }\n      if(magic[nmax].target==\"Single\"){\n\tans+=magic[nmax].mp;\n\tmons[t].hp-=magic[nmax].damage;\n\tif(mons[t].hp<=0){\n\t  mons[t].live=false;\n\t  monster--;\n\t}\n      }else{\n\tans+=magic[nmax].mp;\n\tfor(int i=0;i<n;i++){\n\t  mons[i].hp-=magic[nmax].damage;\n\t  if(!mons[i].live) continue;\n\t  if(mons[i].hp<=0){\n\t    mons[i].live=false;\n\t    monster--;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    bool f=false;\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n      f|=s==0&&d;\n    }\n    long long as[2][100001]={};\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    long long mp=1LL<<62;\n    for(int i=0;i<mp;i++){\n      long long cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<(f?0:mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INFTY=1.01e9;\n\nstruct Spell{\n\tint m,d;\n\tSpell(){}\n\tSpell(int m,int d):m(m),d(d){}\n};\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n,n;){\n\t\tvector<int> hs(n);\n\t\tfor(int& h:hs) cin>>h;\n\t\tcin>>m;\n\t\tvector<Spell> ss,as; // single,all\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring n,t; int m,d;\n\t\t\tcin>>n>>m>>t>>d; chmin(d,100000);\n\t\t\tif(t==\"Single\") ss.emplace_back(m,d);\n\t\t\telse            as.emplace_back(m,d);\n\t\t}\n\t\t\n\t\tvector<int> sdp(100001,INFTY); sdp[0]=0;\n\t\tfor(int i=0;i<ss.size();i++){\n\t\t\tfor(int j=1;j<ss[i].d;j++)\n\t\t\t\tchmin(sdp[j],ss[i].m);\n\t\t\tfor(int j=ss[i].d;j<sdp.size();j++)\n\t\t\t\tchmin(sdp[j],sdp[j-ss[i].d]+ss[i].m);\n\t\t}\n\t\tvector<int> adp(100001,INFTY); adp[0]=0;\n\t\tfor(int i=0;i<as.size();i++){\n\t\t\tfor(int j=1;j<as[i].d;j++)\n\t\t\t\tchmin(adp[j],as[i].m);\n\t\t\tfor(int j=as[i].d;j<adp.size();j++)\n\t\t\t\tchmin(adp[j],adp[j-as[i].d]+as[i].m);\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint temp=adp[i];\n\t\t\tfor(int& h:hs)\n\t\t\t\ttemp+=sdp[max(h-i,0)];\n\t\t\tchmin(res,temp);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INF 20000000\n\nint main()\n{\n\tint N,M,HP[100];\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> HP[i];\n\t\t\t\n\t\tcin >> M;\n\t\tint ss[100], as[100],sd[100],ad[100],sn=0,an=0;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tstring n,t;\n\t\t\tint m,d;\n\t\t\tcin >> n >> m >> t >> d;\n\t\t\tif(d==0) continue;\n\t\t\t\n\t\t\tif(t==\"All\")\n\t\t\t{\n\t\t\t\tas[an]=m;\n\t\t\t\tad[an]=d;\n\t\t\t\tan++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss[sn]=m;\n\t\t\t\tsd[sn]=d;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shp[100001], ahp[100001];\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tshp[i]=INF;\n\t\t\tahp[i]=INF;\n\t\t}\n\t\tshp[0]=0; ahp[0]=0;\n\t\tfor(int i=0; i<sn; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+sd[i]>100000)\n\t\t\t{\n\t\t\t\tif(shp[j]==INF) continue;\n\t\t\t\tshp[100000]=min(shp[100000], shp[j]+ss[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tshp[j+sd[i]]=min(shp[j+sd[i]], shp[j]+ss[i]);\n\t\t}\n\t\t\n\t\tfor(int i=100000-1; i>=0; i--)\n\t\t\tshp[i]=min(shp[i+1], shp[i]);\n\t\t\n\t\tfor(int i=0; i<an; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+ad[i]>100000) \n\t\t\t{\n\t\t\t\tif(ahp[j]==INF) continue;\n\t\t\t\tahp[100000]=min(ahp[100000], ahp[j]+as[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tahp[j+ad[i]]=min(ahp[j+ad[i]], ahp[j]+as[i]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tif(ahp[i]==INF) continue;\n\t\t\tint tmp=ahp[i];\n\t\t\t\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(i>=HP[j]) continue;\n\t\t\t\ttmp+=shp[HP[j]-i];\n\t\t\t}\n\t\t\t\n\t\t\tans=min(ans, tmp);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tauto HP = read<int>(N);\n\n\t\tint maxHP = *max_element(allof(HP));\n\t\tvector<int> tableS(maxHP + 1, INF); // tableS[x] = 単体魔法でxダメージ与えるのに必要なMP\n\t\tvector<int> tableA(maxHP + 1, INF); // tableA[x] = 全体魔法でxダメージ与えるのに必要なMP\n\n\t\tREAD(int, M);\n\t\tREP(_, M)\n\t\t{\n\t\t\tstring name, type;\n\t\t\tint mp, dmg;\n\t\t\tcin >> name >> mp >> type >> dmg;\n\t\t\tvector<int> &tg = type[0] == 'A' ? tableA : tableS;\n\t\t\ttg[0] = 0;\n\t\t\tFOR(d, 1, maxHP + 1) { tg[d] = min(tg[d], tg[max(0, d - dmg)] + mp); }\n\t\t}\n\n\t\t// 全体魔法でd与えてから、単体魔法で倒してみることにしよう。\n\t\tlong result = LINF;\n\t\tREP(d, maxHP + 1)\n\t\t{\n\t\t\tlong cost = tableA[d];\n\t\t\tREP(i, HP.size())\n\t\t\t{\n\t\t\t\tcost += tableS[max(HP[i] - d, 0)];\n\t\t\t}\n\t\t\tresult = min(result, cost);\n\t\t\t//WRITE(\"d:\", d, \" MP:\", cost);\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid fillDP(const vector< pair<int, int> >& skills, vector<int>& dp, int size) {\n    dp.resize(size + 1);\n    fill(dp.begin(), dp.end(), INF);\n    dp[0] = 0;\n    for(auto itr = skills.begin(); itr != skills.end(); itr++) {\n        for(int i = 0; i <= size; i++) {\n            if(dp[i] == INF) {\n                continue;\n            }\n            int damage = min(i + itr->second, size);\n            dp[damage] = min(dp[damage], dp[i] + itr->first);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        int enemyNumber, skillNumber, maxHP;\n        vector<int> allDP, singleDP, hps;\n        vector< pair<int, int> > allSkills, singleSkills;\n\n        cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            int hp;\n            cin >> hp;\n            hps.push_back(hp);\n        }\n\n        cin >> skillNumber;\n        for(int i = 0; i < skillNumber; i++) {\n            int mp, damage;\n            string name, target;\n            cin >> name >> mp >> target >> damage;\n            if(target == \"All\") {\n                allSkills.push_back(make_pair(mp, damage));\n            } else {\n                singleSkills.push_back(make_pair(mp, damage));\n            }\n        }\n\n        maxHP = *max_element(hps.begin(), hps.end());\n        fillDP(allSkills, allDP, maxHP);\n        fillDP(singleSkills, singleDP, maxHP);\n\n        int minimum = INF;\n        for(int i = maxHP; i > 0; i--) {\n            minimum = min(minimum, singleDP[i]);\n            singleDP[i] = minimum;\n        }\n\n        int answer = INF;\n\n        for(int i = 0; i <= maxHP; i++) {\n            if(allDP[i] == INF) {\n                continue;\n            }\n\n            int cost = allDP[i];\n\n            for(auto itr = hps.begin(); itr != hps.end(); itr++) {\n                if(*itr - i > 0) {\n                    cost += singleDP[*itr - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 50000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n  \n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){    \n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n}\n\n\n\nvoid calc_all(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n  \n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){    \n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  }\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF;\n  calc_single(maxhp,mpsingle,damagesingle);\n  calc_all(maxhp,mpall,damageall);\n  \n\n\n\n  rep(i,maxhp){\n    if ( res_all[i]>=INF)continue;\n    int tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid calc(vector<int> &dp, const vector<int> &mp, const vector<int> &dm){\n  int m = dp.size();\n  int n = mp.size();\n  assert(mp.size() == dm.size());\n  \n  fill(ALL(dp), INF);\n  dp[0] = 0;\n  \n  REP(i, n){\n    REP(j, m){\n      int p = min(m - 1, j + dm[i]);\n      dp[p] = min(dp[p], dp[j] + mp[i]);\n    }\n    REP(j, m - 1){\n      dp[m-j-2] = min(dp[m-j-2], dp[m-j-1]);\n    }\n  }\n}\n\nint main(){\n  int n, m, mp, dm;\n  string name, range;\n  \n  while(cin >> n && n){\n    vector<int> enemy(n);\n    REP(i, n) cin >> enemy[i];\n  \n    cin >> m;\n    vector<int> mp_all, mp_single;\n    vector<int> dm_all, dm_single;\n  \n    REP(i, m){\n      cin >> name >> mp >> range >> dm;\n      if(range == \"All\"){\n        mp_all.push_back(mp);\n        dm_all.push_back(dm);\n      }else{\n        mp_single.push_back(mp);\n        dm_single.push_back(dm);\n      }\n    }\n\n    int M = *max_element(ALL(enemy)) + 1;\n\n    vector<int> dp_all(M);\n    vector<int> dp_single(M);\n\n    calc(dp_all, mp_all, dm_all);\n    calc(dp_single, mp_single, dm_single);\n\n\n    ll res = INF;\n    REP(i, M){\n      ll sum = dp_all[i];\n      REP(j, n){\n        int d = max(0, enemy[j] - i);\n        sum += dp_single[d];\n      }\n      res = min(res, sum);\n    }\n  \n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long INF = 1000000000000;\nint main(){\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    vector<int> HP(N);\n    for (int i = 0; i < N; i++){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<long long> dpS(1000000, INF);\n    dpS[0] = 0;\n    vector<long long> dpA(1000000, INF);\n    dpA[0] = 0;\n    for (int i = 0; i < M; i++){\n      string Name;\n      int MP;\n      string Target;\n      int Damage;\n      cin >> Name >> MP >> Target >> Damage;\n      if (Target == \"Single\"){\n        for (int j = 0; j < 1000000; j++){\n          dpS[j] = min(dpS[j], dpS[max(j - Damage, 0)] + MP);\n        }\n      }\n      if (Target == \"All\"){\n        for (int j = 0; j < 1000000; j++){\n          dpA[j] = min(dpA[j], dpA[max(j - Damage, 0)] + MP);\n        }\n      }\n    }\n    long long ans = INF;\n    for (int i = 0; i < 1000000; i++){\n      long long sum = dpA[i];\n      for (int j = 0; j < N; j++){\n        sum += dpS[max(HP[j] - i, 0)];\n      }\n      ans = min(ans, sum);\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int MAX_N = 101;\nconst int MAX_DMG = 100001;\nconst int INF = 1<<24;\n\nint N;\nint hp[MAX_N];\nvector<P> ms, ma;\nint Ts[MAX_DMG], Ta[MAX_DMG];\n\nint solve() {\n  Ts[0] = Ta[0] = 0;\n  for(int d = 1; d < MAX_DMG; ++d) {\n    Ts[d] = Ta[d] = INF;\n    for(int i = 0; i < ms.size(); ++i) {\n      int t = max(0, d - ms[i].first);\n      Ts[d] = min(Ts[d], Ts[t] + ms[i].second);\n    }\n    for(int i = 0; i < ma.size(); ++i) {\n      int t = max(0, d - ma[i].first);\n      Ta[d] = min(Ta[d], Ta[t] + ma[i].second);\n    }\n  }\n\n  int res = INF;\n  for(int d = 0; d < MAX_DMG; ++d) {\n    //    if(Ta[d] == INF) continue;\n    int value = Ta[d];\n    for(int i = 0; i < N; ++i) {\n      value += Ts[max(0, hp[i]-d)];\n    }\n    res = min(res, value);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) cin >> hp[i];\n    int M;\n    cin >> M;\n    ms.clear(); ma.clear();\n    for(int i = 0; i < M; ++i) {\n      string name, target;\n      int mp, dmg;\n      cin >> name >> mp >> target >> dmg;\n      dmg = min(dmg, 100000);\n      if(target == \"Single\") {\n\tms.push_back(P(dmg, mp));\n      } else {\n\tma.push_back(P(dmg, mp));\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\n\nusing namespace std;\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\n\nstruct state{\n\tstate():sum_mp(0),rest(0){}\n\tvector<int> vhp;\n\tint sum_mp;\n\tint rest;\n\tbool bComp()const{\n\t\tif(rest<=0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tbool operator<(const state &t)const{\n\t\treturn sum_mp<t.sum_mp;\n\t}\n\tint getHeuristic(double best_rate)const{\n\t\treturn (int)( rest / best_rate + 0.5 );\n\t}\n};\n\nostream &operator <<(ostream &os, const state &t){\n\tos<<\"HP: \";\n\tfor(unsigned int i=0;i<t.vhp.size();++i){\n\t\tos<<t.vhp[i]<<' ';\n\t}\n\tos<<\"\\nSUM MP: \"<<t.sum_mp<<\" REST HP: \" << t.rest;\n\treturn os;\n}\nvoid dfs(const state &now, const vector<magic> &vmag, double best_rate, int limit, int &best_ans){\n\tint n=now.vhp.size();\n\t\n\t//cout<<now<<endl;\n\t\n\tif( now.sum_mp+now.getHeuristic(best_rate) >= best_ans )\n\t\treturn ;\n\n\tif( now.bComp() ){\n\t\tbest_ans=min(best_ans,now.sum_mp);\n\t\treturn ;\n\t}\n\n\tfor(unsigned int i=0;i<vmag.size();++i){\n\t\tif( now.sum_mp+vmag[i].mp >= best_ans && now.sum_mp+vmag[i].mp<limit )\n\t\t\tcontinue;\n\n\t\tif(vmag[i].type==ALL){\n\t\t\tstate t = now;\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif( t.vhp[j] > 0 ){\n\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\tdfs(t,vmag,best_rate,limit,best_ans);\n\t\t}else{\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif( now.vhp[j]>0 ){\n\t\t\t\t\tstate t = now;\n\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\t\tdfs(t,vmag,best_rate,limit,best_ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ;\n}\nvoid solve(const state &ini, const vector<magic> &vmag, double best_rate, int &best_ans){\n\tint n=ini.vhp.size();\n\tpriority_queue< state > qs;\n\n\tqs.push( ini );\n\n\twhile( !qs.empty() ){\n\t\tstate st = qs.top();\n\t\tqs.pop();\n\n\t\tcout<<st<<endl;\n\t\tif( st.sum_mp+st.getHeuristic(best_rate) >= best_ans )\n\t\t\tbreak;\n\n\t\tif( st.bComp() ){\n\t\t\tbest_ans=min(best_ans,st.sum_mp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(unsigned int i=0;i<vmag.size();++i){\n\t\t\tif( st.sum_mp+vmag[i].mp >= best_ans )\n\t\t\t\tcontinue;\n\t\t\tif(vmag[i].type==ALL){\n\t\t\t\tstate t = st;\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( t.vhp[j] > 0 ){\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\tqs.push( t );\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( st.vhp[j]>0 ){\n\t\t\t\t\t\tstate t = st;\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\t\t\tqs.push( t );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tint ans=INFTY;\n\t\tdouble best_rate=0.0;\n\t\tvector<magic> vmagic;\n\t\tmagic magic_for_greedy;\n\t\tstate init;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tinit.rest+=t;\n\t\t\tinit.vhp.push_back(t);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint mp,type,damage;\n\t\t\tchar stype[17]=\"\";\n\n\t\t\tscanf(\"%*s%d%s%d\", &mp, stype, &damage);\n\n\t\t\tif(strcmp(stype,\"All\")==0)type=ALL;\n\t\t\telse type=SINGLE;\n\n\t\t\tif(damage>0&&mp==0){\n\t\t\t\tbest_rate=-2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(damage>0&&mp>0){\n\t\t\t\tmagic tm;\n\t\t\t\tif( best_rate < (double)damage*( type==ALL?n:1 )/mp ){\n\t\t\t\t\tbest_rate=(double)damage*( type==ALL?n:1 )/mp;\n\t\t\t\t\tmagic_for_greedy.damage=damage;\n\t\t\t\t\tmagic_for_greedy.mp=mp;\n\t\t\t\t\tmagic_for_greedy.type=type;\n\t\t\t\t}\n\t\t\t\ttm.damage=damage;tm.mp=mp;tm.type=type;\n\t\t\t\tvmagic.push_back( tm );\n\t\t\t}\n\t\t}\n\n\t\tif( magic_for_greedy.type == ALL ){\n\t\t\tint hp_max = 0;\n\t\t\tfor(unsigned int i = 0; i < init.vhp.size(); ++i){\n\t\t\t\thp_max = max( hp_max, init.vhp[i] );\n\t\t\t}\n\t\t\tans=magic_for_greedy.mp * ((hp_max%magic_for_greedy.damage?1:0)+hp_max/magic_for_greedy.damage);\n\t\t}else{\n\t\t\tans=0;\n\t\t\tfor(unsigned int i = 0; i < init.vhp.size(); ++i){\n\t\t\t\tans+=magic_for_greedy.mp * ((init.vhp[i]%magic_for_greedy.damage?1:0)+init.vhp[i]/magic_for_greedy.damage);\n\t\t\t}\n\t\t}\n\n\t\tif( best_rate<0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tans=INFTY;\n\t\tfor(int i = 0; i < INFTY; i+=1000){\n\t\t\tdfs(init,vmagic,best_rate,i,ans);\n\t\t\tif(ans<INFTY)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n\tmpA.push_back(mp);\n\tdmA.push_back(dm);\t\n      }else{\n\tmpS.push_back(mp);\n\tdmS.push_back(dm);\t\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n\tint tmp = i - dmA[j];\n\tif(tmp < 0) tmp = 0;\n\ttA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n\tint tmp = i - dmS[j];\n\tif(tmp < 0) tmp = 0;\n\ttS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n\n    int ans = INT_MAX;\n\n    REP(i,h){\n      int mp = dpA[i];\n      int dm = i;\n\n      REP(j,n)\n\tif(hp[j] > dm)\n\t  mp += dpS[hp[j] - dm];\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000007\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<long long,int> P;\n\nint n, M;\nint hp[100];\nP x[2][100];\nlong long dp[2][100001];\n\nvoid solve(){\n\trep(i,n) cin >> hp[i];\n\trep(i,2) for(int j = 0; j <= 100000; j++) dp[i][j] = INF;\n\tdp[0][0] = 0; dp[1][0] = 0;\n\tcin >> M;\n\tint m[2] = {0,0};\n\trep(i,M){\n\t\tstring na, tar;\n\t\tint mp, dam, u = 0;\n\t\tcin >> na >> mp >> tar >> dam;\n\t\tif(tar[0] == 'A') u = 1;\n\t\tx[u][m[u]] = P(mp,dam);\n\t\tm[u]++;\n\t}\n\trep(u,2){\n\t\trep(i,m[u]){\n\t\t\tP p = x[u][i];\n\t\t\tfor(int j = 0; j <= 100000; j++){\n\t\t\t\tif(j < p.second) dp[u][j] = min(dp[u][j],p.first);\n\t\t\t\telse dp[u][j] = min(dp[u][j],dp[u][j-p.second]+p.first);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = INF;\n\tfor(int i = 0; i <= 100000; i++){\n\t\tlong long cnt = dp[1][i];\n\t\trep(j,n){\n\t\t\tif(hp[j]-i <= 0) continue;\n\t\t\tint h = hp[j]-i;\n\t\t\tcnt += dp[0][h];\n\t\t}\n\t\tans = min(ans,cnt);\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#define INF 1e8\nusing namespace std;\n\nint n,m;\nint hp[101];\nint dp[2][100001];\nint mp[101],t[101],d[101];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&hp[i]);\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str,st2;\n\t\t\tcin >> str >> mp[i] >> st2 >> d[i];\n\t\t\tif(st2==\"Single\")t[i]=0;\n\t\t\telse t[i]=1;\n\t\t}\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tdp[0][i]=dp[1][i]=INF;\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tdp[i][0]=0;\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tif(dp[i][j]<INF){\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(t[k]==i){\n\t\t\t\t\t\t\tdp[i][min(j+d[k],100000)]=min(dp[i][min(j+d[k],100000)],dp[i][j]+mp[k]);\n\t\t\t\t\t\t\t//printf(\"%d %d %d\\n\",i,min(j+d[k],100000),dp[i][min(j+d[k],100000)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=100000;j>=1;j--){\n\t\t\t\tif(dp[i][j]<dp[i][j-1])dp[i][j-1]=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint cost=dp[1][i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(hp[j]>i)cost+=dp[0][hp[j]-i];\n\t\t\t}\n\t\t\tres=min(res,cost);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint h[100];\nvector<pair<int, int>> s, a;\nlong long dp[100010];\nlong long dp2[100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring na, ta;\n\t\t\tint mp, da;\n\t\t\tcin >> na >> mp >> ta >> da;\n\t\t\t(ta == \"Single\" ? s : a).emplace_back(mp, da);\n\t\t}\n\n\t\tfill_n(dp, 100010, 1ll << 60);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < s.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < s[i].second ? 0 : dp[j - s[i].second];\n\t\t\t\tdp[j] = min<long long>(dp[j], t + s[i].first);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp2, 100010, 1ll << 60);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < a.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tint t = j < a[i].second ? 0 : dp2[j - a[i].second];\n\t\t\t\tdp2[j] = min<long long>(dp2[j], t + a[i].first);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 1 << 28;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tint sum = dp2[i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i <= h[j]) sum += dp[h[j] - i];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> HP(N);\n    for(int i = 0; i < N; ++i){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<int> single_d, single_mp, all_d, all_mp;\n    string name, target;\n    int mp, damege;\n    for(int i = 0; i < M; ++i){\n      cin >> name >> mp >> target >> damege;\n      if(target == \"Single\"){\n        single_d.push_back(damege);\n        single_mp.push_back(mp);\n      }else{\n        all_d.push_back(damege);\n        all_mp.push_back(mp);\n      }\n    }\n    int INF = 1e9, n = 2e5;\n    vector<int> dp1(n,INF), dp2(n,INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < single_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp1[j] >= INF) continue;\n        if(j + single_d[i] < n)\n          dp1[j + single_d[i]] = min(dp1[j + single_d[i]], dp1[j] + single_mp[i]);\n        else\n          dp1[n-1] = min(dp1[n-1], dp1[j] + single_mp[i]);\n      }\n    }\n    for(int i = n-2; i >= 0; --i) dp1[i] = min(dp1[i], dp1[i+1]);\n    for(int i = n-2; i >= 0; --i) dp2[i] = min(dp2[i], dp2[i+1]);\n    \n    for(int i = 0; i < all_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp2[j] >= INF) continue;\n        if(j + all_d[i] < n)\n          dp2[j + all_d[i]] = min(dp2[j + all_d[i]], dp2[j] + all_mp[i]);\n      }\n    }\n    long long int ans = 1e15;\n    for(int i = 0; i < n; ++i){\n      if(dp2[i] >= INF) continue;\n      long long int t = dp2[i];\n      for(int j = 0; j < N; ++j){\n        t += dp1[max(0,HP[j] - i)];\n      }\n      ans = min(ans,t);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nint single[100010] = {};\nint multi[100010] = {};\nint hp[110];\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tfor(int i = 0 ; i < 100010 ; i++) single[i] = 1e9;\n\t\tfor(int i = 0 ; i < 100010 ; i++) multi[i] = 1e9;\n\t\tsingle[0] = multi[0] = 0;\n\t\tfor(int i = 0 ; i < N ; i++)\n\t\t\tcin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring target;\n\t\t\tint dmg;\n\t\t\tcin >> name >> mp >> target >> dmg;\n\t\t\tif( target == \"Single\" ){\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\t\tsingle[t] = min(single[j+dmg],single[j]+mp);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\t\tmulti[t] = min(multi[t],multi[j]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 100000 ; j >= 0 ; j--){\n\t\t\tsingle[j] = min(single[j+1],single[j]);\n\t\t\tmulti[j] = min(multi[j+1],multi[j]);\n\t\t}\n\t\t\t\n\t\tlong long ans = 1e9;\n\t\tfor(int i = 0 ; i <= 100000 ; i++){\n\t\t\tlong long sub = multi[i];\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint r = max(0,hp[j]-i);\n\t\t\t\tsub += single[r];\n\t\t\t}\n\t\t\tans = min(sub,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nclass Magic{\npublic:\n  string name;\n  int mp;\n  string target;\n  int damage;\n};\nclass Monster{\npublic:\n  bool live;\n  int hp;\n  bool operator<(const Monster &s)const{\n    return hp<s.hp;\n  }\n};\n\nint n;\nMonster mons[100];\nint m;\nMagic magic[100];\nmain(){\n  while(1){\n    cin >> n;\n    if(n==0) break;\n\n    for(int i=0;i<n;i++){\n      cin >> mons[i].hp;\n      mons[i].live=true;\n    }\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> magic[i].name;\n      cin >> magic[i].mp;\n      cin >> magic[i].target;\n      cin >> magic[i].damage;\n    }\n    int monster=n;\n    int ans=0;\n    while(monster>0){\n      sort(mons, mons+n);\n      reverse(mons, mons+n);\n      int nmax;\n      double max=-1.0;\n      int t;\n      for(int i=0;i<m;i++){\n\tif(magic[i].target==\"Single\"){\n\t  for(int j=0;j<n;j++){\n\t    if(!mons[j].live) continue;\n\t    double tmp;\n\t    if(mons[j].hp>=magic[i].damage) tmp=(double)magic[i].damage;\n\t    else{\n\t      tmp=(double)mons[j].hp;\n\t      tmp+=(double)mons[j].hp-magic[i].damage;\n\t    }\n\t    tmp/=magic[i].mp;\n\t    if(max<tmp){\n\t      max=tmp;\n\t      nmax=i;\n\t    }\n\t    t=j;\n\t    break;\n\t  }\n\t}else{\n\t  double sum=0.0;\n\t  for(int j=0;j<n;j++){\n\t    if(!mons[j].live){\n\t      sum-=(double)magic[i].damage;\n\t    }\n\t    else if(mons[j].hp>=magic[i].damage) sum+=(double)magic[i].damage;\n\t    else{\n\t      sum+=(double)mons[j].hp;\n\t    }\n\t  }\n\t  sum/=magic[i].mp;\n\t  if(max<sum){\n\t    max=sum;\n\t    nmax=i;\n\t  }\n\t}\n      }\n      if(magic[nmax].target==\"Single\"){\n\tans+=magic[nmax].mp;\n\tmons[t].hp-=magic[nmax].damage;\n\tif(mons[t].hp<=0){\n\t  mons[t].live=false;\n\t  monster--;\n\t}\n      }else{\n\tans+=magic[nmax].mp;\n\tfor(int i=0;i<n;i++){\n\t  mons[i].hp-=magic[nmax].damage;\n\t  if(!mons[i].live) continue;\n\t  if(mons[i].hp<=0){\n\t    mons[i].live=false;\n\t    monster--;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100000;\nint n, h[100], dp[MX], dp2[MX];\nint m, w[100], v[100];\nbool single[100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> h[i];\n\t\tcin >> m;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s >> w[i] >> s >> v[i];\n\t\t\tif(s == \"Single\") single[i] = 1;\n\t\t}\n\t\t\n\t\trep(i, MX) dp[i] = dp2[i] = inf;\n\t\tdp[0] = dp2[0] = 0;\n\t\trep(i, m) if(!single[i]) rep(j, MX){\n\t\t\tint nj = min(MX - 1, j + v[i]);\n\t\t\tdp[nj] = min(dp[nj], dp[j] + w[i]);\n\t\t}\n\t\trep(i, m) if(single[i]) rep(j, MX){\n\t\t\tint nj = min(MX - 1, j + v[i]);\n\t\t\tdp2[nj] = min(dp[nj], dp2[j] + w[i]);\n\t\t}\n\t\tfor(int i = MX - 2; i >= 0; i--) dp2[i] = min(dp2[i], dp2[i + 1]);\n\t\t\n\t\tll ans = inf;\n\t\trep(i, MX){\n\t\t\tll tmp = dp[i];\n\t\t\trep(j, n) if(h[j] > i) tmp += dp2[h[j] - i];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nstruct node{\n  int mp;\n  vector<int> enemy;\n  int hp;\n  node(int m,vector<int>v,int h):mp(m), enemy(v),hp(h){}\n  bool operator > (const node &e) const{\n    if(mp!=e.mp)\n      return mp>e.mp;\n    else\n      return hp>e.mp;\n  }\n\n};\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n  {\n    vector<int> enemy;\n    int sum=0;\n    for(int i=0;i<n;i++)\n      {\n\tint tmp;\n\tcin>>tmp;\n\tenemy.push_back(tmp);\n\tsum+=tmp;\n      }\n    int m;\n    cin>>m;\n    int mp[m];\n    bool all[m];\n    int damege[m];\n    for(int i=0;i<m;i++)\n      {\n\tstring name,tmp;\n\tcin>>name>>mp[i]>>tmp>>damege[i];\n\t//\tcout<<tmp<<endl;\n\tall[i]=(tmp==\"All\");\n      }\n    priority_queue<node,vector<node>,greater<node> >P;\n    P.push(node(0,enemy,sum));\n    while(!P.empty())\n      {\n\n\tnode tmp=P.top();\n\tP.pop();\n\t/*\n\tcout<<\"mp:\"<<tmp.mp<<endl;\n\tcout<<\"sumhp:\"<<tmp.hp<<endl;\n\tfor(int j=0;j<tmp.enemy.size();j++)\n\t  {\n\t    cout<<tmp.enemy[j]<<endl;\n\t    //cout<<enemy[j]<<endl;\n\t  }\n\t*/\n\tif(tmp.hp<=0)\n\t  {\n\t    cout<<tmp.mp<<endl;\n\t    break;\n\t  }\n\tfor(int i=0;i<m;i++)\n\t  {\n\t    int tmp_mp=tmp.mp;\n\t    vector<int>tmp_e=tmp.enemy;\n\t    int tmp_hp=tmp.hp;\n\t    tmp_mp+=mp[i];\n\t    if(all[i])\n\t      {\n\t\t//\tcout<<i<<\"=true\"<<endl;;\n\t\tfor(int j=0;j<tmp_e.size();j++)\n\t\t  {\n\t\t    if(tmp_e[j]>0)\n\t\t      {\n\t\t\tif(tmp_e[j]<damege[i])\n\t\t\t  {\n\t\t\t    tmp_hp-=tmp_e[j];\n\t\t\t    tmp_e[j]=0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    tmp_e[j]-=damege[i];\n\t\t\t    tmp_hp-=damege[i];\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t\tP.push(node(tmp_mp,tmp_e,tmp_hp));\n\t      }\n\t    else\n\t      {\n\t\t//\tcout<<i<<\"=false\"<<endl;;\n\t\tfor(int j=0;j<tmp_e.size();j++)\n\t\t  {\n\t\t    if(tmp_e[j]>0)\n\t\t      {\n\t\t\tint subnum;\n\t\t\tif(tmp_e[j]<damege[i])\n\t\t\t  subnum=tmp_e[j];\n\t\t\telse\n\t\t\t  subnum=damege[i];\n\t\t\ttmp_e[j]-=subnum;\n\t\t\tP.push(node(tmp_mp,tmp_e,tmp_hp-subnum));\n\t\t\ttmp_e[j]+=subnum;\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n\t\n      }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<map>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint hp[100];\nint dp1[100005];\nint dp2[100005];\nconst int inf = 1<<29;\npair<int, int> smagic[100];\npair<int, int> amagic[100];\n\nint main() {\n    int N,M,i,j,k,mp,dm,am,sm,maxhp;\n    string name,range;\n    while(cin>>N, N) {\n        memset(hp, 0, sizeof(hp));\n        rep(i,100005) dp1[i] = dp2[i] = inf;\n        am = sm = maxhp = 0;\n        rep(i,N) cin>>hp[i];\n        rep(i,N) maxhp = max(maxhp, hp[i]);\n        cin>>M;\n\n        rep(i,M) {\n            cin>>name>>mp>>range>>dm;\n            if(range == \"All\") {\n                amagic[am] = make_pair(mp,dm);\n                am++;\n            }else{\n                smagic[sm] = make_pair(mp,dm);\n                sm++;\n            }\n        }\n\n        dp1[0] = dp2[0] = 0;\n        rep(i,maxhp+1) {\n            rep(j,am) {\n                if(dp1[i] == inf) continue;\n                int h = min(maxhp, i+amagic[j].second);\n                dp1[h] = min(dp1[h],\n                             dp1[i]+amagic[j].first);\n            }\n            rep(j,sm) {\n                if(dp2[i] == inf) continue;\n                int h = min(maxhp, i+smagic[j].second);\n                dp2[h] = min(dp2[h],\n                             dp2[i]+smagic[j].first);\n            }\n        }\n\n\n        int smax = inf,amax = inf;\n        for(i = 100004; i>=0; --i) {\n            if(smax > dp2[i]) smax = dp2[i];\n            if(amax > dp1[i]) amax = dp1[i];\n            if(dp2[i] > smax) dp2[i] = smax;\n            if(dp1[i] > amax) dp1[i] = amax;\n        }\n\n        int ans = inf;\n        for(int i=maxhp; i>=0; --i) {\n            //cout<<i<<\" \"<<ans<<endl;\n            int tmp = dp1[i],j;\n            rep(j,N) {\n                if(hp[j]-i > 0) tmp += dp2[hp[j]-i];\n            }\n            //cout<<ans<<\" \"<<tmp<<endl;\n            ans = min(tmp, ans);\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\n\nusing namespace std;\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\n\nstruct state{\n\tstate():sum_mp(0),rest(0){}\n\tvector<int> vhp;\n\tint sum_mp;\n\tint rest;\n\tbool bComp()const{\n\t\tif(rest<=0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tbool operator<(const state &t)const{\n\t\treturn sum_mp<t.sum_mp;\n\t}\n\tint getHeuristic(double best_rate)const{\n\t\treturn (int)( rest / best_rate + 0.5 );\n\t}\n};\n\nostream &operator <<(ostream &os, const state &t){\n\tos<<\"HP: \";\n\tfor(unsigned int i=0;i<t.vhp.size();++i){\n\t\tos<<t.vhp[i]<<' ';\n\t}\n\tos<<\"\\nSUM MP: \"<<t.sum_mp<<\" REST HP: \" << t.rest;\n\treturn os;\n}\n\nvoid solve(const state &ini, const vector<magic> &vmag, double best_rate, int &best_ans){\n\tint n=ini.vhp.size();\n\tqueue< state > qs;\n\n\tqs.push( ini );\n\n\twhile( !qs.empty() ){\n\t\tstate st = qs.front();\n\t\tqs.pop();\n\n\t\tcout<<st<<endl;\n\t\tif( st.sum_mp+st.getHeuristic(best_rate) >= best_ans )\n\t\t\tcontinue;\n\n\t\tif( st.bComp() ){\n\t\t\tbest_ans=min(best_ans,st.sum_mp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(unsigned int i=0;i<vmag.size();++i){\n\t\t\tif( st.sum_mp+vmag[i].mp >= best_ans )\n\t\t\t\tcontinue;\n\t\t\tif(vmag[i].type==ALL){\n\t\t\t\tstate t = st;\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( t.vhp[j] > 0 ){\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\tqs.push( t );\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif( st.vhp[j]>0 ){\n\t\t\t\t\t\tstate t = st;\n\t\t\t\t\t\tt.rest-=min(t.vhp[j],vmag[i].damage);\n\t\t\t\t\t\tt.vhp[j]-=vmag[i].damage;\n\t\t\t\t\t\tt.sum_mp+=vmag[i].mp;\n\t\t\t\t\t\tif( t.sum_mp+t.getHeuristic(best_rate)<best_ans )\n\t\t\t\t\t\t\tqs.push( t );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tint ans=INFTY;\n\t\tdouble best_rate=0.0;\n\t\tvector<magic> vmagic;\n\t\tmagic magic_for_greedy;\n\t\tstate init;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tinit.rest+=t;\n\t\t\tinit.vhp.push_back(t);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint mp,type,damage;\n\t\t\tchar stype[17]=\"\";\n\n\t\t\tscanf(\"%*s%d%s%d\", &mp, stype, &damage);\n\n\t\t\tif(strcmp(stype,\"All\")==0)type=ALL;\n\t\t\telse type=SINGLE;\n\n\t\t\tif(damage>0&&mp==0){\n\t\t\t\tbest_rate=-2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(damage>0&&mp>0){\n\t\t\t\tmagic tm;\n\t\t\t\tif( best_rate < (double)damage*( type==ALL?n:1 )/mp ){\n\t\t\t\t\tbest_rate=(double)damage*( type==ALL?n:1 )/mp;\n\t\t\t\t\tmagic_for_greedy.damage=damage;\n\t\t\t\t\tmagic_for_greedy.mp=mp;\n\t\t\t\t\tmagic_for_greedy.type=type;\n\t\t\t\t}\n\t\t\t\ttm.damage=damage;tm.mp=mp;tm.type=type;\n\t\t\t\tvmagic.push_back( tm );\n\t\t\t}\n\t\t}\n\n\t\tif( magic_for_greedy.type == ALL ){\n\t\t\tint hp_max = 0;\n\t\t\tfor(unsigned int i = 0; i < init.vhp.size(); ++i){\n\t\t\t\thp_max = max( hp_max, init.vhp[i] );\n\t\t\t}\n\t\t\tans=magic_for_greedy.mp * ((hp_max%magic_for_greedy.damage?1:0)+hp_max/magic_for_greedy.damage);\n\t\t}else{\n\t\t\tans=0;\n\t\t\tfor(unsigned int i = 0; i < init.vhp.size(); ++i){\n\t\t\t\tans+=magic_for_greedy.mp * ((init.vhp[i]%magic_for_greedy.damage?1:0)+init.vhp[i]/magic_for_greedy.damage);\n\t\t\t}\n\t\t}\n\n\t\tif( best_rate<0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsolve(init,vmagic,best_rate,ans);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\n#define INF 1000000000\n\nstruct spell{\n  int mp;\n  int damage;\n};\n\nstruct spell sps[100],spa[100];\nint dps[100001],dpa[100001];\n\nint main(){\n  int n;\n  cin >> n;\n  vector<int> hp(n);\n  for(int i=0;i<n;i++){\n    cin >> hp[i];\n  }\n  int m;\n  cin >> m;\n  int counts=0,counta=0;\n  string name,target;\n  int mp,damage;\n  for(int i=0;i<n;i++){\n    cin >> name >> mp >> target >> damage;\n    if(target==\"Single\"){\n      sps[counts]={mp,damage};\n      counts++;\n    }else{\n      spa[counta]={mp,damage};\n      counta++;\n    }\n  }\n  for(int i=0;i<100001;i++){\n    dpa[i]=dps[i]=INF;\n  }\n  dpa[0]=dps[0]=0;\n  for(int i=1;i<100001;i++){\n    for(int j=0;j<counts;j++){\n      if(i-sps[j].damage<0){\n        dps[i]=min(dps[i],sps[j].mp);\n      }else{\n        dps[i]=min(dps[i],dps[i-sps[j].damage]+sps[j].mp);\n      }\n    }\n  }\n  for(int i=1;i<100001;i++){\n    for(int j=0;j<counta;j++){\n      if(i-spa[j].damage<0){\n        dpa[i]=min(dpa[i],spa[j].mp);\n      }else{\n        dpa[i]=min(dpa[i],dpa[i-spa[j].damage]+spa[j].mp);\n      }\n    }\n  }\n  int ans=INF;\n  int count;\n  for(int i=0;i<100001;i++){\n    count=dpa[i];\n    for(int j=0;j<n;j++){\n      count+=(hp[j]-i>=0?dps[hp[j]-i]:0);\n    }\n    ans=min(ans,count);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX = 1e6;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<int> hp(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> hp[i];\n\t\t}\n\t\tsort(hp.begin(), hp.end());\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<ll> dp_s(MAX + 1, 1e17);\n\t\tvector<ll> dp_a(MAX + 1, 1e17);\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring sp, ta;\n\t\t\tint mp, dm;\n\t\t\tcin >> sp >> mp >> ta >> dm;\n\t\t\tif (ta == \"Single\") {\n\t\t\t\tfor (int i = 0; i <= MAX; i++) {\n\t\t\t\t\tint t = min(MAX, i + dm);\n\t\t\t\t\tdp_s[t] = min(dp_s[t], dp_s[i] + mp);\n\t\t\t\t}\n\t\t\t\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\t\t\t\tdp_s[i] = min(dp_s[i + 1], dp_s[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i <= MAX; i++) {\n\t\t\t\t\tint t = min(MAX, i + dm);\n\t\t\t\t\tdp_a[t] = min(dp_a[t], dp_a[i] + mp);\n\t\t\t\t}\n\t\t\t\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\t\t\t\tdp_a[i] = min(dp_a[i + 1], dp_a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = LLONG_MAX;\n\t\tfor (int i = 0; i <= MAX; i++) {\n\t\t\tll val = dp_a[i];\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tval += dp_s[max(0, hp[j] - i)];\n\t\t\t}\n\t\t\tres = min(res, val);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define INF (1e9)\n#define HP 100001\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;//mpcost,N,HP,Alldamage\ntypedef pair<int,P> P2;\n\nint n,hp[N],m,mp[N],damage[N];\nstring name,target[N];\nmap<P2,int> pam;\n\nint dijkstra(){\n  int r;\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  q.push(P1(P(0,0),P(0,0)));\n  pam[P2(0,P(0,0))]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int mpcost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int alldamage=t.second.second;\n    int d;\n    if(pam.find(P2(y,P(x,alldamage)))==pam.end())d=INF;\n    else d=pam[P2(y,P(x,alldamage))];\n    if(d<mpcost)continue;\n    if(y==n-1&&x>=hp[y]){\n      r=mpcost;\n      break;\n    }\n    if(x>=hp[y]){\n      if(pam.find(P2(y+1,P(alldamage,alldamage)))==pam.end())d=INF;\n      else d=pam[P2(y+1,P(alldamage,alldamage))];\n      if(d>mpcost){\n\tpam[P2(y+1,P(alldamage,alldamage))]=mpcost;\n\tq.push(P1(P(mpcost,y+1),P(alldamage,alldamage)));\n      }\n      continue;\n    }\n    for(int i=0;i<=m;i++){\n      int nmpcost=mpcost+mp[i];\n      int ny=y,nx=x+damage[i];\n      int nalldamage=alldamage;\n      if(target[i]==\"All\")nalldamage+=damage[i];\n      if(nx>hp[ny])nx=hp[ny];\n      if(pam.find(P2(ny,P(nx,nalldamage)))==pam.end())d=INF;\n      else d=pam[P2(ny,P(nx,nalldamage))];\n      if(d>nmpcost){\n\tpam[P2(ny,P(nx,nalldamage))]=nmpcost;\n\tq.push(P1(P(nmpcost,ny),P(nx,nalldamage)));\n      }\n    }\n  }\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    cout<<dijkstra()<<endl;\n    pam.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n#define inf 1000000000000000\n\nusing namespace std;\ntypedef pair<long long, long long> P;\n\nlong long N, M;\nlong long HP[105];\nvector<P> sing, all;\nlong long dp_sing[100005], dp_all[100005];\n\nvoid calc(long long dp[100005], vector<P> &vec)\n{\n\tfor(long long i = 0; i < 100005; i++) dp[i] = inf;\n\tdp[0] = 0;\n\t\n\tfor(long long i = 0; i <= 100000; i++){\n\t\tfor(long long j = 0; j < vec.size(); j++){\n\t\t\tif(i <= vec[j].second) dp[i] = min(dp[i], vec[j].first);\n\t\t\telse dp[i] = min(dp[i], dp[i-vec[j].second] + vec[j].first);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(long long i = 0; i < N; i++) cin >> HP[i];\n\t\t\n\t\tcin >> M;\n\t\t\n\t\tstring s, t;\n\t\tlong long mp, dmg;\n\t\t\n\t\tsing.clear();\n\t\tall.clear();\n\t\tfor(long long i = 0; i < M; i++){\n\t\t\tcin >> s >> mp >> t >> dmg;\n\t\t\tif(t == \"Single\") sing.push_back( make_pair(mp, dmg) );\n\t\t\telse all.push_back( make_pair(mp, dmg) );\n\t\t}\n\t\t\n\t\tcalc(dp_sing, sing);\n\t\tcalc(dp_all, all);\n\t\t\n\t\tlong long sum, ans = inf;\n\t\tfor(long long i = 0; i <= 100000; i++){\n\t\t\tsum = dp_all[i];\n\t\t\tfor(long long j = 0; j < N; j++){\n\t\t\t\tif(HP[j] - i > 0) sum += dp_sing[ HP[j] - i ];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;//(h+_all[0].second-1)/_all[0].second*_all[0].first;\n\t\t\tsingle[i]=9999999;//(h+_single[0].second-1)/_single[0].second*_single[0].first;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\t\tif(all.empty()){\n\t\t\tfor(r=j=0;j<monster.size();j++)r+=single[monster[j]];\n\t\t}else{\n\t\t\tr=9999999;//(h+all[h]-1)/all[h];\n\t\t\tfor(i=1;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\t//cout<<i<<' '<<s<<' '<<all[i]<<endl;\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tmap<int,int>all_iter;\n\t\tall_iter[0]=0;\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t\tall_iter[all[i]]=i;\n\t\t}\n\n\t\tif(_single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;\n\t\t\tfor(map<int,int>::iterator it=all_iter.begin();it!=all_iter.end();it++){\n\t\t\t\th=it->first;\n\t\t\t\tfor(j=0;j<monster.size();j++)h+=single[max(0,monster[j]-it->second)];\n\t\t\t\tif(r>h)r=h;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(17,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n    }\n    long long as[2][100001];\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    long long mp=1LL<<62;\n    for(int i=0;i<mp;i++){\n      long long cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<mp<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 100009\nusing namespace std;\n\nint dp1[10009];\nint dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)&&n!=0)\n    {\n        int ma=-1;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        long long ans=(long long)1<<62,sum;\n        for(int i=0; i<ans; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 2000000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  } \n\n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nvector<P>v1,v2;\nint a[101],dp1[100001],dp2[100001],n,t1,t2,t;\nstring s;\nmain(){\n\twhile(cin>>n,n){\n\t\tint ans=1e8;\n\t\tr(i,100001)dp1[i]=dp2[i]=1e8;\n\t\tdp1[0]=dp2[0]=0;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tr(i,n)cin>>a[i];\n\t\tcin>>t;\n\t\tr(i,t){\n\t\t\tcin>>s>>t1>>s>>t2;\n\t\t\tif(s==\"All\")v1.push_back(P(t1,t2));\n\t\t\telse v2.push_back(P(t1,t2));\n\t\t}\n\t\tr(i,v1.size())r(j,100001)if(j+v1[i].S<=100001)\n\t\t  dp1[j+v1[i].S]=min(dp1[j+v1[i].S],dp1[j]+v1[i].F);\n\t\tr(i,v2.size())r(j,100001)if(j+v2[i].S<=100001)\n\t\t  dp2[j+v2[i].S]=min(dp2[j+v2[i].S],dp2[j]+v2[i].F);\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tr(i,100001){\n\t\t\tint sum=0;\n\t\t\tr(j,n)if(a[j]-i>0)sum+=dp2[a[j]-i];\n\t\t\tans=min(ans,sum+dp1[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf = 1 << 30;\n\nint n,m;\nint hp[110];\n\nconst int hpmax=100000;\n\nll single[100010];\nll all[100010];\n\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n) cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i,hpmax+10) single[i]=inf,all[i]=inf;\n\t\tsingle[0]=all[0]=0LL;\n\t\trep(i,m){\n\t\t\tstring _,type;\n\t\t\tint mp,damage;\n\t\t\tcin >> _ >> mp >> type >> damage;\n\t\t\tdamage=min(damage,hpmax);\n\t\t\tif(type==\"Single\"){\n\t\t\t\trep(j,hpmax) if(j+damage<=hpmax) single[j+damage]=min(single[j+damage],single[j]+mp);\n\t\t\t}else{\n\t\t\t\trep(j,hpmax) if(j+damage<=hpmax) all[j+damage]=min(all[j+damage],all[j]+mp);\n\t\t\t}\n\t\t}\n\t\tfor(int i=hpmax;i>=0;i--){\n\t\t\tsingle[i]=min(single[i],single[i+1]);\n\t\t\tall[i]=min(all[i],all[i+1]);\n\t\t}\n\t\tint ans=all[hpmax];\n\t\trep(i,hpmax+1){\n\t\t\tint cur=all[i];\n\t\t\trep(j,n){\n\t\t\t\tint index=max(0,hp[j]-i);\n\t\t\t\tcur+=single[index];\n\t\t\t}\n\t\t\tans=min(ans,cur);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 100002\n#define inf 1<<29\nusing namespace std;\n\nint main()\n{\n  int n,m,hp[101],p,d;\n  string name,s;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    vector<pair<int,int> > all,single; \n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>name>>p>>s>>d;\n      if(s==\"Single\")single.push_back(mp(p,d));\n      else all.push_back(mp(p,d));\n    }\n    \n    int All[MAX],Single[MAX];\n    for(int i=0;i<MAX;i++){\n      All[i]=inf;\n      Single[i]=inf;\n    }\n    All[0]=0;\n    Single[0]=0;\n\n    for(int i=0;i<all.size();i++){\n      for(int j=0;j<MAX;j++){\n\tAll[min(j+all[i].s,MAX-1)]=min(All[min(j+all[i].s,MAX-1)],\n\t\t\t\t       All[j]+all[i].f);\n      }\n    }\n   \n    for(int i=0;i<single.size();i++){\n      for(int j=0;j<MAX;j++){\n\tSingle[min(j+single[i].s,MAX-1)]=min(Single[min(j+single[i].s,MAX-1)],\n\t\t\t\t\t     Single[j]+single[i].f);\n      }\n    }\n\n    int mina=inf,minb=inf;\n    for(int i=MAX-2;i>0;i--){\n      All[i]=min(mina,All[i]);\n      mina=min(All[i],mina);\n      Single[i]=min(minb,Single[i]);\n      minb=min(minb,Single[i]);\n    }\n\n    int ans=inf;\n    for(int i=0;i<MAX;i++){\n      if(All[i]==inf)continue;\n      int sum=All[i];\n      for(int j=0;j<n;j++){\n\tsum+=Single[max(hp[j]-i,0)];\n      }\n      ans=min(ans,sum);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int MAX_HP = 100000;\nint enemy[110];\nint dp[2][MAX_HP + 10];\n\nvoid calc(int idx, vector<int> cst, vector<int> dmg) {\n    int N = cst.size();\n    fill(dp[idx], dp[idx] + MAX_HP + 1, INF);\n    dp[idx][0] = 0;\n\n    for(int i=0; i<N; i++) {\n        for(int j=dmg[i]; j<=MAX_HP; j++) {\n            dp[idx][j] = min(dp[idx][j], dp[idx][j-dmg[i]] + cst[i]);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    while(cin >> N) {\n        if(N == 0) break;\n        for(int i=0; i<N; i++) cin >> enemy[i];\n        cin >> M;\n\n        vector<int> cst1, cst2, dmg1, dmg2;\n        for(int i=0; i<M; i++) {\n            string s, target;\n            int cost, damage;\n            cin >> s >> cost >> target >> damage;\n            damage = min(damage, MAX_HP);\n            if(target == \"Single\") {\n                cst1.push_back(cost);\n                dmg1.push_back(damage);\n            }\n            else {\n                cst2.push_back(cost);\n                dmg2.push_back(damage);\n            }\n        }\n\n        calc(0, cst1, dmg1);\n        calc(1, cst2, dmg2);\n        for(int j=MAX_HP-1; j>=0; j--) {\n            dp[0][j] = min(dp[0][j], dp[0][j+1]);\n        }\n\n        int ans = INF;\n        // 全体攻撃によるダメージ\n        for(int dmg=0; dmg<=MAX_HP; dmg++) {\n            int tmp = dp[1][dmg];\n            if(tmp == INF) continue;\n            for(int i=0; i<N; i++) {\n                if(enemy[i] <= dmg) continue;\n                tmp += dp[0][enemy[i] - dmg];\n            }\n            ans = min(ans, tmp);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,minc;\nint dpAll[D],dpSin[D];\nstring name,target[N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    minc=INF;\n    for(int i=D-1;i>=0;i--){\n      minc=min(minc,dpSin[i]);\n      dpSin[i]=minc;\n    }\n    \n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      int cnt=dpAll[i];\n      for(int j=0;j<n;j++){\n\tint k=hp[j]-i;\n\tif(k<0)k=0;\n\tcnt+=dpSin[k];\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 1e5+10;\n\nint dp_s[N], dp_a[N];\n\nint mons[110];\n\nconst int INF = 1e9;\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = INF;\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tint *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\trep(j, N) dp[min(j + v, 100000)] = min(dp[min(j + v, 100000)], dp[j] + w);\n\t\t}\n\n\t\tfor (int i = N - 2; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tassert(*max_element(dp_s, dp_s + 100000) != INF);\n\t\trep(i, N){\n\t\t\tint tmp = dp_a[i];\n\t\t\tif (tmp == INF) continue;\n\t\t\t\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tmemset(mon, 0, sizeof(mon));\n\t\tmemset(mag, 0, sizeof(mag));\n\t\tvector<magic> all;\n\t\tvector<magic> single;\n\t\tvector<magic> crit;\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 5000; i < 200001; i++) if(dp[i] != INF) cout << i << \" : \" << dp[i] << endl;\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tint mon2[120];\n\t\t\tmemcpy(mon2, mon, sizeof(mon));\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tmon2[j] -= i;\n\t\t\t\tif(mon2[j] > 0) prev += dp2[mon2[j]];\n\t\t\t}\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tauto HP = read<int>(N);\n\n\t\tint maxHP = *max_element(allof(HP));\n\t\tvector<int> tableS(maxHP + 1, INF); // tableS[x] = 単体魔法でxダメージ与えるのに必要なMP\n\t\tvector<int> tableA(maxHP + 1, INF); // tableA[x] = 全体魔法でxダメージ与えるのに必要なMP\n\n\t\tREAD(int, M);\n\t\tREP(_, M)\n\t\t{\n\t\t\tstring name, type;\n\t\t\tint mp, dmg;\n\t\t\tcin >> name >> mp >> type >> dmg;\n\t\t\tvector<int> &tg = type[0] == 'A' ? tableA : tableS;\n\t\t\ttg[0] = 0;\n\t\t\tFOR(d, 1, maxHP + 1) { tg[d] = min(tg[d], tg[max(0, d - dmg)] + mp); }\n\t\t}\n\n\t\t// 全体魔法でd与えてから、単体魔法で倒してみることにしよう。\n\t\tlong result = LINF;\n\t\tfor (int d = 1; d <= maxHP; d = upper_bound(allof(tableA), tableA[d]) - tableA.begin())\n\t\t{\n\t\t\tlong cost = tableA[d - 1];\n\t\t\tREP(i, HP.size())\n\t\t\t{\n\t\t\t\tcost += tableS[max(HP[i] - d - 1, 0)];\n\t\t\t}\n\t\t\tresult = min(result, cost);\n\t\t\t//WRITE(\"d:\", d - 1, \" MP:\", cost);\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid fillDP(const vector< pair<int, int> >& skills, vector<int>& dp, int size) {\n    dp.resize(size + 1);\n    fill(dp.begin(), dp.end(), INF);\n    dp[0] = 0;\n    for(auto itr = skills.begin(); itr != skills.end(); itr++) {\n        for(int i = 0; i <= size; i++) {\n            if(dp[i] == INF) {\n                continue;\n            }\n            int damage = min(i + itr->second, size);\n            dp[damage] = min(dp[damage], dp[i] + itr->first);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        int enemyNumber, skillNumber, maxHP;\n        vector<int> allDP, singleDP, hps;\n        vector< pair<int, int> > allSkills, singleSkills;\n\n        cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            int hp;\n            cin >> hp;\n            hps.push_back(hp);\n        }\n\n        cin >> skillNumber;\n        for(int i = 0; i < skillNumber; i++) {\n            int mp, damage;\n            string name, target;\n            cin >> name >> mp >> target >> damage;\n            if(target == \"All\") {\n                allSkills.push_back(make_pair(mp, damage));\n            } else {\n                singleSkills.push_back(make_pair(mp, damage));\n            }\n        }\n\n        maxHP = *max_element(hps.begin(), hps.end());\n        fillDP(allSkills, allDP, maxHP);\n        fillDP(singleSkills, singleDP, maxHP);\n\n        for(int i = maxHP; i > 0; i--) {\n            if(singleDP[i - 1] == INF) {\n                singleDP[i - 1] = singleDP[i];\n            }\n        }\n\n        int answer = INF;\n\n        for(int i = 0; i <= maxHP; i++) {\n            if(allDP[i] == INF) {\n                continue;\n            }\n\n            int cost = allDP[i];\n\n            for(auto itr = hps.begin(); itr != hps.end(); itr++) {\n                if(*itr - i > 0) {\n                    cost += singleDP[*itr - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1500000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nint dp1[2][100010], dp2[2][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >>  target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 30;\n    }\n    for(int i = 1; i <= m; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(target[i-1] == \"All\"){\n            dp1[i%2][j] = min(dp1[(i-1)%2][j], dp1[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i%2][j] = dp2[(i-1)%2][j];          \n        }\n        else{\n            dp2[i%2][j] = min(dp2[(i-1)%2][j], dp2[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i%2][j] = dp1[(i-1)%2][j];\n        }\n      }\n    }\n    \n    \n    for(int i = 5000; i <= 10000; i++){\n      //cout << i << \" \" << dp2[n][i] <<endl;\n    }\n    \n    int ans = 1 << 30;\n    for(int i = 0; i <= 100000; i++){\n      int sum = dp1[m%2][i];\n      //cout << i << \" \" << dp1[n][i];\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[m%2][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#define INF 1e8\nusing namespace std;\n\nint n,m;\nint hp[101];\nint dp[2][100001];\nint mp[101],t[101],d[101];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&hp[i]);\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str,st2;\n\t\t\tcin >> str >> mp[i] >> st2 >> d[i];\n\t\t\tif(st2==\"Single\")t[i]=0;\n\t\t\telse t[i]=1;\n\t\t}\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tdp[0][i]=dp[1][i]=INF;\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tdp[i][0]=0;\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tif(dp[i][j]<INF){\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(t[k]==i){\n\t\t\t\t\t\t\tdp[i][min(j+d[k],100000)]=min(dp[i][min(j+d[k],100000)],dp[i][j]+mp[k]);\n\t\t\t\t\t\t\t//printf(\"%d %d %d\\n\",i,min(j+d[k],100000),dp[i][min(j+d[k],100000)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=100000;j>=1;j--){\n\t\t\t\tif(dp[i][j]<dp[i][j-1])dp[i][j-1]=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint cost=dp[1][i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(hp[j]>i)cost=min(cost+dp[0][hp[j]-i],INF);\n\t\t\t}\n\t\t\tres=min(res,cost);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e14;\n\nint n, m;\nvector<int> h;\nvector<P> m1, m2; \nint dp[100010], dp2[100010];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin >> n, n){\n        h.resize(n);\n        m1.clear();\n        m2.clear();\n        rep(i, 0, n){\n            cin >> h[i];\n        }\n        cin >> m;\n        rep(i, 0, m){\n            string s1;\n            int mp, damage;\n            cin >> s1 >> mp >> s1 >> damage;\n            if(s1 == \"Single\"){\n                m1.push_back(P(mp, damage));\n            }else if(s1 == \"All\"){  \n                m2.push_back(P(mp, damage));\n            }\n        }\n        rep(i, 0, 100010){\n            dp[i] = dp2[i] = INF;\n        }\n        dp[0] = dp2[0] = 0;\n        rep(i, 0, m1.size()){\n            rep(j, 0, 100001){\n                if(dp[j] == INF) continue;\n                int next = j + m1[i].second;\n                if(next > 100000) next = 100001;\n                chmin(dp[next], dp[j] + m1[i].first);\n            }\n        }\n        rep(i, 0, m2.size()){\n            rep(j, 0, 100001){\n                if(dp2[j] == INF) continue;\n                int next = j + m2[i].second;\n                if(next > 100000) next = 100001;\n                chmin(dp2[next], dp2[j] + m2[i].first);\n            }\n        }\n        int MIN = INF;\n        repb(i, 100001, 0){\n            chmin(MIN, dp[i]);\n            dp[i] = MIN;\n        }\n        MIN = INF;\n        repb(i, 100001, 0){\n            chmin(MIN, dp2[i]);\n            dp2[i] = MIN;\n        }\n        int ans = INF;\n        rep(i, 0, 100001){\n            int sum = dp2[i];\n            rep(j, 0, n){\n                sum += dp[max(0LL, h[j] - i)];\n            }\n            chmin(ans, sum);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint N, M, HP[111];\nvector< int > singleMP, allMP;\nvector< int > singleDM, allDM;\n\nint singleDP[111][1000010], allDP[111][1000010];\nconst int INF = (int)1e9;\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> HP[i];\n\t\n\tstring dumy, type;\n\tcin >> M;\n\t\n\tfor_(i,0,M) {\n\t\tint MP, DM;\n\t\tcin >> dumy >> MP >> type >> DM;\n\t\t\n\t\tif (type == \"All\") {\n\t\t\tallMP.push_back(MP);\n\t\t\tallDM.push_back(DM);\n\t\t} else {\n\t\t\tsingleMP.push_back(MP);\n\t\t\tsingleDM.push_back(DM);\n\t\t}\n\t}\n\t\n\t// single DP\n\tint S = singleMP.size();\n\tfor_(i,0,S+1) fill(singleDP[i], singleDP[i] + 1000010, INF);\n\t\n\tfor_(i,0,S+1) singleDP[i][0] = 0;\n\t\n\tfor_(i,0,S) {\n\t\tint DM = singleDM[i], MP = singleMP[i];\n\t\t\n\t\tfor_(j,0,1000010) {\n\t\t\tif (j < DM) {\n\t\t\t\tsingleDP[i + 1][j] = singleDP[i][j];\n\t\t\t} else {\n\t\t\t\tsingleDP[i + 1][j] = min(singleDP[i][j], singleDP[i + 1][j - DM] + MP);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< int > smp(1000010, INF);\n\tfor_rev(d,1000001,0) smp[d] = min(smp[d + 1], singleDP[S][d]);\n\t\t\n\t// all DP\n\tint A = allMP.size();\n\tfor_(i,0,A+1) fill(allDP[i], allDP[i] + 1000010, INF);\n\t\n\tfor_(i,0,A+1) allDP[i][0] = 0;\n\t\n\tfor_(i,0,A) {\n\t\tint DM = allDM[i], MP = allMP[i];\n\t\t\n\t\tfor_(j,0,1000010) {\n\t\t\tif (j < DM) {\n\t\t\t\tallDP[i + 1][j] = allDP[i][j];\n\t\t\t} else {\n\t\t\t\tallDP[i + 1][j] = min(allDP[i][j], allDP[i + 1][j - DM] + MP);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< int > amp(1000010, INF);\n\tfor_rev(d,1000001,0) amp[d] = min(amp[d + 1], allDP[A][d]);\n\t\n\tint ans = INF;\n\t\n\tfor_(d,0,1000010) {\n\t\tint sum = amp[d];\n\t\tfor_(i,0,N) if (HP[i] - d > 0) sum += smp[HP[i] - d];\n\t\tans = min(ans, sum);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 1e5+10;\n\nint dp_s[N], dp_a[N];\n\nint mons[110];\n\nconst int INF = 1e9;\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = INF;\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tint *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\trep(j, N) dp[min(j + v, 100000)] = min(dp[min(j + v, 100000)], dp[j] + w);\n\t\t}\n\n\t\tfor (int i = N - 2; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, N){\n\t\t\tint tmp = dp_a[i];\n\t\t\tif (tmp == INF) continue;\n\t\t\t\n\t\t\trep(j, n) assert(dp_s[max(mons[j] - i, 0)] != INF);\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi hp(n);\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tvp a,b;\n\t\trep(i,m){\n\t\t\tstring c,d;int e,f;\n\t\t\tcin>>c>>e>>d>>f;\n\t\t\tif(d==\"Single\")a.pb(pii(e,f));\n\t\t\tif(d==\"All\")b.pb(pii(e,f));\n\t\t}\n\t\tvi dps(100000,inf),dpa(100000,inf);\n\t\tdps[0]=dpa[0]=0;\n\t\trep(i,a.size())rep(j,100000){\n\t\t\tint t=j-a[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdps[j]=min(dps[j],dps[t]+a[i].first);\n\t\t}\n\t\trep(i,b.size())rep(j,100000){\n\t\t\tint t=j-b[i].second;\n\t\t\tif(t<0)t=0;\n\t\t\tdpa[j]=min(dpa[j],dpa[t]+b[i].first);\n\t\t}\n\t\tint out=inf;\n\t\trep(i,100000)if(dpa[i]!=inf){\n\t\t\tint sum=dpa[i];\n\t\t\trep(j,n){\n\t\t\t\tint t=hp[j]-i;\n\t\t\t\tif(t<=0)continue;\n\t\t\t\twhile(dps[t]==inf)t++;\n\t\t\t\tsum+=dps[t];\n\t\t\t}\n\t\t\tout=min(out,sum);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,am,sm,hp[110],maxhp;\nll amp[110],adm[110],smp[110],sdm[110];\nll dpa[100100], dps[100100];\nstring name;\nll tmp;\nconst ll INF = (ll)(1e15);\n\nint main(){\n  while(cin >> n,n){\n    maxhp = 0;\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n      maxhp = max(maxhp,hp[i]);\n    }\n\n    cin >> m;\n    am = sm = 0;\n\n    for(int i=0;i<m;i++){\n      cin >> name >> tmp;\n      cin >> name;\n      if(name == \"All\")amp[am] = tmp;\n      else smp[sm] = tmp;\n      cin >> tmp;\n      if(name == \"All\")adm[am++] = tmp;\n      else sdm[sm++] = tmp;\n    }\n\n\n    for(int i=0;i<=maxhp;i++)dpa[i] = INF;\n    dpa[0] = 0;\n\n    for(int i=0;i<am;i++){\n      for(int j=0;j<=maxhp;j++){\n\tif(dpa[j]<INF && j+adm[i]<=maxhp){\n\t  dpa[j+adm[i]] = min(dpa[j+adm[i]],dpa[j] + amp[i]);\n\t}\n      }\n    }\n\n    tmp = INF;\n    for(int i=maxhp;i>=0;i--){\n      if(tmp<dpa[i])dpa[i] = tmp;\n      else tmp = dpa[i];\n    }\n\n    for(int i=0;i<=maxhp;i++)dps[i] = INF;\n    dps[0] = 0;\n\n    for(int i=0;i<sm;i++){\n      for(int j=0;j<=maxhp;j++){\n\tif(dps[j]<INF && j+sdm[i]<=maxhp){\n\t  dps[j+sdm[i]] = min(dps[j+adm[i]],dps[j] + smp[i]);\n\t}\n      }\n    }\n\n    tmp = INF;\n    for(int i=maxhp;i>=0;i--){\n      if(tmp<dps[i])dps[i] = tmp;\n      else tmp = dps[i];\n    }\n\n    ll ans = INF;\n    for(int i=0;i<=maxhp;i++){\n      tmp = dpa[i];\n      for(int j=0;j<n;j++){\n\tint rem = hp[j] - i;\n\tif(rem<=0)continue;\n\ttmp += dps[rem];\n      }\n      ans = min(ans,tmp);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nint dp1[100010];\nint dp2[100010];\nvoid mainmain(){\n\tint n;\n\tint m;\n\twhile(cin>>n,n){\n\t\tvint hp(n);\n\t\trep(i,n) cin>>hp[i];\n\t\tcin>>m;\n\t\tvector<pii> one,all;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint a,b;\n\t\t\tcin>>a>>s>>b;\n\t\t\tif(s==\"Single\"){\n\t\t\t\tone.PB(mkp(a,b));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tall.PB(mkp(a,b));\n\t\t\t}\n\t\t}\n\t\t// cout<<\"aaa\\n\";\n\t\trep(i,100010){\n\t\t\tdp1[i]=INF;\n\t\t\tdp2[i]=INF;\n\t\t}\n\t\tdp1[0]=0;\n\t\t// cout<<\"size \"<<(int)one.size()<<endl;\n\t\trep(i,one.size()){\n\t\t\tint t=INF;\n\t\t\trep(j,100010){\n\t\t\t\tif(j+one[i].S>=100010){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tt=0;\n\t\t\t\t\t}\n\t\t\t\t\tdp1[100009]=min(dp1[100009],t+one[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp1[j]==INF) continue;\n\t\t\t\t// if(dp1[j]+one[i].F<0) continue;\n\t\t\t\tdp1[j+one[i].S]=min(dp1[j+one[i].S],dp1[j]+one[i].F);\n\t\t\t\tif(j+one[i].S*2>=100010) t=min(t,dp1[j+one[i].S]);\n\t\t\t}\n\t\t}\n\t\tint M=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\t// if(dp1[i]!=INF) cout<<\"dp1\"<<\" \"<<i<<\" \"<<dp1[i]<<endl;\n\t\t\tdp1[i]=min(dp1[i],M);\n\t\t\tM=min(dp1[i],M);\n\t\t}\n\t\tdp2[0]=0;\n\t\trep(i,all.size()){\n\t\t\t// cout<<i<<endl;\n\t\t\tint t=INF;\n\t\t\trep(j,100010){\n\t\t\t\tif(j+all[i].S>=100010){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tt=0;\n\t\t\t\t\t}\n\t\t\t\t\tdp2[100009]=min(dp2[100009],t+all[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp2[j]==INF) continue;\n\t\t\t\t// if(dp2[j]+all[i].F<0) continue;\n\t\t\t\tdp2[j+all[i].S]=min(dp2[j+all[i].S],dp2[j]+all[i].F);\n\t\t\t\tif(j+all[i].S*2>=100010) t=min(t,dp2[j+all[i].S]);\n\t\t\t}\n\t\t\t// cout<<t<<endl;\n\t\t}\n\t\tM=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\tdp2[i]=min(dp2[i],M);\n\t\t\tM=min(dp2[i],M);\n\t\t\t// if(i<100) cout<<\"dp2 \"<<i<<\" \"<<dp2[i]<<endl;\n\t\t}\n\t\t// cout<<\"M \"<<M<<endl;\n\t\t// cout<<\"hoge\\n\";\n\t\tint ans=INF;\n\t\trep(i,100010){\n\t\t\tint tmp=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tif(hp[j]<=i) continue;\n\t\t\t\ttmp+=dp1[hp[j]-i];\n\t\t\t}\n\t\t\tans=min(ans,tmp);\n\t\t}\n\t\t// cout<<\"dp1\\n\";\n\t\t// rep(i,50){\n\t\t\t// cout<<i<<\" \"<<dp1[i]<<endl;\n\t\t// }\n\t\t// cout<<\"dp2\"<<endl;\n\t\t// rep(i,50){\n\t\t\t// cout<<i<<\" \"<<dp2[i]<<endl;\n\t\t// }\n\t\t// cout<<ans<<endl;\n\t\t// cout<<dp1[100000]<<endl;\n\t\t// rep(i,n){\n\t\t\t// if(hp[i]-40221*3>0) cout<<hp[i]-40221*3<<endl;\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n\n}\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX = 2e6;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<int> hp(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> hp[i];\n\t\t}\n\t\tsort(hp.begin(), hp.end());\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<ll> dp_s(MAX + 1, 1e17);\n\t\tvector<ll> dp_a(MAX + 1, 1e17);\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring sp, ta;\n\t\t\tint mp, dm;\n\t\t\tcin >> sp >> mp >> ta >> dm;\n\t\t\tif (ta == \"Single\") {\n\t\t\t\tfor (int i = dm; i <= MAX; i++) {\n\t\t\t\t\tdp_s[i] = min(dp_s[i], dp_s[i - dm] + mp);\n\t\t\t\t}\n\t\t\t\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\t\t\t\tdp_s[i] = min(dp_s[i + 1], dp_s[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = dm; i <= MAX; i++) {\n\t\t\t\t\tdp_a[i] = min(dp_a[i], dp_a[i - dm] + mp);\n\t\t\t\t}\n\t\t\t\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\t\t\t\tdp_a[i] = min(dp_a[i + 1], dp_a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = LLONG_MAX;\n\t\tfor (int i = 0; i <= MAX; i++) {\n\t\t\tll val = dp_a[i];\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tval += dp_s[max(0, hp[j] - i)];\n\t\t\t}\n\t\t\tres = min(res, val);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 50000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  } \n\n\n\n  rep(i,maxhp){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nint dp1[100010],dp2[100010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint m,d;\n\t\t\tcin>>s>>m>>t>>d;\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=m;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=m;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+100001,INF);\n\t\tfill(dp2,dp2+100001,INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,100001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,100001){\n\t\t\tint res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tint rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint single[200001] = {};\nint target[200001] = {};\n\nvoid solve(){\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return;\n\t\tvector<int> hp(n);\n\t\tREP(i, n) {\n\t\t\tcin >> hp[i];\n\t\t}\n\t\tREP(i, 200001) {\n\t\t\tsingle[i] = 1e9;\n\t\t\ttarget[i] = 1e9;\n\t\t}\n\t\tsingle[0] = 0;\n\t\ttarget[0] = 0;\n\t\tint m;\n\t\tcin >> m;\n\t\tREP(i, m) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tint a, b;\n\t\t\tstring c;\n\t\t\tcin >> a >> c >> b;\n\t\t\tb = min(b, 100000LL);\n\t\t\tif (c == \"Single\") {\n\t\t\t\tfor (int q = 0; q < 100000; ++q) {\n\t\t\t\t\tsingle[q + b] = min(single[q + b], single[q] + a);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int q = 0; q < 100000; ++q) {\n\t\t\t\t\ttarget[q + b] = min(target[q + b], target[q] + a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int q = 200000 - 1; q >= 0; --q) {\n\t\t\ttarget[q] = min(target[q], target[q + 1]);\n\t\t\tsingle[q] = min(single[q], single[q + 1]);\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor (int q = 0; q <= 100000; ++q) {\n\t\t\tint tmp = target[q];\n\t\t\tREP(i, n) {\n\t\t\t\tint hoge = max(hp[i] - q, 0LL);\n\t\t\t\ttmp += single[hoge];\n\t\t\t}\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nlong long int DP1[150000], DP2[150000];\n\nint main(){\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint HP[200];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> HP[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 110000; i++){\n\t\t\tDP1[i] = INF;\n\t\t\tDP2[i] = INF;\n\t\t}\n\t\t\n\t\tDP1[0] = 0;\n\t\tDP2[0] = 0;\n\t\t\n\t\tcin >> m;\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tlong long int cost, D;\n\t\t\tstring hoge, t;\n\t\t\tcin >> hoge >> cost >> t >> D;\n\t\t\tif(t == \"Single\"){\n\t\t\t\tfor(int j = 0; j < 110000; j++){\n\t\t\t\t\tDP1[j] = min(DP1[j], DP1[max(0LL, j - D)] + cost);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 110000; j++){\n\t\t\t\t\tDP2[j] = min(DP2[j], DP2[max(0LL, j - D)] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = INF;\n\t\tfor(int i = 0; i < 110000; i++){\n\t\t\tlong long int ret = DP2[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tret += DP1[max(0, HP[j] - i)];\n\t\t\t}\n\t\t\tans = min(ans, ret);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nvector<int> solve_dp(\n\tint max_damage, const vector<int> &mp, const vector<int> &damage)\n{\n\tvector<int> dp(max_damage, -1);\n\tdp[0] = 0;\n\tfor(int i = 0; i < mp.size(); ++i){\n\t\tfor(int j = 0; j < max_damage; ++j){\n\t\t\tif(dp[j] < 0){ continue; }\n\t\t\tint idx = j + damage[i];\n\t\t\tif(idx >= max_damage){ break; }\n\t\t\tif(dp[idx] < 0){\n\t\t\t\tdp[idx] = dp[j] + mp[i];\n\t\t\t}else{\n\t\t\t\tdp[idx] = min(dp[idx], dp[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = max_damage - 2; i >= 0; --i){\n\t\tif(dp[i + 1] < 0){ continue; }\n\t\tif(dp[i] < 0){\n\t\t\tdp[i] = dp[i + 1];\n\t\t}else{\n\t\t\tdp[i] = min(dp[i], dp[i + 1]);\n\t\t}\n\t}\n\treturn dp;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<int> hp(n);\n\t\tint max_hp = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> hp[i];\n\t\t\tmax_hp = max(max_hp, hp[i]);\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<int> all_mp, all_damage;\n\t\tvector<int> single_mp, single_damage;\n\t\tint max_damage = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tmax_damage = max(max_damage, damage);\n\t\t\tif(damage == 0){ continue; }\n\t\t\tif(target == \"All\"){\n\t\t\t\tall_mp.push_back(mp);\n\t\t\t\tall_damage.push_back(damage);\n\t\t\t}else{\n\t\t\t\tsingle_mp.push_back(mp);\n\t\t\t\tsingle_damage.push_back(damage);\n\t\t\t}\n\t\t}\n\t\tint am = all_mp.size(), sm = single_mp.size();\n\t\tmax_damage = max(max_damage, max_hp) + max_damage + 1;\n\t\tvector<int> all_dp = solve_dp(max_damage, all_mp, all_damage);\n\t\tvector<int> single_dp = solve_dp(max_damage, single_mp, single_damage);\n\t\tint answer = INT_MAX;\n\t\tfor(int i = 0; i < max_damage; ++i){\n\t\t\tif(all_dp[i] < 0){ continue; }\n\t\t\tint sum = all_dp[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(hp[j] <= i){ continue; }\n\t\t\t\tif(single_mp.size() == 0 && hp[j] > i){\n\t\t\t\t\tsum = INT_MAX;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum += single_dp[hp[j] - i];\n\t\t\t}\n\t\t\tanswer = min(answer, sum);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst long long INF = 1LL << 60;\nusing namespace std;\n\nconst int MAX_D = 1000000;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tif(i + a[j].second >= MAX_D) continue;\n\t\t\tres[i + a[j].second] = min(res[i + a[j].second], res[i] + a[j].first);\n\t\t}\n\t}\n\n\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\tif(res[i - 1] == INF) res[i - 1] = res[i];\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\n\t\tlong long ans = INF;\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) break;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\n#define inf 999999999999\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        for(int i=1;i<=10000;i++)dp2[i]=-inf;\n        memset(dp1,0,sizeof dp1);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=inf,sum;\n        for(int i=0; i<10001; i++)\n        {\n            if(dp2[i]<0)continue;\n            sum=i;\n            for(int j=0; j<n; j++)\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nint dp1[2][100010], dp2[2][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >> target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 30;\n    }\n    for(int i = 1; i <= m; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(target[i-1] == \"All\"){\n            dp1[i%2][j] = min(dp1[(i-1)%2][j], dp1[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i%2][j] = dp2[(i-1)%2][j];          \n        }\n        else{\n            dp2[i%2][j] = min(dp2[(i-1)%2][j], dp2[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i%2][j] = dp1[(i-1)%2][j];\n        }\n      }\n    }\n    \n    \n    for(int i = 5000; i <= 10000; i++){\n      //cout << i << \" \" << dp2[n][i] <<endl;\n    }\n    \n    int ans = 1 << 30;\n    for(int i = 0; i <= 100000; i++){\n      int sum = dp1[m%2][i];\n      //cout << i << \" \" << dp1[n][i] << endl;\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[m%2][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid fillDP(const vector< pair<int, int> >& skills, vector<int>& dp, int size) {\n    dp.resize(size + 1);\n    fill(dp.begin(), dp.end(), INF);\n    dp[0] = 0;\n    for(auto itr = skills.begin(); itr != skills.end(); itr++) {\n        for(int i = 0; i <= size; i++) {\n            if(dp[i] == INF) {\n                continue;\n            }\n            int damage = min(i + itr->second, size);\n            dp[damage] = min(dp[damage], dp[i] + itr->first);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        int enemyNumber, skillNumber, maxHP;\n        vector<int> allDP, singleDP, hps;\n        vector< pair<int, int> > allSkills, singleSkills;\n\n        cin >> enemyNumber;\n        if(enemyNumber == 0) {\n            break;\n        }\n        for(int i = 0; i < enemyNumber; i++) {\n            int hp;\n            cin >> hp;\n            hps.push_back(hp);\n        }\n\n        cin >> skillNumber;\n        for(int i = 0; i < skillNumber; i++) {\n            int mp, damage;\n            string name, target;\n            cin >> name >> mp >> target >> damage;\n            if(target == \"All\") {\n                allSkills.push_back(make_pair(mp, damage));\n            } else {\n                singleSkills.push_back(make_pair(mp, damage));\n            }\n        }\n\n        maxHP = *max_element(hps.begin(), hps.end());\n        fillDP(allSkills, allDP, maxHP);\n        fillDP(singleSkills, singleDP, maxHP);\n\n        for(int i = maxHP; i > 0; i--) {\n            static int minimum;\n            minimum = min(minimum, singleDP[i]);\n            singleDP[i] = minimum;\n        }\n\n        int answer = INF;\n\n        for(int i = 0; i <= maxHP; i++) {\n            if(allDP[i] == INF) {\n                continue;\n            }\n\n            int cost = allDP[i];\n\n            for(auto itr = hps.begin(); itr != hps.end(); itr++) {\n                if(*itr - i > 0) {\n                    cost += singleDP[*itr - i];\n                }\n            }\n\n            answer = min(answer, cost);\n        }\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(s[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\n\t\tr=9999999;\n\t\tfor(i=0;i<=h;i++){\n\t\t\ts=all[i];\n\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\tif(r>s)r=s;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[20];\nint t[110];\nint p[110];\nint q[110];\nint c[110];\nint dp[2][110000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d\",c+i);\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s%d%s%d\",str,p+i,str,q+i);\n\t\t\tif(str[0]=='S')t[i]=1;\n\t\t\telse t[i]=0;\n\t\t}\n\t\tfor(int i=0;i<110000;i++)dp[0][i]=dp[1][i]=1999999999;\n\t\tdp[0][0]=dp[1][0]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<110000;j++){\n\t\t\t\tdp[t[i]][min(109999,j+q[i])]=min(dp[t[i]][min(109999,j+q[i])],dp[t[i]][j]+p[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=109998;i>=0;i--){\n\t\t\tdp[0][i]=min(dp[0][i],dp[0][i+1]);\n\t\t\tdp[1][i]=min(dp[1][i],dp[1][i+1]);\n\t\t}\n\t\tint ret=1999999999;\n\t\tfor(int i=0;i<110000;i++){\n\t\t\tint val=dp[0][i];\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i>=c[j])continue;\n\t\t\t\tval+=dp[1][c[j]-i];\n\t\t\t}\n\t\t\tret=min(ret,val);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nint n, m;\nint hp[102];\nint mp[102], isAll[102], dam[102];\nint minMp[100002], minAllMp[100002];\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> hp[i];\n    }\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >> s >> dam[i];\n      isAll[i] = (s == \"All\");\n    }\n\n    fill(minMp, minMp + 100002, INT_MAX);\n    fill(minAllMp, minAllMp + 100002, INT_MAX);\n    minMp[0] = 0;\n    minAllMp[0] = 0;\n\n    for(int i = 0; i < 100000; i++){\n      if(minMp[i] != INT_MAX){\n        for(int j = 0; j < m; j++){\n          if(isAll[j]) continue;\n          int ni = min(100000, i + dam[j]);\n          minMp[ni] = min(minMp[ni], minMp[i] + mp[j]);\n        }\n      }\n\n      if(minAllMp[i] != INT_MAX){\n        for(int j = 0; j < m; j++){\n          if(!isAll[j]) continue;\n          int ni = min(100000, i + dam[j]);\n          minAllMp[ni] = min(minAllMp[ni], minAllMp[i] + mp[j]);\n        }\n      }\n    }\n\n    for(int i = 99999; i >= 0; i--){\n      minMp[i] = min(minMp[i], minMp[i + 1]);\n      minAllMp[i] = min(minAllMp[i], minAllMp[i + 1]);\n    }\n\n    int ans = INT_MAX;\n\n    for(int i = 0; i <= 100000; i++){\n      if(minAllMp[i] == INT_MAX) continue;\n\n      int sum = minAllMp[i];\n\n      for(int j = 0; j < n; j++){\n        int remHp = max(0, hp[j] - i);\n\n        if(minMp[remHp] == INT_MAX){\n          sum = INT_MAX;\n          break;\n        }\n\n        sum += minMp[remHp];\n      }\n\n      ans = min(ans, sum);\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int kMaxHP = 100001;\n\n#define F first\n#define S second\n\nvoid make_dp(vector<pii> & spell, vi & dp){\n    dp[0] = 0;\n\n    for(auto s : spell){\n        rep(i, dp.size()){\n            if(dp[i] == inf) continue;\n\n            int next_dmg = min(kMaxHP - 1, i + s.S);\n            dp[next_dmg] = min(dp[next_dmg], dp[i] + s.F);\n        }\n    }\n\n    int cost = dp[kMaxHP - 1];\n    for(int d = kMaxHP - 2; d >= 0; d--){\n        if(dp[d] == inf) dp[d] = cost;\n        else cost = dp[d];\n    }\n}\n\nint main(void){\n    for(int n; cin >> n, n;){\n        vi hp(n);\n        rep(i, n) cin >> hp[i];\n\n        int m; cin >> m;\n\n        // (cost, damage)\n        vector<pii> single, all;\n        rep(i, m){\n            string name, target;\n            int cost, damage;\n            cin >> name >> cost >> target >> damage;\n\n            if(target == \"All\") all.pb(mp(cost, damage));\n            else single.pb(mp(cost, damage));\n        }\n\n        vi dp_single(kMaxHP, inf), dp_all(kMaxHP, inf);\n\n        make_dp(single, dp_single);\n        make_dp(all, dp_all);\n\n        int res = inf;\n        rep(d, kMaxHP){\n            int cost_single = 0;\n            rep(i, n){\n                if(hp[i] - d > 0){\n                    cost_single += dp_single[hp[i] - d];\n                }\n            }\n            res = min(res, dp_all[d] + cost_single);\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100001;\nconst int INF = (1<<30);\nstruct Spell{\n  string name,tar;\n  int MP,Dam;\n  Spell(){}\n  Spell(string n, int m, string t, int d):name(n),MP(m),tar(t),Dam(d){}\n};\n\nint dp[2][MAX];\nvector<int> Enemy;\nvector<Spell> V[2];\nint N;\n\nvoid init(){\n  fill(dp[0],dp[0]+2*MAX,INF);\n\n  //for(int i = 0; i < 2; i++) for(int j = 0; j < MAX; j++) dp[i][j] = INF;\n  V[0].clear();\n  V[1].clear();\n  Enemy.clear();\n}\n\nvoid input(){\n\n  while(N--){\n    int in;\n    cin >> in;\n    Enemy.push_back(in);\n  }\n\n  int m;\n  cin >> m;\n  while(m--){\n    Spell s;\n    cin >> s.name >> s.MP >> s.tar >> s.Dam;\n    if(s.tar == \"All\") V[0].push_back(s);\n    else V[1].push_back(s);\n  }\n\n}\n\n\nvoid make(){\n\n  dp[0][0] = dp[1][0] = 0;\n\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < MAX; i++){\n      if(dp[x][i] == INF) continue;\n      for(int j = 0; j < V[x].size(); j++){\n        int nex = min(i+V[x][j].Dam,100000);\n        int cos = dp[x][i]+V[x][j].MP;\n        dp[x][nex] = min(dp[x][nex],cos);\n      }\n    }\n  }\n  \n  int mincos[2];\n  mincos[0] = dp[0][MAX-1];\n  mincos[1] = dp[1][MAX-1];\n  \n  for(int i = MAX-1; i >= 0; i--){\n    mincos[0] = min(mincos[0],dp[0][i]);\n    mincos[1] = min(mincos[1],dp[1][i]);\n    dp[0][i] = min(dp[0][i],mincos[0]);\n    dp[1][i] = min(dp[1][i],mincos[1]);\n  }\n}\n\nvoid solve(){\n\n  int ans = INF;\n\n  for(int i = 0; i < MAX; i++){\n\n    int cos = dp[0][i];\n    for(int j = 0; j < Enemy.size(); j++){\n      int need = max(Enemy[j]-i,0);\n      cos+=dp[1][need];\n\n      //    cout << \"cos \" << dp[1][need] << endl;\n    }\n    ans = min(ans,cos);\n  }\n  cout << ans << endl;\n}\n\n\nint main(){\n\n  while(cin >> N && N){\n    init();\n    input();\n    make();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint HP[100], M;\nlong long dp1[100001], dp2[100001];\n\nint solve(int N)\n{\n  memset(dp1, 0, sizeof(dp1));\n  memset(dp2, 0, sizeof(dp2));\n    \n  for(int i = 0; i < N; i++) {\n    cin >> HP[i];\n  }\n  cin >> M;\n\n  bool end = false;\n  while(M--) {\n    string Name, Target;\n    int MP, Damage;\n    cin >> Name >> MP >> Target >> Damage;\n    if(MP == 0) {\n      if(Damage > 0) end = true;\n      continue;\n    }\n    long long *dp = Target.size() == 3 ? dp1 : dp2;\n    for(int i = MP; i <= 100000; i++) {\n      dp[i] = max(dp[i], dp[i - MP] + Damage);\n    }\n  }\n  if(end) return(0);\n  \n  int best = 1 << 30;\n  for(int i = 0; i <= 100000; i++) {\n    int ret = 0;\n    for(int j = 0; j < N; j++) {\n      ret += lower_bound(dp2, dp2 + 100001, HP[j] - dp1[i]) - dp2;\n    }\n    best = min(best, i + ret);\n  }\n  return(best);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> HP(N);\n    for(int i = 0; i < N; ++i){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<int> single_d, single_mp, all_d, all_mp;\n    string name, target;\n    int mp, damege;\n    for(int i = 0; i < M; ++i){\n      cin >> name >> mp >> target >> damege;\n      if(target == \"Single\"){\n        single_d.push_back(damege);\n        single_mp.push_back(mp);\n      }else{\n        all_d.push_back(damege);\n        all_mp.push_back(mp);\n      }\n    }\n    long long int INF = 1e10, n = 2e5;\n    vector<int> dp1(n,INF), dp2(n,INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < single_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp1[j] >= INF) continue;\n        if(j + single_d[i] < n)\n          dp1[j + single_d[i]] = min(dp1[j + single_d[i]], dp1[j] + single_mp[i]);\n        else\n          dp1[n-1] = min(dp1[n-1], dp1[j] + single_mp[i]);\n      }\n    }\n    for(int i = n-2; i >= 0; --i) dp1[i] = min(dp1[i], dp1[i+1]);\n    for(int i = n-2; i >= 0; --i) dp2[i] = min(dp2[i], dp2[i+1]);\n    \n    for(int i = 0; i < all_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp2[j] >= INF) continue;\n        if(j + all_d[i] < n)\n          dp2[j + all_d[i]] = min(dp2[j + all_d[i]], dp2[j] + all_mp[i]);\n      }\n    }\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      if(dp2[i] >= INF) continue;\n      long long int t = dp2[i];\n      for(int j = 0; j < N; ++j){\n        t += dp1[max(0,HP[j] - i)];\n      }\n      ans = min(ans,t);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[100],b[100],d[100];vector<int>v1,v2,w1,w2,dp1,dp2;\nvector<int>knapsack(int W,vector<int>v,vector<int>w){\n\tvector<int>dp(W+1,999999999);dp[0]=0;\n\tfor(int i=0;i<(int)v.size();i++){\n\t\tfor(int j=v[i];j<=W;j++)dp[j]=min(dp[j],dp[j-v[i]]+w[i]);\n\t}\n\tfor(int i=W-1;i>=0;i--)dp[i]=min(dp[i],dp[i+1]);\n\treturn dp;\n}\nint main(){\n\twhile(true){\n\t\tv1.clear();v2.clear();w1.clear();w2.clear();dp1.clear();dp2.clear();\n\t\tcin>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];cin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring S,T;cin>>S>>b[i]>>T>>d[i];if(d[i]>=200000)d[i]=200000;\n\t\t\tif(T==\"Single\"){v1.push_back(d[i]);w1.push_back(b[i]);}\n\t\t\tif(T==\"All\"){v2.push_back(d[i]);w2.push_back(b[i]);}\n\t\t}\n\t\tdp1=knapsack(300000,v1,w1);\n\t\tdp2=knapsack(300000,v2,w2);\n\t\tint maxn=999999999;\n\t\tfor(int i=0;i<=300000;i++){\n\t\t\tint sum=dp2[i];\n\t\t\tfor(int j=0;j<n;j++)sum+=dp1[max(0,a[j]-i)];\n\t\t\tmaxn=min(maxn,sum);\n\t\t}\n\t\tcout<<maxn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi hp(n);\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tvp a,b;\n\t\trep(i,m){\n\t\t\tstring c,d;int e,f;\n\t\t\tcin>>c>>e>>d>>f;\n\t\t\tif(d==\"Single\")a.pb(pii(e,f));\n\t\t\tif(d==\"All\")b.pb(pii(e,f));\n\t\t}\n\t\tvi dps(200000,inf),dpa(200000,inf);\n\t\tdps[0]=dpa[0]=0;\n\t\trep(i,a.size())rep(j,200000)if(dps[j]!=inf){\n\t\t\tif(j+a[i].second<200000)\n\t\t\t\tdps[j+a[i].second]=min(dps[j+a[i].second],dps[j]+a[i].first);\n\t\t}\n\t\trep(i,b.size())rep(j,200000)if(dpa[j]!=inf){\n\t\t\tif(j+b[i].second<200000)\n\t\t\t\tdpa[j+b[i].second]=min(dpa[j+b[i].second],dpa[j]+b[i].first);\n\t\t}\n\t\tint out=inf;\n\t\trep(i,200000)if(dpa[i]!=inf){\n\t\t\tint sum=dpa[i];\n\t\t\trep(j,n){\n\t\t\t\tint t=hp[j]-i;\n\t\t\t\tif(t<=0)continue;\n\t\t\t\twhile(dps[t]==inf)t++;\n\t\t\t\tsum+=dps[t];\n\t\t\t}\n\t\t\tout=min(out,sum);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst ll INF=100000000000000LL;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nll dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nll dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tll minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp*1LL);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tll res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tll res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp*1LL);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tll cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,HP[111],M;\nint dpa[100001],dps[100001];\nvector<P> ds,da;\nint MAX;\nconst int INF = (1<<29);\n\nvoid init(const vector<P> &D,int *dp){\n  for(int j=0;j<=MAX;j++){\n    for(int i=0;i<(int)D.size();i++){\n      int np = j + D[i].first;\n      np = min( np, MAX );\n      dp[np] = min( dp[j] + D[i].second, dp[np] );\n    }\n  }\n  for(int i=MAX-1;i>=0;i--){\n    dp[i] = min( dp[i+1], dp[i] );\n  }\n}\n\nint main(){\n  while( cin >> N && N ){\n    MAX = 0;\n    for(int i=0;i<N;i++) {\n      cin >> HP[i]; MAX = max( MAX, HP[i] );\n    }\n    cin >> M;\n    for(int i=0;i<M;i++){\n      string s,ta;int mp,dm;\n      cin >> s >> mp >> ta >> dm;\n      if( ta == \"Single\" )\n\tds.push_back( P(dm,mp) );\n      else\n\tda.push_back( P(dm,mp) );\n    }\n    fill(dps,dps+MAX+1,INF);\n    fill(dpa,dpa+MAX+1,INF);\n    dps[0] = dpa[0] = 0;\n    init(da,dpa);\n    init(ds,dps);\n    int res = INF;\n    for(int i=0;i<=MAX;i++){\n      int ret = dpa[i];\n      for(int j=0;j<N;j++){\n\tint hp = HP[j] - i;\n\thp = max(hp,0);\n\tret += dps[hp];\n\tif( ret > INF ) ret = INF;\n      }\n      res = min( res, ret );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,cnt;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nvector<P> v;\n\nint bynary_search(int x){\n  int l=0,r=v.size();\n  while(l<r){\n    int m=(l+r)/2;\n    if(v[m].first>=x)r=m;\n    else l=m+1;\n  }\n  return l;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++)\n      if(dpSin[i]!=INF)v.push_back(P(i,dpSin[i]));\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      cnt=dpAll[i];\n      for(int j=0;j<m;j++){\n\tint k=hp[j]-i;\n\tcnt+=v[bynary_search(k)].second;\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\nLL dp1[100101];\nLL dp2[100101];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint HP[100] = {};\n\t\tfor (int i = 0; i < N; i++) cin >> HP[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tvector<P> single;\n\t\tvector<P> all;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring name, target;\n\t\t\tint mp, damage;\n\t\t\tcin >> name >> mp >> target >> damage;\n\t\t\tif (target == \"Single\") {\n\t\t\t\tsingle.emplace_back(mp, damage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tall.emplace_back(mp, damage);\n\t\t\t}\n\t\t}\n\t\tfill(dp1, dp1 + 100101, 1 << 30);\n\t\tdp1[0] = 0;\n\t\tfor (int i = 0; i < single.size(); i++) {\n\t\t\tfor (int j = 0; j <= 100100; j++) {\n\t\t\t\tif (j < single[i].second) continue;\n\t\t\t\tdp1[j] = min(dp1[j], dp1[j - single[i].second] + single[i].first);\n\t\t\t}\n\t\t\tfor (int j = 100100; j > 0; j--) {\n\t\t\t\tdp1[j - 1] = min(dp1[j - 1], dp1[j]);\n\t\t\t}\n\t\t}\n\t\tfill(dp2, dp2 + 100101, 1 << 30);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < all.size(); i++) {\n\t\t\tfor (int j = 0; j <= 100100; j++) {\n\t\t\t\tif (j < all[i].second) continue;\n\t\t\t\tdp2[j] = min(dp2[j], dp2[j - all[i].second] + all[i].first);\n\t\t\t}\n\t\t\tfor (int j = 100100; j > 0; j--) {\n\t\t\t\tdp2[j - 1] = min(dp2[j - 1], dp2[j]);\n\t\t\t}\n\t\t}\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 0; i <= 100100; i++) {\n\t\t\tint cost = 0;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (HP[j] <= i) continue;\n\t\t\t\tcost += dp1[HP[j] - i];\n\t\t\t}\n\t\t\tcost += dp2[i];\n\t\t\tans = min(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int MAX_HP = 100000;\nint enemy[110];\nint dp[2][MAX_HP + 10];\n\nvoid calc(int idx, vector<int> cst, vector<int> dmg) {\n    int N = cst.size();\n    fill(dp[idx], dp[idx] + MAX_HP + 1, INF);\n    dp[idx][0] = 0;\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=MAX_HP; j++) {\n            if(dp[idx][j] == INF) continue;\n            int nj = min(MAX_HP, j+dmg[i]);\n            dp[idx][nj] = min(dp[idx][nj], dp[idx][j] + cst[i]);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    while(cin >> N) {\n        if(N == 0) break;\n        for(int i=0; i<N; i++) cin >> enemy[i];\n        cin >> M;\n\n        vector<int> cst1, cst2, dmg1, dmg2;\n        for(int i=0; i<M; i++) {\n            string s, target;\n            int cost, damage;\n            cin >> s >> cost >> target >> damage;\n            damage = min(damage, MAX_HP);\n            if(target == \"Single\") {\n                cst1.push_back(cost);\n                dmg1.push_back(damage);\n            }\n            else {\n                cst2.push_back(cost);\n                dmg2.push_back(damage);\n            }\n        }\n\n        calc(0, cst1, dmg1);\n        calc(1, cst2, dmg2);\n        for(int j=MAX_HP-1; j>=0; j--) {\n            dp[0][j] = min(dp[0][j], dp[0][j+1]);\n        }\n\n        int ans = INF;\n        // 全体攻撃によるダメージ\n        for(int dmg=0; dmg<=MAX_HP; dmg++) {\n            int tmp = dp[1][dmg];\n            if(tmp == INF) continue;\n            bool ok = true;\n            for(int i=0; i<N; i++) {\n                if(enemy[i] <= dmg) continue;\n                if(dp[0][enemy[i] - dmg] == INF) ok = false;\n                tmp += dp[0][enemy[i] - dmg];\n            }\n            if(ok) ans = min(ans, tmp);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\nint main(){\n    ll n;\n    while(cin>>n,n){\n    vector<ll> a(n);\n    for(auto &i:a){cin>>i;}\n    ll m;\n    cin>>m;\n    vector<pll> Sg,Ml;\n    for(int i=0;i<m;i++){\n        string N,T;\n        ll M,D;\n        cin>>N>>M>>T>>D;\n        if(T==\"Single\"){Sg.push_back({D,M});}\n        else{Ml.push_back({D,M});}\n    }\n    ll mx=100001;\n    vector<ll> dp1(mx,E),dp2(mx,E);\n    dp1[0]=dp2[0]=0;\n    for(auto &i:Sg){\n        for(int t=0;t+i.F<mx;t++){\n            dp1[t+i.F]=min(dp1[t+i.F],dp1[t]+i.S);\n        }\n    }\n    for(auto &i:Ml){\n        for(int t=0;t+i.F<mx;t++){\n            dp2[t+i.F]=min(dp2[t+i.F],dp2[t]+i.S);\n        }\n    }\n    for(ll i=mx-2;i>=0;i--){\n        dp1[i]=min(dp1[i],dp1[i+1]);\n        dp2[i]=min(dp2[i],dp2[i+1]);\n    }\n    ll ans=E;\n    for(int i=0;i<mx;i++){\n        ll count=dp2[i];\n        for(int t=0;t<n;t++){\n            if(a[t]>i){count+=dp1[a[t]-i];}\n        }\n        ans=min(ans,count);\n    }\n    cout<<ans<<endl;\n    \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define INF (1e9)\n#define HP 30001\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;//mpcost,N,HP,Alldamage\ntypedef pair<int,P> P2;\n\nint n,hp[N],m,mp[N],damage[N];\nstring name,target[N];\nmap<P2,int> pam;\n\nint dijkstra(){\n  int r;\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  q.push(P1(P(0,0),P(0,0)));\n  pam[P2(0,P(0,0))]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int mpcost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int alldamage=t.second.second;\n    int d;\n    if(pam.find(P2(y,P(x,alldamage)))==pam.end())d=INF;\n    else d=pam[P2(y,P(x,alldamage))];\n    if(d<mpcost)continue;\n    if(y==n-1&&x>=hp[y]){\n      r=mpcost;\n      break;\n    }\n    if(x>=hp[y]){\n      if(pam.find(P2(y+1,P(alldamage,alldamage)))==pam.end())d=INF;\n      else d=pam[P2(y+1,P(alldamage,alldamage))];\n      if(d>mpcost){\n\tpam[P2(y+1,P(alldamage,alldamage))]=mpcost;\n\tq.push(P1(P(mpcost,y+1),P(alldamage,alldamage)));\n      }\n      continue;\n    }\n    for(int i=0;i<=m;i++){\n      int nmpcost=mpcost+mp[i];\n      int ny=y,nx=x+damage[i];\n      int nalldamage=alldamage;\n      if(target[i]==\"All\")nalldamage+=damage[i];\n      if(nx>hp[ny])nx=hp[ny];\n      if(pam.find(P2(ny,P(nx,nalldamage)))==pam.end())d=INF;\n      else d=pam[P2(ny,P(nx,nalldamage))];\n      if(d>nmpcost){\n\tpam[P2(ny,P(nx,nalldamage))]=nmpcost;\n\tq.push(P1(P(nmpcost,ny),P(nx,nalldamage)));\n      }\n    }\n  }\n  return r;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid calc(vector<int> &dp, const vector<int> &mp, const vector<int> &dm){\n  int m = dp.size();\n  int n = mp.size();\n  assert(mp.size() == dm.size());\n  \n  fill(ALL(dp), INF);\n  dp[0] = 0;\n  \n  REP(i, n){\n    REP(j, m - dm[i]){\n      dp[j+dm[i]] = min(dp[j+dm[i]], dp[j] + mp[i]);\n    }\n    REP(j, m - 1){\n      dp[m-j-2] = min(dp[m-j-2], dp[m-j-1]);\n    }\n  }\n}\n\nint main(){\n  int n, m, mp, dm;\n  string name, range;\n  \n  while(cin >> n && n){\n    vector<int> enemy(n);\n    REP(i, n) cin >> enemy[i];\n  \n    cin >> m;\n    vector<int> mp_all, mp_single;\n    vector<int> dm_all, dm_single;\n  \n    REP(i, m){\n      cin >> name >> mp >> range >> dm;\n      if(range == \"All\"){\n        mp_all.push_back(mp);\n        dm_all.push_back(dm);\n      }else{\n        mp_single.push_back(mp);\n        dm_single.push_back(dm);\n      }\n    }\n\n    int M = *max_element(ALL(enemy)) + 1;\n\n    vector<int> dp_all(M);\n    vector<int> dp_single(M);\n\n    calc(dp_all, mp_all, dm_all);\n    calc(dp_single, mp_single, dm_single);\n\n\n    ll res = INF;\n    REP(i, M){\n      ll sum = dp_all[i];\n      REP(j, n){\n        int d = max(0, enemy[j] - i);\n        sum += dp_single[d];\n      }\n      res = min(res, sum);\n    }\n  \n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1e17\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\n\nsigned main(){\n  cin.tie(0);\t\n  //ios::sync_with_stdio(false);\n  while(1){\n    int n,m;\n    int mxhp=0;\n    cin>>n;\n    if(n==0) break;\n    int a[n];\n    rep(i,n){cin>>a[i];mxhp=max(mxhp,a[i]);}\n    cin>>m;\n    string s[m];\n    int mana[m],damage[m];\n    rep(i,m){\n      cin>>s[i]>>mana[i]>>s[i]>>damage[i];\n      if(damage[i]>100009) damage[i]=100009;\n    }\n    int dps[100010],dpm[100010];\n    rep(i,100010) dps[i]=dpm[i]=INF;\n    dps[0]=0;dpm[0]=0;\n    rep(i,100010){\n      rep(j,m){\n\tif(i+damage[j]<100010){\n\t  if(s[j]==\"Single\" && dps[i]!=INF){\n\t    dps[i+damage[j]]=min(dps[i+damage[j]],dps[i]+mana[j]);\n\t  }else if(s[j]==\"All\" && dpm[i]!=INF){\n\t    dpm[i+damage[j]]=min(dpm[i+damage[j]],dpm[i]+mana[j]);\n\t  }\n\t}else{\n\t  if(s[j]==\"Single\" && dps[i]!=INF){\n\t    dps[100009]=min(dps[100009],dps[i]+mana[j]);\n\t  }else if(s[j]==\"All\" && dpm[i]!=INF){\n\t    dpm[100009]=min(dpm[100009],dpm[i]+mana[j]);\n\t  }\n\t}\n      }\n    }\n    \n    repn(i,100008){\n      dps[i]=min(dps[i],dps[i+1]);\n      dpm[i]=min(dpm[i],dpm[i+1]);\n      \n    }\n    \n    int ans=INF;\n    rep(i,mxhp+1){\n      int cnt=0;\n      cnt+=dpm[i];\n      rep(j,n){\n\tcnt+=dps[max((int)0,a[j]-i)];\n      }\n      ans=min(cnt,ans);\n    }\n    cout<<ans<<endl;\n  }\n      \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;//first : MP, second : Damage\nvoid set_cost(vector<int>& cost, const vector<pint>& attack){\n    cost[0] = 0;\n    REP(i, 1, cost.size()){\n        for(pint k : attack){\n            int temp = k.first;\n            if(i - k.second >= 0) temp += cost[i - k.second];\n            cost[i] = min(cost[i], temp);\n        }\n    }\n    return;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        int HP_MAX = -INF;\n        vector<int> HP(N);\n        rep(i, N){\n            cin >> HP[i];\n            HP_MAX = max(HP_MAX, HP[i]);\n        }\n        int M; cin >> M;\n        vector<pint> single, all;\n        rep(i, M){\n            string a, b;\n            int c, d;\n            cin >> a >> c >> b >> d;\n            if(b == \"All\")\n              all.push_back(pint(c, d));\n            else\n              single.push_back(pint(c, d));\n        }\n        vector<int> scost(HP_MAX + 1, INF), acost(HP_MAX + 1, INF);\n        set_cost(scost, single);\n        set_cost(acost, all);\n        ll ans = 0;\n        /*rep(d, HP_MAX + 1){\n            ll sum = acost[d];\n            for(int k : HP){\n                int need = max(0, k - d);\n                sum += scost[need];\n            }\n            ans = min(sum, ans);\n        }*/\n        while(true){\n            int hit = INF, enemies = 0;\n            for(int k : HP)\n              if(k > 0) {\n                  enemies++;\n                  hit = min(k, hit);\n              }\n            if(enemies == 0) break;\n            int cost, damage;\n            if(acost[hit] > scost[hit] * enemies){\n                cost = scost[hit];\n                REP(i, hit, HP_MAX + 1) if(scost[i] != cost){ damage = i - 1; break;}\n                cost *= enemies;\n            }else{\n                cost = acost[hit];\n                REP(i, hit, HP_MAX + 1) if(acost[i] != cost){ damage = i - 1; break;}\n            }\n            for(int& k : HP) k -= damage;\n            ans += (ll)cost;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#define INF 1e12\nusing namespace std;\ntypedef long long ll;\nint n,m;\nint hp[101];\nll dp[2][100001];\nint mp[101],t[101],d[101];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&hp[i]);\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str,st2;\n\t\t\tcin >> str >> mp[i] >> st2 >> d[i];\n\t\t\tif(st2==\"Single\")t[i]=0;\n\t\t\telse t[i]=1;\n\t\t}\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tdp[0][i]=dp[1][i]=INF;\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tdp[i][0]=0;\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tif(dp[i][j]<INF){\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(t[k]==i){\n\t\t\t\t\t\t\tdp[i][min(j+d[k],100000)]=min(dp[i][min(j+d[k],100000)],dp[i][j]+mp[k]);\n\t\t\t\t\t\t\t//printf(\"%d %d %d\\n\",i,min(j+d[k],100000),dp[i][min(j+d[k],100000)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=100000;j>=1;j--){\n\t\t\t\tif(dp[i][j]<dp[i][j-1])dp[i][j-1]=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tll res=INF;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tll cost=dp[1][i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(hp[j]>i)cost+=dp[0][hp[j]-i];\n\t\t\t}\n\t\t\tres=min(res,cost);\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\nint N,M,HP[105],A,SDP[100005],ADP[100005],res,tmp;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tmemset(ADP,0x7f,sizeof(ADP));\n\t\tSDP[0]=ADP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tSDP[np]=min(SDP[np],SDP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tfor(int i=100000;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\n\t\tfor(int i=M-A;i<M;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tADP[np]=min(ADP[np],ADP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tif(A==M)\n\t\t{\n\t\t\tint mh=0;\n\t\t\tfor(int i=0;i<N;i++)mh=max(mh,HP[i]);\n\t\t\tfor(int i=mh;i<=100000;i++)\n\t\t\t\tres=min(res,ADP[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<=100000;i++)\n\t\t\t{\n\t\t\t\ttmp=ADP[i];\n\t\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\t{\n\t\t\t\t\tif(HP[k]-i>=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint np=HP[k]-i;\n\t\t\t\t\t\tif(np>0)np=0;\n\t\t\t\t\t\ttmp+=SDP[np];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres=min(res,tmp);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid calc(vector<int> &dp, const vector<int> &mp, const vector<int> &dm){\n  int m = dp.size();\n  int n = mp.size();\n  assert(mp.size() == dm.size());\n  \n  fill(ALL(dp), INF);\n  dp[0] = 0;\n  \n  REP(i, n){\n    REP(j, m - dm[i]){\n      dp[j+dm[i]] = min(dp[j+dm[i]], dp[j] + mp[i]);\n    }\n    REP(j, m - 1){\n      dp[m-j-2] = min(dp[m-j-2], dp[m-j-1]);\n    }\n  }\n}\n\nint main(){\n  int n, m, mp, dm;\n  string name, range;\n  \n  cin >> n;\n  vector<int> enemy(n);\n  REP(i, n) cin >> enemy[i];\n  \n  cin >> m;\n  vector<int> mp_all, mp_single;\n  vector<int> dm_all, dm_single;\n  \n  REP(i, m){\n    cin >> name >> mp >> range >> dm;\n    if(range == \"All\"){\n      mp_all.push_back(mp);\n      dm_all.push_back(dm);\n    }else{\n      mp_single.push_back(mp);\n      dm_single.push_back(dm);\n    }\n  }\n\n  int M = *max_element(ALL(enemy)) + 1;\n\n  vector<int> dp_all(M);\n  vector<int> dp_single(M);\n\n  calc(dp_all, mp_all, dm_all);\n  calc(dp_single, mp_single, dm_single);\n\n\n  ll res = INF;\n  REP(i, M){\n    ll sum = dp_all[i];\n    REP(j, n){\n      int d = max(0, enemy[j] - i);\n      sum += dp_single[d];\n    }\n    res = min(res, sum);\n  }\n  \n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<LL> maketbl(const vector<int> &mp, const vector<int> &dmg){\n\tvector<LL> ret(100001, 1LL << 60);\n\tret[0] = 0;\n\tfor(int i = 1; i <= 100000; ++i){\n\t\tfor(size_t j = 0; j < mp.size(); ++j){\n\t\t\tret[i] = min(ret[i], ret[max(i - dmg[j], 0)] + mp[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> hp(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tvector<int> mps, dmgs, mpa, dmga;\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint d, p;\n\t\t\tchar c;\n\t\t\tscanf(\"%*s%d %c%*s%d\", &p, &c, &d);\n\t\t\tif(d){\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\tmps.push_back(p);\n\t\t\t\t\tdmgs.push_back(d);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmpa.push_back(p);\n\t\t\t\t\tdmga.push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<LL> tbls = maketbl(mps, dmgs);\n\t\tvector<LL> tbla = maketbl(mpa, dmga);\n\t\tLL ans = 1LL << 60;\n\t\tfor(int i = 0; i <= 100000; ++i){\n\t\t\tLL s = tbla[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\ts += tbls[max(hp[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, s);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000001\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nint dp[2][MAX_Damage];\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)\n\t{\n\t  rep(j,MP[i].size())\n\t    {\n\t      rep(k,MAX_Damage)\n\t\t{\n\t\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t\t      dp[i][k] + MP[i][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,2)\n\t{\n\t  for(int j=MAX_Damage-2;j>=0;j--)\n\t    {\n\t      dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\t    }\n\t}\n\n      int ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  if(dp[1][i] == inf)continue;\n\t  int cnt = dp[1][i];\n\t  rep(j,N)//Single\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      if(dp[0][HP[j]-i] == inf)continue;\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  ans = min(ans,cnt);\n\t}\n\n      int mex = -inf;\n      int cnt = 0;\n      rep(i,N)//Single\n\t{\n\t  mex = max(mex,HP[i]);\n\t  cnt += dp[0][HP[i]];\n\t}\n      ans = min(ans,cnt);\n      ans = min(ans,dp[1][mex]);//All\n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, M;\nint HP[105];\nvector<P> sing, all;\nint dp_sing[100005], dp_all[100005];\n\nvoid calc(int dp[100005], vector<P> &vec)\n{\n\tfor(int i = 0; i < 100005; i++) dp[i] = inf;\n\tdp[0] = 0;\n\t\n\tfor(int i = 0; i <= 100000; i++){\n\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\tif(i <= vec[j].second) dp[i] = min(dp[i], vec[j].first);\n\t\t\telse dp[i] = min(dp[i], dp[i-vec[j].second] + vec[j].first);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 0; i < N; i++) cin >> HP[i];\n\t\t\n\t\tcin >> M;\n\t\t\n\t\tstring s, t;\n\t\tint mp, dmg;\n\t\t\n\t\tsing.clear();\n\t\tall.clear();\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s >> mp >> t >> dmg;\n\t\t\tif(t == \"Single\") sing.push_back( make_pair(mp, dmg) );\n\t\t\telse all.push_back( make_pair(mp, dmg) );\n\t\t}\n\t\t\n\t\tcalc(dp_sing, sing);\n\t\tcalc(dp_all, all);\n\t\t\n\t\tint sum, ans = inf;\n\t\tfor(int i = 0; i <= 100000; i++){\n\t\t\tsum = dp_all[i];\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(HP[j] - i > 0) sum += dp_sing[ HP[j] - i ];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst int INF = 10000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tmemset(mon, 0, sizeof(mon));\n\t\tmemset(mag, 0, sizeof(mag));\n\t\tvector<magic> all;\n\t\tvector<magic> single;\n\t\tvector<magic> crit;\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\t\t\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tint mon2[120];\n\t\t\tmemcpy(mon2, mon, sizeof(mon));\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tmon2[j] -= i;\n\t\t\t\tif(mon2[j] > 0) prev += dp2[mon2[j]];\n\t\t\t}\n\t\t\t\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, m, a[200], b[200], d[200]; vector<int>v1, v2, w1, w2, dp1, dp2;\nvector<int>knapsack(int W, vector<int>v, vector<int>w) {\n\tvector<int>dp(W + 1000, 999999999);\n\tfor (int i = 0; i < dp.size(); i++) { dp[i] = 999999999; }\n\tdp[0] = 0;\n\tfor (int i = 0; i < (int)min(v.size(), w.size()); i++) {\n\t\tfor (int j = v[i]; j <= W; j++)dp[j] = min(dp[j], dp[j - v[i]] + w[i]);\n\t}\n\tfor (int i = W - 1; i >= 0; i--) {\n\t\tdp[i] = min(dp[i], dp[i + 1]);\n\t}\n\treturn dp;\n}\nint main() {\n\twhile (true) {\n\t\tv1.clear(); v2.clear(); w1.clear(); w2.clear(); dp1.clear(); dp2.clear();\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> a[i]; cin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tstring S, T; cin >> S >> b[i] >> T >> d[i]; if (d[i] >= 200000)d[i] = 200000;\n\t\t\tif (d[i] == 0)continue;\n\t\t\tif (T == \"Single\") { v1.push_back(d[i]); w1.push_back(b[i]); }\n\t\t\tif (T == \"All\") { v2.push_back(d[i]); w2.push_back(b[i]); }\n\t\t}\n\t\tdp1 = knapsack(400000, v1, w1);\n\t\tdp2 = knapsack(400000, v2, w2);\n\t\tif (v1.size() == 0) {\n\t\t\tint maxn = 0; for (int i = 0; i < n; i++)maxn = max(maxn, a[i]);\n\t\t\tcout << dp2[maxn] << endl;\n\t\t}\n\t\telse {\n\t\t\tint maxn = 999999999;\n\t\t\tfor (int i = 0; i <= 300000; i++) {\n\t\t\t\tint sum = dp2[i];\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (a[j] > i && dp1[a[j] - i] <= 1e8) {\n\t\t\t\t\t\tsum += dp1[a[j] - i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = min(maxn, sum);\n\t\t\t}\n\t\t\tcout << maxn << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nint dp1[100010],dp2[100010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint m,d;\n\t\t\tcin>>s>>m>>t>>d;\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=m;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=m;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+100001,INF);\n\t\tfill(dp2,dp2+100001,INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,100001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,100001){\n\t\t\tint res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tint rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\ntemplate <typename T> constexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity() : numeric_limits<T>::max() / 4;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); } } initCpp;\n\nsigned main() {\n  while (true) {\n    i64 n;\n    cin >> n;\n    if (n == 0) break;\n    vector<i64> HP(n);\n    i64 hpm = 0;\n    REP(i, n) {\n      cin >> HP[i];\n      hpm = max(hpm, HP[i]);\n    }\n    i64 m;\n    cin >> m;\n    vector<i64> MP(m);\n    vector<bool> Single(m);\n    vector<i64> Damage(m);\n    REP(i, m) {\n      cin.ignore(numeric_limits<streamsize>::max(), ' ');\n      string target;\n      cin >> MP[i] >> target >> Damage[i];\n      Single[i] = target == \"Single\";\n    }\n    vector<i64> A(hpm + 1, inf<i32>);\n    vector<i64> B(hpm + 1, inf<i32>);\n    A[0] = 0;\n    B[0] = 0;\n    REP(d, hpm + 1) {\n      REP(k, m) {\n        if (Single[k]) {\n          A[d] = min(A[d], (d - Damage[k] < 0 ? 0 : A[d - Damage[k]]) + MP[k]);\n        } else {\n          B[d] = min(B[d], (d - Damage[k] < 0 ? 0 : B[d - Damage[k]]) + MP[k]);\n        }\n      }\n    }\n    i64 ans = inf<i64>;\n    REP(d, hpm + 1) {\n      i64 sum = 0;\n      REP(i, n) {\n        sum += HP[i] - d < 0 ? 0 : A[HP[i] - d];\n        sum = min(sum, inf<i64>);\n      }\n      sum += B[d];\n      ans = min(ans, sum);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 32;\n\nconst int MAX_D = 1000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tsi[i - 1] = min(si[i - 1], si[i]);\n\t\t}\n\n\t\tlong long ans = al[*max_element(all(h))];\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct data{ int mp,damage; };\n#define INF (1e9)\nint N,M;\nint HP[100];\nvector< data > single,all;\n \nint dp[100001];\nint dp2[100001];\n \nint main(){\n   \n  int b,d;\n  string a,c;\n  while(1){\n    cin>>N;\n    single.clear();\n    all.clear();\n    if(N==0)break;\n    for(int i=0;i<N;i++)cin>>HP[i];\n \n    cin>>M;\n    for(int i=0;i<M;i++){\n      cin>>a>>b>>c>>d;\n      if(d==0)continue;\n      if(c==\"Single\"){\n    single.push_back( (data){b,d} );\n      }else{\n    all.push_back( (data){b,d} );\n      }\n    }\n    for(int i=0;i<=100000;i++)dp[i]=dp2[i]=INF;\n    dp[0]=dp2[0]=0;\n \n \n    for(int i=0;i<(int)single.size();i++){\n      data d=single[i];\n      for(int j=0;j<=100000;j++){\n    if(j-d.damage<=0)dp[j]=min(dp[j],d.mp);\n    else dp[j]=min(dp[j],dp[j-d.damage]+d.mp);\n      }\n    }\n    for(int i=0;i<(int)all.size();i++){\n      data d=all[i];\n      for(int j=0;j<=100000;j++){\n    if(j-d.damage<=0)dp2[j]=min(dp2[j],d.mp);\n    else dp2[j]=min(dp2[j],dp2[j-d.damage]+d.mp);\n      }\n    }\n \n    int ans=INF,sum;\n    for(int i=0;i<=100000;i++){\n      if(dp2[i]==INF)break;\n      sum=0;\n      for(int j=0;j<N;j++){\n    if(HP[j]<=i)continue;\n    if(dp[HP[j]-i]==INF){sum=INF;break;}\n    sum+=dp[HP[j]-i];\n      }\n       \n      ans=min(ans,dp2[i]+sum);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\n#define inf 999999999999\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        for(int i=1;i<=10000;i++)dp2[i]=-inf;\n        dp2[0]=0;\n        memset(dp1,0,sizeof dp1);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=inf,sum;\n        for(int i=0; i<10001; i++)\n        {\n            if(dp2[i]<0)continue;\n            sum=i;\n            for(int j=0; j<n; j++)\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define MAX_H 100000\n#define INF (1<<29)\n\nint main(){\n    int N,M;\n    string in;\n    while(cin >> N, N){\n        int MHP = 0;\n        vector<int> HP(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> HP[i];\n            MHP = max(MHP,HP[i]);\n        }\n        cin >> M;\n        vector<int> MP(M),t(M),d(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> in >> MP[i] >> in >> d[i];\n            t[i] = (in == \"All\");\n        }\n        int dp[2][MAX_H+1];\n        fill(dp[0],dp[0]+2*(MAX_H+1),INF);\n        dp[0][0] = dp[1][0] = 0;\n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j <= MHP ; j++){\n                int nt = t[i],nhp = min(MHP,j+d[i]);\n                dp[nt][nhp] = min(dp[nt][nhp],dp[nt][j]+MP[i]);\n            }\n        }\n        for(int i = MHP ; i > 0 ; i--){\n            dp[0][i-1] = min(dp[0][i-1],dp[0][i]);\n            dp[1][i-1] = min(dp[1][i-1],dp[1][i]);\n        }\n        int res = INF;\n        for(int i = 0 ; i <= MHP ; i++){\n            int mp = dp[1][i],mp2 = 0;\n            if(mp == INF) continue;\n            for(int j = 0 ; j < N ; j++){\n                int rest = max(HP[j]-i,0);\n                if(rest == 0) continue;\n                mp2 += dp[0][rest];\n            }\n            res = min(res,mp+mp2);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n#define int long long\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=INT_MAX;\n\nint dp1[100010];\nint dp2[100010];\nvoid mainmain(){\n\tint n;\n\tint m;\n\twhile(cin>>n,n){\n\t\tvint hp(n);\n\t\trep(i,n) cin>>hp[i];\n\t\tcin>>m;\n\t\tvector<pii> one,all;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint a,b;\n\t\t\tcin>>a>>s>>b;\n\t\t\tb=min(b,100005LL);\n\t\t\tif(s==\"Single\"){\n\t\t\t\tone.PB(mkp(a,b));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tall.PB(mkp(a,b));\n\t\t\t}\n\t\t}\n\t\t// cout<<\"aaa\\n\";\n\t\trep(i,100010){\n\t\t\tdp1[i]=INF;\n\t\t\tdp2[i]=INF;\n\t\t}\n\t\tdp1[0]=0;\n\t\t// cout<<\"size \"<<(int)one.size()<<endl;\n\t\trep(i,one.size()){\n\t\t\trep(j,100010){\n\t\t\t\tif(j+one[i].S>=100010){\n\t\t\t\t\tdp1[100009]=min(dp1[100009],dp1[j]+one[i].F);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(dp1[j]==INF) continue;\n\t\t\t\t// if(dp1[j]+one[i].F<0) continue;\n\t\t\t\tdp1[j+one[i].S]=min(dp1[j+one[i].S],dp1[j]+one[i].F);\n\t\t\t}\n\t\t}\n\t\tint M=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\t// if(dp1[i]!=INF) cout<<\"dp1\"<<\" \"<<i<<\" \"<<dp1[i]<<endl;\n\t\t\tdp1[i]=min(dp1[i],M);\n\t\t\tM=min(dp1[i],M);\n\t\t}\n\t\tdp2[0]=0;\n\t\trep(i,all.size()){\n\t\t\trep(j,100010){\n\t\t\t\tif(j+all[i].S>=100010) break;\n\t\t\t\tif(dp2[j]==INF) continue;\n\t\t\t\t// if(dp2[j]+all[i].F<0) continue;\n\t\t\t\tdp2[j+all[i].S]=min(dp2[j+all[i].S],dp2[j]+all[i].F);\n\t\t\t}\n\t\t}\n\t\tM=INF;\n\t\tfor(int i=100009;i>=0;i--){\n\t\t\tdp2[i]=min(dp2[i],M);\n\t\t\tM=min(dp2[i],M);\n\t\t\t// if(i<100) cout<<\"dp2 \"<<i<<\" \"<<dp2[i]<<endl;\n\t\t}\n\t\t// cout<<\"M \"<<M<<endl;\n\t\t// cout<<\"hoge\\n\";\n\t\tint ans=INF;\n\t\trep(i,100010){\n\t\t\tint tmp=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tif(hp[j]<=i) continue;\n\t\t\t\ttmp+=dp1[hp[j]-i];\n\t\t\t}\n\t\t\tans=min(ans,tmp);\n\t\t}\n\t\t// cout<<\"dp1\\n\";\n\t\t// rep(i,50){\n\t\t\t// cout<<i<<\" \"<<dp1[i]<<endl;\n\t\t// }\n\t\t// cout<<\"dp2\"<<endl;\n\t\t// rep(i,50){\n\t\t\t// cout<<i<<\" \"<<dp2[i]<<endl;\n\t\t// }\n\t\t// cout<<ans<<endl;\n\t\t// rep(i,n){\n\t\t\t// if(hp[i]-40221*2>0) cout<<hp[i]-40221*2<<endl;\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n\n}\n/*\n\n\nN 12 Single 185515\nA 5 All 40221\nI 4 Single 149524\nO 53 Single 234292\nH 1 Single 728919\nJ 99 All 326986\nK 59 Single 920445\nD 7 Single 896780\nY 0 Single 0\nS 17 Single 752291\nW 88 All 326927\n\n*/\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tbool no=false;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0){\n\t\t\t\t\tif(dp2[0][a]==INF){\n\t\t\t\t\t\tno=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcnt+=dp2[0][a];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(no)continue;\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[200],b[200],d[200];vector<int>v1,v2,w1,w2,dp1,dp2;\nvector<int>knapsack(int W,vector<int>v,vector<int>w){\n\tvector<int>dp(W+1000,999999999);\n\tfor(int i=0;i<dp.size();i++){dp[i]=999999999;}\n\tdp[0]=0;\n\tfor(int i=0;i<(int)v.size();i++){\n\t\tfor(int j=v[i];j<=W;j++)dp[j]=min(dp[j],dp[j-v[i]]+w[i]);\n\t}\n\tfor(int i=W-1;i>=0;i--){\n\t\tdp[i]=min(dp[i],dp[i+1]);\n\t}\n\treturn dp;\n}\nint main(){\n\twhile(true){\n\t\tv1.clear();v2.clear();w1.clear();w2.clear();dp1.clear();dp2.clear();\n\t\tfor(int i=0;i<200;i++){a[i]=0;b[i]=0;d[i]=0;}\n\t\tcin>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];cin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring S,T;cin>>S>>b[i]>>T>>d[i];if(d[i]>=200000)d[i]=200000;\n\t\t\tif(T==\"Single\"){v1.push_back(d[i]);w1.push_back(b[i]);}\n\t\t\tif(T==\"All\"){v2.push_back(d[i]);w2.push_back(b[i]);}\n\t\t}\n\t\tdp1=knapsack(400000,v1,w1);\n\t\tdp2=knapsack(400000,v2,w2);\n\t\tint maxn=999999999;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint sum=dp2[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(a[j]>i)sum+=dp1[a[j]-i];\n\t\t\t}\n\t\t\tmaxn=min(maxn,sum);\n\t\t}\n\t\tcout<<maxn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nconst int MAX_D = 1000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tif(res[i] == INF) continue;\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tsi[i - 1] = min(si[i - 1], si[i]);\n\t\t}\n\n\t\tlong long ans = al[*max_element(all(h))];\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 2 * 1e9;\n\nconst int MAX_D = 1000005;\n\nvector<int> dp(vector<pair<int, int>>& a){\n\tvector<int> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tint idx = min(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<int,int>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tint MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<int> al = dp(a);\n\t\tvector<int> si = dp(s);\n\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tsi[i - 1] = min(si[i - 1], si[i]);\n\t\t}\n\n\t\tint ans = al[*max_element(all(h))];\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tint sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst ll inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n; if(n==0) break;\n        vector<ll> hp(n);\n        for(ll& in:hp) cin >> in;\n        cin >> m;\n        vector<ll> consume(m),damage(m);\n        vector<string> type(m);\n        rep(i,0,m){\n            string s;\n            cin >> s >> consume[i] >> type[i] >> damage[i];\n        }\n\n        ll ans=inf,dp1[100001],dp2[100001];\n        fill_n((ll*)dp1,100001,infll);\n        fill_n((ll*)dp2,100001,infll);\n        dp1[0]=dp2[0]=0;\n        rep(i,0,m){\n            ll* dp;\n            if(type[i]==\"Single\") dp=dp1;\n            else dp=dp2;\n            rep(j,0,100001) dp[j]=min(dp[j],dp[max(j-damage[i],0LL)]+consume[i]);\n        }\n        rep(i,0,100001){\n            ll tmp=dp2[i];\n            rep(j,0,n) if(hp[j]-i>=0) tmp+=dp1[hp[j]-i];\n            ans=min(ans,tmp);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r;\n\tstring str;\n\tfor(;cin>>n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tmap<int,int>all_iter;\n\t\tall_iter[0]=0;\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t\tall_iter[all[i]]=i;\n\t\t}\n\n\t\tr=9999999;\n\t\tfor(map<int,int>::iterator it=all_iter.begin();it!=all_iter.end();it++){\n\t\t\th=it->first;\n\t\t\tfor(j=0;j<monster.size();j++)h+=single[max(0,monster[j]-it->second)];\n\t\t\tif(r>h)r=h;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<28\n#define MAX_HP 100001\n\nusing namespace std;\n\nstruct monster{\n\tint hp;\n};\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n};\n\nvoid min_mp(int *min, int max_hp, const vector<magic> &vmag){\n\tint m = vmag.size();\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tmin[i] = INFTY;\n\t}\n\n\tif( m == 0 )\n\t\treturn ;\n\n\tint **dp = new int*[m];\n\tfor(int i = 0; i < m; ++i){\n\t\tdp[i] = new int[max_hp];\n\t}\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tdp[i][j] = INFTY;\n\t\t}\n\t}\n\t\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < m; ++i){\n\t\tint mp = vmag[i].mp;\n\t\tint damage = vmag[i].damage;\n\t\t\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tif( dp[i][j] < INFTY ){\n\t\t\t\tif( i + 1 < m )\n\t\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][j] );\n\t\t\t\tint &t = dp[i][std::min(j+damage,max_hp-1)];\n\t\t\t\tt = std::min( t, dp[i][j] + mp );\n\t\t\t}\n\t\t}\n\t}\n\n\tmin[max_hp-1] = dp[m-1][max_hp-1];\n\tfor(int i = max_hp-2; i >= 0; --i){\n\t\tmin[i] = std::min( min[i+1], dp[m-1][i] );\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tdelete [] dp[i];\n\t}\n\tdelete [] dp;\n}\nint MagicSlayer(const vector<monster> &vmon, const vector<magic> &vmag){\n\tint ret = INFTY;\n\tvector<magic> vmag_single;\n\tvector<magic> vmag_all;\n\tint max_hp = 0;\n\tint min_mp_single[MAX_HP]={0,};\n\tint min_mp_all[MAX_HP]={0,};\n\n\tfor(unsigned int i = 0; i < vmon.size(); ++i){\n\t\tmax_hp = max( max_hp, vmon[i].hp );\n\t}\n\t++max_hp;\n\n\tfor(unsigned int i = 0; i < vmag.size(); ++i){\n\t\tif( vmag[i].type == ALL )\n\t\t\tvmag_all.push_back( vmag[i] );\n\t\telse\n\t\t\tvmag_single.push_back( vmag[i] );\n\t}\n\n\tmin_mp( min_mp_single, max_hp, vmag_single );\n\tmin_mp( min_mp_all, max_hp, vmag_all );\n\n\t/*for(int i = 0; i < max_hp; ++i){\n\t\tif( i % 500 == 0 )\n\t\t\tcout << \"DAMAGE: \" << i << \" MP: \" << min_mp_single[i] << endl;\n\t}*/\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tint dam;\n\t\tint mp;\n\n\t\tif( min_mp_all[i] >= INFTY ){\n\t\t\tdam = 0;\n\t\t\tmp = 0;\n\t\t}else{\n\t\t\tdam = i;\n\t\t\tmp = min_mp_all[i];\n\t\t}\n\n\t\tfor(unsigned int j = 0; j < vmon.size(); ++j){\n\t\t\tif( vmon[j].hp - dam > 0 ){\n\t\t\t\tint t = min_mp_single[ vmon[j].hp - dam ];\n\t\t\t\tif( t >= INFTY ){\n\t\t\t\t\tmp = INFTY;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tmp += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret = min( ret, mp );\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tvector<monster> vmonster;\n\t\tvector<magic> vmagic;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmonster t;\n\t\t\t\n\t\t\tscanf(\"%d\", &t.hp);\n\t\t\tvmonster.push_back( t );\n\t\t}\n\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar stype[17]=\"\";\n\t\t\tmagic mag;\n\n\t\t\tscanf(\"%*s%d%s%d\", &mag.mp, stype, &mag.damage);\n\t\t\tif(strcmp(stype,\"All\")==0)mag.type=ALL;\n\t\t\telse mag.type=SINGLE;\n\t\t\tvmagic.push_back( mag );\n\t\t}\n\n\t\tprintf(\"%d\\n\", MagicSlayer( vmonster, vmagic ) );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nint dp1[200010],dp2[200010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint m,d;\n\t\t\tcin>>s>>m>>t>>d;\n\t\t\td=min(d,100000);\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=m;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=m;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+200001,INF);\n\t\tfill(dp2,dp2+200001,INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,200001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=199999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,200001){\n\t\t\tint res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tint rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nvector<P>v1,v2;\nint a[101],dp1[100001],dp2[100001],n,t1,t2,t;\nstring s;\nmain(){\n\twhile(cin>>n,n){\n\t\tint ans=1e8;\n\t\tr(i,100001)dp1[i]=dp2[i]=1e8;\n\t\tdp1[0]=dp2[0]=0;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tr(i,n)cin>>a[i];\n\t\tcin>>t;\n\t\tr(i,t){\n\t\t\tcin>>s>>t1>>s>>t2;\n\t\t\tif(t2>100000)t2=100000;\n\t\t\tif(s==\"All\")v1.push_back(P(t1,t2));\n\t\t\telse v2.push_back(P(t1,t2));\n\t\t}\n\t\tr(i,v1.size())r(j,100001)if(j+v1[i].S<=100001)\n\t\t  dp1[j+v1[i].S]=min(dp1[j+v1[i].S],dp1[j]+v1[i].F);\n\t\t  else dp1[100000]=min(dp1[100000],dp1[j]+v1[i].F);\n\t\tr(i,v2.size())r(j,100001)if(j+v2[i].S<=100001)\n\t\t  dp2[j+v2[i].S]=min(dp2[j+v2[i].S],dp2[j]+v2[i].F);\n\t\t  else dp2[100000]=min(dp2[100000],dp2[j]+v1[i].F);\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tr(i,100001){\n\t\t\tint sum=0;\n\t\t\tr(j,n)if(a[j]-i>0)sum+=dp2[a[j]-i];\n\t\t\tans=min(ans,sum+dp1[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 2000000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\t//\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp = INF;\n  for(int i=maxhp;i>=0;i--){\n    if ( single[n][i] >=INF){res_all[i]=INF;continue;}\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  } \n\n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\t\tif(all.empty()){\n\t\t\tfor(r=j=0;j<monster.size();j++)r+=single[monster[j]];\n\t\t}else if(single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;\n\t\t\tfor(i=0;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000007\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, M;\nint hp[100];\nP x[2][100];\nint dp[2][100001];\n\nvoid solve(){\n\trep(i,n) cin >> hp[i];\n\trep(i,2) for(int j = 0; j <= 100000; j++) dp[i][j] = INF;\n\tdp[0][0] = 0; dp[1][0] = 0;\n\tcin >> M;\n\tint m[2] = {0,0};\n\trep(i,M){\n\t\tstring na, tar;\n\t\tint mp, dam, u = 0;\n\t\tcin >> na >> mp >> tar >> dam;\n\t\tif(tar[0] == 'A') u = 1;\n\t\tx[u][m[u]] = P(mp,dam);\n\t\tm[u]++;\n\t}\n\trep(u,2){\n\t\trep(i,m[u]){\n\t\t\tP p = x[u][i];\n\t\t\tfor(int j = 0; j <= 100000; j++){\n\t\t\t\tif(j < p.second) dp[u][j] = min(dp[u][j],p.first);\n\t\t\t\telse dp[u][j] = min(dp[u][j],dp[u][j-p.second]+p.first);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i = 0; i <= 100000; i++){\n\t\tint cnt = dp[1][i];\n\t\trep(j,n){\n\t\t\tif(hp[j]-i < 0) continue;\n\t\t\tint h = hp[j]-i;\n\t\t\tcnt += dp[0][h];\n\t\t}\n\t\tans = min(ans,cnt);\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\n\t\t\tr=9999999;\n\t\t\tfor(i=0;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nint dp1[100010];\nint dp2[100010];\nvoid mainmain(){\n\tint n;\n\tint m;\n\tcin>>n;\n\tvint hp(n);\n\trep(i,n) cin>>hp[i];\n\tcin>>m;\n\tvector<pii> one,all;\n\trep(i,m){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint a,b;\n\t\tcin>>a>>s>>b;\n\t\tif(s==\"Single\"){\n\t\t\tone.PB(mkp(a,b));\n\t\t}\n\t\telse{\n\t\t\tall.PB(mkp(a,b));\n\t\t}\n\t}\n\t// cout<<\"aaa\\n\";\n\trep(i,100010){\n\t\tdp1[i]=INF;\n\t\tdp2[i]=INF;\n\t}\n\tdp1[0]=0;\n\t// cout<<\"size \"<<(int)one.size()<<endl;\n\trep(i,one.size()){\n\t\trep(j,100010){\n\t\t\tif(j+one[i].S>=100010) break;\n\t\t\tdp1[j+one[i].S]=min(dp1[j+one[i].S],dp1[j]+one[i].F);\n\t\t}\n\t}\n\tint M=INF;\n\tfor(int i=100009;i>=0;i--){\n\t\tdp1[i]=min(dp1[i],M);\n\t\tM=min(dp1[i],M);\n\t}\n\tdp2[0]=0;\n\trep(i,all.size()){\n\t\trep(j,100010){\n\t\t\tif(j+all[i].S>=100010) break;\n\t\t\tdp2[j+all[i].S]=min(dp2[j+all[i].S],dp2[j]+all[i].F);\n\t\t}\n\t}\n\tM=INF;\n\tfor(int i=100009;i>=0;i--){\n\t\tdp2[i]=min(dp2[i],M);\n\t\tM=min(dp2[i],M);\n\t\t// if(i<100) cout<<\"dp2 \"<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t// cout<<\"M \"<<M<<endl;\n\t// cout<<\"hoge\\n\";\n\tint ans=INF;\n\trep(i,100010){\n\t\tint tmp=dp2[i];\n\t\trep(j,n){\n\t\t\tif(hp[j]<=i) continue;\n\t\t\ttmp+=dp1[hp[j]-i];\n\t\t}\n\t\tif(ans>tmp){\n\t\t\tans=min(ans,tmp);\n\t\t\t// cout<<i<<endl;\n\t\t}\n\t}\n\t// cout<<\"dp1\\n\";\n\t// rep(i,50){\n\t\t// cout<<i<<\" \"<<dp1[i]<<endl;\n\t// }\n\t// cout<<\"dp2\"<<endl;\n\t// rep(i,50){\n\t\t// cout<<i<<\" \"<<dp2[i]<<endl;\n\t// }\n\tcout<<ans<<endl;\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nstruct Magi{int mp,damage;\n  float cosper;\n  Magi(int a,int b,float c){\n    mp = a;\n    cosper = c;\n    damage = b;\n  }\n};\nint main(){\n  int n;\n  cin >> n;\n  vector<int> enemy_def(n+1,0);\n  REP(i,n) cin >> enemy_def[i+1];\n\n  int m;\n  cin >> m;\n  vector<Magi> ALLmagic;\n  vector<Magi> SINmagic;\n  int a_ct = 0,s_ct = 0;\n  int best_all = 0, best_sin = 0;\n  REP(i,m){\n    int mp,damage;\n    string name,target;\n    cin >> name >> mp >> target >> damage;\n    if(target == \"All\"){\n      ALLmagic.push_back(Magi(mp,damage,float(damage/mp)));\n      if(float(damage/mp) > ALLmagic[best_all].cosper)\n\tbest_all = a_ct;\n      a_ct++;\n    }else{\n      SINmagic.push_back(Magi(mp,damage,float(damage/mp)));\n      if(float(damage/mp) > SINmagic[best_sin].cosper)\n\tbest_sin = s_ct;\n      s_ct++;      \n    }\n  }\n  sort(enemy_def.begin(),enemy_def.end());\n  int best_mp = 10000000;\n  for(int i=0;i<=n;i++){\n    int con_mp=0;\n    vector<int> enemy(enemy_def);\n    while(enemy[i] >= ALLmagic[best_all].damage){\n      REP(j,n){\n\tenemy[j+1] -= ALLmagic[best_all].damage;\n      }\n\tcon_mp += ALLmagic[best_all].mp;\t  \n    }\n    //??????????????§??????????????\\???\n    int but_best_all = best_all;\n    if(i>0 && enemy[i]>0){\n      for(int k = 0;k<ALLmagic.size();k++){\n\tif(i==0 || enemy[i] <= 0)break;\n\tif(ALLmagic[but_best_all].mp>ALLmagic[k].mp && ALLmagic[k].damage >= enemy[i] || ALLmagic[but_best_all].mp==ALLmagic[k].mp && ALLmagic[k].damage >= enemy[i] && ALLmagic[but_best_all].damage > ALLmagic[k].damage){\n\t  but_best_all = k;\n\t}\n      }\n      REP(j,n){\n\tenemy[j+1] -= ALLmagic[but_best_all].damage;\n      }\n      con_mp += ALLmagic[but_best_all].mp;\n    }\n    //????????????????????°???\n    for(int j = i+1;j<=n;j++){\n      while(enemy[j] >= SINmagic[best_sin].damage){\n\tenemy[j] -= SINmagic[best_sin].damage;\n\tcon_mp += SINmagic[best_sin].mp;\t  \n      }\n      //??????????????§??????????????\\???\n      int but_best_sin = best_sin;\n      if(i<n && enemy[j]>0){\n\tfor(int k = 0;k<SINmagic.size();k++){\n\t  if(SINmagic[but_best_sin].mp>SINmagic[k].mp && SINmagic[k].damage >= enemy[i] || SINmagic[but_best_sin].mp==SINmagic[k].mp && SINmagic[k].damage >= enemy[i] && SINmagic[but_best_sin].damage > SINmagic[k].damage){\n\t    but_best_sin = k;\n\t  }\n\t}\n\tenemy[j] -= SINmagic[but_best_sin].damage;\n\tcon_mp += SINmagic[but_best_sin].mp;\n      } \n    }\n    best_mp = min(con_mp,best_mp);\n    //    cout << i << \" \" << best_mp << endl;\n  }\n  cout << best_mp << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m;\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tvector<int>hp(n);\n\t\tfor(int i=0;i<n;i++)cin>>hp[i];\n\t\tsort(hp.begin(),hp.end());\n\t\tcin>>m;\n\t\tvector<pair<int,int> >s,a;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tstring t;int mp,d;\n\t\t\tcin>>t>>mp>>t>>d;\n\t\t\tif(t==\"Single\")s.push_back({mp,d});\n\t\t\telse a.push_back({mp,d});\n\t\t}\n\t\tvector<int>S(hp.back()+1,1e9);\n\t\tS[0]=0;\n\t\tfor(pair<int,int>p:s)\n\t\t{\n\t\t\tfor(int j=1;j<p.second&&j<=hp.back();j++)S[j]=min(S[j],p.first);\n\t\t\tfor(int j=0;j+p.second<=hp.back();j++)\n\t\t\t{\n\t\t\t\tS[j+p.second]=min(S[j+p.second],S[j]+p.first);\n\t\t\t}\n\t\t}\n\t\tvector<int>A(hp.back()+1,1e9);\n\t\tA[0]=0;\n\t\tfor(pair<int,int>p:a)\n\t\t{\n\t\t\tfor(int j=1;j<p.second&&j<=hp.back();j++)A[j]=min(A[j],p.first);\n\t\t\tfor(int j=0;j+p.second<=hp.back();j++)\n\t\t\t{\n\t\t\t\tA[j+p.second]=min(A[j+p.second],A[j]+p.first);\n\t\t\t}\n\t\t}\n\t\tlong ans=1e9;\n\t\tfor(int i=0;i<=hp.back();i++)\n\t\t{\n\t\t\tlong now=A[i];\n\t\t\tfor(int j=0;j<n;j++)if(hp[j]>i)\n\t\t\t{\n\t\t\t\tnow+=S[hp[j]-i];\n\t\t\t}\n\t\t\tans=min(ans,now);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\n\n\n\nint main(){\n  int n,m,hp[101];\n  while(cin>>n,n){\n  for(int i=0;i<n;i++) cin>>hp[i];\n\n  vector <P> mg[2];\n  cin>>m;\n  for(int i=0,cost,dam;i<m;i++){\n    string name,type;\n    cin>>name>>cost>>type>>dam;\n    mg[type==\"All\"].push_back(P(dam,cost));\n  }\n  int dp[2][200010]={};\n  for(int i=0;i<2;i++) \n    for(int j=1;j<200010;j++)dp[i][j]=INF;\n \n  for(int k=0;k<2;k++)\n    for(int i=0;i<(int)mg[k].size();i++)\n      for(int j=mg[k][i].f;j<=100000+mg[k][i].f;j++)\n\tdp[k][j]=min(dp[k][j],dp[k][j-mg[k][i].f]+mg[k][i].s);\n    \n  for(int i=0;i<2;i++)\n    for(int j=200000;j>=0;j--)\n      dp[i][j]=min(dp[i][j],dp[i][j+1]);\n\n  int ans=INF;\n  for(int i=0;i<200000;i++){\n    int cost=dp[1][i];\n    for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n    ans=min(ans,cost);\n }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define N 111111\n#define INF 100000000000\nint dp[N+1],dp2[N+1],cost[N+1],cost2[N+1];\ntypedef pair<int,int> P;\nint getcost(int x){\n  if(x<=0) return 0;\n  return cost2[x];\n}\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int hp[n];\n    for(int i=0;i<n;i++) cin>>hp[i];\n    sort(hp,hp+n,greater<int>());\n    int m;cin>>m;\n    vector<P> single,all;\n    for(int i=0;i<m;i++){\n      string name,target;\n      int mp,damage;\n      cin>>name>>mp>>target>>damage;\n      if(target==\"All\") all.push_back(P(mp,damage));\n      else single.push_back(P(mp,damage));\n    }\n    for(int i=0;i<=N;i++) cost[i]=cost2[i]=dp[i]=dp2[i]=INF;\n    cost[0]=dp[0]=0;\n    for(int i=0;i<N;i++){\n      if(cost[i]==INF) continue;\n      for(int j=0;j<(int)single.size();j++){\n\tint u=single[j].first,v=single[j].second;\n\tif(i+v<N) cost[i+v]=min(cost[i+v],cost[i]+u);\n\telse cost[N]=min(cost[N],cost[i]+u);\n      }\n    }\n    for(int i=N-1;i>=0;i--) cost2[i]=min(cost2[i+1],cost[i]);\n    for(int i=0;i<N;i++){\n      if(dp[i]==INF) continue;\n      for(int j=0;j<(int)all.size();j++){\n\tint u=all[j].first,v=all[j].second;\n\tif(i+v<N) dp[i+v]=min(dp[i+v],dp[i]+u);\n\telse dp[N]=min(dp[N],dp[i]+u);\n      }\n    }\n    for(int i=N-1;i>=0;i--) dp2[i]=min(dp2[i+1],dp[i]);\n    int ans=INF;\n    for(int i=0;i<N;i++){\n      if(dp2[i]==INF) continue;\n      int tmp=0;\n      for(int j=0;j<n;j++) tmp+=getcost(hp[j]-i);\n      ans=min(ans,dp2[i]+tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\nll hp[110];\nll mp[2][100010];\nchar str1[1000];\nchar str2[1000];\npair<ll, ll> magic[2][110];\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    REP(i, n) { scanf(\"%lld\", &hp[i]); }\n    scanf(\"%d\", &m);\n    int single = 0;\n    int all = 0;\n    REP(i, m) {\n      int mpower, damage;\n      scanf(\"%s %d %s %d\", str1, &mpower, str2, &damage);\n      if (str2[0] == 'S') {\n        magic[0][single++] = make_pair(mpower, damage);\n      } else {\n        magic[1][all++] = make_pair(mpower, damage);\n      }\n    }\n    int cnt[2] = { single, all };\n    MEMSET(mp, 0x0f);\n    REP(iter, 2) {\n      mp[iter][0] = 0;\n      REP(i, 100001) {\n        REP(j, cnt[iter]) {\n          ll ndamage = i + magic[iter][j].second;\n          ll nmpower = mp[iter][i] + magic[iter][j].first;\n          ndamage = min(ndamage, 100000LL);\n          mp[iter][ndamage] = min(mp[iter][ndamage], nmpower);\n        }\n      }\n      for (int i = 100000; i > 0; i--) {\n        if (mp[iter][i] > mp[iter][i + 1]) { mp[iter][i] = mp[iter][i + 1]; }\n      }\n    }\n    ll ans = 1LL << 60;\n    REP(a, 100001) {\n      ll lsum = mp[1][a];\n      REP(e, n) {\n        if (hp[e] - a <= 0) { continue; }\n        lsum += mp[0][hp[e] - a];\n      }\n      ans = min(ans, lsum);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nint single[200010] = {};\nint multi[200010] = {};\nint hp[110];\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tfor(int i = 0 ; i < 100010 ; i++) single[i] = 1e9;\n\t\tfor(int i = 0 ; i < 100010 ; i++) multi[i] = 1e9;\n\t\tsingle[0] = multi[0] = 0;\n\t\tfor(int i = 0 ; i < N ; i++)\n\t\t\tcin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring target;\n\t\t\tint dmg;\n\t\t\tcin >> name >> mp >> target >> dmg;\n\t\t\tif( target == \"Single\" ){\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\t\tsingle[t] = min(single[j+dmg],single[j]+mp);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\t\tmulti[t] = min(multi[t],multi[j]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 100000 ; j >= 0 ; j--){\n\t\t\tsingle[j] = min(single[j+1],single[j]);\n\t\t\tmulti[j] = min(multi[j+1],multi[j]);\n\t\t}\n\t\t\t\n\t\tlong long ans = 1e9;\n\t\tfor(int i = 0 ; i <= 100000 ; i++){\n\t\t\tlong long sub = multi[i];\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint r = max(0,hp[j]-i);\n\t\t\t\tsub += single[r];\n\t\t\t}\n\t\t\tans = min(sub,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\nbool ok[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(dm == 0) continue;\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n\n    REP(i,h+1) dpS[i] =dpA[i] = INT_MAX;\n    dpA[0] = dpS[0] = 0;\n    REP(i,h+1){\n      if(dpA[i] != INT_MAX){\n        REP(j,a){\n          int dd = min(h, i + dmA[j]);\n          dpA[dd] = min(dpA[dd], dpA[i]+mpA[j]);\n        }\n      }\n\n      if(dpS[i] != INT_MAX){\n        REP(j,s){\n          int dd = min(h, i + dmS[j]);\n          dpS[dd] = min(dpS[dd], dpS[i]+mpS[j]);\n        }\n      }\n    }\n\n    /*\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    REP(i,h+1) dpS[i] = INT_MAX;\n    REP(i,h+1) dpA[i] = INT_MAX;\n\n    q.push(mpi(0,0));\n    REP(i,h+1) ok[i] = false;\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] > mm){\n          dpS[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n\n    REP(i,h+1) ok[i] = false;\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] > mm){\n          dpA[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n    */\n\n    for(int i = h-1; i >= 0; i--){\n      dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    for(int i=h; i>=0; i--){\n      if(dpA[i] == INT_MAX) continue;\n      int mp = dpA[i];\n      int dm = i;\n      if(ans <= mp) continue;\n\n      REP(j,n)\n        if(hp[j] > dm){\n          mp += dpS[hp[j] - dm];\n          if(mp >= ans) break;\n        }\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(16,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n    }\n    int as[2][100001]={};\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    int mp=1<<30;\n    for(int i=0;i<mp;i++){\n      int cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<mp<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 2000000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\t//single[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp = INF;\n  for(int i=maxhp;i>=0;i--){\n    if ( single[n][i] >=INF){res_all[i]=INF;continue;}\n    //if (tmp>single[n][i])tmp=single[n][i];\n    else res_all[i]=single[n][i];\n  } \n \n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      if(  res_single[hp[j]-i]==INF){tmp=INF;break;}\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1001001001;\n\nint all[100001], single[100001];\n\nint main()\n{\n\tint N;\n\tint H[128];\n\n\twhile (scanf(\"%d\", &N) && N){\n\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d\", H + i);\n\n\t\tfill(all, all + 100001, INF);\n\t\tfill(single, single + 100001, INF);\n\n\t\tall[0] = single[0] = 0;\n\n\t\tint M;\n\t\tscanf(\"%d\", &M);\n\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint mp, dmg;\n\t\t\tchar type[128];\n\n\t\t\tscanf(\"%*s %d %s %d\", &mp, type, &dmg);\n\n\t\t\tdmg = min(dmg, 100000);\n\n\t\t\tint *p = (type[0] == 'S' ? single : all);\n\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tp[j] = min(p[j], p[max(0, j - dmg)] + mp);\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tint tmp = all[i];\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\ttmp = min(INF, tmp + single[max(0, H[j] - i)]);\n\t\t\t}\n\t\t\tans = min(ans, tmp);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstruct edge {\n\tint from;\n\tint to;\n\tlong double time;\n};\nstruct aa {\n\tint now;\n\tlong double time;\n\tbitset<8>tickets;\n};\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint fizznum[15] = { 0,0,1,1,1,2,2,2,3,3,3,4,4,4,4 };\nint buzznum[15] = { 0,0,0,0,1,1,1,1,1,2,2,2,2,2,2 };\nint fibunum[15] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 };\nlong long int memo[18];\n\nstring makefb(long long int num) {\n\tstring st;\n\tif (!(num % 3)) {\n\t\tst+=(\"Fizz\");\n\t}\n\tif (!(num % 5)) {\n\t\tst+=(\"Buzz\");\n\t}\n\tif (st.size() == 0) {\n\t\tst = to_string(num);\n\t}\n\treturn st;\n}\n\nstring getans(long long int rest, long long int from) {\n\tstring ans;\n\tlong long int now(from);\n\twhile (1) {\n\t\tstring ast(makefb(now));\n\t\tif (rest <= ast.size()) {\n\t\t\tans+=(ast.substr(rest, int(ast.size() - rest)));\n\t\t\trest = 0;\n\t\t}\n\t\telse {\n\t\t\trest -= ast.size();\n\t\t}\n\t\tnow++;\n\t\tif (ans.size() >= 20) {\n\t\t\treturn ans.substr(0, 20);\n\t\t}\n\t}\n}\n\n\nvector<pair<int, int>>smag, amag;\nvector<int>hps;\n\nlong long int sdp[100001];\nlong long int adp[100001];\n\n\nlong long int getmp(int damage) {\n\tlong long int ans = 0;\n\tfor (auto i : hps) {\n\t\tif (i - damage <= 0) {\n\n\t\t}\n\t\telse {\n\t\t\tans += sdp[i - damage];\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\thps.clear();\n\t\tsmag.clear();\n\t\tamag.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\thps.emplace_back(a);\n\t\t}\n\t\tconst int max_hp = *max_element(hps.begin(), hps.end());\n\t\tint M; cin >> M;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tint mp; cin >> mp;\n\t\t\tcin >> st;\n\t\t\tint dam; cin >> dam;\n\t\t\tif (st == \"Single\") {\n\t\t\t\tsmag.push_back({ mp,dam });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamag.push_back({ mp,dam });\n\t\t\t}\n\t\t}\n\n\t\tmemset(sdp, 9999999,sizeof(sdp));\n\t\tmemset(adp, 9999999, sizeof(adp));\n\t\tsdp[0] = 0; adp[0] = 0;\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tfor (auto mag : smag) {\n\t\t\t\tsdp[min(100000,i + mag.second)] = min(sdp[min(100000, i + mag.second)], sdp[i] + mag.first);\n\t\t\t}\n\t\t\tfor (auto mag : amag) {\n\t\t\t\tadp[min(100000, i + mag.second)] = min(adp[min(100000, i + mag.second)], adp[i] + mag.first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\t\n\t\t\tsdp[100000-i-1] = min(sdp[100000-i], sdp[100000 - i - 1]);\n\t\t\t\n\t\t\t\n\t\t\tadp[100000-i-1] = min(adp[100000-i], adp[100000 - i - 1]);\n\t\t\t\n\t\t}\n\t\tlong long int ans = 9999999999999999;\n\t\tfor (int alldamage = 0; alldamage <= max_hp; ++alldamage) {\n\t\t\tans = min(ans, adp[alldamage] + getmp(alldamage));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nstruct Magic{ int cost,dmg; };\n\nint main(){\n\tfor(int n,m;scanf(\"%d\",&n),n;){\n\t\tint hp[100],hp_max=-1;\n\t\trep(i,n) scanf(\"%d\",hp+i), hp_max=max(hp_max,hp[i]);\n\n\t\tscanf(\"%d\",&m);\n\t\tint ms=0,ma=0; // s:single, a:all\n\t\tMagic magic_s[100],magic_a[100];\n\t\trep(i,m){\n\t\t\tint cost,dmg;\n\t\t\tchar s[7];\n\t\t\tscanf(\"%*s%d%s%d\",&cost,s,&dmg), dmg=min(dmg,hp_max);\n\t\t\tif(dmg>0){\n\t\t\t\tif(s[0]=='S') magic_s[ms++]=(Magic){cost,dmg};\n\t\t\t\telse          magic_a[ma++]=(Magic){cost,dmg};\n\t\t\t}\n\t\t}\n\n\t\tstatic int dp_a[100001];\n\t\trep(j,hp_max+1) dp_a[j]=(j==0?0:INF);\n\t\trep(i,ma){\n\t\t\tint cost=magic_a[i].cost,dmg=magic_a[i].dmg;\n\t\t\trep(j,hp_max-dmg+1) dp_a[j+dmg]=min(dp_a[j+dmg],dp_a[j]+cost);\n\t\t}\n\n\t\tstatic int dp_s[100001];\n\t\trep(j,hp_max+1) dp_s[j]=(j==0?0:INF);\n\t\trep(i,ms){\n\t\t\tint cost=magic_s[i].cost,dmg=magic_s[i].dmg;\n\t\t\trep(j,hp_max-dmg+1) dp_s[j+dmg]=min(dp_s[j+dmg],dp_s[j]+cost);\n\t\t}\n\t\tfor(int j=hp_max;j>0;j--) dp_s[j-1]=min(dp_s[j-1],dp_s[j]);\n\n\t\tint ans=INF;\n\t\trep(j,hp_max+1){\n\t\t\tint cost=dp_a[j];\n\t\t\trep(i,n) cost+=dp_s[max(hp[i]-j,0)];\n\t\t\tans=min(ans,cost);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;//(h+_all[0].second-1)/_all[0].second*_all[0].first;\n\t\t\tsingle[i]=9999999;//(h+_single[0].second-1)/_single[0].second*_single[0].first;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\t\tif(all.empty()){\n\t\t\tfor(r=j=0;j<monster.size();j++)r+=single[monster[j]];\n\t\t}else if(single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;//(h+all[h]-1)/all[h];\n\t\t\tfor(i=0;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\t//cout<<i<<' '<<s<<' '<<all[i]<<endl;\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    int h[n];\n    for(int i=0; i<n; i++) cin >> h[i];\n    cin >> m;\n    vector<P> a,b;\n    string name,t;\n    for(int i=0; i<m; i++) {\n      P c;\n      cin >> name >> c.first >> t >> c.second;\n      if(t==\"All\") a.push_back(c);\n      else b.push_back(c);\n    }\n    sort(a.begin(),a.end());\n    sort(b.begin(),b.end());\n    int da[100001],db[100001];\n    fill(da,da+100001,1<<29);\n    fill(db,db+100001,1<<29);\n    da[0]=db[0]=0;\n    for(int i=0; i<a.size(); i++) {\n      for(int j=0; j<100001; j++) {\n\tif(j+a[i].second<=100000) da[j+a[i].second]=min(da[j+a[i].second],da[j]+a[i].first);\n      }\n    }\n    for(int i=0; i<b.size(); i++) {\n      for(int j=0; j<100001; j++) {\n\tif(j+b[i].second<=100000) db[j+b[i].second]=min(db[j+b[i].second],db[j]+b[i].first);\n      }\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    for(int i=0; i<100001; i++) {\n      if(da[i]==1<<29) {\n\tfor(int j=0; j<a.size(); j++) da[i]=min(da[i],da[max(0,i-a[j].second)]+a[j].first);\n      }\n      if(db[i]==1<<29) {\n\tfor(int j=0; j<b.size(); j++) db[i]=min(db[i],db[max(0,i-b[j].second)]+b[j].first);\n      }\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    int ans=1<<29;\n    for(int i=0; i<=100000; i++) {\n      int d=da[i];\n      for(int j=0; j<n; j++) {\n\tint x=max(0,h[j]-i);\n\td+=db[x];\n      }\n      ans=min(ans,d);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n && n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 1000000 + 1;\n    const int inf = 1000000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          if(j + damage < MAX)\n            memo[j + damage] = min(memo[j + damage], memo[j] + mp);\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      for(int j = MAX - 1; j > 0; j--){\n        memo[j - 1] = min(memo[j - 1], memo[j]);\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      if(mp >= ans) goto next;\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n          if(mp >= ans) goto next;\n        }\n      }\n      ans = mp;\n    next:;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, h[100], dp[100000], dp2[100000];\nint m, w[100], v[100];\nbool single[100];\n\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> h[i];\n\tcin >> m;\n\trep(i, m){\n\t\tstring s;\n\t\tcin >> s >> w[i] >> s >> v[i];\n\t\tif(s == \"Single\") single[i] = 1;\n\t}\n\t\n\trep(i, 100000) dp[i] = dp2[i] = inf;\n\tdp[0] = dp2[0] = 0;\n\trep(i, m) if(!single[i]) rep(j, 100000){\n\t\tint nj = min(99999, j + v[i]);\n\t\tdp[nj] = min(dp[nj], dp[j] + w[i]);\n\t}\n\trep(i, m) if(single[i]) rep(j, 100000){\n\t\tint nj = min(99999, j + v[i]);\n\t\tdp2[nj] = min(dp[nj], dp2[j] + w[i]);\n\t}\n\tfor(int i = 99998; i >= 0; i--) dp2[i] = min(dp2[i], dp2[i + 1]);\n\t\n\tll ans = inf;\n\trep(i, 100000){\n\t\tll tmp = dp[i];\n\t\trep(j, n) if(h[j] > i) tmp += dp2[h[j] - i];\n\t\tans = min(ans, tmp);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 101;\nconst int MAXD = 200001;\nconst int INF = 1<<28;\nint N, A, S;\nint HP[MAXN];\nint aMP[MAXN], aDM[MAXN];\nint sMP[MAXN], sDM[MAXN];\nint aDP[MAXD], sDP[MAXD];\n\nvoid calc(int n, int w[MAXN], int cost[MAXN], int dp[MAXD]) {\n  fill(dp, dp+MAXD, INF);\n  dp[0] = 0;\n  for(int i = 0; i < n; ++i) {\n    for(int j = w[i]; j < MAXD; ++j) {\n      dp[j] = min(dp[j], dp[j-w[i]] + cost[i]);\n    }\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) cin >> HP[i];\n    int M; cin >> M;\n    A = S = 0;\n    for(int i = 0; i < M; ++i) {\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      damage = min(damage, 100000);\n      if(damage == 0) continue;\n      if(target == \"All\") {\n        aMP[A] = mp;\n        aDM[A] = damage;\n        ++A;\n      } else {\n        sMP[S] = mp;\n        sDM[S] = damage;\n        ++S;\n      }\n    }\n    calc(A, aDM, aMP, aDP);\n    calc(S, sDM, sMP, sDP);\n    for(int i = MAXD-1; i-1 >= 0; --i)\n      sDP[i-1] = min(sDP[i-1], sDP[i]);\n    int res = INF;\n    for(int i = 0; i < MAXD; ++i) {\n      int sum = aDP[i];\n      if(sum == INF) continue;\n      for(int j = 0; j < N; ++j) {\n        if(sDP[max(0, HP[j]-i)] == INF) {\n          sum = INF;\n          continue;\n        }\n        sum += sDP[max(0, HP[j]-i)];\n      }\n      res = min(res, sum);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nint dp1[2][100010], dp2[2][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >>  target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 25;\n    }\n    for(int i = 1; i <= n; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(target[i-1] == \"All\"){\n            dp1[i%2][j] = min(dp1[(i-1)%2][j], dp1[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i%2][j] = dp2[(i-1)%2][j];          \n        }\n        else{\n            dp2[i%2][j] = min(dp2[(i-1)%2][j], dp2[i%2][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i%2][j] = dp1[(i-1)%2][j];\n        }\n      }\n    }\n    \n    \n    for(int i = 5000; i <= 10000; i++){\n      //cout << i << \" \" << dp2[n][i] <<endl;\n    }\n    \n    int ans = 1 << 25;\n    for(int i = 0; i <= 100000; i++){\n      int sum = dp1[n%2][i];\n      //cout << i << \" \" << dp1[n][i];\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[n%2][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<assert.h>\nusing namespace std;\ntypedef long long LL;\nchar s[100];\nconst int N = 105;\nconst int M = 100050;\nconst int inf = (int)1e9+2;\nstruct node{\n    int a,b,c;\n    void read(){\n        scanf(\"%s%d%s%d\",s,&a,s,&b);\n        if(s[0]=='S') c=0;\n        else c=1;\n    }\n    bool operator <(const node tmp)const{\n        if(c!=tmp.c) return c<tmp.c;\n        return b*tmp.a>tmp.b*a;\n    }\n    void print(){\n        cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n    }\n}no[N];\nint val[N],n,m;\nLL opt[M],dp[M];\nint main()\n{\n    while(scanf(\"%d\",&n),n)\n    {\n        for(int i=1;i<=n;++i)\n            scanf(\"%d\",val+i);\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;++i)\n            no[i].read();\n        sort(no+1,no+1+m);\n//        for(int i=1;i<=m;++i)\n//            no[i].print();\n        int al;\n        for(al=1;al<=m;++al)\n            if(no[al].c==1) break;\n        for(int i=0;i<M;++i){\n            opt[i]=inf;opt[0]=0;\n            for(int j=1;j<al;++j){\n                int pi=i-no[j].b;\n                if(pi<0) pi=0;\n                if(opt[i]>opt[pi]+no[j].a)\n                    opt[i]=opt[pi]+no[j].a;\n            }\n        }\n        LL ans=inf;\n        for(int i=0;i<M;++i)\n        {\n            dp[i]=inf; dp[0]=0;\n            for(int j=al;j<=m;++j){\n                int pi=i-no[j].b;\n                if(pi<0) pi=0;\n                if(dp[i]>dp[pi]+no[j].a)\n                    dp[i]=dp[pi]+no[j].a;\n            }\n            LL tmp=dp[i];\n            for(int j=1;j<=n;++j){\n                int nv=val[j]-i;\n                if(nv<0) nv=0;\n                tmp+=opt[nv];\n            }\n            if(ans>tmp) ans=tmp;\n        }\n        if(ans>=inf) assert(0);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 101;\nconst int MAXD = 200001;\nconst int INF = 1<<28;\nint N, A, S;\nint HP[MAXN];\nint aMP[MAXN], aDM[MAXN];\nint sMP[MAXN], sDM[MAXN];\nint aDP[MAXD], sDP[MAXD];\n\nvoid calc(int n, int w[MAXN], int cost[MAXN], int dp[MAXD]) {\n  fill(dp, dp+MAXD, INF);\n  dp[0] = 0;\n  for(int i = 0; i < n; ++i) {\n    for(int j = w[i]; j < MAXD; ++j) {\n      dp[j] = min(dp[j], dp[j-w[i]] + cost[i]);\n    }\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) cin >> HP[i];\n    int M; cin >> M;\n    A = S = 0;\n    for(int i = 0; i < M; ++i) {\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      damage = min(damage, 100000);\n      if(damage == 0) continue;\n      if(target == \"All\") {\n        aMP[A] = mp;\n        aDM[A] = damage;\n        ++A;\n      } else {\n        sMP[S] = mp;\n        sDM[S] = damage;\n        ++S;\n      }\n    }\n    calc(A, aDM, aMP, aDP);\n    calc(S, sDM, sMP, sDP);\n    for(int i = MAXD-1; i-1 >= 0; --i) sDP[i-1] = min(sDP[i-1], sDP[i]);\n    int res = INF;\n    for(int i = 0; i < MAXD; ++i) {\n      int sum = aDP[i];\n      for(int j = 0; j < N; ++j) {\n        sum += sDP[max(0, HP[j]-i)];\n      }\n      res = min(res, sum);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\n\nconst int MAX_N=110,MAX_H=1e5+10;\n\nint N,M;\nint H[MAX_N],MP[MAX_N],T[MAX_N],D[MAX_N];\n\nvoid solve(){\n    vector<int> dp0(MAX_H,INF),dp1(MAX_H,INF);\n    dp0[0]=dp1[0]=0;\n    for (int i=0;i<MAX_H;++i){\n        for (int j=0;j<M;++j){\n            if (!T[j]){\n                int nxt=min(MAX_H-1,i+D[j]);\n                dp0[nxt]=min(dp0[nxt],dp0[i]+MP[j]);\n            } else {\n                int nxt=min(MAX_H-1,i+D[j]);\n                dp1[nxt]=min(dp1[nxt],dp1[i]+MP[j]);\n            }\n        }\n    }\n    for (int i=MAX_H-2;i>=0;--i){\n        dp0[i]=min(dp0[i],dp0[i+1]);\n        dp1[i]=min(dp1[i],dp1[i+1]);\n    }\n    int ans=INF;\n    for (int i=0;i<MAX_H;++i){\n        int sum=dp1[i];\n        for (int j=0;j<N;++j){\n            sum+=dp0[max(0,H[j]-i)];\n            if (ans<sum) break;\n        }\n        ans=min(ans,sum);\n    }\n    cout << ans << '\\n';\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N,N){\n        for (int i=0;i<N;++i) cin >> H[i];\n        cin >> M;\n        for (int i=0;i<M;++i){\n            string S,Tar; cin >> S >> MP[i] >> Tar >> D[i];\n            T[i]=(Tar==\"All\");\n        }\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 50;\nconst int inf = 1 << 30;\n\nint n,m;\nint hp[110];\n\nconst ll hpmax=100000;\n\nll single[100010];\nll all[100010];\n\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n) cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i,100010) single[i]=INF,all[i]=INF;\n\t\tsingle[0]=all[0]=0LL;\n\t\trep(i,m){\n\t\t\tstring _,type;\n\t\t\tll mp,damage;\n\t\t\tcin >> _ >> mp >> type >> damage;\n\t\t\tif(type==\"Single\"){\n\t\t\t\trep(j,hpmax+1){\n\t\t\t\t\tll ndamage=min(damage+j,hpmax);\n\t\t\t\t\tsingle[ndamage]=min(single[ndamage],single[j]+mp);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(j,hpmax+1){\n\t\t\t\t\tll ndamage=min(damage+j,hpmax);\n\t\t\t\t\tall[ndamage]=min(all[ndamage],all[j]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=hpmax;i>=0;i--){\n\t\t\tsingle[i]=min(single[i],single[i+1]);\n\t\t\tall[i]=min(all[i],all[i+1]);\n\t\t}\n\t\tll ans=INF;\n\t\trep(i,hpmax+1){\n\t\t\tll cur=all[i];\n\t\t\trep(j,n){\n\t\t\t\tint index=max(0,hp[j]-i);\n\t\t\t\tcur+=single[index];\n\t\t\t}\n\t\t\tans=min(ans,cur);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\n#define N 100005\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin>>n&&n){\n    int hp[100],m,mp[100],tg[100],dm[100];\n    string s;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>s>>mp[i]>>s>>dm[i];\n      tg[i]=s[0]=='A';\n    }\n\n    int dp[2][N];\n\n    for(int i=0;i<N;i++)dp[0][i]=dp[1][i]=inf;\n    dp[0][0]=dp[1][0]=0;\n    for(int i=0;i<m;i++){\n      for(int j=0;j<N;j++){\n\tdp[tg[i]][min(N-1,j+dm[i])]=min(\n        dp[tg[i]][min(N-1,j+dm[i])],dp[tg[i]][j]+mp[i]);\n      }\n    }\n\n    for(int i=N-1;i>0;i--){\n      dp[0][i-1]=min(dp[0][i-1],dp[0][i]);\n      dp[1][i-1]=min(dp[1][i-1],dp[1][i]);\n    }\n\n    int mn=inf;\n    for(int i=0;i<=100000;i++){\n      bool f=false;\n      int s=dp[1][i];\n      for(int j=0;j<n;j++)\n\ts+=dp[0][max(0,hp[j]-i)],f|=s>=inf;\n      if(!f)mn=min(mn,s);\n    }\n    cout<<mn<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"input.txt\");\n#define cin ifs\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tbool no=false;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0){\n\t\t\t\t\tif(dp2[0][a]==INF){\n\t\t\t\t\t\tno=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcnt+=dp2[0][a];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(no)continue;\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 50000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  } \n\n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tif(i==0&&j==52261){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tif(singleMagics.size()>0){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint a=hps[j]-i;\n\t\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t\t}\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\n#define N 100000\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long ll;\n\nint main(){\n  int n,m,hp[101];\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>hp[i];\n\n    vector <P> mg[2];  \n    cin>>m;\n    for(int i=0,cost,dam;i<m;i++){\n      string name,type;\n      cin>>name>>cost>>type>>dam;\n      if(dam)mg[type==\"All\"].push_back(P(dam,cost));\n    }\n\n    int dp[2][N+10]={};\n    for(int i=0;i<2;i++)for(int j=1;j<N+10;j++)dp[i][j]=INF;\n \n    for(int k=0;k<2;k++)\n      for(int i=0;i<mg[k].size();i++)\n\tfor(int j=mg[k][i].f;j<=(N/mg[k][i].f+1)*mg[k][i].f;j++)\n\t  dp[k][min(N,j)]=min(dp[k][min(N,j)],dp[k][j-mg[k][i].f]+mg[k][i].s);\n\n    for(int j=N;j>=0;j--)dp[0][j]=min(dp[0][j],dp[0][j+1]);\n\n    ll ans=INF;      \n    for(int i=0;i<=N;i++){\n      ll cost=dp[1][i];\n      for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n      ans=min(ans,cost);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> ene_hp(n);\n\t\tREP(i, n)\n\t\t\tcin >> ene_hp[i];\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<pii, bool>> spell(m);\n\t\tREP(i, m) {\n\t\t\tstring s;\n\t\t\tcin >> s >> spell[i].first.first >> s >> spell[i].first.second;\n\t\t\tspell[i].second = (s == \"All\");\n\t\t}\n\t\tREP(i, m) {\n\t\t\tif (spell[i].first.second == 0) {\n\t\t\t\tspell.erase(spell.begin() + i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tint ans;\n\t\tpriority_queue<pair<int, vi>> Q;\n\t\tQ.push({ 0,ene_hp });\n\t\tmap<vi, int> G;\n\t\tG[ene_hp] = 0;\n\t\twhile (1) {\n\t\t\tif (Q.top().second.empty()) {\n\t\t\t\tans = -Q.top().first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpair<int, vi> q = Q.top();\n\t\t\tQ.pop();\n\t\t\tq.first *= -1;\n\t\t\tREP(i, m) {\n\t\t\t\tif (spell[i].second) {\n\t\t\t\t\tpair<int, vi> q2 = q;\n\t\t\t\t\tREP(j, q2.second.size()) {\n\t\t\t\t\t\tq2.second[j] = q2.second[j] - spell[i].first.second;\n\t\t\t\t\t\tif (q2.second[j] <= 0) {\n\t\t\t\t\t\t\tq2.second.erase(q2.second.begin() + j);\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (G.find(q2.second) == G.end()) {\n\t\t\t\t\t\tG[q2.second] = q2.first + spell[i].first.first;\n\t\t\t\t\t\tQ.push({ -q2.first - spell[i].first.first,q2.second });\n\t\t\t\t\t}\n\t\t\t\t\telse if (G[q.second] > q2.first + spell[i].first.first) {\n\t\t\t\t\t\tG[q2.second] = q2.first + spell[i].first.first;\n\t\t\t\t\t\tQ.push({ -q2.first - spell[i].first.first,q2.second });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tREP(j, q.second.size()) {\n\t\t\t\t\t\tpair<int, vi> q2 = q;\n\t\t\t\t\t\tq2.second[j] = q2.second[j] - spell[i].first.second;\n\t\t\t\t\t\tif (q2.second[j] <= 0) {\n\t\t\t\t\t\t\tq2.second.erase(q2.second.begin() + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (G.find(q2.second) == G.end()) {\n\t\t\t\t\t\t\tG[q2.second] = q2.first + spell[i].first.first;\n\t\t\t\t\t\t\tQ.push({ -q2.first - spell[i].first.first,q2.second });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (G[q.second] > q2.first + spell[i].first.first) {\n\t\t\t\t\t\t\tG[q2.second] = q2.first + spell[i].first.first;\n\t\t\t\t\t\t\tQ.push({ -q2.first - spell[i].first.first,q2.second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int64_t INF = 1e+8;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<int> hp(n);\n    REP(i,n)cin>>hp[i];\n    int m;\n    cin>>m;\n    vector<tuple<int,int>> sg;\n    vector<tuple<int,int>> al;\n    REP(i,m){\n      string name,tg;\n      int mp,dm;\n      cin>>name>>mp>>tg>>dm;\n      if(tg==\"Single\")\n        sg.emplace_back(mp,dm);\n      else\n        al.emplace_back(mp,dm);\n    }\n    int a=sg.size();\n    int b=al.size();\n    vector<vector<int>> dps(a+1, vector<int>(100001, INF));\n    vector<vector<int>> dpa(b+1, vector<int>(100001, INF));\n    dps[0][0] = 0;\n    dpa[0][0] = 0;\n    REP(i,a) {\n      REP(j,100001) {\n        dps[i+1][j] = dps[i][j];\n        if (j >= get<1>(sg[i]))\n          dps[i+1][j] = min(dps[i+1][j], dps[i+1][j-get<1>(sg[i])] + get<0>(sg[i]));\n        else\n          dps[i+1][j] = min(dps[i+1][j], get<0>(sg[i]));\n      }\n    }\n    REP(i,b) {\n      REP(j,100001) {\n        dpa[i+1][j] = dpa[i][j];\n        if (j >= get<1>(al[i]))\n          dpa[i+1][j] = min(dpa[i+1][j], dpa[i+1][j-get<1>(al[i])] + get<0>(al[i]));\n        else\n          dpa[i+1][j] = min(dpa[i+1][j], get<0>(al[i]));\n      }\n    }\n    vector<int64_t> costs(100001);\n    REP(i,n){\n      REP(j,hp[i]) {\n        costs[j] += dps[a][hp[i] - j];\n      }\n    }\n    int64_t mcos = INF;\n    REP(i,100001) mcos = min(mcos, dpa[b][i] + costs[i]);\n    cout << mcos << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#define INF 100000\nusing namespace std;\n\nstruct spell{\n    string name;\n    long long int mp;\n    string target;\n    long long int damage;\n};\nlong long int max(long long int n,long long int m){\n    if (n<m) {\n        return m;\n    }else{\n        return n;\n    }\n}\n\nlong long int min(long long int n, long long int m){\n    if (n<m) {\n        return n;\n    }else{\n        return m;\n    }\n}\n\nint main() {\n    for (; ;) {\n        long long int n;\n        cin >> n;\n        if (n==0) break;\n        vector<long long int> hp(n);\n        long long int max_hp=0;\n        for (int i=0; i<n; i++) {\n            cin >> hp[i];\n            max_hp = max(max_hp,hp[i]);\n        }\n        int m;\n        cin >> m;\n        vector<spell> sp(m);\n        for (int i=0; i<m; i++) {\n            cin >> sp[i].name>> sp[i].mp>> sp[i].target >> sp[i].damage;\n        }\n        long long int smp=1000,amp=1000,sdm=10,adm=10;\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"Single\") {\n                if (smp>sp[i].mp) {\n                smp=sp[i].mp;\n                sdm=sp[i].damage;\n                }\n            }\n        }\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"All\") {\n                if (amp>sp[i].mp) {\n                    amp=sp[i].mp;\n                    adm=sp[i].damage;\n                }\n            }\n        }\n        vector<long long int> single(max_hp+1,INF);\n        if (smp!=100) {\n            single[0]=0;\n            for (int i=1; i<=sdm; i++) {\n                single[i]=smp;\n                //if(i/100==0) cout << single[i]<<endl;\n            }\n            for (long long int i=smp+1; i<=max_hp; i++) {\n                long long int res = 11451419;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target==\"Single\" && single[max(0,i-sp[k].damage)]+sp[k].mp<=res) res = single[max(0,i-sp[k].damage)]+sp[k].mp;\n                }\n                if(res!=11451419) single[i]=res;\n            }\n        }\n        \n        vector<long long int> all(max_hp+1,INF);\n        if (amp!=100) {\n            all[0]=0;\n            for (int i=1; i<=adm; i++) {\n                all[i]=amp;\n            }\n            for (long long int i=adm+1; i<=max_hp; i++) {\n                long long int res = 11451419;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target== \"All\"  && all[max(0,i-sp[k].damage)]+sp[k].mp<=res){\n                        res = all[max(0,i-sp[k].damage)]+sp[k].mp;\n                    }\n                }\n                if(res!=11451419) all[i]=res;\n            }\n        }\n        long long int ans=1000000;\n        for (int i=0; i<=max_hp; i++) {\n            vector<long long int> hpp(hp);\n            int hoge=0;\n            for (int j=0; j<n; j++) {\n                hpp[j]=max(0,hpp[j]-i);\n                hoge += single[hpp[j]];\n            }\n            ans = min(ans,all[i]+hoge);\n        }\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    int h[n];\n    for(int i=0; i<n; i++) cin >> h[i];\n    cin >> m;\n    vector<P> a,b;\n    string name,t;\n    for(int i=0; i<m; i++) {\n      P c;\n      cin >> name >> c.first >> t >> c.second;\n      if(t==\"All\") a.push_back(c);\n      else b.push_back(c);\n    }\n    sort(a.begin(),a.end());\n    sort(b.begin(),b.end());\n    int da[100001],db[100001];\n    fill(da,da+100001,1<<29);\n    fill(db,db+100001,1<<29);\n    da[0]=db[0]=0;\n    for(int i=0; i<a.size(); i++) {\n      for(int j=0; j<100001; j++) {\n\tif(j+a[i].second<=100000) da[j+a[i].second]=min(da[j+a[i].second],da[j]+a[i].first);\n      }\n    }\n    for(int i=0; i<b.size(); i++) {\n      for(int j=0; j<100001; j++) {\n\tif(j+b[i].second<=100000) db[j+b[i].second]=min(db[j+b[i].second],db[j]+b[i].first);\n      }\n    }\n    for(int i=0; i<100001; i++) {\n      if(da[i]==1<<29) {\n\tfor(int j=0; j<a.size(); j++) da[i]=min(da[i],da[max(0,i-a[j].second)]+a[j].first);\n      }\n      if(db[i]==1<<29) {\n\tfor(int j=0; j<b.size(); j++) db[i]=min(db[i],db[max(0,i-b[j].second)]+b[j].first);\n      }\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    int ans=1<<29;\n    for(int i=0; i<=100000; i++) {\n      int d=da[i];\n      for(int j=0; j<n; j++) {\n\tint x=max(0,h[j]-i);\n\td+=db[x];\n      }\n      ans=min(ans,d);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+1000;\n\nint dp_s[100100], dp_a[100100];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N,N){\n\tVI HP(N); REP(i,N) cin >> HP[i];\n\tcin >> M;\n\n\tfill(dp_s, dp_s+100100, INF);\n\tfill(dp_a, dp_a+100100, INF);\n\tdp_s[0] = dp_a[0] = 0;\n\tREP(i,M){\n\t  int mp, dam;\n\t  string s1, s2;\n\t  cin >> s1 >> mp >> s2 >> dam;\n\t  if(s2 == \"Single\"){\n\t\tFOR(hp,1,100001)\n\t\t  dp_s[hp] = min(dp_s[hp], dp_s[max(0,hp-dam)]+mp);\n\t  }\n\t  else\n\t\tFOR(hp,1,100001)\n\t\t  dp_a[hp] = min(dp_a[hp], dp_a[max(0,hp-dam)]+mp);\n\t}\n\n\tLL ans = INF;\n\tREP(a,100001){\n\t  LL sum = dp_a[a];\n\t  REP(i,N) sum += dp_s[max(0,HP[i]-a)];\n\t  ans = min(ans, sum);\n\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 100009\nusing namespace std;\n\nint dp1[10009];\nint dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)&&n!=0)\n    {\n        int ma=-1;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        long long ans=(long long)1<<62,sum;\n        for(int i=0; i<ans; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INF 99999999\n\nint main()\n{\n\tint N,M,HP[100];\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> HP[i];\n\t\t\t\n\t\tcin >> M;\n\t\tint ss[100], as[100],sd[100],ad[100],sn=0,an=0;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tstring n,t;\n\t\t\tint m,d;\n\t\t\tcin >> n >> m >> t >> d;\n\t\t\tif(d==0) continue;\n\t\t\t\n\t\t\tif(t==\"All\")\n\t\t\t{\n\t\t\t\tas[an]=m;\n\t\t\t\tad[an]=d;\n\t\t\t\tan++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss[sn]=m;\n\t\t\t\tsd[sn]=d;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shp[100001], ahp[100001];\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tshp[i]=INF;\n\t\t\tahp[i]=INF;\n\t\t}\n\t\tshp[0]=0; ahp[0]=0;\n\t\tfor(int i=0; i<sn; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+sd[i]>100000) break;\n\t\t\tshp[j+sd[i]]=min(shp[j+sd[i]], shp[j]+ss[i]);\n\t\t}\n\t\t\n\t\tfor(int i=100000-1; i>=0; i--)\n\t\t\tshp[i]=min(shp[i+1], shp[i]);\n\t\t\n\t\tfor(int i=0; i<an; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(j+ad[i]>100000) break;\n\t\t\tahp[j+ad[i]]=min(ahp[j+ad[i]], ahp[j]+as[i]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tif(ahp[i]==INF) continue;\n\t\t\tint tmp=ahp[i];\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(i>=HP[j]) continue;\n\t\t\t\ttmp+=shp[HP[j]-i];\n\t\t\t}\n\t\t\t\n\t\t\tans=min(ans, tmp);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n, n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 100000 + 1;\n    const int inf = 1000000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          if(j + damage < MAX)\n            memo[j + damage] = min(memo[j + damage], memo[j] + mp);\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      for(int j = MAX - 1; j > 0; j--){\n        memo[j - 1] = min(memo[j - 1], memo[j]);\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      if(mp >= ans) goto next;\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n          if(mp >= ans) goto next;\n        }\n      }\n      ans = mp;\n    next:;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tmap<int,int>all_iter;\n\t\tall_iter[0]=0;\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t\tall_iter[all[i]]=i;\n\t\t}\n\n\t\tr=9999999;\n\t\tfor(map<int,int>::iterator it=all_iter.begin();it!=all_iter.end();it++){\n\t\t\th=it->first;\n\t\t\tfor(j=0;j<monster.size();j++)h+=single[max(0,monster[j]-it->second)];\n\t\t\tif(r>h)r=h;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1500000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\telse res=min(res,allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 100002\n#define inf 1<<29\nusing namespace std;\n\nint main()\n{\n  int n,m,hp[101],p,d;\n  string name,s;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    vector<pair<int,int> > all,single; \n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>name>>p>>s>>d;\n      if(s==\"Single\")single.push_back(mp(p,d));\n      else all.push_back(mp(p,d));\n    }\n    \n    int All[MAX],Single[MAX];\n    for(int i=0;i<MAX;i++){\n      All[i]=inf;\n      Single[i]=inf;\n    }\n    All[0]=0;\n    Single[0]=0;\n\n    for(int i=0;i<all.size();i++){\n      for(int j=0;j<MAX;j++){\n\tAll[min(j+all[i].s,MAX-1)]=min(All[min(j+all[i].s,MAX-1)],\n\t\t\t\t       All[j]+all[i].f);\n      }\n    }\n   \n    for(int i=0;i<single.size();i++){\n      for(int j=0;j<MAX;j++){\n\tSingle[min(j+single[i].s,MAX-1)]=min(Single[min(j+single[i].s,MAX-1)],\n\t\t\t\t\t     Single[j]+single[i].f);\n      }\n    }\n\n    int mina=inf,minb=inf;\n    for(int i=MAX-1;i>0;i--){\n      All[i]=min(mina,All[i]);\n      mina=min(All[i],mina);\n      Single[i]=min(minb,Single[i]);\n      minb=min(minb,Single[i]);\n    }\n\n    int ans=inf;\n    for(int i=0;i<MAX;i++){\n      if(All[i]==inf)continue;\n      int sum=All[i];\n      for(int j=0;j<n;j++){\n\tsum+=Single[max(hp[j]-i,0)];\n      }\n      ans=min(ans,sum);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nconst int MAX_D = 1000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tif(res[i] == INF) continue;\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tif(si[i - 1] == INF) si[i - 1] = si[i];\n\t\t}\n\n\t\tlong long ans = INF;\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;//first : MP, second : Damage\nvoid set_cost(vector<int>& cost, const vector<pint>& attack){\n    cost[0] = 0;\n    REP(i, 1, cost.size()){\n        for(pint k : attack){\n            int temp = k.first;\n            if(i - k.second >= 0) temp += cost[i - k.second];\n            cost[i] = min(cost[i], temp);\n        }\n    }\n    return;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        int HP_MAX = -INF;\n        vector<int> HP(N);\n        rep(i, N){\n            cin >> HP[i];\n            HP_MAX = max(HP_MAX, HP[i]);\n        }\n        int M; cin >> M;\n        vector<pint> single, all;\n        rep(i, M){\n            string a, b;\n            int c, d;\n            cin >> a >> c >> b >> d;\n            if(b == \"All\")\n              all.push_back(pint(c, d));\n            else\n              single.push_back(pint(c, d));\n        }\n        vector<int> scost(HP_MAX + 1, INF), acost(HP_MAX + 1, INF);\n        set_cost(scost, single);\n        set_cost(acost, all);\n        ll ans = INF;\n        rep(d, HP_MAX + 1){\n            int sum = acost[d];\n            for(int k : HP){\n                int need = max(0, k - d);\n                sum += scost[need];\n            }\n            ans = min(sum, ans);\n        }\n        /*\n        while(true){\n            int hit = INF, enemies = 0;\n            for(int k : HP)\n              if(k > 0) {\n                  enemies++;\n                  hit = min(k, hit);\n              }\n            if(enemies == 0) break;\n            int cost, damage;\n            if(acost[hit] > scost[hit] * enemies){\n                cost = scost[hit];\n                REP(i, hit, HP_MAX + 1) if(scost[i] != cost){ damage = i - 1; break;}\n                cost *= enemies;\n            }else{\n                cost = acost[hit];\n                REP(i, hit, HP_MAX + 1) if(acost[i] != cost){ damage = i - 1; break;}\n            }\n            for(int& k : HP) k -= damage;\n            ans += cost;\n        }*/\n        \n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n, n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 100000 + 1;\n    const int inf = 100000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          if(j + damage < MAX)\n            memo[j + damage] = min(memo[j + damage], memo[j] + mp);\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      for(int j = MAX - 1; j > 0; j--){\n        memo[j - 1] = min(memo[j - 1], memo[j]);\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      if(mp >= ans) goto next;\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n          if(mp >= ans) goto next;\n        }\n      }\n      ans = mp;\n    next:;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\n#define INF 1000000000\n\nstruct spell{\n  LL mp;\n  LL damage;\n};\n\nstruct spell sps[100],spa[100];\nLL dps[100001],dpa[100001];\n\nint main(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) return 0;\n    vector<LL> hp(n);\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n    }\n    int m;\n    cin >> m;\n    int counts=0,counta=0;\n    string name,target;\n    LL mp,damage;\n    for(int i=0;i<m;i++){\n      cin >> name >> mp >> target >> damage;\n      if(target==\"Single\"){\n        sps[counts]={mp,damage};\n        counts++;\n      }else{\n        spa[counta]={mp,damage};\n        counta++;\n      }\n    }\n    for(int i=0;i<100001;i++){\n      dpa[i]=dps[i]=INF;\n    }\n    dpa[0]=dps[0]=0;\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counts;j++){\n        if(i-sps[j].damage<0){\n          dps[i]=min(dps[i],sps[j].mp);\n        }else{\n          dps[i]=min(dps[i],dps[i-sps[j].damage]+sps[j].mp);\n        }\n      }\n    }\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counta;j++){\n        if(i-spa[j].damage<0){\n          dpa[i]=min(dpa[i],spa[j].mp);\n        }else{\n          dpa[i]=min(dpa[i],dpa[i-spa[j].damage]+spa[j].mp);\n        }\n      }\n    }\n    LL ans=INF;\n    LL count;\n    for(int i=0;i<100001;i++){\n      count=dpa[i];\n      for(int j=0;j<n;j++){\n        count+=(hp[j]-i>=0?dps[hp[j]-i]:0);\n      }\n      ans=min(ans,count);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<LL> maketbl(const vector<int> &mp, const vector<int> &dmg, int mh){\n\tvector<LL> ret(mh + 1, 1LL << 50);\n\tret[0] = 0;\n\tfor(int i = 1; i <= mh; ++i){\n\t\tfor(size_t j = 0; j < mp.size(); ++j){\n\t\t\tret[i] = min(ret[i], ret[max(i - dmg[j], 0)] + mp[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> hp(n);\n\t\tint mh = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t\tmh = max(mh, hp[i]);\n\t\t}\n\t\tvector<int> mps, dmgs, mpa, dmga;\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint d, p;\n\t\t\tchar c;\n\t\t\tscanf(\"%*s%d %c%*s%d\", &p, &c, &d);\n\t\t\tif(d){\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\tmps.push_back(p);\n\t\t\t\t\tdmgs.push_back(d);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmpa.push_back(p);\n\t\t\t\t\tdmga.push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<LL> tbls = maketbl(mps, dmgs, mh);\n\t\tvector<LL> tbla = maketbl(mpa, dmga, mh);\n\t\tLL ans = 1LL << 50;\n\t\tfor(int i = 0; i <= mh; ++i){\n\t\t\tLL s = tbla[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\ts += tbls[max(hp[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, s);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint HP[100], M;\nlong long dp1[100001], dp2[100001];\n\nint solve(int N)\n{\n  memset(dp1, 0, sizeof(dp1));\n  memset(dp2, 0, sizeof(dp2));\n    \n  for(int i = 0; i < N; i++) {\n    cin >> HP[i];\n  }\n  cin >> M;\n  \n  while(M--) {\n    string Name, Target;\n    int MP, Damage;\n    cin >> Name >> MP >> Target >> Damage;\n    if(MP == 0) {\n      if(Damage > 0) return(0);\n      else continue;\n    }\n    for(int i = MP; i <= 100000; i++) {\n      dp2[i] = max(dp2[i], dp2[i - MP] + Damage);\n    }\n    if(Target.size() == 6) MP *= N;\n    for(int i = MP; i <= 100000; i++) {\n      dp1[i] = max(dp1[i], dp1[i - MP] + Damage);\n    }\n  }\n  \n  int best = 1 << 30;\n  for(int i = 0; i <= 100000; i++) {\n    int ret = 0;\n    for(int j = 0; j < N; j++) {\n      ret += lower_bound(dp2, dp2 + 100001, HP[j] - dp1[i]) - dp2;\n    }\n    best = min(best, i + ret);\n  }\n  return(best);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint h[100];\nvector<pair<int, int>> s, a;\nlong long dp[100010];\nlong long dp2[100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring na, ta;\n\t\t\tint mp, da;\n\t\t\tcin >> na >> mp >> ta >> da;\n\t\t\t(ta == \"Single\" ? s : a).emplace_back(mp, da);\n\t\t}\n\n\t\tfill_n(dp, 100010, 1ll << 60);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < s.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tlong long t = j < s[i].second ? 0 : dp[j - s[i].second];\n\t\t\t\tdp[j] = min<long long>(dp[j], t + s[i].first);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp2, 100010, 1ll << 60);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < a.size(); i++){\n\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\tlong long t = j < a[i].second ? 0 : dp2[j - a[i].second];\n\t\t\t\tdp2[j] = min<long long>(dp2[j], t + a[i].first);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long res = 1ll << 60;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long sum = dp2[i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i <= h[j]) sum += dp[h[j] - i];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nconst int MAX_D = 1000000;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tif(res[i] == INF) continue;\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tif(si[i - 1] == INF) si[i - 1] = si[i];\n\t\t}\n\n\t\tlong long ans = INF;\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdint.h>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000005\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nuint64_t dp[2][MAX_Damage];\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(damage == 0)continue;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)rep(j,MP[i].size())rep(k,MAX_Damage)\n\t{\n\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t      dp[i][k] + MP[i][j]);\n\t}\n      \n      rep(i,2)for(int j=MAX_Damage-2;j>=0;j--)dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\n      uint64_t ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  if(dp[1][i] == inf)continue;\n\t  uint64_t cnt = dp[1][i];\n\t  bool ok = true;\n\t  rep(j,N)//Single\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      if(dp[0][HP[j]-i] == inf)\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  if(!ok)continue;\n\t  ans = min(ans,cnt);\n\t}\n\n      int mex = -inf;\n      uint64_t cnt = 0;\n      rep(i,N)//Single\n\t{\n\t  mex = max(mex,HP[i]);\n\t  cnt += dp[0][HP[i]];\n\t}\n      ans = min(ans,cnt);\n      ans = min(ans,dp[1][mex]);//All\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\n#define INF 1000000000\n\nstruct spell{\n  int mp;\n  int damage;\n};\n\nstruct spell sps[100],spa[100];\nLL dps[100001],dpa[100001];\n\nint main(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) return 0;\n    vector<int> hp(n);\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n    }\n    int m;\n    cin >> m;\n    int counts=0,counta=0;\n    string name,target;\n    int mp,damage;\n    for(int i=0;i<n;i++){\n      cin >> name >> mp >> target >> damage;\n      if(target==\"Single\"){\n        sps[counts]={mp,damage};\n        counts++;\n      }else{\n        spa[counta]={mp,damage};\n        counta++;\n      }\n    }\n    for(int i=0;i<100001;i++){\n      dpa[i]=dps[i]=INF;\n    }\n    dpa[0]=dps[0]=0;\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counts;j++){\n        if(i-sps[j].damage<0){\n          dps[i]=min(dps[i],sps[j].mp);\n        }else{\n          dps[i]=min(dps[i],dps[i-sps[j].damage]+sps[j].mp);\n        }\n      }\n    }\n    for(int i=1;i<100001;i++){\n      for(int j=0;j<counta;j++){\n        if(i-spa[j].damage<0){\n          dpa[i]=min(dpa[i],spa[j].mp);\n        }else{\n          dpa[i]=min(dpa[i],dpa[i-spa[j].damage]+spa[j].mp);\n        }\n      }\n    }\n    LL ans=INF;\n    int count;\n    for(int i=0;i<100001;i++){\n      count=dpa[i];\n      for(int j=0;j<n;j++){\n        count+=(hp[j]-i>=0?dps[hp[j]-i]:0);\n      }\n      ans=min(ans,count);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n&&n){\n    int hp[100],m,mp[100],tg[100]={},dm[100];\n    string s;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>s>>mp[i]>>s>>dm[i];\n      if(s[0]=='A')tg[i]=1;\n    }\n    int dp[2][200001];\n    for(int i=0;i<200001;i++)dp[0][i]=dp[1][i]=inf;\n    dp[0][0]=dp[1][0]=0;\n    for(int i=0;i<m;i++)\n      for(int j=0;j<200001-dm[i];j++)\n\tdp[tg[i]][j+dm[i]]=min(dp[tg[i]][j+dm[i]],dp[tg[i]][j]+mp[i]);\n    for(int i=200000;i>0;i--){\n      dp[0][i-1]=min(dp[0][i-1],dp[0][i]);\n      dp[1][i-1]=min(dp[1][i-1],dp[1][i]);\n    }\n    int mn=inf;\n    for(int i=0;i<100000;i++){\n      int s=dp[1][i];\n      for(int j=0;j<n;j++)\n\ts+=dp[0][max(0,hp[j]-i)];\n      mn=min(mn,s);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[100],b[100],d[100];vector<int>v1,v2,w1,w2,dp1,dp2;\nvector<int>knapsack(int W,vector<int>v,vector<int>w){\n\tvector<int>dp(W+1,999999999);dp[0]=0;\n\tfor(int i=0;i<(int)v.size();i++){\n\t\tfor(int j=v[i];j<=W;j++)dp[j]=min(dp[j],dp[j-v[i]]+w[i]);\n\t}\n\tfor(int i=W-1;i>=0;i--)dp[i]=min(dp[i],dp[i+1]);\n\treturn dp;\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];cin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring S,T;cin>>S>>b[i]>>T>>d[i];if(d[i]>=200000)d[i]=200000;\n\t\t\tif(T==\"Single\"){v1.push_back(d[i]);w1.push_back(b[i]);}\n\t\t\tif(T==\"All\"){v2.push_back(d[i]);w2.push_back(b[i]);}\n\t\t}\n\t\tdp1=knapsack(300000,v1,w1);\n\t\tdp2=knapsack(300000,v2,w2);\n\t\tint maxn=999999999;\n\t\tfor(int i=0;i<=300000;i++){\n\t\t\tint sum=dp2[i];\n\t\t\tfor(int j=0;j<n;j++)sum+=dp1[max(0,a[j]-i)];\n\t\t\tmaxn=min(maxn,sum);\n\t\t}\n\t\tcout<<maxn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<28\n#define MAX_HP 100001\n\nusing namespace std;\n\nstruct monster{\n\tint hp;\n};\n\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\n\nvoid min_mp(int *min, int max_hp, const vector<magic> &vmag){\n\tint m = vmag.size();\n\n\tif( m == 0 )\n\t\treturn ;\n\n\tint **dp = new int*[m];\n\tfor(int i = 0; i < m; ++i){\n\t\tdp[i] = new int[max_hp];\n\t}\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tdp[i][j] = INFTY;\n\t\t}\n\t}\n\t\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < m; ++i){\n\t\tint mp = vmag[i].mp;\n\t\tint damage = vmag[i].damage;\n\t\tfor(int j = 0; j < max_hp; ++j){\n\t\t\tif( dp[i][j] < INFTY ){\n\t\t\t\tif( i + 1 < m )\n\t\t\t\t\tdp[i+1][j] = std::min( dp[i][j], dp[i+1][j] );\n\t\t\t\tint &a = dp[i][std::min(j+damage,max_hp-1)];\n\t\t\t\ta = std::min( a, dp[i][j] + mp );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = max_hp-1; i >= 0; --i){\n\t\tmin[i] = dp[m-1][i] == INFTY ? min[i+1] : dp[m-1][i];\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tdelete [] dp[i];\n\t}\n\tdelete [] dp;\n}\nint MagicSlayer(const vector<monster> &vmon, const vector<magic> &vmag){\n\tint ret = INFTY;\n\tvector<magic> vmag_single;\n\tvector<magic> vmag_all;\n\tint max_hp = 0;\n\tint min_mp_single[MAX_HP]={0,};\n\tint min_mp_all[MAX_HP]={0,};\n\n\tfor(unsigned int i = 0; i < vmon.size(); ++i){\n\t\tmax_hp = max( max_hp, vmon[i].hp );\n\t}\n\t++max_hp;\n\n\tfor(unsigned int i = 0; i < vmag.size(); ++i){\n\t\tif( vmag[i].type == ALL )\n\t\t\tvmag_all.push_back( vmag[i] );\n\t\telse\n\t\t\tvmag_single.push_back( vmag[i] );\n\t}\n\n\tmin_mp( min_mp_single, max_hp, vmag_single );\n\tmin_mp( min_mp_all, max_hp, vmag_all );\n\n\tfor(int i = 0; i < max_hp; ++i){\n\t\tint t = min_mp_all[i];\n\n\t\tif( min_mp_all[i] >= INFTY )\n\t\t\tcontinue;\n\n\t\tfor(unsigned int j = 0; j < vmon.size(); ++j){\n\t\t\tif( vmon[j].hp - i > 0 ){\n\t\t\t\tt += min_mp_single[ vmon[j].hp - i ];\n\t\t\t}\n\t\t}\n\n\t\tret = min( ret, t );\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tvector<monster> vmonster;\n\t\tvector<magic> vmagic;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmonster t;\n\t\t\t\n\t\t\tscanf(\"%d\", &t.hp);\n\t\t\tvmonster.push_back( t );\n\t\t}\n\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar stype[17]=\"\";\n\t\t\tmagic mag;\n\n\t\t\tscanf(\"%*s%d%s%d\", &mag.mp, stype, &mag.damage);\n\t\t\tif(strcmp(stype,\"All\")==0)mag.type=ALL;\n\t\t\telse mag.type=SINGLE;\n\t\t\tvmagic.push_back( mag );\n\t\t}\n\n\t\tprintf(\"%d\\n\", MagicSlayer( vmonster, vmagic ) );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"input.txt\");\n#define cin ifs\ntypedef long long ll;\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst ll INF=100000000000000LL;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nll dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nll dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tll minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp*1LL);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tll res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tll res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp*1LL);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tll cnt=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint a=hps[j]-i;\n\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 100009\nusing namespace std;\n\nint dp1[10009];\nint dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)&&n!=0)\n    {\n        int ma=-1;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        int ans=1<<28,sum;\n        for(int i=0; i<n; i++)\n        {\n            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            int tmp=sum;\n//        printf(\"%d\\n\",tmp);\n            for(int j=i+1; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[tmp])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "3\n8000 15000 30000\n3\nFlare 45 Single 8000\nMeteor 62 All 6000\nUltimate 80 All 9999\n0"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\n\nconst int N = 1e5+10;\n\nll dp_s[N], dp_a[N];\n\nint mons[110];\n\nconst ll INF = 1e15;\n\nint main(){\n\tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile (cin >> n, n){\n\t\trep(i, n) cin >> mons[i];\n\n\t\tint m;\n\t\tcin >> m;\n\t\tFOR(i, 1, N) dp_s[i] = dp_a[i] = INF;\n\t\tdp_s[0] = dp_a[0] = 0;\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tint w, v;\n\t\t\tcin >> s >> w >> s >> v;\n\t\t\tll *dp;\n\t\t\tif (s[0] == 'S') dp = dp_s;\n\t\t\telse dp = dp_a;\n\n\t\t\trep(j, N) dp[min(j + v, 100000)] = min(dp[min(j + v, 100000)], dp[j] + w);\n\t\t}\n\n\t\tfor (int i = N - 2; i >= 0; --i){\n\t\t\tdp_s[i] = min(dp_s[i], dp_s[i + 1]);\n\t\t\tdp_a[i] = min(dp_a[i], dp_a[i + 1]);\n\t\t}\n\n\t\tll ans = INF;\n\t\trep(i, N){\n\t\t\tll tmp = dp_a[i];\n\t\t\tif (tmp == INF) continue;\n\n\t\t\trep(j, n) tmp += dp_s[max(mons[j] - i, 0)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nvector<P>v1,v2;\nint a[101],dp1[100001],dp2[100001],n,t1,t2,t;\nstring s;\nmain(){\n\twhile(cin>>n,n){\n\t\tint ans=1e8;\n\t\tr(i,100001)dp1[i]=dp2[i]=1e9;\n\t\tdp1[0]=dp2[0]=0;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tr(i,n)cin>>a[i];\n\t\tcin>>t;\n\t\tr(i,t){\n\t\t\tcin>>s>>t1>>s>>t2;\n\t\t\tif(t2>100000)t2=100000;\n\t\t\tif(s==\"All\")v1.push_back(P(t1,t2));\n\t\t\telse v2.push_back(P(t1,t2));\n\t\t}\n\t\tr(i,v1.size())r(j,100001)if(j+v1[i].S<=100001)\n\t\t  dp1[j+v1[i].S]=min(dp1[j+v1[i].S],dp1[j]+v1[i].F);\n\t\t  else dp1[100000]=min(dp1[100000],dp1[j]+v1[i].F);\n\t\tr(i,v2.size())r(j,100001)if(j+v2[i].S<=100001)\n\t\t  dp2[j+v2[i].S]=min(dp2[j+v2[i].S],dp2[j]+v2[i].F);\n\t\t  else dp2[100000]=min(dp2[100000],dp2[j]+v1[i].F);\n\t\tfor(int i=99999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tr(i,100001)if(dp1[i]!=1e8){\n\t\t\tint sum=0;\n\t\t\tr(j,n)if(a[j]-i>0)sum+=dp2[a[j]-i];\n\t\t\tans=min(ans,sum+dp1[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n\n#define HP_MAX 100005\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint N; cin >> N;\n\t\tif (N == 0) return 0;\n\t\tvi HP(N); rep(i, 0, N) cin >> HP[i];\n\n\t\tint M; cin >> M;\n\t\tvector<pii> single, all;\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring a, b; int mp, da;\n\t\t\tcin >> a >> mp >> b >> da;\n\t\t\tif (b == \"Single\")\n\t\t\t\tsingle.push_back(pii(mp, da));\n\t\t\telse\n\t\t\t\tall.push_back(pii(mp, da));\n\t\t}\n\n\t\tvi sdp(HP_MAX, INF);\n\t\tsdp[0] = 0;\n\t\trep(i, 0, HP_MAX)\n\t\t{\n\t\t\tif (sdp[i] == INF) continue;\n\t\t\tfor (auto p : single)\n\t\t\t{\n\t\t\t\tint mp = p.first;\n\t\t\t\tint da = p.second;\n\n\t\t\t\tint ni = i + da;\n\n\t\t\t\tif (HP_MAX <= ni) ni = HP_MAX - 1;\n\t\t\t\tsdp[ni] = min(sdp[ni], sdp[i] + mp);\n\t\t\t}\n\t\t}\n\t\tint _min = sdp[HP_MAX - 1];\n\t\trrep(i, HP_MAX - 2, 0)\n\t\t{\n\t\t\t_min = min(_min, sdp[i]);\n\t\t\tsdp[i] = _min;\n\t\t}\n\n\t\tvi adp(HP_MAX, INF);\n\t\tadp[0] = 0;\n\t\trep(i, 0, HP_MAX)\n\t\t{\n\t\t\tif (adp[i] == INF) continue;\n\t\t\tfor (auto p : all)\n\t\t\t{\n\t\t\t\tint mp = p.first;\n\t\t\t\tint da = p.second;\n\n\t\t\t\tint ni = i + da;\n\n\t\t\t\tif (HP_MAX <= ni) ni = HP_MAX - 1;\n\t\t\t\tadp[ni] = min(adp[ni], adp[i] + mp);\n\t\t\t}\n\t\t}\n\t\t_min = adp[HP_MAX - 1];\n\t\trrep(i, HP_MAX - 2, 0)\n\t\t{\n\t\t\t_min = min(_min, adp[i]);\n\t\t\tadp[i] = _min;\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, 0, HP_MAX)\n\t\t{\n\t\t\tint mp = adp[i];\n\t\t\trep(j, 0, N)\n\t\t\t{\n\t\t\t\tint d = HP[j] - i;\n\t\t\t\tif (d < 0) continue;\n\t\t\t\tmp += sdp[d];\n\t\t\t}\n\t\t\tans = min(ans, mp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#define INF 100000\nusing namespace std;\n\nstruct spell{\n    string name;\n    long long int mp;\n    string target;\n    long long int damage;\n};\nlong long int max(long long int n,long long int m){\n    if (n<m) {\n        return m;\n    }else{\n        return n;\n    }\n}\n\nlong long int min(long long int n, long long int m){\n    if (n<m) {\n        return n;\n    }else{\n        return m;\n    }\n}\n\nint main() {\n    for (; ;) {\n        int n;\n        cin >> n;\n        if (n==0) break;\n        vector<long long int> hp(n);\n        long long int max_hp=0;\n        for (int i=0; i<n; i++) {\n            cin >> hp[i];\n            max_hp = max(max_hp,hp[i]);\n        }\n        int m;\n        cin >> m;\n        vector<spell> sp(m);\n        for (int i=0; i<m; i++) {\n            cin >> sp[i].name>> sp[i].mp>> sp[i].target >> sp[i].damage;\n        }\n        long long int smp=1000,amp=1000,sdm=10,adm=10;\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"Single\") {\n                if (smp>sp[i].mp) {\n                smp=sp[i].mp;\n                sdm=sp[i].damage;\n                }\n            }\n        }\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"All\") {\n                if (amp>sp[i].mp) {\n                    amp=sp[i].mp;\n                    adm=sp[i].damage;\n                }\n            }\n        }\n        vector<long long int> single(max_hp+1,INF);\n        if (smp!=100) {\n            single[0]=0;\n            for (int i=1; i<=sdm; i++) {\n                single[i]=smp;\n                //if(i/100==0) cout << single[i]<<endl;\n            }\n            for (long long int i=smp+1; i<=max_hp; i++) {\n                long long int res = 114514;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target==\"Single\" && single[max(0,i-sp[k].damage)]+sp[k].mp<=res) res = single[max(0,i-sp[k].damage)]+sp[k].mp;\n                }\n                if(res!=114514) single[i]=res;\n            }\n        }\n        \n        vector<long long int> all(max_hp+1,INF);\n        if (amp!=100) {\n            all[0]=0;\n            for (int i=1; i<=adm; i++) {\n                all[i]=amp;\n            }\n            for (long long int i=adm+1; i<=max_hp; i++) {\n                long long int res = 114514;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target== \"All\"  && all[max(0,i-sp[k].damage)]+sp[k].mp<=res){\n                        res = all[max(0,i-sp[k].damage)]+sp[k].mp;\n                    }\n                }\n                if(res!=114514) all[i]=res;\n            }\n        }\n        long long int ans=100000;\n        for (int i=0; i<=max_hp; i++) {\n            vector<long long int> hpp(hp);\n            int hoge=0;\n            for (int j=0; j<n; j++) {\n                hpp[j]=max(0,hpp[j]-i);\n                hoge += single[hpp[j]];\n            }\n            ans = min(ans,all[i]+hoge);\n        }\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,am,sm,hp[110],maxhp;\nll amp[110],adm[110],smp[110],sdm[110];\nll dpa[100100], dps[100100];\nstring name;\nll tmp;\nconst ll INF = (ll)(1e15);\n\nint main(){\n  while(cin >> n,n){\n    maxhp = 0;\n    for(int i=0;i<n;i++){\n      cin >> hp[i];\n      maxhp = max(maxhp,hp[i]);\n    }\n\n    cin >> m;\n    am = sm = 0;\n\n    for(int i=0;i<m;i++){\n      cin >> name >> tmp;\n      cin >> name;\n      if(name == \"All\")amp[am] = tmp;\n      else smp[sm] = tmp;\n      cin >> tmp;\n      if(name == \"All\")adm[am++] = tmp;\n      else sdm[sm++] = tmp;\n    }\n\n\n    for(int i=0;i<=maxhp;i++)dpa[i] = INF;\n    dpa[0] = 0;\n\n    for(int i=0;i<am;i++){\n      for(int j=0;j<=maxhp;j++){\n\tif(dpa[j]<INF && j+adm[i]<=maxhp){\n\t  dpa[j+adm[i]] = min(dpa[j+adm[i]],dpa[j] + amp[i]);\n\t}\n      }\n    }\n\n    tmp = INF;\n    for(int i=maxhp;i>=0;i--){\n      if(tmp<dpa[i])dpa[i] = tmp;\n      else tmp = dpa[i];\n    }\n\n    for(int i=0;i<=maxhp;i++)dps[i] = INF;\n    dps[0] = 0;\n\n    for(int i=0;i<sm;i++){\n      for(int j=0;j<=maxhp;j++){\n\tif(dps[j]<INF && j+sdm[i]<=maxhp){\n\t  dps[j+sdm[i]] = min(dps[j+sdm[i]],dps[j] + smp[i]);\n\t}\n      }\n    }\n\n    tmp = INF;\n    for(int i=maxhp;i>=0;i--){\n      if(tmp<dps[i])dps[i] = tmp;\n      else tmp = dps[i];\n    }\n\n    ll ans = INF;\n    for(int i=0;i<=maxhp;i++){\n      tmp = dpa[i];\n      for(int j=0;j<n;j++){\n\tint rem = hp[j] - i;\n\tif(rem<=0)continue;\n\ttmp += dps[rem];\n      }\n      ans = min(ans,tmp);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<map>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\nint hp[100];\nint dp1[100050];\nint dp2[100050];\nconst int inf = 1<<29;\npair<int, int> smagic[100];\npair<int, int> amagic[100];\n\nint main() {\n    int N,M,i,j,k,mp,dm,am,sm,maxhp;\n    string name,range;\n    while(cin>>N, N) {\n        memset(hp, 0, sizeof(hp));\n        rep(i,100005) dp1[i] = dp2[i] = inf;\n        am = sm = maxhp = 0;\n        rep(i,N) cin>>hp[i];\n        rep(i,N) maxhp = max(maxhp, hp[i]);\n        cin>>M;\n\n        rep(i,M) {\n            cin>>name>>mp>>range>>dm;\n            if(range == \"All\") {\n                amagic[am] = make_pair(mp,dm);\n                am++;\n            }else{\n                smagic[sm] = make_pair(mp,dm);\n                sm++;\n            }\n        }\n\n        dp1[0] = dp2[0] = 0;\n        rep(i,maxhp+1) {\n            rep(j,am) {\n                if(dp1[i] == inf) continue;\n                int h = min(maxhp, i+amagic[j].second);\n                dp1[h] = min(dp1[h],\n                             dp1[i]+amagic[j].first);\n            }\n            rep(j,sm) {\n                if(dp2[i] == inf) continue;\n                int h = min(maxhp, i+smagic[j].second);\n                dp2[h] = min(dp2[h],\n                             dp2[i]+smagic[j].first);\n            }\n        }\n\n\n        int smax = inf,amax = inf;\n        for(i = 100004; i>=0; --i) {\n            if(smax > dp2[i]) smax = dp2[i];\n            if(amax > dp1[i]) amax = dp1[i];\n            if(dp2[i] > smax) dp2[i] = smax;\n            if(dp1[i] > amax) dp1[i] = amax;\n        }\n\n        ll ans = inf;\n        for(int i=maxhp; i>=0; --i) {\n            int j;\n            ll tmp = dp1[i];\n            rep(j,N) {\n                if(hp[j]-i > 0) {\n                    tmp += dp2[hp[j]-i];\n                }\n            }\n            ans = min(tmp, ans);\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint n, m;\n\nvoid solve(){\n    int hp[n];\n    rep(i, n) scanf(\"%d\", &hp[i]);\n    scanf(\"%d\", &m);\n    vector<pii> single, all; // (mp, damage)\n    rep(_, m){\n        string name, target;\n        lint mp, damage;\n        cin >> name >> mp >> target >> damage;\n        if(target == \"Single\") single.emplace_back(mp, damage);\n        else all.emplace_back(mp, damage);\n    }\n\n    lint all_cost[MAX];\n    fill(all_cost, all_cost + MAX, INF);\n    all_cost[0] = 0;\n    rep(i, all.size()){\n        rep(j, MAX)if(all_cost[j] < INF){\n            chmin(all_cost[min(MAX - 1, j + all[i].se)], min(INF, all_cost[j] + all[i].fi));\n        }\n    }\n\n    lint single_cost[MAX];\n    fill(single_cost, single_cost + MAX, INF);\n    single_cost[0] = 0;\n    rep(i, single.size()){\n        rep(j, MAX)if(single_cost[j] < INF){\n            chmin(single_cost[min(MAX - 1, j + single[i].se)], min(INF, single_cost[j] + single[i].fi));\n        }\n    }\n    rrep(i, MAX - 1) chmin(single_cost[i], single_cost[i + 1]);\n    \n    lint ans = INF;\n    rep(all_damage, MAX){\n        lint tmp = all_cost[all_damage];\n        rep(i, n){\n            tmp += single_cost[max(0, hp[i] - all_damage)];\n            chmin(tmp, INF);\n        }\n        chmin(ans, tmp);\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint mon[120];\ntypedef struct magic{\n\tint mp;\n\tint t;\n\tint d;\n}magic;\n\nmagic mag[120];\nconst long long int INF = 10000000;\nint n, m, ans, prev;\n\nint dp[200001];\nint dp2[200001];\n\nint main(void){\n\tint i, j;\n\twhile(cin >> n, n){\n\t\tans = 0;\n\t\tmemset(mon, 0, sizeof(mon));\n\t\tmemset(mag, 0, sizeof(mag));\n\t\tvector<magic> all;\n\t\tvector<magic> single;\n\t\tvector<magic> crit;\n\t\tfor(i = 0; i < n; i++) cin >> mon[i];\n\t\tcin >> m;\n\t\tfor(i = 0; i < m; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tcin >> mag[i].mp;\n\t\t\tif(cin >> name, name == \"All\") mag[i].t = 1;\n\t\t\tif(cin >> mag[i].d, !mag[i].d) continue;\n\t\t\telse if(mag[i].t){\n\t\t\t\tif(mag[i].d >= 100000) crit.push_back(mag[i]);\n\t\t\t\telse all.push_back(mag[i]);\n\t\t\t}\n\t\t\telse single.push_back(mag[i]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n\t\tfor(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n\t\t\n\t\t//dp(ALL_Magic)\n\t\tfor(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp[j] == INF) continue;\n\t\t\t\tdp[j + i] = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\n\t\t//dp(SINGLE_Magic)\n\t\tfor(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n\n\t\tfor(i = 0; i < 200001; i++){\n\t\t\tif(dp2[i] == INF) continue;\n\t\t\tfor(j = i; j + i < 200001; j++){\n\t\t\t\tif(dp2[j] == INF) continue;\n\t\t\t\tdp2[j + i] = dp2[i] + dp2[j];\n\t\t\t}\n\t\t}\n\t\tfor(i = 200000; dp2[i] == INF; i--);\n\t\tfor(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n\t\t\n\n\t\tfor(i = 200000; i >= 0; i--){\n\t\t\tif(dp[i] == INF) continue;\n\t\t\tint mon2[120];\n\t\t\tmemcpy(mon2, mon, sizeof(mon));\n\t\t\tprev = dp[i];\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tmon2[j] -= i;\n\t\t\t\tif(mon2[j] > 0) prev += dp2[mon2[j]];\n\t\t\t}\n\t\t\t\n\t\t\tans = min(prev, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nconst int MAX_D = 2000000;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\tfor (int j = MAX_D - 1; j > 0; j--) {\n\t\tres[j - 1] = min(res[j - 1], res[j]);\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\n\t\tlong long ans = al[*max_element(all(h))];\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\nint n,m,hp[100],dp[100001],dp2[100001],inf=1e9;\nvector<P> al,one;\nint dfs(int h){\n\tif(dp[h]!=inf) return dp[h];\n\trep(i,one.size()){\n\t\tint mp=one[i].fs,dam=one[i].sc;\n\t\tif(dam>=h) dp[h]=min(dp[h],mp);\n\t\telse dp[h]=min(dp[h],dfs(h-dam)+mp);\n\t}\n\treturn dp[h];\n}\nint dfs2(int h){\n\tif(dp2[h]!=inf) return dp2[h];\n\trep(i,al.size()){\n\t\tint mp=al[i].fs,dam=al[i].sc;\n\t\tif(dam>=h) dp2[h]=min(dp2[h],mp);\n\t\telse dp2[h]=min(dp2[h],dfs2(h-dam)+mp);\n\t}\n\treturn dp2[h];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tal.clear();\n\t\tone.clear();\n\t\trep(i,n) cin>>hp[i];\n\t\trep1(i,100000) dp[i]=inf,dp2[i]=inf;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring name,tar;\n\t\t\tint mp,dam;\n\t\t\tcin>>name>>mp>>tar>>dam;\n\t\t\tif(dam==0) continue;\n\t\t\tif(tar[0]=='A') al.pb(P(mp,dam));\n\t\t\telse one.pb(P(mp,dam));\n\t\t}\n\t\trep1(i,100000) dfs(i),dfs2(i);\n\t\tint ans=inf;\n\t\trep(damal,100001){\n\t\t\tint now=dp2[damal];\n\t\t\trep(i,n) if(hp[i]>damal) now+=dp[hp[i]-damal];\n\t\t\tans=min(ans,now);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int HSIZE=100001;\nconst int INF=1e9;\nint solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<int> smp,sdmg;\n    vector<int> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<int> sdp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+sdmg[i]<HSIZE) tmp[to][j+sdmg[i]]=min(tmp[to][j+sdmg[i]],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<int> adp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+admg[i]<HSIZE) tmp[to][j+admg[i]]=min(tmp[to][j+admg[i]],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    int res=INF;\n    for(int i=0;i<HSIZE;i++){\n        int sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc+=sdp[max(h[j]-i,0)];\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#define INF (1<<21)\nusing namespace std;\n\nclass Enemy{\npublic:\n  int hp[100];\n  int mp;\n  char a;\n  bool operator < (const Enemy &p)const{\n    return mp > p.mp;\n  }\n  Enemy (int mp = 0,char a = 0): mp(mp),a(a){}\n};\n\nclass Actor{\npublic:\n  int mp,damage;\n  string name;\n  bool all;\n};\n\nint main(){\n  int i,j,k,n,m,ans;\n  string str;\n  while(1){\n    Enemy u,v;\n    Actor p[100];\n    priority_queue<Enemy> Q;\n    cin >> n;\n    if(n == 0) break;\n    for(i=0;i<n;i++){\n      cin >> u.hp[i];\n    }\n    cin >> m;\n    for(i=0;i<m;i++){\n      cin >> p[i].name >> p[i].mp >> str >> p[i].damage;\n      if(str == \"Single\") p[i].all = false;\n      else p[i].all = true;\n    }\n\n    ans = INF;\n    Q.push(u);\n    bool f = false;\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      for(i=0;i<m;i++){\n\tif(p[i].damage <= 0) continue;\n\tv = u;\n\tv.mp += p[i].mp;\n\tif(v.mp >= ans) continue;\n\n\tif(p[i].all){\n\t  for(j=0;j<n;j++){\n\t    if(v.hp[j] > 0 && v.hp[j] - p[i].damage <= 0) v.a++;\n\t    v.hp[j] -= min(v.hp[j],p[i].damage);\n\t  }\n\t  if(v.a >= n){\n\t    ans = min(ans,v.mp);\n\t    f = true;\n\t  }\n\t  else Q.push(v);\n\t}\n\n\telse{\n\t  for(j=0;j<n;j++){\n\t    v = u;\n\t    v.mp += p[i].mp;\n\t    if(v.mp >= ans) continue;\n\n\t    if(v.hp[j] > 0 && v.hp[j] - p[i].damage <= 0) v.a++;\n\t    v.hp[j] -= min(v.hp[j],p[i].damage);\n\t    if(v.a >= n){\n\t      ans = min(ans,v.mp);\n\t      f = true;\n\t    }\n\t    else Q.push(v);\n\t  }\n\t}\n      }\n      if(f) break;\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_N = 101;\nconst int MAX_DMG = 200001;\nconst int INF = 1<<24;\nint N;\nint HP[MAX_N];\nvector<P> vs, va;\n\nint Ts[MAX_DMG];\nint Ta[MAX_DMG];\n\nint solve() {\n  Ts[0] = Ta[0] = 0;\n  for(int d = 1; d < MAX_DMG; ++d) {\n    Ts[d] = Ta[d] = INF;\n    for(int i = 0; i < vs.size(); ++i) {\n      int t = max(0, d-vs[i].first);\n      Ts[d] = min(Ts[d], Ts[t] + vs[i].second);\n    }\n    for(int i = 0; i < va.size(); ++i) {\n      int t = d-va[i].first;\n      if(t < 0) continue;\n      Ta[d] = min(Ta[d], Ta[t] + va[i].second);\n    }\n  }\n\n  int ans = INF;\n  for(int d = 0; d < MAX_DMG; ++d) {\n    if(Ta[d] == INF) continue;\n    int res = Ta[d];\n    for(int i = 0; i < N; ++i) {\n      int hp = max(0, HP[i] - d);\n      res += Ts[hp];\n    }\n    ans = min(ans, res);\n  }\n  return ans;\n}\n\nint main() {\n  while(cin >> N && N) {\n    vs.clear();\n    va.clear();\n    for(int i = 0; i < N; ++i) {\n      cin >> HP[i];\n    }\n    int m;\n    bool costZero = false;\n    cin >> m;\n    for(int i = 0; i < m; ++i) {\n      string name, target;\n      int mp, d;\n      cin >> name >> mp >> target >> d;\n      P p(min(100000, d), mp);\n      if(p.first == 0) continue;\n      if(mp == 0) costZero = true;\n      if(target == \"Single\") vs.push_back(p);\n      else va.push_back(p);\n    }\n    if(costZero) cout << 0 << endl;\n    else cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mpi make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\n#define MAX 100001\n\nint dpA[MAX];\nint dpS[MAX];\nbool ok[MAX];\n\nint main(){\n  int n, m;\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%d\", &m);\n\n    vector<int> hp(n);\n\n    vector<int> mpS;\n    vector<int> dmS;\n\n    vector<int> mpA;\n    vector<int> dmA;\n\n    int highest;\n\n    REP(i,n) scanf(\"%d\", &hp[i]);\n    REP(i,n){\n      char buff[256];\n      char target[256];\n      int mp, dm;\n\n      scanf(\"%s%d%s%d\",buff,&mp,target,&dm);\n      if(target[0] == 'A'){\n        mpA.push_back(mp);\n        dmA.push_back(dm);\n      }else{\n        mpS.push_back(mp);\n        dmS.push_back(dm);\n      }\n    }\n\n    int h = *max_element(hp.begin(), hp.end()) + 1;\n    int s = mpS.size();\n    int a = mpA.size();\n\n    /*\n    dpA[0] = dpS[0] = 0;\n    for(int i=1; i<=h; i++){\n      int tA = INT_MAX, tS = INT_MAX;\n\n      REP(j,a){\n        int tmp = i - dmA[j];\n        if(tmp < 0) tmp = 0;\n        tA = min(tA, dpA[tmp] + mpA[j]);\n      }\n\n      REP(j,s){\n        int tmp = i - dmS[j];\n        if(tmp < 0) tmp = 0;\n        tS = min(tS, dpS[tmp] + mpS[j]);\n      }\n\n      dpA[i] = tA;\n      dpS[i] = tS;\n    }\n    */\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    REP(i,h+1) dpS[i] = INT_MAX;\n    REP(i,h+1) dpA[i] = INT_MAX;\n    REP(i,h+1) ok[i] = false;\n\n    q.push(mpi(0,0));\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      //printf(\"S: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,s){\n        int mm = mp + mpS[i];\n        int dd = dm + dmS[i];\n\n        if(dd > h) dd = h;\n        if(dpS[dd] > mm){\n          dpS[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    q = priority_queue<data,vector<data>,greater<data> >();\n    q.push(mpi(0,0));\n    REP(i,h+1) ok[i] = false;\n\n    while(q.size()){\n      int mp = q.top().f;\n      int dm = q.top().s;\n      q.pop();\n\n      if(ok[dm]) continue;\n      ok[dm] = true;\n      dpA[dm] = mp;\n      //printf(\"A: dm = %d, mp = %d\\n\",dm,mp);\n\n      if(dm == h) break;\n\n      REP(i,a){\n        int mm = mp + mpA[i];\n        int dd = dm + dmA[i];\n\n        if(dd > h) dd = h;\n        if(dpA[dd] > mm){\n          dpA[dd] = mm;\n          q.push(mpi(mm,dd));\n        }\n      }\n    }\n\n    for(int i = h-1; i >= 0; i--){\n      dpA[i] = min(dpA[i+1], dpA[i]);\n      dpS[i] = min(dpS[i+1], dpS[i]);\n    }\n\n    int ans = INT_MAX;\n\n    REP(i,h+1){\n      int mp = dpA[i];\n      int dm = i;\n\n      REP(j,n)\n        if(hp[j] > dm)\n          mp += dpS[hp[j] - dm];\n\n      ans = min(ans, mp);\n    }\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#define INF 100000\nusing namespace std;\n\nstruct spell{\n    string name;\n    int mp;\n    string target;\n    int damage;\n};\n\nint main() {\n    for (; ;) {\n        int n;\n        cin >> n;\n        if (n==0) break;\n        vector<int> hp(n);\n        int max_hp=0;\n        for (int i=0; i<n; i++) {\n            cin >> hp[i];\n            max_hp = max(max_hp,hp[i]);\n        }\n        int m;\n        cin >> m;\n        vector<spell> sp(m);\n        for (int i=0; i<m; i++) {\n            cin >> sp[i].name>> sp[i].mp>> sp[i].target >> sp[i].damage;\n        }\n        int smp=1000,amp=1000,sdm=10,adm=10;\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"Single\") {\n                if (smp>sp[i].mp) {\n                smp=sp[i].mp;\n                sdm=sp[i].damage;\n                }\n            }\n        }\n        for (int i=0; i<m; i++) {\n            if (sp[i].target==\"All\") {\n                if (amp>sp[i].mp) {\n                    amp=sp[i].mp;\n                    adm=sp[i].damage;\n                }\n            }\n        }\n        vector<int> single(max_hp+1,INF);\n        if (smp!=100) {\n            single[0]=0;\n            for (int i=1; i<=sdm; i++) {\n                single[i]=smp;\n                //if(i/100==0) cout << single[i]<<endl;\n            }\n            for (int i=smp+1; i<=max_hp; i++) {\n                int res = 11451419;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target==\"Single\" && single[max(0,i-sp[k].damage)]+sp[k].mp<=res) res = single[max(0,i-sp[k].damage)]+sp[k].mp;\n                }\n                if(res!=11451419) single[i]=res;\n            }\n        }\n        \n        vector<int> all(max_hp+1,INF);\n        if (amp!=100) {\n            all[0]=0;\n            for (int i=1; i<=adm; i++) {\n                all[i]=amp;\n            }\n            for (int i=adm+1; i<=max_hp; i++) {\n                int res = 11451419;\n                for (int k=0; k<m; k++) {\n                    if (sp[k].target== \"All\"  && all[max(0,i-sp[k].damage)]+sp[k].mp<=res){\n                        res = all[max(0,i-sp[k].damage)]+sp[k].mp;\n                    }\n                }\n                if(res!=11451419) all[i]=res;\n            }\n        }\n        int ans=1000000;\n        for (int i=0; i<=max_hp; i++) {\n            vector<int> hpp(hp);\n            int hoge=0;\n            for (int j=0; j<n; j++) {\n                hpp[j]=max(0,hpp[j]-i);\n                hoge += single[hpp[j]];\n            }\n            ans = min(ans,all[i]+hoge);\n        }\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint hp[100];\nint mp[100];\nstring target[100];\nint damage[100];\nint dp1[110][100010], dp2[110][100010];\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) cin >> hp[i];\n    \n    cin >> m;\n    for(int i = 0; i < m; i++){\n      string s;\n      cin >> s >> mp[i] >>  target[i] >> damage[i];\n      //cout << s <<\" \" <<mp[i]<<\" \" << target[i]<<\" \" << damage[i] <<endl;\n    }\n    \n    memset(dp1, 0, sizeof dp1);\n    memset(dp2, 0, sizeof dp2);\n    for(int i = 1; i <= 100000; i++){\n      dp1[0][i] = dp2[0][i] = 1 << 25;\n    }\n    for(int i = 1; i <= n; i++){\n      for(int j = 0; j <= 100000; j++){\n        if(target[i-1] == \"All\"){\n            dp1[i][j] = min(dp1[i-1][j], dp1[i][max(0,j - damage[i-1])] + mp[i-1]);\n            dp2[i][j] = dp2[i-1][j];          \n        }\n        else{\n            dp2[i][j] = min(dp2[i-1][j], dp2[i][max(0,j - damage[i-1])] + mp[i-1]);\n            dp1[i][j] = dp1[i-1][j];\n        }\n      }\n    }\n    \n    \n    for(int i = 5000; i <= 10000; i++){\n      //cout << i << \" \" << dp2[n][i] <<endl;\n    }\n    \n    int ans = 1 << 25;\n    for(int i = 0; i <= 100000; i++){\n      int sum = dp1[n][i];\n      //cout << i << \" \" << dp1[n][i];\n      for(int j = 0; j < n; j++){\n        if(hp[j] - i <= 0) continue;\n        sum += dp2[n][hp[j] - i];\n      }\n      //cout << i << \" \" << sum <<endl;\n      ans = min(ans, sum);\n    }\n    \n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000005\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nint dp[2][MAX_Damage];\n\n\n\nint main()\n{\n  while(cin >> N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(damage == 0)continue;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)\n\t{\n\t  rep(j,MP[i].size())\n\t    {\n\t      rep(k,MAX_Damage)\n\t\t{\n\t\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t\t      dp[i][k] + MP[i][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,2)\n\t{\n\t  for(int j=MAX_Damage-2;j>=0;j--)\n\t    {\n\t      dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\t    }\n\t}\n\n      int ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  if(dp[1][i] == inf)continue;\n\t  int cnt = dp[1][i];\n\t  rep(j,N)//Single\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      if(dp[0][HP[j]-i] == inf)break;\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  ans = min(ans,cnt);\n\t}\n\n      int mex = -inf;\n      int cnt = 0;\n      rep(i,N)//Single\n\t{\n\t  mex = max(mex,HP[i]);\n\t  cnt += dp[0][HP[i]];\n\t}\n      ans = min(ans,cnt);\n      ans = min(ans,dp[1][mex]);//All\n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nint single[100010] = {};\nint multi[100010] = {};\nint hp[110];\nint main(){\n\tfor(int i = 0 ; i < 100010 ; i++) single[i] = 1e9;\n\tfor(int i = 0 ; i < 100010 ; i++) multi[i] = 1e9;\n\tsingle[0] = multi[0] = 0;\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++)\n\t\tcin >> hp[i];\n\tint M;\n\tcin >> M;\n\tfor(int i = 0 ; i < M ; i++){\n\t\tstring name;\n\t\tint mp;\n\t\tstring target;\n\t\tint dmg;\n\t\tcin >> name >> mp >> target >> dmg;\n\t\tif( target == \"Single\" ){\n\t\t\t\n\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\tsingle[t] = min(single[j+dmg],single[j]+mp);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\tmulti[t] = min(multi[t],multi[j]+mp);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j = 100000-1 ; j >= 0 ; j--){\n\t\tsingle[j] = min(single[j+1],single[j]);\n\t\tmulti[j] = min(multi[j+1],multi[j]);\n\t}\n\t\t\n\tlong long ans = 1e9;\n\tfor(int i = 0 ; i <= 100000 ; i++){\n\t\tlong long sub = multi[i];\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\tint r = max(0,hp[j]-i);\n\t\t\tsub += single[r];\n\t\t}\n\t\tans = min(sub,ans);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n\n\n#define N_MAX 100\n#define M_MAX 100\n#define HP_MAX 100000\nusing namespace std;\n\nint N,M;\nint HP[N_MAX];\nint dp[2][HP_MAX+1];\nint A_dp[HP_MAX+1];//HP??????????????????MP???????°?????????????\nint S_dp[HP_MAX+1];\n\ntypedef pair<int,int> P;\n\nint main(){\n    string s;\n    vector<P> A,S;//<MP,Damage>\n    while(cin>>N,N!=0){\n        A.clear();\n        S.clear();\n        for(int i=0;i<N;i++)cin>>HP[i];\n        cin>>M;\n\n        for(int i=0;i<M;i++){\n            int m,d;\n            cin>>s>>m>>s>>d;\n            if(s[0]=='A'){\n                A.emplace_back(m,d);\n            }else{\n                S.emplace_back(m,d);\n            }\n        }\n        \n        fill_n(dp[0],HP_MAX+1,0);\n        fill_n(dp[1],HP_MAX+1,INT_MAX);\n        for(int i=0;i<A.size();i++){\n            for(int hp=0;hp<=HP_MAX;hp++){\n                if(i==0){\n                    dp[0][hp]=A[0].first+(hp-A[0].second>=0?dp[0][hp-A[0].second]:0);\n                }else{\n                    dp[i%2][hp]=min(dp[(i+1)%2][hp],hp-A[i].second>=0?dp[i%2][hp-A[i].second]+A[i].first:INT_MAX);\n                }\n            }\n        }\n        for(int i=0;i<=HP_MAX;i++) A_dp[i]=dp[(A.size()-1)%2][i];\n\n        fill_n(dp[0],HP_MAX+1,0);\n        fill_n(dp[1],HP_MAX+1,INT_MAX);\n        for(int i=0;i<S.size();i++){\n            for(int hp=0;hp<=HP_MAX;hp++){\n                if(i==0){\n                    dp[0][hp]=S[0].first+(hp-S[0].second>=0?dp[0][hp-S[0].second]:0);\n                }else{\n                    dp[i%2][hp]=min(dp[(i+1)%2][hp],hp-S[i].second>=0?dp[i%2][hp-S[i].second]+S[i].first:INT_MAX);\n                }\n            }\n        }\n        for(int i=0;i<=HP_MAX;i++) S_dp[i]=dp[(S.size()-1)%2][i];\n\n        int MP_min=INT_MAX;\n\n        for(int alldamage=0;alldamage<=HP_MAX;alldamage++){\n            int mp=A_dp[alldamage];\n            for(int i=0;i<N;i++){\n                int hp=HP[i];\n                hp-=alldamage;\n                if(hp>0){\n                    mp+=S_dp[hp];\n                }\n            }\n            MP_min=min(MP_min,mp);\n        }\n        cout << MP_min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\n\t\tr=9999999;\n\t\tfor(i=0;i<=h;i++){\n\t\t\ts=all[i];\n\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\tif(r>s)r=s;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint N, M;\n\tint HP[100];\n\tint costS[100001], costA[100001];\n\twhile(cin >> N, N){\n\t\tint maxHP = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> HP[i];\n\t\t\tmaxHP = max(maxHP, HP[i]);\n\t\t}\n\t\tcin >> M;\n\t\tstring target;\n\t\tint MP, damage;\n\t\tvector< pair<int,int> > single;\n\t\tvector< pair<int,int> > all;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\tif(damage==0) continue;\n\t\t\tif(target==\"Single\") single.push_back(make_pair(MP,damage));\n\t\t\telse                 all.push_back(make_pair(MP,damage));\n\t\t}\n\t\tmemset(costS,-1,sizeof(costS)); costS[0] = 0;\n\t\tmemset(costA,-1,sizeof(costA)); costA[0] = 0;\n\t\tfor(int i=1;i<=maxHP;i++){\n\t\t\tfor(int j=0;j<single.size();j++){\n\t\t\t\tint prev = max(0,i-single[j].second);\n\t\t\t\tif(costS[i]==-1||costS[i]>costS[prev]+single[j].first)\n\t\t\t\t\tcostS[i] = costS[prev]+single[j].first;\n\t\t\t}  \n\t\t\tfor(int j=0;j<all.size();j++){\n\t\t\t\tint prev = max(0,i-all[j].second);\n\t\t\t\tif(costA[i]==-1||costA[i]>costA[prev]+all[j].first)\n\t\t\t\t\tcostA[i] = costA[prev]+all[j].first;\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tfor(int i=0;i<=maxHP;i++){\n\t\t\tif(costA[i]==-1) continue;\n\t\t\tif(costS[maxHP-i]==-1) continue;\n\t\t\tint tmp = costA[i];\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\ttmp += costS[max(0,HP[j]-i)];\n\t\t\tif(ans==-1||ans>tmp) ans = tmp;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator < (const DD &a)const{ return mp<a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1199999],res=1000000000;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<M;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\nint N,M,HP[105],A,SDP[100005],ADP[100005],res,tmp;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tmemset(ADP,0x7f,sizeof(ADP));\n\t\tSDP[0]=ADP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tSDP[np]=min(SDP[np],SDP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tfor(int i=100000;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\n\t\tfor(int i=M-A;i<M;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tADP[np]=min(ADP[np],ADP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tif(A==M)\n\t\t{\n\t\t\tint mh=0;\n\t\t\tfor(int i=0;i<N;i++)mh=max(mh,HP[i]);\n\t\t\tfor(int i=mh;i<=100000;i++)\n\t\t\t\tres=min(res,ADP[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<=100000;i++)\n\t\t\t{\n\t\t\t\tif(ADP[i]==2139062143)continue;\n\t\t\t\ttmp=ADP[i];\n\t\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\t{\n\t\t\t\t\tif(HP[k]-i>=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint np=HP[k]-i;\n\t\t\t\t\t\tif(np<0)np=0;\n\t\t\t\t\t\tif(SDP[np]==2139062143)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp=1000000000;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp+=SDP[np];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres=min(res,tmp);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define SIZE 100000\nconst int INF = 1000000000;\nint single[101][SIZE+1];\nint res_all[SIZE+1];\nint res_single[SIZE+1];\n\nvoid calc_single(int maxhp,vector<int>&mp,vector<int>&damage){\n  int n=mp.size(),m=maxhp;\n  rep(i,n+1)rep(j,m+1)single[i][j]=INF;\n  single[0][0]=0;\n  rep(i,n){\n    rep(j,m+1){\n      if ( single[i][j] >=INF)continue;\n      single[i+1][j]=min(single[i][j],single[i+1][j]);\n      if ( j+damage[i] <=maxhp){\n\tsingle[i][j+damage[i]]=min(single[i][j+damage[i]],single[i][j]+mp[i]);\n\tsingle[i+1][j+damage[i]]=min(single[i+1][j+damage[i]],single[i][j]+mp[i]);\n      }else single[i+1][maxhp]=min(single[i+1][maxhp],single[i][j]+mp[i]);\n    }\n  }\n\n  /*\n  int tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if ( tmp > single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  */\n\n}\n\n\nint solve(int maxhp,vector<int>& hp,vector<int>&mpsingle,vector<int>& damagesingle,\n\t  vector<int>&mpall,vector<int> &damageall){\n  int ret = INF,n,tmp;\n  calc_single(maxhp,mpsingle,damagesingle);\n  n=mpsingle.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_single[i]=tmp;\n  }\n  calc_single(maxhp,mpall,damageall);\n  n=mpall.size();\n  tmp=single[n][maxhp];\n  for(int i=maxhp;i>=0;i--){\n    if (tmp>single[n][i])tmp=single[n][i];\n    res_all[i]=tmp;\n  } \n\n\n  rep(i,maxhp+1){\n    if ( res_all[i]>=INF)continue;\n    tmp=res_all[i];\n    rep(j,hp.size()){\n      if ( hp[j]-i<=0)continue;\n      tmp+=res_single[hp[j]-i];\n    }\n    ret=min(tmp,ret);\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    int m;\n    int maxhp=0;\n    vector<int>hp;\n    rep(i,n){\n      int tmp;\n      cin>>tmp;\n      maxhp=max(maxhp,tmp);\n      hp.push_back(tmp);\n    }\n    cin>>m;\n    vector<int> mpsingle,mpall,damagesingle,damageall;\n    rep(i,m){\n      string t,check;\n      int tmp,tdamage;\n      cin>>t>>tmp>>check>>tdamage;\n      if ( check[0] == 'A' && tdamage != 0)mpall.push_back(tmp),damageall.push_back(tdamage);\n      else if ( check[0] == 'S'&&tdamage!=0)mpsingle.push_back(tmp),damagesingle.push_back(tdamage);\n    }\n    cout << solve(maxhp,hp,mpsingle,damagesingle,mpall,damageall)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define fr first\n#define sc second\n\ntypedef long long ll;\nconst ll INF=100000000;\nll dx[4]={1,0,-1,0};\nll dy[4]={0,1,0,-1};\nusing namespace std;\n\nstruct Spell {\n    ll mp,target,damage;\n    Spell(ll mp=0,ll target=0,ll damage=0) :\n        mp(mp),target(target),damage(damage){}\n\n};\n\nstruct State {\n    ll cost;\n    vector<int> HP;\n    State(ll cost=0,const vector<int> &HP=vector<int>()):\n        cost(cost),HP(HP){}\n    bool operator<(const State& rhs) const {\n        return cost>rhs.cost;\n    }\n};\n\nll N;\nvector<int> HP;\nll M;\nSpell spells[102];\nll dp1[1000006],dp2[1000006];\n\nll solve() {\n    ll ret=INF;\n    rep(i,1000006) dp1[i]=dp2[i]=INF;\n    dp1[0]=dp2[0]=0;\n    rep(i,M) rep(j,1000006) {\n        if(j+spells[i].damage>=1000006) continue;\n        if(spells[i].target==0) {\n            dp1[j+spells[i].damage]=min(dp1[j+spells[i].damage],dp1[j]+spells[i].mp);\n        }\n        else {\n            dp2[j+spells[i].damage]=min(dp2[j+spells[i].damage],dp2[j]+spells[i].mp);\n        }\n    }\n    for(ll i=1000005;i>=1;i--) {\n        dp2[i-1]=min(dp2[i],dp2[i-1]);\n        dp1[i-1]=min(dp1[i],dp1[i-1]);\n    }\n\n    rep(i,1000006) {\n        ll s=dp2[i];\n        rep(j,N) {\n            s+=dp1[max(0,HP[j]-i)];\n        }\n\n        //printf(\"%d %d\\n\",i,s);\n        ret=min(ret,s);\n    }\n\n    return ret;\n}\n\nint main() {\n    while(cin>>N) {\n        HP.clear();\n        if(!N) break;\n        HP.resize(N);\n        rep(i,N) cin>>HP[i];\n        cin>>M;\n        rep(i,M) {\n            string s1,s2;\n            ll mp,damage;\n            cin>>s1>>mp>>s2>>damage;\n            ll t=0;\n            if(s2==\"All\") t=1;\n            spells[i]=Spell(mp,t,damage);\n        }\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define chmin(a, b) (a = min(a, b))\n\nint n, m;\nint a[100];\nvector<pair<int, int>> v[2];\nint dp[2][100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tv[0].clear(), v[1].clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s, t;\n\t\t\tint p, d;\n\t\t\tcin >> s >> p >> t >> d;\n\t\t\tv[t == \"Single\"].emplace_back(p, d);\n\t\t}\n\t\tfill_n(*dp, 2 * 100010, INT_MAX);\n\t\tdp[0][0] = dp[1][0] = 0;\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < v[i].size(); j++){\n\t\t\t\tfor (int k = 1; k <= 100000; k++){\n\t\t\t\t\tchmin(dp[i][k], dp[i][max(0, k - v[i][j].second)] + v[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INT_MAX;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tint sum = dp[0][i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tsum += dp[1][max(0, a[j] - i)];\n\t\t\t}\n\t\t\tchmin(res, sum);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INFTY=1ll<<61;\n\nstruct Spell{\n\tint m,d;\n\tSpell(){}\n\tSpell(int m,int d):m(m),d(d){}\n};\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n,n;){\n\t\tvector<int> hs(n);\n\t\tfor(int& h:hs) cin>>h;\n\t\tcin>>m;\n\t\tvector<Spell> ss,as; // single,all\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring n,t; int m,d;\n\t\t\tcin>>n>>m>>t>>d; chmin(d,100000);\n\t\t\tif(t==\"Single\") ss.emplace_back(m,d);\n\t\t\telse            as.emplace_back(m,d);\n\t\t}\n\t\t\n\t\tvector<ll> sdp(100001,INFTY); sdp[0]=0;\n\t\tfor(int i=0;i<ss.size();i++){\n\t\t\tfor(int j=1;j<ss[i].d;j++)\n\t\t\t\tchmin<ll>(sdp[j],ss[i].m);\n\t\t\tfor(int j=ss[i].d;j<sdp.size();j++)\n\t\t\t\tchmin<ll>(sdp[j],sdp[j-ss[i].d]+ss[i].m);\n\t\t}\n\t\tvector<ll> adp(100001,INFTY); adp[0]=0;\n\t\tfor(int i=0;i<as.size();i++){\n\t\t\tfor(int j=1;j<as[i].d;j++)\n\t\t\t\tchmin<ll>(adp[j],as[i].m);\n\t\t\tfor(int j=as[i].d;j<adp.size();j++)\n\t\t\t\tchmin<ll>(adp[j],adp[j-as[i].d]+as[i].m);\n\t\t}\n\t\t\n\t\tll res=INFTY;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tll temp=adp[i];\n\t\t\tfor(int& h:hs)\n\t\t\t\ttemp+=sdp[max(h-i,0)];\n\t\t\tchmin(res,temp);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Spell {\n    int mp,target,damage;\n    Spell(int mp=0,int target=0,int damage=0) :\n        mp(mp),target(target),damage(damage){}\n\n};\n\nstruct State {\n    ll cost;\n    vector<int> HP;\n    State(int cost=0,const vector<int> &HP=vector<int>()):\n        cost(cost),HP(HP){}\n    bool operator<(const State& rhs) const {\n        return cost>rhs.cost;\n    }\n};\n\nint N;\nvector<int> HP;\nint M;\nSpell spells[102];\nint dp1[1000006],dp2[1000006];\n\nint solve() {\n    int ret=INF;\n    rep(i,1000006) dp1[i]=dp2[i]=INF;\n    dp1[0]=dp2[0]=0;\n    rep(i,M) rep(j,1000006) {\n        if(j+spells[i].damage>1000006) continue;\n        if(spells[i].target==0) {\n            dp1[j+spells[i].damage]=min(dp1[j+spells[i].damage],dp1[j]+spells[i].mp);\n        }\n        else {\n            dp2[j+spells[i].damage]=min(dp2[j+spells[i].damage],dp2[j]+spells[i].mp);\n        }\n    }\n    for(int i=1000005;i>=1;i--) {\n        dp2[i-1]=min(dp2[i],dp2[i-1]);\n        dp1[i-1]=min(dp1[i],dp1[i-1]);\n    }\n\n    rep(i,1000006) {\n        int s=dp2[i];\n        rep(j,N) {\n            s+=dp1[max(0,HP[j]-i)];\n        }\n\n        ret=min(ret,s);\n    }\n\n    return ret;\n}\n\nint main() {\n    while(cin>>N) {\n        HP.clear();\n        if(!N) break;\n        HP.resize(N);\n        rep(i,N) cin>>HP[i];\n        cin>>M;\n        rep(i,M) {\n            string s1,s2;\n            int mp,damage;\n            cin>>s1>>mp>>s2>>damage;\n            int t=0;\n            if(s2==\"All\") t=1;\n            spells[i]=Spell(mp,t,damage);\n        }\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m;\nll h[111];\nmap<ll,ll> dpa,dpb;\nll na,nb;\nll ma[111],mb[111],da[111],db[111];\n\nll dfsa(ll i){\n  if(dpa.find(i)!=dpa.end())return dpa[i];\n  if(i==0)return 0;\n  ll res=INF;\n  rep(j,na){\n    minch(res,ma[j]+dfsa(mmax(i-da[j],0)));\n  }\n  return dpa[i]=res;\n}\n\nll dfsb(ll i){\n  if(dpb.find(i)!=dpb.end())return dpb[i];\n  if(i==0)return 0;\n  ll res=INF;\n  rep(j,nb){\n    minch(res,mb[j]+dfsb(mmax(i-db[j],0)));\n  }\n  return dpb[i]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    ll maxh=0;\n    rep(i,n){\n      cin>>h[i];\n      maxch(maxh,h[i]);\n    }\n    cin>>m;\n    na=0; nb=0;\n    rep(i,m){\n      string name,target;\n      ll mp,dmg;\n      cin>>name>>mp>>target>>dmg;\n      if(target==\"All\"){\n        ma[na]=mp; da[na]=dmg; na++;\n      }else{\n        mb[nb]=mp; db[nb]=dmg; nb++;\n      }\n    }\n    dpa.clear(); dpb.clear();\n    ll res=INF;\n    rep(ah,maxh+1){\n      ll sum=0;\n      rep(i,n){\n        sum+=dfsb(mmax(h[i]-ah,0LL));\n      }\n      minch(res,sum+dfsa(ah));\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator < (const DD &a)const{ return mp<a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1199999],res;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tif(SP[i].Dam==0)continue;\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tvector<int> h(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> h[i];\n\t\tint M; cin >> M;\n\t\tvector<string> t(M);\n\t\tvector<int> m(M), d(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tstring s;\n\t\t\tcin >> s >> m[j] >> t[j] >> d[j];\n\t\t\td[j] = min(d[j], 100000);\n\t\t}\n\t\tvector<int> dps(100001, INF), dpa(100001, INF);\n\t\tdps[0] = dpa[0] = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tvector<int>& dp = (t[j] == \"Single\" ? dps : dpa);\n\t\t\tfor (int k = 0; k < d[j]; k++)\n\t\t\t\tdp[k] = min(dp[k], m[j]);\n\t\t\tfor (int k = d[j]; k <= 100000; k++)\n\t\t\t\tdp[k] = min(dp[k], dp[k - d[j]] + m[j]);\n\t\t}\n\t\tll mini = INF;\n\t\tfor (int k = 0; k <= 100000; k++) {\n\t\t\tll sum = dpa[k];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint x = max(0, h[i] - k);\n\t\t\t\tsum += dps[x];\n\t\t\t}\n\t\t\tmini = min(mini, sum);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nlong long int DP1[150000], DP2[150000];\n\nint main(){\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint HP[200];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> HP[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 110000; i++){\n\t\t\tDP1[i] = INF;\n\t\t\tDP2[i] = INF;\n\t\t}\n\t\t\n\t\tDP1[0] = 0;\n\t\tDP2[0] = 0;\n\t\t\n\t\tcin >> m;\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tlong long int cost, D;\n\t\t\tstring hoge, t;\n\t\t\tcin >> hoge >> cost >> t >> D;\n\t\t\tif(t == \"Single\"){\n\t\t\t\tfor(int j = 0; j < 110000; j++){\n\t\t\t\t\tDP1[j] = min(DP1[j], DP1[max(0LL, j - D)] + cost);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 110000; j++){\n\t\t\t\t\tDP2[j] = min(DP2[j], DP2[max(0LL, j - D)] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = INF;\n\t\tfor(int i = 0; i < 110000; i++){\n\t\t\tlong long int ret = DP2[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tret += DP1[max(0, HP[j] - i)];\n\t\t\t\tif(ret >= INF){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(ans, ret);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,hp[111];\nint m1,mp1[111],d1[111];\nint m2,mp2[111],d2[111];\nll dp1[200010],dp2[200010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>hp[i];\n\t\tint m;\n\t\tcin>>m;\n\t\tm1=m2=0;\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tint mp,d;\n\t\t\tcin>>s>>mp>>t>>d;\n\t\t\td=min(d,100000);\n\t\t\tif(t==\"Single\"){\n\t\t\t\tmp1[m1]=mp;\n\t\t\t\td1[m1]=d;\n\t\t\t\tm1++;\n\t\t\t}else{\n\t\t\t\tmp2[m2]=mp;\n\t\t\t\td2[m2]=d;\n\t\t\t\tm2++;\n\t\t\t}\n\t\t}\n\t\tfill(dp1,dp1+200001,INF*INF);\n\t\tfill(dp2,dp2+200001,INF*INF);\n\t\tdp1[0]=dp2[0]=0;\n\t\trep2(i,1,200001){\n\t\t\trep(j,m1)if(d1[j]<=i){\n\t\t\t\tdp1[i]=min(dp1[i],mp1[j]+dp1[i-d1[j]]);\n\t\t\t}\n\t\t\trep(j,m2)if(d2[j]<=i){\n\t\t\t\tdp2[i]=min(dp2[i],mp2[j]+dp2[i-d2[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=199999;i>=0;i--){\n\t\t\tdp1[i]=min(dp1[i],dp1[i+1]);\n\t\t\tdp2[i]=min(dp2[i],dp2[i+1]);\n\t\t}\n\t\tll ans=INF*INF;\n\t\trep(i,200001){\n\t\t\tll res=dp2[i];\n\t\t\trep(j,n){\n\t\t\t\tll rest=max(0,hp[j]-i);\n\t\t\t\tres+=dp1[rest];\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint multi[100010], single[100010], hp[110];\n\n\nint main(){\n\tint N;\n\twhile (cin >> N && N){\n\t\tfor (int i = 0; i < 100010; i++){\n\t\t\tmulti[i] = 1e9; single[i] = 1e9;\n\t\t}\n\t\tmulti[0] = 0; single[0] = 0;\n\t\tfor (int i = 0; i < N; i++)cin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring command;\n\t\t\tint dmp;\n\t\t\tcin >> name >> mp >> command >> dmp;\n\t\t\tif (command == \"Single\"){\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tsingle[s] = min(single[s], single[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tmulti[s] = min(multi[s], multi[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100000; i >= 0; i--){\n\t\t\tmulti[i] = min(multi[i], multi[i + 1]);\n\t\t\tsingle[i] = min(single[i], single[i + 1]);\n\t\t}\n\t\tlong long ans = 1e9;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long u = multi[i];\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tint v = min(0, hp[j] - i);\n\t\t\t\tu += single[v];\n\t\t\t}\n\t\t\tans = min(u, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n         return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;//first : MP, second : Damage\nvoid set_cost(vector<int>& cost, const vector<pint>& attack){\n    cost[0] = 0;\n    REP(i, 1, cost.size()){\n        for(pint k : attack){\n            int temp = k.first;\n            if(i - k.second >= 0) temp += cost[i - k.second];\n            cost[i] = min(cost[i], temp);\n        }\n    }\n    return;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        int HP_MAX = -INF;\n        vector<int> HP(N);\n        rep(i, N){\n            cin >> HP[i];\n            HP_MAX = max(HP_MAX, HP[i]);\n        }\n        int M; cin >> M;\n        vector<pint> single, all;\n        rep(i, M){\n            string a, b;\n            int c, d;\n            cin >> a >> c >> b >> d;\n            if(b == \"All\")\n              all.push_back(pint(c, d));\n            else\n              single.push_back(pint(c, d));\n        }\n        vector<int> scost(HP_MAX + 1, INF), acost(HP_MAX + 1, INF);\n        set_cost(scost, single);\n        set_cost(acost, all);\n        int ans = 0;\n        while(true){\n            int hit = INF, enemies = 0;\n            for(int k : HP)\n              if(k > 0) {\n                  enemies++;\n                  hit = min(k, hit);\n              }\n            if(enemies == 0) break;\n            int cost, damage;\n            if(acost[hit] > scost[hit] * enemies){\n                cost = scost[hit];\n                REP(i, hit, HP_MAX + 1) if(scost[i] != cost){ damage = i - 1; break;}\n                cost *= enemies;\n            }else{\n                cost = acost[hit];\n                REP(i, hit, HP_MAX + 1) if(acost[i] != cost){ damage = i - 1; break;}\n            }\n            for(int& k : HP) k -= damage;\n            ans += cost;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define chmin(a, b) (a = min(a, b))\n\nint n, m;\nint a[100];\nvector<pair<int, int>> v[2];\nlong long dp[2][100010];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tv[0].clear(), v[1].clear();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s, t;\n\t\t\tint p, d;\n\t\t\tcin >> s >> p >> t >> d;\n\t\t\tv[t == \"Single\"].emplace_back(p, d);\n\t\t}\n\t\tfill_n(*dp, 2 * 100010, 1ll << 52);\n\t\tdp[0][0] = dp[1][0] = 0;\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < v[i].size(); j++){\n\t\t\t\tfor (int k = 1; k <= 100000; k++){\n\t\t\t\t\tchmin(dp[i][k], dp[i][max(0, k - v[i][j].second)] + v[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = 1ll << 52;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long sum = dp[0][i];\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tsum += dp[1][max(0, a[j] - i)];\n\t\t\t}\n\t\t\tchmin(res, sum);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int inf = 1e9;\n\ntypedef long long ll;\n\nint n;\nint hp[100];\nint ms, ma;\nint mps[100];\nint mpa[100];\nint dmgs[100];\nint dmga[100];\nint dps[101][100001];\nint dpa[101][100001];\n\nvoid calc(int m, int mp[], int dmg[], int dp[][100001]){\n\tdp[0][0] = 0;\n\tfill_n(dp[0] + 1, 100000, inf);\n\tfor(int i = 1; i <= m; ++i){\n\t\trep(j, 100001){\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(dmg[i - 1]){\n\t\t\t\tif(j < dmg[i - 1]){\n\t\t\t\t\tdp[i][j] = min(mp[i - 1], dp[i][j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = min(dp[i][j - dmg[i - 1]] + mp[i - 1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\trep(i, n){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tms = ma = 0;\n\t\trep(i, m){\n\t\t\tchar nm[17];\n\t\t\tint mp;\n\t\t\tchar trgt[7];\n\t\t\tint dmg;\n\t\t\tscanf(\"%s%d%s%d\", nm, &mp, trgt, &dmg);\n\t\t\tif(trgt[0] == 'S'){\n\t\t\t\tmps[ms] = mp;\n\t\t\t\tdmgs[ms++] = dmg;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmpa[ma] = mp;\n\t\t\t\tdmga[ma++] = dmg;\n\t\t\t}\n\t\t}\n\n\t\tcalc(ms, mps, dmgs, dps);\n\t\tcalc(ma, mpa, dmga, dpa);\n\t\t\n\t\tll ans = inf;\n\t\trep(i, 100001){\n\t\t\tll p = dpa[ma][i];\n\t\t\trep(j, n){\n\t\t\t\tif(hp[j] > i){\n\t\t\t\t\tp += dps[ms][hp[j] - i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(p, ans);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\n#define N 100000\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long ll;\n\nint main(){\n  int n,m,hp[101];\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>hp[i];\n\n    vector <P> mg[2];  \n    cin>>m;\n    for(int i=0,cost,dam;i<m;i++){\n      string name,type;\n      cin>>name>>cost>>type>>dam;\n      if(dam)mg[type==\"All\"].push_back(P(dam,cost));\n    }\n\n    int dp[2][N+10]={};\n    for(int i=0;i<2;i++)for(int j=1;j<N+10;j++)dp[i][j]=INF;\n \n    for(int k=0;k<2;k++)\n      for(int i=0;i<mg[k].size();i++)\n\tfor(int j=mg[k][i].f;j<=(N/mg[k][i].f+1)*mg[k][i].f;j++){\n\t  dp[k][min(N,j)]=min(dp[k][min(N,j)],dp[k][j-mg[k][i].f]+mg[k][i].s);\n\t  if(N<j) cout <<j<<endl;\n\t}\n    for(int i=0;i<2;i++)\n      for(int j=N;j>=0;j--)dp[i][j]=min(dp[i][j],dp[i][j+1]);\n      \n    ll ans=INF;\n    for(int i=0;i<=N;i++){\n      ll cost=dp[1][i];\n      for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n      ans=min(ans,cost);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maketbl(const vector<int> &mp, const vector<int> &dmg){\n\tvector<int> ret(100001, 1010101010);\n\tret[0] = 0;\n\tfor(int i = 1; i <= 100000; ++i){\n\t\tfor(size_t j = 0; j < mp.size(); ++j){\n\t\t\tret[i] = min(ret[i], ret[max(i - dmg[j], 0)] + mp[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> hp(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tvector<int> mps, dmgs, mpa, dmga;\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint d, p;\n\t\t\tchar c;\n\t\t\tscanf(\"%*s%d %c%*s%d\", &p, &c, &d);\n\t\t\tif(c == 'S'){\n\t\t\t\tmps.push_back(p);\n\t\t\t\tdmgs.push_back(d);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmpa.push_back(p);\n\t\t\t\tdmga.push_back(d);\n\t\t\t}\n\t\t}\n\t\tvector<int> tbls = maketbl(mps, dmgs);\n\t\tvector<int> tbla = maketbl(mpa, dmga);\n\t\tint ans = 1010101010;\n\t\tfor(int i = 0; i <= 100000; ++i){\n\t\t\tint s = tbla[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\ts += tbls[max(hp[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, s);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tauto HP = read<int>(N);\n\n\t\tint maxHP = *max_element(allof(HP));\n\t\tvector<int> tableS(maxHP + 1, INF); // tableS[x] = 単体魔法でxダメージ与えるのに必要なMP\n\t\tvector<int> tableA(maxHP + 1, INF); // tableA[x] = 全体魔法でxダメージ与えるのに必要なMP\n\n\t\tREAD(int, M);\n\t\tREP(_, M)\n\t\t{\n\t\t\tstring name, type;\n\t\t\tint mp, dmg;\n\t\t\tcin >> name >> mp >> type >> dmg;\n\t\t\tvector<int> &tg = type[0] == 'A' ? tableA : tableS;\n\t\t\ttg[0] = 0;\n\t\t\tFOR(d, 1, maxHP + 1) { tg[d] = min(tg[d], tg[max(0, d - dmg)] + mp); }\n\t\t}\n\n\t\t// 全体魔法でd与えてから、単体魔法で倒してみることにしよう。\n\t\tlong result = LINF;\n\t\tREP(d, maxHP + 1)\n\t\tfor (int d = 0; d <= maxHP; d++)\n\t\t{\n\t\t\tlong cost = tableA[d];\n\t\t\tREP(i, HP.size())\n\t\t\t{\n\t\t\t\tcost += tableS[max(HP[i] - d, 0)];\n\t\t\t}\n\t\t\tresult = min(result, cost);\n\t\t\t//WRITE(\"d:\", d, \" MP:\", cost);\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 100000\n\nint *dp_single,*dp_all;\nint N,monster[100];\n\nvoid func(){\n\n\tint max_hp = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&monster[i]);\n\t\tmax_hp = max(max_hp,monster[i]);\n\t}\n\n\tfor(int i = 1; i <= NUM; i++){\n\t\tdp_single[i] = BIG_NUM;\n\t\tdp_all[i] = BIG_NUM;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint mp,damage;\n\tchar buf[17],target[7];\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s %d %s %d\",buf,&mp,target,&damage);\n\n\t\tif(target[0] == 'S'){\n\t\t\tfor(int i = damage; i <= NUM; i++){\n\t\t\t\tif(dp_single[i-damage] != BIG_NUM){\n\t\t\t\t\tdp_single[i] = min(dp_single[i],dp_single[i-damage]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = damage; i <= NUM; i++){\n\t\t\t\tif(dp_all[i-damage] != BIG_NUM){\n\t\t\t\t\tdp_all[i] = min(dp_all[i],dp_all[i-damage]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = NUM-1; i >= 1; i--){\n\t\tdp_single[i] = min(dp_single[i],dp_single[i+1]);\n\t\tdp_all[i] = min(dp_all[i],dp_all[i+1]);\n\t}\n\n\tint minimum = BIG_NUM,tmp_hp,tmp_minimum;\n\n\tfor(int all_damage = 0; all_damage <= max_hp; all_damage++){\n\t\ttmp_minimum = dp_all[all_damage];\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttmp_hp = monster[i] - all_damage;\n\t\t\tif(tmp_hp > 0){\n\t\t\t\ttmp_minimum += dp_single[tmp_hp];\n\t\t\t}\n\t\t}\n\n\t\tminimum = min(minimum,tmp_minimum);\n\t}\n\n\tprintf(\"%d\\n\",minimum);\n}\n\nint main(){\n\n\tdp_single = new int[NUM+1];\n\tdp_all = new int[NUM+1];\n\n\tdp_single[0] = 0;\n\tdp_all[0] = 0;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=1ll<<60,sum;\n        for(int i=0; i<n; i++)\n        {\n            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n            ll tmp=sum;\n//        printf(\"%d\\n\",tmp);\n            for(int j=i+1; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[tmp])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 105\n#define HP 100010\n\n\nvoid calc(int n){\n  int hp[SIZE],m,mp[SIZE],damage[SIZE],target[SIZE];\n  int max_hp = 0;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",hp+i);\n    max_hp = max(max_hp,hp[i]);\n  }\n\n  scanf(\"%d\",&m);\n\n  for(int i=0;i<m;i++){\n    char target_c[SIZE];\n    scanf(\"%*s%d%s%d\",mp+i,target_c,damage+i);\n\n    target[i] = target_c[0] == 'A';\n  }\n\n  int dp_a[HP],dp_s[HP];\n  \n  for(int i=0;i<HP;i++){\n    dp_a[i] = dp_s[i] = INF;\n  }\n\n  dp_a[0] = dp_s[0] = 0;\n\n  for(int i=0;i<max_hp;i++){\n    for(int j=0;j<m;j++){\n      int p = min(i+damage[j],max_hp);\n      if(target[j]){ //ALL\n        dp_a[p] = min(dp_a[p], dp_a[i]+mp[j]);\n      }else{\n        dp_s[p] = min(dp_s[p], dp_s[i]+mp[j]);\n      }   \n    }\n  }\n\n  for(int i=max_hp;i>0;i--){\n    dp_a[i-1] = min(dp_a[i-1],dp_a[i]);\n    dp_s[i-1] = min(dp_s[i-1],dp_s[i]);\n  }\n\n  ll ans = LLINF;\n  \n  for(int i=0;i<=max_hp;i++){\n    ll sum = dp_a[i];\n\n    for(int j=0;j<n;j++){\n      sum += dp_s[max(0,hp[j]-i)];\n    }\n\n    ans = min(ans, sum);\n  }\n\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n  int x;\n  \n  while(1){\n    scanf(\"%d\",&x);\n\n    if(x == 0) break;\n\n    calc(x);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nint HP[101];\n\nint M;\n\nvector< tuple<int, int, int> > magic;\n\nint dp[2][1000001]; // Single/All???just i???????????????????????????????°????MP\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    int mxhp = 0;\n    rep(i, N) cin >> HP[i], mxhp = max(mxhp, HP[i]);\n\n    cin >> M;\n    rep(i, M) {\n      string na, tar;\n      int mp, dam;\n      cin >> na >> mp >> tar >> dam;\n      magic.emplace_back(mp, (tar == \"All\"), dam);\n    }\n\n    fill(dp[0], dp[2], inf);\n    dp[0][0] = dp[1][0] = 0;\n    for(auto m : magic) {\n      int mp, tar, dam;\n      tie(mp, tar, dam) = m;\n      rep(i, mxhp+1) {\n\tdp[tar][min(mxhp, i+dam)] = min(dp[tar][min(mxhp, i+dam)], dp[tar][i] + mp);\n      }\n    }\n\n    int ans = inf;\n    rep(i, mxhp+1) if(dp[1][i] != inf) {\n      int sum = dp[1][i];\n      rep(j, N) sum += dp[0][max(HP[j]-i, 0LL)];\n      ans = min(ans, sum);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int HSIZE=100001;\nconst int INF=1e9;\nusing ll = long long;\nll solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<int> smp,sdmg;\n    vector<int> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<int> sdp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+sdmg[i]<HSIZE) tmp[to][j+sdmg[i]]=min(tmp[to][j+sdmg[i]],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<int> adp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+admg[i]<HSIZE) tmp[to][j+admg[i]]=min(tmp[to][j+admg[i]],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    ll res=ll(1e15);\n    for(int i=0;i<HSIZE;i++){\n        ll sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc+=sdp[h[j]-i];\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint main(){\n  int n;\n  map<string, int> type;\n\n  type[\"All\"] = 0;\n  type[\"Single\"] = 1;\n\n  while(cin >> n, n){\n    vector<int> hp(n);\n    vector<pair<int, int> > magic[2];\n\n    REP(i,n) cin >> hp[i];\n\n    int m; cin >> m;\n\n    REP(i,m){\n      string name, target;\n      int mp, damage;\n      cin >> name >> mp >> target >> damage;\n      magic[type[target]].push_back(make_pair(mp, damage));\n    }\n\n    vector<int> dp[2];\n    const int MAX = 100000 + 1;\n    const int inf = 100000000;\n\n    REP(cc, 2){\n      vector<int> &memo = dp[cc];\n      memo = vector<int>(MAX, inf);\n      memo[0] = 0;\n\n      REP(i,magic[cc].size()){\n        const int mp     = magic[cc][i].first;\n        const int damage = magic[cc][i].second;\n        REP(j,MAX) if(memo[j] != inf){\n          for(int k = 1; j + k * damage < MAX; k++){\n            memo[j + k * damage] = min(memo[j + k * damage], memo[j] + k * mp);\n          }\n        }\n      }\n\n      // REP(i,MAX) if(memo[i] != inf)\n      // cout << i << \": \" << memo[i] << endl;\n\n      for(int j = MAX - 1; j > 0; j--){\n        memo[j - 1] = min(memo[j - 1], memo[j]);\n      }\n    }\n\n    int ans = inf;\n    REP(all, MAX) if(dp[0][all] != inf){\n      int mp = dp[0][all];\n      REP(i,n){\n        if(hp[i] > all){\n          mp += dp[1][hp[i] - all];\n        }\n      }\n      ans = min(ans, mp);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r;\n\tstring str;\n\tfor(;cin>>n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tmap<int,int>all_iter;\n\t\tall_iter[0]=0;\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t\tall_iter[all[i]]=i;\n\t\t}\n\n\t\tif(_single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\tr=9999999;\n\t\tfor(map<int,int>::iterator it=all_iter.begin();it!=all_iter.end();it++){\n\t\t\th=it->first;\n\t\t\tfor(j=0;j<monster.size();j++)h+=single[max(0,monster[j]-it->second)];\n\t\t\tif(r>h)r=h;\n\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Spell {\n    int mp,target,damage;\n    Spell(int mp=0,int target=0,int damage=0) :\n        mp(mp),target(target),damage(damage){}\n\n};\n\nstruct State {\n    ll cost;\n    vector<int> HP;\n    State(int cost=0,const vector<int> &HP=vector<int>()):\n        cost(cost),HP(HP){}\n    bool operator<(const State& rhs) const {\n        return cost>rhs.cost;\n    }\n};\n\nint N;\nvector<int> HP;\nint M;\nSpell spells[102];\nll dijk() {\n    map<vector<int>,ll> d;\n    priority_queue<State> que;\n    que.push(State(0,HP));\n    d[HP]=0;\n    ll ans=1e18;\n    while(que.size()) {\n        State s=que.top(); que.pop();\n        if(s.HP.size()==0) {\n            ans=min(ans,s.cost);\n            continue;\n        }\n        //cout<<s.cost<<\", \"<<s.HP.size()<<endl;\n        //if(d.count(s)) continue;\n\n        rep(i,M) {\n            vector<int> vec=s.HP;\n\n            if(spells[i].target==0) {\n                vec[0]-=spells[i].damage;\n            }\n            else {\n                rep(j,vec.size()) vec[j]-=spells[i].damage;\n            }\n            auto it=vec.begin();\n            while(it!=vec.end()) {\n                if(*it<=0) it=vec.erase(it);\n                else ++it;\n            }\n\n            State next(s.cost+spells[i].mp,vec);\n            if(!d.count(vec)||d[vec]>d[s.HP]+spells[i].mp) {\n                d[vec]=d[s.HP]+spells[i].mp;\n                que.push(next);\n            }\n        }\n    }\n\n    return ans;\n}\nint main() {\n    while(cin>>N) {\n        HP.clear();\n        if(!N) break;\n        HP.resize(N);\n        rep(i,N) cin>>HP[i];\n        cin>>M;\n        rep(i,M) {\n            string s1,s2;\n            int mp,damage;\n            cin>>s1>>mp>>s2>>damage;\n            int t=0;\n            if(s2==\"All\") t=1;\n            spells[i]=Spell(mp,t,damage);\n        }\n        cout<<dijk()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<LL> maketbl(const vector<int> &mp, const vector<int> &dmg, int mh){\n\tvector<LL> ret(mh + 1, 1LL << 60);\n\tret[0] = 0;\n\tfor(int i = 1; i <= mh; ++i){\n\t\tfor(size_t j = 0; j < mp.size(); ++j){\n\t\t\tret[i] = min(ret[i], ret[max(i - dmg[j], 0)] + mp[j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> hp(n);\n\t\tint mh = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t\tmh = max(mh, hp[i]);\n\t\t}\n\t\tvector<int> mps, dmgs, mpa, dmga;\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint d, p;\n\t\t\tchar c;\n\t\t\tscanf(\"%*s%d %c%*s%d\", &p, &c, &d);\n\t\t\tif(d){\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\tmps.push_back(p);\n\t\t\t\t\tdmgs.push_back(d);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmpa.push_back(p);\n\t\t\t\t\tdmga.push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<LL> tbls = maketbl(mps, dmgs, mh);\n\t\tvector<LL> tbla = maketbl(mpa, dmga, mh);\n\t\tLL ans = 1LL << 60;\n\t\tfor(int i = 0; i <= mh; ++i){\n\t\t\tLL s = tbla[i];\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\ts += tbls[max(hp[j] - i, 0)];\n\t\t\t}\n\t\t\tans = min(ans, s);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int HSIZE=100001;\nconst int INF=1e9;\nint solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<int> smp,sdmg;\n    vector<int> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<int> sdp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+sdmg[i]<HSIZE) tmp[to][j+sdmg[i]]=min(tmp[to][j+sdmg[i]],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<int> adp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+admg[i]<HSIZE) tmp[to][j+admg[i]]=min(tmp[to][j+admg[i]],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    int res=INF;\n    for(int i=0;i<HSIZE;i++){\n        int sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc=min(INF,sdp[max(h[j]-i,0)]+sc);\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,cnt;\nint dpAll[D],dpSin[D];\nstring name,target[N];\nvector<P> v;\n\nint bynary_search(int x){\n  int l=0,r=v.size();\n  while(l<r){\n    int m=(l+r)/2;\n    if(v[m].first>x)r=m;\n    else l=m+1;\n  }\n  return l;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++)\n      if(dpSin[i]!=INF)v.push_back(P(i,dpSin[i]));\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      cnt=dpAll[i];\n      for(int j=0;j<m;j++){\n\tint k=hp[j]-i;\n\tcnt+=v[bynary_search(k)].second;\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 999999\n\nint *dp_single,*dp_all;\nint N,monster[100];\n\nvoid func(){\n\n\tint max_hp = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&monster[i]);\n\t\tmax_hp = max(max_hp,monster[i]);\n\t}\n\n\tfor(int i = 1; i <= NUM; i++){\n\t\tdp_single[i] = BIG_NUM;\n\t\tdp_all[i] = BIG_NUM;\n\t}\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tint mp,damage,single_count = 0,all_count = 0;\n\tchar buf[17],target[7];\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s %d %s %d\",buf,&mp,target,&damage);\n\t\tif(damage == 0)continue;\n\n\t\tif(target[0] == 'S'){\n\t\t\tsingle_count++;\n\t\t\tfor(int i = damage; i <= max(damage,max_hp); i++){\n\t\t\t\tif(dp_single[i-damage] != BIG_NUM){\n\t\t\t\t\tdp_single[i] = min(dp_single[i],dp_single[i-damage]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tall_count++;\n\t\t\tfor(int i = damage; i <= max(damage,max_hp); i++){\n\t\t\t\tif(dp_all[i-damage] != BIG_NUM){\n\t\t\t\t\tdp_all[i] = min(dp_all[i],dp_all[i-damage]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = NUM-1; i >= 1; i--){\n\t\tdp_single[i] = min(dp_single[i],dp_single[i+1]);\n\t\tdp_all[i] = min(dp_all[i],dp_all[i+1]);\n\t}\n\n\tint minimum = BIG_NUM,tmp_hp,tmp_minimum;\n\n\tif(single_count > 0 && all_count > 0){\n\n\t\tfor(int all_damage = 0; all_damage <= max_hp; all_damage++){\n\t\t\ttmp_minimum = dp_all[all_damage];\n\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\ttmp_hp = monster[i] - all_damage;\n\t\t\t\tif(tmp_hp > 0){\n\t\t\t\t\ttmp_minimum += dp_single[tmp_hp];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminimum = min(minimum,tmp_minimum);\n\t\t}\n\n\t}else if(single_count == 0){\n\t\tminimum = dp_all[max_hp];\n\t}else{ //all_count = 0;\n\t\tminimum = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tminimum += dp_single[monster[i]];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",minimum);\n}\n\nint main(){\n\n\tdp_single = new int[NUM+1];\n\tdp_all = new int[NUM+1];\n\n\tdp_single[0] = 0;\n\tdp_all[0] = 0;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<map>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nlong long hp[100];\nlong long dp1[100050];\nlong long dp2[100050];\nconst long long inf = 1<<29;\npair<long long, long long> smagic[100];\npair<long long, long long> amagic[100];\n\nint main() {\n    int N,M,i,j,k,mp,dm,am,sm;\n    long long maxhp;\n    string name,range;\n    while(cin>>N, N) {\n        memset(hp, 0, sizeof(hp));\n        rep(i,100005) dp1[i] = dp2[i] = inf;\n        am = sm = maxhp = 0;\n        rep(i,N) cin>>hp[i];\n        rep(i,N) maxhp = max(maxhp, hp[i]);\n        cin>>M;\n\n        rep(i,M) {\n            cin>>name>>mp>>range>>dm;\n            if(range == \"All\") {\n                amagic[am] = make_pair(mp,dm);\n                am++;\n            }else{\n                smagic[sm] = make_pair(mp,dm);\n                sm++;\n            }\n        }\n\n        dp1[0] = dp2[0] = 0;\n        rep(i,maxhp+1) {\n            rep(j,am) {\n                if(dp1[i] == inf) continue;\n                long long h = min(maxhp, i+amagic[j].second);\n                dp1[h] = min(dp1[h],\n                             dp1[i]+amagic[j].first);\n            }\n            rep(j,sm) {\n                if(dp2[i] == inf) continue;\n                int h = min(maxhp, i+smagic[j].second);\n                dp2[h] = min(dp2[h],\n                             dp2[i]+smagic[j].first);\n            }\n        }\n\n\n        int smax = inf,amax = inf;\n        for(i = 100004; i>=0; --i) {\n            if(smax > dp2[i]) smax = dp2[i];\n            if(amax > dp1[i]) amax = dp1[i];\n            if(dp2[i] > smax) dp2[i] = smax;\n            if(dp1[i] > amax) dp1[i] = amax;\n        }\n\n        long long ans = inf;\n        for(int i=maxhp; i>=0; --i) {\n            //cout<<i<<\" \"<<ans<<endl;\n            int j;\n            long long tmp = dp1[i];\n            rep(j,N) {\n                if(hp[j]-i > 0) {\n                    //if(i == 98495) cout<<hp[j]-i<<\" \"<<j<<\" \"<<dp2[hp[j]-i]<<endl;\n                    tmp += dp2[hp[j]-i];\n                }\n            }\n            //cout<<ans<<\" \"<<tmp<<endl;\n            // if(ans > tmp) {\n            //     cout<<i<<\" \"<<ans<<\" \"<<tmp<<endl;\n            // }\n            ans = min(tmp, ans);\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Spell {\n    int mp,target,damage;\n    Spell(int mp=0,int target=0,int damage=0) :\n        mp(mp),target(target),damage(damage){}\n\n};\n\nstruct State {\n    ll cost;\n    vector<int> HP;\n    State(int cost=0,const vector<int> &HP=vector<int>()):\n        cost(cost),HP(HP){}\n    bool operator<(const State& rhs) const {\n        return cost>rhs.cost;\n    }\n};\n\nint N;\nvector<int> HP;\nint M;\nSpell spells[102];\nint dp1[100005],dp2[100005];\n\nint solve() {\n    int ret=INF;\n    rep(i,100005) dp1[i]=dp2[i]=INF;\n    dp1[0]=dp2[0]=0;\n    rep(i,M) rep(j,100005) {\n        if(j+spells[i].damage>100005) continue;\n        if(spells[i].target==0) {\n            dp1[j+spells[i].damage]=min(dp1[j+spells[i].damage],dp1[j]+spells[i].mp);\n        }\n        else {\n            dp2[j+spells[i].damage]=min(dp2[j+spells[i].damage],dp2[j]+spells[i].mp);\n        }\n    }\n    for(int i=100004;i>=1;i--) {\n        dp2[i-1]=min(dp2[i],dp2[i-1]);\n        dp1[i-1]=min(dp1[i],dp1[i-1]);\n    }\n\n    rep(i,100005) {\n        int s=dp2[i];\n        rep(j,N) {\n            s+=dp1[max(0,HP[j]-i)];\n        }\n\n        ret=min(ret,s);\n    }\n\n    return ret;\n}\n\nint main() {\n    while(cin>>N) {\n        HP.clear();\n        if(!N) break;\n        HP.resize(N);\n        rep(i,N) cin>>HP[i];\n        cin>>M;\n        rep(i,M) {\n            string s1,s2;\n            int mp,damage;\n            cin>>s1>>mp>>s2>>damage;\n            int t=0;\n            if(s2==\"All\") t=1;\n            spells[i]=Spell(mp,t,damage);\n        }\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\n#define MAX_DM 1000000\n\nint N, M, HP[111];\nvector< int > singleMP, allMP;\nvector< int > singleDM, allDM;\n\nint singleDP[MAX_DM], allDP[MAX_DM];\nconst int INF = (int)1e9;\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> HP[i];\n\t\n\tstring dumy, type;\n\tcin >> M;\n\t\n\tfor_(i,0,M) {\n\t\tint MP, DM;\n\t\tcin >> dumy >> MP >> type >> DM;\n\t\t\n\t\tDM = min(DM, 100000);\n\t\tif (DM == 0) continue;\n\t\t\n\t\tif (type == \"All\") {\n\t\t\tallMP.push_back(MP);\n\t\t\tallDM.push_back(DM);\n\t\t} else {\n\t\t\tsingleMP.push_back(MP);\n\t\t\tsingleDM.push_back(DM);\n\t\t}\n\t}\n\t\n\t// single DP\n\tint S = singleMP.size();\n\tfill(singleDP, singleDP + MAX_DM, INF);\n\tsingleDP[0] = 0;\n\t\n\tfor_(i,0,S) {\n\t\tint DM = singleDM[i], MP = singleMP[i];\n\t\t\n\t\tfor_(j,DM,MAX_DM) {\n\t\t\tsingleDP[j] = min(singleDP[j], singleDP[j - DM] + MP);\n\t\t}\n\t}\n\t\n\tvector< int > smp(MAX_DM, singleDP[MAX_DM-1]);\n\tfor_rev(d,MAX_DM-2,0) smp[d] = min(smp[d + 1], singleDP[d]);\n\t\n\t// all DP\n\tint A = allMP.size();\n\tfill(allDP, allDP + MAX_DM, INF);\n\tallDP[0] = 0;\n\t\n\tfor_(i,0,A) {\n\t\tint DM = allDM[i], MP = allMP[i];\n\t\t\n\t\tfor_(j,DM,MAX_DM) {\n\t\t\tallDP[j] = min(allDP[j], allDP[j - DM] + MP);\n\t\t}\n\t}\n\t\n\tvector< int > amp(MAX_DM, allDP[MAX_DM-1]);\n\tfor_rev(d,MAX_DM-2,0) amp[d] = min(amp[d + 1], allDP[d]);\n\t\n\tint ans = INF;\n\t\n\tfor_(d,0,MAX_DM) {\n\t\tint sum = amp[d];\n\t\tfor_(i,0,N) if (HP[i] - d > 0) sum += smp[HP[i] - d];\n\t\tans = min(ans, sum);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 100009\nusing namespace std;\n\nll dp1[10009];\nll dp2[10006];\nchar s[25];\n\nint num[105];\n\nint main()\n{\n    int n,m,x,y;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)break;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&num[i]);\n        sort(num,num+n);\n        memset(dp1,0,sizeof dp1);\n        memset(dp2,0,sizeof dp2);\n        scanf(\"%d\",&m);\n        bool flag=0;\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%s\",s);\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n            if(x==0&&y>0)flag=1;\n//        printf(\"%d %d\\n\",x,y);\n            if(s[0]=='S')\n            {\n                for(int j=x; j<=10000; j++)\n                    dp1[j]=max(dp1[j],dp1[j-x]+y);//single\n            }\n            else\n            {\n                for(int j=x; j<=10000; j++)\n                    dp2[j]=max(dp2[j],dp2[j-x]+y);//all\n            }\n        }\n        if(flag)\n        {\n            puts(\"0\");\n            continue;\n        }\n        ll ans=1ll<<60,sum;\n        for(int i=0; i<ans; i++)\n        {\n//            sum=lower_bound(dp2,dp2+10000,num[i])-dp2;\n//            ll tmp=sum;\n            sum=i;\n//        printf(\"%d\\n\",tmp);\n            for(int j=0; j<n; j++)\n            {\n                sum+=lower_bound(dp1,dp1+10000,num[j]-dp2[i])-dp1;\n            }\n            ans=min(ans,sum);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tif(singleMagics.size()>0){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint a=hps[j]-i;\n\t\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t\t}\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m;\nll h[111];\nll dpa[1000010],dpb[1000010];\nll na,nb;\nll ma[111],mb[111],da[111],db[111];\n\nint main(){\n\t//cin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    ll maxh=0;\n    rep(i,n){\n      cin>>h[i];\n      maxch(maxh,h[i]);\n    }\n    cin>>m;\n    na=0; nb=0;\n    rep(i,m){\n      string name,target;\n      ll mp,dmg;\n      cin>>name>>mp>>target>>dmg;\n      if(target==\"All\"){\n        ma[na]=mp; da[na]=dmg; na++;\n      }else{\n        mb[nb]=mp; db[nb]=dmg; nb++;\n      }\n    }\n    rep(i,1000010)dpa[i]=dpb[i]=INF;\n    dpa[0]=dpb[0]=0;\n    rep(j,1000001)rep(i,na){\n      if(dpa[j]==INF)continue;\n      if(j+da[i]<=1000000)minch(dpa[j+da[i]],dpa[j]+ma[i]);\n    }\n    for(ll j=1000000;j>=0;j--)minch(dpa[j],dpa[j+1]);\n    rep(j,1000001)rep(i,nb){\n      if(dpb[j]==INF)continue;\n      if(j+db[i]<=1000000)minch(dpb[j+db[i]],dpb[j]+mb[i]);\n    }\n    for(ll j=1000000;j>=0;j--)minch(dpb[j],dpb[j+1]);\n    ll res=INF;\n    rep(ah,maxh+1){\n      ll sum=0;\n      rep(i,n){\n        sum+=dpb[max(h[i]-ah,0LL)];\n      }\n      minch(res,sum+dpa[ah]);\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n \nint mon[120];\ntypedef struct magic{\n    int mp;\n    int t;\n    int d;\n}magic;\n \nmagic mag[120];\nconst int INF = 1000000000;\nint n, m, ans, prev;\n \nint dp[200001];\nint dp2[200001];\nvector<magic> all;\nvector<magic> single;\nvector<magic> crit;\n \nint main(void){\n    int i, j;\n    while(cin >> n, n){\n        ans = 0;\n        all.clear();\n        single.clear();\n        crit.clear();\n        for(i = 0; i < n; i++) cin >> mon[i];\n        cin >> m;\n        for(i = 0; i < m; i++){\n            string name;\n            cin >> name;\n            cin >> mag[i].mp;\n            if(cin >> name, name == \"All\") mag[i].t = 1;\n            if(cin >> mag[i].d, !mag[i].d) continue;\n            else if(mag[i].t){\n                if(mag[i].d >= 100000) crit.push_back(mag[i]);\n                else all.push_back(mag[i]);\n            }\n            else single.push_back(mag[i]);\n        }\n \n        int ans = INF;\n        for(i = 0; i < (int)crit.size(); i++) ans = min(ans, crit[i].mp);\n        for(i = 0; i <= 200000; i++) dp[i] = dp2[i] = INF;\n         \n        //dp(ALL_Magic)\n        dp[0] = 0;\n        for(i = 0; i < (int)all.size(); i++) dp[all[i].d] = all[i].mp;\n        for(i = 0; i < 200001; i++){\n            if(dp[i] == INF) continue;\n            for(j = i; j + i < 200001; j++){\n                if(dp[j] == INF) continue;\n                dp[j + i] = min(dp[i] + dp[j], dp[j + i]);\n            }\n        }\n \n        //dp(SINGLE_Magic)\n        for(i = 0; i < (int)single.size(); i++) dp2[single[i].d] = single[i].mp;\n        for(i = 0; i < 200001; i++){\n            if(dp2[i] == INF) continue;\n            for(j = i; j + i < 200001; j++){\n                if(dp2[j] == INF) continue;\n                dp2[j + i] = min(dp2[i] + dp2[j], dp2[j + i]);\n            }\n        }\n        for(i = 200000; dp2[i] == INF && i >= 0; i--);\n        for(; i >= 0; i--) if(dp2[i] == INF) dp2[i] = dp2[i + 1];\n \n \n        for(i = 200000; i >= 0; i--){\n            if(dp[i] == INF) continue;\n            prev = dp[i];\n            for(j = 0; j < n; j++){\n                if(mon[j] <= i) continue;\n                prev += dp2[mon[j] - i];\n            }\n            if(prev < 0) continue;\n            ans = min(prev, ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#define INF 1e8\nusing namespace std;\n\nint n,m;\nint hp[101];\nint dp[2][100001];\nint mp[101],t[101],d[101];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&hp[i]);\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str,st2;\n\t\t\tcin >> str >> mp[i] >> st2 >> d[i];\n\t\t\tif(st2==\"Single\")t[i]=0;\n\t\t\telse t[i]=1;\n\t\t}\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tdp[0][i]=dp[1][i]=INF;\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tdp[i][0]=0;\n\t\t\tfor(int j=0;j<=100000;j++){\n\t\t\t\tif(dp[i][j]<INF){\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(t[k]==i){\n\t\t\t\t\t\t\tdp[i][min(j+d[k],100000)]=min(dp[i][min(j+d[k],100000)],dp[i][j]+mp[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=99999;j>=0;j--){\n\t\t\t\tif(dp[i][j]<dp[i][j-1])dp[i][j-1]=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<=100000;i++){\n\t\t\tint cost=dp[1][i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(hp[j]>i)cost+=dp[0][hp[j]-i];\n\t\t\t}\n\t\t\tres=min(res,cost);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nconst int inf = 1e9;\n\nsigned main()\n{\n    int N;\n\n    while (cin >> N, N) {\n        vector<int> hp(N);\n\n        rep(i, N) {\n            cin >> hp[i];\n        }\n\n        int M;\n\n        cin >> M;\n\n        vector<pair<int,int>> S, A;\n\n        rep(i, M) {\n            string s;\n            int mp, dmg;\n            cin >> s >> mp >> s >> dmg;\n            if (dmg == 0) continue;\n            if (s == \"Single\") S.push_back(make_pair(mp, dmg));\n            else A.push_back(make_pair(mp, dmg));\n        }\n\n        vector<int> dp1(100010, inf), dp2(100010, inf);\n        dp1[0] = dp2[0] = 0;\n\n        for (int i = 0; i < S.size(); ++i) {\n            int mp = S[i].first, dmg = S[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0) {\n                    dp1[j] = min(dp1[j], dp1[j - dmg] + mp);\n                } else {\n                    dp1[j] = min(dp1[j], mp);\n                }\n            }\n        }\n\n        for (int i = 100001; i >= 1; --i) dp1[i - 1] = min(dp1[i - 1], dp1[i]);\n\n        for (int i = 0; i < A.size(); ++i) {\n            int mp = A[i].first, dmg = A[i].second;\n            for (int j = 0; j <= 100000; ++j) {\n                if (j - dmg >= 0) {\n                    dp2[j] = min(dp2[j], dp2[j - dmg] + mp);\n                } else {\n                    dp2[j] = min(dp2[j], mp);\n                }\n            }\n        }\n\n        for (int i = 100001; i >= 1; --i) dp2[i - 1] = min(dp2[i - 1], dp2[i]);\n\n        int mi = inf;\n\n        dp1[0] = dp2[0] = 0;\n\n        for (int a = 0; a <= 100000; ++a) {\n            int sum = dp2[a];\n\n            for (int i = 0; i < N; ++i) {\n                if (hp[i] - a >= 0) {\n                    sum += dp1[hp[i] - a];\n                }\n            }\n\n            mi = min(mi, sum);\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\n// struct P {\n//   string name;\n//   int MP;\n//   string target;\n//   int damage;\n//   P() {}\n//   P(string n, int m, string t, int d) : name(n), MP(m), target(t), damage(d) {}\n// };\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int N;\n  while (cin >> N, N) {\n    vector<int> HP(N);\n    for (int i = 0; i < N; i++) {\n      cin >> HP[i];\n    }\n\n    int M;\n    cin >> M;\n\n    vector<int> MP(M), target(M), damage(M);\n    for (int i = 0; i < M; i++) {\n      string na, ta;\n      cin >> na >> MP[i] >> ta >> damage[i];\n      target[i] = ta == \"All\";\n    }\n\n    vector<int> dp(2000010, 1 << 20), dp2(2000010, 1 << 20);\n    dp[0] = 0, dp2[0] = 0;\n    for (int i = 0; i <= 2000000; i++) {\n      for (int j = 0; j < M; j++) {\n        if (i + damage[j] <= 2000000) {\n          if (target[j]) dp[i + damage[j]] = min(dp[i + damage[j]], dp[i] + MP[j]);\n          else dp2[i + damage[j]] = min(dp2[i + damage[j]], dp2[i] + MP[j]);\n        }\n      }\n    }\n    for (int i = 2000000; i> 0; --i) {\n      dp[i-1] = min(dp[i], dp[i-1]);\n      dp2[i-1] = min(dp2[i], dp2[i-1]);\n    }\n\n    int ans = 1 << 20;\n    for (int i = 0; i <= 200000; i++) {\n      int sum = dp[i];\n      for (int j = 0; j < N; j++) {\n        int rem = max(0, HP[j] - i);\n        if (rem < 0) continue;\n        sum += dp2[rem];\n      }\n      ans = min(ans, sum);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"input.txt\");\n#define cin ifs\n\nstruct Magic{\n\tstring name;\n\tint mp;\n\tbool isAll;\n\tint dmg;\n};\n\nint n;\nint hps[101];\nint m;\nMagic magics[101];\nconst int INF=1000000000;\n\n// SÌÉ é_[Wð^¦éÌÉKvÈÅ¬ÌMP(¶ÝµÈ¯êÎ-1)\nint dp[2][200001];\n// PÌÉ é_[Wð^¦éÌÉKvÈÅ¬MP(¿å¤ÇÌ_[WÅÈ­Äàæ¢\nint dp2[2][200001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tvector<Magic> allMagics;\n\t\tvector<Magic> singleMagics;\n\t\tvector<Magic> crit;\n\t\tfor(int i=0;i<n;i++)cin>>hps[i];\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>magics[i].name>>magics[i].mp;\n\t\t\tstring tgt;\n\t\t\tcin>>tgt;\n\t\t\tif(tgt==\"All\")magics[i].isAll=true;\n\t\t\telse magics[i].isAll=false;\n\t\t\tcin>>magics[i].dmg;\n\t\t\tif(magics[i].dmg==0)continue;\n\t\t\telse if(magics[i].isAll){\n\t\t\t\t// 100000ÈãÌêAêKE\n\t\t\t\tif(magics[i].dmg>=100000)crit.push_back(magics[i]);\n\t\t\t\telse allMagics.push_back(magics[i]);\n\t\t\t}\n\t\t\telse singleMagics.push_back(magics[i]);\n\t\t}\n\t\tint minMP=INF;\n\t\t// êKE\n\t\tfor(int i=0;i<(int)crit.size();i++)minMP=min(minMP,crit[i].mp);\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=200000;j++)dp[i][j]=dp2[i][j]=INF;\n\t\tdp[(allMagics.size())%2][0]=0;\n\t\tdp2[(singleMagics.size())%2][0]=0;\n\t\tfor(int i=allMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp[cur][dmg]);\n\t\t\t\t// ¿å¤Ç0ÉÈéKvª é\n\t\t\t\tif(dmg-allMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp[nxt][dmg-allMagics[pos].dmg]+allMagics[pos].mp);\n\t\t\t\tdp[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\tfor(int i=singleMagics.size()-1;i>=0;i--){\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tint dmg=j;\n\t\t\t\tint pos=i;\n\t\t\t\tint res=INF;\n\t\t\t\tint cur=(i+1)%2;\n\t\t\t\tint nxt=i%2;\n\t\t\t\tres=min(res,dp2[cur][dmg]);\n\t\t\t\tif(dmg-singleMagics[pos].dmg>=0)\n\t\t\t\t\tres=min(res,dp2[nxt][dmg-singleMagics[pos].dmg]+singleMagics[pos].mp);\n\t\t\t\t// KvÈÌÍ¡ñÌªÌÝ\n\t\t\t\telse res=min(res,singleMagics[pos].mp);\n\t\t\t\tif(i==0&&j==52261){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tdp2[nxt][dmg]=res;\n\t\t\t}\n\t\t}\n\t\t// SÌÉ^¦é_[WÊðvZ\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[0][i]==INF)continue;\n\t\t\tint cnt=0;\n\t\t\tif(singleMagics.size()>0){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint a=hps[j]-i;\n\t\t\t\t\tif(a>0)cnt+=dp2[0][a];\n\t\t\t\t}\n\t\t\t}\n\t\t\tminMP=min(minMP,cnt+dp[0][i]);\n\t\t}\n\t\tcout<<minMP<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int MAX = 100000;\nconst int INF = INT_MAX / 2;\n\nvoid solve(const vector<pair<int, int> >& attack, vector<int>& cost)\n{\n    cost.assign(MAX+1, INF);\n    cost[0] = 0;\n\n    int n = attack.size();\n    for(int i=0; i<MAX; ++i){\n        for(int j=0; j<n; ++j){\n            int k = i + attack[j].second;\n            if(k > MAX)\n                k = MAX;\n            cost[k] = min(cost[k], cost[i] + attack[j].first);\n        }\n    }\n\n    for(int i=MAX; i>0; --i)\n        cost[i-1] = min(cost[i-1], cost[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> hp(n);\n        for(int i=0; i<n; ++i)\n            cin >> hp[i];\n\n        int m;\n        cin >> m;\n        vector<pair<int, int> > a; // 単体攻撃\n        vector<pair<int, int> > b; // 全体攻撃\n        for(int i=0; i<m; ++i){\n            string s, target;\n            int mp, damage;\n            cin >> s >> mp >> target >> damage;\n            if(target == \"Single\")\n                a.push_back(make_pair(mp, damage));\n            else\n                b.push_back(make_pair(mp, damage));\n        }\n\n        vector<int> cost1, cost2;\n        solve(a, cost1);\n        solve(b, cost2);\n\n        long long ret = INF;\n        for(int i=0; i<=MAX; ++i){\n            long long tmp = cost2[i];\n            for(int j=0; j<n; ++j)\n                tmp += cost1[max(0, hp[j] - i)];\n            ret = min(ret, tmp);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\nint N,M,HP[105],A,SDP[100005],ADP[100005],res,tmp;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tmemset(ADP,0x7f,sizeof(ADP));\n\t\tSDP[0]=ADP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tSDP[np]=min(SDP[np],SDP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tfor(int i=100000;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\n\t\tfor(int i=M-A;i<M;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=100000;j++)\n\t\t\t{\n\t\t\t\tint np=j+SP[i].Dam;\n\t\t\t\tif(np>100000)np=100000;\n\t\t\t\tADP[np]=min(ADP[np],ADP[j]+SP[i].MP);\n\t\t\t}\n\t\t}\n\t\tif(A==M)\n\t\t{\n\t\t\tint mh=0;\n\t\t\tfor(int i=0;i<N;i++)mh=max(mh,HP[i]);\n\t\t\tfor(int i=mh;i<=100000;i++)\n\t\t\t\tres=min(res,ADP[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<=100000;i++)\n\t\t\t{\n\t\t\t\tif(ADP[i]==2139062143)continue;\n\t\t\t\ttmp=ADP[i];\n\t\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\t{\n\t\t\t\t\tif(HP[k]-i>=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint np=HP[k]-i;\n\t\t\t\t\t\tif(np<0)np=0;\n\t\t\t\t\t\ttmp+=SDP[np];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres=min(res,tmp);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Magic{ int cost,damage; };\nvector<Magic> s,a;\n\nconst int N=200000;\n\nconst int INF=123456789;\nint dp[2][N+1];\nvoid calc(const vector<Magic> &v, int dst[])\n{\n    int V=v.size();\n\n    fill(dp[0],dp[2],INF);\n    dp[0][0]=0;\n    rep(i,V)rep(j,N+2)\n    {\n        if(j-v[i].damage<0) dp[(i+1)&1][j]=dp[i&1][j];\n        else dp[(i+1)&1][j]=min(dp[i&1][j],dp[(i+1)&1][j-v[i].damage]+v[i].cost);\n    }\n\n    rep(i,N+1) dst[i]=dp[V&1][i];\n\n    int min_cost=INF;\n    for(int i=N; i>=0; --i)\n    {\n        min_cost=min(min_cost,dst[i]);\n        dst[i]=min_cost;\n    }\n}\n\nint main()\n{\n    int ds[N+1],da[N+1];\n\n    int n;\n    while(cin >>n,n)\n    {\n        s.clear();\n        a.clear();\n\n        vector<int> hp(n);\n        rep(i,n) cin >>hp[i];\n\n        int m;\n        cin >>m;\n        rep(i,m)\n        {\n            string M,sa;\n            int mp,d;\n            cin >>M >>mp >>sa >>d;\n\n            if(d==0) continue;\n            if(d>=N) d=N;\n\n            if(sa==\"All\") a.pb(Magic{mp,d});\n            else s.pb(Magic{mp,d});\n        }\n\n        calc(s,ds);\n        calc(a,da);\n\n        int ans=INF;\n\n        rep(i,100001)\n        {\n            // printf(\"da[%d]=%d\\n\", i,da[i]);\n            int tmp=da[i];\n            rep(j,n)\n            {\n                int rem=hp[j]-i;\n                if(rem<=0) continue;\n                // printf(\"ds %d = %d\\n\", j,ds[rem]);\n                tmp+=ds[rem];\n            }\n\n            // if(ans>tmp) printf(\"update: i=%d, tmp=%d\\n\", i,tmp);\n            ans=min(ans,tmp);\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#define INF (1<<21)\nusing namespace std;\n\nclass Enemy{\npublic:\n  int hp[100];\n  int mp,a;\n  bool operator < (const Enemy &p)const{\n    return mp > p.mp;\n  }\n  Enemy (int mp = 0,int a = 0): mp(mp),a(a){}\n};\n\nclass Actor{\npublic:\n  int mp,damage;\n  string name;\n  bool all;\n};\n\nint main(){\n  int i,j,k,n,m,ans;\n  string str;\n  while(1){\n    Enemy u,v;\n    Actor p[100];\n    priority_queue<Enemy> Q;\n    cin >> n;\n    if(n == 0) break;\n    for(i=0;i<n;i++){\n      cin >> u.hp[i];\n    }\n    cin >> m;\n    for(i=0;i<m;i++){\n      cin >> p[i].name >> p[i].mp >> str >> p[i].damage;\n      if(str == \"Single\") p[i].all = false;\n      else p[i].all = true;\n    }\n\n    ans = INF;\n    Q.push(u);\n    bool f = false;\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      if(u.a >= n){\n\tans = min(ans,u.mp);\n\tbreak;\n      }\n\n      for(i=0;i<m;i++){\n\tif(p[i].damage <= 0) continue;\n\n\tv = u;\n\tv.mp += p[i].mp;\n\tif(p[i].all){\n\t  for(j=0;j<n;j++){\n\t    if(v.hp[j] > 0 && v.hp[j] - p[i].damage <= 0) v.a++;\n\t    v.hp[j] -= min(v.hp[j],p[i].damage);\n\t  }\n\t  if(v.a >= n){\n\t    ans = min(ans,v.mp);\n\t    f = true;\n\t  }\n\t  else Q.push(v);\n\t}\n\n\telse{\n\t  for(j=0;j<n;j++){\n\t    v = u;\n\t    v.mp += p[i].mp;\n\t    if(v.hp[j] > 0 && v.hp[j] - p[i].damage <= 0) v.a++;\n\t    v.hp[j] -= min(v.hp[j],p[i].damage);\n\t    if(v.a >= n){\n\t      ans = min(ans,v.mp);\n\t      f = true;\n\t    }\n\t    else Q.push(v);\n\t  }\n\t}\n      }\n      if(f) break;\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    int h[n];\n    for(int i=0; i<n; i++) cin >> h[i];\n    cin >> m;\n    vector<P> a,b;\n    string name,t;\n    for(int i=0; i<m; i++) {\n      P c;\n      cin >> name >> c.first >> t >> c.second;\n      if(t==\"All\") a.push_back(c);\n      else b.push_back(c);\n    }\n    sort(a.begin(),a.end());\n    sort(b.begin(),b.end());\n    P da[100001],db[100001];\n    for(int i=0; i<100001; i++) da[i]=db[i]=P(1<<29,i);\n    da[0]=db[0]=P(0,0);\n    for(int i=0; i<a.size(); i++) {\n      for(int j=0; j<100001; j++) da[min(100000,j+a[i].second)].first=min(da[min(100000,j+a[i].second)].first,da[j].first+a[i].first);\n    }\n    for(int i=0; i<b.size(); i++) {\n      for(int j=0; j<100001; j++) db[min(100000,j+b[i].second)].first=min(db[min(100000,j+b[i].second)].first,db[j].first+b[i].first);\n    }\n    for(int i=99999; i>=0; i--) {\n      da[i]=min(da[i],da[i+1]);\n      db[i]=min(db[i],db[i+1]);\n    }\n    int ans=1<<29;\n    for(int i=0; i<=100000; i++) {\n      int d=da[i].first;\n      for(int j=0; j<n; j++) {\n\tint x=max(0,h[j]-da[i].second);\n\td+=db[x].first;\n      }\n      ans=min(ans,d);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint dp[2][100010];\n\nint main(){\n  int n,m,hp[101];\n\n  while(cin>>n,n){\n  for(int i=0;i<n;i++) cin>>hp[i];\n\n  vector <P> mg[2];  \n  cin>>m;\n  for(int i=0,cost,dam;i<m;i++){\n    string name,type;\n    cin>>name>>cost>>type>>dam;\n    mg[type==\"All\"].push_back(P(dam,cost));\n  }\n\n\n  for(int i=0;i<2;i++)for(int j=1;j<100010;j++)dp[i][j]=INF;\n \n  for(int k=0;k<2;k++)\n    for(int i=0;i<mg[k].size();i++)\n      for(int j=mg[k][i].f;j<100000+mg[k][i].f;j++)\n\tdp[k][min(100000,j)]=min(dp[k][min(100000,j)],dp[k][min(100000,j-mg[k][i].f)]+mg[k][i].s);\n\t\t\n  \n  for(int i=0;i<2;i++)\n    for(int j=100000;j>=0;j--)\n      dp[i][j]=min(dp[i][j],dp[i][j+1]);\n\nlong long ans=INF;\n  for(int i=0;i<=100000;i++){\n    long long cost=dp[1][i];\n    for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n    ans=min(ans,cost);\n }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint multi[100010], single[100010], hp[110];\n\n\nint main(){\n\tint N;\n\twhile (cin >> N && N){\n\t\tfor (int i = 0; i < 100010; i++){\n\t\t\tmulti[i] = 1e9; single[i] = 1e9;\n\t\t}\n\t\tmulti[0] = 0; single[0] = 0;\n\t\tfor (int i = 0; i < N; i++)cin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring command;\n\t\t\tint dmp;\n\t\t\tcin >> name >> mp >> command >> dmp;\n\t\t\tif (command == \"Single\"){\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tsingle[s] = min(single[s], single[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (int j = 0; j <= 100000; j++){\n\t\t\t\t\tint s = min(100000, j + dmp);\n\t\t\t\t\tmulti[s] = min(multi[s], multi[j] + mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 100000; i >= 0; i--){\n\t\t\tmulti[i] = min(multi[i], multi[i + 1]);\n\t\t\tsingle[i] = min(single[i], single[i + 1]);\n\t\t}\n\t\tlong long ans = 1e9;\n\t\tfor (int i = 0; i <= 100000; i++){\n\t\t\tlong long u = multi[i];\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tint v = max(0, hp[j] - i);\n\t\t\t\tu += single[v];\n\t\t\t}\n\t\t\tans = min(u, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n         return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\n#define MAX_DM 2000000\n\nint N, M, HP[111];\nvector< int > singleMP, allMP;\nvector< int > singleDM, allDM;\n\nint singleDP[MAX_DM], allDP[MAX_DM];\nconst int INF = (int)1e9;\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> HP[i];\n\t\n\tstring dumy, type;\n\tcin >> M;\n\t\n\tfor_(i,0,M) {\n\t\tint MP, DM;\n\t\tcin >> dumy >> MP >> type >> DM;\n\t\t\n\t\tif (type == \"All\") {\n\t\t\tallMP.push_back(MP);\n\t\t\tallDM.push_back(DM);\n\t\t} else {\n\t\t\tsingleMP.push_back(MP);\n\t\t\tsingleDM.push_back(DM);\n\t\t}\n\t}\n\t\n\t// single DP\n\tint S = singleMP.size();\n\tfill(singleDP, singleDP + MAX_DM, INF);\n\tsingleDP[0] = 0;\n\t\n\tfor_(i,0,S) {\n\t\tint DM = singleDM[i], MP = singleMP[i];\n\t\t\n\t\tfor_(j,DM,MAX_DM) {\n\t\t\tsingleDP[j] = min(singleDP[j], singleDP[j - DM] + MP);\n\t\t}\n\t}\n\t\n\tvector< int > smp(MAX_DM, singleDP[MAX_DM-1]);\n\tfor_rev(d,MAX_DM-2,0) smp[d] = min(smp[d + 1], singleDP[d]);\n\t\n\t// all DP\n\tint A = allMP.size();\n\tfill(allDP, allDP + MAX_DM, INF);\n\tallDP[0] = 0;\n\t\n\tfor_(i,0,A) {\n\t\tint DM = allDM[i], MP = allMP[i];\n\t\t\n\t\tfor_(j,DM,MAX_DM) {\n\t\t\tallDP[j] = min(allDP[j], allDP[j - DM] + MP);\n\t\t}\n\t}\n\t\n\tvector< int > amp(MAX_DM, allDP[MAX_DM-1]);\n\tfor_rev(d,MAX_DM-2,0) amp[d] = min(amp[d + 1], allDP[d]);\n\t\n\tint ans = INF;\n\t\n\tfor_(d,0,MAX_DM) {\n\t\tint sum = amp[d];\n\t\tfor_(i,0,N) if (HP[i] - d > 0) sum += smp[HP[i] - d];\n\t\tans = min(ans, sum);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll dp[10][100100];\nll n, m;\nll hp[110];\nvector<ll> mp[2];\nvector<ll> d[2];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tmp[0].clear();\n\t\tmp[1].clear();\n\t\td[0].clear();\n\t\td[1].clear();\n\t\trep(i, n)cin >> hp[i];\n\t\tcin >> m;\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tll mpp, dd;\n\t\t\tcin >> s >> mpp >> s >> dd;\n\t\t\tif (s == \"All\") {\n\t\t\t\tmp[0].push_back(mpp);\n\t\t\t\td[0].push_back(dd);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[1].push_back(mpp);\n\t\t\t\td[1].push_back(dd);\n\t\t\t}\n\t\t}\n\t\trep(i, 100100) {\n\t\t\tdp[0][i] = INF;\n\t\t\tdp[1][i] = INF;\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp[1][0] = 0;\n\t\trep(i, mp[0].size()) {\n\t\t\trep(j, 100100) {\n\t\t\t\tif (j + d[0][i] < 100100) {\n\t\t\t\t\tdp[0][j + d[0][i]] = min(dp[0][j + d[0][i]], dp[0][j] + mp[0][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, mp[1].size()) {\n\t\t\trep(j, 100100) {\n\t\t\t\tif (j + d[1][i] < 100100) {\n\t\t\t\t\tdp[1][j + d[1][i]] = min(dp[1][j + d[1][i]], dp[1][j] + mp[1][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 2) {\n\t\t\trep(j, 100100 - 1) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t\t//rep(i, 2) {\n\t\t//\trep(j, 50) {\n\t\t//\t\tif (dp[i][j] == INF)cout << -1 << \" \";\n\t\t//\t\telse cout << dp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tll ans = INF;\n\t\trep(i, 100100) {\n\t\t\tll sum = dp[0][i];\n\t\t\trep(j, n) {\n\t\t\t\tif (hp[j] - i >= 0)sum += dp[1][hp[j] - i];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define NMAX 100\n#define MAX 1000000\n#define INFTY (1<<21)\n\n\nvoid setTable(int maxv, pair<int, int> v[NMAX], int vs,  int T[MAX+1]){\n    rep(i, maxv+1) T[i] = INFTY;\n    T[0] = 0;\n    rep(i, vs){\n\tfor ( int j = 1; j <= v[i].second; j++ ) T[j] = min(T[j], v[i].first);\n\tfor ( int j = v[i].second+1; j <= maxv; j++ ){\n\t    T[j] = min(T[j], T[j-v[i].second] + v[i].first);\n\t}\n    }\n}\n\nmain(){\n    int n, M[NMAX], TS[MAX+1], TA[MAX+1], ss, as;\n    pair<int, int> S[NMAX], A[NMAX];\n\n    string name, type;\n    int maxh = 0;\n    while( cin >> n && n ){\n\tss = as = 0;\n\trep(i, n) { cin >> M[i]; maxh = max(maxh, M[i]); }\n\tint m, cost, damage; \n\tcin >> m;\n\trep(i, m){\n\t    cin >> name >> cost >> type >> damage;\n\t    if ( type == \"Single\") S[ss++] = make_pair(cost, damage);\n\t    if ( type == \"All\") A[as++] = make_pair(cost, damage);\n\t}\n\tsetTable(maxh, S, ss, TS);\n\tsetTable(maxh, A, as, TA);\n\t\n\tint ans = INFTY;\n\tfor( int a = 0; a <= maxh; a++ ){\n\t    int cost = TA[a];\n\t    for ( int i = 0; i < n; i++ ){\n\t\tint rem = M[i] - a;\n\t\tif ( rem <= 0 ) continue;\n\t\tcost += TS[rem];\n\t    }\n\t    ans = min(ans, cost);\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll MAX = 1000000, INF = 1LL << 60;\n\nvector<ll> solve(vector<pll> &data) {\n  ll n = data.size();\n  vector<ll> cost(n), damage(n);\n  REP(i, 0, n) cost[i] = data[i].first;\n  REP(i, 0, n) damage[i] = data[i].second;\n\n  vector<ll> dp(MAX + 1, INF);\n  dp[0] = 0;\n  REP(k, 0, n) REP(i, 0, MAX) {\n    if(i + damage[k] <= MAX) {\n      dp[i + damage[k]] = min(dp[i + damage[k]], dp[i] + cost[k]);\n    }\n  }\n  for(ll i = MAX - 1; i >= 0; i--) dp[i] = min(dp[i], dp[i + 1]);\n  return dp;\n}\n\nint main(void) {\n  ll N, M;\n  while(cin >> N, N != 0) {\n    vector<ll> H(N);\n    REP(i, 0, N) cin >> H[i];\n    cin >> M;\n    vector<pll> S, A;\n    REP(i, 0, M) {\n      string name, target;\n      ll cost, damage;\n      cin >> name >> cost >> target >> damage;\n      if(target == \"Single\") S.push_back(pll(cost, damage));\n      if(target == \"All\") A.push_back(pll(cost, damage));\n    }\n\n    vector<ll> scost = solve(S);\n    vector<ll> acost = solve(A);\n\n    ll ans = INF;\n    REP(i, 0, MAX + 1) {\n      ll d = acost[i];\n      REP(j, 0, N) d += scost[max(H[j] - i, 0LL)];\n      ans = min(ans, d);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    int h[100];\n    for(int i=0;i<n;i++){\n      cin>>h[i];\n    }\n    int m;\n    cin>>m;\n    vector<pair<int,int> > s[2];\n    while(m--){\n      int m,d;\n      char t[7];\n      cin.ignore(16,' ')>>m>>t>>d;\n      s[t[0]=='S'].push_back(make_pair(m,d));\n    }\n    static int as[2][100001];\n    fill(as[0],as[2],0);\n    for(int i=0;i<2;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k+s[i][j].first<=100000;k++){\n\t  as[i][k+s[i][j].first]=max(as[i][k+s[i][j].first],as[i][k]+s[i][j].second);\n\t}\n      }\n    }\n    int mp=1<<30;\n    for(int i=0;i<mp;i++){\n      int cm=i;\n      for(int j=0;j<n;j++){\n\tcm+=lower_bound(as[1],as[2],h[j]-as[0][i])-as[1];\n      }\n      mp=min(mp,cm);\n    }\n    cout<<mp<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 1e+9;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<int> hp(n);\n    REP(i,n)cin>>hp[i];\n    int m;\n    cin>>m;\n    vector<tuple<int,int>> sg;\n    vector<tuple<int,int>> al;\n    REP(i,m){\n      string name,tg;\n      int mp,dm;\n      cin>>name>>mp>>tg>>dm;\n      if(tg==\"Single\")\n        sg.emplace_back(mp,dm);\n      else\n        al.emplace_back(mp,dm);\n    }\n    int a=sg.size();\n    int b=al.size();\n    vector<vector<int>> dps(a+1, vector<int>(100001, INF));\n    vector<vector<int>> dpa(b+1, vector<int>(100001, INF));\n    dps[0][0] = 0;\n    dpa[0][0] = 0;\n    REP(i,a) {\n      REP(j,100001) {\n        dps[i+1][j] = dps[i][j];\n        if (j >= get<1>(sg[i]))\n          dps[i+1][j] = min(dps[i+1][j], dps[i+1][j-get<1>(sg[i])] + get<0>(sg[i]));\n        else\n          dps[i+1][j] = min(dps[i+1][j], get<0>(sg[i]));\n      }\n    }\n    REP(i,b) {\n      REP(j,100001) {\n        dpa[i+1][j] = dpa[i][j];\n        if (j >= get<1>(al[i]))\n          dpa[i+1][j] = min(dpa[i+1][j], dpa[i+1][j-get<1>(al[i])] + get<0>(al[i]));\n        else\n          dpa[i+1][j] = min(dpa[i+1][j], get<0>(al[i]));\n      }\n    }\n    vector<int> costs(100001);\n    REP(i,n){\n      REP(j,hp[i]) {\n        costs[j] += dps[a][hp[i] - j];\n      }\n    }\n    int mcos = INF;\n    REP(i,100001) mcos = min(mcos, dpa[b][i] + costs[i]);\n    cout << mcos << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str[0]=='A')_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;\n\t\t\tsingle[i]=9999999;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\n\t\tr=9999999;\n\t\tfor(i=0;i<=h;i++){\n\t\t\ts=all[i];\n\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\tif(r>s)r=s;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1000005;\nconst ll INF=1LL<<50;\nll dp[2][MAX],dp2[2][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        vector<int> A(N);\n        for(int i=0;i<N;i++) cin>>A[i];\n        for(int i=0;i<MAX;i++){\n            dp[0][i]=dp[1][i]=INF;\n            dp2[0][i]=dp2[1][i]=INF;\n        }\n        dp[0][0]=0;\n        dp2[0][0]=0;\n        \n        int M;cin>>M;\n        vector<pair<int,int>> B,C;\n        for(int i=0;i<M;i++){\n            string S,T;\n            int a,b;cin>>S>>a>>T>>b;\n            if(T[0]=='S'){\n                B.push_back({a,b});\n            }else{\n                C.push_back({a,b});\n            }\n        }\n        \n        for(int i=1;i<=B.size();i++){\n            for(int j=0;j<MAX;j++){\n                dp[i&1][j]=min(dp[!(i&1)][j],dp[i&1][j]);\n                if(j-B[i-1].second>=0) dp[i&1][j]=min(dp[i&1][j],dp[i&1][j-B[i-1].second]+B[i-1].first);\n            }\n            \n            for(int j=1;j<MAX;j++){\n                dp[!(i&1)][j]=INF;\n            }\n        }\n        \n        for(int i=1;i<=C.size();i++){\n            for(int j=0;j<MAX;j++){\n                dp2[i&1][j]=min(dp2[!(i&1)][j],dp2[i&1][j]);\n                if(j-C[i-1].second>=0) dp2[i&1][j]=min(dp2[i&1][j],dp2[i&1][j-C[i-1].second]+C[i-1].first);\n            }\n            \n            for(int j=1;j<MAX;j++){\n                dp2[!(i&1)][j]=INF;\n            }\n        }\n        \n        for(int j=MAX-2;j>=0;j--){\n            dp[int(B.size())&1][j]=min(dp[int(B.size())&1][j],dp[int(B.size())&1][j+1]);\n            dp2[int(C.size())&1][j]=min(dp2[int(C.size())&1][j],dp2[int(C.size())&1][j+1]);\n        }\n        \n        ll ans=INF;\n        \n        for(int j=0;j<MAX;j++){\n            ll sum=dp2[int(C.size())&1][j];\n            for(int i=0;i<N;i++){\n                if(A[i]>j){\n                    sum+=dp[int(B.size())&1][A[i]-j];\n                }\n            }\n            ans=min(ans,sum);\n            \n            //if(j<=1000) cout<<j<<\" \"<<sum<<endl;\n        }\n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int HSIZE=100001;\nconst int INF=1e9;\nusing ll = long long;\nint solve(int n){\n    vector<int> h(n);\n    for(int i=0;i<n;i++) cin>>h[i];\n    int m;\n    cin>>m;\n    vector<int> smp,sdmg;\n    vector<int> amp,admg;\n    bool isok=false;\n    for(int i=0;i<m;i++){\n        string buf,tar;\n        int mp,dmg;\n        cin>>buf>>mp>>tar>>dmg;\n        if(mp==0){\n            if(dmg==0) continue;\n            isok=true;\n        }\n        else if(tar==\"Single\"){\n            smp.push_back(mp);\n            sdmg.push_back(dmg);\n        }\n        else{\n            amp.push_back(mp);\n            admg.push_back(dmg);\n        }\n        \n    }\n    if(isok) return 0;\n    int N=sdmg.size();\n    vector<int> sdp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+sdmg[i]<HSIZE) tmp[to][j+sdmg[i]]=min(tmp[to][j+sdmg[i]],tmp[to][j]+smp[i]);\n            }\n        }\n        sdp=tmp[N&1];\n    }\n    N=admg.size();\n    vector<int> adp;\n    {\n        vector<vector<int>> tmp(2,vector<int>(HSIZE,INF));\n        tmp[0][0]=0;\n        for(int i=0;i<N;i++){\n            int fr=i&1;\n            int to=(i+1)&1;\n            fill(tmp[to].begin(),tmp[to].end(),INF);\n            for(int j=0;j<HSIZE;j++){\n                tmp[to][j]=min(tmp[to][j],tmp[fr][j]);\n                if(j+admg[i]<HSIZE) tmp[to][j+admg[i]]=min(tmp[to][j+admg[i]],tmp[to][j]+amp[i]);\n            }\n        }\n        adp=tmp[N&1];\n    }\n    for(int i=HSIZE-2;i>=0;i--){\n        sdp[i]=min(sdp[i],sdp[i+1]);\n    }\n    ll res=ll(1e15);\n    for(int i=0;i<HSIZE;i++){\n        ll sc=adp[i];\n        for(int j=0;j<n;j++){\n            sc=min(ll(1e15),sdp[max(h[j]-i,0)]+sc);\n        }\n        res=min(res,sc);\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\n#define D 100001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,hp[N],m,mp[N],damage[N],ans,minc;\nint dpAll[D],dpSin[D];\nstring name,target[N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)cin>>hp[i];\n    cin>>m;\n    for(int i=0;i<m;i++)\n      cin>>name>>mp[i]>>target[i]>>damage[i];\n    for(int i=0;i<D;i++)dpAll[i]=dpSin[i]=INF;\n    dpAll[0]=dpSin[0]=0;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"All\")continue;\n\tif(i+damage[j]<D)\n\t  dpAll[i+damage[j]]=min(dpAll[i+damage[j]],dpAll[i]+mp[j]);\n\telse\n\t  dpAll[D-1]=min(dpAll[D-1],dpAll[i]+mp[j]);\n      }\n    }\n    for(int i=0;i<D;i++){\n      if(dpSin[i]==INF)continue;\n      for(int j=0;j<m;j++){\n\tif(target[j]!=\"Single\")continue;\n\tif(i+damage[j]<D)\n\t  dpSin[i+damage[j]]=min(dpSin[i+damage[j]],dpSin[i]+mp[j]);\n\telse\n\t  dpSin[D-1]=min(dpSin[D-1],dpSin[i]+mp[j]);\n      }\n    }\n    minc=INF;\n    for(int i=D-1;i>=0;i--){\n      minc=min(minc,dpSin[i]);\n      dpSin[i]=minc;\n    }\n    ans=INF;\n    for(int i=0;i<D;i++){\n      if(dpAll[i]==INF)continue;\n      int cnt=dpAll[i];\n      for(int j=0;j<m;j++){\n\tint k=hp[j]-i;\n\tif(k<0)k=0;\n\tcnt+=dpSin[k];\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\nusing namespace std;\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\nvoid solve(int n, int hp[N], int m, magic mag[M], int now, int limit, int &ans){\n\tbool bSolved=true;\n\t/*for(int i=0;i<n;++i){\n\t\tcout<<hp[i]<<' ';\n\t}\n\tcout<<endl;*/\n\tfor(int i=0;i<n;++i){\n\t\tif(hp[i]>0){\n\t\t\tbSolved=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( bSolved ){\n\t\tans=min(ans,now);\n\t\treturn ;\n\t}\n\t\n\n\tfor(int i=0;i<m;++i){\n\t\tif( now+mag[i].mp>limit||now+mag[i].mp>=ans )\n\t\t\tcontinue;\n\t\tint nx_hp[N];\n\t\tfor(int j=0;j<n;++j){\n\t\t\tnx_hp[j]=hp[j];\n\t\t}\n\t\tif(mag[i].type==ALL){\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t}\n\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,limit,ans );\n\t\t}else{\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif(nx_hp[j]>0){\n\t\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,limit,ans );\n\t\t\t\t\tnx_hp[j]+=mag[i].damage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint ans=INFTY;\n\t\tint n,m;\n\t\tint minmp=INFTY;\n\t\tint magsz=0;\n\t\tint hp[N]={0,};\n\t\tmagic mag[M];\n\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar type[17]=\"\";\n\t\t\tscanf(\"%*s%d%s%d\", &mag[magsz].mp, type, &mag[magsz].damage);\n\t\t\tif(strcmp(type,\"All\")==0)mag[magsz].type=ALL;\n\t\t\telse mag[magsz].type=SINGLE;\n\t\t\tif(mag[magsz].damage>0)\n\t\t\t\t++magsz;\n\t\t\telse{\n\t\t\t\tminmp=min(minmp,mag[magsz].mp);\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<magsz;++i){\n\t\t\tcout << \"MP: \" << mag[i].mp <<\" TYPE: \" << mag[i].type << \" DAMAGE: \" << mag[i].damage << endl;\n\t\t}*/\n\t\tsort(mag,mag+magsz);\n\t\tfor(int i=0;i<INFTY;i+=1000){\n\t\t\tsolve(n,hp,magsz,mag,0,i,ans);\n\t\t\tif(ans<INFTY)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n\n\n#define N_MAX 100\n#define M_MAX 100\n#define HP_MAX 100000\nusing namespace std;\n\nint N,M;\nint HP[N_MAX];\nlong long int dp[2][HP_MAX+1];\nlong long int A_dp[HP_MAX+1];//HP??????????????????MP???????°?????????????\nlong long int S_dp[HP_MAX+1];\n\ntypedef pair<int,int> P;\n\nint main(){\n    string s;\n    vector<P> A,S; //<MP,Damage>\n    while(cin>>N,N!=0){\n        A.clear();\n        S.clear();\n        for(int i=0;i<N;i++) cin>>HP[i];\n        cin>>M;\n\n        for(int i=0;i<M;i++){\n            int m,d;\n            cin>>s>>m>>s>>d;\n            if(s[0]=='A'){\n                A.emplace_back(m,d);\n            }else{\n                S.emplace_back(m,d);\n            }\n        }\n\n        fill_n(dp[0],2*(HP_MAX+1),INT_MAX);\n        dp[1][0]=dp[0][0]=0;\n        for(int i=0;i<A.size();i++){\n            for(int hp=1;hp<=HP_MAX;hp++){\n                if(i==0){\n                    dp[0][hp]=A[0].first+(hp-A[0].second>=0?dp[0][hp-A[0].second]:0);\n                }else{\n                    dp[i%2][hp]=min(dp[(i+1)%2][hp],((hp-A[i].second)>=0?dp[i%2][hp-A[i].second]:0)+A[i].first);\n                }\n            }\n        }\n        for(int i=0;i<=HP_MAX;i++) A_dp[i]=dp[(A.size()+1)%2][i];\n\n        fill_n(dp[0],2*(HP_MAX+1),INT_MAX);\n        dp[1][0]=dp[0][0]=0;\n        for(int i=0;i<S.size();i++){\n            for(int hp=1;hp<=HP_MAX;hp++){\n                if(i==0){\n                    dp[0][hp]=S[0].first+(hp-S[0].second>=0?dp[0][hp-S[0].second]:0);\n                }else{\n                    dp[i%2][hp]=min(dp[(i+1)%2][hp],((hp-S[i].second)>=0?dp[i%2][hp-S[i].second]:0)+S[i].first);\n                }\n            }\n        }\n        for(int i=0;i<=HP_MAX;i++) S_dp[i]=dp[(S.size()+1)%2][i];\n\n        long long int MP_min=LLONG_MAX;\n        for(int alldamage=0;alldamage<=HP_MAX;alldamage++){\n            long long int mp=A_dp[alldamage];\n            if(mp==INT_MAX) continue;\n            for(int i=0;i<N;i++){\n                int hp=HP[i]-alldamage;\n                if(hp>0){\n                    mp+=S_dp[hp];\n                }\n            }\n            MP_min=min(MP_min,mp);\n        }\n        cout << MP_min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nconst int MAX_D = 1000005;\n\nvector<long long> dp(vector<pair<long long, long long>>& a){\n\tvector<long long> res(MAX_D, INF);\n\tres[0] = 0;\n\trep(i,MAX_D){\n\t\trep(j,a.size()){\n\t\t\tif(res[i] == INF) continue;\n\t\t\tint idx = min<int>(i + a[j].second, MAX_D - 1);\n\t\t\tres[idx] = min(res[idx], res[i] + a[j].first);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<long long> h(n);\n\t\trep(i,n){\n\t\t\tcin >> h[i];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<pair<long long,long long>> s, a; // first MP, second damage\n\t\trep(i,m){\n\t\t\tlong long MP, damage;\n\t\t\tstring target;\n\t\t\tcin >> target >> MP >> target >> damage;\n\t\t\t(target  == \"Single\" ? s : a).emplace_back(MP, damage);\n\t\t}\n\n\t\tvector<long long> al = dp(a);\n\t\tvector<long long> si = dp(s);\n\t\tfor (int i = MAX_D - 1; i > 0; i--) {\n\t\t\tsi[i - 1] = min(si[i - 1], si[i]);\n\t\t}\n\n\t\tlong long ans = INF;\n\t\trep(i,MAX_D){\n\t\t\tif(al[i] == INF) continue;\n\t\t\tlong long sum = al[i];\n\t\t\trep(j,n){\n\t\t\t\tsum += si[max(h[j] - i, 0LL)];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A)const{return tag==A.tag?A.MP>MP:tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator < (const DD &a)const{ return mp>a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1199999],res;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tres=1000000000;\n\t\tA=0;\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp); \n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tif(tmp.mp>=res)continue;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tif(SP[i].Dam==0)continue;\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstruct edge {\n\tint from;\n\tint to;\n\tlong double time;\n};\nstruct aa {\n\tint now;\n\tlong double time;\n\tbitset<8>tickets;\n};\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\n\n\nvector<pair<long long int, long long int>>smag, amag;\nvector<long long int>hps;\n\nlong long int sdp[100001];\nlong long int adp[100001];\n\n\nlong long int getmp(const long long int damage) {\n\tlong long int ans = 0;\n\tfor (auto i : hps) {\n\t\tif (i - damage <= 0) {\n\n\t\t}\n\t\telse {\n\t\t\tans += sdp[i - damage];\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\thps.clear();\n\t\tsmag.clear();\n\t\tamag.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\thps.emplace_back(a);\n\t\t}\n\t\tconst long long int max_hp = *max_element(hps.begin(), hps.end());\n\t\tint M; cin >> M;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tlong long int mp; cin >> mp;\n\t\t\tcin >> st;\n\t\t\tlong long int dam; cin >> dam;\n\t\t\tif (st == \"Single\") {\n\t\t\t\tsmag.push_back({ mp,dam });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamag.push_back({ mp,dam });\n\t\t\t}\n\t\t}\n\n\t\tmemset(sdp, 9999999,sizeof(sdp));\n\t\tmemset(adp, 9999999, sizeof(adp));\n\t\tsdp[0] = 0; adp[0] = 0;\n\t\tfor (long long int i = 0; i < 100000; ++i) {\n\t\t\tfor (auto mag : smag) {\n\t\t\t\tsdp[min(100000ll,i + mag.second)] = min(sdp[min(100000ll, i + mag.second)], sdp[i] + mag.first);\n\t\t\t}\n\t\t\tfor (auto mag : amag) {\n\t\t\t\tadp[min(100000ll, i + mag.second)] = min(adp[min(100000ll, i + mag.second)], adp[i] + mag.first);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\t\n\t\t\tsdp[100000-i-1] = min(sdp[100000-i], sdp[100000 - i - 1]);\n\t\t\t\n\t\t\t\n\t\t\tadp[100000-i-1] = min(adp[100000-i], adp[100000 - i - 1]);\n\t\t\t\n\t\t}\n\n\t\tlong long int ans = 9999999999999999;\n\t\tif (adp[1] > 1000) {\n\t\t\tans = getmp(0);\n\t\t}\n\t\telse if (sdp[1] > 1000) {\n\t\t\tans = adp[max_hp];\n\t\t}\n\t\telse {\n\n\t\t\tfor (int alldamage = 0; alldamage <= max_hp; ++alldamage) {\n\t\t\t\tans = min(ans, adp[alldamage] + getmp(alldamage));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nstruct Magic{ int cost,dmg; };\n\nint main(){\n\tfor(int n,m;scanf(\"%d\",&n),n;){\n\t\tint hp[100],hp_max=-1;\n\t\trep(i,n) scanf(\"%d\",hp+i), hp_max=max(hp_max,hp[i]);\n\n\t\tscanf(\"%d\",&m);\n\t\tint ms=0,ma=0; // s:single, a:all\n\t\tMagic magic_s[100],magic_a[100];\n\t\trep(i,m){\n\t\t\tint cost,dmg;\n\t\t\tchar s[7];\n\t\t\tscanf(\"%*s%d%s%d\",&cost,s,&dmg), dmg=min(dmg,hp_max);\n\t\t\tif(dmg>0){\n\t\t\t\tif(s[0]=='S') magic_s[ms++]=(Magic){cost,dmg};\n\t\t\t\telse          magic_a[ma++]=(Magic){cost,dmg};\n\t\t\t}\n\t\t}\n\n\t\tstatic int dp_a[200001];\n\t\trep(j,2*hp_max+1) dp_a[j]=(j==0?0:INF);\n\t\trep(i,ma){\n\t\t\tint cost=magic_a[i].cost,dmg=magic_a[i].dmg;\n\t\t\trep(j,2*hp_max-dmg+1) dp_a[j+dmg]=min(dp_a[j+dmg],dp_a[j]+cost);\n\t\t}\n\n\t\tstatic int dp_s[200001];\n\t\trep(j,2*hp_max+1) dp_s[j]=(j==0?0:INF);\n\t\trep(i,ms){\n\t\t\tint cost=magic_s[i].cost,dmg=magic_s[i].dmg;\n\t\t\trep(j,2*hp_max-dmg+1) dp_s[j+dmg]=min(dp_s[j+dmg],dp_s[j]+cost);\n\t\t}\n\t\tfor(int j=2*hp_max;j>0;j--) dp_s[j-1]=min(dp_s[j-1],dp_s[j]);\n\n\t\tint ans=INF;\n\t\tif(ms==0) ans=*min_element(dp_a+hp_max,dp_a+2*hp_max+1);\n\t\telse{\n\t\t\trep(j,2*hp_max+1){\n\t\t\t\tint cost=dp_a[j];\n\t\t\t\trep(i,n) cost+=dp_s[max(hp[i]-j,0)];\n\t\t\t\tans=min(ans,cost);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INF 99990000\n\nint main()\n{\n\tint N,M,HP[100];\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> HP[i];\n\t\t\t\n\t\tcin >> M;\n\t\tint ss[100], as[100],sd[100],ad[100],sn=0,an=0;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tstring n,t;\n\t\t\tint m,d;\n\t\t\tcin >> n >> m >> t >> d;\n\t\t\tif(d==0) continue;\n\t\t\t\n\t\t\tif(t==\"All\")\n\t\t\t{\n\t\t\t\tas[an]=m;\n\t\t\t\tad[an]=d;\n\t\t\t\tan++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss[sn]=m;\n\t\t\t\tsd[sn]=d;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint shp[100001], ahp[100001];\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tshp[i]=INF;\n\t\t\tahp[i]=INF;\n\t\t}\n\t\tshp[0]=0; ahp[0]=0;\n\t\tfor(int i=0; i<sn; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(shp[j]==INF) continue;\n\t\t\tif(j+sd[i]>100000)\n\t\t\t{\n\t\t\t\tshp[100000]=min(shp[100000], shp[j]+ss[i]);\n\t\t\t}\n\t\t\telse shp[j+sd[i]]=min(shp[j+sd[i]], shp[j]+ss[i]);\n\t\t}\n\t\t\n\t\tfor(int i=100000-1; i>=0; i--)\n\t\t\tshp[i]=min(shp[i+1], shp[i]);\n\t\t\n\t\tfor(int i=0; i<an; i++)\n\t\tfor(int j=0; j<=100000; j++)\n\t\t{\n\t\t\tif(ahp[j]==INF) continue;\n\t\t\tif(j+ad[i]>100000) \n\t\t\t{\n\t\t\t\tahp[100000]=min(ahp[100000], ahp[j]+as[i]);\n\t\t\t}\n\t\t\telse ahp[j+ad[i]]=min(ahp[j+ad[i]], ahp[j]+as[i]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<=100000; i++)\n\t\t{\n\t\t\tif(ahp[i]==INF) continue;\n\t\t\tint tmp=ahp[i];\n\t\t\t\n\t\t\tbool g=true;\n\t\t\t\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(i>=HP[j]) continue;\n\t\t\t\tif(shp[HP[j]-i]==INF) g=false;\n\t\t\t\ttmp+=shp[HP[j]-i];\n\t\t\t}\n\t\t\tif(!g) continue;\n\t\t\t\n\t\t\tans=min(ans, tmp);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nint single[100010] = {};\nint multi[100010] = {};\nint hp[110];\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tfor(int i = 0 ; i < 100010 ; i++) single[i] = 1e9;\n\t\tfor(int i = 0 ; i < 100010 ; i++) multi[i] = 1e9;\n\t\tsingle[0] = multi[0] = 0;\n\t\tfor(int i = 0 ; i < N ; i++)\n\t\t\tcin >> hp[i];\n\t\tint M;\n\t\tcin >> M;\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tstring name;\n\t\t\tint mp;\n\t\t\tstring target;\n\t\t\tint dmg;\n\t\t\tcin >> name >> mp >> target >> dmg;\n\t\t\tif( target == \"Single\" ){\n\t\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\t\tsingle[t] = min(single[t],single[j]+mp);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0 ; j <= 100000 ; j++){\n\t\t\t\t\tint t = min(100000,j+dmg);\n\t\t\t\t\tmulti[t] = min(multi[t],multi[j]+mp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 100000 ; j >= 0 ; j--){\n\t\t\tsingle[j] = min(single[j+1],single[j]);\n\t\t\tmulti[j] = min(multi[j+1],multi[j]);\n\t\t}\n\t\t\t\n\t\tlong long ans = 1e9;\n\t\tfor(int i = 0 ; i <= 100000 ; i++){\n\t\t\tlong long sub = multi[i];\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint r = max(0,hp[j]-i);\n\t\t\t\tsub += single[r];\n\t\t\t}\n\t\t\tans = min(sub,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m,d,h,i,j,r,s;\n\tstring str;\n\tfor(;cin>>n,n;cout<<r<<endl){\n\t\tvector<int>monster(n);\n\t\tfor(h=i=0;i<n;i++){\n\t\t\tcin>>monster[i];\n\t\t\tif(h<monster[i])h=monster[i];\n\t\t}\n\t\tvector<pair<int,int> >_all,_single;\n\t\tvector<int>all(h+1),single(h+1);\n\t\tfor(cin>>i;i--;){\n\t\t\tcin>>str>>m>>str>>d;\n\t\t\tif(d){\n\t\t\t\tif(str==\"All\")_all.push_back(make_pair(m,d));\n\t\t\t\telse _single.push_back(make_pair(m,d));\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tall[i]=9999999;//(h+_all[0].second-1)/_all[0].second*_all[0].first;\n\t\t\tsingle[i]=9999999;//(h+_single[0].second-1)/_single[0].second*_single[0].first;\n\t\t\tfor(j=0;j<_all.size();j++){\n\t\t\t\tall[i]=min(all[i],all[max(0,i-_all[j].second)]+_all[j].first);\n\t\t\t}\n\t\t\tfor(j=0;j<_single.size();j++){\n\t\t\t\tsingle[i]=min(single[i],single[max(0,i-_single[j].second)]+_single[j].first);\n\t\t\t}\n\t\t}\n\t\tif(all.empty()){\n\t\t\tfor(r=j=0;j<monster.size();j++)r+=single[monster[j]];\n\t\t}else if(single.empty()){\n\t\t\tr=all[h];\n\t\t}else{\n\t\t\tr=9999999;//(h+all[h]-1)/all[h];\n\t\t\tfor(i=0;i<=h;i++){\n\t\t\t\ts=all[i];\n\t\t\t\tfor(j=0;j<monster.size();j++)s+=single[max(0,monster[j]-i)];\n\t\t\t\t//cout<<i<<' '<<s<<' '<<all[i]<<endl;\n\t\t\t\tif(r>s)r=s;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<stdint.h>\n#include<cmath>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29) \n#define MAX_N 101\n#define MAX_M 101\n#define MAX_Damage 1000005\nusing namespace std;\n\nint N,M;\nint HP[MAX_N];\nvector<int> MP[2],Damage[2];\nbool Target[MAX_M];//false -> Single, true -> All\nuint64_t dp[2][MAX_Damage];\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      rep(i,N)cin >> HP[i];\n      cin >> M;\n      string Name,target;\n      int mp,damage;\n      rep(i,2)MP[i].clear(),Damage[i].clear();\n      rep(i,M)\n\t{\n\t  cin >> Name >> mp >> target >> damage;\n\t  if(damage == 0)continue;\n\t  if(target[0] == 'S')\n\t    {\n\t      Target[i] = 0;\n\t      MP[0].push_back(mp),Damage[0].push_back(damage);\n\t    }\n\t  else\n\t    {\n\t      Target[i] = 1;\n\t      MP[1].push_back(mp),Damage[1].push_back(damage);\n\t    }\n\t}\n\n      rep(i,2)rep(j,MAX_Damage)dp[i][j] = inf;\n      dp[0][0] = dp[1][0] = 0;\n\n      rep(i,2)\n\t{\n\t  rep(j,MP[i].size())\n\t    {\n\t      rep(k,MAX_Damage)\n\t\t{\n\t\t  if(dp[i][k] == inf || k+Damage[i][j] >= MAX_Damage)continue;\n\t\t  dp[i][k+Damage[i][j]] = min(dp[i][k+Damage[i][j]],\n\t\t\t\t\t      dp[i][k] + MP[i][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,2)\n\t{\n\t  for(int j=MAX_Damage-2;j>=0;j--)\n\t    {\n\t      dp[i][j] = min(dp[i][j],dp[i][j+1]);\n\t    }\n\t}\n      /*\n      rep(i,11)\n\t{\n\t  cout << \"dp[\"<<0<<\"][\"<<i<<\"] = \" <<dp[0][i] << endl;\n\t}\n      */\n      uint64_t ans = inf;\n      rep(i,MAX_Damage)//All\n\t{\n\t  if(dp[1][i] == inf)continue;\n\t  uint64_t cnt = dp[1][i];\n\t  bool ok = true;\n\t  rep(j,N)//Single\n\t    {\n\t      if(HP[j]-i <= 0)continue;\n\t      if(dp[0][HP[j]-i] == inf)\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t      cnt += dp[0][HP[j]-i];\n\t    }\n\t  if(!ok)continue;\n\t  //cout << \"cnt = \" << cnt << \" ans = \"<< ans << endl;\n\t  ans = min(ans,cnt);\n\t}\n      //cout << \"1 : \" << ans << endl;\n      int mex = -inf;\n      uint64_t cnt = 0;\n      rep(i,N)//Single\n\t{\n\t  mex = max(mex,HP[i]);\n\t  cnt += dp[0][HP[i]];\n\t}\n      ans = min(ans,cnt);\n      //cout << \"2 : \" << ans << endl;\n      ans = min(ans,dp[1][mex]);//All\n      //cout << \"3 : \" << ans << endl;\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int inf = 1e9;\n\ntypedef long long ll;\n\nint n;\nint hp[100];\nint ms, ma;\nint mps[100];\nint mpa[100];\nint dmgs[100];\nint dmga[100];\nint dps[2][100001];\nint dpa[2][100001];\n\nvoid calc(int m, int mp[], int dmg[], int dp[][100001]){\n\tdp[0][0] = 0;\n\tfill_n(dp[0] + 1, 100000, inf);\n\tfor(int i = 1; i <= m; ++i){\n\t\trep(j, 100001){\n\t\t\tdp[i & 1][j] = dp[(i - 1) & 1][j];\n\t\t\tif(dmg[i - 1]){\n\t\t\t\tif(j < dmg[i - 1]){\n\t\t\t\t\tdp[i & 1][j] = min(mp[i - 1], dp[i & 1][j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i & 1][j] = min(dp[i & 1][j - dmg[i - 1]] + mp[i - 1], dp[i & 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\trep(i, n){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tms = ma = 0;\n\t\trep(i, m){\n\t\t\tchar nm[17];\n\t\t\tint mp;\n\t\t\tchar trgt[7];\n\t\t\tint dmg;\n\t\t\tscanf(\"%s%d%s%d\", nm, &mp, trgt, &dmg);\n\t\t\tif(trgt[0] == 'S'){\n\t\t\t\tmps[ms] = mp;\n\t\t\t\tdmgs[ms++] = dmg;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmpa[ma] = mp;\n\t\t\t\tdmga[ma++] = dmg;\n\t\t\t}\n\t\t}\n\n\t\tcalc(ms, mps, dmgs, dps);\n\t\tcalc(ma, mpa, dmga, dpa);\n\t\t\n\t\tll ans = inf;\n\t\trep(i, 100001){\n\t\t\tll p = dpa[ma & 1][i];\n\t\t\trep(j, n){\n\t\t\t\tif(hp[j] > i){\n\t\t\t\t\tp += dps[ms & 1][hp[j] - i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(p, ans);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct Mag\n{\n\tint MP,tag,Dam;//single:0 all:1\n\tbool operator < (const Mag &A){return tag<A.tag;}\n}Mag;\n\ntypedef struct DD\n{\n\tint mp;\n\tvector<int>M;\n\tbool operator <(const DD &a)const{ return mp<a.mp;};\n}DD;\n\nint N,M,HP[105],A,SDP[1199999],res=1000000000;\nMag SP[105];\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(SDP,0x7f,sizeof(SDP));\n\t\tSDP[0]=0;\n\t\tfor(int i=0;i<N;i++)scanf(\"%d\",HP+i);\n\t\tscanf(\"%d\\n\",&M);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tchar t[20];\n\t\t\tscanf(\"%*s%d%s%d\\n\",&SP[i].MP,t,&SP[i].Dam);\n\t\t\tA+=SP[i].tag=t[0]=='S'?0:1;\n\t\t}\n\t\tsort(SP,SP+M);\n\t\tfor(int i=0;i<M-A;i++)\n\t\t{\n\t\t\tfor(int j=0;j+SP[i].Dam<1100000;j++)\n\t\t\t\tSDP[j+SP[i].Dam]=min(SDP[j+SP[i].Dam],SDP[j]+SP[i].MP);\n\t\t}\n\t\tfor(int i=1100000-1;i>=0;i--)\n\t\t\tSDP[i]=min(SDP[i],SDP[i+1]);\n\t\tpriority_queue<DD>Q;\n\t\tDD tmp;\n\t\ttmp.mp=0;\n\t\tfor(int i=0;i<N;i++)tmp.M.push_back(HP[i]);\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint cs=0,f=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(tmp.M[i]>0)\n\t\t\t\t{\n\t\t\t\t\tcs+=SDP[tmp.M[i]];\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=min(res,tmp.mp+cs);\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tfor(int i=M-A;i<M;i++)\n\t\t\t\t{\n\t\t\t\t\tDD ins=tmp;\n\t\t\t\t\tfor(int j=0;j<M;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ins.M[j]>0)ins.M[j]-=SP[i].Dam;\n\t\t\t\t\t}\n\t\t\t\t\tins.mp+=SP[i].MP;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define M 100\n#define N 100\n#define SINGLE 1\n#define ALL 2\n#define INFTY 1<<30\nusing namespace std;\nstruct magic{\n\tint mp;\n\tint type;\n\tint damage;\n\tbool operator<(const magic &m)const{\n\t\treturn mp<m.mp;\n\t}\n};\nvoid solve(int n, int hp[N], int m, magic mag[M], int now, int limit, int &ans){\n\tbool bSolved=true;\n\t/*for(int i=0;i<n;++i){\n\t\tcout<<hp[i]<<' ';\n\t}\n\tcout<<endl;*/\n\tfor(int i=0;i<n;++i){\n\t\tif(hp[i]>0){\n\t\t\tbSolved=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( bSolved ){\n\t\tans=min(ans,now);\n\t\treturn ;\n\t}\n\tif( now+mag[0].mp>limit )\n\t\treturn ;\n\n\tfor(int i=0;i<m;++i){\n\t\tint nx_hp[N];\n\t\tfor(int j=0;j<n;++j){\n\t\t\tnx_hp[j]=hp[j];\n\t\t}\n\t\tif(mag[i].type==ALL){\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t}\n\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,limit,ans );\n\t\t}else{\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif(nx_hp[j]>0){\n\t\t\t\t\tnx_hp[j]-=mag[i].damage;\n\t\t\t\t\tsolve( n,nx_hp,m,mag,now+mag[i].mp,limit,ans );\n\t\t\t\t\tnx_hp[j]+=mag[i].damage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(true){\n\t\tint ans=INFTY;\n\t\tint n,m;\n\t\tint minmp=INFTY;\n\t\tint magsz=0;\n\t\tint hp[N]={0,};\n\t\tmagic mag[M];\n\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tscanf(\"%d\", &hp[i]);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tchar type[17]=\"\";\n\t\t\tscanf(\"%*s%d%s%d\", &mag[magsz].mp, type, &mag[magsz].damage);\n\t\t\tif(strcmp(type,\"All\")==0)mag[magsz].type=ALL;\n\t\t\telse mag[magsz].type=SINGLE;\n\t\t\tif(mag[magsz].damage>0)\n\t\t\t\t++magsz;\n\t\t\telse{\n\t\t\t\tminmp=min(minmp,mag[magsz].mp);\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<magsz;++i){\n\t\t\tcout << \"MP: \" << mag[i].mp <<\" TYPE: \" << mag[i].type << \" DAMAGE: \" << mag[i].damage << endl;\n\t\t}*/\n\t\tsort(mag,mag+magsz);\n\t\tfor(int i=0;i<INFTY;++i){\n\t\t\tsolve(n,hp,magsz,mag,0,i,ans);\n\t\t\tif(ans<INFTY)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e18;\n\nint n, m;\nvector<int> h;\nvector<P> m1, m2; \nint dp[100010], dp2[100010];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin >> n, n){\n        h.resize(n);\n        m1.clear();\n        m2.clear();\n        rep(i, 0, n){\n            cin >> h[i];\n        }\n        cin >> m;\n        rep(i, 0, m){\n            string s1;\n            int mp, damage;\n            cin >> s1 >> mp >> s1 >> damage;\n            if(s1 == \"Single\"){\n                m1.push_back(P(mp, damage));\n            }else if(s1 == \"All\"){  \n                m2.push_back(P(mp, damage));\n            }\n        }\n        rep(i, 0, 100010){\n            dp[i] = dp2[i] = INF;\n        }\n        dp[0] = dp2[0] = 0;\n        rep(i, 0, m1.size()){\n            rep(j, 0, 100001){\n                if(dp[j] == INF) continue;\n                int next = j + m1[i].second;\n                if(next > 100000) next = 100001;\n                chmin(dp[next], dp[j] + m1[i].first);\n            }\n        }\n        rep(i, 0, m2.size()){\n            rep(j, 0, 100001){\n                if(dp2[j] == INF) continue;\n                int next = j + m2[i].second;\n                if(next > 100000) next = 100001;\n                chmin(dp2[next], dp2[j] + m2[i].first);\n            }\n        }\n        int MIN = INF;\n        repb(i, 100001, 0){\n            chmin(MIN, dp[i]);\n            dp[i] = MIN;\n        }\n        MIN = INF;\n        repb(i, 100001, 0){\n            chmin(MIN, dp2[i]);\n            dp2[i] = MIN;\n        }\n        int ans = INF;\n        rep(i, 0, 100001){\n            int sum = dp2[i];\n            rep(j, 0, n){\n                sum += dp[max(0LL, h[j] - i)];\n            }\n            chmin(ans, sum);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nconst int INF=1e12;\n\nvoid solve(int N)\n{\n    vector<int> h(N);\n    for(int i=0;i<N;i++) cin>>h[i];\n\n    int M; cin>>M;\n    vector<int> m1,d1,m2,d2;\n    for(int i=0;i<M;i++){\n        string s,t;\n        int x,y;\n        cin>>s>>x>>t>>y;\n        if(t==\"Single\") m1.push_back(x),d1.push_back(y);\n        else m2.push_back(x),d2.push_back(y);\n    }\n    // for(int i:m1) cout<<i<<' '; cout<<endl;\n    // for(int i:d1) cout<<i<<' '; cout<<endl;\n    // for(int i:m2) cout<<i<<' '; cout<<endl;\n    // for(int i:d2) cout<<i<<' '; cout<<endl;\n    int maxH=*max_element(h.begin(),h.end());\n    vector<int> dp1(maxH+1,INF),dp2(maxH+1,INF);\n    dp1[0]=dp2[0]=0;\n    for(int i=0;i<m1.size();i++){\n        for(int j=0;j<=maxH;j++){\n            int damage=min(j+d1[i],maxH);\n            chmin(dp1[damage],dp1[j]+m1[i]);\n        }\n    }\n    for(int i=0;i<m2.size();i++){\n        for(int j=0;j<=maxH;j++){\n            int damage=min(j+d2[i],maxH);\n            chmin(dp2[damage],dp2[j]+m2[i]);\n        }\n    }\n    for(int i=maxH-1;i>=0;i--) chmin(dp1[i],dp1[i+1]);\n    for(int i=maxH-1;i>=0;i--) chmin(dp2[i],dp2[i+1]);\n    int ans=INF;\n    for(int i=0;i<=maxH;i++){\n        int sum=dp2[i];\n        for(int j=0;j<N;j++) sum+=dp1[max(0LL,h[j]-i)];\n        chmin(ans,sum);\n    }\n    cout<<ans<<endl;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        int N; cin>>N;\n        if(N==0) break;\n        solve(N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[200],b[200],d[200];vector<int>v1,v2,w1,w2,dp1,dp2;\nvector<int>knapsack(int W,vector<int>v,vector<int>w){\n\tvector<int>dp(W+1000,999999999);\n\tfor(int i=0;i<dp.size();i++){dp[i]=999999999;}\n\tdp[0]=0;\n\tfor(int i=0;i<(int)min(v.size(),w.size());i++){\n\t\tfor(int j=v[i];j<=W;j++)dp[j]=min(dp[j],dp[j-v[i]]+w[i]);\n\t}\n\tfor(int i=W-1;i>=0;i--){\n\t\tdp[i]=min(dp[i],dp[i+1]);\n\t}\n\treturn dp;\n}\nint main(){\n\twhile(true){\n\t\tv1.clear();v2.clear();w1.clear();w2.clear();dp1.clear();dp2.clear();\n\t\tfor(int i=0;i<200;i++){a[i]=0;b[i]=0;d[i]=0;}\n\t\tcin>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];cin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring S,T;cin>>S>>b[i]>>T>>d[i];if(d[i]>=200000)d[i]=200000;\n\t\t\tif(T==\"Single\"){v1.push_back(d[i]);w1.push_back(b[i]);}\n\t\t\tif(T==\"All\"){v2.push_back(d[i]);w2.push_back(b[i]);}\n\t\t}\n\t\tdp1=knapsack(400000,v1,w1);\n\t\tdp2=knapsack(400000,v2,w2);\n\t\tint maxn=999999999;\n\t\tfor(int i=0;i<=300000;i++){\n\t\t\tint sum=dp2[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(a[j]>i && dp1[a[j]-i]<=1e8){\n\t\t\t\t\tsum+=dp1[a[j]-i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn=min(maxn,sum);\n\t\t}\n\t\tcout<<maxn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nconst int N = 100;\nconst int M = 100000;\nconst int INF = 1 << 28;\n\ntypedef pair<int, int> P;\n\nint n, m, hp[N], sm[M+1], am[M+1];\nvector<P> s, a;\n\nint main(){\n\twhile(cin >> n && n){\n\t\ts.clear();\n\t\ta.clear();\n\t\tfor(int i=0;i<n;i++) cin >> hp[i];\n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring ran;\n\t\t\tint mp, da;\n\t\t\tcin >> ran >> mp >> ran >> da;\n\t\t\tif(ran == \"All\") a.push_back(P(da, mp));\n\t\t\telse s.push_back(P(da, mp));\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\tsort(a.begin(), a.end());\n\t\tfill(sm, sm+M+1, INF);\n\t\tfill(am, am+M+1, INF);\n\t\tsm[0] = am[0] = 0;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tint nx = min(M, i + s[j].first);\n\t\t\t\tsm[nx] = min(sm[nx], sm[i] + s[j].second);\n\t\t\t}\n\t\t\tfor(int j=0;j<(int)a.size();j++){\n\t\t\t\tint nx = min(M, i + a[j].first);\n\t\t\t\tam[nx] = min(am[nx], am[i] + a[j].second);\n\t\t\t}\n\t\t}\n\t\tint valm[2] = {sm[M], am[M]};\n\t\tfor(int i=M;i>=0;i--){\n\t\t\tvalm[0] = min(valm[0], sm[i]);\n\t\t\tvalm[1] = min(valm[1], am[i]);\n\t\t\tsm[i] = valm[0];\n\t\t\tam[i] = valm[1];\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tint tmp = am[i];\n\t\t\tfor(int j=0;j<n;j++) tmp += sm[max(0, hp[j] - i)];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define f first\n#define s second\n#define N 100000\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long ll;\n\nint main(){\n  int n,m,hp[101];\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>hp[i];\n\n    vector <P> mg[2];  \n    cin>>m;\n    for(int i=0,cost,dam;i<m;i++){\n      string name,type;\n      cin>>name>>cost>>type>>dam;\n      if(dam)mg[type==\"All\"].push_back(P(dam,cost));\n    }\n\n    int dp[2][N+10]={};\n    for(int i=0;i<2;i++)for(int j=1;j<N+10;j++)dp[i][j]=INF;\n \n    for(int k=0;k<2;k++)\n      for(int i=0;i<mg[k].size();i++)\n\tfor(int j=mg[k][i].f;j<=(N/mg[k][i].f+1)*mg[k][i].f;j++)\n\t  dp[k][min(N,j)]=min(dp[k][min(N,j)],dp[k][j-mg[k][i].f]+mg[k][i].s);\n\n    for(int i=0;i<2;i++)\n      for(int j=N;j>=0;j--)dp[i][j]=min(dp[i][j],dp[i][j+1]);\n      \n    ll ans=INF;\n    for(int i=0;i<=N;i++){\n      ll cost=dp[1][i];\n      for(int j=0;j<n;j++)cost+=dp[0][max(0,hp[j]-i)];\n      ans=min(ans,cost);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        if(n==0){break;}\n    vector<ll> a(n);\n    for(auto &i:a){cin>>i;}\n    ll m;\n    cin>>m;\n    vector<pll> Sg,Ml;\n        ll mx=100001;\n    for(int i=0;i<m;i++){\n        string N,T;\n        ll M,D;\n        cin>>N>>M>>T>>D;\n        if(D>=mx){D=mx-1;}\n        if(T==\"Single\"){Sg.push_back({D,M});}\n        else if(T==\"All\"){Ml.push_back({D,M});}\n    }\n    vector<ll> dp1(mx,E),dp2(mx,E);\n    dp1[0]=dp2[0]=0;\n    for(auto &i:Sg){\n        for(int t=0;t+i.F<mx;t++){\n            dp1[t+i.F]=min(dp1[t+i.F],dp1[t]+i.S);\n        }\n        for(ll i=mx-2;i>=0;i--){\n            dp1[i]=min(dp1[i],dp1[i+1]);\n        }\n    }\n    for(auto &i:Ml){\n        for(int t=0;t+i.F<mx;t++){\n            dp2[t+i.F]=min(dp2[t+i.F],dp2[t]+i.S);\n        }\n        for(ll i=mx-2;i>=0;i--){\n            dp2[i]=min(dp2[i],dp2[i+1]);\n        }\n    }\n    ll ans=E;\n    for(int i=0;i<mx;i++){\n        ll count=dp2[i];\n        for(int t=0;t<n;t++){\n            if(a[t]>i){count+=dp1[a[t]-i];}\n        }\n        ans=min(ans,count);\n    }\n    cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <tuple>\n\nstd::vector<size_t> dp(std::vector<std::pair<int, int>> const& magic) {\n  size_t inf = 1e9;\n  std::vector<size_t> res(100001, inf);\n  res[0] = 0;\n  for (size_t i = 0; i < res.size(); ++i) {\n    for (size_t j = 0; j < magic.size(); ++j) {\n      // if (i + magic[j].second >= res.size()) continue;\n      size_t ni = std::min(i+magic[j].second, res.size()-1);\n      res[ni] = std::min(res[ni], res[i] + magic[j].first);\n    }\n  }\n  for (size_t j = res.size(); j-- > 1;)\n    res[j-1] = std::min(res[j-1], res[j]);\n  return res;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<size_t> hp(n);\n  for (auto& hi: hp) scanf(\"%zu\", &hi);\n\n  size_t m;\n  scanf(\"%zu\", &m);\n  std::vector<std::pair<int, int>> magic_s, magic_a;  // {mp, damage}\n  for (size_t i = 0; i < m; ++i) {\n    char tg;\n    int mp, dmg;\n    scanf(\"%*s %d %c%*s %d\", &mp, &tg, &dmg);\n    if (tg == 'S') {\n      magic_s.emplace_back(mp, dmg);\n    } else if (tg == 'A') {\n      magic_a.emplace_back(mp, dmg);\n    } else {\n      assert(false);\n    }\n  }\n\n  std::vector<size_t> dp_s = dp(magic_s);\n  std::vector<size_t> dp_a = dp(magic_a);\n  size_t res = 1e9;\n  for (size_t i = 0; i <= 100000; ++i) {\n    size_t cur = dp_a[i];\n    for (size_t j = 0; j < n; ++j) {\n      if (hp[j] <= i) continue;\n      cur += dp_s[hp[j] - i];\n    }\n    res = std::min(res, cur);\n  }\n  printf(\"%zu\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long MIN(long long a,long long b){return a<b?a:b;}\nlong long MAX(long long a,long long b){return a<b?b:a;}\nlong long n,m,i,j,k,a[100010],b[100010],c[100010],min,d[2][100010];\nint main(){\n\tchar s[100010][10];\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++)scanf(\"%*s %lld %s %lld\",&b[i],&s[i],&c[i]);\n\t\tfor(i=0;i<100010;i++)d[0][i]=d[1][i]=1e9+10;\n\t\tfor(i=d[0][0]=d[1][0]=0;i<100000;i++){\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tk=(s[j][0]=='S'?0:1);\n\t\t\t\td[k][MIN(100000,i+c[j])]=MIN(d[k][MIN(100000,i+c[j])],d[k][i]+b[j]);\n\t\t\t}\n\t\t}//return 0;\n\t\tfor(i=0;i<2;i++){\n\t\t\tfor(j=100000;j;j--)d[i][j-1]=MIN(d[i][j-1],d[i][j]);\n\t\t}\n\t\tmin=1e9+10;\n\t\tfor(i=0;i<100001;i++){\n\t\t\tk=d[1][i];\n\t\t\tfor(j=0;j<n;j++)k+=d[0][MAX(0,a[j]-i)];\n\t\t\tmin=MIN(min,k);\n\t\t}\n\t\tprintf(\"%lld\\n\",min);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Magic Slayer\npublic class Main{\n\n\tvoid run(){\n\t\tint INF = 1<<29;\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[] hp = new int[n];\n\t\t\tfor(int i=0;i<n;i++)hp[i]=sc.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\tint maxhp = hp[n-1];\n\t\t\tint m = sc.nextInt();\n\t\t\tint sn = 0, an = 0;\n\t\t\tint[] singleD = new int[m];\n\t\t\tint[] singleM = new int[m];\n\t\t\tint[] allD = new int[m];\n\t\t\tint[] allM = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tsc.next();\n\t\t\t\tint mp = sc.nextInt();\n\t\t\t\tboolean f = \"Single\".equals(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tif(d==0)continue;\n\t\t\t\tif(f){\n\t\t\t\t\tsingleD[sn] = d;\n\t\t\t\t\tsingleM[sn] = mp;\n\t\t\t\t\tsn++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tallD[an] = d;\n\t\t\t\t\tallM[an] = mp;\n\t\t\t\t\tan++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] sdp = new int[maxhp+1];\n\t\t\tArrays.fill(sdp, INF);\n\t\t\tsdp[0] = 0;\n\t\t\tif(sn>0){\n\t\t\t\tfor(int d=1;d<=maxhp;d++)sdp[d] = ((d-1)/singleD[0]+1)*singleM[0];\n\t\t\t\tfor(int i=1;i<sn;i++){\n\t\t\t\t\tfor(int d=1;d<=maxhp;d++){\n\t\t\t\t\t\tif(d-singleD[i]<=0)sdp[d] = Math.min(sdp[d], singleM[i]);\n\t\t\t\t\t\telse sdp[d] = Math.min(sdp[d], sdp[d-singleD[i]]+singleM[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] adp = new int[maxhp+1];\n\t\t\tArrays.fill(adp, INF);\n\t\t\tadp[0] = 0;\n\t\t\tif(an>0){\n\t\t\t\tfor(int d=1;d<=maxhp;d++)adp[d] = ((d-1)/allD[0]+1)*allM[0];\n\t\t\t\tfor(int i=1;i<an;i++){\n\t\t\t\t\tfor(int d=1;d<=maxhp;d++){\n\t\t\t\t\t\tif(d-allD[i]<=0)adp[d] = Math.min(adp[d], allM[i]);\n\t\t\t\t\t\telse adp[d] = Math.min(adp[d], adp[d-allD[i]]+allM[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(sdp);\n//\t\t\tdebug(adp);\n\t\t\tint min = INF;\n\t\t\tfor(int d=0;d<=maxhp;d++){\n\t\t\t\tint mp = adp[d];\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tmp += sdp[Math.max(0, hp[i]-d)];\n\t\t\t\t\tif(INF<=mp){\n\t\t\t\t\t\tmp = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin = Math.min(min, mp);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport javax.swing.undo.StateEdit;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 100100;\n\tint INF = 100000;\n\t\n\tint[] knapzak(String TARGET, int[] mp, String[] target, int[] damage) {\n\t\tint m = mp.length;\n\t\tint[] res = new int[MAX];\n\t\t\n\t\tArrays.fill(res, INF);\n\t\tres[0] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!target[i].matches(TARGET)) continue;\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tint nj = Math.min(j + damage[i], MAX - 1);\n\t\t\t\tres[nj] = Math.min(res[nj], res[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tres[i] = Math.min(res[i], res[i + 1]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\t\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] hp = in.nextIntArray(n);\n\t\t\tint m = in.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\t\n\t\t\tString[] name = new String[m];\n\t\t\tint[] mp = new int[m];\n\t\t\tString[] target = new String[m];\n\t\t\tint[] damage = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tname[i] = in.next();\n\t\t\t\tmp[i] = in.nextInt();\n\t\t\t\ttarget[i] = in.next();\n\t\t\t\tdamage[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] single = knapzak(\"Single\", mp, target, damage);\n\t\t\tint[] all = knapzak(\"All\", mp, target, damage);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (all[hp[i]] == INF) continue;\n\t\t\t\tint sum = all[hp[i]];\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += single[hp[j] - hp[i]];\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport javax.swing.undo.StateEdit;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 100100;\n\tint INF = 100000000;\n\t\n\tint[] knapzak(String TARGET, int[] mp, String[] target, int[] damage) {\n\t\tint m = mp.length;\n\t\tint[] res = new int[MAX];\n\t\t\n\t\tArrays.fill(res, INF);\n\t\tres[0] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (TARGET.matches(\"All\") && target[i].matches(\"Single\")) continue;\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tint nj = Math.min(j + damage[i], MAX - 1);\n\t\t\t\tres[nj] = Math.min(res[nj], res[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tres[i] = Math.min(res[i], res[i + 1]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\t\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] hp = in.nextIntArray(n);\n\t\t\tint m = in.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\t\n\t\t\tString[] name = new String[m];\n\t\t\tint[] mp = new int[m];\n\t\t\tString[] target = new String[m];\n\t\t\tint[] damage = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tname[i] = in.next();\n\t\t\t\tmp[i] = in.nextInt();\n\t\t\t\ttarget[i] = in.next();\n\t\t\t\tdamage[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] single = knapzak(\"Single\", mp, target, damage);\n\t\t\tint[] all = knapzak(\"All\", mp, target, damage);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = -1; i < n; i++) {\n\t\t\t\tint sum = (i != -1) ? all[hp[i]] : 0;\n\t\t\t\tif (sum == INF) continue;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tint idx = (i == -1) ? hp[j] : hp[j] - hp[i];\n\t\t\t\t\tsum += single[idx];\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport javax.swing.undo.StateEdit;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = true;\n\tString __DEBUG_FILE_NAME__ = \"T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 100100;\n\tint INF = 100000000;\n\t\n\tint[] knapzak(String TARGET, int[] mp, String[] target, int[] damage) {\n\t\tint m = mp.length;\n\t\tint[] res = new int[MAX];\n\t\t\n\t\tArrays.fill(res, INF);\n\t\tres[0] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!target[i].matches(TARGET)) continue;\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tint nj = Math.min(j + damage[i], MAX - 1);\n\t\t\t\tres[nj] = Math.min(res[nj], res[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tres[i] = Math.min(res[i], res[i + 1]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\t\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] hp = in.nextIntArray(n);\n\t\t\tint m = in.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\t\n\t\t\tString[] name = new String[m];\n\t\t\tint[] mp = new int[m];\n\t\t\tString[] target = new String[m];\n\t\t\tint[] damage = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tname[i] = in.next();\n\t\t\t\tmp[i] = in.nextInt();\n\t\t\t\ttarget[i] = in.next();\n\t\t\t\tdamage[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] single = knapzak(\"Single\", mp, target, damage);\n\t\t\tint[] all = knapzak(\"All\", mp, target, damage);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = all[hp[i]];\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += single[hp[j] - hp[i]];\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Magic Slayer\npublic class Main{\n\n\tvoid run(){\n\t\tint INF = 1<<29;\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[] hp = new int[n];\n\t\t\tfor(int i=0;i<n;i++)hp[i]=sc.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\tint maxhp = hp[n-1];\n\t\t\tint m = sc.nextInt();\n\t\t\tint sn = 0, an = 0;\n\t\t\tint[] singleD = new int[m];\n\t\t\tint[] singleM = new int[m];\n\t\t\tint[] allD = new int[m];\n\t\t\tint[] allM = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tsc.next();\n\t\t\t\tint mp = sc.nextInt();\n\t\t\t\tboolean f = \"Single\".equals(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tif(d==0)continue;\n\t\t\t\tif(f){\n\t\t\t\t\tsingleD[sn] = d;\n\t\t\t\t\tsingleM[sn] = mp;\n\t\t\t\t\tsn++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tallD[an] = d;\n\t\t\t\t\tallM[an] = mp;\n\t\t\t\t\tan++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] sdp = new int[maxhp+1];\n\t\t\tArrays.fill(sdp, INF);\n\t\t\tsdp[0] = 0;\n\t\t\tif(sn>0){\n\t\t\t\tfor(int d=1;d<=maxhp;d++)sdp[d] = ((d-1)/singleD[0]+1)*singleM[0];\n\t\t\t\tfor(int i=1;i<sn;i++){\n\t\t\t\t\tfor(int d=1;d<=maxhp;d++){\n\t\t\t\t\t\tif(d-singleD[i]<=0)sdp[d] = Math.min(sdp[d], singleM[i]);\n\t\t\t\t\t\telse sdp[d] = Math.min(sdp[d], sdp[d-singleD[i]]+singleM[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] adp = new int[maxhp+1];\n\t\t\tArrays.fill(adp, INF);\n\t\t\tadp[0] = 0;\n\t\t\tif(an>0){\n\t\t\t\tfor(int d=1;d<=maxhp;d++)adp[d] = ((d-1)/allD[0]+1)*allM[0];\n\t\t\t\tfor(int i=1;i<an;i++){\n\t\t\t\t\tfor(int d=1;d<=maxhp;d++){\n\t\t\t\t\t\tif(d-allD[i]<=0)adp[d] = Math.min(adp[d], allM[i]);\n\t\t\t\t\t\telse adp[d] = Math.min(adp[d], adp[d-allD[i]]+allM[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int d=0;d<=maxhp;d++){\n\t\t\t\tint mp = adp[d];\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tmp += sdp[Math.max(0, hp[i]-d)];\n\t\t\t\t}\n\t\t\t\tmin = Math.min(min, mp);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport javax.swing.undo.StateEdit;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 100100;\n\tint INF = 100000000;\n\t\n\tint[] knapzak(String TARGET, int[] mp, String[] target, int[] damage) {\n\t\tint m = mp.length;\n\t\tint[] res = new int[MAX];\n\t\t\n\t\tArrays.fill(res, INF);\n\t\tres[0] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (TARGET.matches(\"All\") && target[i].matches(\"Single\")) continue;\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tint nj = Math.min(j + damage[i], MAX - 1);\n\t\t\t\tres[nj] = Math.min(res[nj], res[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tres[i] = Math.min(res[i], res[i + 1]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\t\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] hp = in.nextIntArray(n);\n\t\t\tint m = in.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\t\n\t\t\tString[] name = new String[m];\n\t\t\tint[] mp = new int[m];\n\t\t\tString[] target = new String[m];\n\t\t\tint[] damage = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tname[i] = in.next();\n\t\t\t\tmp[i] = in.nextInt();\n\t\t\t\ttarget[i] = in.next();\n\t\t\t\tdamage[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] single = knapzak(\"Single\", mp, target, damage);\n\t\t\tint[] all = knapzak(\"All\", mp, target, damage);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = -1; i < n; i++) {\n\t\t\t\tint sum = (i != -1) ? all[hp[i]] : 0;\n\t\t\t\tif (sum == INF) continue;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tint idx = (i == -1) ? hp[j] : hp[j] - hp[i];\n\t\t\t\t\tsum += single[idx];\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport javax.swing.undo.StateEdit;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"src/2156-input.txt\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 100100;\n\tint INF = 10000000;\n\t\n\tint[] knapzak(String TARGET, int[] mp, String[] target, int[] damage) {\n\t\tint m = mp.length;\n\t\tint[] res = new int[MAX];\n\t\t\n\t\tArrays.fill(res, INF);\n\t\tres[0] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (TARGET.matches(\"All\") && target[i].matches(\"Single\")) continue;\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tint nj = Math.min(j + damage[i], MAX - 1);\n\t\t\t\tres[nj] = Math.min(res[nj], res[j] + mp[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tres[i] = Math.min(res[i], res[i + 1]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\t\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] hp = in.nextIntArray(n);\n\t\t\tint m = in.nextInt();\n\t\t\tArrays.sort(hp);\n\t\t\t\n\t\t\tString[] name = new String[m];\n\t\t\tint[] mp = new int[m];\n\t\t\tString[] target = new String[m];\n\t\t\tint[] damage = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tname[i] = in.next();\n\t\t\t\tmp[i] = in.nextInt();\n\t\t\t\ttarget[i] = in.next();\n\t\t\t\tdamage[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] single = knapzak(\"Single\", mp, target, damage);\n\t\t\tint[] all = knapzak(\"All\", mp, target, damage);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\t\tint sum = all[i];\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (hp[j] - i >= 0) \n\t\t\t\t\t\tsum += single[hp[j] - i];\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n\tpublic static long[] dp1, dp2;\n\tpublic static int[] hp;\n\tpublic static int hpmax;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (n == 0) break;\n\t\t\thp = new int[n];\n\t\t\thpmax = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\thp[i] = int.Parse(Console.ReadLine().Trim());\n\t\t\t\thpmax = Max(hpmax, hp[i]);\n\t\t\t}\n\t\t\tArray.Sort(hp);\n\t\t\tvar m = int.Parse(Console.ReadLine().Trim());\n\t\t\tdp1 = new long[hpmax + 1];\n\t\t\tdp2 = new long[hpmax + 1];\n\t\t\tvar Allc = 0; var singlec = 0;\n\t\t\tvar mp0find = false;\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tvar mp = int.Parse(line[1]);\n\t\t\t\tvar target = line[2];\n\t\t\t\tvar damage = int.Parse(line[3]);\n\t\t\t\tif (mp == 0 && damage > 0) { mp0find = true; }\n\t\t\t\tif (damage == 0) continue;\n\t\t\t\tif (target == \"All\")\n\t\t\t\t{\n\t\t\t\t\tgetDptable(dp1, mp, damage);\n\t\t\t\t\tAllc++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgetDptable(dp2, mp, damage);\n\t\t\t\t\tsinglec++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mp0find) { Console.WriteLine(0); goto next; }\n\t\t\tif (singlec == 0) { Console.WriteLine(LowerBound(dp1, hpmax)); goto next; }\n\t\t\tvar ssum = 0L;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tssum += LowerBound(dp2, hp[i]);\n\t\t\tif (Allc == 0) { Console.WriteLine(ssum); goto next; }\n\t\t\tvar ans = getAns(n, ssum);\n\t\t\tConsole.WriteLine(ans);\n\t\tnext:;\n\t\t}\n\t}\n\tstatic long getAns(int n, long ssum)\n\t{\n\t\tvar ans = ssum; // all single\n\t\tans = Min(ans, LowerBound(dp1, hpmax));   // no single\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvar tans = LowerBound(dp1, hp[i]);\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\ttans += LowerBound(dp2, hp[j] - dp1[tans]);\n\t\t\tans = Min(ans, tans);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic void getDptable(long[] dp, int mp, int damage)\n\t{\n\t\tfor (int i = mp; i < hpmax + 1; i++)\n\t\t\tdp[i] = Max(dp[i], dp[i - mp] + damage);\n\t}\n\tpublic static int LowerBound<T>(T[] arr, int start, int end, T value, IComparer<T> comparer)\n\t{\n\t\tvar low = start;\n\t\tvar high = end;\n\t\twhile (low < high)\n\t\t{\n\t\t\tvar mid = ((high - low) >> 1) + low;\n\t\t\tif (comparer.Compare(arr[mid], value) < 0) low = mid + 1;\n\t\t\telse high = mid;\n\t\t}\n\t\treturn low;\n\t}\n\tpublic static int LowerBound<T>(T[] arr, T value) where T : IComparable\n\t\t=> LowerBound(arr, 0, arr.Length, value, Comparer<T>.Default);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n\tpublic static long[] dp1, dp2;\n\tpublic static int[] hp;\n\tpublic static int hpmax;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (n == 0) break;\n\t\t\thp = new int[n];\n\t\t\thpmax = 0;\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\thp[i] = int.Parse(line[i]);\n\t\t\t\thpmax = Max(hpmax, hp[i]);\n\t\t\t}\n\t\t\tArray.Sort(hp);\n\t\t\tvar m = int.Parse(Console.ReadLine().Trim());\n\t\t\tdp1 = new long[hpmax + 1];\n\t\t\tdp2 = new long[hpmax + 1];\n\t\t\tvar Allc = 0; var singlec = 0;\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tvar mp = int.Parse(line[1]);\n\t\t\t\tvar target = line[2];\n\t\t\t\tvar damage = int.Parse(line[3]);\n\t\t\t\tif (mp == 0) { Console.WriteLine(0); goto next; }\n\t\t\t\tif (damage > 0)\n\t\t\t\t\tif (target == \"All\")\n\t\t\t\t\t{\n\t\t\t\t\t\tgetDptable(dp1, mp, damage);\n\t\t\t\t\t\tAllc++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgetDptable(dp2, mp, damage);\n\t\t\t\t\t\tsinglec++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (singlec == 0) { Console.WriteLine(LowerBound(dp1, hpmax)); goto next; }\n\t\t\tvar ssum = 0L;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tssum += LowerBound(dp2, hp[i]);\n\t\t\t}\n\t\t\tif (Allc == 0) { Console.WriteLine(ssum); goto next; }\n\t\t\tvar ans = getAns(n, ssum);\n\t\t\tConsole.WriteLine(ans);\n\t\tnext:;\n\t\t}\n\t}\n\tstatic long getAns(int n, long ssum)\n\t{\n\t\tvar ans = ssum; // all single\n\t\tans = Min(ans, LowerBound(dp1, hpmax));   // no single\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvar tans = LowerBound(dp1, hp[i]);\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\ttans += LowerBound(dp2, hp[j] - dp1[tans]);\n\t\t\tans = Min(ans, tans);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic void getDptable(long[] dp, int mp, int damage)\n\t{\n\t\tfor (int i = mp; i < hpmax + 1; i++)\n\t\t\tdp[i] = Max(dp[i], dp[i - mp] + damage);\n\t}\n\tpublic static int LowerBound<T>(T[] arr, int start, int end, T value, IComparer<T> comparer)\n\t{\n\t\tint low = start;\n\t\tint high = end;\n\t\tint mid;\n\t\twhile (low < high)\n\t\t{\n\t\t\tmid = ((high - low) >> 1) + low;\n\t\t\tif (comparer.Compare(arr[mid], value) < 0) low = mid + 1;\n\t\t\telse high = mid;\n\t\t}\n\t\treturn low;\n\t}\n\tpublic static int LowerBound<T>(T[] arr, T value) where T : IComparable\n\t\t=> LowerBound(arr, 0, arr.Length, value, Comparer<T>.Default);\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n\tpublic static long[] dp1, dp2;\n\tpublic static int[] hp;\n\tpublic static int hpmax;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (n == 0) break;\n\t\t\thp = new int[n];\n\t\t\thpmax = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\thp[i] = int.Parse(Console.ReadLine().Trim());\n\t\t\t\thpmax = Max(hpmax, hp[i]);\n\t\t\t}\n\t\t\tArray.Sort(hp);\n\t\t\tvar m = int.Parse(Console.ReadLine().Trim());\n\t\t\tdp1 = new long[hpmax + 1];\n\t\t\tdp2 = new long[hpmax + 1];\n\t\t\tvar Allc = 0; var singlec = 0;\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tvar mp = int.Parse(line[1]);\n\t\t\t\tvar target = line[2];\n\t\t\t\tvar damage = int.Parse(line[3]);\n\t\t\t\tif (mp == 0) { Console.WriteLine(0); goto next; }\n\t\t\t\tif (damage > 0)\n\t\t\t\t\tif (target == \"All\")\n\t\t\t\t\t{\n\t\t\t\t\t\tgetDptable(dp1, mp, damage);\n\t\t\t\t\t\tAllc++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgetDptable(dp2, mp, damage);\n\t\t\t\t\t\tsinglec++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (singlec == 0) { Console.WriteLine(LowerBound(dp1, hpmax)); goto next; }\n\t\t\tvar ssum = 0L;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tssum += LowerBound(dp2, hp[i]);\n\t\t\t}\n\t\t\tif (Allc == 0) { Console.WriteLine(ssum); goto next; }\n\t\t\tvar ans = getAns(n, ssum);\n\t\t\tConsole.WriteLine(ans);\n\t\tnext:;\n\t\t}\n\t}\n\tstatic long getAns(int n, long ssum)\n\t{\n\t\tvar ans = ssum; // all single\n\t\tans = Min(ans, LowerBound(dp1, hpmax));   // no single\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tvar tans = LowerBound(dp1, hp[i]);\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\ttans += LowerBound(dp2, hp[j] - dp1[tans]);\n\t\t\tans = Min(ans, tans);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic void getDptable(long[] dp, int mp, int damage)\n\t{\n\t\tfor (int i = mp; i < hpmax + 1; i++)\n\t\t\tdp[i] = Max(dp[i], dp[i - mp] + damage);\n\t}\n\tpublic static int LowerBound<T>(T[] arr, int start, int end, T value, IComparer<T> comparer)\n\t{\n\t\tint low = start;\n\t\tint high = end;\n\t\tint mid;\n\t\twhile (low < high)\n\t\t{\n\t\t\tmid = ((high - low) >> 1) + low;\n\t\t\tif (comparer.Compare(arr[mid], value) < 0) low = mid + 1;\n\t\t\telse high = mid;\n\t\t}\n\t\treturn low;\n\t}\n\tpublic static int LowerBound<T>(T[] arr, T value) where T : IComparable\n\t\t=> LowerBound(arr, 0, arr.Length, value, Comparer<T>.Default);\n\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def unbounded_knapsack(items, target_value)\n\ttable = [0]\n\ti = 0\n\thash = {0 => 0}\n\tloop {\n\t\ti += 1\n\t\ttable[i] = 0\n\t\titems.each{|c, v|\n\t\t\tnext if c > i\n\t\t\tx = table[i-c] + v\n\t\t\ttable[i] = x if x > table[i]\n\t\t}\n\t\thash[table[i]] ||= i\n\t\treturn hash.to_a if table[i] >= target_value\n\t}\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\tenemies = (1..n).map{gets.to_i}.sort\n\tm = gets.to_i\n\tsingle_spells = []\n\tall_spells = []\n\tzero = false\n\t(1..m).each{\n\t\t_, cost, type, damage = gets.chomp.split\n\t\tif cost == ?0\n\t\t\tif damage == ?0\n\t\t\t\tnext\n\t\t\telse\n\t\t\t\tzero = true\n\t\t\tend\n\t\tend\n\t\tnext if damage == ?0\n\t\t\n\t\tif type == 'Single'\n\t\t\tsingle_spells << [cost, damage].map(&:to_i)\n\t\telse\n\t\t\tall_spells << [cost, damage].map(&:to_i)\n\t\tend\n\t}\n\n\tif zero\n\t\tputs 0\n\t\tnext\n\tend\n\n\tsingle_cost = (single_spells.empty? ? [] : unbounded_knapsack(single_spells, enemies.max))\n\tall_cost = (all_spells.empty? ? [] : unbounded_knapsack(all_spells, enemies.max))\n\n\tif all_cost.empty?\n\t\tcost = 0\n\t\tenemies.each{|hp|\n\t\t\tcost += single_cost.bsearch_first_item{|v, c| v >= hp}[1]\n\t\t}\n\t\tputs cost\n\telsif single_cost.empty?\n\t\thp = enemies.max\n\t\tputs all_cost.bsearch_first_item{|v, c| v >= hp}[1]\n\telse\n\t\tmin = Float::INFINITY\n\t\t(0..enemies.max).each{|limit|\n\t\t\tall_cost.shift until all_cost[0][0] >= limit\n\t\t\tcost = all_cost[0][1]\n\t\t\tbreak if cost >= min\n\t\t\t\n\t\t\tl = 0\n\t\t\tenemies.each{|hp|\n\t\t\t\tif hp > limit\n\t\t\t\t\tl += 1 until single_cost[l][0] >= hp - limit\n\t\t\t\t\tcost += single_cost[l][1]\n\t\t\t\t\tbreak if cost >= min\n\t\t\t\tend\n\t\t\t}\n\t\t\tmin = cost if cost < min\n\t\t}\n\t\tp min\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "def unbounded_knapsack(items, target_value)\n\ttable = [0]\n\ti = 0\n\thash = {0 => 0}\n\tloop {\n\t\ti += 1\n\t\ttable[i] = 0\n\t\titems.each{|c, v|\n\t\t\tnext if c > i\n\t\t\tx = table[i-c] + v\n\t\t\ttable[i] = x if x > table[i]\n\t\t}\n\t\thash[table[i]] ||= i\n\t\treturn hash.to_a if table[i] >= target_value\n\t}\nend\n\ndef inverse_unbounded_knapsack(items, target_value)\n\ttable = [0]\n\tfor i in 1..target_value\n\t\ttable[i] = Float::INFINITY\n\t\titems.each{|c, v|\n\t\t\tnext if v > i\n\t\t\tx = table[i-v] + c\n\t\t\ttable[i] = x if x < table[i]\n\t\t}\n\tend\n\t(target_value-1).downto(0){|i|\n\t\ttable[i] = table[i+1] if table[i] > table[i+1]\n\t}\n\ttable\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\tenemies = gets.split.map &:to_i\n\tm = gets.to_i\n\tsingle_spells = []\n\tall_spells = []\n\t(1..m).each{\n\t\t_, cost, type, damage = gets.chomp.split\n\t\tif type == 'Single'\n\t\t\tsingle_spells << [cost, damage].map(&:to_i)\n\t\telse\n\t\t\tall_spells << [cost, damage].map(&:to_i)\n\t\tend\n\t}\n\t\n\tsingle_cost = unbounded_knapsack(single_spells, enemies.max)\n\tall_cost = unbounded_knapsack(all_spells, enemies.max)\n\t\n\tmin = Float::INFINITY\n\t(0..enemies.max).each{|limit|\n\t\tcost = 0\n\t\tenemies.each{|hp|\n\t\t\tif hp > limit\n\t\t\t\tcost += single_cost.find{|v, c| v >= hp - limit}[1]\n\t\t\tend\n\t\t}\n\t\tcost += all_cost.find{|v, c| v >= limit}[1]\n\t\tmin = cost if cost < min\n\t}\n\tp min\n}"
  },
  {
    "language": "Ruby",
    "code": "def unbounded_knapsack(items, target_value)\n\ttable = [0]\n\ti = 0\n\thash = {0 => 0}\n\tloop {\n\t\ti += 1\n\t\ttable[i] = 0\n\t\titems.each{|c, v|\n\t\t\tnext if c > i\n\t\t\tx = table[i-c] + v\n\t\t\ttable[i] = x if x > table[i]\n\t\t}\n\t\thash[table[i]] ||= i\n\t\treturn hash.to_a if table[i] >= target_value\n\t}\nend\n\ndef inverse_unbounded_knapsack(items, target_value)\n\ttable = [0]\n\tfor i in 1..target_value\n\t\ttable[i] = Float::INFINITY\n\t\titems.each{|c, v|\n\t\t\tnext if v > i\n\t\t\tx = table[i-v] + c\n\t\t\ttable[i] = x if x < table[i]\n\t\t}\n\tend\n\t(target_value-1).downto(0){|i|\n\t\ttable[i] = table[i+1] if table[i] > table[i+1]\n\t}\n\ttable\nend\n\nn = gets.to_i\nenemies = gets.split.map &:to_i\nm = gets.to_i\nsingle_spells = []\nall_spells = []\n(1..m).each{\n\t_, cost, type, damage = gets.chomp.split\n\tif type == 'Single'\n\t\tsingle_spells << [cost, damage].map(&:to_i)\n\telse\n\t\tall_spells << [cost, damage].map(&:to_i)\n\tend\n}\n\nsingle_cost = unbounded_knapsack(single_spells, enemies.max)\nall_cost = unbounded_knapsack(all_spells, enemies.max)\n\nmin = Float::INFINITY\n(0..enemies.max).each{|limit|\n\tcost = 0\n\tenemies.each{|hp|\n\t\tif hp > limit\n\t\t\tcost += single_cost.find{|v, c| v >= hp - limit}[1]\n\t\tend\n\t}\n\tcost += all_cost.find{|v, c| v >= limit}[1]\n\tmin = cost if cost < min\n}\np min"
  },
  {
    "language": "Ruby",
    "code": "def unbounded_knapsack(items, target_value)\n\ttable = [0]\n\ti = 0\n\thash = {0 => 0}\n\tloop {\n\t\ti += 1\n\t\ttable[i] = 0\n\t\titems.each{|c, v|\n\t\t\tnext if c > i\n\t\t\tx = table[i-c] + v\n\t\t\ttable[i] = x if x > table[i]\n\t\t}\n\t\thash[table[i]] ||= i\n\t\treturn hash.to_a if table[i] >= target_value\n\t}\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\tenemies = (1..n).map{gets.to_i}.sort\n\tm = gets.to_i\n\tsingle_spells = []\n\tall_spells = []\n\tzero = false\n\t(1..m).each{\n\t\t_, cost, type, damage = gets.chomp.split\n\t\tif cost == ?0\n\t\t\tif damage == ?0\n\t\t\t\tnext\n\t\t\telse\n\t\t\t\tzero = true\n\t\t\tend\n\t\tend\n\t\tnext if damage == ?0\n\t\t\n\t\tif type == 'Single'\n\t\t\tsingle_spells << [cost, damage].map(&:to_i)\n\t\telse\n\t\t\tall_spells << [cost, damage].map(&:to_i)\n\t\tend\n\t}\n\n\tif zero\n\t\tputs 0\n\t\tnext\n\tend\n\n\tsingle_cost = (single_spells.empty? ? [] : unbounded_knapsack(single_spells, enemies.max))\n\tall_cost = (all_spells.empty? ? [] : unbounded_knapsack(all_spells, enemies.max))\n\n\tif all_cost.empty?\n\t\tcost = 0\n\t\tenemies.each{|hp|\n\t\t\tcost += single_cost.find{|v, c| v >= hp}[1]\n\t\t}\n\t\tputs cost\n\telsif single_cost.empty?\n\t\thp = enemies.max\n\t\tputs all_cost.find{|v, c| v >= hp}[1]\n\telse\n\t\tmin = Float::INFINITY\n\t\t(0..enemies.max).each{|limit|\n\t\t\tall_cost.shift until all_cost[0][0] >= limit\n\t\t\tcost = all_cost[0][1]\n\t\t\tbreak if cost >= min\n\t\t\t\n\t\t\tl = 0\n\t\t\tenemies.each{|hp|\n\t\t\t\tif hp > limit\n\t\t\t\t\tl += 1 until single_cost[l][0] >= hp - limit\n\t\t\t\t\tcost += single_cost[l][1]\n\t\t\t\t\tbreak if cost >= min\n\t\t\t\tend\n\t\t\t}\n\t\t\tmin = cost if cost < min\n\t\t}\n\t\tp min\n\tend\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst INF = 1L << 50;\nconst P = 100000;\n\nstruct Magic {\n    int range; /* 0 : single, 1 : all */\n    long cost, damage;\n}\n\nint N, M;\nint[] HP;\nMagic[] Ms;\n\nbool input() {\n    scanf(\"%d\\n\", &N);\n    if (N == 0) return false;\n    HP = new int[N];\n    foreach (i; 0 .. N) {\n        scanf(\"%d\\n\", &HP[i]);\n    }\n    scanf(\"%d\\n\", &M);\n    Ms = new Magic[M];\n    foreach (i; 0 .. M) {\n        string name, target;\n        int mp, damage;\n        readf(\"%s %d %s %d\\n\", &name, &mp, &target, &damage);\n        if (damage >= P) damage = P;\n        Ms[i] = Magic(target == \"All\", mp, damage);\n    }\n    return true;\n}\n\nvoid solve() {\n    Magic[] As, Ss;\n    foreach (m; Ms) {\n        ( m.range ? As : Ss ) ~= m;\n    }\n\n    auto dp = new long[P + 1];\n    dp[] = INF;\n    dp[0] = 0;\n    foreach (i, a; As) {\n        foreach (j; 0 .. P + 1) {\n            if (j + a.damage > P) {\n                dp[P] = min(dp[P], dp[j] + a.cost);\n                continue;\n            }\n            dp[j + a.damage] = min(dp[j + a.damage], dp[j] + a.cost);\n        }\n    }\n\n    auto dp2 = new long[P + 1];\n    dp2[] = INF;\n    dp2[0] = 0;\n    foreach (s; Ss) {\n        foreach (i; 0 .. P + 1) {\n            if (i + s.damage > P) {\n                dp2[P] = min(dp2[P], dp2[i] + s.cost);\n                continue;\n            }\n            dp2[i + s.damage] = min(dp2[i + s.damage], dp2[i] + s.cost);\n        }\n    }\n\n    foreach_reverse (i; 0 .. P) {\n        dp2[i] = min(dp2[i], dp2[i + 1]);\n    }\n    //writeln(As);\n    //writeln(Ss);\n    //writefln(\"%(%s\\n%)\", dp);\n    //writefln(\"%(%s\\n%)\", dp2);\n\n    long ans = INF;\n    foreach (i; 0 .. P + 1) {\n        long x = dp[i];\n        foreach (j; 0 .. N) {\n            if (HP[j] <= i) continue;\n            x += dp2[ HP[j] - i ];\n        }\n        ans = min(ans, x);\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Magic {\n    int range; /* 0 : single, 1 : all */\n    int cost, damage;\n}\n\nint N, M;\nint[] HP;\nMagic[] Ms;\n\nbool input() {\n    scanf(\"%d\\n\", &N);\n    if (N == 0) return false;\n    HP = new int[N];\n    foreach (i; 0 .. N) {\n        scanf(\"%d\\n\", &HP[i]);\n    }\n    scanf(\"%d\\n\", &M);\n    Ms = new Magic[M];\n    foreach (i; 0 .. M) {\n        string name, target;\n        int mp, damage;\n        readf(\"%s %d %s %d\\n\", &name, &mp, &target, &damage);\n        Ms[i] = Magic(target == \"All\", mp, damage);\n    }\n    return true;\n}\n\nvoid solve() {\n    Magic[] As, Ss;\n    foreach (m; Ms) {\n        ( m.range ? As : Ss ) ~= m;\n    }\n\n    const P = 100000;\n    auto dp = new int[P + 1];\n    dp[] = int.max / 2;\n    dp[0] = 0;\n    foreach (i, a; As) {\n        foreach (j; 0 .. P + 1) {\n            if (j + a.damage > P) continue;\n            dp[j + a.damage] = min(dp[j + a.damage], dp[j] + a.cost);\n        }\n    }\n\n    auto dp2 = new int[P + 1];\n    dp2[] = int.max / 2;\n    dp2[0] = 0;\n    foreach (s; Ss) {\n        foreach (i; 0 .. P + 1) {\n            if (i + s.damage > P) continue;\n            dp2[i + s.damage] = min(dp2[i + s.damage], dp2[i] + s.cost);\n        }\n    }\n\n    foreach_reverse (i; 0 .. P) {\n        dp2[i] = min(dp2[i], dp2[i + 1]);\n    }\n\n    int ans = int.max / 2;\n    foreach (i; 0 .. P + 1) {\n        int x = dp[i];\n        foreach (j; 0 .. N) {\n            if (HP[j] <= i) continue;\n            x += dp2[ HP[j] - i ];\n        }\n        ans = min(ans, x);\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        h = LI()\n        hm = max(h)\n        m = I()\n        ms = []\n        ma = []\n        for _ in range(m):\n            nama,mp,target,damege = LS()\n            mp = int(mp)\n            damege = int(damege)\n            if damege == 0:\n                continue\n            if mp == 0:\n                return 0\n            if target == 'All':\n                ma.append((mp,damege))\n            else:\n                ms.append((mp,damege))\n        ds = [inf] * (hm+1)\n        ds[0] = 0\n        for mp, dm in ms:\n            for i in range(dm,hm+1):\n                if ds[i] > mp + ds[i-dm]:\n                    ds[i] = mp + ds[i-dm]\n            t = min(ds[-dm+1:])\n            if ds[-1] > t + dm:\n                ds[-1] = t + dm\n\n        da = [inf] * (hm+1)\n        da[0] = 0\n        for mp, dm in ma:\n            for i in range(dm,hm+1):\n                if da[i] > mp + da[i-dm]:\n                    da[i] = mp + da[i-dm]\n            t = min(da[-dm+1:])\n            if da[-1] > t + dm:\n                da[-1] = t + dm\n        for i in range(hm-1,-1,-1):\n            if ds[i] > ds[i+1]:\n                ds[i] = ds[i+1]\n            if da[i] > da[i+1]:\n                da[i] = da[i+1]\n        mm = r = inf\n        for i in range(hm,-1,-1):\n            if mm <= da[i]:\n                continue\n            mm = tp = da[i]\n            for hi in h:\n                if hi > i:\n                    tp += ds[hi-i]\n            if r > tp:\n                r = tp\n        return r\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        h = [I() for _ in range(n)]\n        hm = max(h)\n        m = I()\n        ms = []\n        ma = []\n        zf = False\n        for _ in range(m):\n            nama,mp,target,damege = LS()\n            mp = int(mp)\n            damege = int(damege)\n            if damege == 0:\n                continue\n            if mp == 0:\n                zf = True\n                continue\n            if target == 'All':\n                ma.append((mp,damege))\n            else:\n                ms.append((mp,damege))\n        if zf:\n            return 0\n        ds = [inf] * (hm+1)\n        ds[0] = 0\n        for mp, dm in ms:\n            for i in range(dm,hm+1):\n                if ds[i] > mp + ds[i-dm]:\n                    ds[i] = mp + ds[i-dm]\n            if dm < 2:\n                continue\n            t = min(ds[-dm+1:])\n            if ds[-1] > t + mp:\n                ds[-1] = t + mp\n\n        da = [inf] * (hm+1)\n        da[0] = 0\n        for mp, dm in ma:\n            for i in range(dm,hm+1):\n                if da[i] > mp + da[i-dm]:\n                    da[i] = mp + da[i-dm]\n            if dm < 2:\n                continue\n            t = min(da[-dm+1:])\n            if da[-1] > t + mp:\n                da[-1] = t + mp\n        for i in range(hm-1,-1,-1):\n            if ds[i] > ds[i+1]:\n                ds[i] = ds[i+1]\n            if da[i] > da[i+1]:\n                da[i] = da[i+1]\n        mm = r = inf\n        for i in range(hm,-1,-1):\n            if mm <= da[i]:\n                continue\n            mm = tp = da[i]\n            for hi in h:\n                if hi > i:\n                    tp += ds[hi-i]\n            if r > tp:\n                r = tp\n        return r\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 10\nMOD = 10 ** 9 + 7\n\ndef solve(N):\n    HP = [int(input()) for _ in range(N)]\n    M = int(input())\n    all_magic = []\n    single_magic = []\n    zero = False\n    for _ in range(M):\n        a = input().split()\n        if zero:\n            continue\n        if a[2] == 'Single':\n            mp = int(a[1])\n            dam = int(a[3])\n            if mp == 0 and dam > 0:\n                zero = True\n                continue\n            single_magic.append((mp,dam))\n        else:\n            mp = int(a[1])\n            dam = int(a[3])\n            if mp == 0 and dam > 0:\n                zero = True\n                continue\n            all_magic.append((mp,dam))\n    if zero:\n        print(0)\n        return\n\n    MAXHP = max(HP) + 5\n    dp_single = [INF] * MAXHP\n    dp_single[0] = 0\n    for p,damage in single_magic:\n        for i in range(min(damage,MAXHP)):\n            dp_single[i] = min(dp_single[i],p)\n        for i in range(damage,MAXHP):\n            dp_single[i] = min(dp_single[i],dp_single[i - damage] + p)\n    for i in range(MAXHP - 2,-1,-1):\n        dp_single[i] = min(dp_single[i],dp_single[i + 1])\n\n    dp_all = [INF] * MAXHP\n    dp_all[0] = 0\n    for p,damage in all_magic:\n        for i in range(min(damage,MAXHP)):\n            dp_all[i] = min(dp_all[i],p)\n        for i in range(damage,MAXHP):\n            dp_all[i] = min(dp_all[i],dp_all[i - damage] + p)\n    \n    ans = INF\n    for all_dam in range(MAXHP):\n        ret = dp_all[all_dam]\n        if ret == INF:\n            continue\n        for h in HP:\n            h -= all_dam\n            if h > 0:\n                ret += dp_single[h]\n        ans = min(ans,ret)\n    print(ans)\n\ndef main():\n    while True:\n        N = int(input())\n        if N == 0:\n            return\n        solve(N)\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        h = [I() for _ in range(n)]\n        hm = max(h)\n        m = I()\n        ms = []\n        ma = []\n        zf = False\n        for _ in range(m):\n            nama,mp,target,damege = LS()\n            mp = int(mp)\n            damege = int(damege)\n            if damege == 0:\n                continue\n            if mp == 0:\n                zf = True\n                continue\n            if target == 'All':\n                ma.append((mp,damege))\n            else:\n                ms.append((mp,damege))\n        if zf:\n            return 0\n        ds = [inf] * (hm+1)\n        ds[0] = 0\n        for mp, dm in ms:\n            for i in range(dm,hm+1):\n                if ds[i] > mp + ds[i-dm]:\n                    ds[i] = mp + ds[i-dm]\n            t = min(ds[-dm+1:])\n            if ds[-1] > t + dm:\n                ds[-1] = t + dm\n\n        da = [inf] * (hm+1)\n        da[0] = 0\n        for mp, dm in ma:\n            for i in range(dm,hm+1):\n                if da[i] > mp + da[i-dm]:\n                    da[i] = mp + da[i-dm]\n            t = min(da[-dm+1:])\n            if da[-1] > t + dm:\n                da[-1] = t + dm\n        for i in range(hm-1,-1,-1):\n            if ds[i] > ds[i+1]:\n                ds[i] = ds[i+1]\n            if da[i] > da[i+1]:\n                da[i] = da[i+1]\n        mm = r = inf\n        for i in range(hm,-1,-1):\n            if mm <= da[i]:\n                continue\n            mm = tp = da[i]\n            for hi in h:\n                if hi > i:\n                    tp += ds[hi-i]\n            if r > tp:\n                r = tp\n        return r\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\nstruct Magic {\n    mp: i32, damage: usize,\n}\nfn main() {\n    loop {\n        let_all!(n: usize);\n        if n == 0 {\n            return\n        }\n        let mut monsters: Vec<usize> = Vec::with_capacity(n);\n        for i in 0 .. n {\n            let_all!(hp: usize);\n            monsters.push(hp);\n        }\n        monsters.sort();\n        let_all!(m: usize);\n        let mut for_all = Vec::<Magic>::new();\n        let mut for_single = Vec::<Magic>::new();\n        for _ in 0 .. m {\n            let_all!(name: String, mp: i32, target: String, damage:usize);\n            match &target[..] {\n                \"All\" => for_all.push(Magic{mp: mp, damage: damage}),\n                \"Single\" => for_single.push(Magic{mp: mp, damage: damage}),\n                _ => unreachable!()\n            }\n        }\n        let max_health = monsters[n - 1];\n        let mut min_mp_for_all: Vec<i32> = vec![-1; max_health + 1];\n        let mut min_mp_for_single: Vec<i32> = vec![-1; max_health + 1];\n        min_mp_for_all[0] = 0;\n        min_mp_for_single[0] = 0;\n        for &a in &for_all {\n            for i in 0 .. max_health {\n                if min_mp_for_all[i] != -1 {\n                    let j = min(i + a.damage, max_health);\n                    if min_mp_for_all[j] == -1 || min_mp_for_all[j] > min_mp_for_all[i] + a.mp {\n                        min_mp_for_all[j] = min_mp_for_all[i] + a.mp;\n                    }\n                }\n            }\n        }\n        for &s in &for_single {\n            for i in 0 .. max_health {\n                if min_mp_for_single[i] != -1 {\n                    let j = min(i + s.damage, max_health);\n                    if min_mp_for_single[j] == -1 || min_mp_for_single[j] > min_mp_for_single[i] + s.mp {\n                        min_mp_for_single[j] = min_mp_for_single[i] + s.mp;\n                    }\n                }\n            }\n        }\n        let single = min_mp_for_single.len();\n        if min_mp_for_single[max_health] == -1 {\n            min_mp_for_single[max_health] = min_mp_for_all[max_health];\n        }\n        for i in 1 .. min_mp_for_single.len() {\n            if min_mp_for_single[single - i - 1] == -1 || min_mp_for_single[single - i - 1] > min_mp_for_single[single - i]{\n                min_mp_for_single[single - i - 1] = min_mp_for_single[single - i];\n            }\n        }\n        let mut min_mp: i32 = std::i32::MAX;\n        for i in 0 .. max_health + 1 {\n            if min_mp_for_all[i] != -1 {\n                let mut temp = min_mp_for_all[i];\n                for j in 0..n{\n                    if monsters[n - j - 1] > i {\n                        temp += min_mp_for_single[monsters[n - j - 1] - i]\n                    }else {\n                        break\n                    }\n                }\n                if min_mp > temp {\n                    min_mp = temp;\n                }\n            }\n        }\n        println!(\"{}\", min_mp);\n    }\n}\n\n"
  }
]