[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)b - *(int *)a);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int N, A, B;\n        scanf(\"%d %d %d\", &N, &A, &B);\n        int *monsters = (int *)malloc(N * sizeof(int));\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &monsters[i]);\n        }\n\n        qsort(monsters, N, sizeof(int), compare);\n\n        long long total_power = 0;\n        int i = 0;\n        while (i < N) {\n            if (B <= A) {\n                total_power += (long long)monsters[i] * B;\n                break;\n            }\n            if (monsters[i] <= 0) {\n                i++;\n                continue;\n            }\n            int diff = monsters[i] - (i + 1 < N ? monsters[i + 1] : 0);\n            if (diff > 0) {\n                int use_spell = diff;\n                if ((long long)use_spell * A < B) {\n                    total_power += (long long)use_spell * A;\n                    for (int j = 0; j <= i; j++) {\n                        monsters[j] -= use_spell;\n                    }\n                } else {\n                    total_power += B;\n                    for (int j = 0; j <= i; j++) {\n                        monsters[j] -= 1;\n                    }\n                }\n            } else {\n                total_power += B;\n                for (int j = 0; j <= i; j++) {\n                    monsters[j] -= 1;\n                }\n            }\n        }\n        printf(\"%lld\\n\", total_power);\n        free(monsters);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int N, A, B;\n        cin >> N >> A >> B;\n        vector<int> H(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> H[i];\n        }\n        \n        priority_queue<int> pq;\n        for (int h : H) {\n            pq.push(h);\n        }\n        \n        int res = 0;\n        while (true) {\n            int max_h = pq.top();\n            if (max_h <= 0) break;\n            \n            if (B >= A * pq.size()) {\n                res += max_h * A;\n                break;\n            }\n            \n            pq.pop();\n            max_h -= B;\n            res += A;\n            pq.push(max_h);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt();\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n            for (int i = 0; i < N; i++) {\n                maxHeap.add(scanner.nextInt());\n            }\n            \n            long totalMagic = 0;\n            while (!maxHeap.isEmpty()) {\n                int current = maxHeap.poll();\n                if (current == 0) {\n                    continue;\n                }\n                if (maxHeap.isEmpty()) {\n                    totalMagic += Math.min(A, B);\n                    break;\n                }\n                int next = maxHeap.peek();\n                int diff = current - next;\n                if (diff > 0) {\n                    int use = Math.min(diff, current);\n                    current -= use;\n                    totalMagic += (long) use * A;\n                    if (current > 0) {\n                        maxHeap.add(current);\n                    }\n                } else {\n                    int use = 1;\n                    current -= use;\n                    totalMagic += (long) use * B;\n                    if (current > 0) {\n                        maxHeap.add(current);\n                    }\n                }\n            }\n            System.out.println(totalMagic);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:10:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MonsterSpellCaster {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int monsters = scanner.nextInt();\n            int[] hitPoints = new int[monsters];\n            int[] singleSpells = new int[monsters];\n            int aoeSpellPower = 0;\n\n            for (int i = 0; i < monsters; i++) {\n                hitPoints[i] = scanner.nextInt();\n            }\n\n            for (int i = 0; i < monsters; i++) {\n                singleSpells[i] = scanner.nextInt();\n            }\n\n            aoeSpellPower = scanner.nextInt();\n\n            System.out.println(minimumMagicPower(hitPoints, singleSpells, aoeSpellPower));\n        }\n    }\n\n    private static int minimumMagicPower(int[] hitPoints, int[] singleSpells, int aoeSpellPower) {\n        int totalHitPoints = Arrays.stream(hitPoints).sum();\n        int minPower = Integer.MAX_VALUE;\n\n        for (int aoeSpells = 0; aoeSpells <= (totalHitPoints + aoeSpellPower - 1) / aoeSpellPower; aoeSpells++) {\n            int remainingHitPoints = totalHitPoints - aoeSpells * aoeSpellPower;\n            if (remainingHitPoints <= 0) {\n                minPower = Math.min(minPower, aoeSpells * aoeSpellPower);\n                continue;\n            }\n\n            int singleSpellPower = 0;\n            for (int i = 0; i < hitPoints.length; i++) {\n                int requiredSpellPower = Math.max(0, remainingHitPoints > hitPoints[i] ? 0 : hitPoints[i] - remainingHitPoints);\n                singleSpellPower += requiredSpellPower * singleSpells[i];\n            }\n\n            minPower = Math.min(minPower, aoeSpells * aoeSpellPower + singleSpellPower);\n        }\n\n        return minPower;\n    }\n}",
    "timestamp": "2025-08-05 21:10:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_MONSTERS 15\n#define MAX_SPELLS 10\n\nint min_magic_power(int monsters[], int monster_count, int single_spells[], int single_spell_count, \n                    int aoe_spells[], int aoe_spell_count) {\n    int dp[1 << MAX_MONSTERS];\n    for (int i = 0; i < (1 << monster_count); i++) {\n        dp[i] = INT_MAX;\n    }\n    dp[0] = 0;\n\n    for (int state = 0; state < (1 << monster_count); state++) {\n        if (dp[state] == INT_MAX) continue;\n\n        // Try single target spells\n        for (int i = 0; i < single_spell_count; i++) {\n            for (int j = 0; j < monster_count; j++) {\n                if (!(state & (1 << j))) {\n                    int new_state = state;\n                    int remaining_hp = monsters[j] - single_spells[i];\n                    if (remaining_hp <= 0) {\n                        new_state |= (1 << j);\n                    }\n                    dp[new_state] = fmin(dp[new_state], dp[state] + single_spells[i]);\n                }\n            }\n        }\n\n        // Try AOE spells\n        for (int i = 0; i < aoe_spell_count; i++) {\n            int new_state = state;\n            for (int j = 0; j < monster_count; j++) {\n                if (!(state & (1 << j))) {\n                    int remaining_hp = monsters[j] - aoe_spells[i];\n                    if (remaining_hp <= 0) {\n                        new_state |= (1 << j);\n                    }\n                }\n            }\n            dp[new_state] = fmin(dp[new_state], dp[state] + aoe_spells[i]);\n        }\n    }\n\n    return dp[(1 << monster_count) - 1];\n}\n\nint main() {\n    int test_cases;\n    scanf(\"%d\", &test_cases);\n\n    while (test_cases--) {\n        int monster_count, single_spell_count, aoe_spell_count;\n        scanf(\"%d %d %d\", &monster_count, &single_spell_count, &aoe_spell_count);\n\n        int monsters[MAX_MONSTERS];\n        for (int i = 0; i < monster_count; i++) {\n            scanf(\"%d\", &monsters[i]);\n        }\n\n        int single_spells[MAX_SPELLS];\n        for (int i = 0; i < single_spell_count; i++) {\n            scanf(\"%d\", &single_spells[i]);\n        }\n\n        int aoe_spells[MAX_SPELLS];\n        for (int i = 0; i < aoe_spell_count; i++) {\n            scanf(\"%d\", &aoe_spells[i]);\n        }\n\n        int result = min_magic_power(monsters, monster_count, single_spells, single_spell_count, \n                                     aoe_spells, aoe_spell_count);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nint minimumMagicPower(vector<int>& monsters, vector<int>& singleSpells, vector<int>& areaSpells) {\n    int n = monsters.size();\n    int minPower = numeric_limits<int>::max();\n\n    for (int i = 0; i < (1 << areaSpells.size()); i++) {\n        vector<int> currentMonsters = monsters;\n        int currentPower = 0;\n\n        // Apply area spells\n        for (int j = 0; j < areaSpells.size(); j++) {\n            if (i & (1 << j)) {\n                for (int& monster : currentMonsters) {\n                    monster = max(0, monster - areaSpells[j]);\n                }\n                currentPower += areaSpells[j];\n            }\n        }\n\n        // Apply single target spells\n        for (int k = 0; k < currentMonsters.size(); k++) {\n            if (currentMonsters[k] > 0) {\n                int minSingleSpell = numeric_limits<int>::max();\n                for (int spell : singleSpells) {\n                    if (spell >= currentMonsters[k]) {\n                        minSingleSpell = min(minSingleSpell, spell);\n                    }\n                }\n                if (minSingleSpell == numeric_limits<int>::max()) {\n                    currentPower = numeric_limits<int>::max();\n                    break;\n                }\n                currentPower += minSingleSpell;\n                currentMonsters[k] = 0;\n            }\n        }\n\n        if (all_of(currentMonsters.begin(), currentMonsters.end(), [](int x) { return x == 0; })) {\n            minPower = min(minPower, currentPower);\n        }\n    }\n\n    return minPower == numeric_limits<int>::max() ? -1 : minPower;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n\n        vector<int> monsters(n);\n        for (int& monster : monsters) {\n            cin >> monster;\n        }\n\n        vector<int> singleSpells(m);\n        for (int& spell : singleSpells) {\n            cin >> spell;\n        }\n\n        vector<int> areaSpells(k);\n        for (int& spell : areaSpells) {\n            cin >> spell;\n        }\n\n        int result = minimumMagicPower(monsters, singleSpells, areaSpells);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_magic_power(datasets):\n    def defeat_monsters(hp, single_power, all_power):\n        n = len(hp)\n        hp.sort(reverse=True)\n        dp = [float('inf')] * (max(hp) + 1)\n        dp[0] = 0\n\n        for i in range(1, max(hp) + 1):\n            if i >= single_power:\n                dp[i] = min(dp[i], dp[i - single_power] + single_power)\n            dp[i] = min(dp[i], dp[max(i - all_power, 0)] + all_power)\n\n        total_magic = 0\n        for h in hp:\n            total_magic += dp[h]\n\n        return total_magic\n\n    results = []\n    for data in datasets:\n        hp, single_power, all_power = data\n        results.append(defeat_monsters(hp, single_power, all_power))\n\n    return results\n\n# Example usage:\n# datasets = [([10, 20, 30], 5, 15), ([15, 25, 35], 10, 20)]\n# print(min_magic_power(datasets))  # Output: [30, 50]",
    "timestamp": "2025-08-13 05:17:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MagicSpells {\n\n    public static void main(String[] args) {\n        // Example input\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        while (datasets-- > 0) {\n            int n = scanner.nextInt(); // Number of monsters\n            int m = scanner.nextInt(); // Number of spells\n            int[] monsterHP = new int[n];\n            for (int i = 0; i < n; i++) {\n                monsterHP[i] = scanner.nextInt();\n            }\n            Spell[] spells = new Spell[m];\n            for (int i = 0; i < m; i++) {\n                int type = scanner.nextInt(); \n                int damage = scanner.nextInt();\n                int mp = scanner.nextInt();\n                spells[i] = new Spell(type, damage, mp);\n            }\n            System.out.println(minimumMagicPower(monsterHP, spells));\n        }\n        scanner.close();\n    }\n\n    static int minimumMagicPower(int[] monsterHP, Spell[] spells) {\n        int n = monsterHP.length;\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        \n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (dp[mask] == Integer.MAX_VALUE) continue;\n            for (Spell spell : spells) {\n                if (spell.type == 0) {\n                    for (int i = 0; i < n; i++) {\n                        if ((mask & (1 << i)) == 0) {\n                            int newMask = mask;\n                            if (monsterHP[i] <= spell.damage) {\n                                newMask |= (1 << i);\n                            }\n                            dp[newMask] = Math.min(dp[newMask], dp[mask] + spell.mp);\n                        }\n                    }\n                } else {\n                    int newMask = mask;\n                    for (int i = 0; i < n; i++) {\n                        if ((mask & (1 << i)) == 0 && monsterHP[i] <= spell.damage) {\n                            newMask |= (1 << i);\n                        }\n                    }\n                    dp[newMask] = Math.min(dp[newMask], dp[mask] + spell.mp);\n                }\n            }\n        }\n        \n        return dp[(1 << n) - 1];\n    }\n    \n    static class Spell {\n        int type, damage, mp;\n        \n        Spell(int type, int damage, int mp) {\n            this.type = type;\n            this.damage = damage;\n            this.mp = mp;\n        }\n    }\n}",
    "timestamp": "2025-08-13 05:17:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_MONSTERS 1000\n#define MAX_HIT_POINTS 1000\n\ntypedef struct {\n    int singleTargetCost;\n    int allTargetCost;\n} Spell;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint minMagicPower(int numMonsters, int hitPoints[], Spell spell) {\n    int dp[MAX_MONSTERS + 1][MAX_HIT_POINTS + 1];\n    for (int i = 0; i <= numMonsters; i++) {\n        for (int j = 0; j <= MAX_HIT_POINTS; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n\n    for (int i = 0; i <= numMonsters; i++) {\n        dp[i][0] = 0;\n    }\n\n    for (int i = 1; i <= numMonsters; i++) {\n        for (int j = 0; j <= MAX_HIT_POINTS; j++) {\n            if (j >= hitPoints[i - 1] && dp[i - 1][j - hitPoints[i - 1]] != INT_MAX) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - hitPoints[i - 1]] + spell.singleTargetCost);\n            }\n            dp[i][j] = min(dp[i][j], dp[i - 1][j] + spell.allTargetCost);            \n        }\n    }\n\n    int minCost = INT_MAX;\n    for (int j = 0; j <= MAX_HIT_POINTS; j++) {\n        if (dp[numMonsters][j] != INT_MAX && j >= 1) {\n            minCost = min(minCost, dp[numMonsters][j]);\n        }\n    }\n    return minCost;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        int numMonsters;\n        scanf(\"%d\", &numMonsters);\n\n        int hitPoints[MAX_MONSTERS];\n        for (int i = 0; i < numMonsters; i++) {\n            scanf(\"%d\", &hitPoints[i]);\n        }\n\n        Spell spell;\n        scanf(\"%d %d\", &spell.singleTargetCost, &spell.allTargetCost);\n\n        int minMagic = minMagicPower(numMonsters, hitPoints, spell);\n        printf(\"%d\\n\", minMagic);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:18:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_monster_battle(monsters, spells):\n    def can_defeat_monsters(magic_power):\n        dp = [False] * (magic_power + 1)\n        dp[0] = True\n        \n        for spell_cost, single_damage, all_damage in spells:\n            for power in range(magic_power, spell_cost - 1, -1):\n                if dp[power - spell_cost]:\n                    remaining_monsters = monsters.copy()\n                    \n                    # Single target spell\n                    max_single_damage = max(single_damage, 0)\n                    for i in range(len(remaining_monsters)):\n                        remaining_monsters[i] -= max_single_damage\n                    \n                    # All monsters spell\n                    remaining_monsters = [max(0, monster - all_damage) for monster in remaining_monsters]\n                    \n                    if all(monster <= 0 for monster in remaining_monsters):\n                        dp[power] = True\n        \n        return any(dp)\n\n    left, right = 0, 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if can_defeat_monsters(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        monsters = list(map(int, input().split()))\n        spells = []\n        \n        for _ in range(m):\n            c, d, a = map(int, input().split())\n            spells.append((c, d, a))\n        \n        result = solve_monster_battle(monsters, spells)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:18:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    T = int(data[idx])\n    idx += 1\n    for _ in range(T):\n        N, A, B = map(int, data[idx:idx+3])\n        idx +=3\n        monsters = list(map(int, data[idx:idx+N]))\n        idx +=N\n        \n        max_heap = []\n        for hp in monsters:\n            heapq.heappush(max_heap, -hp)\n        \n        res = 0\n        while True:\n            current = -heapq.heappop(max_heap)\n            if current == 0:\n                break\n            next_current = current - B\n            if next_current <= 0:\n                res += B\n                break\n            if not max_heap:\n                # Only one monster left\n                hits = (current + A -1) // A\n                res += hits * B\n                break\n            next_monster = -max_heap[0]\n            if next_monster <= B:\n                # Use single target\n                hits = (current + A -1) // A\n                res += hits * B\n                break\n            else:\n                # Use AOE\n                res += B\n                heapq.heappush(max_heap, -(current - B))\n        print(res)\n\nsolve()",
    "timestamp": "2025-08-13 05:18:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n    \n    while (numDatasets--) {\n        int numMonsters, singleTargetCost, allTargetCost;\n        cin >> numMonsters >> singleTargetCost >> allTargetCost;\n        \n        vector<int> hitPoints(numMonsters);\n        for (int i = 0; i < numMonsters; ++i) {\n            cin >> hitPoints[i];\n        }\n        \n        // Dynamic Programming array to store minimum cost to defeat i monsters\n        // where i is the index of the monster in sorted order of hitPoints\n        vector<int> dp(numMonsters + 1, numeric_limits<int>::max());\n        dp[0] = 0;\n\n        for (int i = 1; i <= numMonsters; ++i) {\n            // Use single target spell on i-th monster\n            if (dp[i - 1] != numeric_limits<int>::max()) {\n                dp[i] = min(dp[i], dp[i - 1] + hitPoints[i - 1] * singleTargetCost);\n            }\n            \n            // Use all target spell on all monsters so far\n            dp[i] = min(dp[i], dp[0] + allTargetCost);\n        }\n        \n        cout << dp[numMonsters] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:18"
  }
]