[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 2505, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nll dp[MX][MX][2];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n), b(n);\n  rep(i,n) scanf(\"%d%d\",&a[i],&b[i]);\n  vi id(n);\n  rep(i,n) id[i] = i;\n  sort(rng(id),[&](int i, int j) { return a[i]+b[i] > a[j]+b[j];});\n  int m = n/2;\n  rep(i,m+1)rep(j,m+1)rep(k,2) dp[i][j][k] = LINF;\n  dp[0][0][0] = 0;\n  rep(i,n) {\n    ll x = a[id[i]];\n    ll y = b[id[i]];\n    ll w = x+y;\n    rep(k,2)rep(l,m+1) {\n      int r = i-k-l;\n      if (r < 0) break;\n      if (!k) {\n        mins(dp[l][r][k+1], dp[l][r][k]+w*m);\n      }\n      mins(dp[l+1][r][k], dp[l][r][k]+w*l+y);\n      mins(dp[l][r+1][k], dp[l][r][k]+w*r+x);\n    }\n  }\n  cout<<dp[m][m][n&1]<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//memory test\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, d;\n\tinline int operator<(const seg &a) const {return d > a.d;}\n} s[10010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[3510][3510][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].d = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tm = n >> 1;\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[i][j][0] = f[i][j][1] = inf;\n\tf[0][0][0] = 0;\n\t\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m && i+j < n; ++j)\n\t\t\tfor (int k = 0; k <= 1 && i+j+k < n; ++k)\n\t\t\t{\n\t\t\t\tconst ll tmp = f[i][j][k]; const seg p = s[i+j+k+1];\n\t\t\t\tif (i < m)\tf[i+1][j][k] = min(f[i+1][j][k], tmp + p.r + i*p.d);\n\t\t\t\tif (j < m)\tf[i][j+1][k] = min(f[i][j+1][k], tmp + p.l + j*p.d);\n\t\t\t\tif (!k)\t\tf[i][j][k|1] = min(f[i][j][k|1], tmp + m * p.d);\n\t\t\t}\n\t\n\tcout << f[m][m][n&1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define l first\n#define r second\n\nint main() {\n    //ifstream cin(\"testF.in\");\n    int n; cin >> n;\n\n    vector<pair<int, int>> a(n);\n    for(int i = 0; i < n; ++i)\n        cin >> a[i].l >> a[i].r;\n    \n    \n    sort(a.begin(), a.end(), [&] (pair<int, int> A, pair<int, int> B) {\n        return (A.l + A.r) > (B.l + B.r);\n    });\n    \n    int ans = 1e9;\n\n    for(int fixed = n - 1; fixed < n; ++fixed) {\n        vector<int> dp(n + 1, 1e9);\n        int many = 0;\n        dp[0] = 0;\n        for(int i = 0; i < n; ++i) {\n            if(fixed == i)\n                continue;\n            many++;\n            int len = a[i].r + a[i].l;\n            vector<int> newDp(n + 1, 1e9);\n            newDp[0] = dp[0] + a[i].r + a[fixed].l + (many - 1) * len;\n            for(int j = 0; j < many; ++j) {\n                newDp[j + 1] = min(dp[j + 1] + a[i].r + a[fixed].l + (many - 1 - (j + 1)) * len, dp[j] + a[i].l + a[fixed].r + j * len);\n            }\n            dp = newDp;\n        }\n        int temp = 1e9;\n        for(int i = 0; i <= n; ++i)\n            temp = min(temp, dp[i]);\n        ans = min(ans, temp);\n    }\n    \n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define VL vector<long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint from[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    int id=-1;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x){\n                dp[x][y]=dp[x-1][y]+(x-1LL)*p[i].F+(p[i].S+offset);\n                from[x][y]=0;\n            }\n            else dp[x][y]=INF;\n            if(y){\n                if(dp[x][y]>dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset)){\n                    dp[x][y]=dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset);\n                    from[x][y]=1;\n                }\n            }\n            if(i==N-1){\n                if(res>dp[x][y]){\n                    res=dp[x][y];\n                    id=x;\n                }\n            }\n        }\n    }\n    VPII left,right;\n    int x=id,y=N-id;\n    for(int i=N-1;i>=0;i--){\n        if(from[x][y]){\n            right.PB(MP(p[i].F,p[i].S+offset));\n            y--;\n        }\n        else{\n            left.PB(MP(p[i].F,p[i].S+offset));\n            x--;\n        }\n    }\n    VL d;\n    LL now=0;\n    REP(i,SZ(left)){\n        d.PB(left[i].S+now);\n        now+=left[i].F;\n    }\n    now=0;\n    REP(i,SZ(right)){\n        d.PB(-(right[i].F-right[i].S)-now);\n        now+=right[i].F;\n    }\n    sort(ALL(d));\n    LL an=0;\n    for(int i=0,j=SZ(d)-1;j>i;j--,i++)an+=d[j]-d[i];\n    return an;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    int SEG=10;\n    LL res=INF;\n    REP(i,SEG){\n        res=min(res,f(ll+(LL)(rr-ll)*i/(SEG-1)));\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  assert(n > 100);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  // {\n  //   vl dp(1,LINF);\n  //   dp[0] = 0;\n  //   vl d;\n  //   rep(k,n) {\n  //     d = vl(k+2,LINF);\n  //     swap(dp,d);\n  //     ll l = p[k].fi, r = p[k].se, w = r+l;\n  //     rep(j,k+1) {\n  //       int g = k-j;\n  //       mins(dp[j], d[j]+r+w*g);\n  //       mins(dp[j+1], d[j]+l+w*j);\n  //     }\n  //   }\n  // }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, s;\n\tinline int operator<(const seg &a) const {return s > a.s;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[2510][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n; m = n >> 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].s = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tfor (int i = 1; i <= m; ++i)\n\t\tf[i][0] = inf;\n\t\n\tint x = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tx ^= 1;\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[j][x] = inf;\n\t\tfor (int j = 0; j<i && j<=m; ++j)\n\t\t{\n\t\t\tconst int k = i-j-1;\n\t\t\tif (j < m)\n\t\t\t\tf[j+1][x] = min(f[j+1][x], f[j][x^1] + s[i].r + s[i].s * j);\n\t\t\tif (k < m)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][x^1] + s[i].l + s[i].s * k);\n\t\t\tif (n & 1)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][x^1] + (n-1)/2 * s[i].s);\n\t\t}\n\t}\n\t\n\tcout << f[m][x] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x)dp[x][y]=dp[x-1][y]+(x-1)*p[i].F+(p[i].S-offset);\n            else dp[x][y]=INF;\n            if(y)dp[x][y]=min(dp[x][y],dp[x][y-1]+y*p[i].F-(p[i].S-offset));\n            if(i==N-1)res=min(res,dp[x][y]);\n        }\n    }\n    return res;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    cout<<f(0)<<endl;\n    /*\n    while(ll<rr){\n        int mm1=(rr-ll)/2+ll;\n        int mm2=mm1+1;\n        LL v1=f(mm1);\n        LL v2=f(mm2);\n        if(v1>v2)ll=mm2;\n        else rr=mm1;\n    }\n    cout<<f(ll)<<endl;*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    ll len=l[idx]+r[idx];\n    if(i==n-1&&n&1)l[idx]=0,r[idx]=0;\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+len*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+len*(i-j)+l[idx]);\n    }\n  }\n  ll suml=0,sumr=0;\n  rep(i,0,n){\n    suml+=l[i];\n    sumr+=r[i];\n  }\n  //debug(dp,n+1,n+1);\n  cout<<min({*min_element(ALL(dp[n])),dp[n][0],dp[n][n]-sumr})<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[5010][5010][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst int m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\tconst int r = i - l;\n\t\t\trep(k, m + 1) {\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n - 1) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\ntemplate<int... Sizes>\nstruct MultidimensionalIndex;\ntemplate<>\nstruct MultidimensionalIndex<> {\n\tMultidimensionalIndex() {}\n\tint getTotalSize() const { return 1; }\n\tint getIndexAcc(int acc) const { return acc; }\n};\ntemplate<int Head, int... Tail>\nstruct MultidimensionalIndex<Head, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tenum { size = Head };\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(TailT... tail) : Base(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\ntemplate<int... Tail>\nstruct MultidimensionalIndex<0, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tconst int size;\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(int head, TailT... tail) : size(head), MultidimensionalIndex<Tail...>(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\n\ntemplate<typename Val, int... Sizes>\nstruct DP : MultidimensionalIndex<Sizes...> {\n\tusing Base = MultidimensionalIndex<Sizes...>;\n\tstd::vector<Val> dp;\n\ttemplate<typename... SizesT>\n\tDP(Val init, SizesT... sizes) : Base(sizes...), dp(Base::getTotalSize(), init) {}\n\ttemplate<typename... SizesT>\n\tVal &operator()(SizesT... indices) { return dp[Base::getIndexAcc(0, indices...)]; }\n\ttemplate<typename... SizesT>\n\tVal operator()(SizesT... indices) const { return dp[Base::getIndexAcc(0, indices...)]; }\n\tvoid swap(DP &that) { dp.swap(that); }\n};\n\nstruct Interval {\n\tint L, R, X;\n\tbool operator<(const Interval &that) const {\n\t\treturn X < that.X;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<Interval> intervals(N);\n\t\trep(i, N) {\n\t\t\tint L; int R;\n\t\t\tscanf(\"%d%d\", &L, &R);\n\t\t\tintervals[i] = { L, R, L + R };\n\t\t}\n\t\tsort(intervals.begin(), intervals.end());\n\t\treverse(intervals.begin(), intervals.end());\n\t\tDP<ll, 0, 0, 2> dp(INFL, N + 1, N + 1);\n\t\tdp(0, 0, 0) = 0;\n\t\trep(i, N) {\n\t\t\tconst Interval a = intervals[i];\n\t\t\trer(l, 0, i) rep(c, l == i ? 1 : 2) {\n\t\t\t\tint r = i - l - c;\n\t\t\t\tll x = dp(l, r, c);\n\t\t\t\tif(x == INFL) continue;\n\t\t\t\tamin(dp(l + 1, r, c), x + a.R + (ll)a.X * l);\n\t\t\t\tamin(dp(l, r + 1, c), x + a.L + (ll)a.X * r);\n\t\t\t\tif(c == 0)\n\t\t\t\t\tamin(dp(l, r, c + 1), x + (ll)a.X * (N / 2));\n\t\t\t}\n\t\t}\n\t\tll ans = dp(N / 2, N / 2, N % 2);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[2][5010];\nll dp2[5010][5010];\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n\n\tvector<pii> vec;\n\n\trep(j, N) vec.eb(L[j]+R[j], j);\n\tsort(ALL(vec));\n\n\tfor (int l=(N-1)/2; l <= (N/2); ++l) { // to left\n\t\trep(j, N+1) rep(k, N+1) dp[j][k] = dp2[j][k] = LLONG_MAX;\t\t\n\t\tdp[0][0] = dp2[N][0] = 0;\n\t\t\n\t\trep(j, N) {\n\t\t\tint id = vec[j].se;\n\t\t\trep(k, N) {\n\t\t\t\tif (dp[j][k] == LLONG_MAX) continue;\n\t\t\t\tdp[j+1][k+1] = min(dp[j+1][k+1], dp[j][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[j][k] + (ll)((N-1-l)-1-(j-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = N-1; j >= 0; --j) {\n\t\t\tint id = vec[j].se;\n\t\t\trep(k, N) {\n\t\t\t\tif (dp2[j+1][k] == LLONG_MAX) continue;\n\t\t\t\tdp2[j][k+1] = min(dp2[j][k+1], dp2[j+1][k] + (ll)k*(L[id]+R[id]) + R[id]);\n\t\t\t\tdp2[j][k] = min(dp2[j][k], dp2[j+1][k] + (ll)(N-1-j-k)*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\n\t\trep(i, N) { //fix\n\n\t\t\tint id = vec[i].se;\n\t\t\tll t = (ll)L[id] * l + (ll)R[id] * (N-1-l);\n\n\t\t\tll u = LLONG_MAX;\n\t\t\tfor (int p = 0; p <= l; ++p) {\n\t\t\t\tif (dp[i][p] == LLONG_MAX || dp2[i+1][l-p] == LLONG_MAX) continue;\n\t\t\t\tu = min(u, dp[i][p] + dp2[i+1][l-p]);\n\t\t\t}\n\t\t\tu += t;\n\t\t\tret = min(ret, u);\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[2510][2510][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n / 2 + 1)rep(j, n / 2 + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst int m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\tconst int r = i - l;\n\t\t\tif (l > n / 2 or r > n / 2) continue;\n\t\t\trep(k, m + 1) {\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n - 1) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[5050],R[5050];\npair<ll,int> P[5050];\n\nll dp[3030][3030][2];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>L[i]>>R[i];\n\t\tP[i]={R[i]+L[i],i};\n\t}\n\tif(N%2==0) {\n\t\tP[N]={0,N};\n\t\tN++;\n\t}\n\t\n\tFOR(x,3000) FOR(y,3000) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\tdp[0][0][0]=0;\n\t\n\tsort(P,P+N);\n\tFOR(i,N) {\n\t\tj=P[i].second;\n\t\tfor(l=0;l<=N/2;l++) {\n\t\t\tfor(k=0;k<=1;k++) {\n\t\t\t\tr=i-l-k;\n\t\t\t\tif(r<0 || r>N/2) continue;\n\t\t\t\t\n\t\t\t\tif(l+1<=N/2) dp[l+1][r][k]=min(dp[l+1][r][k],dp[l][r][k]+R[j]+(N/2-(l+1))*P[i].first);\n\t\t\t\tif(r+1<=N/2) dp[l][r+1][k]=min(dp[l][r+1][k],dp[l][r][k]+L[j]+(N/2-(r+1))*P[i].first);\n\t\t\t\tif(k==0)     dp[l][r][k+1]=min(dp[l][r][k+1],dp[l][r][k]+(N-1)*P[i].first);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(N%2) {\n\t\tcout<<dp[N/2][N/2][1]<<endl;\n\t}\n\telse {\n\t\tcout<<min(dp[N/2-1][N/2][1],dp[N/2][N/2-1][1])<<endl;\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, s;\n\tinline int operator<(const seg &a) const {return s > a.s;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[5010][2], g[5010][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n    \tcin >> s[i].l >> s[i].r;\n    \ts[i].s = s[i].l + s[i].r;\n    }\n    sort(s+1, s+n+1);\n\t\n    for (int i = 1; i <= n; ++i)\n    \tf[i][0] = f[i][1] = g[i][0] = g[i][1] = inf;\n    f[0][0] = 0;\n    \n    int x = 1, y = 0;\n    m = n / 2;\n    for (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tf[j][x] = g[j][x] = inf;\n\t\tfor (int j = 0; j < i; ++j)\n\t\t{\n\t\t    int k = i-j-1;\n\t\t    if (j <= m)\n\t\t\t{\n\t\t\t\tf[j+1][x] = min(f[j+1][x], f[j][y] + s[i].r + s[i].s * j);\n\t\t\t\tg[j+1][x] = min(g[j+1][x], g[j][y] + s[i].r + s[i].s * j);\n\t\t    }\n\t\t    if (k <= m)\n\t\t\t{\n\t\t\t\tf[j][x] = min(f[j][x], f[j][y] + s[i].l + s[i].s * k);\n\t\t\t\tg[j][x] = min(g[j][x], g[j][y] + s[i].l + s[i].s * k);\n\t\t    }\n\t\t    g[j][x] = min(g[j][x], f[j][y] + (n-1)/2 * s[i].s);\n\t\t}\n\t\tswap(x, y);\n    }\n\t\n    cout << (n&1 ? g[m][y] : f[m][y]) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //i,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+(r[idx]+l[idx])*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+(r[idx]+l[idx])*(i-j)+l[idx]);\n    }\n  }\n  cout<<*min_element(ALL(dp[n]))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e15)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//ダイナミックプログラミンッ!!!\n\tint i,j,n;cin>>n;\n\tstatic llint dp[2505][2505]={0};\n\tvector<tuple<llint,llint,llint>> kuka(n);\n\tfor(i=0;i<n;i++){\n\t\tllint L,R;cin>>L>>R;\n\t\tkuka[i]=mt(L+R,L,R);\n\t}\n\tSO(kuka);REV(kuka);\n\t//でかい奴から両端に埋めていく\n\t//(n/2個) ((n+1)/2個) になる\n\tdp[0][0]=-big;\n\tfor(i=0;i<n-n%2;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tint hi=j;\n\t\t\tint mg=i-j;\n\t\t\tif(n/2<hi){continue;}\n\t\t\tif((n+1)/2<mg){continue;}\n\t\t\tllint wa,L,R;\n\t\t\ttie(wa,L,R)=kuka[i];\n\t\t\tmineq(dp[hi+1][mg],dp[hi][mg]+hi*wa+L);\n\t\t\tmineq(dp[hi][mg+1],dp[hi][mg]+mg*wa+R);\n\t\t}\n\t}\n\tif(n%2==1){\n\t\tdp[n/2][n/2]+=get<0>(kuka[n-1])*(n/2);\n\t}\n\tcout<<dp[n/2][n/2]+big<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nstruct intv{\n\tlong long l, r, d;\n\tbool operator <(const intv &t) const{\n\t\treturn d > t.d;\n\t}\n} I[5050];\n\nlong long d[2555][2555][2];\n\nvoid mn(long long &a, long long b)\n{\n\tif (a > b)\n\t\ta = b;\n}\n\nint main()\n{\n\tint N; scanf (\"%d\", &N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%lld %lld\", &I[i].l, &I[i].r);\n\t\tI[i].d = I[i].l + I[i].r;\n\t}\n\tsort(I, I + N);\n\n\tlong long ans = 1e18;\n\tint s = N / 2;\n\tfor (int l = s, r = N - s - 1; r <= s; l--, r++){\n\t\tfor (int i = 0; i <= l; i++) for (int j = 0; j <= r; j++) d[i][j][0] = d[i][j][1] = 1e18;\n\t\td[0][0][0] = 0;\n\n\t\tfor (int i = 0; i <= l; i++) for (int j = 0; j <= r; j++) for (int k = 0; k <= 1; k++){\n\t\t\tauto &t = I[i + j + k];\n\t\t\tif (i < l) mn(d[i + 1][j][k], d[i][j][k] + t.r + i * t.d);\n\t\t\tif (j < r) mn(d[i][j + 1][k], d[i][j][k] + t.l + j * t.d);\n\t\t\tif (k < 1) mn(d[i][j][k + 1], d[i][j][k] + l * t.l + r * t.r);\n\t\t}\n\t\tmn(ans, d[l][r][1]);\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e18)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//ダイナミックプログラミンッ!!!\n\tint i,j,n;cin>>n;\n\tstatic llint dp[2505][2505]={0};\n\tvector<tuple<llint,llint,llint>> kuka(n);\n\tfor(i=0;i<n;i++){\n\t\tllint L,R;cin>>L>>R;\n\t\tkuka[i]=mt(L+R,L,R);\n\t}\n\tSO(kuka);REV(kuka);\n\t//でかい奴から両端に埋めていく\n\t//(n/2個) ((n+1)/2個) になる\n\tdp[0][0]=-big;\n\t//n%2==1のとき、片方が埋まった状態も考えなければならない\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tint hi=j;\n\t\t\tint mg=i-j;\n\t\t\tif(n/2<hi){continue;}\n\t\t\tif(n/2<mg){continue;}\n\t\t\tllint wa,L,R;\n\t\t\ttie(wa,L,R)=kuka[i];\n\t\t\tmineq(dp[hi+1][mg],dp[hi][mg]+hi*wa+L);\n\t\t\tmineq(dp[hi][mg+1],dp[hi][mg]+mg*wa+R);\n\t\t\tif(n%2==1){dp[hi][mg]+=(n/2)*wa;}\n\t\t}\n\t}\n\tcout<<dp[n/2][n/2]+big<<endl;\n\tRE;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define l first\n#define r second\n\nint main() {\n    //ifstream cin(\"testF.in\");\n    int n; cin >> n;\n\n    vector<pair<int, int>> a(n);\n    for(int i = 0; i < n; ++i)\n        cin >> a[i].l >> a[i].r;\n    \n    \n    sort(a.begin(), a.end(), [&] (pair<int, int> A, pair<int, int> B) {\n        return (A.l + A.r) > (B.l + B.r);\n    });\n    \n    int64_t ans = 1e15;\n\n    for(int fixed = 0; fixed < n; ++fixed) {\n        vector<int64_t> dp(n + 1, 1e15);\n        int64_t many = 0;\n        dp[0] = 0;\n        for(int i = 0; i < n; ++i) {\n            if(fixed == i)\n                continue;\n            many++;\n            int len = a[i].r + a[i].l;\n            vector<int64_t> newDp(n + 1, 1e15);\n            newDp[0] = dp[0] + a[i].r + a[fixed].l + (many - 1) * len;\n            for(int j = 0; j < many; ++j) {\n                newDp[j + 1] = min(dp[j + 1] + a[i].r + a[fixed].l + 1LL * (many - 1 - (j + 1)) * len, dp[j] + a[i].l + a[fixed].r + 1LL * j * len);\n            }\n            dp = newDp;\n        }\n        int64_t temp = 1e9;\n        for(int i = 0; i <= n; ++i)\n            temp = min(temp, dp[i]);\n        ans = min(ans, temp);\n    }\n    \n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+l*i+r*j);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nbool cmp(const ii &a, const ii &b)\n{\n\tll lena = a.se-a.fi; ll lenb = b.se-b.fi;\n\tif(lena!=lenb) return lena>lenb;\n\telse return a.fi<a.se;\n}\n\nll pref[5011][5011];\nll suf[2][5011];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tvec.pb({-l,r});\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcerr<<vec[i].fi<<' '<<vec[i].se<<'\\n';\n\t}\n\t*/\n\tll ans = ll(2e18);\n\tfor(int l=(n-1)/2;l<=n/2;l++)\n\t{\n\t\tint r=n-1-l;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tpref[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tsuf[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tpref[0][0]=vec[0].se;\n\t\tpref[0][1]=-vec[0].fi;\n\t\tfor(int i=0;i+1<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(pref[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=pref[i][j];\n\t\t\t\t\tll L=vec[i+1].fi; ll R=vec[i+1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(pref[i+1][j], v+R+ll(i+1-j)*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(pref[i+1][j+1], v-L+ll(j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuf[(n-1)&1][0]=vec[n-1].se+ll(l-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tsuf[(n-1)&1][1]=-vec[n-1].fi+ll(r-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tfor(int i=max(n-2,0);i<n;i++)\n\t\t{\n\t\t\t//segment i is fixed\n\t\t\tll constant = vec[i].se*r-vec[i].fi*l;\n\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t{\n\t\t\t\tll lef = 0; \n\t\t\t\tll ri = 0;\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse lef=pref[i-1][j];\n\t\t\t\tif(i==n-1)\n\t\t\t\t{\n\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse ri=suf[(i+1)&1][r-j];\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n-1;i>0;i--)\n\t\t{\n\t\t\tint cur=(i+1)&1; int pre=cur^1;\n\t\t\tfor(int j=0;j<=n;j++) suf[cur][j]=ll(1e18);\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(suf[pre][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=suf[pre][j];\n\t\t\t\t\tll L=vec[i-1].fi; ll R=vec[i-1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(suf[cur][j], v+R+ll(l-1-((n-1-i)+1-j))*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(suf[cur][j+1], v-L+ll(r-1-j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i2=i-2;\n\t\t\t\tif(i2<0) continue;\n\t\t\t\tll constant = vec[i2].se*r-vec[i2].fi*l;\n\t\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t\t{\n\t\t\t\t\tll lef = 0; \n\t\t\t\t\tll ri = 0;\n\t\t\t\t\tif(i2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse lef=pref[i2-1][j];\n\t\t\t\t\tif(i2==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse ri=suf[cur][r-j];\n\t\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, s;\n\tinline int operator<(const seg &a) const {return s > a.s;}\n} s[10010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[10010][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].s = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t\tf[i][0] = f[i][1] = inf;\n\tf[0][0] = 0;\n\t\n\tint x = 1, y = 0;\n\tm = n / 2;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tf[j][x] = inf;\n\t\tfor (int j = 0; j<i && j<=m; ++j)\n\t\t{\n\t\t\tconst int k = i-j-1;\n\t\t\tif (j < m)\n\t\t\t\tf[j+1][x] = min(f[j+1][x], f[j][y] + s[i].r + s[i].s * j);\n\t\t\tif (k < m)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][y] + s[i].l + s[i].s * k);\n\t\t\tif (n & 1)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][y] + (n-1)/2 * s[i].s);\n\t\t}\n\t\tswap(x, y);\n\t}\n\t\n\tcout << f[m][y] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[5010][5010];\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n\n\trep(i, N) { //fix\n\t\tvector<pii> vec;\n\n\t\trep(j, N) {\n\t\t\tif (j != i) {\n\t\t\t\tvec.eb(L[j]+R[j], j);\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(vec));\n\n\t\tfor (int l=(N-1)/2; l < (N/2); ++l) { // to left\n\t\t\tll t = (ll)L[i] * l + (ll)R[i] * (N-1-l);\n\t\t\trep(j, N) rep(k, N) dp[j][k] = LLONG_MAX;\n\n\t\t\tdp[0][0] = 0;\n\t\t\trep(j, N-1) {\n\t\t\t\tint id = vec[j].se;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif (dp[j][k] == LLONG_MAX) continue;\n\t\t\t\t\tdp[j+1][k+1] = min(dp[j+1][k+1], dp[j][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[j][k] + (ll)((N-1-l)-1-(j-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tt += dp[N-1][l];\n\t\t\tret = min(ret, t);\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, d;\n\tinline int operator<(const seg &a) const {return d > a.d;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[2510][2510][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].d = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tm = n >> 1;\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[i][j][0] = f[i][j][1] = inf;\n\tf[0][0][0] = 0;\n\t\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m && i+j < n; ++j)\n\t\t\tfor (int k = 0; k <= 1 && i+j+k < n; ++k)\n\t\t\t{\n\t\t\t\tconst ll tmp = f[i][j][k]; const seg p = s[i+j+k+1];\n\t\t\t\tif (i < m)\tf[i+1][j][k] = min(f[i+1][j][k], tmp + p.r + i*p.d);\n\t\t\t\tif (j < m)\tf[i][j+1][k] = min(f[i][j+1][k], tmp + p.l + j*p.d);\n\t\t\t\tif (!k)\t\tf[i][j][k|1] = min(f[i][j][k|1], tmp + m * p.d);\n\t\t\t}\n\t\n\tcout << f[m][m][n&1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n \n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n \nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[5010][5010];\n \nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n \n \tif (N>200) return 0;\n\trep(i, N) { //fix\n\t\tvector<pii> vec;\n \n\t\trep(j, N) {\n\t\t\tif (j != i) {\n\t\t\t\tvec.eb(L[j]+R[j], j);\n\t\t\t}\n\t\t}\n \n\t\tsort(ALL(vec));\n \n\t\tfor (int l=0; l <= N-1; ++l) { // to left\n\t\t\tll t = (ll)L[i] * l + (ll)R[i] * (N-1-l);\n\t\t\trep(j, N) rep(k, N) dp[j][k] = LLONG_MAX;\n \n\t\t\tdp[0][0] = 0;\n\n\t\t\trep(j, N-1) {\n\t\t\t\tint id = vec[j].se;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif (dp[j][k] == LLONG_MAX) continue;\n\t\t\t\t\tdp[j+1][k+1] = min(dp[j+1][k+1], dp[j][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[j][k] + (ll)((N-1-l)-1-(j-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt += dp[N-1][l];\n\t\t\tret = min(ret, t);\n\t\t}\n\t}\n \n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\ntemplate<int... Sizes>\nstruct MultidimensionalIndex;\ntemplate<>\nstruct MultidimensionalIndex<> {\n\tMultidimensionalIndex() {}\n\tint getTotalSize() const { return 1; }\n\tint getIndexAcc(int acc) const { return acc; }\n};\ntemplate<int Head, int... Tail>\nstruct MultidimensionalIndex<Head, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tenum { size = Head };\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(TailT... tail) : Base(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\ntemplate<int... Tail>\nstruct MultidimensionalIndex<0, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tconst int size;\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(int head, TailT... tail) : size(head), MultidimensionalIndex<Tail...>(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\n\ntemplate<typename Val, int... Sizes>\nstruct DP : MultidimensionalIndex<Sizes...> {\n\tusing Base = MultidimensionalIndex<Sizes...>;\n\tstd::vector<Val> dp;\n\ttemplate<typename... SizesT>\n\tDP(Val init, SizesT... sizes) : Base(sizes...), dp(Base::getTotalSize(), init) {}\n\ttemplate<typename... SizesT>\n\tVal &operator()(SizesT... indices) { return dp[Base::getIndexAcc(0, indices...)]; }\n\ttemplate<typename... SizesT>\n\tVal operator()(SizesT... indices) const { return dp[Base::getIndexAcc(0, indices...)]; }\n\tvoid swap(DP &that) { dp.swap(that); }\n};\n\nstruct Interval {\n\tint L, R, X;\n\tbool operator<(const Interval &that) const {\n\t\treturn X < that.X;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<Interval> intervals(N);\n\t\trep(i, N) {\n\t\t\tint L; int R;\n\t\t\tscanf(\"%d%d\", &L, &R);\n\t\t\tintervals[i] = { L, R, L + R };\n\t\t}\n\t\tsort(intervals.begin(), intervals.end());\n\t\treverse(intervals.begin(), intervals.end());\n\t\tDP<ll, 0, 0, 2> dp(INFL, N / 2 + 2, N / 2 + 2);\n\t\tdp(0, 0, 0) = 0;\n\t\trep(i, N) {\n\t\t\tconst Interval a = intervals[i];\n\t\t\trer(l, 0, min(i, N / 2)) rep(c, 2) {\n\t\t\t\tint r = i - l - c;\n\t\t\t\tif(r < 0 || r > N / 2) continue;\n\t\t\t\tll x = dp(l, r, c);\n\t\t\t\tif(x == INFL) continue;\n\t\t\t\tamin(dp(l + 1, r, c), x + a.R + (ll)a.X * l);\n\t\t\t\tamin(dp(l, r + 1, c), x + a.L + (ll)a.X * r);\n\t\t\t\tif(c == 0)\n\t\t\t\t\tamin(dp(l, r, c + 1), x + (ll)a.X * (N / 2));\n\t\t\t}\n\t\t}\n\t\tll ans = dp(N / 2, N / 2, N % 2);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 5005;\nconst long long inf = (1LL<<62);\n\nint i, j, n, k, curr;\nstruct interval\n{\n    int l, r, len;\n    bool operator < (const interval &other) const\n    {\n        return len > other.len;\n    }\n} a[Nmax];\nlong long d[Nmax/2][Nmax/2][2], ans;\n\nint main()\n{\n    //freopen(\"intervals.in\", \"r\", stdin);\n    //freopen(\"intervals.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for(i=1; i<=n; ++i) scanf(\"%d%d\", &a[i].l, &a[i].r), a[i].len = a[i].l + a[i].r;\n\n    if(n%2==0) ++n;\n    sort(a+1, a+n+1);\n\n    for(i=0; i<=n/2; ++i)\n    for(j=0; j<=n/2; ++j)\n        d[i][j][0] = d[i][j][1] = inf;\n\n    d[0][0][0] = 0;\n\n    for(i=0; i<=n/2; ++i)\n    for(j=0; j<=n/2; ++j)\n    for(k=0; k<=1; ++k)\n    {\n        curr = i+j+k+1;\n        if(curr>n) continue;\n\n        if(i<n/2) d[i+1][j][k] = min(d[i+1][j][k], d[i][j][k] + a[curr].r + 1LL*a[curr].len*i);\n        if(j<n/2) d[i][j+1][k] = min(d[i][j+1][k], d[i][j][k] + a[curr].l + 1LL*a[curr].len*j);\n        if(!k) d[i][j][1] = min(d[i][j][1], d[i][j][0] + 1LL*(n-1)/2*a[curr].len);\n    }\n\n    printf(\"%lld\\n\", d[n/2][n/2][1]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x)dp[x][y]=dp[x-1][y]+(x-1)*p[i].F+(p[i].S+offset);\n            else dp[x][y]=INF;\n            if(y)dp[x][y]=min(dp[x][y],dp[x][y-1]+y*p[i].F-(p[i].S+offset));\n            if(i==N-1)res=min(res,dp[x][y]);\n        }\n    }\n    return res;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    while(ll<rr){\n        int mm1=(rr-ll)/2+ll;\n        int mm2=mm1+1;\n        LL v1=f(mm1);\n        LL v2=f(mm2);\n        if(v1>v2)ll=mm2;\n        else rr=mm1;\n    }\n    cout<<f(ll)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nbool cmp(const ii &a, const ii &b)\n{\n\tll lena = a.se-a.fi; ll lenb = b.se-b.fi;\n\tif(lena!=lenb) return lena>lenb;\n\telse return a.fi<a.se;\n}\n\nll pref[5011][5011];\nll suf[5011][5011];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tvec.pb({-l,r});\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcerr<<vec[i].fi<<' '<<vec[i].se<<'\\n';\n\t}\n\t*/\n\tll ans = ll(2e18);\n\tfor(int l=(n-1)/2;l<=n/2;l++)\n\t{\n\t\tint r=n-1-l;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tpref[i][j]=suf[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tpref[0][0]=vec[0].se;\n\t\tpref[0][1]=-vec[0].fi;\n\t\tfor(int i=0;i+1<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(pref[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=pref[i][j];\n\t\t\t\t\tll L=vec[i+1].fi; ll R=vec[i+1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(pref[i+1][j], v+R+ll(i+1-j)*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(pref[i+1][j+1], v-L+ll(j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuf[n-1][0]=vec[n-1].se+ll(l-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tsuf[n-1][1]=-vec[n-1].fi+ll(r-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tfor(int i=n-1;i>0;i--)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(suf[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=suf[i][j];\n\t\t\t\t\tll L=vec[i-1].fi; ll R=vec[i-1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(suf[i-1][j], v+R+ll(l-1-((n-1-i)+1-j))*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(suf[i-1][j+1], v-L+ll(r-1-j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\t//segment i is fixed\n\t\t\tll constant = vec[i].se*r-vec[i].fi*l;\n\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t{\n\t\t\t\tll lef = 0; \n\t\t\t\tll ri = 0;\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse lef=pref[i-1][j];\n\t\t\t\tif(i==n-1)\n\t\t\t\t{\n\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse ri=suf[i+1][r-j];\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5050;\nusing ll = long long;\nusing pll = pair<ll, ll>;\nvoid amin(ll &a, ll b){\n\ta = min(a, b);\n}\nll f[2][maxn][maxn];\nint main(){\n\tvector<pll> e;\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, b; cin >> a >> b;\n\t\te.push_back({a, b});\n\t}\n\tsort(e.begin(), e.end(), [](pll a, pll b){\n\t\treturn a.first + a.second > b.first + b.second;\n\t});\n\tint m = n / 2;\n\tconst ll inf = 1ll<<60;\n\tfor(int i = 0; i < 2; i++) \n\t\tfor(int j = 0; j <= m; j++) \n\t\t\tfor(int k = 0; k <= m; k++) \n\t\t\t\tf[i][j][k] = inf;\n\tf[0][0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, b; tie(a, b) = e[i];\n\t\tll l = a + b;\n\t\tfor(int x = 0; x < 2; x++){\n\t\t\tfor(int y = 0; y + x <= i; y++){\n\t\t\t\tint z = i - y - x;\n\t\t\t\tamin(f[x][y+1][z], f[x][y][z] + b + y * l);\n\t\t\t\tamin(f[x][y][z+1], f[x][y][z] + a + z * l);\n\t\t\t\tif(!x){\n\t\t\t\t\tamin(f[1][y][z], f[x][y][z] + m * l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << f[n&1][m][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nvector<pii> arr;\nint cmp(pii a,pii b){\n  return a.Y-a.X<b.Y-b.X;\n}\nll dp[5005][5005];\nint main(){\n  int n; scanf(\"%d\",&n); \n  REP(i,n){\n    pii z; scanf(\"%d%d\",&z.X,&z.Y); z.X=-z.X; arr.pb(z);\n  }\n  sort(all(arr),cmp);\n  reverse(all(arr));\n  REP(i,n+1) REP(j,n+1)  dp[i][j]=INF;\n  dp[0][0]=0;\n  ll lk = -arr[n-1].X,rk=arr[n-1].Y;\n  ll ans=INF;\n  REP(i,n){\n    ll ls = arr[i].X,rs=arr[i].Y;\n    ll dis = rs-ls;\n    ll sub=0,add=0;\n   // printf(\"%lld %lld\\n\",-ls,rs);\n    REP(j,i+1)if(dp[i][j]<INF){\n    //  printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n      dp[i+1][j]=min(dp[i+1][j],dp[i][j]+(i-j)*dis+lk+rs);\n      dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+j*dis+rk-ls);\n    }\n  }\n  REP(i,n) ans=min(ans,dp[n-1][i]);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[5010][5010];\nll dp2[5010][5010];\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n\n\tvector<pii> vec;\n\n\trep(j, N) vec.eb(L[j]+R[j], j);\n\tsort(ALL(vec));\n\n\tfor (int l=(N-1)/2; l <= (N/2); ++l) { // to left\n\t\trep(j, N+1) rep(k, N+1) dp[j][k] = dp2[j][k] = LLONG_MAX;\t\t\n\t\tdp[0][0] = dp2[N][0] = 0;\n\t\t\n\t\trep(j, N) {\n\t\t\tint id = vec[j].se;\n\t\t\trep(k, N) {\n\t\t\t\tif (dp[j][k] == LLONG_MAX) continue;\n\t\t\t\tdp[j+1][k+1] = min(dp[j+1][k+1], dp[j][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[j][k] + (ll)((N-1-l)-1-(j-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = N-1; j >= 0; --j) {\n\t\t\tint id = vec[j].se;\n\t\t\trep(k, N) {\n\t\t\t\tif (dp2[j+1][k] == LLONG_MAX) continue;\n\t\t\t\tdp2[j][k+1] = min(dp2[j][k+1], dp2[j+1][k] + (ll)k*(L[id]+R[id]) + R[id]);\n\t\t\t\tdp2[j][k] = min(dp2[j][k], dp2[j+1][k] + (ll)(N-1-j-k)*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\n\t\trep(i, N) { //fix\n\t\t\tint id = vec[i].se;\n\t\t\tll t = (ll)L[id] * l + (ll)R[id] * (N-1-l);\n\n\t\t\tll u = LLONG_MAX;\n\t\t\tfor (int p = 0; p <= l; ++p) {\n\t\t\t\tif (dp[i][p] == LLONG_MAX || dp2[i+1][l-p] == LLONG_MAX) continue;\n\t\t\t\t//puts(\"wo\");\n\t\t\t\t//cout << dp[i][p] << \" \" << dp2[i+1][l-p] << endl;\n\t\t\t\tu = min(u, dp[i][p] + dp2[i+1][l-p]);\n\t\t\t}\n\t\t\tu += t;\n\t\t\t//cout << u << endl;\n\t\t\tret = min(ret, u);\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  srand(600);\n  int n;\n  scanf(\"%d\",&n);\n  assert(n != 4999);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  // {\n  //   vl dp(1,LINF);\n  //   dp[0] = 0;\n  //   vl d;\n  //   rep(k,n) {\n  //     d = vl(k+2,LINF);\n  //     swap(dp,d);\n  //     ll l = p[k].fi, r = p[k].se, w = r+l;\n  //     rep(j,k+1) {\n  //       int g = k-j;\n  //       mins(dp[j], d[j]+r+w*g);\n  //       mins(dp[j+1], d[j]+l+w*j);\n  //     }\n  //   }\n  // }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define VL vector<long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint from[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    int id=-1;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x){\n                dp[x][y]=dp[x-1][y]+(x-1LL)*p[i].F+(p[i].S+offset);\n                from[x][y]=0;\n            }\n            else dp[x][y]=INF;\n            if(y){\n                if(dp[x][y]>dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset)){\n                    dp[x][y]=dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset);\n                    from[x][y]=1;\n                }\n            }\n            if(i==N-1){\n                if(res>dp[x][y]){\n                    res=dp[x][y];\n                    id=x;\n                }\n            }\n        }\n    }\n    VPII left,right;\n    int x=id,y=N-id;\n    for(int i=N-1;i>=0;i--){\n        if(from[x][y]){\n            right.PB(p[i]);\n            y--;\n        }\n        else{\n            left.PB(p[i]);\n            x--;\n        }\n    }\n    VL d;\n    LL now=0;\n    REP(i,SZ(left)){\n        d.PB(left[i].S+offset+now);\n        now+=left[i].F;\n    }\n    now=0;\n    REP(i,SZ(right)){\n        d.PB(-(right[i].F-right[i].S-offset)-now);\n        now+=right[i].F;\n    }\n    sort(ALL(d));\n    LL an=0;\n    for(int i=0,j=SZ(d)-1;j>i;j--,i++)an+=d[j]-d[i];\n    return an;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    int SEG=10;\n    LL res=INF;\n    REP(i,SEG){\n        res=min(res,f(ll+(rr-ll)*i/(SEG-1)));\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, s;\n\tinline int operator<(const seg &a) const {return s > a.s;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[2510][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n; m = n >> 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].s = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tfor (int i = 1; i <= m; ++i)\n\t\tf[i][0] = inf;\n\t\n\tint x = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tx ^= 1;\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[j][x] = inf;\n\t\tfor (int j = 0; j<i && j<=m; ++j)\n\t\t{\n\t\t\tconst int k = i-j-1;\n\t\t\tif (j < m)\n\t\t\t\tf[j+1][x] = min(f[j+1][x], f[j][x^1] + s[i].r + s[i].s * j);\n\t\t\tif (k < m)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][x^1] + s[i].l + s[i].s * k);\n\t\t\tif (n & 1)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][x^1] + m * s[i].s);\n\t\t}\n\t}\n\t\n\tcout << f[m][x] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, d;\n\tinline int operator<(const seg &a) const {return d > a.d;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[2510][2510][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].d = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tm = n >> 1;\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[i][j][0] = f[i][j][1] = inf;\n\tf[0][0][0] = 0;\n\t\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m && i+j < n; ++j)\n\t\t\tfor (int k = 0; k <= 1 && i+j+k < n; ++k)\n\t\t\t{\n\t\t\t\tconst int tmp = f[i][j][k]; const seg p = s[i+j+k+1];\n\t\t\t\tif (i < m)\tf[i+1][j][k] = min(f[i+1][j][k], tmp + p.r + i*p.d);\n\t\t\t\tif (j < m)\tf[i][j+1][k] = min(f[i][j+1][k], tmp + p.l + j*p.d);\n\t\t\t\tif (!k)\t\tf[i][j][k|1] = min(f[i][j][k|1], tmp + m * p.d);\n\t\t\t}\n\t\n\tcout << f[m][m][n&1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[2510][2510][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n / 2 + 1)rep(j, n / 2 + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst int m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\trep(k, m + 1) {\n\t\t\t\tconst int r = i - l - k;\n\t\t\t\tif (l < 0 or l > n / 2) continue;\n\t\t\t\tif (r < 0 or r > n / 2) continue;\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n - 1) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nbool cmp(const ii &a, const ii &b)\n{\n\tll lena = a.se-a.fi; ll lenb = b.se-b.fi;\n\tif(lena!=lenb) return lena>lenb;\n\telse return a.fi<a.se;\n}\n\nll pref[5011][5011];\nll suf[2][5011];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tif(n==1){cout<<0<<'\\n'; return 0;}\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tvec.pb({-l,r});\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcerr<<vec[i].fi<<' '<<vec[i].se<<'\\n';\n\t}\n\t*/\n\tll ans = ll(2e18);\n\tfor(int l=(n-1)/2;l<=n/2;l++)\n\t{\n\t\tint r=n-1-l;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tpref[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tsuf[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tpref[0][0]=vec[0].se;\n\t\tpref[0][1]=-vec[0].fi;\n\t\tfor(int i=0;i+1<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(pref[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=pref[i][j];\n\t\t\t\t\tll L=vec[i+1].fi; ll R=vec[i+1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(pref[i+1][j], v+R+ll(i+1-j)*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(pref[i+1][j+1], v-L+ll(j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuf[(n-1)&1][0]=vec[n-1].se+ll(l-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tsuf[(n-1)&1][1]=-vec[n-1].fi+ll(r-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tfor(int i=max(n-2,0);i<n;i++)\n\t\t{\n\t\t\t//segment i is fixed\n\t\t\tll constant = vec[i].se*r-vec[i].fi*l;\n\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t{\n\t\t\t\tll lef = 0; \n\t\t\t\tll ri = 0;\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse lef=pref[i-1][j];\n\t\t\t\tif(i==n-1)\n\t\t\t\t{\n\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse ri=suf[(i+1)&1][r-j];\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n-1;i>0;i--)\n\t\t{\n\t\t\tint cur=(i+1)&1; int pre=cur^1;\n\t\t\tfor(int j=0;j<=n;j++) suf[cur][j]=ll(1e18);\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(suf[pre][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=suf[pre][j];\n\t\t\t\t\tll L=vec[i-1].fi; ll R=vec[i-1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(suf[cur][j], v+R+ll(l-1-((n-1-i)+1-j))*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(suf[cur][j+1], v-L+ll(r-1-j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i2=i-2;\n\t\t\t\tif(i2<0) continue;\n\t\t\t\tll constant = vec[i2].se*r-vec[i2].fi*l;\n\t\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t\t{\n\t\t\t\t\tll lef = 0; \n\t\t\t\t\tll ri = 0;\n\t\t\t\t\tif(i2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse lef=pref[i2-1][j];\n\t\t\t\t\tif(i2==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse ri=suf[cur][r-j];\n\t\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  vector<vector<ll>>dp(n+1);\n  vector<vector<ll>>dp2(n+1);\n  dp[0].assign(1,0);\n  dp2[0].assign(1,INF);\n  //j,左に寄せた個数\n  rep(i,0,n){\n    dp[i+1].assign(i+2,INF);\n    dp2[i+1].assign(i+2,INF);\n    ll idx=order[i];\n    ll len=l[idx]+r[idx];\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+len*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+len*(i-j)+l[idx]);\n      chmin(dp2[i+1][j],dp[i][j]+len*(n/2));\n      chmin(dp2[i+1][j+1],dp2[i][j]+len*j+r[idx]);\n      if(i-j-1>=0)chmin(dp2[i+1][j],dp2[i][j]+len*(i-j-1)+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  if(~n&1)cout<<dp[n][n/2]<<endl;\n  else cout<<dp2[n][n/2]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, s;\n\tinline int operator<(const seg &a) const {return s > a.s;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[5010][2], g[5010][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].s = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t\tf[i][0] = f[i][1] = g[i][0] = g[i][1] = inf;\n\tf[0][0] = 0;\n\t\n\tint x = 1, y = 0;\n\tm = n / 2;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tf[j][x] = g[j][x] = inf;\n\t\tfor (int j = 0; j < i; ++j)\n\t\t{\n\t\t\tint k = i-j-1;\n\t\t\tif (j < m)\n\t\t\t{\n\t\t\t\tf[j+1][x] = min(f[j+1][x], f[j][y] + s[i].r + s[i].s * j);\n\t\t\t\tg[j+1][x] = min(g[j+1][x], g[j][y] + s[i].r + s[i].s * j);\n\t\t\t}\n\t\t\tif (k < m)\n\t\t\t{\n\t\t\t\tf[j][x] = min(f[j][x], f[j][y] + s[i].l + s[i].s * k);\n\t\t\t\tg[j][x] = min(g[j][x], g[j][y] + s[i].l + s[i].s * k);\n\t\t\t}\n\t\t\tg[j][x] = min(g[j][x], f[j][y] + (n-1)/2 * s[i].s);\n\t\t}\n\t\tswap(x, y);\n\t}\n\t\n\tcout << (n&1 ? g[m][y] : f[m][y]) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll dp[5001][2];\nll cop[5001][2];\nbool comp(LP a, LP b) {\n\treturn a.second + a.first < b.second + b.first;\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<LP> v(n);\n\trep(i, n) {\n\t\tcin >> v[i].first >> v[i].second;\n\t}\n\tsort(v.begin(), v.end(), comp);\n\tif (n % 2) {\n\t\tint d = n / 2;\n\t\trep(i, d + 1) {\n\t\t\trep(j, 2) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\trep(i, n) {\n\t\t\trep(j, d + 1) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tcop[j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll len = v[i].second + v[i].first;\n\t\t\trep(j, d + 1) {\n\t\t\t\tif (j > i)continue;\n\t\t\t\t//真ん中にする\n\t\t\t\tcop[j][1] = min(cop[j][1], dp[j][0] + d * len);\n\t\t\t\t//左にする\n\t\t\t\tif (j < d) {\n\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\tcop[j + 1][k] = min(cop[j + 1][k], dp[j][k] + (d - 1 - j)*len + v[i].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//右にする\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tint r = i - j - k;\n\t\t\t\t\tif (r < d) {\n\t\t\t\t\t\tcop[j][k] = min(cop[j][k], dp[j][k] + (d - 1 - r)*len + v[i].first);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, d + 1) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tdp[j][k] = cop[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = dp[d][1];\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tll ans = INF;\n\n\t\tint l = n / 2; int r = l - 1;\n\t\trep(i, l + 1) {\n\t\t\trep(j, 2) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\trep(i, n) {\n\t\t\trep(j, l + 1) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tcop[j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll len = v[i].second + v[i].first;\n\t\t\trep(j, l + 1) {\n\t\t\t\tif (j > i)continue;\n\t\t\t\t//真ん中にする\n\t\t\t\tcop[j][1] = min(cop[j][1], dp[j][0] + l * v[i].first + r*v[i].second);\n\t\t\t\t//左にする\n\t\t\t\tif (j < l) {\n\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\tcop[j + 1][k] = min(cop[j + 1][k], dp[j][k] + (l - 1 - j)*len + v[i].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//右にする\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tint rest = i - j - k;\n\t\t\t\t\tif (rest < r) {\n\t\t\t\t\t\tcop[j][k] = min(cop[j][k], dp[j][k] + (r - 1 - rest)*len + v[i].first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << i << endl;\n\t\t\trep(j, l + 1) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tdp[j][k] = cop[j][k];\n\t\t\t\t\t//cout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans,dp[l][1]);\n\n\t\t//cout << ans << endl;\n\t\tl = n / 2-1; r = l+1;\n\t\trep(i, l + 1) {\n\t\t\trep(j, 2) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\trep(i, n) {\n\t\t\trep(j, l + 1) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tcop[j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll len = v[i].second + v[i].first;\n\t\t\trep(j, l + 1) {\n\t\t\t\tif (j > i)continue;\n\t\t\t\t//真ん中にする\n\t\t\t\tcop[j][1] = min(cop[j][1], dp[j][0] + l * v[i].first + r * v[i].second);\n\t\t\t\t//左にする\n\t\t\t\tif (j < l) {\n\t\t\t\t\trep(k, 2) {\n\t\t\t\t\t\tcop[j + 1][k] = min(cop[j + 1][k], dp[j][k] + (l - 1 - j)*len + v[i].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//右にする\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tint rest = i - j - k;\n\t\t\t\t\tif (rest < r) {\n\t\t\t\t\t\tcop[j][k] = min(cop[j][k], dp[j][k] + (r - 1 - rest)*len + v[i].first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, l + 1) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tdp[j][k] = cop[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans, dp[l][1]);\n\t\t//cout << dp[l][1] << endl;\n\t\tcout << ans << endl;\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2550;\nusing ll = long long;\nusing pll = pair<ll, ll>;\nvoid amin(ll &a, ll b){\n\ta = min(a, b);\n}\nll f[2][maxn][maxn];\nint main(){\n\tvector<pll> e;\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, b; cin >> a >> b;\n\t\te.push_back({a, b});\n\t}\n\tsort(e.begin(), e.end(), [](pll a, pll b){\n\t\treturn a.first + a.second > b.first + b.second;\n\t});\n\tint m = n / 2;\n\tconst ll inf = 1ll<<60;\n\tfor(int i = 0; i < 2; i++) \n\t\tfor(int j = 0; j <= m; j++) \n\t\t\tfor(int k = 0; k <= m; k++) \n\t\t\t\tf[i][j][k] = inf;\n\tf[0][0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, b; tie(a, b) = e[i];\n\t\tll l = a + b;\n\t\tfor(int x = 0; x < 2; x++){\n\t\t\tfor(int y = 0; y + x <= i; y++){\n\t\t\t\tint z = i - y - x;\n\t\t\t\tamin(f[x][y+1][z], f[x][y][z] + b + y * l);\n\t\t\t\tamin(f[x][y][z+1], f[x][y][z] + a + z * l);\n\t\t\t\tif(!x){\n\t\t\t\t\tamin(f[1][y][z], f[x][y][z] + m * l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << f[n&1][m][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define VL vector<long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint from[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    int id=-1;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x){\n                dp[x][y]=dp[x-1][y]+(x-1)*p[i].F+(p[i].S+offset);\n                from[x][y]=0;\n            }\n            else dp[x][y]=INF;\n            if(y){\n                if(dp[x][y]>dp[x][y-1]+y*p[i].F-(p[i].S+offset)){\n                    dp[x][y]=dp[x][y-1]+y*p[i].F-(p[i].S+offset);\n                    from[x][y]=1;\n                }\n            }\n            if(i==N-1){\n                if(res>dp[x][y]){\n                    res=dp[x][y];\n                    id=x;\n                }\n            }\n        }\n    }\n    VPII left,right;\n    int x=id,y=N-id;\n    for(int i=N-1;i>=0;i--){\n        if(from[x][y]){\n            right.PB(p[i]);\n            y--;\n        }\n        else{\n            left.PB(p[i]);\n            x--;\n        }\n    }\n    VL d;\n    LL now=0;\n    REP(i,SZ(left)){\n        d.PB(left[i].S+now);\n        now+=left[i].F;\n    }\n    now=0;\n    REP(i,SZ(right)){\n        d.PB(-(right[i].F-right[i].S)-now);\n        now+=right[i].F;\n    }\n    sort(ALL(d));\n    LL an=0;\n    for(int i=0,j=SZ(d)-1;j>i;j--,i++)an+=d[j]-d[i];\n    return an;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    cout<<f(0)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst LL INF = 1LL << 61;\n\nint N;\nLL L[5145];\nLL R[5145];\nLL W[5145];\nLL dp[5145][5145];\nint Llast[5145][5145];\nint Rlast[5145][5145];\nvector<int> ps;\n\nLL Solve(LL x) {\n  rep(i, N) {\n    L[i] -= x;\n    R[i] += x;\n  }\n\n  fill(dp[0], dp[N+1], INF);\n  dp[0][0] = 0;\n  rep(i, N) {\n    int idx = ps[i];\n    rep(j, i+1) {\n      if (MN(dp[i+1][j+1], dp[i][j] + j*W[idx] + R[idx])) {\n        Llast[i+1][j+1] = idx;\n        Rlast[i+1][j+1] = Rlast[i][j];\n      }\n\n      if (MN(dp[i+1][j], dp[i][j] + (i-j)*W[idx] + L[idx])) {\n        Llast[i+1][j] = Llast[i][j];\n        Rlast[i+1][j] = idx;\n      }\n    }\n  }\n\n  LL ret = INF;\n  if (N%2 == 0) {\n    ret = dp[N][N/2];\n  } else {\n    int l = N/2;\n    int idx = Rlast[N][l];\n    MN(ret, dp[N][l] - (N-l)*L[idx] + l*L[idx]);\n    idx = Llast[N][l+1];\n    MN(ret, dp[N][l+1] - (l+1)*R[idx] + (N-1-l)*R[idx]);\n  }\n\n  rep(i, N) {\n    L[i] += x;\n    R[i] -= x;\n  }\n\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n\n  LL ml = INF;\n  LL mr = INF;\n  rep(i, N) {\n    cin >> L[i] >> R[i];\n    W[i] = L[i] + R[i];\n    ps.eb(i);\n    MN(ml, L[i]);\n    MN(mr, R[i]);\n  }\n  sort(all(ps), [&](int a, int b){return W[a] > W[b];});\n\n  LL ans = INF;\n  ans = Solve(0);\n  //LL low = -ml-1;\n  //LL high = mr+1;\n  //while (high - low > 10) {\n  //  LL lmid = (high+low*2)/3;\n  //  LL rmid = (high*2+low)/3;\n  //  LL lval = Solve(lmid);\n  //  LL rval = Solve(rmid);\n  //  if (lval < rval) high = rmid;\n  //  else low = lmid;\n  //}\n\n  //for (LL i=low; i<high+1; i++) {\n  //  if (i < -ml || mr < i) continue;\n  //  MN(ans, Solve(i));\n  //}\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[2][5010];\nll dp2[5010][5010];\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n\n\tvector<pii> vec;\n\n\trep(j, N) vec.eb(L[j]+R[j], j);\n\tsort(ALL(vec));\n\n\tfor (int l=(N-1)/2; l <= (N/2); ++l) { // to left\n\t\trep(j, N+1) rep(k, N+1) dp2[j][k] = LLONG_MAX;\t\t\n\t\tdp2[N][0] = 0;\n\t\t\n\t\tfor (int j = N-1; j >= 0; --j) {\n\t\t\tint id = vec[j].se;\n\t\t\trep(k, N) {\n\t\t\t\tif (dp2[j+1][k] == LLONG_MAX) continue;\n\t\t\t\tdp2[j][k+1] = min(dp2[j][k+1], dp2[j+1][k] + (ll)k*(L[id]+R[id]) + R[id]);\n\t\t\t\tdp2[j][k] = min(dp2[j][k], dp2[j+1][k] + (ll)(N-1-j-k)*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tint c = 0, f = 1;\n\t\trep(j, 2) rep(k, N) dp[j][k] = LLONG_MAX;\n\t\tdp[0][0] = 0;\n\n\t\trep(i, N) { //fix\n\t\t\tint id = vec[i].se;\n\n\t\t\tll t = (ll)L[id] * l + (ll)R[id] * (N-1-l);\n\n\t\t\tll u = LLONG_MAX;\n\t\t\tfor (int p = 0; p <= l; ++p) {\n\t\t\t\tif (dp[c][p] == LLONG_MAX || dp2[i+1][l-p] == LLONG_MAX) continue;\n\t\t\t\tu = min(u, dp[c][p] + dp2[i+1][l-p]);\n\t\t\t}\n\t\t\tu += t;\n\t\t\tret = min(ret, u);\n\n\t\t\trep(j, N+1) dp[f][j] = LLONG_MAX;\n\n\t\t\trep(k, N) {\n\t\t\t\tif (dp[c][k] == LLONG_MAX) continue;\n\t\t\t\tdp[f][k+1] = min(dp[f][k+1], dp[c][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\tdp[f][k] = min(dp[f][k], dp[c][k] + (ll)((N-1-l)-1-(i-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t}\n\n\t\t\tswap(c, f);\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst lint INF=1e18;\n\nint n;\npi range[5005];\nlint dp[5005][5005];\nint main(){\n  cin>>n;\n  REP(i,n) cin>>range[i].fr>>range[i].sc;\n  sort(range,range+n,[&](pi a,pi b ){\n    return a.fr+a.sc>b.fr+b.sc;\n  });\n\n  REP(i,5005) REP(j,5005) dp[i][j]=INF;\n\n  int m=(n+1)/2;\n  dp[0][0]=0;\n\n  REP(i,m+1) REP(j,m+1) if(dp[i][j]<INF){\n    pi r=range[i+j];\n    lint sum=r.fr+r.sc;\n    if(n&1 && i+1==m) chmin(dp[i+1][j],dp[i][j]+sum*i);\n    else chmin(dp[i+1][j],dp[i][j]+sum*i+r.sc);\n    if(n&1 && j+1==m) chmin(dp[i][j+1],dp[i][j]+sum*j);\n    else chmin(dp[i][j+1],dp[i][j]+sum*j+r.fr);\n  }\n  lint res=INF;\n  REP(i,m+1) REP(j,m+1) if(i+j==n) chmin(res,dp[i][j]);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL L[5011], R[5011];\npair<LL, int> P[5011];\n\nLL buf[2][5011];\nLL *cur = buf[0];\nLL *nxt = buf[1];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld\", L+i, R+i);\n\n    REP (i, N) P[i] = make_pair(L[i]+R[i], i);\n    sort(P, P+N);\n    reverse(P, P+N);\n\n    int M = N - N%2;\n    memset(cur, 0x3f, sizeof buf[0]);\n    cur[0] = 0;\n    REP (i, M) {\n\tLL l = L[P[i].second];\n\tLL r = R[P[i].second];\n\n\tmemset(nxt, 0x3f, sizeof buf[0]);\n\n\tREP (a, i+1) {\n\t    int b = i-a;\n\n\t    if ((a+1)*2 <= N) {\n\t\tamin(nxt[a+1], cur[a] + r + (l+r)*a);\n\t    }\n\t    if ((b+1)*2 <= N) {\n\t\tamin(nxt[a], cur[a] + l + (l+r)*b);\n\t    }\n\t}\n\tswap(cur, nxt);\n    }\n\n    LL ans = cur[M/2];\n    if (N % 2) ans += P[N-1].first * (M/2);\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[2510][2510][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tll n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n / 2 + 1)rep(j, n / 2 + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst ll m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\trep(k, m + 1) {\n\t\t\t\tconst int r = i - l - k;\n\t\t\t\tif (l < 0 or l > n / 2) continue;\n\t\t\t\tif (r < 0 or r > n / 2) continue;\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = 1LL * (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = 1LL * (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n / 2) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define l first\n#define r second\n\nint main() {\n    //ifstream cin(\"testF.in\");\n    int n; cin >> n;\n\n    vector<pair<int, int>> a(n);\n    for(int i = 0; i < n; ++i)\n        cin >> a[i].l >> a[i].r;\n    \n    \n    sort(a.begin(), a.end(), [&] (pair<int, int> A, pair<int, int> B) {\n        return (A.l + A.r) > (B.l + B.r);\n    });\n    \n    int64_t ans = 1e15;\n\n    for(int fixed = n - 1; fixed < n; ++fixed) {\n        vector<int64_t> dp(n + 1, 1e15);\n        int64_t many = 0;\n        dp[0] = 0;\n        for(int i = 0; i < n; ++i) {\n            if(fixed == i)\n                continue;\n            many++;\n            int len = a[i].r + a[i].l;\n            vector<int64_t> newDp(n + 1, 1e15);\n            newDp[0] = dp[0] + a[i].r + a[fixed].l + (many - 1) * len;\n            for(int j = 0; j < many; ++j) {\n                newDp[j + 1] = min(dp[j + 1] + a[i].r + a[fixed].l + 1LL * (many - 1 - (j + 1)) * len, dp[j] + a[i].l + a[fixed].r + 1LL * j * len);\n            }\n            dp = newDp;\n        }\n        int64_t temp = 1e9;\n        for(int i = 0; i <= n; ++i)\n            temp = min(temp, dp[i]);\n        ans = min(ans, temp);\n    }\n    \n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e17)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//ダイナミックプログラミンッ!!!\n\tint i,j,n;cin>>n;\n\tstatic llint dp[2505][2505]={0};\n\tvector<tuple<llint,llint,llint>> kuka(n);\n\tfor(i=0;i<n;i++){\n\t\tllint L,R;cin>>L>>R;\n\t\tkuka[i]=mt(L+R,L,R);\n\t}\n\tSO(kuka);REV(kuka);\n\t//でかい奴から両端に埋めていく\n\t//(n/2個) ((n+1)/2個) になる\n\tdp[0][0]=-big;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tint hi=j;\n\t\t\tint mg=i-j;\n\t\t\tif(n/2<hi){continue;}\n\t\t\tif((n+1)/2<mg){continue;}\n\t\t\tllint wa,L,R;\n\t\t\ttie(wa,L,R)=kuka[i];\n\t\t\tmineq(dp[hi+1][mg],dp[hi][mg]+hi*wa+L);\n\t\t\tmineq(dp[hi][mg+1],dp[hi][mg]+mg*wa+R);\n\t\t}\n\t}\n\t\n\tcout<<dp[n/2][(n+1)/2]+big<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long L[5100];\nlong long R[5100];\nlong long l[5100];\nlong long r[5100];\npair<long long,int>p[5100];\nlong long dp[5100][5100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lld%lld\",L+i,R+i);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=make_pair(R[i]+L[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tl[i]=L[p[i].second];\n\t\tr[i]=R[p[i].second];\n\t}\n\tfor(int i=0;i<5100;i++)for(int j=0;j<5100;j++)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(a%2&&i==0){\n\t\t\tdp[1][0]=l[0]*(a/2)+r[0]*(a/2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<=min(i-a%2,a/2);j++){\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+l[i]*(a/2-j)+r[i]*(a/2-j-1));\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+l[i]*(a/2-(i-j-a%2)-1)+r[i]*(a/2-(i-j-a%2)));\n\t\t}\n\t}\n\tlong long ret=dp[a][a/2];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long L[5100];\nlong long R[5100];\nlong long l[5100];\nlong long r[5100];\npair<long long,int>p[5100];\nlong long dp[5100][2600][2];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lld%lld\",L+i,R+i);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=make_pair(R[i]+L[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tl[i]=L[p[i].second];\n\t\tr[i]=R[p[i].second];\n\t}\n\tfor(int i=0;i<5100;i++)for(int j=0;j<5100;j++)dp[i][j][0]=dp[i][j][1]=inf;\n\tdp[0][0][0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<=min(i,a/2);j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tif(dp[i][j][k]==inf)continue;\n\t\t\t\tif(k==0){\n\t\t\t\t\tdp[i+1][j][k+1]=min(dp[i+1][j][k+1],dp[i][j][k]+(l[i]+r[i])*(a/2));\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1][k]=min(dp[i+1][j+1][k],dp[i][j][k]+l[i]*(a/2-j)+r[i]*(a/2-j-1));\n\t\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]+l[i]*(a/2-(i-j-k)-1)+r[i]*(a/2-(i-j-k)));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=dp[a][a/2][a%2];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nstruct node{\n\tint l,r;\n\tvoid read(){\n\t\tgn(l);gn(r);\n\t}\n}a[5555];\nint cmp(const node&a,const node&b){\n\treturn a.r+a.l>b.r+b.l;\n}\n\n\nll f[2][5055][2];\nint n;\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\trep(i,1,n+1){\n\t\ta[i].read();\n\t}\n\tfil(f[0],63);\n\tf[0][0][0]=0;\n\tsort(a+1,a+1+n,cmp);\n\n\tll ans=0x3f3f3f3f3f3f3f3fll;\n\tfor (int d=0;d<n;d++){\n\t\tfil(f[(d&1)^1],63);\n\t\trep(l,0,d+1){\n\t\t\tint r=d-l;\n\t\t\tupmin(f[(d&1)^1][l][0],f[d&1][l][0]+a[d+1].l+1ll*r*(a[d+1].r+a[d+1].l));\n\t\t\tupmin(f[(d&1)^1][l+1][0],f[d&1][l][0]+a[d+1].r+1ll*l*(a[d+1].r+a[d+1].l));\n\n\t\t\tupmin(f[(d&1)^1][l][1],f[d&1][l][0]+1ll*(n/2)*(a[d+1].r+a[d+1].l));\n\n\t\t\tif(d-l-1>=0){\n\t\t\t\tr=d-l-1;\n\t\t\t\tupmin(f[(d&1)^1][l][1],f[d&1][l][1]+a[d+1].l+1ll*r*(a[d+1].r+a[d+1].l));\n\t\t\t\tupmin(f[(d&1)^1][l+1][1],f[d&1][l][1]+a[d+1].r+1ll*l*(a[d+1].r+a[d+1].l));\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,0,n+1){\n\t\tupmin(ans,f[n&1][i][0]);\n\t}\n\tif(n%2==1){\n\t\tupmin(ans,f[n&1][n/2][1]);\n\t}\n\n\tcout<<ans<<endl;\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//another memory test XD\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, d;\n\tinline int operator<(const seg &a) const {return d > a.d;}\n} s[10010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[5010][5010][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].d = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tm = n >> 1;\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[i][j][0] = f[i][j][1] = inf;\n\tf[0][0][0] = 0;\n\t\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m && i+j < n; ++j)\n\t\t\tfor (int k = 0; k <= 1 && i+j+k < n; ++k)\n\t\t\t{\n\t\t\t\tconst ll tmp = f[i][j][k]; const seg p = s[i+j+k+1];\n\t\t\t\tif (i < m)\tf[i+1][j][k] = min(f[i+1][j][k], tmp + p.r + i*p.d);\n\t\t\t\tif (j < m)\tf[i][j+1][k] = min(f[i][j+1][k], tmp + p.l + j*p.d);\n\t\t\t\tif (!k)\t\tf[i][j][k|1] = min(f[i][j][k|1], tmp + m * p.d);\n\t\t\t}\n\t\n\tcout << f[m][m][n&1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[2510][2510][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst int m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\tconst int r = i - l;\n\t\t\tif (l > n / 2 or r > n / 2) continue;\n\t\t\trep(k, m + 1) {\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n - 1) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+(r[idx]+l[idx])*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+(r[idx]+l[idx])*(i-j)+l[idx]);\n    }\n  }\n  ll suml=0,sumr=0;\n  rep(i,0,n){\n    suml+=l[i];\n    sumr+=r[i];\n  }\n  //debug(dp,n+1,n+1);\n  cout<<min({*min_element(ALL(dp[n])),dp[n][0]-suml,dp[n][n]-sumr})<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define VL vector<long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint from[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    int id=-1;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x){\n                dp[x][y]=dp[x-1][y]+(x-1LL)*p[i].F+(p[i].S+offset);\n                from[x][y]=0;\n            }\n            else dp[x][y]=INF;\n            if(y){\n                if(dp[x][y]>dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset)){\n                    dp[x][y]=dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset);\n                    from[x][y]=1;\n                }\n            }\n            if(i==N-1){\n                if(res>dp[x][y]){\n                    res=dp[x][y];\n                    id=x;\n                }\n            }\n        }\n    }\n    VPII left,right;\n    int x=id,y=N-id;\n    for(int i=N-1;i>=0;i--){\n        if(from[x][y]){\n            right.PB(MP(p[i].F,p[i].S+offset));\n            y--;\n        }\n        else{\n            left.PB(MP(p[i].F,p[i].S+offset));\n            x--;\n        }\n    }\n    VL d;\n    LL now=0;\n    REP(i,SZ(left)){\n        d.PB(left[i].S+now);\n        now+=left[i].F;\n    }\n    now=0;\n    REP(i,SZ(right)){\n        d.PB(-(right[i].F-right[i].S)-now);\n        now+=right[i].F;\n    }\n    sort(ALL(d));\n    LL an=0;\n    for(int i=0,j=SZ(d)-1;j>i;j--,i++)an+=d[j]-d[i];\n    return an;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    int SEG=5;\n    LL res=INF;\n    REP(i,SEG){\n        res=min(res,f(ll+(LL)(rr-ll)*i/(SEG-1)));\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2550;\nusing ll = long long;\nusing pll = pair<ll, ll>;\nvoid amin(ll &a, ll b){\n\ta = min(a, b);\n}\nll f[2][maxn][maxn];\nint main(){\n\tvector<pll> e;\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, b; cin >> a >> b;\n\t\te.push_back({a, b});\n\t}\n\tsort(e.begin(), e.end(), [](pll a, pll b){\n\t\treturn a.first + a.second > b.first + b.second;\n\t});\n\tint m = n / 2;\n\tconst ll inf = 1ll<<60;\n\tfor(int i = 0; i < 2; i++) \n\t\tfor(int j = 0; j <= m; j++) \n\t\t\tfor(int k = 0; k <= m; k++) \n\t\t\t\tf[i][j][k] = inf;\n\tf[0][0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, b; tie(a, b) = e[i];\n\t\tll l = a + b;\n\t\tint ati = min(i, m);\n\t\tfor(int x = 0; x < 2; x++){\n\t\t\tfor(int y = 0; y + x <= ati; y++){\n\t\t\t\tint z = i - y - x;\n\t\t\t\tamin(f[x][y+1][z], f[x][y][z] + b + y * l);\n\t\t\t\tamin(f[x][y][z+1], f[x][y][z] + a + z * l);\n\t\t\t\tif(!x){\n\t\t\t\t\tamin(f[1][y][z], f[x][y][z] + m * l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << f[n&1][m][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long L[5100];\nlong long R[5100];\nlong long l[5100];\nlong long r[5100];\npair<long long,int>p[5100];\nlong long dp[5100][5100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lld%lld\",L+i,R+i);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=make_pair(R[i]+L[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tl[i]=L[p[i].second];\n\t\tr[i]=R[p[i].second];\n\t}\n\tfor(int i=0;i<5100;i++)for(int j=0;j<5100;j++)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(a%2&&i==0){\n\t\t\tdp[1][0]=l[0]*(a/2)+r[0]*(a/2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<=min(i,a/2);j++){\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+l[i]*(a/2-j)+r[i]*(a/2-j-1));\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+l[i]*(a/2-(i-j-a%2)-1)+r[i]*(a/2-(i-j-a%2)));\n\t\t}\n\t}\n\tlong long ret=dp[a][a/2];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define VL vector<long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint from[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    int id=-1;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x){\n                dp[x][y]=dp[x-1][y]+(x-1LL)*p[i].F+(p[i].S+offset);\n                from[x][y]=0;\n            }\n            else dp[x][y]=INF;\n            if(y){\n                if(dp[x][y]>dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset)){\n                    dp[x][y]=dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset);\n                    from[x][y]=1;\n                }\n            }\n            if(i==N-1){\n                if(res>dp[x][y]){\n                    res=dp[x][y];\n                    id=x;\n                }\n            }\n        }\n    }\n    VPII left,right;\n    int x=id,y=N-id;\n    for(int i=N-1;i>=0;i--){\n        if(from[x][y]){\n            right.PB(p[i]);\n            y--;\n        }\n        else{\n            left.PB(p[i]);\n            x--;\n        }\n    }\n    VL d;\n    LL now=0;\n    REP(i,SZ(left)){\n        d.PB(left[i].S+now);\n        now+=left[i].F;\n    }\n    now=0;\n    REP(i,SZ(right)){\n        d.PB(-(right[i].F-right[i].S)-now);\n        now+=right[i].F;\n    }\n    sort(ALL(d));\n    LL an=0;\n    for(int i=0,j=SZ(d)-1;j>i;j--,i++)an+=d[j]-d[i];\n    return an;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    cout<<f(0)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e17)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//ダイナミックプログラミンッ!!!\n\tint i,j,n;cin>>n;\n\tstatic llint dp[2505][2505]={0};\n\tvector<tuple<llint,llint,llint>> kuka(n);\n\tfor(i=0;i<n;i++){\n\t\tllint L,R;cin>>L>>R;\n\t\tkuka[i]=mt(L+R,L,R);\n\t}\n\tSO(kuka);REV(kuka);\n\t//でかい奴から両端に埋めていく\n\t//(n/2個) ((n+1)/2個) になる\n\tdp[0][0]=-big;\n\t//n%2==1のとき、片方が埋まった状態も考えなければならない\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tint hi=j;\n\t\t\tint mg=i-j;\n\t\t\tif(n/2<hi){continue;}\n\t\t\tif(n/2<mg){continue;}\n\t\t\tllint wa,L,R;\n\t\t\ttie(wa,L,R)=kuka[i];\n\t\t\tmineq(dp[hi+1][mg],dp[hi][mg]+hi*wa+L);\n\t\t\tmineq(dp[hi][mg+1],dp[hi][mg]+mg*wa+R);\n\t\t\tif(n%2==1){dp[hi][mg]+=(n/2)*wa;}\n\t\t}\n\t}\n\tcout<<dp[n/2][n/2]+big<<endl;\n\tRE;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  rep(k,n) {\n    vl d(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll INF=1e18;\nint main()\n{\n    int n; cin>>n;\n    ll l[5010], r[5010];\n    vector<int> ind(n);\n    iota(ind.begin(), ind.end(), 0);\n    for(int i=0; i<n; i++) cin>>l[i]>>r[i];\n    if(n==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    sort(ind.begin(), ind.end(), [&](int i, int j){ return l[i]+r[i]>l[j]+r[j];});\n    ll dp[2][5010];\n    dp[0][0]=0;\n    for(int i=0; i<n; i++){\n        int t=ind[i];\n        for(int j=0; j<=i+1; j++) dp[(i+1)&1][j]=INF;\n        for(int j=0; j<=i; j++){\n            dp[(i+1)&1][j]=min(dp[(i+1)&1][j], dp[i&1][j]+(i-j)*(l[t]+r[t])+l[t]);\n            dp[(i+1)&1][j+1]=min(dp[(i+1)&1][j+1], dp[i&1][j]+j*(l[t]+r[t])+r[t]);\n        }\n    }\n    ll ans=INF;\n    for(int i=0; i<=n; i++) ans=min(ans, dp[n&1][i]);\n    if(n%2==0){\n        cout<<ans<<endl;\n        return 0;\n    }\n    ll dp2[2][2][5010];\n    dp2[0][0][0]=0, dp2[0][1][0]=INF;\n    for(int i=0; i<n; i++){\n        int t=ind[i];\n        for(int j=0; j<=i+1; j++) dp2[(i+1)&1][0][j]=dp2[(i+1)&1][1][j]=INF;\n        for(int j=0; j<=i; j++){\n            for(int k=0; k<2; k++){\n                dp2[(i+1)&1][k][j]=min(dp2[(i+1)&1][k][j], dp2[i&1][k][j]+(i-j)*(l[t]+r[t])+l[t]);\n                dp2[(i+1)&1][k][j+1]=min(dp2[(i+1)&1][k][j+1], dp2[i&1][k][j]+j*(l[t]+r[t])+r[t]);\n            }\n            dp2[(i+1)&1][1][j]=min(dp2[(i+1)&1][1][j], dp2[i&1][0][j]+(n-1)/2*(l[t]+r[t]));\n        }\n    }\n    ans=min(ans, dp2[n&1][1][(n-1)/2]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 5005;\nconst ll inf = 1e18;\nint n , l[N] , r[N];\nll dp[2][N][2];\ninline void Update(ll &x,ll d) {\n  if(x > d) x = d;\n}\n\nint main(){\n  cin >> n;\n  rep(i,0,n) cin >> l[i] >> r[i];\n  vector<pair<ll,int> > seg;\n  rep(i,0,n) seg.pb(mp(l[i] + r[i] , i));\n  sort(all(seg));\n  reverse(all(seg));\n  rep(i,0,2) rep(j,0,N) rep(k,0,2) dp[i][j][k] = inf;\n  auto f = dp[0] , g = dp[1];\n  f[0][0] = 0;\n  int goleft = n / 2 , goright = n - 1 - goleft;\n  rep(i,0,n) {\n    int s = seg[i].se;\n    rep(j,0,i+2) rep(k,0,2) g[j][k] = inf;\n    rep(j,0,i+1) {\n      if(f[j][0] != inf) {\n        Update(g[j][0] , f[j][0] + ll(l[s] + r[s]) * (i - j) + l[s]);\n        Update(g[j+1][0] , f[j][0] + ll(l[s] + r[s]) * j + r[s]);\n        Update(g[j][1] , f[j][0] + ll(goleft) * l[s] + ll(goright) * r[s]);\n      }\n      if(f[j][1] != inf) {\n        Update(g[j][1] , f[j][1] + ll(l[s] + r[s]) * (i - 1 - j) + l[s]);\n        Update(g[j+1][1] , f[j][1] + ll(l[s] + r[s]) * j + r[s]);\n      }\n    }\n    swap(f , g);\n  }\n  cout << f[goleft][1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long L[5100];\nlong long R[5100];\nlong long l[5100];\nlong long r[5100];\npair<long long,int>p[5100];\nlong long dp[5100][5100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tif(a%2)return 1;\n\tfor(int i=0;i<a;i++)scanf(\"%lld%lld\",L+i,R+i);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=make_pair(R[i]+L[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tl[i]=L[p[i].second];\n\t\tr[i]=R[p[i].second];\n\t}\n\tfor(int i=0;i<5100;i++)for(int j=0;j<5100;j++)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(a%2&&i==0){\n\t\t\tdp[1][0]=l[0]*(a/2)+r[0]*(a/2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<=min(i-a%2,a/2);j++){\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+l[i]*(a/2-j)+r[i]*(a/2-j-1));\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+l[i]*(a/2-(i-j-a%2)-1)+r[i]*(a/2-(i-j-a%2)));\n\t\t}\n\t}\n\tlong long ret=dp[a][a/2];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[2510][2510][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tll n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n / 2 + 1)rep(j, n / 2 + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst ll m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\trep(k, m + 1) {\n\t\t\t\tconst int r = i - l - k;\n\t\t\t\tif (l < 0 or l > n / 2) continue;\n\t\t\t\tif (r < 0 or r > n / 2) continue;\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = 1LL * (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = 1LL * (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n - 1) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    ll len=l[idx]+r[idx];\n    if(i==n-1&&n&1)l[idx]=0,r[idx]=0;\n    rep(j,0,i+1){\n      ll add1=len*j,add2=len*(i-j);\n      if(i==n-1&&n&1)add1=len*i,add2=len*i;\n      chmin(dp[i+1][j+1],dp[i][j]+add1+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+add2+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<*min_element(ALL(dp[n]))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n#define fst first\n#define snd second\n\nll dp[2510][2510][2];\nll L[5010], R[5010];\n\nconst ll inf = 1LL << 60;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\t{\n\t\tusing pll = pair<ll, ll>;\n\t\tvector<pll> ary;\n\n\t\trep(i, n) {\n\t\t\tcin >> L[i] >> R[i];\n\t\t\tary.push_back(pll(L[i] + R[i], L[i]));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\n\t\trep(i, n) {\n\t\t\tL[i] = ary[i].snd;\n\t\t\tR[i] = ary[i].fst - L[i];\n\t\t}\n\t}\n\n\trep(i, n / 2 + 1)rep(j, n / 2 + 1)rep(k, 2) dp[i][j][k] = inf;\n\tdp[0][0][0] = 0LL;\n\n\tconst int m = n % 2;\n\n\t// cost = \\sum  L_i  + \\sum R_i\n\n\trep(i, n) {\n\t\trep(l, i + 1) {\n\t\t\trep(k, m + 1) {\n\t\t\t\tconst int r = i - l - k;\n\t\t\t\tif (l > n / 2 or r > n / 2) continue;\n\n\t\t\t\t// dp[l][r][k]\n\n\t\t\t\t// left\n\t\t\t\tif (l + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - l) * (L[i] + R[i]) + R[i];\n\t\t\t\t\tchmin(dp[l + 1][r][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// right\n\t\t\t\tif (r + 1 <= n / 2) {\n\t\t\t\t\tconst ll add = (n / 2 - 1 - r) * (L[i] + R[i]) + L[i];\n\t\t\t\t\tchmin(dp[l][r + 1][k], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t\t// odd\n\t\t\t\tif (k + 1 <= m) {\n\t\t\t\t\tconst ll add = (n - 1) * (L[i] + R[i]);\n\t\t\t\t\tchmin(dp[l][r][k + 1], dp[l][r][k] + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n / 2][n / 2][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nvector<pii> arr;\nint cmp(pii a,pii b){\n  return a.Y-a.X<b.Y-b.X;\n}\nll dp[5005][5005];\nint main(){\n  int n; scanf(\"%d\",&n); \n  if(n==1){\n    printf(\"0\\n\"); exit(0);\n  }\n  REP(i,n){\n    pii z; scanf(\"%d%d\",&z.X,&z.Y); z.X=-z.X; arr.pb(z);\n  }\n  sort(all(arr),cmp);\n  reverse(all(arr));\n  int fl=1;\n  REP(i,n-1) if(arr[i].X-arr[i].Y!=arr[i+1].X-arr[i+1].Y) fl=0;\n  if(fl){\n    assert(0);\n    sort(all(arr));\n    swap(arr[n/2],arr[n-1]);\n  } \n  REP(i,n+1) REP(j,n+1)  dp[i][j]=INF;\n  dp[0][0]=0;\n  ll lk = -arr[n-1].X,rk=arr[n-1].Y;\n  ll ans=INF;\n  REP(i,n){\n    ll ls = arr[i].X,rs=arr[i].Y;\n    ll dis = rs-ls;\n    \n   // printf(\"%lld %lld\\n\",lk,rk);\n    REP(j,i+1)if(dp[i][j]<INF){\n    //  printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n      dp[i+1][j]=min(dp[i+1][j],dp[i][j]+(i-j)*dis+lk+rs);\n      dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+j*dis+rk-ls);\n    }\n  }\n  REP(i,n) ans=min(ans,dp[n-1][i]);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst LL INF = 1LL << 61;\n\nint N;\nLL L[5145];\nLL R[5145];\nLL W[5145];\nLL dp[2][5145];\nint Llast[2][5145];\nint Rlast[2][5145];\nvector<int> ps;\n\nLL Solve(LL x) {\n  rep(i, N) {\n    L[i] -= x;\n    R[i] += x;\n  }\n\n  int src = 0;\n  int dst = 1;\n  fill(dp[src], dp[src+1], INF);\n  dp[src][0] = 0;\n  rep(i, N) {\n    fill(dp[dst], dp[dst+1], INF);\n\n    int idx = ps[i];\n    rep(j, i+1) {\n      if (MN(dp[dst][j+1], dp[src][j] + j*W[idx] + R[idx])) {\n        Llast[dst][j+1] = idx;\n        Rlast[dst][j+1] = Rlast[src][j];\n      }\n\n      if (MN(dp[dst][j], dp[src][j] + (i-j)*W[idx] + L[idx])) {\n        Llast[dst][j] = Llast[src][j];\n        Rlast[dst][j] = idx;\n      }\n    }\n\n    swap(src, dst);\n  }\n\n  LL ret = INF;\n  if (N%2 == 0) {\n    ret = dp[src][N/2];\n  } else {\n    int l = N/2;\n    int idx = Rlast[src][l];\n    MN(ret, dp[src][l] - (N-l)*L[idx] + l*L[idx]);\n    idx = Llast[src][l+1];\n    MN(ret, dp[src][l+1] - (l+1)*R[idx] + (N-1-l)*R[idx]);\n  }\n\n  rep(i, N) {\n    L[i] += x;\n    R[i] -= x;\n  }\n\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n\n  LL ml = INF;\n  LL mr = INF;\n  rep(i, N) {\n    cin >> L[i] >> R[i];\n    W[i] = L[i] + R[i];\n    ps.eb(i);\n    MN(ml, L[i]);\n    MN(mr, R[i]);\n  }\n  sort(all(ps), [&](int a, int b){return W[a] > W[b];});\n\n  LL ans = INF;\n  ans = Solve(0);\n  //LL low = -ml-1;\n  //LL high = mr+1;\n  //while (high - low > 10) {\n  //  LL lmid = (high+low*2)/3;\n  //  LL rmid = (high*2+low)/3;\n  //  LL lval = Solve(lmid);\n  //  LL rval = Solve(rmid);\n  //  if (lval < rval) high = rmid;\n  //  else low = lmid;\n  //}\n\n  //for (LL i=low; i<high+1; i++) {\n  //  if (i < -ml || mr < i) continue;\n  //  MN(ans, Solve(i));\n  //}\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    ll len=l[idx]+r[idx];\n    if(i==n-1&&n&1)l[idx]=0,r[idx]=0;\n    rep(j,0,i+1){\n      ll add1=len*j,add2=len*(i-j);\n      if(i==n-1&&n&1)add1=len*(i/2),add2=len*(i/2);\n      chmin(dp[i+1][j+1],dp[i][j]+add1+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+add2+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<*min_element(ALL(dp[n]))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long L[5100];\nlong long R[5100];\nlong long l[5100];\nlong long r[5100];\npair<long long,int>p[5100];\nlong long dp[5100][5100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lld%lld\",L+i,R+i);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=make_pair(R[i]+L[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tl[i]=L[p[i].second];\n\t\tr[i]=R[p[i].second];\n\t}\n\tfor(int i=0;i<5100;i++)for(int j=0;j<5100;j++)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(a%2&&i==0){\n\t\t\tdp[1][0]=l[0]*(a/2)+r[0]*(a/2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<=min(i-a%2,a/2);j++){\n\t\t\tif(dp[i][j]==inf)continue;\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+l[i]*(a/2-j)+r[i]*(a/2-j-1));\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+l[i]*(a/2-(i-j-a%2)-1)+r[i]*(a/2-(i-j-a%2)));\n\t\t}\n\t}\n\tlong long ret=dp[a][a/2];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL L[5011], R[5011];\npair<LL, int> P[5011];\n\nLL dp[2][5011];\nLL ep[2][5011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld\", L+i, R+i);\n\n    REP (i, N) P[i] = make_pair(L[i]+R[i], i);\n    sort(P, P+N);\n    reverse(P, P+N);\n\n    memset(dp, 0x3f, sizeof dp);\n    memset(ep, 0x3f, sizeof ep);\n    int cur = 0, nxt = 1;\n    dp[0][0] = 0;\n    REP (i, N) {\n\tLL l = L[P[i].second];\n\tLL r = R[P[i].second];\n\n\tmemset(dp[nxt], 0x3f, sizeof dp[nxt]);\n\tmemset(ep[nxt], 0x3f, sizeof ep[nxt]);\n\n\tREP (a, i+1) {\n\t    int b = i-a;\n\n\t    if ((a+1)*2 <= N) {\n\t\tamin(dp[nxt][a+1], dp[cur][a] + r + (l+r)*a);\n\t\tamin(ep[nxt][a+1], ep[cur][a] + r + (l+r)*a);\n\t    }\n\t    if ((b+1)*2 <= N) {\n\t\tamin(dp[nxt][a], dp[cur][a] + l + (l+r)*b);\n\t\tamin(ep[nxt][a], ep[cur][a] + l + (l+r)*b);\n\t    }\n\n\t    amin(ep[nxt][a], dp[cur][a] + abs(l-r)/2 + (N-1)/2*(l+r));\n\t}\n\tswap(cur, nxt);\n    }\n\n    LL ans;\n    if (N % 2 == 0) ans = dp[cur][N/2];\n    else ans = ep[cur][N/2];\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define l first\n#define r second\n\nint main() {\n    //ifstream cin(\"testF.in\");\n    int n; cin >> n;\n\n    vector<pair<int, int>> a(n);\n    for(int i = 0; i < n; ++i)\n        cin >> a[i].l >> a[i].r;\n    \n    \n    sort(a.begin(), a.end(), [&] (pair<int, int> A, pair<int, int> B) {\n        return (A.l + A.r) > (B.l + B.r);\n    });\n    \n    int64_t ans = 1e15;\n\n    for(int fixed = n - 1; fixed < n; ++fixed) {\n        vector<int64_t> dp(n + 1, 1e15);\n        int64_t many = 0;\n        dp[0] = 0;\n        for(int i = 0; i < n; ++i) {\n            if(fixed == i)\n                continue;\n            many++;\n            int len = a[i].r + a[i].l;\n            vector<int64_t> newDp(n + 1, 1e15);\n            newDp[0] = dp[0] + a[i].r + a[fixed].l + (many - 1) * len;\n            for(int j = 0; j < many; ++j) {\n                newDp[j + 1] = min(dp[j + 1] + a[i].r + a[fixed].l + (many - 1 - (j + 1)) * len, dp[j] + a[i].l + a[fixed].r + j * len);\n            }\n            dp = newDp;\n        }\n        int64_t temp = 1e9;\n        for(int i = 0; i <= n; ++i)\n            temp = min(temp, dp[i]);\n        ans = min(ans, temp);\n    }\n    \n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; cin>>n;\n    ll l[5010], r[5010];\n    vector<int> ind(n);\n    iota(ind.begin(), ind.end(), 0);\n    for(int i=0; i<n; i++) cin>>l[i]>>r[i];\n    sort(ind.begin(), ind.end(), [&](int i, int j){ return l[i]+r[i]>l[j]+r[j];});\n    ll dp[5010][5010];\n    for(int i=0; i<=n; i++) for(int j=0; j<=i; j++) dp[i][j]=1e18;\n    dp[0][0]=0;\n    for(int i=0; i<n; i++){\n        int t=ind[i];\n        for(int j=0; j<=i; j++){\n            dp[i+1][j]=min(dp[i+1][j], dp[i][j]+(i-j)*(l[t]+r[t])+l[t]);\n            dp[i+1][j+1]=min(dp[i+1][j+1], dp[i][j]+j*(l[t]+r[t])+r[t]);\n        }\n    }\n    ll ans=1e18;\n    for(int i=0; i<=n; i++) ans=min(ans, dp[n][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=make_v(n+1,n+1,INF);\n  auto dp2=make_v(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    ll len=l[idx]+r[idx];\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+len*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+len*(i-j)+l[idx]);\n      chmin(dp2[i+1][j],dp[i][j]+len*(n/2));\n      chmin(dp2[i+1][j+1],dp2[i][j]+len*j+r[idx]);\n      if(i-j-1>=0)chmin(dp2[i+1][j],dp2[i][j]+len*(i-j-1)+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  if(~n&1)cout<<dp[n][n/2]<<endl;\n  else cout<<dp2[n][n/2]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    ll len=l[idx]+r[idx];\n    if(i==n-1&&n&1)l[idx]=0,r[idx]=0;\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+len*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+len*(i-j)+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<*min_element(ALL(dp[n]))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  rep(k,n) {\n    vl d(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n \n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n \nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[5010][5010];\n \nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n \n \tassert(N<=300);\n\trep(i, N) { //fix\n\t\tvector<pii> vec;\n \n\t\trep(j, N) {\n\t\t\tif (j != i) {\n\t\t\t\tvec.eb(L[j]+R[j], j);\n\t\t\t}\n\t\t}\n \n\t\tsort(ALL(vec));\n \n\t\tfor (int l=0; l <= N-1; ++l) { // to left\n\t\t\tll t = (ll)L[i] * l + (ll)R[i] * (N-1-l);\n\t\t\trep(j, N) rep(k, N) dp[j][k] = LLONG_MAX;\n \n\t\t\tdp[0][0] = 0;\n\n\t\t\trep(j, N-1) {\n\t\t\t\tint id = vec[j].se;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif (dp[j][k] == LLONG_MAX) continue;\n\t\t\t\t\tdp[j+1][k+1] = min(dp[j+1][k+1], dp[j][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[j][k] + (ll)((N-1-l)-1-(j-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt += dp[N-1][l];\n\t\t\tret = min(ret, t);\n\t\t}\n\t}\n \n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long L[5100];\nlong long R[5100];\nlong long l[5100];\nlong long r[5100];\npair<long long,int>p[5100];\nlong long dp[5100][5100][2];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lld%lld\",L+i,R+i);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=make_pair(R[i]+L[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tl[i]=L[p[i].second];\n\t\tr[i]=R[p[i].second];\n\t}\n\tfor(int i=0;i<5100;i++)for(int j=0;j<5100;j++)dp[i][j][0]=dp[i][j][1]=inf;\n\tdp[0][0][0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<=min(i,a/2);j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tif(dp[i][j][k]==inf)continue;\n\t\t\t\tif(k==0){\n\t\t\t\t\tdp[i+1][j][k+1]=min(dp[i+1][j][k+1],dp[i][j][k]+(l[i]+r[i])*(a/2));\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1][k]=min(dp[i+1][j+1][k],dp[i][j][k]+l[i]*(a/2-j)+r[i]*(a/2-j-1));\n\t\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]+l[i]*(a/2-(i-j-k)-1)+r[i]*(a/2-(i-j-k)));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=dp[a][a/2][a%2];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 62;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\npl I[MAX_N];\nll dp[2510][2510][2];\n\nbool comp(const pl& p1, const pl& p2) {\n\treturn p1.sec + p1.fst >= p2.sec + p2.fst;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tI[i] = pl(l, r);\n\t}\n\tsort(I, I + N, comp);\n\n\tint LN = (N - 1) / 2, RN = N / 2;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\tdp[i][j][0] = linf;\n\t\t\tdp[i][j][1] = linf;\n\t\t}\n\t}\n\n\tdp[0][0][0] = 0;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\trep(k, 0, 2) {\n\t\t\t\tif(dp[i][j][k] == linf) continue;\n\t\t\t\tint id = i + j + k;\n\t\t\t\tll l = I[id].fst, r = I[id].sec;\n\t\t\t\tif(i < LN) MIN(dp[i + 1][j][k], dp[i][j][k] + (i + 1) * (l + r) - l);\n\t\t\t\tif(j < RN) MIN(dp[i][j + 1][k], dp[i][j][k] + (j + 1) * (l + r) - r);\n\t\t\t\tif(k == 0) MIN(dp[i][j][k + 1], dp[i][j][k] + l * LN + r * RN);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[LN][RN][1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define VL vector<long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint from[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    int id=-1;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x){\n                dp[x][y]=dp[x-1][y]+(x-1LL)*p[i].F+(p[i].S+offset);\n                from[x][y]=0;\n            }\n            else dp[x][y]=INF;\n            if(y){\n                if(dp[x][y]>dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset)){\n                    dp[x][y]=dp[x][y-1]+(LL)y*p[i].F-(p[i].S+offset);\n                    from[x][y]=1;\n                }\n            }\n            if(i==N-1){\n                if(res>dp[x][y]){\n                    res=dp[x][y];\n                    id=x;\n                }\n            }\n        }\n    }\n    VPII left,right;\n    int x=id,y=N-id;\n    for(int i=N-1;i>=0;i--){\n        if(from[x][y]){\n            right.PB(p[i]);\n            y--;\n        }\n        else{\n            left.PB(p[i]);\n            x--;\n        }\n    }\n    VL d;\n    LL now=0;\n    REP(i,SZ(left)){\n        d.PB(left[i].S+offset+now);\n        now+=left[i].F;\n    }\n    now=0;\n    REP(i,SZ(right)){\n        d.PB(-(right[i].F-right[i].S-offset)-now);\n        now+=right[i].F;\n    }\n    sort(ALL(d));\n    LL an=0;\n    for(int i=0,j=SZ(d)-1;j>i;j--,i++)an+=d[j]-d[i];\n    return an;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    int SEG=3;\n    LL res=f(0);\n    REP(i,SEG){\n        res=min(res,f(ll+(LL)(rr-ll)*i/(SEG-1)));\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nbool cmp(const ii &a, const ii &b)\n{\n\tll lena = a.se-a.fi; ll lenb = b.se-b.fi;\n\tif(lena!=lenb) return lena>lenb;\n\telse return a.fi<a.se;\n}\n\nll pref[5011][5111];\nll suf[3][5111];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tif(n==1){cout<<0<<'\\n'; return 0;}\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tvec.pb({-l,r});\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcerr<<vec[i].fi<<' '<<vec[i].se<<'\\n';\n\t}\n\t*/\n\tll ans = ll(2e18);\n\tfor(int l=(n-1)/2;l<=n/2;l++)\n\t{\n\t\tint r=n-1-l;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tpref[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tsuf[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tpref[0][0]=vec[0].se;\n\t\tpref[0][1]=-vec[0].fi;\n\t\tfor(int i=0;i+1<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(pref[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=pref[i][j];\n\t\t\t\t\tll L=vec[i+1].fi; ll R=vec[i+1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(pref[i+1][j], v+R+ll(i+1-j)*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(pref[i+1][j+1], v-L+ll(j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuf[(n-1)&1][0]=vec[n-1].se+ll(l-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tsuf[(n-1)&1][1]=-vec[n-1].fi+ll(r-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tfor(int i=max(n-2,0);i<n;i++)\n\t\t{\n\t\t\t//segment i is fixed\n\t\t\tll constant = vec[i].se*r-vec[i].fi*l;\n\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t{\n\t\t\t\tll lef = 0; \n\t\t\t\tll ri = 0;\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse lef=pref[i-1][j];\n\t\t\t\tif(i==n-1)\n\t\t\t\t{\n\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse ri=suf[(i+1)&1][r-j];\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n-1;i>0;i--)\n\t\t{\n\t\t\tint cur=(i+1)&1; int pre=cur^1;\n\t\t\tfor(int j=0;j<=n;j++) suf[cur][j]=ll(1e18);\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(suf[pre][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=suf[pre][j];\n\t\t\t\t\tll L=vec[i-1].fi; ll R=vec[i-1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(suf[cur][j], v+R+ll(l-1-((n-1-i)+1-j))*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(suf[cur][j+1], v-L+ll(r-1-j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i2=i-2;\n\t\t\t\tif(i2<0) continue;\n\t\t\t\tll constant = vec[i2].se*r-vec[i2].fi*l;\n\t\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t\t{\n\t\t\t\t\tll lef = 0; \n\t\t\t\t\tll ri = 0;\n\t\t\t\t\tif(i2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse lef=pref[i2-1][j];\n\t\t\t\t\tif(i2==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse ri=suf[cur][r-j];\n\t\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[5050],R[5050];\npair<ll,int> P[5050];\n\nll dp[3030][3030][2];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>L[i]>>R[i];\n\t\tP[i]={R[i]+L[i],i};\n\t}\n\t\n\tFOR(x,3000) FOR(y,3000) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\tdp[0][0][0]=0;\n\t\n\tsort(P,P+N);\n\tFOR(i,N) {\n\t\tj=P[i].second;\n\t\tfor(l=0;l<=N/2;l++) {\n\t\t\tfor(k=0;k<=1;k++) {\n\t\t\t\tr=i-l-k;\n\t\t\t\tif(r<0 || r>N/2) continue;\n\t\t\t\t\n\t\t\t\tif(l+1<=N/2) dp[l+1][r][k]=min(dp[l+1][r][k],dp[l][r][k]+R[j]+(N/2-(l+1))*P[i].first);\n\t\t\t\tif(r+1<=N/2) dp[l][r+1][k]=min(dp[l][r+1][k],dp[l][r][k]+L[j]+(N/2-(r+1))*P[i].first);\n\t\t\t\tif(k==0)     dp[l][r][k+1]=min(dp[l][r][k+1],dp[l][r][k]+(N-1)*P[i].first);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(N%2) {\n\t\tcout<<dp[N/2][N/2][1]<<endl;\n\t}\n\telse {\n\t\tcout<<min(dp[N/2-1][N/2][1],dp[N/2][N/2-1][1])<<endl;\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(j,n) {\n    if (p[j].fi+p[j].se != p.back().fi+p.back().se) continue;\n    rep(i,n) {\n      ll l = p[j].fi, r = p[j].se;\n      int g = n-1-i;\n      mins(ans, d[i]+r*i+l*g);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[5050],R[5050];\npair<ll,int> P[5050];\n\nll dp[3030][3030][2];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>L[i]>>R[i];\n\t\tP[i]={R[i]+L[i],i};\n\t}\n\tif(N%2==0) {\n\t\tP[N]={0,N};\n\t\tN++;\n\t}\n\t\n\tFOR(x,3000) FOR(y,3000) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\tdp[0][0][0]=0;\n\t\n\tsort(P,P+N);\n\tFOR(i,N) {\n\t\tj=P[i].second;\n\t\tfor(l=0;l<=N/2;l++) {\n\t\t\tfor(k=0;k<=1;k++) {\n\t\t\t\tr=i-l-k;\n\t\t\t\tif(r<0 || r>N/2) continue;\n\t\t\t\t\n\t\t\t\tif(l+1<=N/2) dp[l+1][r][k]=min(dp[l+1][r][k],dp[l][r][k]+R[j]+(N/2-(l+1))*P[i].first);\n\t\t\t\tif(r+1<=N/2) dp[l][r+1][k]=min(dp[l][r+1][k],dp[l][r][k]+L[j]+(N/2-(r+1))*P[i].first);\n\t\t\t\tif(k==0)     dp[l][r][k+1]=min(dp[l][r][k+1],dp[l][r][k]+(N-1)/2*P[i].first);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<dp[N/2][N/2][1]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  srand(600);\n  int n;\n  scanf(\"%d\",&n);\n  assert(n != 5000);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  // {\n  //   vl dp(1,LINF);\n  //   dp[0] = 0;\n  //   vl d;\n  //   rep(k,n) {\n  //     d = vl(k+2,LINF);\n  //     swap(dp,d);\n  //     ll l = p[k].fi, r = p[k].se, w = r+l;\n  //     rep(j,k+1) {\n  //       int g = k-j;\n  //       mins(dp[j], d[j]+r+w*g);\n  //       mins(dp[j+1], d[j]+l+w*j);\n  //     }\n  //   }\n  // }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\npl I[MAX_N];\nll dp[2510][2510][2];\n\nbool comp(const pl& p1, const pl& p2) {\n\treturn p1.sec + p1.fst >= p2.sec + p2.fst;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tI[i] = pl(l, r);\n\t}\n\tsort(I, I + N, comp);\n\n\n\tint LN = (N - 1) / 2, RN = N / 2;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\tdp[i][j][0] = linf;\n\t\t\tdp[i][j][1] = linf;\n\t\t}\n\t}\n\n\tdp[0][0][0] = 0;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\trep(k, 0, 2) {\n\t\t\t\tif(dp[i][j][k] == linf) continue;\n\t\t\t\tint id = i + j + k;\n\t\t\t\tll l = I[id].fst, r = I[id].sec;\n\t\t\t\tif(i < LN) MIN(dp[i + 1][j][k], dp[i][j][k] + (i + 1) * (l + r) - l);\n\t\t\t\tif(j < RN) MIN(dp[i][j + 1][k], dp[i][j][k] + (j + 1) * (l + r) - r);\n\t\t\t\tif(k == 0) MIN(dp[i][j][k + 1], dp[i][j][k] + l * LN + r * RN);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[LN][RN][1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 5e3 + 10;\nint n;\n\nint ls[maxn], rs[maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", ls + i, rs + i);\n  }\n  return 1;\n}\n\npair<int, int> tosort[maxn];\n\nlong long dp[2][maxn];\n\nvoid solve() {\n  for (int i = 0; i < n; ++i) {\n    tosort[i] = mp(ls[i] + rs[i], i);\n  }\n  sort(tosort, tosort + n);\n  reverse(tosort, tosort + n);\n\n  dp[0][0] = 0;\n  dp[1][0] = (long long) 1e18;\n\n  for (int iter = 0; iter < n; ++iter) {\n    dp[0][iter + 1] = dp[1][iter + 1] = (long long) 1e18;\n    for (int type = 1; type >= 0; --type) {\n      for (int tl = iter; tl >= 0; --tl) {\n        auto cur = dp[type][tl];\n        dp[type][tl + 1] = min(dp[type][tl + 1], cur + (long long) tl * tosort[iter].first + rs[tosort[iter].second]);\n        if (!type && (n & 1)) {\n          dp[1][tl] = min(dp[1][tl], cur + (long long) (n - 1) * tosort[iter].first / 2);\n        }\n        dp[type][tl] = cur + (long long) (iter - tl - type) * tosort[iter].first + ls[tosort[iter].second];\n      }\n    }\n  }\n  long long res = *min_element(dp[0], dp[0] + n + 1);\n  if (n & 1) {\n    res = min(res, dp[1][n / 2]);\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[5050],R[5050];\npair<ll,int> P[5050];\n\nll dp[3030][3030][2];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>L[i]>>R[i];\n\t\tP[i]={R[i]+L[i],i};\n\t}\n\tif(N%2==0) {\n\t\tP[N]={0,N};\n\t\tN++;\n\t}\n\t\n\tFOR(x,3000) FOR(y,3000) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\tdp[0][0][0]=0;\n\t\n\tsort(P,P+N);\n\tFOR(i,N) {\n\t\tj=P[i].second;\n\t\tfor(l=0;l<=N/2;l++) {\n\t\t\tfor(k=0;k<=1;k++) {\n\t\t\t\tr=i-l-k;\n\t\t\t\tif(r<0 || r>N/2) continue;\n\t\t\t\t\n\t\t\t\tif(l+1<=N/2) dp[l+1][r][k]=min(dp[l+1][r][k],dp[l][r][k]+R[j]+(N/2-(l+1))*P[i].first);\n\t\t\t\tif(r+1<=N/2) dp[l][r+1][k]=min(dp[l][r+1][k],dp[l][r][k]+L[j]+(N/2-(r+1))*P[i].first);\n\t\t\t\tif(k==0) dp[l][r][k+1]=min(dp[l][r][k+1],dp[l][r][k]+(N-1)*P[i].first);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<dp[N/2][N/2][1]<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 62;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\npl I[MAX_N];\nll dp[2510][2510][2];\n\nbool comp(const pl& p1, const pl& p2) {\n\treturn p1.sec + p1.fst >= p2.sec + p2.fst;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tI[i] = pl(l, r);\n\t}\n\tsort(I, I + N, comp);\n\n\tint LN = (N - 1) / 2, RN = N / 2;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\tdp[i][j][0] = linf;\n\t\t\tdp[i][j][1] = linf;\n\t\t}\n\t}\n\n\tdp[0][0][0] = 0;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\trep(k, 0, 2) {\n\t\t\t\tif(dp[i][j][k] == linf) continue;\n\t\t\t\tint id = i + j + k;\n\t\t\t\tll l = I[id].fst, r = I[id].sec;\n\t\t\t\tif(i < LN) MIN(dp[i + 1][j][k], dp[i][j][k] + (l + r) * (i + 1) - l);\n\t\t\t\tif(j < RN) MIN(dp[i][j + 1][k], dp[i][j][k] + (l + r) * (j + 1) - r);\n\t\t\t\tif(k == 0) MIN(dp[i][j][k + 1], dp[i][j][k] + l * LN + r * RN);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[LN][RN][1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\ntemplate<int... Sizes>\nstruct MultidimensionalIndex;\ntemplate<>\nstruct MultidimensionalIndex<> {\n\tMultidimensionalIndex() {}\n\tint getTotalSize() const { return 1; }\n\tint getIndexAcc(int acc) const { return acc; }\n};\ntemplate<int Head, int... Tail>\nstruct MultidimensionalIndex<Head, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tenum { size = Head };\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(TailT... tail) : Base(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\ntemplate<int... Tail>\nstruct MultidimensionalIndex<0, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tconst int size;\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(int head, TailT... tail) : size(head), MultidimensionalIndex<Tail...>(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\n\ntemplate<typename Val, int... Sizes>\nstruct DP : MultidimensionalIndex<Sizes...> {\n\tstd::vector<Val> dp;\n\ttemplate<typename... SizesT>\n\tDP(Val init, SizesT... sizes) : MultidimensionalIndex<Sizes...>(sizes...), dp(MultidimensionalIndex<Sizes...>::getTotalSize(), init) {}\n\ttemplate<typename... SizesT>\n\tVal &operator()(SizesT... indices) { return dp[getIndexAcc(0, indices...)]; }\n\ttemplate<typename... SizesT>\n\tVal operator()(SizesT... indices) const { return dp[getIndexAcc(0, indices...)]; }\n\tvoid swap(DP &that) { dp.swap(that); }\n};\n\nstruct Interval {\n\tint L, R, X;\n\tbool operator<(const Interval &that) const {\n\t\treturn X < that.X;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<Interval> intervals(N);\n\t\trep(i, N) {\n\t\t\tint L; int R;\n\t\t\tscanf(\"%d%d\", &L, &R);\n\t\t\tintervals[i] = { L, R, L + R };\n\t\t}\n\t\tsort(intervals.begin(), intervals.end());\n\t\treverse(intervals.begin(), intervals.end());\n\t\tDP<ll, 0, 0, 2> dp(INFL, N + 1, N + 1);\n\t\tdp(0, 0, 0) = 0;\n\t\trep(i, N) {\n\t\t\tconst Interval a = intervals[i];\n\t\t\trer(l, 0, i) rep(c, l == i ? 1 : 2) {\n\t\t\t\tint r = i - l - c;\n\t\t\t\tll x = dp(l, r, c);\n\t\t\t\tif(x == INFL) continue;\n\t\t\t\tamin(dp(l + 1, r, c), x + a.R + (ll)a.X * l);\n\t\t\t\tamin(dp(l, r + 1, c), x + a.L + (ll)a.X * r);\n\t\t\t\tif(c == 0)\n\t\t\t\t\tamin(dp(l, r, c + 1), x + (ll)a.X * (N / 2));\n\t\t\t}\n\t\t}\n\t\tll ans = INFL;\n\t\trer(l, 0, N - N % 2) {\n\t\t\tint r = N - N % 2 - l;\n\t\t\tamin(ans, dp(l, r, N % 2));\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nstruct intv{\n\tlong long l, r, d;\n\tbool operator <(const intv &t) const{\n\t\treturn d > t.d;\n\t}\n} I[5050];\n\nlong long d[2555][2555][2];\n\nvoid mn(long long &a, long long b)\n{\n\tif (a > b)\n\t\ta = b;\n}\n\nint main()\n{\n\tint N; scanf (\"%d\", &N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%lld %lld\", &I[i].l, &I[i].r);\n\t\tI[i].d = I[i].l + I[i].r;\n\t}\n\tsort(I, I + N);\n\n\tint s = N / 2;\n\tfor (int i = 0; i <= s; i++) for (int j = 0; j <= s; j++) d[i][j][0] = d[i][j][1] = 1e18;\n\td[0][0][0] = 0;\n\n\tfor (int i = 0; i <= s; i++) for (int j = 0; j <= s; j++) for (int k = 0; k <= 1; k++) if (i + j + k < N){\n\t\tauto &t = I[i + j + k];\n\t\tif (i < s) mn(d[i + 1][j][k], d[i][j][k] + t.r + i * t.d);\n\t\tif (j < s) mn(d[i][j + 1][k], d[i][j][k] + t.l + j * t.d);\n\t\tif (k < 1) mn(d[i][j][k + 1], d[i][j][k] + s * t.d);\n\t}\n\n\tprintf (\"%lld\\n\", d[s][s][N%2]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nbool cmp(const ii &a, const ii &b)\n{\n\tll lena = a.se-a.fi; ll lenb = b.se-b.fi;\n\tif(lena!=lenb) return lena>lenb;\n\telse return a.fi<a.se;\n}\n\nll pref[5011][5111];\nll suf[2][5111];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tif(n==1){cout<<0<<'\\n'; return 0;}\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tvec.pb({-l,r});\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcerr<<vec[i].fi<<' '<<vec[i].se<<'\\n';\n\t}\n\t*/\n\tll ans = ll(2e18);\n\tfor(int l=(n-1)/2;l<=n/2;l++)\n\t{\n\t\tint r=n-1-l;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tpref[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tsuf[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tpref[0][0]=vec[0].se;\n\t\tpref[0][1]=-vec[0].fi;\n\t\tfor(int i=0;i+1<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(pref[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=pref[i][j];\n\t\t\t\t\tll L=vec[i+1].fi; ll R=vec[i+1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(pref[i+1][j], v+R+ll(i+1-j)*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(pref[i+1][j+1], v-L+ll(j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuf[(n-1)&1][0]=vec[n-1].se+ll(l-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tsuf[(n-1)&1][1]=-vec[n-1].fi+ll(r-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tfor(int i=max(n-2,0);i<n;i++)\n\t\t{\n\t\t\t//segment i is fixed\n\t\t\tll constant = vec[i].se*r-vec[i].fi*l;\n\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t{\n\t\t\t\tll lef = 0; \n\t\t\t\tll ri = 0;\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse lef=pref[i-1][j];\n\t\t\t\tif(i==n-1)\n\t\t\t\t{\n\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse ri=suf[(i+1)&1][r-j];\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n-1;i>0;i--)\n\t\t{\n\t\t\tint cur=(i+1)&1; int pre=cur^1;\n\t\t\tfor(int j=0;j<=n;j++) suf[cur][j]=ll(1e18);\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(suf[pre][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=suf[pre][j];\n\t\t\t\t\tll L=vec[i-1].fi; ll R=vec[i-1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(suf[cur][j], v+R+ll(l-1-((n-1-i)+1-j))*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(suf[cur][j+1], v-L+ll(r-1-j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i2=i-2;\n\t\t\t\tif(i2<0) continue;\n\t\t\t\tll constant = vec[i2].se*r-vec[i2].fi*l;\n\t\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t\t{\n\t\t\t\t\tll lef = 0; \n\t\t\t\t\tll ri = 0;\n\t\t\t\t\tif(i2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse lef=pref[i2-1][j];\n\t\t\t\t\tif(i2==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse ri=suf[cur][r-j];\n\t\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nvector<pii> arr;\nint cmp(pii a,pii b){\n  return a.Y-a.X<b.Y-b.X;\n}\nll dp[5005][5005];\nint main(){\n  int n; scanf(\"%d\",&n); \n  if(n==1){\n    printf(\"0\\n\"); exit(0);\n  }\n  REP(i,n){\n    pii z; scanf(\"%d%d\",&z.X,&z.Y); z.X=-z.X; arr.pb(z);\n  }\n  sort(all(arr),cmp);\n  reverse(all(arr));\n  int fl=1;\n  REP(i,n-1) if(arr[i].X-arr[i].Y!=arr[i+1].X-arr[i+1].Y) fl=0;\n  if(fl){\n    sort(all(arr));\n    swap(arr[n/2],arr[n-1]);\n  } \n  REP(i,n+1) REP(j,n+1)  dp[i][j]=INF;\n  dp[0][0]=0;\n  ll lk = -arr[n-1].X,rk=arr[n-1].Y;\n  ll ans=INF;\n  REP(i,n){\n    ll ls = arr[i].X,rs=arr[i].Y;\n    ll dis = rs-ls;\n    \n   // printf(\"%lld %lld\\n\",lk,rk);\n    REP(j,i+1)if(dp[i][j]<INF){\n    //  printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n      dp[i+1][j]=min(dp[i+1][j],dp[i][j]+(i-j)*dis+lk+rs);\n      dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+j*dis+rk-ls);\n    }\n  }\n  REP(i,n) ans=min(ans,dp[n-1][i]);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[5050],R[5050];\npair<ll,int> P[5050];\n\nll dp[3030][3030][2];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>L[i]>>R[i];\n\t\tP[i]={R[i]+L[i],i};\n\t}\n\tif(N%2==0) N++;\n\t\n\tFOR(x,3000) FOR(y,3000) dp[x][y][0]=dp[x][y][1]=1LL<<60;\n\tdp[0][0][0]=0;\n\t\n\tsort(P,P+N);\n\tFOR(i,N) {\n\t\tj=P[i].second;\n\t\tfor(l=0;l<=N/2;l++) {\n\t\t\tfor(k=0;k<=1;k++) {\n\t\t\t\tr=i-l-k;\n\t\t\t\tif(r<0 || r>N/2) continue;\n\t\t\t\t\n\t\t\t\tif(l+1<=N/2) dp[l+1][r][k]=min(dp[l+1][r][k],dp[l][r][k]+R[j]+(N/2-(l+1))*P[i].first);\n\t\t\t\tif(r+1<=N/2) dp[l][r+1][k]=min(dp[l][r+1][k],dp[l][r][k]+L[j]+(N/2-(r+1))*P[i].first);\n\t\t\t\tif(k==0) dp[l][r][k+1]=min(dp[l][r][k+1],dp[l][r][k]+(N-1)*P[i].first);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<dp[N/2][N/2][1]<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL L[5011], R[5011];\npair<LL, int> P[5011];\n\nLL dp[5011][5011];\nLL ep[5011][5011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld\", L+i, R+i);\n\n    REP (i, N) P[i] = make_pair(L[i]+R[i], i);\n    sort(P, P+N);\n    reverse(P, P+N);\n\n    memset(dp, 0x3f, sizeof dp);\n    memset(ep, 0x3f, sizeof ep);\n    dp[0][0] = 0;\n    REP (i, N) {\n\tLL l = L[P[i].second];\n\tLL r = R[P[i].second];\n\tREP (a, i+1) {\n\t    int b = i-a;\n\n\t    if ((a+1)*2 <= N) {\n\t\tamin(dp[i+1][a+1], dp[i][a] + r + (l+r)*a);\n\t\tamin(ep[i+1][a+1], ep[i][a] + r + (l+r)*a);\n\t    }\n\t    if ((b+1)*2 <= N) {\n\t\tamin(dp[i+1][a], dp[i][a] + l + (l+r)*b);\n\t\tamin(ep[i+1][a], ep[i][a] + l + (l+r)*b);\n\t    }\n\n\t    amin(ep[i+1][a], dp[i][a] + abs(l-r)/2 + (N-1)/2*(l+r));\n\t}\n    }\n\n    LL ans;\n    if (N % 2 == 0) ans = dp[N][N/2];\n    else ans = ep[N][N/2];\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define l first\n#define r second\n\nint main() {\n    //ifstream cin(\"testF.in\");\n    int n; cin >> n;\n\n    vector<pair<int, int>> a(n);\n    for(int i = 0; i < n; ++i)\n        cin >> a[i].l >> a[i].r;\n    \n    \n    sort(a.begin(), a.end(), [&] (pair<int, int> A, pair<int, int> B) {\n        return (A.l + A.r) > (B.l + B.r);\n    });\n    \n    int64_t ans = 1e15;\n\n    for(int fixed = n - 1; fixed < n; ++fixed) {\n        vector<int64_t> dp(n + 1, 1e15);\n        int many = 0;\n        dp[0] = 0;\n        for(int i = 0; i < n; ++i) {\n            if(fixed == i)\n                continue;\n            many++;\n            int len = a[i].r + a[i].l;\n            vector<int64_t> newDp(n + 1, 1e15);\n            newDp[0] = dp[0] + a[i].r + a[fixed].l + (many - 1) * len;\n            for(int j = 0; j < many; ++j) {\n                newDp[j + 1] = min(dp[j + 1] + a[i].r + a[fixed].l + (many - 1 - (j + 1)) * len, dp[j] + a[i].l + a[fixed].r + j * len);\n            }\n            dp = newDp;\n        }\n        int64_t temp = 1e9;\n        for(int i = 0; i <= n; ++i)\n            temp = min(temp, dp[i]);\n        ans = min(ans, temp);\n    }\n    \n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, s;\n\tinline int operator<(const seg &a) const {return s > a.s;}\n} s[5010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[2510][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n; m = n >> 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].s = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tfor (int i = 0; i <= m; ++i)\n\t\tf[i][0] = f[i][1] = inf;\n\tf[0][0] = 0;\n\t\n\tint x = 1, y = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[j][x] = inf;\n\t\tfor (int j = 0; j<i && j<=m; ++j)\n\t\t{\n\t\t\tconst int k = i-j-1;\n\t\t\tif (j < m)\n\t\t\t\tf[j+1][x] = min(f[j+1][x], f[j][y] + s[i].r + s[i].s * j);\n\t\t\tif (k < m)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][y] + s[i].l + s[i].s * k);\n\t\t\tif (n & 1)\n\t\t\t\tf[j][x] = min(f[j][x], f[j][y] + (n-1)/2 * s[i].s);\n\t\t}\n\t\tswap(x, y);\n\t}\n\t\n\tcout << f[m][y] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(j,n) {\n    // if (p[j].fi+p[j].se != p.back().fi+p.back().se) continue;\n    rep(i,n) {\n      ll l = p[j].fi, r = p[j].se;\n      int g = n-1-i;\n      mins(ans, d[i]+r*i+l*g);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nbool cmp(const ii &a, const ii &b)\n{\n\tll lena = a.se-a.fi; ll lenb = b.se-b.fi;\n\tif(lena!=lenb) return lena>lenb;\n\telse return a.fi<b.fi;\n}\n\nll pref[5011][5111];\nll suf[2][5111];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tif(n==1){cout<<0<<'\\n'; return 0;}\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tvec.pb({-l,r});\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcerr<<vec[i].fi<<' '<<vec[i].se<<'\\n';\n\t}\n\t*/\n\tll ans = ll(2e18);\n\tfor(int l=(n-1)/2;l<=n/2;l++)\n\t{\n\t\tint r=n-1-l;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tpref[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tsuf[i][j]=ll(1e18);\n\t\t\t}\n\t\t}\n\t\tpref[0][0]=vec[0].se;\n\t\tpref[0][1]=-vec[0].fi;\n\t\tfor(int i=0;i+1<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(pref[i][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=pref[i][j];\n\t\t\t\t\tll L=vec[i+1].fi; ll R=vec[i+1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(pref[i+1][j], v+R+ll(i+1-j)*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(pref[i+1][j+1], v-L+ll(j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuf[(n-1)&1][0]=vec[n-1].se+ll(l-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tsuf[(n-1)&1][1]=-vec[n-1].fi+ll(r-1)*(vec[n-1].se-vec[n-1].fi);\n\t\tfor(int i=max(n-2,0);i<n;i++)\n\t\t{\n\t\t\t//segment i is fixed\n\t\t\tll constant = vec[i].se*r-vec[i].fi*l;\n\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t{\n\t\t\t\tll lef = 0; \n\t\t\t\tll ri = 0;\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse lef=pref[i-1][j];\n\t\t\t\tif(i==n-1)\n\t\t\t\t{\n\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t}\n\t\t\t\telse ri=suf[(i+1)&1][r-j];\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n-1;i>0;i--)\n\t\t{\n\t\t\tint cur=(i+1)&1; int pre=cur^1;\n\t\t\tfor(int j=0;j<=n;j++) suf[cur][j]=ll(1e18);\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(suf[pre][j]<ll(1e18))\n\t\t\t\t{\n\t\t\t\t\tll v=suf[pre][j];\n\t\t\t\t\tll L=vec[i-1].fi; ll R=vec[i-1].se;\n\t\t\t\t\t//go left\n\t\t\t\t\tamin(suf[cur][j], v+R+ll(l-1-((n-1-i)+1-j))*(R-L));\n\t\t\t\t\t//go right\n\t\t\t\t\tamin(suf[cur][j+1], v-L+ll(r-1-j)*(R-L));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i2=i-2;\n\t\t\t\tif(i2<0) continue;\n\t\t\t\tll constant = vec[i2].se*r-vec[i2].fi*l;\n\t\t\t\tfor(int j=0;j<=r;j++)\n\t\t\t\t{\n\t\t\t\t\tll lef = 0; \n\t\t\t\t\tll ri = 0;\n\t\t\t\t\tif(i2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j!=0) lef=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse lef=pref[i2-1][j];\n\t\t\t\t\tif(i2==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(r-j!=0) ri=ll(1e18);\n\t\t\t\t\t}\n\t\t\t\t\telse ri=suf[cur][r-j];\n\t\t\t\t\t//cerr<<i<<' '<<j<<' '<<constant<<' '<<lef<<' '<<ri<<'\\n';\n\t\t\t\t\tans = min(ans, constant+lef+ri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+(r[idx]+l[idx])*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+(r[idx]+l[idx])*(i-j)+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<*min_element(ALL(dp[n]))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e15)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//ダイナミックプログラミンッ!!!\n\tint i,j,n;cin>>n;\n\tstatic llint dp[2505][2505]={0};\n\tvector<tuple<llint,llint,llint>> kuka(n);\n\tfor(i=0;i<n;i++){\n\t\tllint L,R;cin>>L>>R;\n\t\tkuka[i]=mt(L+R,L,R);\n\t}\n\tSO(kuka);REV(kuka);\n\t//でかい奴から両端に埋めていく\n\t//(n/2個) ((n+1)/2個) になる\n\tdp[0][0]=-big;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tint hi=j;\n\t\t\tint mg=i-j;\n\t\t\tif(n/2<hi){continue;}\n\t\t\tif((n+1)/2<mg){continue;}\n\t\t\tllint wa,L,R;\n\t\t\ttie(wa,L,R)=kuka[i];\n\t\t\tmineq(dp[hi+1][mg],dp[hi][mg]+hi*wa+L);\n\t\t\tmineq(dp[hi][mg+1],dp[hi][mg]+mg*wa+R);\n\t\t}\n\t}\n\tif(n%2==1){dp[n/2][(n+1)/2]-=get<2>(kuka[n-1]);}\n\tcout<<dp[n/2][(n+1)/2]+big<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL INF = 1e18;\nconst int SIZE = 5001;\nPII p[SIZE];\nLL dp[SIZE][SIZE];\nint N;\nLL f(int offset){\n    LL res=INF;\n    REP(i,N){\n        REP(j,i+2){\n            int x=j,y=i+1-j;\n            if(x)dp[x][y]=dp[x-1][y]+(x-1)*p[i].F+(p[i].S-offset);\n            else dp[x][y]=INF;\n            if(y)dp[x][y]=min(dp[x][y],dp[x][y-1]+y*p[i].F-(p[i].S-offset));\n            if(i==N-1)res=min(res,dp[x][y]);\n        }\n    }\n    return res;\n}\nint main(){\n    RI(N);\n    int ll=1e9,rr=1e9;\n    REP(i,N){\n        DRII(x,y);\n        p[i]=MP(x+y,x);\n        ll=min(x,ll);\n        rr=min(y,rr);\n    }\n    ll=-ll;\n    sort(p,p+N);\n    reverse(p,p+N);\n    while(ll<rr){\n        int mm1=(rr-ll)/2+ll;\n        int mm2=mm1+1;\n        LL v1=f(mm1);\n        LL v2=f(mm2);\n        if(v1>v2)ll=mm2;\n        else rr=mm1;\n    }\n    cout<<f(ll)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL L[5011], R[5011];\npair<LL, int> P[5011];\n\nLL dp[2][5011];\nLL ep[2][5011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld\", L+i, R+i);\n\n    REP (i, N) P[i] = make_pair(L[i]+R[i], i);\n    sort(P, P+N);\n    reverse(P, P+N);\n\n    memset(dp, 0x3f, sizeof dp);\n    memset(ep, 0x3f, sizeof ep);\n    int cur = 0, nxt = 1;\n    dp[0][0] = 0;\n\n    REP (i, N) {\n\tLL l = L[P[i].second];\n\tLL r = R[P[i].second];\n\n\tmemset(dp[nxt], 0x3f, sizeof dp[nxt]);\n\tmemset(ep[nxt], 0x3f, sizeof ep[nxt]);\n\n\tREP (a, i+1) {\n\t    int b = i-a;\n\n\t    if ((a+1)*2 <= N) {\n\t\tamin(dp[nxt][a+1], dp[cur][a] + r + (l+r)*a);\n\t\tamin(ep[nxt][a+1], ep[cur][a] + r + (l+r)*a);\n\t    }\n\t    if ((b+1)*2 <= N) {\n\t\tamin(dp[nxt][a], dp[cur][a] + l + (l+r)*b);\n\t\tamin(ep[nxt][a], ep[cur][a] + l + (l+r)*b);\n\t    }\n\n\t    amin(ep[nxt][a], dp[cur][a] + (N-1)/2*(l+r));\n\t}\n\tswap(cur, nxt);\n    }\n\n    LL ans;\n    if (N % 2 == 0) ans = dp[cur][N/2];\n    else ans = ep[cur][N/2];\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+(r[idx]+l[idx])*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+(r[idx]+l[idx])*(i-j)+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<min({*min_element(ALL(dp[n])),dp[n][0]-*max_element(ALL(l)),dp[n][n]-*max_element(ALL(r))})<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e18)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//ダイナミックプログラミンッ!!!\n\tint i,j,n;cin>>n;\n\tstatic llint dp[2505][2505]={0};\n\tvector<tuple<llint,llint,llint>> kuka(n);\n\tfor(i=0;i<n;i++){\n\t\tllint L,R;cin>>L>>R;\n\t\tkuka[i]=mt(L+R,L,R);\n\t}\n\tSO(kuka);REV(kuka);\n\t//でかい奴から両端に埋めていく\n\t//(n/2個) ((n+1)/2個) になる\n\tdp[0][0]=-big;\n\t//n%2==1のとき、片方が埋まった状態も考えなければならない\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tint hi=j;\n\t\t\tint mg=i-j;\n\t\t\tif(n/2<hi){continue;}\n\t\t\tif(n/2<mg){continue;}\n\t\t\tllint wa,L,R;\n\t\t\ttie(wa,L,R)=kuka[i];\n\t\t\tmineq(dp[hi+1][mg],dp[hi][mg]+hi*wa+L);\n\t\t\tmineq(dp[hi][mg+1],dp[hi][mg]+mg*wa+R);\n\t\t\tif(n%2==1){\n\t\t\t\tdp[hi][mg]+=(n/2)*wa;\n\t\t\t\tif(hi>0){mineq(dp[hi][mg],dp[hi-1][mg]+(hi-1)*wa+L);}\n\t\t\t\tif(mg>0){mineq(dp[hi][mg],dp[hi][mg-1]+(mg-1)*wa+R);}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n/2][n/2]+big<<endl;\n\tRE;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 62;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\npl I[5010];\nll dp[2510][2510][2];\n\nbool compare(const pl& p1, const pl& p2) {\n\treturn (p1.sec + p1.fst) > (p2.sec + p2.fst);\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tI[i] = pl(l, r);\n\t}\n\tsort(I, I + N, compare);\n\n\tint LN = (N - 1) / 2, RN = N / 2;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\tdp[i][j][0] = linf;\n\t\t\tdp[i][j][1] = linf;\n\t\t}\n\t}\n\n\tdp[0][0][0] = 0;\n\n\trep(i, 0, LN + 1) {\n\t\trep(j, 0, RN + 1) {\n\t\t\trep(k, 0, 2) {\n\t\t\t\tif(dp[i][j][k] == linf) continue;\n\t\t\t\tint id = i + j + k;\n\t\t\t\tll l = I[id].fst, r = I[id].sec;\n\t\t\t\tif(i < LN) MIN(dp[i + 1][j][k], dp[i][j][k] + (l + r) * (i + 1) - l);\n\t\t\t\tif(j < RN) MIN(dp[i][j + 1][k], dp[i][j][k] + (l + r) * (j + 1) - r);\n\t\t\t\tif(k == 0) MIN(dp[i][j][k + 1], dp[i][j][k] + l * LN + r * RN);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[LN][RN][1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct seg\n{\n\tll l, r, d;\n\tinline int operator<(const seg &a) const {return d > a.d;}\n} s[10010];\n\nconst ll inf = (1ll<<62) - 1;\nint n, m;\nll f[5010][5010][2];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> s[i].l >> s[i].r;\n\t\ts[i].d = s[i].l + s[i].r;\n\t}\n\tsort(s+1, s+n+1);\n\tm = n >> 1;\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[i][j][0] = f[i][j][1] = inf;\n\tf[0][0][0] = 0;\n\t\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m && i+j < n; ++j)\n\t\t\tfor (int k = 0; k <= 1 && i+j+k < n; ++k)\n\t\t\t{\n\t\t\t\tconst ll tmp = f[i][j][k]; const seg p = s[i+j+k+1];\n\t\t\t\tif (i < m)\tf[i+1][j][k] = min(f[i+1][j][k], tmp + p.r + i*p.d);\n\t\t\t\tif (j < m)\tf[i][j+1][k] = min(f[i][j+1][k], tmp + p.l + j*p.d);\n\t\t\t\tif (!k)\t\tf[i][j][k|1] = min(f[i][j][k|1], tmp + m * p.d);\n\t\t\t}\n\t\n\tcout << f[m][m][n&1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 5005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\nint main() {\n  srand(600);\n  int n;\n  scanf(\"%d\",&n);\n  assert(n%2 == 0);\n  if (n == 1) dame;\n  vp p(n);\n  rep(i,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n  sort(rng(p),[&](P a, P b){\n    return a.fi+a.se > b.fi+b.se;\n  });\n  vl dp(1,LINF);\n  dp[0] = 0;\n  vl d;\n  rep(k,n) {\n    d = vl(k+2,LINF);\n    swap(dp,d);\n    ll l = p[k].fi, r = p[k].se, w = r+l;\n    rep(j,k+1) {\n      int g = k-j;\n      mins(dp[j], d[j]+r+w*g);\n      mins(dp[j+1], d[j]+l+w*j);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n+1) mins(ans,dp[i]);\n  rep(i,n) {\n    ll l = p.back().fi, r = p.back().se;\n    int j = n-1-i;\n    mins(ans, d[i]+r*i+l*j);\n  }\n  // {\n  //   vl dp(1,LINF);\n  //   dp[0] = 0;\n  //   vl d;\n  //   rep(k,n) {\n  //     d = vl(k+2,LINF);\n  //     swap(dp,d);\n  //     ll l = p[k].fi, r = p[k].se, w = r+l;\n  //     rep(j,k+1) {\n  //       int g = k-j;\n  //       mins(dp[j], d[j]+r+w*g);\n  //       mins(dp[j+1], d[j]+l+w*j);\n  //     }\n  //   }\n  // }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>l(n),r(n);\n  rep(i,0,n)cin>>l[i]>>r[i];\n  vector<ll>order(n);\n  iota(ALL(order),0);\n  sort(ALL(order),[&](ll x,ll y){\n    return l[x]+r[x]>l[y]+r[y];\n  });\n  auto dp=vec(n+1,n+1,INF);\n  dp[0][0]=0;\n  //j,左に寄せた個数\n  rep(i,0,n/2*2){\n    ll idx=order[i];\n    //cout<<idx spa l[idx] spa r[idx]<<endl;\n    ll len=l[idx]+r[idx];\n    rep(j,0,i+1){\n      chmin(dp[i+1][j+1],dp[i][j]+len*j+r[idx]);\n      chmin(dp[i+1][j],dp[i][j]+len*(i-j)+l[idx]);\n    }\n  }\n  //debug(dp,n+1,n+1);\n  ll add=0;\n  if(n&1)add=n/2*(l[order[n-1]]+r[order[n-1]]);\n  cout<<dp[n/2*2][n/2]+add<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define MAXN 5005\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\n\nint n;\nlong long dp[MAXN][MAXN][2];\npair<int, int> v[MAXN];\n\nbool Comp(pair<int, int> a, pair<int, int> b) {\n    return a.first + a.second > b.first + b.second;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        scanf(\"%d %d\", &v[i].first, &v[i].second);\n    }\n\n    sort(v + 1, v + n + 1, Comp);\n\n    for(int l = 0; l <= n; ++l) {\n        for(int r = 0; l + r <= n; ++r) {\n            for(int c = 0; c <= 1 && l + r + c <= n; ++c) {\n                if(l == 0 && r == 0 && c == 0) continue;\n\n                int L = v[l + r + c].first;\n                int R = v[l + r + c].second;\n                int X = L + R;\n\n                dp[l][r][c] = INF;\n                if(l > 0)\n                    dp[l][r][c] = min(dp[l][r][c], dp[l - 1][r][c] + R + 1LL * (l - 1) * X);\n                if(r > 0)\n                    dp[l][r][c] = min(dp[l][r][c], dp[l][r - 1][c] + L + 1LL * (r - 1) * X);\n                if(c > 0)\n                    dp[l][r][c] = min(dp[l][r][c], dp[l][r][c - 1] + 1LL * n / 2 * X);\n            }\n        }\n    }\n\n\n    printf(\"%lld\\n\", ((n % 2) ? dp[n / 2][n / 2][1] : dp[n / 2][n / 2][0]));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n \n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n \nint N;\nint L[5010], R[5010];\nll ret = LLONG_MAX;\nll dp[5010][5010];\n \nint main() {\n\tcin >> N;\n\trep(i, N) cin >> L[i] >> R[i];\n \n \tassert(N<=500);\n\n\trep(i, N) { //fix\n\t\tvector<pii> vec;\n \n\t\trep(j, N) {\n\t\t\tif (j != i) {\n\t\t\t\tvec.eb(L[j]+R[j], j);\n\t\t\t}\n\t\t}\n \n\t\tsort(ALL(vec));\n \n\t\tfor (int l=(N-1)/2; l <= (N/2); ++l) { // to left\n\t\t\tll t = (ll)L[i] * l + (ll)R[i] * (N-1-l);\n\t\t\trep(j, N) rep(k, N) dp[j][k] = LLONG_MAX;\n \n\t\t\tdp[0][0] = 0;\n\n\t\t\trep(j, N-1) {\n\t\t\t\tint id = vec[j].se;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif (dp[j][k] == LLONG_MAX) continue;\n\t\t\t\t\tdp[j+1][k+1] = min(dp[j+1][k+1], dp[j][k] + (ll)(l-1-k)*(L[id]+R[id]) + R[id]);\n\t\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[j][k] + (ll)((N-1-l)-1-(j-k))*(L[id]+R[id]) + L[id]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt += dp[N-1][l];\n\t\t\tret = min(ret, t);\n\t\t}\n\t}\n \n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190714\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nlong long val;\nlong long lv;\nlong long rv;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nint main(void){\n  long long dp[2525][2525][2];\n  long long i,j,k,n,f,w;\n  sd dat[8192];\n  scanf(\"%lld\",&n);\n  for(i=0;i<2525;i++){\n    for(j=0;j<2525;j++){\n      dp[i][j][0]=llinf;\n      dp[i][j][1]=llinf;\n    }\n  }\n  dp[0][0][0]=0;\n  for(i=0;i<n;i++){\n    scanf(\"%lld%lld\",&dat[i].lv,&dat[i].rv);\n    dat[i].val=dat[i].lv+dat[i].rv;\n  }\n  if(n%2==0){\n    dat[n].val=0;\n    dat[n].lv=0;\n    dat[n].rv=0;\n    n++;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  k=(n-1)/2;\n  for(i=0;i<n;i++){\n    for(j=0;j<=k;j++){\n      for(f=0;f<2;f++){\n        if((j+f)>i){continue;}\n        if((i-(j+f))>k){continue;}\n        w=dp[i-(j+f)][j][f];\n        if((i-(j+f))!=k){\n          dp[i-(j+f)+1][j][f]=llmin(w+dat[i].rv+(k-(i-(j+f)+1))*dat[i].val,dp[i-(j+f)+1][j][f]);\n        }\n        if(j!=k){\n          dp[i-(j+f)][j+1][f]=llmin(w+dat[i].lv+(k-(j+1))*dat[i].val,dp[i-(j+f)][j+1][f]);\n        }\n        if(f==0){\n          dp[i-(j+f)][j][1]=llmin(w+k*dat[i].val,dp[i-(j+f)][j][1]);          \n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\",dp[k][k][1]);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define inf (int)(1e18)\n\ntypedef struct {\n\tint L;\n\tint R;\n}pair;\n\nsigned compair(const void *a, const void *b){\n\tint sub = (((pair *)a)->L + ((pair *)a)->R) - (((pair *)b)->L + ((pair *)b)->R);\n\tif(sub > 0){\n\t\treturn -1;\n\t}\n\telse if(sub == 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nsigned main(){\n\tint N, i, j, k, l;\n\tscanf(\"%lld\", &N);\n\tpair *ps = (pair *)malloc(sizeof(pair) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &ps[i].L, &ps[i].R);\n\t}\n\tqsort(ps, N, sizeof(pair), compair);\n\tint ***dp = (int ***)malloc(sizeof(int **) * (N / 2 + 2));\n\tfor(i = 0; i <= N / 2 + 1; i++){\n\t\tdp[i] = (int **)malloc(sizeof(int *) * (N / 2 + 2));\n\t\tfor(j = 0; j <= N / 2 + 1; j++){\n\t\t\tdp[i][j] = (int *)malloc(sizeof(int) * (N % 2 + 1));\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tfor(i = 0; i <= N / 2; i++){\n\t\tfor(j = 0; j <= N / 2; j++){\n\t\t\tfor(k = 0; k <= N % 2; k++){\n//\t\t\t\tprintf(\"(i, j, k) = (%lld, %lld, %lld)\\n\", i, j, k);\n//\t\t\t\tprintf(\"dp = %lld\\n\", dp[i][j][k]);\n\t\t\t\tl = i + j + k;\n\t\t\t\tif(l >= N){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k] + i * (ps[l].L + ps[l].R) + ps[l].R);\n//\t\t\t\tprintf(\"test\\n\");\n\t\t\t\tdp[i][j + 1][k] = min(dp[i][j + 1][k], dp[i][j][k] + j * (ps[l].L + ps[l].R) + ps[l].L);\n//\t\t\t\tprintf(\"dp2 = %lld\\n\", dp[i][j + 1][k]);\n\t\t\t\tif(k == 0 && N % 2 == 1 && l < N){\n\t\t\t\t\tdp[i][j][1] = min(dp[i][j][1], dp[i][j][0] + (N / 2) * (ps[l].L + ps[l].R));\n//\t\t\t\t\tprintf(\"dp3 = %lld\\n\", dp[i][j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tfor(j = 0; j < N; j++){\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tprintf(\"dp[%lld][%lld][%lld] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n*/\tprintf(\"%lld\\n\", dp[N / 2][N / 2][N % 2]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define inf (int)(1e18)\n\ntypedef struct {\n\tint L;\n\tint R;\n}pair;\n\nsigned compair(const void *a, const void *b){\n\tint sub = (((pair *)a)->L + ((pair *)a)->R) - (((pair *)b)->L + ((pair *)b)->R);\n\tif(sub > 0){\n\t\treturn -1;\n\t}\n\telse if(sub == 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nsigned main(){\n\tint N, i, j, k, l;\n\tscanf(\"%lld\", &N);\n\tpair *ps = (pair *)malloc(sizeof(pair) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &ps[i].L, &ps[i].R);\n\t}\n\tqsort(ps, N, sizeof(pair), compair);\n\tint ***dp = (int ***)malloc(sizeof(int **) * (N + 2));\n\tfor(i = 0; i <= N; i++){\n\t\tdp[i] = (int **)malloc(sizeof(int *) * (N + 2));\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tdp[i][j] = (int *)malloc(sizeof(int) * (N % 2 + 1));\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tfor(i = 0; i <= N; i++){\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tfor(k = 0; k <= N % 2; k++){\n//\t\t\t\tprintf(\"(i, j, k) = (%lld, %lld, %lld)\\n\", i, j, k);\n//\t\t\t\tprintf(\"dp = %lld\\n\", dp[i][j][k]);\n\t\t\t\tl = i + j + k;\n\t\t\t\tif(l >= N){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k] + i * (ps[l].L + ps[l].R) + ps[l].R);\n\t\t\t\tdp[i][j + 1][k] = min(dp[i][j + 1][k], dp[i][j][k] + j * (ps[l].L + ps[l].R) + ps[l].L);\n//\t\t\t\tprintf(\"dp2 = %lld\\n\", dp[i][j + 1][k]);\n\t\t\t\tif(k == 0 && N % 2 == 1 && l < N){\n\t\t\t\t\tdp[i][j][1] = min(dp[i][j][1], dp[i][j][0] + (N / 2) * (ps[l].L + ps[l].R));\n//\t\t\t\t\tprintf(\"dp3 = %lld\\n\", dp[i][j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tfor(j = 0; j < N; j++){\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tprintf(\"dp[%lld][%lld][%lld] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n*/\tprintf(\"%lld\\n\", dp[N / 2][N / 2][N % 2]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define inf (int)(1e18)\n\ntypedef struct {\n\tint L;\n\tint R;\n}pair;\n\nsigned compair(const void *a, const void *b){\n\tint sub = (((pair *)a)->L + ((pair *)a)->R) - (((pair *)b)->L + ((pair *)b)->R);\n\tif(sub > 0){\n\t\treturn -1;\n\t}\n\telse if(sub == 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nsigned main(){\n\tint N, i, j, k, l;\n\tscanf(\"%lld\", &N);\n\tpair *ps = (pair *)malloc(sizeof(pair) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &ps[i].L, &ps[i].R);\n\t}\n\tqsort(ps, N, sizeof(pair), compair);\n\tint ***dp = (int ***)malloc(sizeof(int **) * (N / 2 + 2));\n\tfor(i = 0; i <= N / 2 + 1; i++){\n\t\tdp[i] = (int **)malloc(sizeof(int *) * (N / 2 + 2));\n\t\tfor(j = 0; j <= N / 2 + 1; j++){\n\t\t\tdp[i][j] = (int *)malloc(sizeof(int) * (N % 2 + 1));\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tfor(i = 0; i <= N / 2; i++){\n\t\tfor(j = 0; j <= N / 2; j++){\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tl = i + j + k;\n\t\t\t\tif(l >= N){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k] + i * (ps[l].L + ps[l].R) + ps[l].R);\n\t\t\t\tdp[i][j + 1][k] = min(dp[i][j + 1][k], dp[i][j][k] + j * (ps[l].L + ps[l].R) + ps[l].L);\n\t\t\t\tif(k == 0 && N % 2 == 1 && l < N){\n\t\t\t\t\tdp[i][j][1] = min(dp[i][j][1], dp[i][j][0] + (N / 2) * (ps[l].L + ps[l].R));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tfor(j = 0; j < N; j++){\n\t\t\tfor(k = 0; k <= N % 2; k++){\n\t\t\t\tprintf(\"dp[%lld][%lld][%lld] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n*/\tprintf(\"%lld\\n\", dp[N / 2][N / 2][N % 2]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\null dp[2][5050][2];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tconst ull vb = 100000000000000000LL;\n\n\tfor (i = 0; i < n; i++) {\n\t\txy[i] = (hwll){a[i] + b[i], i};\n\t}\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tfor (j = 0; j <= n; j++) {\n\t\tfor (ki = 0; ki < 2; ki++) {\n\t\t\tdp[0][j][ki] = vb;\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tull v = xy[(n - 1) - i].b;\n\n\t\tull curr = (i & 1);\n\t\tull next = (curr ^ 1);\n\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\tfor (ki = 0; ki < 2; ki++) {\n\t\t\t\tdp[next][j][ki] = vb;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j <= i; j++) {\n\t\t\tfor (ki = 0; ki < 2; ki++) {\n\t\t\t\tsll ri = i - j - ki;\n\t\t\t\tif (ri < 0) continue;\n\n\t\t\t\tull now = dp[curr][j][ki];\n\t\t\t\tull add;\n\n\t\t\t\tadd = a[v] * ri + b[v] * (ri + 1);\n\t\t\t\tdp[next][j][ki] = umin(dp[next][j][ki], now + add);\n\n\t\t\t\tadd = a[v] * (j + 1) + b[v] * j;\n\t\t\t\tdp[next][j + 1][ki] = umin(dp[next][j + 1][ki], now + add);\n\n\t\t\t\tif (!ki) {\n\t\t\t\t\tadd = a[v] * (n / 2) + b[v] * (n / 2);\n\t\t\t\t\tdp[next][j][ki + 1] = umin(dp[next][j][ki + 1], now + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = dp[n % 2][n / 2][n % 2];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\tprintf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][][] g = new long[2][n / 2 + 10][n / 2 + 10];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 10;\n\t\tg[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\t\tfor (int j = Math.max(0, -n / 2 - k + i); j <= i - k && j <= n / 2; ++j) {\n\t\t\t\t\tg[k][i - j - k][j + 1] = Math.min(g[k][i - j - k][j + 1],\n\t\t\t\t\t\t\tg[k][i - j][j] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\tg[k][i - j - k + 1][j] = Math.min(g[k][i - j - k + 1][j],\n\t\t\t\t\t\t\tg[k][i - j - k][j] + a[i][1] + (i - j - k) * (a[i][0] + a[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tfor (int j = Math.max(0, -n / 2 + i); j <= Math.min(n / 2, i); ++j) {\n\t\t\t\t\tg[1][i - j][j] = Math.min(g[1][i - j][j],\n\t\t\t\t\t\t\tg[0][i - j][j] + (n - 1) / 2 * (a[i][0] + a[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k) {\n\t\t\t\t\tif (i + j + k == n) {\n\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][][] g = new long[2][(n + 1) / 2 + 10][(n + 1) / 2 + 10];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 3;\n\t\tg[0][0][0] = 0;\n\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = Math.max(0, i - (n + 1) / 2); j <= Math.min(i, (n + 1) / 2); ++j) {\n\t\t\t\t\tg[k][i - j][j + 1] = Math.min(g[k][i - j][j + 1],\n\t\t\t\t\t\t\tg[k][i - j][j] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\tg[k][i - j + 1][j] = Math.min(g[k][i - j + 1][j],\n\t\t\t\t\t\t\tg[k][i - j][j] + a[i][1] + (i - j) * (a[i][0] + a[i][1]));\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\tg[1][i - j][j] = Math.min(g[1][i - j][j], g[0][i - j][j] + (n - 1) * (a[i][0] + a[i][1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tif (i + j + k == n)\n\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][][] g = new long[n + 1][n + 1][2];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 3;\n\t\tg[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\t\t\tg[i - j][j + 1][k] = Math.min(g[i - j][j + 1][k],\n\t\t\t\t\t\t\tg[i - j][j][k] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\tg[i - j + 1][j][k] = Math.min(g[i - j + 1][j][k],\n\t\t\t\t\t\t\tg[i - j][j][k] + a[i][1] + (i - j) * (a[i][0] + a[i][1]));\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\tg[i - j][j][1] = Math.min(g[i - j][j][1], g[i - j][j][0] + (n - 1) * (a[i][0] + a[i][1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tif (i + j + k == n)\n\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][][] g = new long[2][(n + 1) / 2 + 10][(n + 1) / 2 + 10];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 3;\n\t\tg[0][0][0] = 0;\n\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = Math.max(0, i - (n + 1) / 2); j <= Math.min(i, (n + 1) / 2); ++j) {\n\t\t\t\t\tg[k][i - j][j + 1] = Math.min(g[k][i - j][j + 1],\n\t\t\t\t\t\t\tg[k][i - j][j] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\tg[k][i - j + 1][j] = Math.min(g[k][i - j + 1][j],\n\t\t\t\t\t\t\tg[k][i - j][j] + a[i][1] + (i - j) * (a[i][0] + a[i][1]));\n\t\t\t\t\tif (k == 0 && n % 2 == 1) {\n\t\t\t\t\t\tg[1][i - j][j] = Math.min(g[1][i - j][j], g[0][i - j][j] + (n - 1) / 2 * (a[i][0] + a[i][1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tif (i + j + k == n)\n\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][][] g = new long[(n + 1) / 2 + 10][(n + 1) / 2 + 10][2];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 3;\n\t\tg[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = Math.max(0, i - (n + 1) / 2); j <= Math.min(i, (n + 1) / 2); ++j) {\n\t\t\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\t\t\tg[i - j][j + 1][k] = Math.min(g[i - j][j + 1][k],\n\t\t\t\t\t\t\tg[i - j][j][k] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\tg[i - j + 1][j][k] = Math.min(g[i - j + 1][j][k],\n\t\t\t\t\t\t\tg[i - j][j][k] + a[i][1] + (i - j) * (a[i][0] + a[i][1]));\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\tg[i - j][j][1] = Math.min(g[i - j][j][1], g[i - j][j][0] + (n - 1) * (a[i][0] + a[i][1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tif (i + j + k == n)\n\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][][] g = new long[2][n + 1][n + 1];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 10;\n\t\tg[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\t\tfor (int j = 0; j <= i - k; ++j) {\n\t\t\t\t\tg[k][i - j - k][j + 1] = Math.min(g[k][i - j - k][j + 1],\n\t\t\t\t\t\t\tg[k][i - j][j] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\tg[k][i - j - k + 1][j] = Math.min(g[k][i - j - k + 1][j],\n\t\t\t\t\t\t\tg[k][i - j - k][j] + a[i][1] + (i - j - k) * (a[i][0] + a[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\t\tg[1][i - j][j] = Math.min(g[1][i - j][j],\n\t\t\t\t\t\t\tg[0][i - j][j] + (n - 1) / 2 * (a[i][0] + a[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k) {\n\t\t\t\t\tif (i + j + k == n) {\n\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[][] a = new long[n][2];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i][0] = sc.nextLong();\n\t\t\ta[i][1] = sc.nextLong();\n\t\t}\n\t\tArrays.sort(a, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn -Long.compare(arg0[0] + arg0[1], arg1[0] + arg1[1]);\n\t\t\t}\n\t\t});\n\t\tlong ans = Long.MAX_VALUE / 3;\n\t\tlong[][] f = new long[n + 1][n + 1];\n\t\tfor (int i = 0; i < f.length; ++i)\n\t\t\tfor (int j = 0; j < f[i].length; ++j)\n\t\t\t\tf[i][j] = Long.MAX_VALUE / 3;\n\t\tf[0][0] = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tf[i - j][j + 1] = Math.min(f[i - j][j + 1], f[i - j][j] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\tf[i - j + 1][j] = Math.min(f[i - j + 1][j], f[i - j][j] + a[i][1] + (i - j) * (a[i][0] + a[i][1]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tans = Math.min(ans, f[i][n - i]);\n\t\t}\n\n\t\tif (n % 2 == 1) {\n\t\t\tlong[][][] g = new long[n + 1][n + 1][2];\n\t\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\t\tfor (int j = 0; j < g[i].length; ++j)\n\t\t\t\t\tfor (int k = 0; k < g[i][j].length; ++k)\n\t\t\t\t\t\tg[i][j][k] = Long.MAX_VALUE / 3;\n\t\t\tg[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\t\tfor (int k = 0; k <= 1; ++k) {\n\t\t\t\t\t\tg[i - j][j + 1][k] = Math.min(g[i - j][j + 1][k],\n\t\t\t\t\t\t\t\tg[i - j][j][k] + a[i][0] + j * (a[i][0] + a[i][1]));\n\t\t\t\t\t\tg[i - j + 1][j][k] = Math.min(g[i - j + 1][j][k],\n\t\t\t\t\t\t\t\tg[i - j][j][k] + a[i][1] + (i - j) * (a[i][0] + a[i][1]));\n\t\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t\tg[i - j][j][1] = Math.min(g[i - j][j][1], g[i - j][j][0] + (n - 1) * (a[i][0] + a[i][1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i + j + k == n)\n\t\t\t\t\t\t\tans = Math.min(ans, g[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n\n            var a = Enumerate(n, x => new long[] { rl, rl }).ToList();\n            if (n % 2 == 0) { n++; a.Add(new long[] { 0, 0 }); }\n            a.Sort((l, r) => (l[0] + l[1]).CompareTo(r[0] + r[1]));\n            a.Reverse();\n            //左側に動かすコスト Σi*Len_{i} + Σr_i\n            //右側に動かすコスト Σi*Len_{i} + Σl_i\n\n            //すでに i 個左に置かれていて，中心に置いたかどうか\n            var dp = new long[n + 5, 2];\n            for (int i = 0; i < n + 5; i++)\n                for (int j = 0; j < 2; j++)\n                    dp[i, j] = INF;\n            dp[0, 0] = 0;\n            var cnt = 0;\n            foreach (var x in a)\n            {\n                var l = x[0];\n                var r = x[1];\n                var len = x[0] + x[1];\n                Debug.WriteLine(len);\n                var next = new long[n + 5, 2];\n                for (int i = 0; i < n + 5; i++)\n                    for (int j = 0; j < 2; j++)\n                        next[i, j] = INF;\n                for (int j = 0; j < 2; j++)\n                    for (int i = 0; i + j <= cnt; i++)\n                    {\n                        var k = cnt - j - i;\n                        //left\n                        next[i + 1, j] = Math.Min(next[i + 1, j], dp[i, j] + i * len + r);\n                        //right\n                        next[i, j] = Math.Min(next[i, j], dp[i, j] + k * len + l);\n                        //center\n                        if (j == 0) next[i, j + 1] = Math.Min(next[i, j + 1], dp[i, j] + len * (n - 1));\n\n                    }\n                if (len == 0) { Console.WriteLine(dp[(n - 1) / 2, 0]); return; }\n                cnt++;\n                dp = next;\n            }\n            Console.WriteLine(dp[(n - 1) / 2, 1]);\n        }\n        const long INF = 1L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n\n            var a = Enumerate(n, x => new long[] { rl, rl }).ToList();\n            if (n % 2 == 0) { n++; a.Add(new long[] { 0, 0 }); }\n            a.Sort((l, r) => (l[0] + l[1]).CompareTo(r[0] + r[1]));\n            a.Reverse();\n            //左側に動かすコスト Σi*Len_{i} + Σr_i\n            //右側に動かすコスト Σi*Len_{i} + Σl_i\n\n            //すでに i 個左に置かれていて，中心に置いたかどうか\n            var dp = new long[n + 5, 2];\n            for (int i = 0; i < n + 5; i++)\n                for (int j = 0; j < 2; j++)\n                    dp[i, j] = INF;\n            dp[0, 0] = 0;\n            var cnt = 0;\n            foreach (var x in a)\n            {\n                var l = x[0];\n                var r = x[1];\n                var len = x[0] + x[1];\n                Debug.WriteLine(len);\n                var next = new long[n + 5, 2];\n                for (int i = 0; i < n + 5; i++)\n                    for (int j = 0; j < 2; j++)\n                        next[i, j] = INF;\n                for (int j = 0; j < 2; j++)\n                    for (int i = 0; i + j <= cnt; i++)\n                    {\n                        var k = cnt - j - i;\n                        //left\n                        next[i + 1, j] = Math.Min(next[i + 1, j], dp[i, j] + i * len + r);\n                        //right\n                        next[i, j] = Math.Min(next[i, j], dp[i, j] + k * len + l);\n                        //center\n                        if (j == 0) next[i, j + 1] = Math.Min(next[i, j + 1], dp[i, j] + len * (n - 1));\n                    }\n                cnt++;\n                dp = next;\n            }\n            Console.WriteLine(dp[(n - 1) / 2, 1]);\n        }\n        const long INF = 1L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n\n            var a = Enumerate(n, x => new long[] { rl, rl }).ToList();\n            if (n % 2 == 0) { n++; a.Add(new long[] { 0, 0 }); }\n            a.Sort((l, r) => (l[0] + l[1]).CompareTo(r[0] + r[1]));\n            a.Reverse();\n            //左側に動かすコスト Σi*Len_{i} + Σr_i\n            //右側に動かすコスト Σi*Len_{i} + Σl_i\n\n            //すでに i 個左に置かれていて，中心に置いたかどうか\n            var dp = new long[n + 5, 2];\n            for (int i = 0; i < n + 5; i++)\n                for (int j = 0; j < 2; j++)\n                    dp[i, j] = INF;\n            dp[0, 0] = 0;\n            var cnt = 0;\n            foreach (var x in a)\n            {\n                var l = x[0];\n                var r = x[1];\n                var len = x[0] + x[1];\n                Debug.WriteLine(len);\n                var next = new long[n + 5, 2];\n                for (int i = 0; i < n + 5; i++)\n                    for (int j = 0; j < 2; j++)\n                        next[i, j] = INF;\n                for (int j = 0; j < 2; j++)\n                    for (int i = 0; i + j <= cnt; i++)\n                    {\n                        var k = cnt - j - i;\n                        //left\n                        next[i + 1, j] = Math.Min(next[i + 1, j], dp[i, j] + i * len + r);\n                        //right\n                        next[i, j] = Math.Min(next[i, j], dp[i, j] + k * len + l);\n                        //center\n                        if (j == 0) next[i, j + 1] = Math.Min(next[i, j + 1], dp[i, j] + len * (n - 1) / 2);\n\n                    }\n                cnt++;\n                dp = next;\n            }\n            Console.WriteLine(dp[(n - 1) / 2, 1]);\n        }\n        const long INF = 1L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv, std.range;\nimport std.typecons, std.math;\n\n// import dcomp.scanner, dcomp.functional;\n\nalias E = Tuple!(int, \"to\");\n\nint U;\nlong[2][] d;\nlong[][][] dp;\nbool[][][] used;\nlong calc(int p, int a, int c) {\n    if (used[c][p][a]) return dp[c][p][a];\n    used[c][p][a] = true;\n    if (p == d.length) return 0;\n    long[2] nw = d[p];\n    int b = p-a;\n\n    long ans = 10L^^18;\n    if (c == 0) {\n        ans = min(ans, U*(nw[0]+nw[1]) + calc(p+1, a, 1));\n    }\n    if (a < U) {\n        ans = min(ans, a*(nw[0]+nw[1]) + nw[1] + calc(p+1, a+1, c));\n    }\n    if (b < U) {\n        ans = min(ans, b*(nw[0]+nw[1]) + nw[0] + calc(p+1, a, c));\n    }\n    return dp[c][p][a] = ans;\n}\n\nint main() {\n    dp = new long[][][](2, 5005, 2505);\n    used = new bool[][][](2, 5005, 2505);\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    d = new long[2][n];\n    foreach (i; 0..n) {\n        sc.read(d[i]);\n    }\n    d.sort!\"a[0]+a[1] > b[0]+b[1]\";\n    U = n/2;\n    writeln(calc(0, 0, 1-n%2));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args)); // should be int only?\n\n    static immutable N = Args.length;\n    static string toTuple(string s) { //int[N] -> (N[0], N[1], N[2], ...)\n        return \"(\" ~ iota(N).map!(i => s~\"[\"~i.to!string~\"]\").join(\",\") ~ \")\";\n    }\n    static string toArray(string s) { //int[N] -> [N[0]][N[1]][N[2]]...\n        return iota(N).map!(i => \"[\"~s~\"[\"~i.to!string~\"]]\").join(\"\");\n    }\n    template NArray(T, int N) {\n        static if (!N) alias NArray = T;\n        else alias NArray = NArray!(T, N-1)[];\n    }\n    int[2][N] rng;\n    NArray!(R, N) dp;\n    NArray!(bool, N) used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        int[N] len = rng[].map!(a => a[1]-a[0]+1).array;\n        \n        //dp = new typeof(dp)(len[0], len[1], ..., len[N-1])\n        //used = new typeof(used)(len[0], len[1], ..., len[N-1])\n        dp = mixin(\"new typeof(dp)\"~toTuple(\"len\"));\n        used = mixin(\"new typeof(used)\"~toTuple(\"len\"));\n    }\n    R opCall(Args args) {\n        int[N] idx;\n        foreach (i, v; args) {\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx[i] = v - rng[i][0];\n        }\n        //if (used[idx[0]]..[idx[N-1]]) dp[idx[0]]..[idx[N-1]]\n        //used[idx[0]]..[idx[N-1]] = true\n        if (mixin(\"used\"~toArray(\"idx\"))) return mixin(\"dp\"~toArray(\"idx\"));\n        mixin(\"used\"~toArray(\"idx\")) = true;\n\n        auto r = pred(args);\n\n        //dp[idx[0]]..[idx[N-1]] = r\n        mixin(\"dp\"~toArray(\"idx\")) = r;\n\n        return r;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv, std.range;\nimport std.typecons, std.math;\n\n// import dcomp.scanner, dcomp.functional;\n\nalias E = Tuple!(int, \"to\");\n\nint U;\nlong[2][] d;\nlong calcB(int p, int a, int c) {\n    if (p == d.length) return 0;\n    long[2] nw = d[p];\n    int b = p-a;\n\n    long ans = 10L^^18;\n    if (c == 0) {\n        ans = min(ans, U*(nw[0]+nw[1]) + calc(p+1, a, 1));\n    }\n    if (a < U) {\n        ans = min(ans, a*(nw[0]+nw[1]) + nw[1] + calc(p+1, a+1, c));\n    }\n    if (b < U) {\n        ans = min(ans, b*(nw[0]+nw[1]) + nw[0] + calc(p+1, a, c));\n    }\n    return ans;\n}\nmemoCont!calcB calc;\n\nint main() {\n    calc.init([[0, 5005], [0, 2505], [0, 1]]);\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    d = new long[2][n];\n    foreach (i; 0..n) {\n        sc.read(d[i]);\n    }\n    d.sort!\"a[0]+a[1] > b[0]+b[1]\";\n    U = n/2;\n    writeln(calc(0, 0, 1-n%2));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args)); // should be int only?\n\n    static immutable N = Args.length;\n    static string toTuple(string s) { //int[N] -> (N[0], N[1], N[2], ...)\n        return \"(\" ~ iota(N).map!(i => s~\"[\"~i.to!string~\"]\").join(\",\") ~ \")\";\n    }\n    static string toArray(string s) { //int[N] -> [N[0]][N[1]][N[2]]...\n        return iota(N).map!(i => \"[\"~s~\"[\"~i.to!string~\"]]\").join(\"\");\n    }\n    template NArray(T, int N) {\n        static if (!N) alias NArray = T;\n        else alias NArray = NArray!(T, N-1)[];\n    }\n    int[2][N] rng;\n    NArray!(R, N) dp;\n    NArray!(bool, N) used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        int[N] len = rng[].map!(a => a[1]-a[0]+1).array;\n        \n        //dp = new typeof(dp)(len[0], len[1], ..., len[N-1])\n        //used = new typeof(used)(len[0], len[1], ..., len[N-1])\n        dp = mixin(\"new typeof(dp)\"~toTuple(\"len\"));\n        used = mixin(\"new typeof(used)\"~toTuple(\"len\"));\n    }\n    R opCall(Args args) {\n        int[N] idx;\n        foreach (i, v; args) {\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx[i] = v - rng[i][0];\n        }\n        //if (used[idx[0]]..[idx[N-1]]) dp[idx[0]]..[idx[N-1]]\n        //used[idx[0]]..[idx[N-1]] = true\n        if (mixin(\"used\"~toArray(\"idx\"))) return mixin(\"dp\"~toArray(\"idx\"));\n        mixin(\"used\"~toArray(\"idx\")) = true;\n\n        auto r = pred(args);\n\n        //dp[idx[0]]..[idx[N-1]] = r\n        mixin(\"dp\"~toArray(\"idx\")) = r;\n\n        return r;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv, std.range;\nimport std.typecons, std.math;\n\n// import dcomp.scanner, dcomp.functional;\n\nint U;\nlong[2][] d;\nlong[][][] dp;\nbool[][][] used;\n\nlong calcBase(int p, int a, int c) {\n    if (p == d.length) return 0;\n    long[2] nw = d[p];\n    int b = p-a;\n \n    long ans = 10L^^18;\n    if (c == 0) {\n        ans = min(ans, U*(nw[0]+nw[1]) + calc(p+1, a, 1));\n    }\n    if (a < U) {\n        ans = min(ans, a*(nw[0]+nw[1]) + nw[1] + calc(p+1, a+1, c));\n    }\n    if (b < U) {\n        ans = min(ans, b*(nw[0]+nw[1]) + nw[0] + calc(p+1, a, c));\n    }\n    return ans;\n}\n\nmemoCont!calcBase calc;\n\nint main() {\n    calc.init([[0, 5005], [0,2505], [0, 1]]);\n//    dp = new long[][][](2, 5005, 2505);\n//    used = new bool[][][](2, 5005, 2505);\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    d = new long[2][n];\n    foreach (i; 0..n) {\n        sc.read(d[i]);\n    }\n    d.sort!\"a[0]+a[1] > b[0]+b[1]\";\n    U = n/2;\n    writeln(calc(0, 0, 1-n%2));\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        \n        int sz = len.reduce!\"a*b\";\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        int idx, base = 1;\n        foreach (i, v; args) {\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\nunittest {\n//     import dcomp.numeric.primitive;\n//     import dcomp.numeric.modint;\n    alias Mint = ModInt!(10^^9+7);\n    auto fact = factTable!Mint(100);\n    auto iFac = invFactTable!Mint(100);\n    Mint C0(int a, int b) {\n        if (a < 0 || a < b) return Mint(0);\n        return fact[a]*iFac[b]*iFac[a-b];\n    }\n    struct A {\n        static memoCont!C1base C1;\n        static Mint C1base(int a, int b) {\n            if (a == 0) {\n                if (b == 0) return Mint(1);\n                return Mint(0);\n            }\n            if (b < 0) return Mint(0);\n            return C1(a-1, b-1) + C1(a-1, b);\n        }\n    }\n    A.C1.init([[0, 100], [-2, 100]]);\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            assert(C0(i, j) == A.C1(i, j));\n        }\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/modint.d */\n// module dcomp.numeric.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (long(v)%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt {\n    import std.conv : to;\n    uint MD, v;\n    this(int v, uint md) {\n        MD = md;\n        this.v = ((long(v)%MD+MD)%MD).to!uint;\n    }\n    this(long v, uint md) {\n        MD = md;\n        this.v = ((v%MD+MD)%MD).to!uint;\n    }\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        assert(MD == r.MD);\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        assert(MD == r.MD);\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        assert(MD == r.MD);\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        assert(MD == r.MD);\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, x.MD)[0], x.MD);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    immutable MD = 10^^9 + 7;\n    alias Mint = DModInt;\n    //negative check\n    assert(Mint(-1, MD).v == 10^^9 + 6);\n    assert(Mint(-1L, MD).v == 10^^9 + 6);\n    Mint a = Mint(48, MD);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15, MD);\n    Mint d = Mint(3, MD);\n    assert((c/d).v == 5);\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) { return pow(x, n, T(1)); }\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n\nT[] factTable(T)(size_t length) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]/T(n)).take(length).array;\n}\n\nunittest {\n    import std.stdio;\n//     import dcomp.numeric.modint;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv, std.range;\nimport std.typecons, std.math;\n\n// import dcomp.scanner, dcomp.functional;\n\nint U;\nlong[2][] d;\nlong[][][] dp;\nbool[][][] used;\n\nlong calcBase(int p, int a, int c) {\n    if (p == d.length) return 0;\n    long[2] nw = d[p];\n    int b = p-a;\n \n    long ans = 10L^^18;\n    if (c == 0) {\n        ans = min(ans, U*(nw[0]+nw[1]) + calc(p+1, a, 1));\n    }\n    if (a < U) {\n        ans = min(ans, a*(nw[0]+nw[1]) + nw[1] + calc(p+1, a+1, c));\n    }\n    if (b < U) {\n        ans = min(ans, b*(nw[0]+nw[1]) + nw[0] + calc(p+1, a, c));\n    }\n    return ans;\n}\n\nmemoCont!calcBase calc;\n\nint main() {\n    calc.init([[0, 5005], [0,5005], [0, 1]]);\n//    dp = new long[][][](2, 5005, 2505);\n//    used = new bool[][][](2, 5005, 2505);\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    d = new long[2][n];\n    foreach (i; 0..n) {\n        sc.read(d[i]);\n    }\n    d.sort!\"a[0]+a[1] > b[0]+b[1]\";\n    U = n/2;\n    writeln(calc(0, 0, 1-n%2));\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        \n        int sz = len.reduce!\"a*b\";\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        int idx, base = 1;\n        foreach (i, v; args) {\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\nunittest {\n//     import dcomp.numeric.primitive;\n//     import dcomp.numeric.modint;\n    alias Mint = ModInt!(10^^9+7);\n    auto fact = factTable!Mint(100);\n    auto iFac = invFactTable!Mint(100);\n    Mint C0(int a, int b) {\n        if (a < 0 || a < b) return Mint(0);\n        return fact[a]*iFac[b]*iFac[a-b];\n    }\n    struct A {\n        static memoCont!C1base C1;\n        static Mint C1base(int a, int b) {\n            if (a == 0) {\n                if (b == 0) return Mint(1);\n                return Mint(0);\n            }\n            if (b < 0) return Mint(0);\n            return C1(a-1, b-1) + C1(a-1, b);\n        }\n    }\n    A.C1.init([[0, 100], [-2, 100]]);\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            assert(C0(i, j) == A.C1(i, j));\n        }\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/modint.d */\n// module dcomp.numeric.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (long(v)%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt {\n    import std.conv : to;\n    uint MD, v;\n    this(int v, uint md) {\n        MD = md;\n        this.v = ((long(v)%MD+MD)%MD).to!uint;\n    }\n    this(long v, uint md) {\n        MD = md;\n        this.v = ((v%MD+MD)%MD).to!uint;\n    }\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        assert(MD == r.MD);\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        assert(MD == r.MD);\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        assert(MD == r.MD);\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        assert(MD == r.MD);\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, x.MD)[0], x.MD);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    immutable MD = 10^^9 + 7;\n    alias Mint = DModInt;\n    //negative check\n    assert(Mint(-1, MD).v == 10^^9 + 6);\n    assert(Mint(-1L, MD).v == 10^^9 + 6);\n    Mint a = Mint(48, MD);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15, MD);\n    Mint d = Mint(3, MD);\n    assert((c/d).v == 5);\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) { return pow(x, n, T(1)); }\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n\nT[] factTable(T)(size_t length) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]/T(n)).take(length).array;\n}\n\nunittest {\n    import std.stdio;\n//     import dcomp.numeric.modint;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nN = int(readline())\nLR = [tuple(int(x) for x in line.split()) for line in readlines()]\n\n\"\"\"\n・奇数個のとき：中央にどれかを固定。\n・偶数のとき：原点で左右に分けるとしてよい。\n・基本的に長さで内側から昇順（奇数のときの中央は謎）。→ソートしてdpできる。\n・左に置いた個数をもってdp更新。また、中央を使ったかも同時に持って。\n・偶数のときは、中央に1つ置いた状態から始める。\n・大きい区間から外側に入れていく。\n\"\"\"\n\nLR.sort(key = lambda x: -x[1]-x[0])\n\nINF = 10**15\ndp_0 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央未確定。\ndp_1 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央確定。\nif N&1:\n    dp_0[0] = 0\nelse:\n    dp_1[0] = 0\nfor n,(L,R) in enumerate(LR):\n    length = R + L\n    prev_0 = dp_0\n    prev_1 = dp_1\n    dp_0 = np.full(N+1,INF,np.int64)\n    dp_1 = np.full(N+1,INF,np.int64)\n    x = np.arange(n+1,dtype=np.int64) # もともと左側にあった個数\n    # 左側に置く場合\n    np.minimum(prev_0[:n+1] + R + x * length, dp_0[1:n+2], out=dp_0[1:n+2])\n    np.minimum(prev_1[:n+1] + R + x * length, dp_1[1:n+2], out=dp_1[1:n+2])\n    # 右側に置く場合\n    np.minimum(prev_0[:n+1] + L + (n-x) * length, dp_0[:n+1], out=dp_0[:n+1])\n    np.minimum(prev_1[:n+1] + L + (n-x) * length, dp_1[:n+1], out=dp_1[:n+1])\n    # 中央に置く場合\n    np.minimum(prev_0[:n+1] + (N-1)//2 * length, dp_1[:n+1], out = dp_1[:n+1])\n\nanswer = dp_1[N//2]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nN = int(readline())\nLR = [tuple(int(x) for x in line.split()) for line in readlines()]\n\n\"\"\"\n・奇数個のとき：中央にどれかを固定。\n・偶数のとき：原点で左右に分けるとしてよい。\n・基本的に長さで内側から昇順（奇数のときの中央は謎）。→ソートしてdpできる。\n・左に置いた個数をもってdp更新。また、中央を使ったかも同時に持って。\n・偶数のときは、中央に1つ置いた状態から始める。\n・大きい区間から外側に入れていく。\n\"\"\"\n\nLR.sort(key = lambda x: -x[1]-x[0])\n\nINF = 10**18\ndp_0 = np.full(1,INF,np.int64) # 左に置いた個数 → コスト。中央未確定。\ndp_1 = np.full(1,INF,np.int64) # 左に置いた個数 → コスト。中央確定。\nif N&1:\n    dp_0[0] = 0\nelse:\n    dp_1[0] = 0\nfor n,(L,R) in enumerate(LR):\n    length = R + L\n    prev_0 = dp_0\n    prev_1 = dp_1\n    dp_0 = np.full(n+2,INF,np.int64)\n    dp_1 = np.full(n+2,INF,np.int64)\n    x = np.arange(n+1,dtype=np.int64) # もともと左側にあった個数\n    # 左側に置く場合\n    np.minimum(prev_0[:n+1] + R + x * length, dp_0[1:n+2], out=dp_0[1:n+2])\n    np.minimum(prev_1[:n+1] + R + x * length, dp_1[1:n+2], out=dp_1[1:n+2])\n    # 右側に置く場合\n    np.minimum(prev_0[:n+1] + L + (n-x) * length, dp_0[:n+1], out=dp_0[:n+1])\n    np.minimum(prev_1[:n+1] + L + (n-x) * length, dp_1[:n+1], out=dp_1[:n+1])\n    # 中央に置く場合\n    np.minimum(prev_0[:n+1] + (N-1)//2 * length, dp_1[:n+1], out = dp_1[:n+1])\n\nanswer = dp_1[N//2]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nN = int(readline())\nLR = [tuple(int(x) for x in line.split()) for line in readlines()]\n\n\"\"\"\n・奇数個のとき：中央にどれかを固定。\n・偶数のとき：原点で左右に分けるとしてよい。\n・基本的に長さで内側から昇順（奇数のときの中央は謎）。→ソートしてdpできる。\n・左に置いた個数をもってdp更新。また、中央を使ったかも同時に持って。\n・偶数のときは、中央に1つ置いた状態から始める。\n・大きい区間から外側に入れていく。\n\"\"\"\n\nLR.sort(key = lambda x: -x[1]-x[0])\n\nINF = 10**18\ndp_0 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央未確定。\ndp_1 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央確定。\nif N&1:\n    dp_0[0] = 0\nelse:\n    dp_1[0] = 0\nfor n,(L,R) in enumerate(LR):\n    length = R + L\n    prev_0 = dp_0\n    prev_1 = dp_1\n    dp_0 = np.full(N+1,INF,np.int64)\n    dp_1 = np.full(N+1,INF,np.int64)\n    x = np.arange(n+1,dtype=np.int64) # もともと左側にあった個数\n    # 左側に置く場合\n    np.minimum(prev_0[:n+1] + R + x * length, dp_0[1:n+2], out=dp_0[1:n+2])\n    np.minimum(prev_1[:n+1] + R + x * length, dp_1[1:n+2], out=dp_1[1:n+2])\n    # 右側に置く場合\n    np.minimum(prev_0[:n+1] + L + (n-x) * length, dp_0[:n+1], out=dp_0[:n+1])\n    np.minimum(prev_1[:n+1] + L + (n-x) * length, dp_1[:n+1], out=dp_1[:n+1])\n    # 中央に置く場合\n    np.minimum(prev_0[:n+1] + (N-1)//2 * length, dp_1[:n+1], out = dp_1[:n+1])\n\nanswer = dp_1[N//2]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nN = int(readline())\nLR = [tuple(int(x) for x in line.split()) for line in readlines()]\n\n\"\"\"\n・奇数個のとき：中央にどれかを固定。\n・偶数のとき：原点で左右に分けるとしてよい。\n・基本的に長さで内側から昇順（奇数のときの中央は謎）。→ソートしてdpできる。\n・左に置いた個数をもってdp更新。また、中央を使ったかも同時に持って。\n・偶数のときは、中央に1つ置いた状態から始める。\n・大きい区間から外側に入れていく。\n\"\"\"\n\nLR.sort(key = lambda x: -x[1]-x[0])\n\nif N%2 == 1:\n    raise Exception\n\nINF = 10**15\ndp_0 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央未確定。\ndp_1 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央確定。\nif N&1:\n    dp_0[0] = 0\nelse:\n    dp_1[0] = 0\nfor n,(L,R) in enumerate(LR):\n    length = R + L\n    prev_0 = dp_0\n    prev_1 = dp_1\n    dp_0 = np.full(N+1,INF,np.int64)\n    dp_1 = np.full(N+1,INF,np.int64)\n    x = np.arange(n+1,dtype=np.int64) # もともと左側にあった個数\n    # 左側に置く場合\n    np.minimum(prev_0[:n+1] + R + x * length, dp_0[1:n+2], out=dp_0[1:n+2])\n    np.minimum(prev_1[:n+1] + R + x * length, dp_1[1:n+2], out=dp_1[1:n+2])\n    # 右側に置く場合\n    np.minimum(prev_0[:n+1] + L + (n-x) * length, dp_0[:n+1], out=dp_0[:n+1])\n    np.minimum(prev_1[:n+1] + L + (n-x) * length, dp_1[:n+1], out=dp_1[:n+1])\n    # 中央に置く場合\n    np.minimum(prev_0[:n+1] + (N-1)//2 * length, dp_1[:n+1], out = dp_1[:n+1])\n\nanswer = dp_1[N//2]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nimport numpy as np\n\nN = int(readline())\nLR = [tuple(int(x) for x in line.split()) for line in readlines()]\n\n\"\"\"\n・奇数個のとき：中央にどれかを固定。\n・偶数のとき：原点で左右に分けるとしてよい。\n・基本的に長さで内側から昇順（奇数のときの中央は謎）。→ソートしてdpできる。\n・左に置いた個数をもってdp更新。また、中央を使ったかも同時に持って。\n・偶数のときは、中央に1つ置いた状態から始める。\n・大きい区間から外側に入れていく。\n\"\"\"\n\nLR.sort(key = lambda x: -x[1]-x[0])\n\nif N%2 == 1:\n    raise Exception\n\n\n\nINF = 10**18\ndp_0 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央未確定。\ndp_1 = np.full(N+1,INF,np.int64) # 左に置いた個数 → コスト。中央確定。\nif N&1:\n    dp_0[0] = 0\nelse:\n    dp_1[0] = 0\nfor n,(L,R) in enumerate(LR):\n    length = R + L\n    prev_0 = dp_0\n    prev_1 = dp_1\n    dp_0 = np.full(N+1,INF,np.int64)\n    dp_1 = np.full(N+1,INF,np.int64)\n    x = np.arange(n+1,dtype=np.int64) # もともと左側にあった個数\n    # 左側に置く場合\n    np.minimum(prev_0[:n+1] + R + x * length, dp_0[1:n+2], out=dp_0[1:n+2])\n    np.minimum(prev_1[:n+1] + R + x * length, dp_1[1:n+2], out=dp_1[1:n+2])\n    # 右側に置く場合\n    np.minimum(prev_0[:n+1] + L + (n-x) * length, dp_0[:n+1], out=dp_0[:n+1])\n    np.minimum(prev_1[:n+1] + L + (n-x) * length, dp_1[:n+1], out=dp_1[:n+1])\n    # 中央に置く場合\n    np.minimum(prev_0[:n+1] + (N-1)//2 * length, dp_1[:n+1], out = dp_1[:n+1])\n\nanswer = dp_1[N//2]\nprint(answer)"
  }
]