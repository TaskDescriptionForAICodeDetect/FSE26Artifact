[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int l, r;\n} Interval;\n\nint compare(const void* a, const void* b) {\n    Interval* x = (Interval*)a;\n    Interval* y = (Interval*)b;\n    return x->l - y->l;\n}\n\nint solve(Interval* intervals, int n) {\n    qsort(intervals, n, sizeof(Interval), compare);\n    \n    int min_cost = INT_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int cost = 0;\n            Interval* temp = malloc(n * sizeof(Interval));\n            memcpy(temp, intervals, n * sizeof(Interval));\n            \n            for (int k = 0; k < n; k++) {\n                if (k == j) continue;\n                \n                while (k != j && temp[k].r > temp[j].l) {\n                    int move_dist = temp[k].r - temp[j].l + 1;\n                    temp[k].l -= move_dist;\n                    temp[k].r -= move_dist;\n                    cost += move_dist;\n                }\n            }\n            \n            int is_disjoint = 1;\n            for (int k = 0; k < n; k++) {\n                for (int l = k + 1; l < n; l++) {\n                    if (k == j || l == j) continue;\n                    if (temp[k].r >= temp[l].l) {\n                        is_disjoint = 0;\n                        break;\n                    }\n                }\n                if (!is_disjoint) break;\n            }\n            \n            if (is_disjoint) {\n                min_cost = (cost < min_cost) ? cost : min_cost;\n            }\n            \n            free(temp);\n        }\n    }\n    \n    return min_cost;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Interval* intervals = malloc(n * sizeof(Interval));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &intervals[i].l, &intervals[i].r);\n    }\n    \n    int result = solve(intervals, n);\n    printf(\"%d\\n\", result);\n    \n    free(intervals);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int l, r;\n} Interval;\n\nint compare(const void *a, const void *b) {\n    Interval *ia = (Interval *)a;\n    Interval *ib = (Interval *)b;\n    return (ia->l + ia->r) - (ib->l + ib->r);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Interval *intervals = (Interval *)malloc(N * sizeof(Interval));\n    for (int i = 0; i < N; ++i) {\n        int L, R;\n        scanf(\"%d %d\", &L, &R);\n        intervals[i].l = -L;\n        intervals[i].r = R;\n    }\n\n    qsort(intervals, N, sizeof(Interval), compare);\n\n    long long cost = 0;\n    for (int i = 0; i < N; ++i) {\n        int mid = (intervals[i].l + intervals[i].r) / 2;\n        cost += abs(intervals[i].l - mid) + abs(intervals[i].r - mid);\n    }\n\n    printf(\"%lld\\n\", cost);\n    free(intervals);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Interval {\n    long long a, b;\n    bool operator<(const Interval& other) const {\n        return a < other.a;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Interval> intervals(N);\n    for (int i = 0; i < N; ++i) {\n        long long L, R;\n        cin >> L >> R;\n        intervals[i].a = -L;\n        intervals[i].b = R;\n    }\n    sort(intervals.begin(), intervals.end());\n    \n    long long cost = 0;\n    for (int i = 1; i < N; ++i) {\n        long long prev_b = intervals[i-1].b;\n        long long curr_a = intervals[i].a;\n        if (curr_a < prev_b) {\n            long long d = prev_b - curr_a;\n            cost += d;\n            intervals[i].a += d;\n            intervals[i].b += d;\n        }\n    }\n    cout << cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Interval implements Comparable<Interval> {\n        long left, right;\n        Interval(long l, long r) {\n            left = l;\n            right = r;\n        }\n        @Override\n        public int compareTo(Interval other) {\n            return Long.compare(this.left + this.right, other.left + other.right);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        Interval[] intervals = new Interval[N];\n        for (int i = 0; i < N; i++) {\n            long L = scanner.nextLong();\n            long R = scanner.nextLong();\n            intervals[i] = new Interval(-L, R);\n        }\n        Arrays.sort(intervals);\n\n        long res = 0;\n        for (int i = 0; i < N; i++) {\n            long center = (intervals[i].left + intervals[i].right) / 2;\n            res += Math.abs(intervals[i].left - center) + Math.abs(intervals[i].right - center);\n            if (i < N - 1) {\n                long nextCenter = (intervals[i + 1].left + intervals[i + 1].right) / 2;\n                if (nextCenter < center) {\n                    intervals[i + 1].left = intervals[i + 1].left + (center - nextCenter);\n                    intervals[i + 1].right = intervals[i + 1].right + (center - nextCenter);\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:30:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SnukeIntervals {\n    public static void solve(int N, int[] L, int[] R) {\n        // Sort intervals by left endpoint\n        Integer[] indices = new Integer[N];\n        for (int i = 0; i < N; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, (a, b) -> Integer.compare(L[a], L[b]));\n\n        // Dynamic programming to find minimum cost\n        long[][] dp = new long[N][N];\n        for (int[] row : dp) Arrays.fill(row, Long.MAX_VALUE / 2);\n        \n        // Initial state for single intervals\n        for (int i = 0; i < N; i++) {\n            dp[i][i] = 0;\n        }\n\n        // Try covering all possible interval combinations\n        for (int len = 2; len <= N; len++) {\n            for (int i = 0; i + len - 1 < N; i++) {\n                int j = i + len - 1;\n                \n                // Try separate left and right intervals\n                for (int k = i; k < j; k++) {\n                    // Ensure no overlap when combined\n                    int leftMax = L[indices[k]];\n                    int rightMin = L[indices[k+1]];\n                    long cost = dp[i][k] + dp[k+1][j];\n                    \n                    if (R[indices[k]] < rightMin) {\n                        // Add cost to move right interval\n                        cost += Math.max(0, leftMax + 1 - rightMin);\n                    }\n                    \n                    dp[i][j] = Math.min(dp[i][j], cost);\n                }\n            }\n        }\n\n        // Output minimum cost\n        System.out.println(dp[0][N-1]);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        // Read input\n        int N = Integer.parseInt(br.readLine());\n        int[] L = new int[N];\n        int[] R = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            String[] parts = br.readLine().split(\" \");\n            L[i] = Integer.parseInt(parts[0]);\n            R[i] = Integer.parseInt(parts[1]);\n        }\n        \n        solve(N, L, R);\n    }\n}",
    "timestamp": "2025-08-05 23:30:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAXN = 100005;\nvector<pair<ll, ll>> intervals;\nint N;\n\nll solve() {\n    sort(intervals.begin(), intervals.end());\n    \n    ll cost = 0;\n    for (int i = 1; i < N; i++) {\n        ll overlap = max(0LL, intervals[i-1].second - intervals[i].first + 1);\n        if (overlap > 0) {\n            cost += overlap;\n            intervals[i].first += overlap;\n            intervals[i].second += overlap;\n        }\n    }\n    \n    return cost;\n}\n\nint main() {\n    cin >> N;\n    intervals.resize(N);\n    \n    for (int i = 0; i < N; i++) {\n        ll L, R;\n        cin >> L >> R;\n        intervals[i] = {L, R};\n    }\n    \n    cout << solve() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_cost_intervals(N, intervals):\n    events = []\n    for i in range(N):\n        L, R = intervals[i]\n        events.append((-(L + R), L, R, i))\n\n    events.sort()\n    active_intervals = []\n    total_cost = 0\n\n    for event in events:\n        _, L, R, i = event\n        if not active_intervals or active_intervals[-1][1] < L:\n            active_intervals.append((L, R, i))\n        else:\n            overlap = active_intervals[-1][1] - L + 1\n            move_cost = abs(overlap // 2)\n            L += move_cost\n            R += move_cost\n            total_cost += move_cost\n            active_intervals.append((L, R, i))\n\n    return total_cost\n\n# Example usage:\nN = 3\nintervals = [(3, 5), (1, 4), (6, 8)]\nprint(minimum_cost_intervals(N, intervals))  # Output should be the minimum cost to make intervals disjoint",
    "timestamp": "2025-08-13 15:34:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class IntervalAdjustment {\n    public static void main(String[] args) {\n        int[][] intervals = {{1, 3}, {2, 5}, {4, 6}};\n        System.out.println(minimumCost(intervals));\n    }\n\n    public static int minimumCost(int[][] intervals) {\n        int n = intervals.length;\n\n        // Sort intervals by their starting point [-L_i, R_i] -> [L_i, R_i]\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n\n        // Dynamic programming array to store minimum cost up to each interval\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        \n        // Initializing the first interval\n        dp[0] = 0;\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                // Calculate overlap between intervals i and j\n                int overlap = Math.max(0, Math.min(intervals[i][1], intervals[j][1]) - intervals[i][0]);\n\n                // Compute the distance needed to move interval i to make it non-overlapping with interval j\n                int distance = overlap + 1; // at least 1 unit gap\n                int cost = i <= j ? dp[j] + distance : dp[j];\n\n                // Update dp[i] by trying to adjust current interval i to be non-overlapping with j\n                dp[i] = Math.min(dp[i], cost);\n            }\n        }\n\n        // The answer is the minimum cost to adjust the last interval\n        return dp[n - 1];\n    }\n}",
    "timestamp": "2025-08-13 15:34:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int left;\n    int right;\n} Interval;\n\nint compare(const void *a, const void *b) {\n    Interval *interval1 = (Interval *)a;\n    Interval *interval2 = (Interval *)b;\n    return interval1->right - interval2->right;\n}\n\nint minCostToDisjoinIntervals(int n, Interval *intervals) {\n    qsort(intervals, n, sizeof(Interval), compare);\n\n    int totalCost = 0;\n    for (int i = 1; i < n; i++) {\n        if (intervals[i].left <= intervals[i - 1].right) {\n            int moveRightCost = intervals[i - 1].right - intervals[i].left + 1;\n            intervals[i].left += moveRightCost;\n            intervals[i].right += moveRightCost;\n            totalCost += moveRightCost;\n        }\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Interval intervals[n];\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        intervals[i].left = -l;\n        intervals[i].right = r;\n    }\n\n    int result = minCostToDisjoinIntervals(n, intervals);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:34:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Interval {\n    int L, R;\n};\n\n// Custom comparator to sort intervals by their end points\nbool compareByEndpoint(const Interval &a, const Interval &b) {\n    return a.R < b.R;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Interval> intervals(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> intervals[i].L >> intervals[i].R;\n        intervals[i].L = -intervals[i].L;  // Change [-Li, Ri] to [Li, Ri]\n    }\n    \n    // Sort intervals by their right ends\n    sort(intervals.begin(), intervals.end(), compareByEndpoint);\n    \n    int totalCost = 0;\n    int currentEnd = -std::numeric_limits<int>::max();\n    \n    for (const auto &interval : intervals) {\n        if (interval.L > currentEnd) {\n            // If current interval is already non-overlapping\n            currentEnd = interval.R;\n        } else {\n            // Calculate the cost to move the interval past currentEnd\n            int cost = currentEnd - interval.L;\n            totalCost += cost;\n            currentEnd += interval.R - interval.L;\n        }\n    }\n\n    cout << totalCost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:34:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_intervals(N, intervals):\n    intervals.sort(key=lambda x: x[0])\n    \n    def check_overlap(intervals):\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= intervals[i-1][1]:\n                return False\n        return True\n    \n    def min_move_cost(intervals):\n        if check_overlap(intervals):\n            return 0\n        \n        min_cost = float('inf')\n        \n        for i in range(len(intervals)):\n            for j in range(i+1, len(intervals)):\n                # Try moving interval i\n                for sign in [-1, 1]:\n                    new_intervals = intervals.copy()\n                    move_dist = intervals[j][1] - intervals[i][1] + 1 if sign > 0 else intervals[i][0] - intervals[j][0] + 1\n                    new_intervals[i] = (intervals[i][0] + sign * move_dist, intervals[i][1] + sign * move_dist)\n                    new_intervals.sort(key=lambda x: x[0])\n                    \n                    if check_overlap(new_intervals):\n                        min_cost = min(min_cost, move_dist)\n        \n        return min_cost\n    \n    return min_move_cost(intervals)\n\n# Input handling\nN = int(input())\nintervals = []\nfor _ in range(N):\n    L, R = map(int, input().split())\n    intervals.append((L, R))\n\nprint(solve_intervals(N, intervals))",
    "timestamp": "2025-08-13 15:34:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    intervals = []\n    for _ in range(N):\n        L, R = map(int, sys.stdin.readline().split())\n        intervals.append((L, R))\n    \n    # Sort intervals based on L_i + R_i\n    intervals.sort(key=lambda x: x[0] + x[1])\n    \n    res = 0\n    # The optimal positions are centered around the median of (L_i + R_i)/2\n    # But we can also think in terms of the sum L_i + R_i\n    # The minimal total movement is sum (| (L_i + R_i) - (L_j + R_j) |) for some j\n    # The median minimizes the sum of absolute deviations\n    sums = [L + R for L, R in intervals]\n    sums.sort()\n    median = sums[N//2]\n    for s in sums:\n        res += abs(s - median)\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 15:34:48"
  }
]