[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint **grid;\nint rows, cols, capacity;\n\nint sumRegion(Point topLeft, Point bottomRight) {\n    int sum = 0;\n    for (int i = topLeft.x; i <= bottomRight.x; i++) {\n        for (int j = topLeft.y; j <= bottomRight.y; j++) {\n            sum += grid[i][j];\n        }\n    }\n    return sum;\n}\n\ntypedef struct {\n    int maxGroups;\n    int maxReserve;\n} Result;\n\nResult solve(Point topLeft, Point bottomRight) {\n    Result result = {1, capacity - sumRegion(topLeft, bottomRight)};\n    if (result.maxReserve < 0) {\n        result.maxGroups = -1;\n        return result;\n    }\n\n    int totalSum = sumRegion(topLeft, bottomRight);\n    if (totalSum <= capacity) {\n        return result;\n    }\n\n    Result best = {0, -1};\n\n    // Try vertical splits\n    for (int x = topLeft.x; x < bottomRight.x; x++) {\n        Point splitBottom = {x, bottomRight.y};\n        Point splitTop = {x + 1, topLeft.y};\n        Result left = solve(topLeft, splitBottom);\n        Result right = solve(splitTop, bottomRight);\n        if (left.maxGroups != -1 && right.maxGroups != -1) {\n            int totalGroups = left.maxGroups + right.maxGroups;\n            int minReserve = (left.maxReserve < right.maxReserve) ? left.maxReserve : right.maxReserve;\n            if (totalGroups > best.maxGroups || (totalGroups == best.maxGroups && minReserve > best.maxReserve)) {\n                best.maxGroups = totalGroups;\n                best.maxReserve = minReserve;\n            }\n        }\n    }\n\n    // Try horizontal splits\n    for (int y = topLeft.y; y < bottomRight.y; y++) {\n        Point splitBottom = {bottomRight.x, y};\n        Point splitTop = {topLeft.x, y + 1};\n        Result top = solve(topLeft, splitBottom);\n        Result bottom = solve(splitTop, bottomRight);\n        if (top.maxGroups != -1 && bottom.maxGroups != -1) {\n            int totalGroups = top.maxGroups + bottom.maxGroups;\n            int minReserve = (top.maxReserve < bottom.maxReserve) ? top.maxReserve : bottom.maxReserve;\n            if (totalGroups > best.maxGroups || (totalGroups == best.maxGroups && minReserve > best.maxReserve)) {\n                best.maxGroups = totalGroups;\n                best.maxReserve = minReserve;\n            }\n        }\n    }\n\n    if (best.maxGroups == 0) {\n        result.maxGroups = -1;\n        return result;\n    }\n    return best;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &rows, &cols, &capacity);\n    grid = (int **)malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    Point topLeft = {0, 0};\n    Point bottomRight = {rows - 1, cols - 1};\n    Result result = solve(topLeft, bottomRight);\n\n    if (result.maxGroups == -1) {\n        printf(\"No solution\\n\");\n    } else {\n        printf(\"%d %d\\n\", result.maxGroups, result.maxReserve);\n    }\n\n    for (int i = 0; i < rows; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass PowerGridOptimizer {\n    static class Area {\n        int x, y, width, height;\n        int demand;\n\n        Area(int x, int y, int width, int height, int demand) {\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n            this.demand = demand;\n        }\n    }\n\n    static class Solution {\n        List<List<Area>> groups;\n        int reservePower;\n\n        Solution(List<List<Area>> groups, int reservePower) {\n            this.groups = groups;\n            this.reservePower = reservePower;\n        }\n    }\n\n    public static Solution optimizeBlackouts(Area[][] grid, int supplyCapacity) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        return findOptimalGrouping(grid, 0, 0, rows, cols, supplyCapacity);\n    }\n\n    private static Solution findOptimalGrouping(Area[][] grid, int startX, int startY, int endX, int endY, int supplyCapacity) {\n        // Base case: single area\n        if (endX - startX <= 1 && endY - startY <= 1) {\n            List<List<Area>> singleGroup = new ArrayList<>();\n            singleGroup.add(Arrays.asList(grid[startX][startY]));\n            return new Solution(singleGroup, supplyCapacity - grid[startX][startY].demand);\n        }\n\n        Solution bestSolution = null;\n        int maxGroups = 0;\n        int maxReservePower = -1;\n\n        // Try horizontal splits\n        for (int splitX = startX + 1; splitX < endX; splitX++) {\n            Solution topSolution = findOptimalGrouping(grid, startX, startY, splitX, endY, supplyCapacity);\n            Solution bottomSolution = findOptimalGrouping(grid, splitX, startY, endX, endY, supplyCapacity);\n            Solution combinedSolution = combineSolutions(topSolution, bottomSolution, supplyCapacity);\n\n            if (updateBestSolution(bestSolution, combinedSolution, maxGroups, maxReservePower)) {\n                bestSolution = combinedSolution;\n                maxGroups = combinedSolution.groups.size();\n                maxReservePower = combinedSolution.reservePower;\n            }\n        }\n\n        // Try vertical splits\n        for (int splitY = startY + 1; splitY < endY; splitY++) {\n            Solution leftSolution = findOptimalGrouping(grid, startX, startY, endX, splitY, supplyCapacity);\n            Solution rightSolution = findOptimalGrouping(grid, startX, splitY, endX, endY, supplyCapacity);\n            Solution combinedSolution = combineSolutions(leftSolution, rightSolution, supplyCapacity);\n\n            if (updateBestSolution(bestSolution, combinedSolution, maxGroups, maxReservePower)) {\n                bestSolution = combinedSolution;\n                maxGroups = combinedSolution.groups.size();\n                maxReservePower = combinedSolution.reservePower;\n            }\n        }\n\n        return bestSolution;\n    }\n\n    private static Solution combineSolutions(Solution sol1, Solution sol2, int supplyCapacity) {\n        List<List<Area>> combinedGroups = new ArrayList<>(sol1.groups);\n        combinedGroups.addAll(sol2.groups);\n\n        int totalDemand = 0;\n        for (List<Area> group : combinedGroups) {\n            totalDemand += group.stream().mapToInt(area -> area.demand).sum();\n        }\n\n        int reservePower = supplyCapacity - totalDemand;\n        return new Solution(combinedGroups, reservePower);\n    }\n\n    private static boolean updateBestSolution(Solution currentBest, Solution candidate, int currentMaxGroups, int currentMaxReservePower) {\n        if (currentBest == null) return true;\n        if (candidate.groups.size() > currentMaxGroups) return true;\n        if (candidate.groups.size() == currentMaxGroups && candidate.reservePower > currentMaxReservePower) return true;\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 19:11:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Result {\n    int max_groups;\n    int max_reserve;\n};\n\nResult solve(int x1, int y1, int x2, int y2, const vector<vector<int>>& demand, int supply) {\n    int total = 0;\n    for (int i = x1; i < x2; ++i) {\n        for (int j = y1; j < y2; ++j) {\n            total += demand[i][j];\n        }\n    }\n    if (total <= supply) {\n        return {1, supply - total};\n    }\n\n    Result best = {0, -1};\n    for (int i = x1 + 1; i < x2; ++i) {\n        Result left = solve(x1, y1, i, y2, demand, supply);\n        Result right = solve(i, y1, x2, y2, demand, supply);\n        if (left.max_groups + right.max_groups > best.max_groups) {\n            best.max_groups = left.max_groups + right.max_groups;\n            best.max_reserve = min(left.max_reserve, right.max_reserve);\n        } else if (left.max_groups + right.max_groups == best.max_groups) {\n            best.max_reserve = max(best.max_reserve, min(left.max_reserve, right.max_reserve));\n        }\n    }\n    for (int j = y1 + 1; j < y2; ++j) {\n        Result top = solve(x1, y1, x2, j, demand, supply);\n        Result bottom = solve(x1, j, x2, y2, demand, supply);\n        if (top.max_groups + bottom.max_groups > best.max_groups) {\n            best.max_groups = top.max_groups + bottom.max_groups;\n            best.max_reserve = min(top.max_reserve, bottom.max_reserve);\n        } else if (top.max_groups + bottom.max_groups == best.max_groups) {\n            best.max_reserve = max(best.max_reserve, min(top.max_reserve, bottom.max_reserve));\n        }\n    }\n    return best;\n}\n\nint main() {\n    int rows, cols, supply;\n    cin >> rows >> cols >> supply;\n    vector<vector<int>> demand(rows, vector<int>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> demand[i][j];\n        }\n    }\n    Result result = solve(0, 0, rows, cols, demand, supply);\n    cout << result.max_groups << \" \" << result.max_reserve << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_TOWNS 100\n#define MAX_GROUPS 10\n\ntypedef struct {\n    int x, y;\n    int demand;\n} Town;\n\ntypedef struct {\n    Town towns[MAX_TOWNS];\n    int town_count;\n    int supply_capacity;\n} Area;\n\nint total_demand(Area *area, int *group_towns, int group_size) {\n    int demand = 0;\n    for (int i = 0; i < group_size; i++) {\n        demand += area->towns[group_towns[i]].demand;\n    }\n    return demand;\n}\n\nint find_best_grouping(Area *area, int *towns, int town_count, int max_groups, \n                       int *best_groups, int *best_group_sizes, int *max_reserve) {\n    if (town_count <= 1 || max_groups <= 1) {\n        memcpy(best_groups, towns, town_count * sizeof(int));\n        best_group_sizes[0] = town_count;\n        *max_reserve = area->supply_capacity - total_demand(area, towns, town_count);\n        return 1;\n    }\n\n    int best_num_groups = 1;\n    int current_reserve = 0;\n\n    for (int split = 1; split < town_count; split++) {\n        int left_towns[MAX_TOWNS], right_towns[MAX_TOWNS];\n        int left_count = split, right_count = town_count - split;\n\n        memcpy(left_towns, towns, left_count * sizeof(int));\n        memcpy(right_towns, towns + left_count, right_count * sizeof(int));\n\n        int left_groups[MAX_GROUPS], right_groups[MAX_GROUPS];\n        int left_group_sizes[MAX_GROUPS], right_group_sizes[MAX_GROUPS];\n        int left_reserve = 0, right_reserve = 0;\n\n        int left_num_groups = find_best_grouping(area, left_towns, left_count, \n                                                 max_groups/2, left_groups, \n                                                 left_group_sizes, &left_reserve);\n        int right_num_groups = find_best_grouping(area, right_towns, right_count, \n                                                  max_groups/2, right_groups, \n                                                  right_group_sizes, &right_reserve);\n\n        int total_groups = left_num_groups + right_num_groups;\n        int total_reserve = left_reserve + right_reserve;\n\n        if (total_groups > best_num_groups || \n            (total_groups == best_num_groups && total_reserve > current_reserve)) {\n            best_num_groups = total_groups;\n            current_reserve = total_reserve;\n\n            int group_index = 0;\n            for (int i = 0; i < left_num_groups; i++) {\n                for (int j = 0; j < left_group_sizes[i]; j++) {\n                    best_groups[group_index++] = left_groups[i * MAX_TOWNS + j];\n                }\n            }\n            for (int i = 0; i < right_num_groups; i++) {\n                for (int j = 0; j < right_group_sizes[i]; j++) {\n                    best_groups[group_index++] = right_groups[i * MAX_TOWNS + j];\n                }\n            }\n\n            memcpy(best_group_sizes, left_group_sizes, left_num_groups * sizeof(int));\n            memcpy(best_group_sizes + left_num_groups, right_group_sizes, \n                   right_num_groups * sizeof(int));\n        }\n    }\n\n    *max_reserve = current_reserve;\n    return best_num_groups;\n}\n\nint main() {\n    Area area;\n    int towns[MAX_TOWNS];\n    int best_groups[MAX_TOWNS];\n    int best_group_sizes[MAX_GROUPS];\n    int max_reserve;\n\n    // Input area details\n    scanf(\"%d\", &area.supply_capacity);\n    scanf(\"%d\", &area.town_count);\n\n    for (int i = 0; i < area.town_count; i++) {\n        scanf(\"%d %d %d\", &area.towns[i].x, &area.towns[i].y, &area.towns[i].demand);\n        towns[i] = i;\n    }\n\n    // Find best grouping\n    int num_groups = find_best_grouping(&area, towns, area.town_count, MAX_GROUPS, \n                                        best_groups, best_group_sizes, &max_reserve);\n\n    // Output results\n    printf(\"Number of groups: %d\\n\", num_groups);\n    printf(\"Reserve power: %d\\n\", max_reserve);\n\n    for (int i = 0; i < num_groups; i++) {\n        printf(\"Group %d: \", i+1);\n        for (int j = 0; j < best_group_sizes[i]; j++) {\n            int town_index = best_groups[j];\n            printf(\"(%d,%d) \", area.towns[town_index].x, area.towns[town_index].y);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n\nclass PowerGrid {\nprivate:\n    struct Town {\n        int demand;\n        int x, y, width, height;\n    };\n\n    struct GroupSolution {\n        std::vector<std::vector<Town>> groups;\n        int maxGroups;\n        int reservePower;\n    };\n\n    int totalSupplyCapacity;\n    std::vector<Town> towns;\n\n    GroupSolution findOptimalGrouping(std::vector<Town>& area, int supplyCapacity) {\n        if (area.empty()) return {{}, 0, 0};\n\n        GroupSolution bestSolution = {{}, 0, INT_MIN};\n\n        // Try horizontal split\n        for (int split = 1; split < area.size(); ++split) {\n            std::vector<Town> upperArea(area.begin(), area.begin() + split);\n            std::vector<Town> lowerArea(area.begin() + split, area.end());\n\n            auto upperSolution = findOptimalGrouping(upperArea, supplyCapacity);\n            auto lowerSolution = findOptimalGrouping(lowerArea, supplyCapacity);\n\n            GroupSolution currentSolution;\n            currentSolution.groups = upperSolution.groups;\n            for (auto& group : lowerSolution.groups) {\n                currentSolution.groups.push_back(group);\n            }\n            currentSolution.maxGroups = upperSolution.maxGroups + lowerSolution.maxGroups;\n\n            int totalDemand = 0;\n            for (auto& group : currentSolution.groups) {\n                int groupDemand = 0;\n                for (auto& town : group) {\n                    groupDemand += town.demand;\n                }\n                totalDemand = std::max(totalDemand, groupDemand);\n            }\n\n            currentSolution.reservePower = supplyCapacity - totalDemand;\n\n            if (currentSolution.maxGroups > bestSolution.maxGroups || \n                (currentSolution.maxGroups == bestSolution.maxGroups && \n                 currentSolution.reservePower > bestSolution.reservePower)) {\n                bestSolution = currentSolution;\n            }\n        }\n\n        // Try vertical split\n        for (int split = 1; split < area.size(); ++split) {\n            std::vector<Town> leftArea(area.begin(), area.begin() + split);\n            std::vector<Town> rightArea(area.begin() + split, area.end());\n\n            auto leftSolution = findOptimalGrouping(leftArea, supplyCapacity);\n            auto rightSolution = findOptimalGrouping(rightArea, supplyCapacity);\n\n            GroupSolution currentSolution;\n            currentSolution.groups = leftSolution.groups;\n            for (auto& group : rightSolution.groups) {\n                currentSolution.groups.push_back(group);\n            }\n            currentSolution.maxGroups = leftSolution.maxGroups + rightSolution.maxGroups;\n\n            int totalDemand = 0;\n            for (auto& group : currentSolution.groups) {\n                int groupDemand = 0;\n                for (auto& town : group) {\n                    groupDemand += town.demand;\n                }\n                totalDemand = std::max(totalDemand, groupDemand);\n            }\n\n            currentSolution.reservePower = supplyCapacity - totalDemand;\n\n            if (currentSolution.maxGroups > bestSolution.maxGroups || \n                (currentSolution.maxGroups == bestSolution.maxGroups && \n                 currentSolution.reservePower > bestSolution.reservePower)) {\n                bestSolution = currentSolution;\n            }\n        }\n\n        // Single group case\n        if (bestSolution.maxGroups == 0) {\n            bestSolution.groups = {area};\n            bestSolution.maxGroups = 1;\n\n            int totalDemand = 0;\n            for (auto& town : area) {\n                totalDemand += town.demand;\n            }\n            bestSolution.reservePower = totalSupplyCapacity - totalDemand;\n        }\n\n        return bestSolution;\n    }\n\npublic:\n    PowerGrid(int supplyCapacity, const std::vector<Town>& townList) \n        : totalSupplyCapacity(supplyCapacity), towns(townList) {}\n\n    GroupSolution planBlackouts() {\n        return findOptimalGrouping(towns, totalSupplyCapacity);\n    }\n};",
    "timestamp": "2025-08-05 19:12:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class RollingBlackout {\n\n    static class Result {\n        int maxGroups;\n        int maxReserve;\n\n        Result(int maxGroups, int maxReserve) {\n            this.maxGroups = maxGroups;\n            this.maxReserve = maxReserve;\n        }\n    }\n\n    public static List<Integer> planBlackout(int[][] grid, int supply) {\n        Result result = findOptimalSplit(grid, supply);\n        List<Integer> output = new ArrayList<>();\n        output.add(result.maxGroups);\n        output.add(result.maxReserve);\n        return output;\n    }\n\n    private static Result findOptimalSplit(int[][] grid, int supply) {\n        int totalDemand = calculateTotalDemand(grid);\n        if (totalDemand <= supply) {\n            return new Result(1, supply - totalDemand);\n        }\n\n        Result bestResult = new Result(0, -1);\n\n        // Try horizontal splits\n        for (int i = 1; i < grid.length; i++) {\n            int[][] topGrid = new int[i][grid[0].length];\n            int[][] bottomGrid = new int[grid.length - i][grid[0].length];\n\n            for (int x = 0; x < grid.length; x++) {\n                for (int y = 0; y < grid[0].length; y++) {\n                    if (x < i) {\n                        topGrid[x][y] = grid[x][y];\n                    } else {\n                        bottomGrid[x - i][y] = grid[x][y];\n                    }\n                }\n            }\n\n            Result topResult = findOptimalSplit(topGrid, supply);\n            Result bottomResult = findOptimalSplit(bottomGrid, supply);\n\n            int totalGroups = topResult.maxGroups + bottomResult.maxGroups;\n            int currentReserve = Math.min(topResult.maxReserve, bottomResult.maxReserve);\n\n            if (totalGroups > bestResult.maxGroups || \n                (totalGroups == bestResult.maxGroups && currentReserve > bestResult.maxReserve)) {\n                bestResult = new Result(totalGroups, currentReserve);\n            }\n        }\n\n        // Try vertical splits\n        for (int j = 1; j < grid[0].length; j++) {\n            int[][] leftGrid = new int[grid.length][j];\n            int[][] rightGrid = new int[grid.length][grid[0].length - j];\n\n            for (int x = 0; x < grid.length; x++) {\n                for (int y = 0; y < grid[0].length; y++) {\n                    if (y < j) {\n                        leftGrid[x][y] = grid[x][y];\n                    } else {\n                        rightGrid[x][y - j] = grid[x][y];\n                    }\n                }\n            }\n\n            Result leftResult = findOptimalSplit(leftGrid, supply);\n            Result rightResult = findOptimalSplit(rightGrid, supply);\n\n            int totalGroups = leftResult.maxGroups + rightResult.maxGroups;\n            int currentReserve = Math.min(leftResult.maxReserve, rightResult.maxReserve);\n\n            if (totalGroups > bestResult.maxGroups || \n                (totalGroups == bestResult.maxGroups && currentReserve > bestResult.maxReserve)) {\n                bestResult = new Result(totalGroups, currentReserve);\n            }\n        }\n\n        return bestResult;\n    }\n\n    private static int calculateTotalDemand(int[][] grid) {\n        int total = 0;\n        for (int[] row : grid) {\n            for (int val : row) {\n                total += val;\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int[][] grid = {{1, 2}, {3, 4}};\n        int supply = 6;\n        List<Integer> result = planBlackout(grid, supply);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 19:12:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Town:\n    def __init__(self, name, demand):\n        self.name = name\n        self.demand = demand\n\ndef calculate_demand(area):\n    return sum(town.demand for town in area)\n\ndef divide_area(area, supply_capacity):\n    if len(area) == 1:\n        return [], calculate_demand(area)\n    \n    max_groups = []\n    max_reserve_power = -1\n    \n    for split_index in range(1, len(area)):\n        left = area[:split_index]\n        right = area[split_index:]\n        \n        if calculate_demand(left) <= supply_capacity:\n            groups, reserve_power = divide_area(left, supply_capacity)\n            groups.append(left)\n            if reserve_power > max_reserve_power or (reserve_power == max_reserve_power and len(groups) > len(max_groups)):\n                max_groups = groups.copy()\n                max_reserve_power = reserve_power\n\n        if calculate_demand(right) <= supply_capacity:\n            groups, reserve_power = divide_area(right, supply_capacity)\n            groups.append(right)\n            if reserve_power > max_reserve_power or (reserve_power == max_reserve_power and len(groups) > len(max_groups)):\n                max_groups = groups.copy()\n                max_reserve_power = reserve_power\n\n    max_demand_area = max(area, key=lambda t: t.demand)\n    suppressed_demand = calculate_demand(area) - max_demand_area.demand\n    reserve_power = supply_capacity - suppressed_demand\n    return max_groups, reserve_power\n\ndef plan_rolling_blackouts(towns, supply_capacity):\n    rows_split, max_reserve_power_rows = divide_area(towns, supply_capacity)\n    cols_split, max_reserve_power_cols = divide_area(sorted(towns, key=lambda t: t.demand), supply_capacity)\n\n    if max_reserve_power_rows > max_reserve_power_cols:\n        return rows_split\n    else:\n        return cols_split\n\ntowns = [\n    Town(\"TownA\", 30),\n    Town(\"TownB\", 20),\n    Town(\"TownC\", 40),\n    Town(\"TownD\", 20),\n    Town(\"TownE\", 50)\n]\n\nsupply_capacity = 90\ngroups = plan_rolling_blackouts(towns, supply_capacity)\n\nfor group in groups:\n    print(\"Group:\")\n    for town in group:\n        print(f\"  {town.name} with demand {town.demand}\")",
    "timestamp": "2025-08-13 02:53:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class RollingBlackoutPlanner {\n    private static int[][] demands;\n    private static int supplyCapacity;\n\n    public RollingBlackoutPlanner(int[][] demands, int supplyCapacity) {\n        this.demands = demands;\n        this.supplyCapacity = supplyCapacity;\n    }\n\n    private static class Grouping {\n        int totalDemand;\n        int groups;\n        int reservePower;\n\n        Grouping(int totalDemand, int groups, int reservePower) {\n            this.totalDemand = totalDemand;\n            this.groups = groups;\n            this.reservePower = reservePower;\n        }\n    }\n\n    public static Grouping planBlackouts(int[][] area) {\n        return splitArea(area, 0, area.length, 0, area[0].length);\n    }\n\n    private static Grouping splitArea(int[][] area, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int totalDemand = calculateDemand(area, rowStart, rowEnd, colStart, colEnd);\n        if (totalDemand <= supplyCapacity) {\n            return new Grouping(totalDemand, 1, supplyCapacity - totalDemand);\n        }\n        \n        Grouping bestGrouping = new Grouping(totalDemand, 1, Integer.MIN_VALUE);\n        for (int i = rowStart + 1; i < rowEnd; i++) {\n            Grouping g1 = splitArea(area, rowStart, i, colStart, colEnd);\n            Grouping g2 = splitArea(area, i, rowEnd, colStart, colEnd);\n            Grouping combined = new Grouping(g1.totalDemand + g2.totalDemand,\n                                             g1.groups + g2.groups,\n                                             Math.max(g1.reservePower, g2.reservePower));\n            if (combined.groups > bestGrouping.groups ||\n                (combined.groups == bestGrouping.groups && combined.reservePower > bestGrouping.reservePower)) {\n                bestGrouping = combined;\n            }\n        }\n        \n        for (int j = colStart + 1; j < colEnd; j++) {\n            Grouping g1 = splitArea(area, rowStart, rowEnd, colStart, j);\n            Grouping g2 = splitArea(area, rowStart, rowEnd, j, colEnd);\n            Grouping combined = new Grouping(g1.totalDemand + g2.totalDemand,\n                                             g1.groups + g2.groups,\n                                             Math.max(g1.reservePower, g2.reservePower));\n            if (combined.groups > bestGrouping.groups ||\n                (combined.groups == bestGrouping.groups && combined.reservePower > bestGrouping.reservePower)) {\n                bestGrouping = combined;\n            }\n        }\n\n        return bestGrouping;\n    }\n\n    private static int calculateDemand(int[][] area, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int demand = 0;\n        for (int i = rowStart; i < rowEnd; i++) {\n            for (int j = colStart; j < colEnd; j++) {\n                demand += area[i][j];\n            }\n        }\n        return demand;\n    }\n\n    public static void main(String[] args) {\n        int[][] demands = {\n            {10, 20, 30},\n            {40, 50, 60},\n            {70, 80, 90}\n        };\n        int supplyCapacity = 150;\n        RollingBlackoutPlanner planner = new RollingBlackoutPlanner(demands, supplyCapacity);\n        Grouping result = planner.planBlackouts(demands);\n        System.out.println(\"Maximum number of groups: \" + result.groups);\n        System.out.println(\"Greatest reserve power: \" + result.reservePower);\n    }\n}",
    "timestamp": "2025-08-13 02:53:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Area;\n\nint **demand;\nint rows, cols, supply_capacity;\nArea best_split;\nint max_groups = 0;\nint max_reserve_power = INT_MIN;\n\nint calculate_demand(Area area) {\n    int total = 0;\n    for (int i = area.y1; i < area.y2; i++) {\n        for (int j = area.x1; j < area.x2; j++) {\n            total += demand[i][j];\n        }\n    }\n    return total;\n}\n\nvoid find_best_split(Area area, int groups, int reserve_power) {\n    if (groups > max_groups || (groups == max_groups && reserve_power > max_reserve_power)) {\n        max_groups = groups;\n        max_reserve_power = reserve_power;\n        best_split = area;\n    }\n\n    int current_demand = calculate_demand(area);\n    if (current_demand <= supply_capacity) {\n        reserve_power = supply_capacity - current_demand;\n        if (reserve_power > max_reserve_power) {\n            max_reserve_power = reserve_power;\n            best_split = area;\n        }\n    }\n\n    for (int horizontal_cut = area.y1 + 1; horizontal_cut < area.y2; horizontal_cut++) {\n        Area area1 = {area.x1, area.y1, area.x2, horizontal_cut};\n        Area area2 = {area.x1, horizontal_cut, area.x2, area.y2};\n        find_best_split(area1, groups + 1, reserve_power);\n        find_best_split(area2, groups + 1, reserve_power);\n    }\n\n    for (int vertical_cut = area.x1 + 1; vertical_cut < area.x2; vertical_cut++) {\n        Area area1 = {area.x1, area.y1, vertical_cut, area.y2};\n        Area area2 = {vertical_cut, area.y1, area.x2, area.y2};\n        find_best_split(area1, groups + 1, reserve_power);\n        find_best_split(area2, groups + 1, reserve_power);\n    }\n}\n\nint main() {\n    // Initialize demand data here with rows x cols matrix\n    // and supply_capacity value\n    // Example initialization:\n    // rows = N;\n    // cols = M;\n    // demand = (int **)malloc(rows * sizeof(int *));\n    // for (int i = 0; i < rows; i++) {\n    //     demand[i] = (int *)malloc(cols * sizeof(int));\n    //     for (int j = 0; j < cols; j++) {\n    //         demand[i][j] = ...; // insert real demand value\n    //     }\n    // }\n    // supply_capacity = ...; // set real supply capacity\n\n    Area initial_area = {0, 0, cols, rows};\n    find_best_split(initial_area, 0, 0);\n\n    printf(\"Maximum groups: %d\\n\", max_groups);\n    printf(\"Maximum reserve power: %d\\n\", max_reserve_power);\n    printf(\"Best Area Split: (%d, %d) to (%d, %d)\\n\",\n           best_split.x1, best_split.y1, best_split.x2, best_split.y2);\n\n    // Free dynamically allocated memory\n    for (int i = 0; i < rows; i++) {\n        free(demand[i]);\n    }\n    free(demand);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:53:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom typing import List, Tuple\n\nclass PowerGridPlanner:\n    def __init__(self, grid: np.ndarray, supply_capacity: float):\n        self.grid = grid\n        self.supply_capacity = supply_capacity\n        self.best_groups = []\n        self.max_groups = 0\n        self.max_reserve = float('-inf')\n\n    def calculate_demand(self, subgrid: np.ndarray) -> float:\n        return np.sum(subgrid)\n\n    def recursive_split(self, grid: np.ndarray, num_groups: int):\n        def horizontal_split(area):\n            for row in range(1, area.shape[0]):\n                top = area[:row, :]\n                bottom = area[row:, :]\n                return top, bottom\n\n        def vertical_split(area):\n            for col in range(1, area.shape[1]):\n                left = area[:, :col]\n                right = area[:, col:]\n                return left, right\n\n        def validate_groups(groups):\n            demands = [self.calculate_demand(group) for group in groups]\n            max_demand = max(demands)\n            suppressed_demand = max_demand if max_demand > self.supply_capacity else 0\n            reserve = self.supply_capacity - suppressed_demand\n\n            if suppressed_demand == 0 and len(groups) > self.max_groups:\n                self.max_groups = len(groups)\n                self.best_groups = groups\n                self.max_reserve = reserve\n            elif len(groups) == self.max_groups and reserve > self.max_reserve:\n                self.best_groups = groups\n                self.max_reserve = reserve\n\n        def backtrack(area, current_groups):\n            if len(current_groups) >= num_groups:\n                validate_groups(current_groups)\n                return\n\n            # Try horizontal split\n            horizontal_splits = horizontal_split(area)\n            if horizontal_splits:\n                top, bottom = horizontal_splits\n                backtrack(top, current_groups + [top])\n                backtrack(bottom, current_groups + [bottom])\n\n            # Try vertical split\n            vertical_splits = vertical_split(area)\n            if vertical_splits:\n                left, right = vertical_splits\n                backtrack(left, current_groups + [left])\n                backtrack(right, current_groups + [right])\n\n        backtrack(grid, [])\n\n    def plan_blackouts(self) -> List[np.ndarray]:\n        for groups in range(2, self.grid.shape[0] * self.grid.shape[1] + 1):\n            self.recursive_split(self.grid, groups)\n            if self.best_groups:\n                return self.best_groups\n\n        return []\n\n# Example usage\ngrid = np.array([\n    [10, 15, 20],\n    [5, 12, 8],\n    [7, 9, 6]\n])\nsupply_capacity = 50\n\nplanner = PowerGridPlanner(grid, supply_capacity)\nblackout_groups = planner.plan_blackouts()",
    "timestamp": "2025-08-13 02:53:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_blackout_groups(grid, supply_capacity):\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    prefix = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        row_sum = 0\n        for j in range(1, cols + 1):\n            row_sum += grid[i-1][j-1]\n            prefix[i][j] = prefix[i-1][j] + row_sum\n    \n    memo = {}\n    \n    def dfs(x1, y1, x2, y2):\n        if (x1, y1, x2, y2) in memo:\n            return memo[(x1, y1, x2, y2)]\n        total = prefix[x2][y2] - prefix[x1][y2] - prefix[x2][y1] + prefix[x1][y1]\n        if total <= supply_capacity:\n            memo[(x1, y1, x2, y2)] = (1, supply_capacity - total)\n            return (1, supply_capacity - total)\n        \n        max_groups = 0\n        max_reserve = -1\n        \n        # Try horizontal splits\n        for x in range(x1 + 1, x2):\n            left_groups, left_reserve = dfs(x1, y1, x, y2)\n            right_groups, right_reserve = dfs(x, y1, x2, y2)\n            total_groups = left_groups + right_groups\n            current_reserve = min(left_reserve, right_reserve)\n            if total_groups > max_groups:\n                max_groups = total_groups\n                max_reserve = current_reserve\n            elif total_groups == max_groups and current_reserve > max_reserve:\n                max_reserve = current_reserve\n        \n        # Try vertical splits\n        for y in range(y1 + 1, y2):\n            top_groups, top_reserve = dfs(x1, y1, x2, y)\n            bottom_groups, bottom_reserve = dfs(x1, y, x2, y2)\n            total_groups = top_groups + bottom_groups\n            current_reserve = min(top_reserve, bottom_reserve)\n            if total_groups > max_groups:\n                max_groups = total_groups\n                max_reserve = current_reserve\n            elif total_groups == max_groups and current_reserve > max_reserve:\n                max_reserve = current_reserve\n        \n        memo[(x1, y1, x2, y2)] = (max_groups, max_reserve)\n        return (max_groups, max_reserve)\n    \n    total_groups, reserve = dfs(0, 0, rows, cols)\n    return total_groups",
    "timestamp": "2025-08-13 02:54:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Town {\n    int x1, y1, x2, y2, demand;\n};\n\nbool compareReserve(const pair<int, vector<Town>>& a, const pair<int, vector<Town>>& b) {\n    if (a.second.size() != b.second.size()) {\n        return a.second.size() > b.second.size();\n    }\n    return a.first > b.first;\n}\n\npair<int, vector<Town>> maxReserve(int left, int right, int top, int bottom, const vector<Town>& towns, int capacity) {\n    int totalDemand = 0;\n    for (const auto& town : towns) {\n        totalDemand += town.demand;\n    }\n    \n    if (totalDemand <= capacity) {\n        return {capacity - totalDemand, towns};\n    }\n\n    pair<int, vector<Town>> best = {INT_MIN, {}};\n\n    for (int i = top; i < bottom; ++i) {\n        vector<Town> topGroup, bottomGroup;\n        for (const auto& town : towns) {\n            if (town.y2 <= i) topGroup.push_back(town);\n            else if (town.y1 > i) bottomGroup.push_back(town);\n            else return best;\n        }\n        auto topResult = maxReserve(left, right, top, i, topGroup, capacity);\n        auto bottomResult = maxReserve(left, right, i + 1, bottom, bottomGroup, capacity);\n        \n        if (!topResult.second.empty()) {\n            auto result = topResult;\n            result.first = min(result.first, bottomResult.first);\n            result.second.insert(result.second.end(), bottomResult.second.begin(), bottomResult.second.end());\n            best = max(best, result, compareReserve);\n        }\n        if (!bottomResult.second.empty()) {\n            auto result = bottomResult;\n            result.first = min(result.first, topResult.first);\n            result.second.insert(result.second.end(), topResult.second.begin(), topResult.second.end());\n            best = max(best, result, compareReserve);\n        }\n    }\n\n    for (int j = left; j < right; ++j) {\n        vector<Town> leftGroup, rightGroup;\n        for (const auto& town : towns) {\n            if (town.x2 <= j) leftGroup.push_back(town);\n            else if (town.x1 > j) rightGroup.push_back(town);\n            else return best;\n        }\n        auto leftResult = maxReserve(left, j, top, bottom, leftGroup, capacity);\n        auto rightResult = maxReserve(j + 1, right, top, bottom, rightGroup, capacity);\n\n        if (!leftResult.second.empty()) {\n            auto result = leftResult;\n            result.first = min(result.first, rightResult.first);\n            result.second.insert(result.second.end(), rightResult.second.begin(), rightResult.second.end());\n            best = max(best, result, compareReserve);\n        }\n        if (!rightResult.second.empty()) {\n            auto result = rightResult;\n            result.first = min(result.first, leftResult.first);\n            result.second.insert(result.second.end(), leftResult.second.begin(), leftResult.second.end());\n            best = max(best, result, compareReserve);\n        }\n    }\n\n    return best;\n}\n\nint main() {\n    int n, capacity;\n    cin >> n >> capacity;\n    vector<Town> towns(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> towns[i].x1 >> towns[i].y1 >> towns[i].x2 >> towns[i].y2 >> towns[i].demand;\n    }\n    \n    auto result = maxReserve(0, 100, 0, 100, towns, capacity);\n    \n    cout << \"Maximum Reserve Power: \" << result.first << endl;\n    cout << \"Number of Groups: \" << result.second.size() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:08:14"
  }
]