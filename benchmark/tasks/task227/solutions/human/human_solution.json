[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define DBG_N(hoge) cerr<<\" \"<<(hoge)<<endl;\n#define DBG cerr<<\"!\"<<endl;\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\nll h,w,s;\nll sum;\nll num[40][40];\npair<ll,ll> memo[40][40][40][40];\nconst int MAX_N = 50;\nint row,col;\nll rui[MAX_N][MAX_N];\nvoid make_sum(){\n  row = h;\n  col = w;\n  for(int i=1;i<=row+1;i++)\n    for(int j=1;j<=col+1;j++)\n      rui[i][j] = num[i][j] + rui[i-1][j] + rui[i][j-1] - rui[i-1][j-1];\n}\n\nll get_sum(int lx,int ly,int rx,int ry){//閉区間\n  if(lx>rx||ly>ry)return 0;\n  else return rui[rx][ry] - rui[lx-1][ry] - rui[rx][ly-1] + rui[lx-1][ly-1]; \n}\n\n//kosuu,\npair<ll,ll> dfs(int lx,int ly,int rx,int ry){\n\n  if(memo[lx][ly][rx][ry].F>=0)return memo[lx][ly][rx][ry];\n  if(s-(sum-get_sum(lx+1,ly+1,rx+1,ry+1)) < 0)return mp(0,0);\n\n  memo[lx][ly][rx][ry] = mp(1,s-(sum-get_sum(lx+1,ly+1,rx+1,ry+1)));\n\n  for(int i=ly;i<ry;i++){\n    pair<ll,ll>p1 = dfs(lx,i+1,rx,ry);\n    pair<ll,ll>p2 = dfs(lx,ly,rx,i);\n\n    if(p1.F+p2.F > memo[lx][ly][rx][ry].F){\n      memo[lx][ly][rx][ry] = mp(p1.F+p2.F,min(p1.S,p2.S));\n    }else if(p1.F+p2.F == memo[lx][ly][rx][ry].F){\n      memo[lx][ly][rx][ry] = mp(p1.F+p2.F,max(memo[lx][ly][rx][ry].S, min(p1.S,p2.S)));\n    }\n  }\n\n  for(int i=lx;i<rx;i++){\n    pair<ll,ll>p1 = dfs(lx,ly,i,ry);\n    pair<ll,ll>p2 = dfs(i+1,ly,rx,ry);\n\n    if(p1.F+p2.F > memo[lx][ly][rx][ry].F){\n      memo[lx][ly][rx][ry] = mp(p1.F+p2.F,min(p1.S,p2.S));\n    }else if(p1.F+p2.F == memo[lx][ly][rx][ry].F){\n      memo[lx][ly][rx][ry] = mp(p1.F+p2.F,max(memo[lx][ly][rx][ry].S,min(p1.S,p2.S)));\n    }\n  }\n\n  return memo[lx][ly][rx][ry];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin>>h>>w>>s,h+w+s){\n    sum = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>num[i+1][j+1];\n\tsum+=num[i+1][j+1];\n\t//\tcout<<i<<\" \"<<j<<endl;\n      }\n    }\n    for(int i=0;i<40;i++){\n      for(int j=0;j<40;j++){\n\trui[i][j]=0;\n\tfor(int k=0;k<40;k++){\n\t  for(int l=0;l<40;l++){\n\t    memo[i][j][k][l] = mp(-1,llINF);\n\t  }\n\t}\n      }\n    }\n\t\n    make_sum();\n\n    pair<ll,ll>ans = dfs(0,0,h-1,w-1);\n    cout<<ans.F<<\" \"<<ans.S<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nvector<vector<vector<vector<pair<int,int>>>>> dp;\nvector<vector<vector<vector<bool>>>> flag;\n\npair<int,int> f(int sx, int sy, int ex, int ey){\n    if(flag[sx][sy][ex][ey])\n        return dp[sx][sy][ex][ey];\n    for(int i = sx + 1; i < ex; ++i){\n        auto p1 = f(sx, sy, i, ey);\n        auto p2 = f(i, sy, ex, ey);\n        if(p1.second < 0 || p2.second < 0)\n            continue;\n        chmax(dp[sx][sy][ex][ey], make_pair(p1.first + p2.first, min(p1.second, p2.second)));\n    }\n    for(int j = sy + 1; j < ey; ++j){\n        auto p1 = f(sx, sy, ex, j);\n        auto p2 = f(sx, j, ex, ey);\n        if(p1.second < 0 || p2.second < 0)\n            continue;\n        chmax(dp[sx][sy][ex][ey], make_pair(p1.first + p2.first, min(p1.second, p2.second)));\n    }\n    flag[sx][sy][ex][ey] = true;\n    return dp[sx][sy][ex][ey];\n}\n\nbool solve(){\n    int h, w, s;\n    cin >> h >> w >> s;\n    if(!h)\n        return false;\n    vector<vector<int>> v(h, vector<int>(w));\n    int sum = 0;\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j){\n            cin >> v[i][j];\n            sum += v[i][j];\n        }\n    dp.assign(h, vector<vector<vector<pair<int,int>>>>(w, vector<vector<pair<int,int>>>(h + 1, vector<pair<int,int>>(w + 1, make_pair(-MOD, -MOD)))));\n    flag.assign(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h + 1, vector<bool>(w + 1, false))));\n\n    vector<vector<int>> cumsum(h + 1, vector<int>(w + 1, 0));\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j)\n            cumsum[i + 1][j + 1] = v[i][j];\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j <= w; ++j)\n            cumsum[i + 1][j] += cumsum[i][j];\n    for(int i = 0; i <= h; ++i)\n        for(int j = 0; j < w; ++j)\n            cumsum[i][j + 1] += cumsum[i][j];\n\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j)\n            for(int k = i + 1; k <= h; ++k)\n                for(int l = j + 1; l <= w; ++l){\n                    int psum = cumsum[i][j] + cumsum[k][l] - cumsum[i][l] - cumsum[k][j];\n                    if(sum - psum <= s)\n                        dp[i][j][k][l] = make_pair(1, s - (sum - psum));\n                }\n    auto res = f(0, 0, h, w);\n    cout << res.first << \" \" << res.second << endl;\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e8;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nstruct DP {\n  int g, v;\n\n  DP(int g = 0, int v = 0): g(g), v(v) {}\n\n  DP operator + (DP& dp) {\n    return {g + dp.g, min(v, dp.v)};\n  }\n\n  bool operator < (const DP& dp) const {\n    return g != dp.g ? g < dp.g : v < dp.v;\n  }\n};\n\nint h, w, s;\nint u[40][40];\n\nint sum[40][40];\nDP dp[40][40][40][40];\n\nvoid init() {\n  memset(sum, 0, sizeof(sum));\n  rep(i, h) {\n    rep(j, w) {\n      sum[i + 1][j + 1] = u[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i][j];\n      //cout << sum[i + 1][j + 1] << ' ';\n    }\n    //cout << '\\n';\n  }\n  s = sum[h][w] - s;\n  rep(i, 40) rep(j, 40) rep(k, 40) rep(l, 40) dp[i][j][k][l] = {0, 0};\n}\n\nvoid solve() {\n  FOR(dh, 1, h + 1) {\n    FOR(dw, 1, w + 1) {\n      rep(u, h - dh + 1) {\n        int d = u + dh;\n        rep(l, w - dw + 1) {\n          int r = l + dw;\n          if (sum[d][r] - sum[u][r] - sum[d][l] + sum[u][l] < s) continue;\n          DP res = {1, sum[d][r] - sum[u][r] - sum[d][l] + sum[u][l] - s};\n          FOR(i, u + 1, d) {\n            DP nxt = dp[u][i][l][r] + dp[i][d][l][r];\n            res = max(res, nxt);\n          }\n          FOR(j, l + 1, r) {\n            DP nxt = dp[u][d][l][j] + dp[u][d][j][r];\n            res = max(res, nxt);\n          }\n          //cout << u << ' ' << d << ' ' << l << ' ' << r << '\\n';\n          dp[u][d][l][r] = res;\n          //cout << res.g << ' ' << res.v << '\\n';\n        }\n      }\n    }\n  }\n  DP ans = dp[0][h][0][w];\n  cout << ans.g << ' ' << ans.v << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (1) {\n    cin >> h >> w >> s;\n    if (h == 0 && w == 0 && s == 0) return 0;\n    rep(i, h) rep(j, w) cin >> u[i][j];\n\n    init();\n    solve();\n  }\n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define num first\n#define energy second\n#define INF (1<<16)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint cum[64][64];\nint H,W,S,sum;\nP dp[40][40][40][40];\n\nint count(int y1,int x1,int y2,int x2){\n  return cum[y2-1][x2-1] - cum[y2-1][x1-1] - cum[y1-1][x2-1] + cum[y1-1][x1-1];\n}\n\nP dfs(int x1, int y1, int x2, int y2){\n  if(~dp[x1][y1][x2][y2].num) return dp[x1][y1][x2][y2];\n  if(cum[H][W] - count(x1,y1,x2,y2) > S) return MP(-INF, INF);\n  P res = P(1, S-(cum[H][W]-count(x1,y1,x2,y2)));\n  for(int i=x1+1;i<x2;i++){\n    P a = dfs(x1, y1, i, y2);\n    P b = dfs(i, y1, x2, y2);\n    P c = P(a.num+b.num, min(a.energy, b.energy));\n    res = max(res, c);\n  }\n  for(int i=y1+1;i<y2;i++){\n    P a = dfs(x1, y1, x2, i);\n    P b = dfs(x1, i, x2, y2);\n    P c = P(a.num+b.num, min(a.energy, b.energy));\n    res = max(res, c);\n  }\n  return dp[x1][y1][x2][y2] = res;\n}\n\n\nint main(){\n  while(scanf(\"%d%d%d\",&H,&W,&S) && H||W||S){\n    memset(cum, 0, sizeof(cum));\n    rep(i,40) rep(j,40) rep(k,40) rep(l,40) dp[i][j][k][l] = MP(-1,-1);\n    rep(i,H) rep(j,W) scanf(\"%d\", &cum[i+1][j+1]);\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cum[i][j] += cum[i][j-1];\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cum[i][j] += cum[i-1][j];\n    sum = cum[H][W];\n\n    P res = dfs(1,1,W+1,H+1);\n    printf(\"%d %d\\n\", res.first, res.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1000000 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = (resl + resr) / 1000000 * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = (resl + resr) / 1000000 * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << ret / 1000000 << ' ' << ret % 1000000 - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\nint H,W,S,x[40][40];\npair<int,int> dp[40][40][40][40];\nvector<tuple<int,int,int,int,int> >vec;\nint getsum(int ax,int ay,int bx,int by){\n\tint v=0;\n\tfor(int i=ax;i<=bx;i++){\n\t\tfor(int j=ay;j<=by;j++){\n\t\t\tv+=x[i][j];\n\t\t}\n\t}\n\treturn v;\n}\nvoid init(){\n\tfor(int i=0;i<1600;i++){\n\t\tfor(int j=0;j<1600;j++){\n\t\t\tdp[i/40][i%40][j/40][j%40]=make_pair(0,0);\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W>>S;int sum=0;\n\t\tinit();if(H==0 && W==0 && S==0)break;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>x[i][j];sum+=x[i][j];\n\t\t\t}\n\t\t}\n\t\tsum=sum-S;vec.clear();\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int k=i;k<H;k++){\n\t\t\t\t\tfor(int l=j;l<W;l++){\n\t\t\t\t\t\tint area=(k-i+1)*(l-j+1);\n\t\t\t\t\t\tint W=getsum(i,j,k,l);\n\t\t\t\t\t\tif(W<sum)continue;\n\t\t\t\t\t\tdp[i][j][k][l]=make_pair(1,W-sum);\n\t\t\t\t\t\tvec.push_back(make_tuple(area,i,j,k,l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\tfor(int i=0;i<(int)vec.size();i++){\n\t\t\tint lx=get<1>(vec[i]),ly=get<2>(vec[i]);\n\t\t\tint rx=get<3>(vec[i]),ry=get<4>(vec[i]);\n\t\t\tfor(int j=lx;j<rx;j++){\n\t\t\t\tpair<int,int>J1=dp[lx][ly][j][ry];\n\t\t\t\tpair<int,int>J2=dp[j+1][ly][rx][ry];\n\t\t\t\tif(dp[lx][ly][rx][ry].first<J1.first+J2.first){\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t\telse if(dp[lx][ly][rx][ry].first==J1.first+J2.first){\n\t\t\t\t\tif(dp[lx][ly][rx][ry].second>min(J1.second,J2.second))continue;\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=ly;j<ry;j++){\n\t\t\t\tpair<int,int>J1=dp[lx][ly][rx][j];\n\t\t\t\tpair<int,int>J2=dp[lx][j+1][rx][ry];\n\t\t\t\tif(dp[lx][ly][rx][ry].first<J1.first+J2.first){\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t\telse if(dp[lx][ly][rx][ry].first==J1.first+J2.first){\n\t\t\t\t\tif(dp[lx][ly][rx][ry].second>min(J1.second,J2.second))continue;\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][0][H-1][W-1].first<<' '<<dp[0][0][H-1][W-1].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1<<28)\ninline void cmax(int &a, int b) { if (a < b) a = b; }\n\nint n, m, S, f[32][32], _sum[32][32];\n\ninline int sum(int x1, int y1, int x2, int y2) {\n    return _sum[x2+1][y2+1]-_sum[x2+1][y1]-_sum[x1][y2+1]+_sum[x1][y1];\n}\n\nint dp[32][32][32][32];\n\nint solve(int lb) {\n    for (int w = 0; w < n; w++) rep (x1, n-w) {\n        const int x2 = x1+w;\n        for (int h = 0; h < m; h++) rep (y1, m-h) {\n            const int y2 = y1+h;\n            if (sum(x1, y1, x2, y2) < lb) {\n                dp[x1][x2][y1][y2] = -INF;\n                continue;\n            }\n            dp[x1][x2][y1][y2] = 1;\n            for (int i = x1; i < x2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][i][y1][y2]+dp[i+1][x2][y1][y2]);\n            }\n            for (int i = y1; i < y2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][x2][y1][i]+dp[x1][x2][i+1][y2]);\n            }\n        }\n    }\n    return dp[0][n-1][0][m-1];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &n, &m, &S);\n        if (n == 0) return 0;\n        rep (i, n) rep (j, m) scanf(\"%d\", f[i]+j);\n        rep (i, n) rep (j, m) {\n            _sum[i+1][j+1] = f[i][j]+_sum[i+1][j]+_sum[i][j+1]-_sum[i][j];\n        }\n        const int tot = sum(0, 0, n-1, m-1);\n        const int ans = solve(tot-S);\n        int l = 0, r = 120;\n        while (r-l>1) {\n            const int mid = (l+r) / 2;\n            if (solve(tot-S+mid) >= ans) l = mid;\n            else r = mid;\n        }\n        printf(\"%d %d\\n\", ans, l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define range(i, l, r) for (int i = l; i < r; i += 1)\n\npair< int, int > dp[33][33][33][33];\n\nvoid solver(int h, int w, int s) {\n    vector< vector< int > > u(h + 1, vector< int >(w + 1, 0));\n    for (int i = 1; i <= h; ++i) for (int j = 1; j <= w; ++j) {\n        cin >> u[i][j];\n        u[i][j] += u[i - 1][j] + u[i][j - 1] - u[i - 1][j - 1];\n    }\n\n    range(a, 0, h + 1) range(b, 0, h + 1) {\n        range(c, 0, w + 1) range(d, 0, w + 1) {\n            dp[a][b][c][d] = make_pair(0, 0);\n        }\n    }\n\n    pair< int, int > none(0, 0);\n    range(dh, 1, h + 1) range(dw, 1, w + 1) {\n        range(i, dh, h + 1) range(j, dw, w + 1) {\n            int a = i - dh, c = j - dw;\n            int b = i,      d = j;\n\n            range(mi, a + 1, b) {\n                pair< int, int > l = dp[a][mi][c][d], r = dp[mi][b][c][d];\n                if (l == none || r == none) continue;\n                pair< int, int > nxt(l.first + r.first, min(l.second, r.second));\n                dp[a][b][c][d] = max(dp[a][b][c][d], nxt);\n            }\n\n            range(mj, c + 1, d) {\n                pair< int, int > l = dp[a][b][c][mj], r = dp[a][b][mj][d];\n                if (l == none || r == none) continue;\n                pair< int, int > nxt(l.first + r.first, min(l.second, r.second));\n                dp[a][b][c][d] = max(dp[a][b][c][d], nxt);\n            }\n\n            if (dp[a][b][c][d] == none) {\n                int now = u[a][c] + u[b][d] - u[b][c] - u[a][d];\n\n                if (now >= u[h][w] - s) {\n                    dp[a][b][c][d] = make_pair(1, now);\n                }\n            }\n        }\n    }\n\n    auto ans = dp[0][h][0][w];\n\n    cout << ans.first << \" \" << s + ans.second - u[h][w] << endl;\n}\n\nint main() {\n    int h, w, s;\n\n    while (cin >> h >> w >> s, h && w && s) {\n        solver(h, w, s);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint mp[35][35],smp[35][35],n,SUM,W,H;\nP mem[35][35][35][35];\nint used[35][35][35][35];\n\nint cal(int x1,int y1,int x2,int y2){\n  return smp[y2][x2]-(smp[y1-1][x2]+smp[y2][x1-1])+smp[y1-1][x1-1];\n}\n\nP dfs(int x,int y,int w,int h){\n  \n  if(used[x][y][w][h]++) return mem[x][y][w][h];\n\n  P res=P(1,n-(SUM-cal(x,y,w,h)));\n  for(int i=x;i!=w;i++){\n    int m=max(SUM-cal(x,y,i,h),SUM-cal(i+1,y,w,h));\n    if(m<=n){\n      P a=dfs(x,y,i,h);\n      P b=dfs(i+1,y,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n\n  for(int i=y;i!=h;i++){\n    int m=max(SUM-cal(x,y,w,i),SUM-cal(x,i+1,w,h));\n    if(m<=n){\n      P a=dfs(x,y,w,i);\n      P b=dfs(x,i+1,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n  return mem[x][y][w][h]=res;\n}\n\nint main(){\n  while(1){\n  cin>>H>>W>>n;\n  if(!H&&!W&&!n)break;\n\n  memset(mp,0,sizeof(mp));\n  memset(smp,0,sizeof(smp));\n  memset(used,0,sizeof(used));\n  memset(mem,0,sizeof(mem));\n\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)cin>>mp[i][j],smp[i][j]=mp[i][j];\n\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i][j+1]+=smp[i][j];\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i+1][j]+=smp[i][j];\n  SUM=smp[H][W];\n  P ans=dfs(1,1,W,H);\n  cout <<ans.first<<\" \"<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint h, w, s, all;\nint town[32][32];\nP dp[1024][1024];\n\nvoid dfs(P lu, P rd) {\n  int p = lu.fi + lu.se * w, q = rd.fi + rd.se * w;\n\n  if (dp[p][q] != P(0, -INF)) return;\n\n  int sum = 0;\n  repl(i, lu.se, rd.se + 1) {\n    repl(j, lu.fi, rd.fi + 1) {\n      sum += town[i][j];\n    }\n  }\n  int maxi = max(sum, all - sum);\n  if (s >= maxi) dp[p][q] = P(1, s - maxi);\n  if ((s - all) * 2 <= sum) {\n    repl(i, lu.se, rd.se) {\n      int pp = lu.fi + (i + 1) * w, qq = rd.fi + i * w;\n      dfs(lu, P(rd.fi, i));\n      dfs(P(lu.fi, i + 1), rd);\n      maxch(dp[p][q], P(dp[p][qq].fi + dp[pp][q].fi, min(dp[p][qq].se, dp[pp][q].se)));\n    }\n    repl(i, lu.fi, rd.fi) {\n      int pp = i + 1 + lu.se * w, qq = i + rd.se * w;\n      dfs(lu, P(i, rd.se));\n      dfs(P(i + 1, lu.se), rd);\n      maxch(dp[p][q], P(dp[p][qq].fi + dp[pp][q].fi, min(dp[p][qq].se, dp[pp][q].se)));\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> h >> w >> s, h | w | s) {\n    all = 0;\n    rep(i, h)rep(j, w) {\n      cin >> town[i][j];\n      all += town[i][j];\n    }\n\n    rep(i, h * w)rep(j, h * w) dp[i][j] = P(0, -INF);\n    dfs(P(0, 0), P(w - 1, h - 1));\n\n    cout << dp[0][h * w - 1].fi << \" \" << dp[0][h * w - 1].se << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1048576 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", (ret >> 20), ((ret - o) & 1048575));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n#define F first\n#define S second\nP dp[33][33][33][33];\nint h,w,s,sum[33][33],a[33][33],SUM;\nvoid dpp(){\n  r(i,33)r(j,33)r(k,33)r(l,33)dp[i][j][k][l]=P(0,1e9);\n  memset(sum,0,sizeof(sum));\n  r(i,h)r(j,w)sum[i+1][j+1]=a[i][j];\n  r(i,h+1)r(j,w)sum[i][j+1]+=sum[i][j];\n  r(j,w+1)r(i,h)sum[i+1][j]+=sum[i][j];\n}\nint get(int ly,int lx,int ry,int rx){\n  return sum[ry+1][rx+1]-sum[ry+1][ly]-sum[ly][rx+1]+sum[ly][lx];\n}\nP dfs(int ly,int lx,int ry,int rx){\n  if(dp[ly][lx][ry][rx]!=P(0,1e9))return dp[ly][lx][ry][rx];\n  P res=P(1,SUM-get(ly,lx,ry,rx));//cout<<get(ly,lx,ry,rx)<<endl;\n  for(int i=lx;i<rx;i++){\n    if(s-(SUM-get(ly,lx,ry,i))<0)continue;\n    if(s-(SUM-get(ly,i+1,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,ry,i),res2=dfs(ly,i+1,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  for(int i=ly;i<ry;i++){\n    if(s-(SUM-get(ly,lx,i,rx))<0)continue;\n    if(s-(SUM-get(i+1,lx,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,i,rx),res2=dfs(i+1,lx,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  return dp[ly][lx][ry][rx]=res;\n}\n\nint main(){\n  while(cin>>h>>w>>s,s){\n    SUM=0;\n    r(i,h)r(j,w)cin>>a[i][j],SUM+=a[i][j];\n    dpp();\n    P p=dfs(0,0,h-1,w-1);\n    cout<<p.F<<' '<<p.S<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint p[35][35];\nint memo[33][33][33][33];\nint M = 1000000007;\n\n//[l, r), [u, d)\n// max bunkatu\nint dfs(int l, int r, int u, int d, int mi) {\n    if (memo[l][r][u][d] != -1) return memo[l][r][u][d];\n    int sum = 0;\n    for (int i = l; i < r; ++i) {\n        for (int j = u; j < d; ++j) {\n            sum += p[i][j];\n        }\n    }\n    if (sum < mi) {\n        return memo[l][r][u][d] = -M;\n    }\n    int ret = 1;\n    for (int i = l + 1; i < r; ++i) {\n        ret = max(ret, dfs(l, i, u, d, mi) + dfs(i, r, u, d, mi));\n    }\n    for (int i = u + 1; i < d; ++i) {\n        ret = max(ret, dfs(l, r, u, i, mi) + dfs(l, r, i, d, mi));\n    }\n    return memo[l][r][u][d] = ret;\n}\nint main() {\n    while (1) {\n        int h, w, s;\n        cin >> h >> w >> s;\n        if (!h) return 0;\n        int sum = 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> p[i][j];\n                sum += p[i][j];\n            }\n        }\n        for (int i = 0; i < 33; ++i) {\n            for (int j = 0; j < 33; ++j) {\n                for (int k = 0; k < 33; ++k) {\n                    for (int l = 0; l < 33; ++l) {\n                        memo[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n        int ma = dfs(0, h, 0, w, sum - s);\n        int ok = sum - s, ng = sum + 1;\n        while (ok + 1 < ng) {\n            int m = (ok + ng) / 2;\n            for (int i = 0; i < 33; ++i) {\n                for (int j = 0; j < 33; ++j) {\n                    for (int k = 0; k < 33; ++k) {\n                        for (int l = 0; l < 33; ++l) {\n                            memo[i][j][k][l] = -1;\n                        }\n                    }\n                }\n            }\n            if (dfs(0, h, 0, w, m) == ma) {\n                ok = m;\n            }\n            else {\n                ng = m;\n            }\n        }\n        cout << ma << \" \" << (s- sum + ok) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAX_Y = 32+1;\nconst int MAX_X = 32+1;\n\n#define MAX MAX_Y\n#define INF (1<<28)\n\nint bit[MAX_Y][MAX_X];\n\nvoid update(int x, int y, int v)\n{\n\t++x; ++y;\n\tint j = y;\n\twhile (j <= MAX_Y) {\n\t\tint i = x;\n\t\twhile (i <= MAX_X) {\n\t\t\tbit[j][i] += v;\n\t\t\ti += i & -i;\n\t\t}\n\n\t\tj += j & -j;\n\t}\n}\n\nint sum(int x, int y)\n{\n\tint ans = 0;\n\n\t++x; ++y;\n\tint j = y;\n\twhile (j > 0) {\n\t\tint i = x;\n\t\twhile (i > 0) {\n\t\t\tans += bit[j][i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\tj -= j & -j;\n\t}\n\n\treturn ans;\n}\n\nint range_sum(int x1, int y1, int x2, int y2)\n{\n\treturn sum(x2, y2) - sum(x2, y1-1) - sum(x1-1, y2) + sum(x1-1, y1-1);\n}\n\nint h, w, s;\nint required;\n\nint all;\n\nbool memo[MAX][MAX][MAX][MAX];\npii ret[MAX][MAX][MAX][MAX];\n\nbool ok(int x1, int y1, int x2, int y2)\n{\n\treturn range_sum(x1, y1, x2, y2) >= required;\n}\n\npii dfs(int x1, int y1, int x2, int y2)\n{\n\tif (memo[x1][y1][x2][y2])\n\t\treturn ret[x1][y1][x2][y2];\n\tif (!ok(x1, y1, x2, y2)) {\n\t\tmemo[x1][y1][x2][y2] = true;\n\t\treturn ret[x1][y1][x2][y2] = pii(-INF, INF);\n\t}\n\n\tpii ans = pii(1, range_sum(x1, y1, x2, y2));\n\tREP(i, x1, x2) {\n\t\tpii r1, r2;\n\t\tr1 = dfs(x1, y1, i, y2);\n\t\tr2 = dfs(i+1, y1, x2, y2);\n\t\tans = max(ans, pii(r1.first+r2.first, min(r1.second, r2.second)));\n\t}\n\tREP(j, y1, y2) {\n\t\tpii r1, r2;\n\t\tr1 = dfs(x1, y1, x2, j);\n\t\tr2 = dfs(x1, j+1, x2, y2);\n\t\tans = max(ans, pii(r1.first+r2.first, min(r1.second, r2.second)));\n\t}\n\n\tmemo[x1][y1][x2][y2] = true;\n\treturn ret[x1][y1][x2][y2] = ans;\n}\n\nint main(void)\n{\n\twhile (cin >> h >> w >> s, h|w|s) {\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemset(bit, 0, sizeof(bit));\n\n\t\trep(j, h) {\n\t\t\trep(i, w) {\n\t\t\t\tint uij;\n\t\t\t\tcin >> uij;\n\t\t\t\tupdate(i, j, uij);\n\t\t\t}\n\t\t}\n\n\t\tall = sum(w-1, h-1);\n\t\trequired = all-s;\n\t\tpii ans = dfs(0, 0, w-1, h-1);\n\t\tprintf(\"%d %d\\n\", ans.first, s-(all-ans.second));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<p.first<<\" \"<<p.second;return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nvector<pii> memo;\nvvi city;\nint t,s;\n\nconstexpr int getBitCoor(int y, int x){\n\treturn (y<<5)+x;\n}\n\npii solve(int ty, int tx, int by, int bx){\n\tint c=(getBitCoor(ty,tx)<<10)+getBitCoor(by,bx);\n\tif(memo[c].first!=0) {\n\t\treturn memo[c];\n\t}\n\tpii ans(1,city[ty][tx]-city[ty][bx+1]-city[by+1][tx]+city[by+1][bx+1]);\n\tif(t-ans.sc>s)ans={-1,0};\n\t//cout<<\"default: \"<<pii(ty,tx)<<\",\"<<pii(by,bx)<<\":\"<<ans<<endl;\n\t\n\trange(x,tx,bx){\n\t\tauto a=solve(ty,tx,by,x);\n\t\tauto b=solve(ty,x+1,by,bx);\n\t\tif(a.fs==-1 or b.fs==-1) continue;\n\t\ta.fs+=b.fs;\n\t\ta.sc=min(a.sc,b.sc);\n\t\tif(t-a.sc>s) continue;\n\t\tif(ans.fs<a.fs or (ans.fs==a.fs and ans.sc<a.sc)){\n\t\t\tans=a;\n\t\t}\n\t}\n\trange(y,ty,by){\n\t\tauto a=solve(ty,tx,y,bx);\n\t\tauto b=solve(y+1,tx,by,bx);\n\t\tif(a.fs==-1 or b.fs==-1) continue;\n\t\ta.fs+=b.fs;\n\t\ta.sc=min(a.sc,b.sc);\n\t\tif(t-a.sc>s) continue;\n\t\tif(ans.fs<a.fs or (ans.fs==a.fs and ans.sc<a.sc)){\n\t\t\tans=a;\n\t\t}\n\t}\n\t//cout<<pii(ty,tx)<<\",\"<<pii(by,bx)<<\" = \"<<ans<<endl;\n\treturn memo[c]=ans;\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint h,w;\n\twhile(cin>>h>>w>>s,h){\n\t\tt=0;\n\t\tmemo=vector<pii>((int)(1<<20),pii(0,0));\n\t\tcity=vvi(h+1,vi(w+1,0));\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>city[i+1][j+1];\n\t\t\tt+=city[i+1][j+1];\n\t\t}\n\t\trep(i,h)rep(j,w){\n\t\t\tint lt=getBitCoor(i,j)<<10;\n\t\t\tint rb=getBitCoor(i,j);\n\t\t\tif(t-city[i+1][j+1]<=s){\n\t\t\t\tmemo[lt+rb]=pii(1,city[i+1][j+1]);\n\t\t\t}else{\n\t\t\t\tmemo[lt+rb]=pii(-1,0);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\trep(i,h+1)range(j,1,w+1) city[i][j]+=city[i][j-1];\n\t\trange(i,1,h+1)rep(j,w+1) city[i][j]+=city[i-1][j];\n\t\tauto ans=solve(0,0,h-1,w-1);\n\t\tans.sc=s-(t-ans.sc);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 1e8;\n\nint main(){\n    int h,w,s;\n    while(cin>>h>>w>>s,h){\n        int u[32][32];\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>u[i][j];\n                s-=u[i][j];\n            }\n        }\n        s=-s;\n        pair<int,int> dp[32][32][32][32]={};\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                if(u[i][j]>=s){\n                    dp[i][j][0][0]=make_pair(1,u[i][j]);\n                }else{\n                    dp[i][j][0][0]=make_pair(0,u[i][j]);\n                }\n            }\n        }\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                for(int y=h-i-1;y>=0;--y){\n                    for(int x=w-j-1;x>=0;--x){\n                        for(int hk=0;hk<i;++hk){\n                            auto p1=dp[y][x][hk][j], p2=dp[y+hk+1][x][i-hk-1][j];\n                            if(p1.first==0 || p2.first==0){\n                                auto p=make_pair(0, p1.second+p2.second);\n                                if(p.second>=s)p=make_pair(1, p1.second+p2.second);\n                                dp[y][x][i][j]=max(dp[y][x][i][j],p);\n                                continue;\n                            }\n                            dp[y][x][i][j]=max(dp[y][x][i][j],make_pair(p1.first+p2.first, min(p1.second,p2.second)));\n                        }\n                        for(int wk=0;wk<j;++wk){\n                            auto p1=dp[y][x][i][wk], p2=dp[y][x+wk+1][i][j-wk-1];\n                            if(p1.first==0 || p2.first==0){\n                                auto p=make_pair(0, p1.second+p2.second);\n                                if(p.second>=s)p=make_pair(1, p1.second+p2.second);\n                                dp[y][x][i][j]=max(dp[y][x][i][j],p);\n                                continue;\n                            }\n                            dp[y][x][i][j]=max(dp[y][x][i][j],make_pair(p1.first+p2.first, min(p1.second,p2.second)));\n                        }\n                    }\n                }\n            }\n        }\n        cout<<dp[0][0][h-1][w-1].first<<\" \"<<dp[0][0][h-1][w-1].second-s<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint mp[35][35],smp[35][35],n,SUM,W,H;\nP mem[35][35][35][35];\nint used[35][35][35][35];\n\nint cal(int x1,int y1,int x2,int y2){\n  return smp[y2][x2]-(smp[y1-1][x2]+smp[y2][x1-1])+smp[y1-1][x1-1];\n}\n\nP dfs(int x,int y,int w,int h){\n  if(used[x][y][w][h]++) return mem[x][y][w][h];\n\n  P res=P(1,n-(SUM-cal(x,y,w,h)));\n  for(int i=x;i!=w;i++){\n    int m=max(SUM-cal(x,y,i,h),SUM-cal(i+1,y,w,h));\n    if(m<=n){\n      P a=dfs(x,y,i,h);\n      P b=dfs(i+1,y,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n\n  for(int i=y;i!=h;i++){\n    int m=max(SUM-cal(x,y,w,i),SUM-cal(x,i+1,w,h));\n    if(m<=n){\n      P a=dfs(x,y,w,i);\n      P b=dfs(x,i+1,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n  return mem[x][y][w][h]=res;\n}\n\nint main(){\n  while(1){\n  cin>>H>>W>>n;\n  if(!H&&!W&&!n)break;\n\n  memset(used,0,sizeof(used));\n  memset(mem,0,sizeof(mem));\n\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)cin>>mp[i][j],smp[i][j]=mp[i][j];\n\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i][j+1]+=smp[i][j];\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i+1][j]+=smp[i][j];\n  SUM=smp[H][W];\n  P ans=dfs(1,1,W,H);\n  cout <<ans.f<<\" \"<<ans.s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\nint h,w,s;\nint map[32][32];\nint all;\npair<int,int> memo[32][32][33][33];\n\npair<int,int> rec(int y1,int x1,int y2,int x2,int sum){\n  pair<int,int> res,hoge1,hoge2;\n  int a=1,b=0;\n  int tmp;\n  bool flag = false;\n\n  if(memo[y1][x1][y2][x2].first>=0)return memo[y1][x1][y2][x2];\n\n  tmp = 0;\n  for(int i=x1+1;i<x2;i++){\n\n    for(int j=y1;j<y2;j++)tmp += map[j][i-1];\n\n    if( all-tmp <= s && all-(sum-tmp) <= s){\n      flag = true;\n      hoge1 = rec(y1,x1,y2,i,tmp);\n      hoge2 = rec(y1,i,y2,x2,sum-tmp);\n      if(hoge1.first+hoge2.first > a){\n\ta = hoge1.first + hoge2.first;\n\tb = max(hoge1.second,hoge2.second);\n      }else if(hoge1.first + hoge2.first == a && max(hoge1.second,hoge2.second) < b){\n\tb = max(hoge1.second,hoge2.second);\n      }\n    }\n  }\n\n  tmp = 0;\n  for(int i=y1+1;i<y2;i++){\n\n    for(int j=x1;j<x2;j++)tmp += map[i-1][j];\n\n    if( all-tmp <= s && all-(sum-tmp) <= s){\n      flag = true;\n      hoge1 = rec(y1,x1,i,x2,tmp);\n      hoge2 = rec(i,x1,y2,x2,sum-tmp);\n      if(hoge1.first+hoge2.first > a){\n\ta = hoge1.first + hoge2.first;\n\tb = max(hoge1.second,hoge2.second);\n      }else if(hoge1.first + hoge2.first == a && max(hoge1.second,hoge2.second) < b){\n\tb = max(hoge1.second,hoge2.second);\n      }\n    }\n  }\n\n  if(!flag){\n    res.first = 1;\n    res.second = all - sum;\n  }else{\n    res.first = a;\n    res.second = b;\n  }\n  memo[y1][x1][y2][x2] = res;\n  return res;\n}\n\n\nint main(){\n  pair<int,int> ans;\n  while(1){\n    cin >> h >> w >> s;\n    if(!h && !w && !s)break;\n\n    all = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> map[i][j];\n\tall += map[i][j];\n      }\n    }\n \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<=h;k++){\n\t  for(int l=0;l<=w;l++){\n\t    memo[i][j][k][l].first = -1;\n\t    memo[i][j][k][l].second = -1;\n\t  }\n\t}\n      }\n    }\n\n    ans = rec(0,0,h,w,all);\n    cout << ans.first << \" \" << s - ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint sum;\nint H, W, S;\nint tab[32][32];\nPII memo[32][32][32][32];\nPII dfs(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2].first >= 0) return memo[x1][y1][x2][y2];\n  \n  int tot = 0;\n  for(int y=y1;y<y2;++y)\n\tfor(int x=x1;x<x2;++x)\n\t  tot += tab[y][x];\n  if(sum - tot > S) return memo[x1][y1][x2][y2] = MP(0,-1);\n\n  int mx = 1, g = tot;\n  for(int x=x1+1;x<x2;++x){\n\tPII p1 = dfs(x1,y1,x,y2);\n\tPII p2 = dfs(x,y1,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tif(mx < p1.first + p2.first){\n\t  mx = p1.first + p2.first;\n\t  g = min(p1.second, p2.second);\n\t}\n\telse if(mx == p1.first + p2.first){\n\t  g = max(g, min(p1.second, p2.second));\n\t}\n  }\n\n  for(int y=y1+1;y<y2;++y){\n\tPII p1 = dfs(x1,y1,x2,y);\n\tPII p2 = dfs(x1,y,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tif(mx < p1.first + p2.first){\n\t  mx = p1.first + p2.first;\n\t  g = min(p1.second, p2.second);\n\t}\n\telse if(mx == p1.first + p2.first){\n\t  g = max(g, min(p1.second, p2.second));\n\t}\n  }\n\n  return memo[x1][y1][x2][y2] = MP(mx,g);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>W>>S,H){\n\tREP(y,H) REP(x,W) cin >> tab[y][x];\n\tsum = 0;\n\tREP(y,H) REP(x,W) sum += tab[y][x];\n\tfill((PII*)memo, (PII*)memo+32*32*32*32, MP(-1,-1));\n\t\n\tPII pii = dfs(0,0,W,H);\n\tcout << pii.first << \" \" << S + pii.second - sum << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h,w,s,u[33][33]={},a[33][33][33][33]={},t,b[33][33][33][33]={};\nint Usum(int i,int j,int k,int l){\n    int R=0;\n    R=u[i+k][j+l]-u[i+k][j]-u[i][j+l]+u[i][j];\n    return R;\n}\n\nint main(){\n    while (cin >> h >> w >> s && h!=0){\n        for (int i=1; i<=h; i++){\n            for (int j=1; j<=w; j++){\n                cin >> u[i][j];\n                u[i][j] += u[i-1][j];\n                u[i][j] += u[i][j-1];\n\t\t\t\tu[i][j] -= u[i-1][j-1];\n            }\n\t\t}\n\t\tt=u[h][w]-s;\n        for (int i=1; i<=h; i++){\t\t\t\t\t\t//??????\n            for (int j=0; j<=h-i; j++){\t\t\t\t\t//???\n                for (int k=1; k<=w; k++){               //???\n                    for (int l=0; l<=w-k; l++){\t\t\t//???\n                        if (Usum(j,l,i,k)>=t){\n\t\t\t\t\t\t\ta[j][l][i][k]=1;\n\t\t\t\t\t\t}\n                        else a[j][l][i][k]=-100000000;\n                        for (int m=1; m<i; m++){\n                            if (a[j][l][i][k]<a[j][l][m][k]+a[j+m][l][i-m][k]){\n\t\t\t\t\t\t\t\ta[j][l][i][k]=a[j][l][m][k]+a[j+m][l][i-m][k];\n\t\t\t\t\t\t\t\tif (b[j][l][m][k]<b[j+m][l][i-m][k]) b[j][l][i][k]=b[j][l][m][k];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j+m][l][i-m][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[j][l][i][k]==a[j][l][m][k]+a[j+m][l][i-m][k] && b[j][l][i][k]<b[j][l][m][k] && b[j][l][i][k]<b[j+m][l][i-m][k]){\n\t\t\t\t\t\t\t\tif (b[j][l][m][k]<b[j+m][l][i-m][k]) b[j][l][i][k]=b[j][l][m][k];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j+m][l][i-m][k];\n\t\t\t\t\t\t\t}\n                        }\n                        for (int m=1; m<k; m++){\n                            if (a[j][l][i][k]<a[j][l][i][m]+a[j][l+m][i][k-m]){\n\t\t\t\t\t\t\t\ta[j][l][i][k]=a[j][l][i][m]+a[j][l+m][i][k-m];\n\t\t\t\t\t\t\t\tif (b[j][l][i][m]<b[j][l+m][i][k-m]) b[j][l][i][k]=b[j][l][i][m];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j][l+m][i][k-m];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[j][l][i][k]==a[j][l][i][m]+a[j][l+m][i][k-m] && b[j][l][i][k]<b[j][l][i][m] && b[j][l][i][k]<b[j][l+m][i][k-m]){\n\t\t\t\t\t\t\t\tif (b[j][l][i][m]<b[j][l+m][i][k-m]) b[j][l][i][k]=b[j][l][i][m];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j][l+m][i][k-m];\n\t\t\t\t\t\t\t}\n                        }\n\t\t\t\t\t\tif (a[j][l][i][k]==1) b[j][l][i][k]=Usum(j,l,i,k)-t;\n                    }\n                }\n            }\n        }\n        cout << a[0][0][h][w] << \" \" << b[0][0][h][w] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint group_num,value;\n};\n\nint H,W,SUPPLY,SUM;\nint demand[32][32];\nInfo dp[32][32][32][32];\n\nint calc_demand_sum(int row1,int col1,int row2,int col2){\n\tint A = 0,B = 0,C = 0;\n\n\tif(row1 == 0 || col1 == 0){\n\t\tC = 0;\n\t}else{\n\t\tC = demand[row1-1][col1-1];\n\t}\n\n\tif(row1 == 0){\n\t\tB = 0;\n\t}else{\n\t\tB = demand[row1-1][col2];\n\t}\n\n\tif(col1 == 0){\n\t\tA = 0;\n\t}else{\n\t\tA = demand[row2][col1-1];\n\t}\n\n\treturn demand[row2][col2]-A-B+C;\n}\n\nInfo recursive(int row1,int col1,int row2,int col2){\n\n\t if(dp[row1][col1][row2][col2].group_num != -1)return dp[row1][col1][row2][col2];\n\n\t    Info ret;\n\t    ret.group_num = -BIG_NUM;\n\t    ret.value = BIG_NUM;\n\n\t    int rest = SUM - calc_demand_sum(row1,col1,row2,col2);\n\t    if(rest <= SUPPLY) {\n\t        ret.group_num = 1;\n\t        ret.value = -rest;\n\n\t        for(int bottom_row = row1; bottom_row < row2; bottom_row++){\n\n\t\t\t\tInfo ret_a = recursive(row1,col1,bottom_row,col2);\n\t\t\t\tif(ret_a.group_num == -BIG_NUM)continue;\n\t\t\t\tInfo ret_b = recursive(bottom_row+1,col1,row2,col2);\n\t\t\t\tif(ret_b.group_num == -BIG_NUM)continue;\n\n\t\t\t\tInfo ret_c;\n\t\t\t\tret_c.group_num = ret_a.group_num+ret_b.group_num;\n\t\t\t\tret_c.value = min(ret_a.value,ret_b.value);\n\n\t\t\t\tif((ret.group_num < ret_c.group_num) || (ret.group_num == ret_c.group_num && ret.value < ret_c.value)){\n\t\t\t\t\tret = ret_c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int mid_col = col1; mid_col < col2; mid_col++){\n\n\t\t\t\tInfo ret_a = recursive(row1,col1,row2,mid_col);\n\t\t\t\tif(ret_a.group_num == -BIG_NUM)continue;\n\t\t\t\tInfo ret_b = recursive(row1,mid_col+1,row2,col2);\n\t\t\t\tif(ret_b.group_num == -BIG_NUM)continue;\n\n\t\t\t\tInfo ret_c;\n\t\t\t\tret_c.group_num = ret_a.group_num+ret_b.group_num;\n\t\t\t\tret_c.value = min(ret_a.value,ret_b.value);\n\n\t\t\t\tif((ret.group_num < ret_c.group_num) || (ret.group_num == ret_c.group_num && ret.value < ret_c.value)){\n\t\t\t\t\tret = ret_c;\n\t\t\t\t}\n\t\t\t}\n\t    }\n\t    return dp[row1][col1][row2][col2] = ret;\n}\n\nvoid func(){\n\n\tSUM = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&demand[row][col]);\n\t\t\tSUM += demand[row][col];\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 1; col < W; col++){\n\t\t\tdemand[row][col] += demand[row][col-1];\n\t\t}\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tfor(int row = 1; row < H; row++){\n\t\t\tdemand[row][col] += demand[row-1][col];\n\t\t}\n\t}\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\n\t\t\t\t\tdp[a][b][c][d].group_num = -1;\n\t\t\t\t\tdp[a][b][c][d].value = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo ans = recursive(0,0,H-1,W-1);\n\n\tprintf(\"%d %d\\n\",ans.group_num,SUPPLY+ans.value);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&SUPPLY);\n\t\tif(H == 0 && W == 0 && SUPPLY == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n#define F first\n#define S second\nP dp[33][33][33][33];\nint h,w,s,sum[33][33],a[33][33],SUM;\nvoid dpp(){\n  r(i,33)r(j,33)r(k,33)r(l,33)dp[i][j][k][l]=P(0,1e9);\n  memset(sum,0,sizeof(sum));\n  r(i,h)r(j,w)sum[i+1][j+1]=a[i][j];\n  r(i,h+1)r(j,w)sum[i][j+1]+=sum[i][j];\n  r(j,w+1)r(i,h)sum[i+1][j]+=sum[i][j];\n}\nint get(int ly,int lx,int ry,int rx){\n  return sum[ry+1][rx+1]-sum[ry+1][lx]-sum[ly][rx+1]+sum[ly][lx];\n}\nP dfs(int ly,int lx,int ry,int rx){\n  if(dp[ly][lx][ry][rx]!=P(0,1e9))return dp[ly][lx][ry][rx];\n  P res=P(1,SUM-get(ly,lx,ry,rx));//cout<<get(ly,lx,ry,rx)<<endl;\n  for(int i=lx;i<rx;i++){\n    if(s-(SUM-get(ly,lx,ry,i))<0)continue;\n    if(s-(SUM-get(ly,i+1,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,ry,i),res2=dfs(ly,i+1,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  for(int i=ly;i<ry;i++){\n    if(s-(SUM-get(ly,lx,i,rx))<0)continue;\n    if(s-(SUM-get(i+1,lx,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,i,rx),res2=dfs(i+1,lx,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  return dp[ly][lx][ry][rx]=res;\n}\n\nint main(){\n  while(cin>>h>>w>>s,s){\n    SUM=0;\n    r(i,h)r(j,w)cin>>a[i][j],SUM+=a[i][j];\n    dpp();\n    P p=dfs(0,0,h-1,w-1);\n    cout<<p.F<<' '<<p.S<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n\ntypedef pair<int,int> P;\nint h,w,s,all,t[32][32];\nint i,j;\nint rec[32][32][32][32]; //長方形の合計[ly][lx][hy][hx]\nP dp[32][32][32][32]; //メモ化\n\n//全ての(lx,ly)〜(hx,hy)の長方形合計を計算\nvoid mkRec(){\n  memset(rec,0,sizeof(rec));\n\n  rep(i,h){\n    rep(j,w){\n      rec[i][j][i][j] = t[i][j];\n\n      for(int y=i-1;y>=0;y--)\n        rec[y][j][i][j] = rec[y+1][j][i][j] + t[y][j];\n\n      for(int y=i;y>=0;y--){\n        int sum = 0;\n        for(int x=j;x>=0;x--){\n          sum += rec[y][x][i][x];\n          rec[y][x][i][j] = sum;\n        }\n      }\n    }\n  }\n}\n\n//戻り型 : P. first : 最大グループ数. second : 最大予備力\nP dfs(int lx,int ly,int hx,int hy){\n  if(dp[ly][lx][hy][hx].first != 0) return dp[ly][lx][hy][hx];\n\n  P res = P(1,s-(all-rec[ly][lx][hy][hx]));\n\n  //水平分割\n  for(int i=ly;i<hy;i++){\n    if(all - rec[ly][lx][i][hx] > s ||\n       all - rec[i+1][lx][hy][hx] > s) continue;\n    P a = dfs(lx,ly,hx,i);\n    P b = dfs(lx,i+1,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  //垂直分割\n  for(int j=lx;j<hx;j++){\n    if(all - rec[ly][lx][hy][j] > s ||\n       all - rec[ly][j+1][hy][hx] > s) continue;\n    P a = dfs(lx,ly,j,hy);\n    P b = dfs(j+1,ly,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  return dp[ly][lx][hy][hx] = res;\n}\n\nint main(void){\n  while(scanf(\"%d%d%d\",&h,&w,&s),h||w||s){\n    all = 0;\n    rep(i,h){\n      rep(j,w){\n        scanf(\"%d\",&t[i][j]);\n        all += t[i][j];\n      }\n    }\n\n    mkRec();\n\n    memset(dp,0,sizeof(dp));\n    P p = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",p.first,p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\npair<int, int> dp[32][32][32][32];\nint table[32][32], sum_table[32][32];\nint h, w, s;\nint calc(int sy, int sx, int gy, int gx)\n{\n    int res = sum_table[gy][gx];\n    if(sy > 0) res -= sum_table[sy - 1][gx];\n    if(sx > 0) res -= sum_table[gy][sx - 1];\n    if(sy > 0 and sx > 0) res += sum_table[sy - 1][sx - 1];\n    return res;\n}\npair<int, int> dfs(int sy, int sx, int gy, int gx)\n{\n    if(dp[sy][sx][gy][gx].first) return dp[sy][sx][gy][gx];\n    int cost = sum_table[h - 1][w - 1] - calc(sy, sx, gy, gx);\n    if(cost > s) return dp[sy][sx][gy][gx] = make_pair(-1, -1);\n    pair<int, int> res = {1, -cost};\n    for(int i = sy; i < gy; i++)\n    {\n        pair<int, int> s = dfs(sy, sx, i, gx), t = dfs(i + 1, sx, gy, gx);\n        if (s.first == 0 or t.first == 0) continue;\n        pair<int, int> u = make_pair(s.first + t.first, min(s.second, t.second));\n        if(res < u) res = u;\n    }\n\n    for(int j = sx; j < gx; j++)\n    {\n        pair<int, int> s = dfs(sy, j + 1, gy, gx), t = dfs(sy, sx, gy, j);\n        if(s.first == 0 or t.first == 0) continue;\n        pair<int, int> u = make_pair(s.first + t.first, min(s.second, t.second));\n        if(res < u) res = u;\n    }\n    return dp[sy][sx][gy][gx] = res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> h >> w >> s, h or w or s)\n    {\n        for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) cin >> table[i][j];\n        memset(dp, 0, sizeof(dp));\n        memset(sum_table, 0, sizeof(sum_table));\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                sum_table[i][j] = table[i][j];\n                if(i > 0) sum_table[i][j] += sum_table[i - 1][j];\n                if(j > 0) sum_table[i][j] += sum_table[i][j - 1];\n                if(i > 0 and j > 0) sum_table[i][j] -= sum_table[i - 1][j - 1];\n                //cout << setw(5) << sum_table[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        pair<int, int> ans = dfs(0, 0, h - 1, w - 1);\n        cout << ans.first << \" \" << s + ans.second << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\ninline int solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2]) return dp[y1][x1][y2][x2];\n\tint ret = 1048576 + rng(x1, y1, x2, y2);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2), petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i), petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", (ret >> 20), ((ret - o) & 1048575));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint h, w, s, u[32][32], all, diff;\nint group[32][32][32][32], need[32][32][32][32];\n\nint count(int t, int l, int b, int r) {\n  int sum = 0;\n  REP(i, t, b) REP(j, l, r) sum += u[i][j];\n  return sum;\n}\n\npii dfs(int t, int l, int b, int r) {\n  if(need[t][l][b][r] >= 0) {\n    return pii(group[t][l][b][r], need[t][l][b][r]);\n  }\n\n  int sum = count(t, l, b, r);\n  if(sum < diff) {\n    return pii(group[t][l][b][r] = 0, need[t][l][b][r] = INF);\n  }\n\n  pii ret = pii(1, sum);\n  REP(i, t + 1, b) {\n    pii ta = dfs(t, l, i, r);\n    pii ba = dfs(i, l, b, r);\n    ta.first += ba.first;\n    ta.second = min(ta.second, ba.second);\n    ret = max(ret, ta);\n  }\n  REP(i, l + 1, r) {\n    pii la = dfs(t, l, b, i);\n    pii ra = dfs(t, i, b, r);\n    la.first += ra.first;\n    la.second = min(la.second, ra.second);\n    ret = max(ret, la);\n  }\n\n  group[t][l][b][r] = ret.first;\n  need[t][l][b][r] = ret.second;\n  return ret;\n}\n\nint main(void) {\n  while(cin >> h >> w >> s, h != 0 && w != 0 && s != 0) {\n    all = 0;\n    REP(i, 0, h) REP(j, 0, w) {\n      cin >> u[i][j];\n      all += u[i][j];\n    }\n    diff = all - s;\n\n    REP(i, 0, 32) REP(j, 0, 32) REP(k, 0, 32) REP(l, 0, 32) {\n      group[i][j][k][l] = -1;\n      need[i][j][k][l] = -1;\n    }\n\n    pii ret = dfs(0, 0, h, w);\n    cout << ret.first << \" \" << ret.second - diff << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost) { // cost[n][n]\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\npair<ll, ll> dp[33][33][33][33];\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\twhile (true) {\n\t\tll h, w, s; cin >> h >> w >> s;\n\t\tif (h == 0) break;\n\t\tvvl table(w, vl(h));\n\t\tREP(i, h) REP(j, w) cin >> table[j][i]; // table[x][y];\n\n\t\t{\n\t\t\tll sum = 0; REP(i, h) REP(j, w) sum += table[j][i];\n\t\t\ts = sum - s;\n\t\t}\n\n\t\tfill((pair<ll,ll>*)begin(dp), (pair<ll,ll>*)end(dp), pair<ll,ll>{0, -1});\n\t\tfunction<pair<ll,ll>(int, int, int, int)> dfs = [&](int x1, int y1, int x2, int y2) {\n\t\t\tif (dp[x1][y1][x2][y2].second != -1) return dp[x1][y1][x2][y2];\n\t\t\tll sum = 0;\n\t\t\tFOR(x, x1, x2) FOR(y, y1, y2) sum += table[x][y];\n\t\t\tif (sum < s) return dp[x1][y1][x2][y2] = pair<ll, ll>(0, sum);\n\n\t\t\tpair<ll, ll> ans = { 1,  sum };\n\t\t\tFOR(x, x1 + 1, x2) {\n\t\t\t\tauto result_1 = dfs(x1, y1, x, y2);\n\t\t\t\tauto result_2 = dfs(x, y1, x2, y2);\n\t\t\t\tif (result_1.first == 0 || result_2.first == 0) continue;\n\t\t\t\tauto result = make_pair(result_1.first + result_2.first, min(result_1.second, result_2.second));\n\t\t\t\tif (result.first > ans.first || (result.first == ans.first && result.second > ans.second)) {\n\t\t\t\t\tans = result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(y, y1 + 1, y2) {\n\t\t\t\tauto result_1 = dfs(x1, y1, x2, y);\n\t\t\t\tauto result_2 = dfs(x1, y, x2, y2);\n\t\t\t\tif (result_1.first == 0 || result_2.first == 0) continue;\n\t\t\t\tauto result = make_pair(result_1.first + result_2.first, min(result_1.second, result_2.second));\n\t\t\t\tif (result.first > ans.first || (result.first == ans.first && result.second > ans.second)) {\n\t\t\t\t\tans = result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[x1][y1][x2][y2] = ans;\n\t\t};\n\t\tauto ans = dfs(0, 0, w, h);\n\t\tcout << ans.first << \" \" << ans.second - s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define mp(a,b) make_pair(a,b)\n#define num first\n#define energy second\ntypedef pair<int,int> pii;\n\nint H , W , S;\nint mat[40][40];\npii dp[40][40][40][40];\nint count(int x1,int y1,int x2,int y2){\n\treturn mat[y2-1][x2-1] - mat[y2-1][x1-1] - mat[y1-1][x2-1] + mat[y1-1][x1-1];\n}\n\npii dfs(int x1 , int y1 , int x2 , int y2){\n\tif(~dp[x1][y1][x2][y2].num) return dp[x1][y1][x2][y2];\n\tif(mat[H][W] - count(x1,y1,x2,y2) > S) return mp(-10000,1);\n\tpii ans = mp(1,S-(mat[H][W] - count(x1,y1,x2,y2)));\n\t\n\tfor(int i = x1+1 ; i < x2 ; i++){\n\t\tpii A = dfs(x1,y1,i,y2);\n\t\tpii B = dfs(i,y1,x2,y2);\n\t\tpii get = mp(A.num + B.num , min(A.energy,B.energy) );\n\t\tans = max( ans , get);\n\t}\n\tfor(int i = y1+1 ; i < y2 ; i++){\n\t\tpii A = dfs(x1,y1,x2,i);\n\t\tpii B = dfs(x1,i,x2,y2);\n\t\tpii get = mp(A.num + B.num , min(A.energy,B.energy) );\n\t\tans = max( ans , get);\n\t}\n\t\n\treturn dp[x1][y1][x2][y2] = ans ;\n}\n\nint main(){\n\tint t;\n\twhile(cin >> H >> W >> S , H){\n\t\tmemset(mat,0,sizeof(mat));\n\t\tfor(int i = 0 ; i < 40 ; i++)\n\t\t\tfor(int j = 0 ; j < 40 ; j++)\n\t\t\t\tfor(int k = 0 ; k < 40 ; k++)\n\t\t\t\t\tfor(int l = 0 ; l < 40 ; l++)\n\t\t\t\t\t\tdp[i][j][k][l] = mp(-1,-1);\n\t\tfor(int i = 1 ; i <= H ; i++)\n\t\t\tfor(int j = 1 ; j <= W ; j++)\n\t\t\t\tcin >> t , mat[i][j] = t + mat[i][j-1];\n\t\tfor(int i = 1 ; i <= H ; i++)\n\t\t\tfor(int j = 1 ; j <= W ; j++)\n\t\t\t\tmat[i][j] += mat[i-1][j];\n\t\tpii result = dfs(1,1,W+1,H+1);\n\t\tcout << result.num << \" \" << result.energy << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint h, w, s;\nint u[35][35];\nint sum_from1_1[35][35] = {};\npair<int, int> result[35][35][35][35];\n\npair<int, int> solve(int sx, int sy, int tx, int ty)\n{\n\tif(result[sx][sy][tx][ty].first >= -1) return result[sx][sy][tx][ty];\n\tint sum = sum_from1_1[tx][ty] - sum_from1_1[sx - 1][ty] - sum_from1_1[tx][sy - 1] + sum_from1_1[sx - 1][sy - 1];\n\tint groupnum = 1, mingroup = sum;\n\t// cout << sx << \" \" << sy << \" \" << tx << \" \" << ty << \" \" << nowmingroup << endl;\n\tfor(int i = sx; i < tx; i++){\n\t\tint nowsum = sum_from1_1[i][ty] - sum_from1_1[sx - 1][ty] - sum_from1_1[i][sy - 1] + sum_from1_1[sx - 1][sy - 1];\n\t\tif(sum_from1_1[h][w] - (sum - nowsum) <= s && sum_from1_1[h][w] - nowsum <= s){\n\t\t\tpair<int, int> tmp1 = solve(sx, sy, i, ty);\n\t\t\tpair<int, int> tmp2 = solve(i + 1, sy, tx, ty);\n\t\t\tif(tmp1.first + tmp2.first > groupnum){\n\t\t\t\tgroupnum = tmp1.first + tmp2.first;\n\t\t\t\tmingroup = min(tmp1.second, tmp2.second);\n\t\t\t} else if(tmp1.first + tmp2.first == groupnum){\n\t\t\t\tmingroup = max(mingroup, min(tmp1.second, tmp2.second));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = sy; i < ty; i++){\n\t\tint nowsum = sum_from1_1[tx][i] - sum_from1_1[sx - 1][i] - sum_from1_1[tx][sy - 1] + sum_from1_1[sx - 1][sy - 1];\n\t\tif(sum_from1_1[h][w] - (sum - nowsum) <= s && sum_from1_1[h][w] - nowsum <= s){\n\t\t\tpair<int, int> tmp1 = solve(sx, sy, tx, i);\n\t\t\tpair<int, int> tmp2 = solve(sx, i + 1, tx, ty);\n\t\t\tif(tmp1.first + tmp2.first > groupnum){\n\t\t\t\tgroupnum = tmp1.first + tmp2.first;\n\t\t\t\tmingroup = min(tmp1.second, tmp2.second);\n\t\t\t} else if(tmp1.first + tmp2.first == groupnum){\n\t\t\t\tmingroup = max(mingroup, min(tmp1.second, tmp2.second));\n\t\t\t}\n\t\t}\n\t}\n\t// cout << sx << \" \" << sy << \" \" << tx << \" \" << ty << \" : \" << groupnum << \" \" << mingroup << endl;\n\treturn result[sx][sy][tx][ty] = make_pair(groupnum, mingroup);\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> h >> w >> s;\n\t\tif(h == 0) break;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tsum_from1_1[i][j] = sum_from1_1[i - 1][j] + sum_from1_1[i][j - 1] - sum_from1_1[i - 1][j - 1] + u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tfor(int k = 0; k <= h; k++){\n\t\t\t\t\tfor(int l = 0; l <= w; l++){\n\t\t\t\t\t\tresult[i][j][k][l] = make_pair(-2, -2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int, int> ans = solve(1, 1, h, w);\n\t\tcout << ans.first << \" \" << s - (sum_from1_1[h][w] - ans.second) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint DP[33][33][33][33];\nint rem[33][33][33][33];\nint S_[40][40];\n\nint h, w, s;\n\nint S(int y, int x){\n\tif(y < 0 || x < 0 || y >= h || x >= w){\n\t\treturn 0;\n\t}\n\treturn S_[y][x];\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> h >> w >> s;\n\t\tif(h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < 40; i++){\n\t\t\tfor(int j = 0; j < 40; j++){\n\t\t\t\tS_[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint u[40][40] = {};\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tS_[i][j] = u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < 40; i++){\n\t\t\tfor(int j = 0; j < 40; j++){\n\t\t\t\tS_[i][j] += S_[i - 1][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 40; i++){\n\t\t\tfor(int j = 1; j < 40; j++){\n\t\t\t\tS_[i][j] += S_[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tint th = S_[39][39] - s;\n\t\tfor(int i = 0; i < w; i++)for(int l = 0; l < h; l++)\n\t\tfor(int j = 0; j < h; j++)for(int k = 0; k < w; k++){\n\t\t\tDP[i][j][k][l] = 0;\n\t\t\trem[i][j][k][l] = 0;\n\t\t\tif(i <= k && j <= l){\n\t\t\t\tint hoge = S(l, k) - S(l, i - 1) - S(j - 1, k) + S(j - 1, i - 1);\n\t\t\t\tif(hoge >= th){\n\t\t\t\t\tDP[i][j][k][l] = 1;\n\t\t\t\t\trem[i][j][k][l] = hoge - th;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int dx = 0; dx < w; dx++)for(int dy = 0; dy < h; dy++)\n\t\tfor(int sx = 0; sx + dx < w; sx++)for(int sy = 0; sy + dy < h; sy++){\n\t\t\tint gx = sx + dx;\n\t\t\tint gy = sy + dy;\n\t\t\tfor(int px = sx; px < gx; px++){\n\t\t\t\tint ret = DP[sx][sy][px][gy] + DP[px + 1][sy][gx][gy];\n\t\t\t\tint ret2 = min(rem[sx][sy][px][gy], rem[px + 1][sy][gx][gy]);\n\t\t\t\t\n\t\t\t\tif(DP[sx][sy][gx][gy] < ret){\n\t\t\t\t\tDP[sx][sy][gx][gy] = ret;\n\t\t\t\t\trem[sx][sy][gx][gy] = ret2;\n\t\t\t\t}else if(DP[sx][sy][gx][gy] == ret){\n\t\t\t\t\trem[sx][sy][gx][gy] = max(rem[sx][sy][gx][gy], ret2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int py = sy; py < gy; py++){\n\t\t\t\tint ret = DP[sx][sy][gx][py] + DP[sx][py + 1][gx][gy];\n\t\t\t\tint ret2 = min(rem[sx][sy][gx][py], rem[sx][py + 1][gx][gy]);\n\t\t\t\t\n\t\t\t\tif(DP[sx][sy][gx][gy] < ret){\n\t\t\t\t\tDP[sx][sy][gx][gy] = ret;\n\t\t\t\t\trem[sx][sy][gx][gy] = ret2;\n\t\t\t\t}else if(DP[sx][sy][gx][gy] == ret){\n\t\t\t\t\trem[sx][sy][gx][gy] = max(rem[sx][sy][gx][gy], ret2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << DP[0][0][w - 1][h - 1] << \" \" << rem[0][0][w - 1][h - 1] << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include <nmmintrin.h>\n#include <immintrin.h>\n#include <mmintrin.h>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,P) scanf(\"%d %d %d %d\",&n,&m,&o,&P)\n#define SINT5(n,m,o,P,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&P,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 1'010'000'000; // 0x3C33'6080\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\nint h, w, s;\nint memo[36][36][36][36];\nint u[64][64];\nint sum_dat[64][64];\n\nint sum(int l, int u, int r, int d) {\n\treturn sum_dat[d][r] - sum_dat[u][r] - sum_dat[d][l] + sum_dat[u][l];\n}\n\n// solve : v以上で分割したときにできるグループ数．できないなら0\n// グループ数を最大化\nint solve(int l, int u, int r, int d, int v) { // [l,r) [u,d)\n\tif (memo[l][u][r][d] != -1) return memo[l][u][r][d];\n\tint ret = 0;\n\tif (sum(l, u, r, d) >= v) ret = 1;\n\tfor (int i = u + 1; i < d; ++i) { // 上下\n\t\tint a = solve(l, u, r, i, v);\n\t\tint b = solve(l, i, r, d, v);\n\t\tret = max(ret, a + b);\n\t}\n\tfor (int i = l + 1; i < r; ++i) { // 左右\n\t\tint a = solve(l, u, i, d, v);\n\t\tint b = solve(i, u, r, d, v);\n\t\tret = max(ret, a + b);\n\t}\n\t// printf(\"Solve LR[%d,%d) UD[%d,%d] : %d\\n\", l,r,u,d,ret);\n\treturn memo[l][u][r][d] = ret;\n}\n\n// solve : v以上で分割したときにできるグループ数．できないなら0\n// test : v以上に分割できるか．できるならグループ数\nint test(int v) {\n\tmemset(memo, -1, sizeof(memo));\n\tauto ret = solve(0, 0, w, h, v);\n\treturn ret;\n}\n\n\nint main() {\n\twhile (cin >> h >> w >> s, h) {\n\t\tmemset(sum_dat, 0, sizeof(sum_dat));\n\t\trep(i, h) rep(j, w) {\n\t\t\tcin >> u[i][j];\n\t\t\tsum_dat[i + 1][j + 1] = u[i][j];\n\t\t}\n\t\treP(i, h) {\n\t\t\treP(j, w) {\n\t\t\t\tsum_dat[i][j + 1] += sum_dat[i][j];\n\t\t\t}\n\t\t}\n\t\treP(i, h) {\n\t\t\treP(j, w) {\n\t\t\t\tsum_dat[i + 1][j] += sum_dat[i][j];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tputs(\"~~~~~\");\n\t\treP(i, h) {\n\t\t\treP(j, w) {\n\t\t\t\tprintf(\"%2d \", sum_dat[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t//*/\n\t\tint mi = sum_dat[h][w] - s;\n\t\tint miv = test(mi);\n\t\tint ok = mi;\n\t\tint ng = sum_dat[h][w] + 1;\n\n\t\twhile (ng - ok > 1) {\n\t\t\tint m = (ok + ng) / 2;\n\t\t\tif (test(m) != miv) {\n\t\t\t\tng = m;\n\t\t\t} else {\n\t\t\t\tok = m;\n\t\t\t}\n\t\t}\n\t\tcout << miv << \" \" << ok-mi << endl;\n\n\n\t\t/*\n\t\trep(i, h) rep(j, w) {\n\t\t\tprintf(\"[%d,%d]\\n\", i, j);\n\t\t\trepfT(a, 1, h) {\n\t\t\t\trepfT(b, 1, w) {\n\t\t\t\t\tint r = -1;\n\t\t\t\t\tif (i < a && j < b) {\n\t\t\t\t\t\tr = sum(j, i, b, a);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%2d \", r);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"----\");\n\t\t//*/\n\n\t\t/*\n\t\tfor (;;) {\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tcout << v << \" : \" << test(v) << endl;\n\n\t\t\trep(i, h) rep(j, w) {\n\t\t\t\tprintf(\"[%d,%d]\\n\", i, j);\n\t\t\t\trepfT(a, 1, h){\n\t\t\t\t\trepfT(b, 1, w) {\n\t\t\t\t\t\tif (i < a && j < b) {\n\t\t\t\t\t\t\tint r = solve(j, i, b, a, v);\n\t\t\t\t\t\t\tprintf(\"%2d \", r);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\" # \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nclass Result {\npublic:\n    int group, power;\n    Result(int g = -1, int p = -1) :group(g), power(p) {}\n    bool operator<(const Result r) const {\n        if(group != r.group) return group < r.group;\n        return power < r.power;\n    }\n};\n\nint h, w, s;\nint u[32][32];\nResult memo[32][32][32][32];\nint memo_sum[32][32][32][32];\n\nint sum(int x1, int y1, int x2, int y2) {\n    if(memo_sum[x1][y1][x2][y2] != -1) return memo_sum[x1][y1][x2][y2];\n    int sum = 0;\n    for(int y = y1; y <= y2; ++y) for(int x = x1; x <= x2; ++x) sum += u[x][y];\n    return memo_sum[x1][y1][x2][y2] = sum;\n}\n\nResult dfs(int x1, int y1, int x2, int y2) {\n    if(memo[x1][y1][x2][y2].group != -1) return memo[x1][y1][x2][y2];\n    Result result(1, s - (sum(0, 0, w - 1, h - 1) - sum(x1, y1, x2, y2)));\n\n    for(int j = x1; j < x2; ++j) {\n        if(sum(0, 0, w - 1, h - 1) - sum(x1, y1, j, y2) > s) continue;\n        if(sum(0, 0, w - 1, h - 1) - sum(j + 1, y1, x2, y2) > s) continue;\n        Result r1 = dfs(x1, y1, j, y2);\n        Result r2 = dfs(j + 1, y1, x2, y2);\n        result = max(result, Result(r1.group + r2.group, min(r1.power, r2.power)));\n    }\n\n    for(int i = y1; i < y2; ++i) {\n        if(sum(0, 0, w - 1, h - 1) - sum(x1, y1, x2, i) > s) continue;\n        if(sum(0, 0, w - 1, h - 1) - sum(x1, i + 1, x2, y2) > s) continue;\n        Result r1 = dfs(x1, y1, x2, i);\n        Result r2 = dfs(x1, i + 1, x2, y2);\n        result = max(result, Result(r1.group + r2.group, min(r1.power, r2.power)));\n    }\n\n    return memo[x1][y1][x2][y2] = result;\n}\n\nint main() {\n    while(cin >> h >> w >> s, h | w | s) {\n        for(int y1 = 0; y1 < h; ++y1) for(int x1 = 0; x1 < w; ++x1) for(int y2 = 0; y2 < h; ++y2) for(int x2 = 0; x2 < w; ++x2) memo[x1][y1][x2][y2].group = -1;\n        for(int y1 = 0; y1 < h; ++y1) for(int x1 = 0; x1 < w; ++x1) for(int y2 = 0; y2 < h; ++y2) for(int x2 = 0; x2 < w; ++x2) memo_sum[x1][y1][x2][y2] = -1;\n        for(int y = 0; y < h; ++y) for(int x = 0; x < w; ++x) cin >> u[x][y];\n\n        Result result = dfs(0, 0, w - 1, h - 1);\n        cout << result.group << \" \" << result.power << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint H, W, S;\nint U[34][34];\nint total;\ni_i dp[34][34][34][34];\nint sum[35][35];\n\n\nint f(int h1, int h2, int w1, int w2) {\n    int ret = sum[h2][w2];\n    ret -= sum[h1-1][w2];\n    ret -= sum[h2][w1-1];\n    ret += sum[h1-1][w1-1];\n    return ret;\n}\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> H >> W >> S;\n        total = 0;\n        if(H == 0) break;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                cin >> U[h][w];\n                total += U[h][w];\n            }\n        }\n        for(int i = 0; i <= 34; i++) {\n            sum[i][0] = 0;\n            sum[0][i] = 0;\n        }\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                sum[h][w] = sum[h-1][w] + sum[h][w-1] - sum[h-1][w-1] + U[h][w];\n            }\n        }\n        for(int dh = 1; dh <= H; dh++) {\n            for(int dw = 1; dw <= W; dw++) {\n                for(int h1 = 1; h1 + dh - 1 <= H; h1++) {\n                    int h2 = h1 + dh - 1;\n                    for(int w1 = 1; w1 + dw - 1 <= W; w1++) {\n                        int w2 = w1 + dw - 1;\n                        dp[h1][h2][w1][w2] = {-INF, 0};\n                        //cerr << h1 << \" \" << h2 << \" \" << w1 << \" \" << w2 << \" \" << f(h1, h2, w1, w2) << endl;\n                        if(total - f(h1, h2, w1, w2) <= S) {\n                            dp[h1][h2][w1][w2] = {1, S - total + f(h1, h2, w1, w2)};\n                        }\n                        for(int h3 = h1 + 1; h3 <= h2; h3++) {\n                            i_i now;\n                            now.first = dp[h1][h3-1][w1][w2].first + dp[h3][h2][w1][w2].first;\n                            now.second = min(dp[h1][h3-1][w1][w2].second, dp[h3][h2][w1][w2].second);\n                            if(now.first > dp[h1][h2][w1][w2].first) dp[h1][h2][w1][w2] = now;\n                            else if(now.first == dp[h1][h2][w1][w2].first && now.second > dp[h1][h2][w1][w2].second) dp[h1][h2][w1][w2] = now;\n                        }\n                        for(int w3 = w1 + 1; w3 <= w2; w3++) {\n                            i_i now;\n                            now.first = dp[h1][h2][w1][w3-1].first + dp[h1][h2][w3][w2].first;\n                            now.second = min(dp[h1][h2][w1][w3-1].second, dp[h1][h2][w3][w2].second);\n                            if(now.first > dp[h1][h2][w1][w2].first) dp[h1][h2][w1][w2] = now;\n                            else if(now.first == dp[h1][h2][w1][w2].first && now.second > dp[h1][h2][w1][w2].second) dp[h1][h2][w1][w2] = now;\n                        }\n                    }\n                }\n            }\n        }\n        cout << dp[1][H][1][W].first << \" \" << dp[1][H][1][W].second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\n\npair<int, int> split(int ax, int ay, int bx, int by){\n\tpair<int, int> max_group, group, g1, g2;\n\tint sum_e = 0;\n\tint i, j;\n\n\tif(memo[ax][ay][bx][by].first != 0) return memo[ax][ay][bx][by];\n\t\n\tfor(i = ax; i <= bx; i++){\n\t\tfor(j = ay; j <= by; j++){\n\t\t\tsum_e += area[i][j];\n\t\t}\n\t}\n\tif(sum - sum_e > s){\n//\t\tcout << \" :out\" << endl;\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\tmax_group.first = 1;\n\tmax_group.second = s - (sum - sum_e);\n\n\tfor(i = ax; i < bx; i++){\n\t\tg1 = split(ax, ay, i, by);\n\t\tg2 = split(i + 1, ay, bx, by);\n\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n//\t\tgroup.first = g1.first + g2.first;\n//\t\tgroup.second = min(g1.second, g2.second);\n//\t\tif(group.first > max_group.first) max_group = group;\n//\t\telse if(group.first == max_group.first && group.second > max_group.second) max_group = group;\n\t}\n\tfor(i = ay; i < by; i++){\n//\t\tif(!check(ax, ay, bx, i) || !check(ax, i + 1, bx, by)) continue;\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i + 1, bx, by);\n\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n//\t\tgroup.first = g1.first + g2.first;\n//\t\tgroup.second = min(g1.second, g2.second);\t\t\n//\t\tif(group.first > max_group.first) max_group = group;\n//\t\telse if(group.first == max_group.first && group.second > max_group.second) max_group = group;\n\t}\n//\tcout << ax << \" : \" << ay << \" : \" << bx << \" : \" << by << endl << max_group.first << \" : \" << max_group.second << endl;\n\t\n\treturn memo[ax][ay][bx][by] = max_group;\n}\n\nint main(void){\n\tint i,j;\n\tint group_count;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tsum = 0;\n\t\tfor(i = 1; i <= w; i++)\n\t\t\tfor(j = 1; j <= h; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n\t\tans = split(1, 1, w, h);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\ninline int rng(int x1, int y1, int x2, int y2) {\n\treturn sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2];\n}\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1000000 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = (resl / 1000000 + resr / 1000000) * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = (resl / 1000000 + resr / 1000000) * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << ret / 1000000 << ' ' << ret % 1000000 - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ¶ãÌÀWÆEºÌÀWÅÍÍðwèµA±ÌÍÍÌÅåO[vðL¯\npair<int,int> dp[32][32][32][32];\nint h,w,s;\nint field[32][32];\nint sumDemand;\n\nint maxPre=0;\n\npair<int,int> dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[miny][minx][maxy][maxx].first!=-1)\n\t\treturn dp[miny][minx][maxy][maxx];\n\t// »ÝÌêðâd³¹½Æ«ÉAùvªð´¦È¢©Ç¤©\n\tint decDemand=0;\n\tfor(int i = miny; i <= maxy; i++){\n\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\tdecDemand+=field[i][j];\n\t\t}\n\t}\n\tif(sumDemand - decDemand > s){\n\t\treturn make_pair(-1,0);\n\t}\n\n\tint pre=sumDemand-decDemand;\n\n\tpair<int,int> maxGroup;\n\tmaxGroup.first=1;\n\tmaxGroup.second=pre;\n\n\t// «èû·×Äð·\n\t// ¡Øè\n\tfor(int i = miny; i < maxy; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,maxx,i);\n\t\tpair<int,int> ret2=dfs(minx,i+1,maxx,maxy);\n\t\t// ±Ì«èûÍsÂ\\\n\t\tif(ret1.first==-1||ret2.first==-1)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\n\t}\n\t// tateØè\n\tfor(int i = minx; i < maxx; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,i,maxy);\n\t\tpair<int,int> ret2=dfs(i+1,miny,maxx,maxy);\n\t\tif(ret1.first==-1||ret2.first==-2)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t}\n\tdp[miny][minx][maxy][maxx]=maxGroup;\n\treturn maxGroup;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&!(h==0&&s==0&&w==0)){\n\t\tfor(int i = 0; i < 32; i++)\n\t\t\tfor(int j = 0; j < 32; j++)\n\t\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t\t\tfill(dp[i][j][k],dp[i][j][k]+32,make_pair(-1,-1));\n\t\tsumDemand=0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tsumDemand+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mxg=dfs(0,0,w-1,h-1);\n\t\tcout<<mxg.first<<\" \"<<s-mxg.second<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define PB push_back\n\nconst int INF = (1LL<<30);\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nconst int maxh = 35, maxw = 35;\nint csum[maxh][maxw];\nvoid init(VVI vec) {\n  assert(vec.size());\n  REP(i, vec.size()) REP(j, vec[0].size()) {\n    if(!i && !j) csum[i][j] = vec[i][j];\n    else if(!i) csum[i][j] = csum[i][j-1] + vec[i][j];\n    else if(!j) csum[i][j] = csum[i-1][j] + vec[i][j];\n    else csum[i][j] = csum[i-1][j] + csum[i][j-1] - csum[i-1][j-1] + vec[i][j];\n  }\n}\n// 閉区間, 0-indexedで矩形範囲の合計\nint cumsum(int sx, int sy, int gx, int gy) {\n  if(!sx && !sy) return csum[gy][gx];\n  if(!sx) return csum[gy][gx] - csum[sy-1][gx];\n  if(!sy) return csum[gy][gx] - csum[gy][sx-1];\n  return csum[gy][gx] - csum[gy][sx-1] - csum[sy-1][gx] + csum[sy-1][sx-1];\n}\n\nint h, w, s;\nPII dp[35][35][35][35];\nPII func(int sx, int sy, int gx, int gy) {\n  if(dp[sx][sy][gx][gy] != PII{-1, -1}) return dp[sx][sy][gx][gy];\n  // 分割しなかったとしても条件を満たさない\n  if(cumsum(0, 0, w-1, h-1) - cumsum(sx, sy, gx, gy) > s) return {-1, -1};\n  // 分割しない\n  int group = 1, ret = cumsum(sx, sy, gx, gy);\n  // 縦で割る\n  FOR(i, sx, gx) {\n    PII vl = func(sx, sy, i, gy);\n    PII vr = func(i+1, sy, gx, gy);\n    if(group < vl.first + vr.first || (group == vl.first+vr.first && ret < min(vl.second, vr.second))) {\n      group = vl.first + vr.first;\n      ret = min(vl.second, vr.second);\n    }\n  }\n  // 横で割る\n  FOR(i, sy, gy) {\n    PII vl = func(sx, sy, gx, i);\n    PII vr = func(sx, i+1, gx, gy);\n    if(group < vl.first + vr.first || (group == vl.first+vr.first && ret < min(vl.second, vr.second))) {\n      group = vl.first + vr.first;\n      ret = min(vl.second, vr.second);\n    }\n  }\n  return dp[sx][sy][gx][gy] = {group, ret};\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> h >> w >> s;\n    if(!h) break;\n    VVI vec(h, VI(w));\n    REP(i, h) REP(j, w) cin >> vec[i][j];\n\n    // 累積和,dp配列の初期化\n    init(vec);\n    REP(i1, 35) REP(i2, 35) REP(i3, 35) REP(i4, 35) dp[i1][i2][i3][i4] = {-1, -1};\n\n    PII ret = func(0, 0, w-1, h-1);\n    cout << ret.first << \" \" << s - cumsum(0,0,w-1,h-1) + ret.second << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int h,w,s;\n        cin >> h >> w >> s;\n        if(h==0 and w==0 and s==0) break;\n\n        vector<vector<int>> u(h,vector<int>(w));\n        rep(i,0,h) rep(j,0,w) cin >> u[i][j];\n\n        vector<vector<int>> sum(h,vector<int>(w,0));\n        rep(y,0,h){\n            sum[y][0]=u[y][0];\n            rep(x,1,w) sum[y][x]=sum[y][x-1]+u[y][x];\n        }\n        rep(x,0,w) rep(y,1,h) sum[y][x]=sum[y-1][x]+sum[y][x];\n        auto calc_sum=[&](const int y1,const int x1,const int y2,const int x2){\n            int res=sum[y2][x2];\n            if(y1!=0) res-=sum[y1-1][x2];\n            if(x1!=0) res-=sum[y2][x1-1];\n            if(y1!=0 and x1!=0) res+=sum[y1-1][x1-1];\n            return res;\n        };\n\n        static int memo1[32][32][32][32];\n        static int memo2[32][32][32][32];\n        fill_n((int*)memo1,32*32*32*32,0);\n        fill_n((int*)memo2,32*32*32*32,inf);\n        rep(i,0,h) rep(j,0,w){\n            memo1[i][j][i][j]=1;\n            memo2[i][j][i][j]=u[i][j];\n        }\n        const int all=calc_sum(0,0,h-1,w-1);\n        function<pii(int,int,int,int)> rec=[&](const int y1,const int x1,const int y2,const int x2){\n            int& res1=memo1[y1][x1][y2][x2],& res2=memo2[y1][x1][y2][x2];\n            if(res1!=0) return make_pair(res1,res2);\n            res1=1;\n            res2=calc_sum(y1,x1,y2,x2);\n            rep(y,y1,y2){\n                if(all-calc_sum(y1,x1,y,x2)>s or all-calc_sum(y+1,x1,y2,x2)>s) continue;\n                const auto tmp1=rec(y1,x1,y,x2),tmp2=rec(y+1,x1,y2,x2);\n                if(tmp1.first+tmp2.first>res1){\n                    res1=tmp1.first+tmp2.first;\n                    res2=min(tmp1.second,tmp2.second);\n                }else if(tmp1.first+tmp2.first==res1) res2=max(res2,min(tmp1.second,tmp2.second));\n            }\n            rep(x,x1,x2){\n                if(all-calc_sum(y1,x1,y2,x)>s or all-calc_sum(y1,x+1,y2,x2)>s) continue;\n                const auto tmp1=rec(y1,x1,y2,x),tmp2=rec(y1,x+1,y2,x2);\n                if(tmp1.first+tmp2.first>res1){\n                    res1=tmp1.first+tmp2.first;\n                    res2=min(tmp1.second,tmp2.second);\n                }else if(tmp1.first+tmp2.first==res1) res2=max(res2,min(tmp1.second,tmp2.second));\n            }\n            return make_pair(res1,res2);\n        };\n        auto ans=rec(0,0,h-1,w-1);\n        cout << ans.first << \" \" << s-(all-ans.second) << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; double w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 100;\n\nint h, w, s;\nint u[32][32], sum[33][33];\nint num[33][33][33][33], cap[33][33][33][33];\n\nvoid f(int u, int d, int l, int r) {\n\tif (num[u][d][l][r] != -1) return;\n\tint z = sum[d][r] - sum[d][l] - sum[u][r] + sum[u][l];\n\tint x = 1, y = s - (sum[h][w] - z);\n\tfor (int j = l + 1; j <= r - 1; j++) {\n\t\tf(u, d, l, j); f(u, d, j, r);\n\t\tint _x = num[u][d][l][j] + num[u][d][j][r];\n\t\tint _y = min(cap[u][d][l][j], cap[u][d][j][r]);\n\t\tif (_y >= 0 && (_x > x || (_x == x && _y > y))) {\n\t\t\tx = _x; y = _y;\n\t\t}\n\t}\n\tfor (int i = u + 1; i <= d - 1; i++) {\n\t\tf(u, i, l, r); f(i, d, l, r);\n\t\tint _x = num[u][i][l][r] + num[i][d][l][r];\n\t\tint _y = min(cap[u][i][l][r], cap[i][d][l][r]);\n\t\tif (_y >= 0 && (_x > x || (_x == x && _y > y))) {\n\t\t\tx = _x; y = _y;\n\t\t}\n\t}\n\tnum[u][d][l][r] = x; cap[u][d][l][r] = y;\n}\n\nint main() {\n\tfor (;;) {\n\t\tcin >> h >> w >> s;\n\t\tif (h == 0) break;\n\t\tfill_n((int*)sum, 33*33, 0);\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + u[i][j];\n\t\t\t}\n\t\tfill_n((int*)num, 33*33*33*33, -1);\n\t\tfill_n((int*)cap, 33*33*33*33, -1);\n\t\tf(0, h, 0, w);\n\t\tcout << num[0][h][0][w] << ' ' << cap[0][h][0][w] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ¶ãÌÀWÆEºÌÀWÅÍÍðwèµA±ÌÍÍÌÅåO[vðL¯\npair<int,int> dp[32][32][32][32];\nint h,w,s;\nint field[32][32];\nint sumDemand;\n\nint maxPre=0;\n\npair<int,int> dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[miny][minx][maxy][maxx].first!=-1)\n\t\treturn dp[miny][minx][maxy][maxx];\n\t// »ÝÌêðâd³¹½Æ«ÉAùvªð´¦È¢©Ç¤©\n\tint decDemand=0;\n\tfor(int i = miny; i <= maxy; i++){\n\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\tdecDemand+=field[i][j];\n\t\t}\n\t}\n\tif(sumDemand - decDemand > s){\n\t\treturn make_pair(-1,0);\n\t}\n\n\tint pre=sumDemand-decDemand;\n\n\tpair<int,int> maxGroup;\n\tmaxGroup.first=1;\n\tmaxGroup.second=pre;\n\n\t// «èû·×Äð·\n\t// ¡Øè\n\tfor(int i = miny; i < maxy; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,maxx,i);\n\t\tpair<int,int> ret2=dfs(minx,i+1,maxx,maxy);\n\t\t// ±Ì«èûÍsÂ\\\n\t\tif(ret1.first==-1||ret2.first==-1)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\n\t}\n\t// tateØè\n\tfor(int i = minx; i < maxx; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,i,maxy);\n\t\tpair<int,int> ret2=dfs(i+1,miny,maxx,maxy);\n\t\tif(ret1.first==-1||ret2.first==-2)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t}\n\tdp[miny][minx][maxy][maxx]=maxGroup;\n\treturn maxGroup;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&!(h==0&&s==0&&w==0)){\n\t\tfor(int i = 0; i < 32; i++)\n\t\t\tfor(int j = 0; j < 32; j++)\n\t\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t\t\tfill(dp[i][j][k],dp[i][j][k]+32,make_pair(-1,-1));\n\t\tsumDemand=0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tsumDemand+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mxg=dfs(0,0,w-1,h-1);\n\t\tcout<<mxg.first<<\" \"<<s-mxg.second<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> result;\nint h,w,s;\nresult dp[33][33][33][33];\nbool done[33][33][33][33];\nint sum[33][33];\nint g[33][33];\n\nint get(int a,int b,int c,int d)\n{\n  return sum[d][c]-sum[b][c]-sum[d][a]+sum[b][a];\n}\n\nresult solve(int a,int b,int c,int d)\n{\n  result& res = dp[a][b][c][d];\n  if( done[a][b][c][d] ) return res;\n  res = result(1,s-(get(0,0,w,h)-get(a,b,c,d)));\n  //printf(\"%d %d %d %d\\n\",a,b,c,d);\n  if( res.second < 0 ) res = result(0,0);\n  for( int i = a+1; i < c; i++ ) {\n    result p = solve(a,b,i,d);\n    result q = solve(i,b,c,d);\n    res = max(res,result(p.first+q.first,min(p.second,q.second)));\n  }\n  for( int i = b+1; i < d; i++ ) {\n    result p = solve(a,b,c,i);\n    result q = solve(a,i,c,d);\n    res = max(res,result(p.first+q.first,min(p.second,q.second)));\n  }\n  done[a][b][c][d] = true;\n  return res;\n}\n\nint main(void)\n{\n  scanf(\"%d%d%d\",&h,&w,&s);\n  for( int i = 0; i < h; i++ ) {\n    for( int j = 0; j < w; j++ ) {\n      scanf(\"%d\", g[i]+j);\n    }\n  }\n  for( int i = 0; i < h; i++ ) {\n    for( int j = 0; j < w; j++ ) {\n      sum[i+1][j+1] = sum[i+1][j]+g[i][j];\n    }\n  }\n  for( int i = 0; i < h; i++ ) {\n    for( int j = 0; j <= w; j++ ) {\n      sum[i+1][j] += sum[i][j];\n    }\n  }\n  memset(done,0,sizeof(done));\n  result res = solve(0,0,w,h);\n  printf(\"%d %d\\n\",res.first,res.second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nstruct dat{\n\tint gr, mn;\n\tbool operator <(const dat &r) const{\n\t\tif (gr != r.gr) return gr < r.gr;\n\t\treturn mn < r.mn;\n\t}\n};\n\nconst int N = 33;\n\nbool ok[N][N][N][N];\ndat dp[N][N][N][N];\nint v[N][N];\nint sum[N][N];\nint Min;\n\ninline int rect(int t, int l, int b, int r){\n\treturn sum[b][r] - sum[b][l] - sum[t][r] + sum[t][l];\n}\n\ndat rec(int t, int l, int b, int r){\n\tdat &res = dp[t][l][b][r];\n\tif (ok[t][l][b][r]) return res;\n\tok[t][l][b][r] = true;\n\tres = {1, rect(t, l, b, r)};\n\n\t// tate\n\tfor (int i = t + 1; i < b; ++i){\n\t\tif (rect(t, l, i, r) < Min) continue;\n\t\tif (rect(i, l, b, r) < Min) continue;\n\t\tdat r1 = rec(t, l, i, r);\n\t\tdat r2 = rec(i, l, b, r);\n\t\tdat tmp = { r1.gr + r2.gr, min(r1.mn, r2.mn) };\n\t\tres = max(res, tmp);\n\t}\n\n\t// yoko\n\tfor (int j = l + 1; j < r; ++j){\n\t\tif (rect(t, l, b, j) < Min) continue;\n\t\tif (rect(t, j, b, r) < Min) continue;\n\t\tdat r1 = rec(t, l, b, j);\n\t\tdat r2 = rec(t, j, b, r);\n\t\tdat tmp = { r1.gr + r2.gr, min(r1.mn, r2.mn) };\n\t\tres = max(res, tmp);\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint h, w, sup;\n\twhile (cin >> h >> w >> sup, h){\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\tcin >> v[i][j];\n\t\tfor (int i = 1; i <= h; ++i)\n\t\t\tfor (int j = 1; j <= w; ++j)\n\t\t\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i - 1][j - 1];\n\n\t\tMin = sum[h][w] - sup;\n\t\tmemset(ok, 0, sizeof(ok));\n\t\tauto res = rec(0, 0, h, w);\n\t\tcout << res.gr << ' ' << res.mn - Min << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\ntypedef vector<PII> VP;\ntypedef vector<VP> VVP;\ntypedef vector<VVP> VVVP;\ntypedef vector<VVVP> VVVVP;\n\nstruct Solver\n{\n\tconst int H, W, S;\n\tVVI board, csum;\n\tVVVVP dp;\n\n\tSolver( int h, int w, int s ) :\n\t\tH( h ), W( w ), S( s ),\n\t\tboard( H, VI( W ) ),\n\t\tcsum( H + 1, VI( 1, 0 ) ),\n\t\tdp( H, VVVP( W, VVP( H, VP( W, MP( -1, -1 ) ) ) ) )\n\t{\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tREP( j, 0, W )\n\t\t\t{\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tpartial_sum( ALL( board[i] ), back_inserter( csum[ i + 1 ] ) );\n\t\t}\n\t\tcsum[0].resize( W + 1, 0 );\n\t\tREP( x, 0, W + 1 )\n\t\t{\n\t\t\tREP( y, 0, H )\n\t\t\t{\n\t\t\t\tcsum[ y + 1 ][x] += csum[y][x];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tPII solve()\n\t{\n\t\treturn rec( 0, 0, H - 1, W - 1 );\n\t}\n\n\tPII rec( int y1, int x1, int y2, int x2 )\n\t{\n\t\tPII &memoized = dp[ y1 ][ x1 ][ y2 ][ x2 ];\n\t\tif ( memoized.fst != -1 )\n\t\t{\n\t\t\treturn memoized;\n\t\t}\n\n\t\tif ( S < areaSum( 0, 0, H - 1, W - 1 ) - areaSum( y1, x1, y2, x2 ) )\n\t\t{\n\t\t\treturn MP( -1, -1 );\n\t\t}\n\n\t\tPII res = MP( -1, -1 );\n\t\tREP( ix, x1, x2 )\n\t\t{\n\t\t\tPII cut1 = rec( y1, x1, y2, ix );\n\t\t\tPII cut2 = rec( y1, ix + 1, y2, x2 );\n\t\t\t\n\t\t\tif ( min( cut1, cut2 ).fst == -1 )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres = max( res, MP( cut1.fst + cut2.fst, min( cut1.snd, cut2.snd ) ) );\n\t\t}\n\n\t\tREP( iy, y1, y2 )\n\t\t{\n\t\t\tPII cut1 = rec( y1, x1, iy, x2 );\n\t\t\tPII cut2 = rec( iy + 1, x1, y2, x2 );\n\n\t\t\tif ( min( cut1, cut2 ).fst == -1 )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tres = max( res, MP( cut1.fst + cut2.fst, min( cut1.snd, cut2.snd ) ) );\n\t\t}\n\n\t\t\n\t\tif ( res.fst == -1 )\n\t\t{\n\t\t\treturn memoized = MP( 1, S - ( areaSum( 0, 0, H - 1, W - 1 ) - areaSum( y1, x1, y2, x2 ) ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn memoized = res;\n\t\t}\n\t}\n\n\tint areaSum( int y1, int x1, int y2, int x2 )\n\t{\n\t\treturn csum[ y2 + 1 ][ x2 + 1 ] - csum[ y1 ][ x2 + 1 ] - csum[ y2 + 1 ][ x1 ] + csum[ y1 ][ x1 ];\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint h, w, s;\n\t\tcin >> h >> w >> s;\n\n\t\tif ( !( h | w | s ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tPII res( Solver( h, w, s ).solve() );\n\t\tcout << res.fst << ' ' << res.snd << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n\n\n#endif // 0\n\n#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int MAXN = (int) 35;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\nint H,W,S;\nint f[MAXN][MAXN][MAXN][MAXN];\nint g[MAXN][MAXN][MAXN][MAXN];\nint a[MAXN][MAXN];\nint TOTAL;\nint MI;\n\nint get_sum(int i,int j,int k,int t){\n    return a[k][t]-a[k][j-1]-a[i-1][t]+a[i-1][j-1];\n}\n\nvoid DFS(int I,int J,int K,int T){\n    f[I][J][K][T]=1;\n    g[I][J][K][T]=get_sum(I,J,K,T);\n    if(I==K&&J==T) return;\n    if(g[I][J][K][T]<MI) return;\n    for(int i=I;i<K;i++){\n        if(f[I][J][i][T]==-1) DFS(I,J,i,T);\n        if(f[i+1][J][K][T]==-1) DFS(i+1,J,K,T);\n        if(g[I][J][i][T]>=MI&&g[i+1][J][K][T]>=MI){\n            if(f[I][J][i][T]+f[i+1][J][K][T]>f[I][J][K][T]){\n                f[I][J][K][T]=f[I][J][i][T]+f[i+1][J][K][T];\n                g[I][J][K][T]=min(g[I][J][i][T],g[i+1][J][K][T]);\n            }\n            else if(f[I][J][i][T]+f[i+1][J][K][T]==f[I][J][K][T]){\n                int cur_mi=min(g[I][J][i][T],g[i+1][J][K][T]);\n                g[I][J][K][T]=max(g[I][J][K][T],cur_mi);\n            }\n        }\n    }\n    for(int j=J;j<T;j++){\n        if(f[I][J][K][j]==-1) DFS(I,J,K,j);\n        if(f[I][j+1][K][T]==-1) DFS(I,j+1,K,T);\n        if(g[I][J][K][j]>=MI&&g[I][j+1][K][T]>=MI){\n            if(f[I][J][K][j]+f[I][j+1][K][T]>f[I][J][K][T]){\n                f[I][J][K][T]=f[I][J][K][j]+f[I][j+1][K][T];\n                g[I][J][K][T]=min(g[I][J][K][j],g[I][j+1][K][T]);\n            }\n            else if(f[I][J][K][j]+f[I][j+1][K][T]==f[I][J][K][T]){\n                int cur_mi=min(g[I][J][K][j],g[I][j+1][K][T]);\n                g[I][J][K][T]=max(g[I][J][K][T],cur_mi);\n            }\n        }\n    }\n}\n\nvoid work(){\n    while(~scanf(\"%d%d%d\",&H,&W,&S)){\n        if(H==0&&W==0&&S==0) break;\n        TOTAL=0;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                scanf(\"%d\",&a[i][j]);\n                TOTAL+=a[i][j];\n                a[i][j]+=a[i][j-1];\n            }\n        }\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                a[i][j]+=a[i-1][j];\n            }\n        }\n//        for(int i=1;i<=H;i++){\n//            for(int j=1;j<=W;j++){\n//                printf(\"%d \",a[i][j]);\n//            }\n//            printf(\"\\n\");\n//        }\n        MI=TOTAL-S;\n        memset(f,-1,sizeof(f));\n        memset(g,-1,sizeof(g));\n        DFS(1,1,H,W);\n        printf(\"%d %d\\n\",f[1][1][H][W],g[1][1][H][W]-MI);\n    }\n}\n\nint main(){\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\n#define double long double\nconst int mod=1000000007,MAX=35,INF=1<<29;\npair<int,int> dp[MAX][MAX][MAX][MAX];\nbool seen[MAX][MAX][MAX][MAX];\nint H,W,need;\n\nstruct ruirui{\n    vector<vector<ll>> T;\n    \n    void init(vector<vector<ll>> &S){\n        T.clear();\n        int H=S.size(),W=S[0].size();\n        T.resize(H+1);\n        for(int i=0;i<=H;i++) T[i].resize(W+1);\n        \n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                T[i][j]=S[i-1][j-1];\n            }\n        }\n        for(int i=0;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                T[i][j]+=T[i][j-1];\n            }\n        }\n        for(int j=0;j<=W;j++){\n            for(int i=1;i<=H;i++){\n                T[i][j]+=T[i-1][j];\n            }\n        }\n    }\n    \n    ll query(int u,int d,int l,int r){\n        return T[d+1][r+1]+T[u][l]-T[d+1][l]-T[u][r+1];\n    }//u<=i<=d,l<=j<=rの和を返す\n};\n\nruirui T;\n\npair<int,int> solve(int u,int d,int l,int r){\n    if(seen[u][d][l][r]) return dp[u][d][l][r];\n    \n    seen[u][d][l][r]=1;\n    \n    pair<int,int> ret;\n    \n    if(T.query(u,d-1,l,r-1)>=need) ret={1,T.query(u,d-1,l,r-1)};\n    else ret={0,0};\n    \n    if(d-u>=2){\n        for(int i=u+1;i<d;i++){\n            auto a=solve(u,i,l,r),b=solve(i,d,l,r);\n            auto c=make_pair(a.fi+b.fi,min(a.se,b.se));\n            if(ret.fi<c.fi) ret=c;\n            else if(ret.fi==c.fi) chmax(ret.se,c.se);\n        }\n    }\n    \n    if(r-l>=2){\n        for(int j=l+1;j<r;j++){\n            auto a=solve(u,d,l,j),b=solve(u,d,j,r);\n            auto c=make_pair(a.fi+b.fi,min(a.se,b.se));\n            if(ret.fi<c.fi) ret=c;\n            else if(ret.fi==c.fi) chmax(ret.se,c.se);\n        }\n    }\n    \n    return dp[u][d][l][r]=ret;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int S=0,sum=0;\n        cin>>H>>W>>S;\n        if(H+W==0) break;\n        vector<vector<ll>> A(H,vector<ll>(W));\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>A[i][j];\n                sum+=A[i][j];\n            }\n        }\n        T.init(A);\n        need=sum-S;\n        memset(dp,0,sizeof(dp));\n        memset(seen,0,sizeof(seen));\n        \n        auto a=solve(0,H,0,W);\n        cout<<a.fi<<\" \"<<a.se-need<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint H, W, S, U[35][35];\nint sum[35][35][35][35];\npair<int, int> dp[35][35][35][35];\n//dp[y1][x1][y2][x2]: [(y1,x1),(y2,x2)]??? ????????¢??? <?????§??°???????????°, ?????????>\n//dp[0][0][H-1][W-1]??????????????????\n\npair<int, int> dfs(int y1, int x1, int y2, int x2){\n  if(dp[y1][x1][y2][x2].F != -INF){\n     return dp[y1][x1][y2][x2];\n  }\n\n  //first: ?????????????????¨????????????????????°??????????????¨??????????????°??????????????????????????¨??????????????????1?????\\??????\n  //second: ????????????????????°??????????????£?????´??????????????????????????\\????????????\n  pair<int, int> ret = make_pair(1, S-(sum[0][0][H-1][W-1]-sum[y1][x1][y2][x2]));\n\n  //?????´??????\n  for(int cutx=x1; cutx<x2; cutx++){\n    int suml = sum[y1][x1][y2][cutx];\n    int sumr = sum[y1][cutx+1][y2][x2];\n    if(sum[0][0][H-1][W-1]-suml > S || sum[0][0][H-1][W-1]-sumr > S) continue;\n    pair<int, int>  l = dfs(y1,x1,y2,cutx);\n    pair<int, int>  r = dfs(y1,cutx+1,y2,x2);\n    pair<int, int> tmp = make_pair(l.F+r.F, min(l.S,r.S));  //???????????????????????§?¨?????????????\n    ret = max(ret, tmp);  //F->S????????§????????????????????§????????§OK\n  }\n\n  //?°´?????????\n  for(int cuty=y1; cuty<y2; cuty++){\n    int suml = sum[y1][x1][cuty][x2];\n    int sumr = sum[cuty+1][x1][y2][x2];\n    if(sum[0][0][H-1][W-1]-suml > S || sum[0][0][H-1][W-1]-sumr > S) continue;\n    pair<int, int>  l = dfs(y1,x1,cuty,x2);\n    pair<int, int>  r = dfs(cuty+1,x1,y2,x2);\n    pair<int, int> tmp = make_pair(l.F+r.F, min(l.S,r.S));  //???????????????????????§?¨?????????????\n    ret = max(ret, tmp);  //F->S????????§????????????????????§????????§OK\n  }\n\n  //???????????§??\\???????????§?????????????????????????????????????????????????±???????????????§???\n  //????????§dp?????\\??????????????????????????????????????????????????????????????????????????????????????¢?´¢?????????dp?????????????????§?????????\n  return dp[y1][x1][y2][x2] = ret;\n}\n\n\nint main() {\n  while(1){\n    cin>>H>>W>>S;\n    if(H==0&&W==0&&S==0) break;\n    REP(i,0,H){\n      REP(j,0,W){\n        cin>>U[i][j];\n      }\n    }\n    //????????????????¨?????????????????????????\n    REP(i,0,H){\n      REP(j,0,W){\n        REP(ranH,0,H-i)REP(ranW,0,W-j){\n          int tmp = 0;\n          REP(k,i,i+ranH+1){\n            REP(l,j,j+ranW+1){\n              tmp += U[k][l];\n            }\n          }\n          sum[i][j][i+ranH][j+ranW] = tmp;\n        }\n      }\n    }\n    //?????????\n    REP(i,0,H){\n      REP(j,0,W){\n        REP(k,0,H){\n          REP(l,0,W){\n            dp[i][j][k][l] = make_pair(-INF,-INF);\n          }\n        }\n      }\n    }\n\n    pair<int, int> ans = dfs(0,0,H-1,W-1);\n    cout<<ans.F<<\" \"<<ans.S<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint H, W, S;\nint U[32][32];\nint UU[33][33];\n\nint getUsum(int sx, int sy, int tx, int ty)\n{\n\treturn (UU[ty + 1][tx + 1] - UU[ty + 1][sx] - UU[sy][tx + 1] + UU[sy][sx]);\n}\n\nint Usum, Glimit;\n\nbool ismemo[32][32][32][32];\npair<int, int> memo[32][32][32][32];\n\npair<int, int> rec(int sx, int sy, int tx, int ty)\n{\n\tif (ismemo[sx][sy][tx][ty]) return memo[sx][sy][tx][ty];\n\n\tif (getUsum(sx, sy, tx, ty) < Glimit)\n\t{\n\t\tismemo[sx][sy][tx][ty] = true;\n\t\treturn memo[sx][sy][tx][ty] = pair<int, int>(0, INF);\n\t}\n\n\tpair<int, int> ans(1, getUsum(sx, sy, tx, ty));\n\trep(x, sx, tx)\n\t{\n\t\tauto le = rec(sx, sy, x, ty);\n\t\tif (le.first == 0) continue;\n\t\tauto ri = rec(x + 1, sy, tx, ty);\n\t\tif (ri.first == 0) continue;\n\n\t\tint gnum = le.first + ri.first;\n\t\tint sum = min(le.second, ri.second);\n\n\t\tif (ans.first <= gnum)\n\t\t{\n\t\t\tans.first = gnum;\n\t\t\tans.second = min(ans.second, sum);\n\t\t}\n\t}\n\n\trep(y, sy, ty)\n\t{\n\t\tauto le = rec(sx, sy, tx, y);\n\t\tif (le.first == 0) continue;\n\t\tauto ri = rec(sx, y + 1, tx, ty);\n\t\tif (ri.first == 0) continue;\n\n\t\tint gnum = le.first + ri.first;\n\t\tint sum = min(le.second, ri.second);\n\n\t\tif (ans.first <= gnum)\n\t\t{\n\t\t\tans.first = gnum;\n\t\t\tans.second = min(ans.second, sum);\n\t\t}\n\t}\n\n\tismemo[sx][sy][tx][ty] = true;\n\treturn memo[sx][sy][tx][ty] = ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> H >> W >> S)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(y, 0, H) rep(x, 0, W) cin >> U[y][x];\n\t\trep(y, 0, H + 1) rep(x, 0, W + 1) UU[y][x] = 0;\n\t\trep(y, 1, H + 1) rep(x, 1, W + 1) UU[y][x] = U[y - 1][x - 1] + UU[y - 1][x] + UU[y][x - 1] - UU[y - 1][x - 1];\n\n\t\tUsum = getUsum(0, 0, W - 1, H - 1);\n\t\tGlimit = Usum - S;\n\n\t\trep(i, 0, 32) rep(ii, 0, 32) rep(j, 0, 32) rep(jj, 0, 32) ismemo[i][ii][j][jj] = false;\n\t\tauto ans = rec(0, 0, W - 1, H - 1);\n\n\t\tcout << ans.first << \" \" << (ans.second - Glimit) << endl;\n\n\t\t//return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++) \nint h,w,s,u[200][200];\nint c[40][40][40][40];\nint mini,sum;\nint INF = 1e9;\n#define fi first\n#define sc second\n\ntypedef pair<int,int> P;\n\nint cou(int mh,int mw,int Mh,int Mw) {\n    int ret = 0;\n    FOR(i,mh,Mh) {\n        FOR(j,mw,Mw) {\n            ret += u[i][j];\n        }\n    }\n    return ret;\n}\n\nbool used[40][40][40][40];\nP memo[40][40][40][40];\n\nP solve(int mh,int mw,int Mh,int Mw) {\n    //cerr << mh << \" \" << mw << \" \" << Mh << \" \" << Mw << endl;\n\n    if(c[mh][mw][Mh][Mw] < mini) {\n        used[mh][mw][Mh][Mw] = true;\n        return memo[mh][mw][Mh][Mw] = P(-INF,0);\n    }\n\n    if(used[mh][mw][Mh][Mw]) {\n        return memo[mh][mw][Mh][Mw];\n    }\n\n    P ret(P(1,max(sum - c[mh][mw][Mh][Mw],0)));\n\n    FOR(i,mh,Mh-1) {\n        P p = solve(mh,mw,i+1,Mw);\n        P q = solve(i+1,mw,Mh,Mw);\n\n        p.fi += q.fi;\n        p.sc = max(p.sc,q.sc);\n\n        if(ret.fi != p.fi) ret = (p.fi > ret.fi) ? p : ret;\n        else ret = (p.sc < ret.sc) ? p : ret;\n    }\n    FOR(i,mw,Mw-1) {\n        P p = solve(mh,mw,Mh,i+1);\n        P q = solve(mh,i+1,Mh,Mw);\n        p.fi += q.fi;\n        p.sc = max(p.sc,q.sc);\n\n        if(ret.fi != p.fi) ret = (p.fi > ret.fi) ? p : ret;\n        else ret = (p.sc < ret.sc) ? p : ret;\n    }\n    used[mh][mw][Mh][Mw] = true;\n    return memo[mh][mw][Mh][Mw] = ret;\n}\n\nint main() {\n    while(true) {\n        cin >> h >> w >> s;\n        if(h == 0)\n            break;\n\n        rep(i,h)rep(j,w) cin >> u[i][j];\n        rep(i,h)rep(j,w)FOR(k,i+1,h+1)FOR(l,j+1,w+1)c[i][j][k][l] = cou(i,j,k,l);\n\n        rep(i,h+1)rep(j,w+1)rep(k,h+1)rep(l,w+1)used[i][j][k][l] = false;\n\n        mini = c[0][0][h][w] - s;\n        sum = c[0][0][h][w];\n        P ans = solve(0,0,h,w);\n        cout << ans.fi << \" \" << s - ans.sc << endl;\n    } \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define rep(i,from,to) for(int i=from; i<to; ++i)\n#define REP(i,from,to) for(int i=from; i<=to; ++i)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, P> area;\ntypedef struct answer answer;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nstruct answer {\n\tint group, yobi;\n\tanswer(int group, int yobi) {\n\t\tthis->group = group;\n\t\tthis->yobi = yobi;\n\t}\n\tanswer() {\n\t\t*this = answer(1, 0);\n\t}\n\tbool operator<(const answer& a) const {\n\t\tif (group == a.group) {\n\t\t\treturn yobi < a.yobi;\n\t\t} else {\n\t\t\treturn group < a.group;\n\t\t}\n\t}\n\tbool operator==(const answer& a) const {\n\t\treturn group == a.group && yobi == a.yobi;\n\t}\n\tbool operator!=(const answer& a) const {\n\t\treturn !(*this == a);\n\t}\n};\n\nint h, w, s;\nconst int maxh = 33;\nint g[maxh][maxh];\nint sum[maxh][maxh];\nint total;\nanswer dp[maxh][maxh][maxh][maxh];\nconst answer INIT = answer(1, 0);\nint totalpower(area a) {\n\tP &p1 = a.first, &p2 = a.second;\n\tint i1 = p1.first, j1 = p1.second;\n\tint i2 = p2.first, j2 = p2.second;\n\treturn sum[i2][j2] - sum[i1 - 1][j2] - sum[i2][j1 - 1] + sum[i1 - 1][j1 - 1];\n}\n\nanswer dfs(area a, int restpower) { //rest: ???????????????\n\tP &p1 = a.first, &p2 = a.second;\n\tint i1 = p1.first, j1 = p1.second;\n\tint i2 = p2.first, j2 = p2.second;\n//\tprintf(\"area: (%d, %d) , (%d, %d)\\nrestpower: %d\\n\\n\", i1, j1, i2, j2,\n//\t\t\trestpower);\n\tif (dp[i1][j1][i2][j2] != INIT) {\n\t\treturn dp[i1][j1][i2][j2];\n\t}\n\tanswer ret = answer(1, restpower);\n\trep(j, j1, j2)\n\t{\n\t\tarea left = area(P(i1, j1), P(i2, j));\n\t\tarea right = area(P(i1, j + 1), P(i2, j2));\n\t\tint powL = totalpower(left), powR = totalpower(right);\n\t\tint restL = restpower - powR, restR = restpower - powL;\n\t\tif (restL >= 0 && restR >= 0) {\n\t\t\tanswer L = dfs(left, restL);\n\t\t\tanswer R = dfs(right, restR);\n\t\t\tanswer tmp = answer(L.group + R.group, min(L.yobi, R.yobi));\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\n\trep(i, i1, i2)\n\t{\n\t\tarea upper = area(P(i1, j1), P(i, j2));\n\t\tarea down = area(P(i + 1, j1), P(i2, j2));\n\t\tint powP = totalpower(upper), powN = totalpower(down);\n\t\tint restP = restpower - powN, restN = restpower - powP;\n\t\tif (restP >= 0 && restN >= 0) {\n\t\t\tanswer UP = dfs(upper, restP);\n\t\t\tanswer DOWN = dfs(down, restN);\n\t\t\tanswer tmp = answer(UP.group + DOWN.group, min(UP.yobi, DOWN.yobi));\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn dp[i1][j1][i2][j2] = ret;\n}\n\nvoid solve() {\n\twhile (cin >> h >> w >> s, h || w || s) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tvector<area> sep;\n\t\tREP(i, 1, h)\n\t\t{\n\t\t\tREP(j,1,w)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tsum[1][1] = g[1][1];\n\t\tREP(i, 1, h)\n\t\t{\n\t\t\tREP(j,1,w)\n\t\t\t{\n\t\t\t\tif (i == 1 && j == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]\n\t\t\t\t\t\t+ g[i][j];\n\t\t\t}\n\t\t}\n\t\tarea whole = area(P(1, 1), P(h, w));\n\t\ttotal = totalpower(whole);\n\t\tanswer ans = dfs(whole, s);\n//\t\tcout << \"group: \" << ans.group << endl;\n//\t\tcout << \"yobi: \" << ans.yobi << endl;\n\t\tcout << ans.group << \" \" << ans.yobi << endl;\n\t}\n\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> result;\nint h,w,s;\nresult dp[33][33][33][33];\nbool done[33][33][33][33];\nint sum[33][33];\nint g[33][33];\n\nint get(int a,int b,int c,int d)\n{\n  return sum[d][c]-sum[b][c]-sum[d][a]+sum[b][a];\n}\n\nresult solve(int a,int b,int c,int d)\n{\n  result& res = dp[a][b][c][d];\n  if( done[a][b][c][d] ) return res;\n  res = result(1,s-(get(0,0,w,h)-get(a,b,c,d)));\n  //printf(\"%d %d %d %d\\n\",a,b,c,d);\n  if( res.second < 0 ) res = result(0,0);\n  for( int i = a+1; i < c; i++ ) {\n    result p = solve(a,b,i,d);\n    result q = solve(i,b,c,d);\n    res = max(res,result(p.first+q.first,min(p.second,q.second)));\n  }\n  for( int i = b+1; i < d; i++ ) {\n    result p = solve(a,b,c,i);\n    result q = solve(a,i,c,d);\n    res = max(res,result(p.first+q.first,min(p.second,q.second)));\n  }\n  done[a][b][c][d] = true;\n  return res;\n}\n\nint main(void)\n{\n  scanf(\"%d%d%d\",&h,&w,&s);\n  for( int i = 0; i < h; i++ ) {\n    for( int j = 0; j < w; j++ ) {\n      scanf(\"%d\", g[i]+j);\n    }\n  }\n  for( int i = 0; i < h; i++ ) {\n    for( int j = 0; j < w; j++ ) {\n      sum[i+1][j+1] = sum[i+1][j]+g[i][j];\n    }\n  }\n  for( int i = 0; i < h; i++ ) {\n    for( int j = 0; j <= w; j++ ) {\n      sum[i+1][j] += sum[i][j];\n    }\n  }\n  memset(done,0,sizeof(done));\n  result res = solve(0,0,w,h);\n  if( w == 1 && h == 1 ) res = result(1,0);\n  printf(\"%d %d\\n\",res.first,res.second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, S;\nvector< vector<int> > A;\nbool m1[40][40][40][40];\nP m2[40][40][40][40];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, S-(getM(0, 0, W, H) - getM(x1, y1, x2, y2)));\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> S, H || W || S) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[39][39][40], false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<long long int>>M;\n\nlong long int FIRSTCOST;\nlong long int H, W, S;\n\ntypedef pair<long long int, long long int> RETURN;\ntypedef pair<pair<long long int, long long int>, pair<long long int, long long int>> PPLLPLL;\n\nlong long int cost( PPLLPLL  P ) {\n\treturn M[P.first.first][P.first.second] + M[P.second.first][P.second.second] - M[P.first.first][P.second.second] - M[P.second.first][P.first.second];\n}\n\nmap<PPLLPLL, RETURN>dp;\n\nRETURN saiki( PPLLPLL P ) {\n\tif( FIRSTCOST - cost( P ) > S ) {\n\t\treturn make_pair( -1, -1 );\n\t}\n\tif( dp.count( P ) != 0 ) {\n\t\treturn dp[P];\n\t}\n\t//cout << FIRSTCOST - cost( P ) << \" \" << S << endl;\n\tRETURN ret = make_pair( 1, S - (FIRSTCOST - cost( P )) );\n\tfor( size_t i = P.first.first + 1; i < P.second.first; i++ ) {\n\t\tPPLLPLL up = P, down = P;\n\t\tup.second.first = i;\n\t\tdown.first.first = i;\n\t\tauto retup = saiki( up );\n\t\tauto retdown = saiki( down );\n\t\tif( retup.first != -1 && retdown.first != -1 ) {\n\t\t\tRETURN retmemo = make_pair( retup.first + retdown.first, min( retup.second, retdown.second ) );\n\t\t\tif( ret.first < retmemo.first || (ret.first == retmemo.first&&ret.second < retmemo.second) ) {\n\t\t\t\tret = retmemo;\n\t\t\t}\n\t\t}\n\t}\n\tfor( size_t j = P.first.second + 1; j < P.second.second; j++ ) {\n\t\tPPLLPLL right = P, left = P;\n\t\tleft.second.second = j;\n\t\tright.first.second = j;\n\t\tauto retleft = saiki( left );\n\t\tauto retright = saiki( right );\n\t\tif( retleft.first != -1 && retright.first != -1 ) {\n\t\t\tRETURN retmemo = make_pair( retleft.first + retright.first, min( retleft.second, retright.second ) );\n\t\t\tif( ret.first < retmemo.first || (ret.first == retmemo.first&&ret.second < retmemo.second) ) {\n\t\t\t\tret = retmemo;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[P] = ret;\n}\n\nint main() {\n\twhile( cin >> H >> W >> S, H || W || S ) {\n\t\tdp.clear();\n\t\tM = vector<vector<long long int>>( H + 1, vector<long long int>( W + 1 ) );\n\t\tfor( size_t i = 1; i <= H; i++ ) {\n\t\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t i = 0; i < H + 1; i++ ) {\n\t\t\tfor( size_t j = 1; j < W + 1; j++ ) {\n\t\t\t\tM[i][j] += M[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\tfor( size_t i = 0; i < W + 1; i++ ) {\n\t\t\tfor( size_t j = 1; j < H + 1; j++ ) {\n\t\t\t\tM[j][i] += M[j - 1][i];\n\t\t\t}\n\t\t}\n\n\t\tPPLLPLL firstX = make_pair( make_pair( 0, 0 ), make_pair( H, W ) );\n\t\tFIRSTCOST = cost( firstX );\n\t\tauto ans = saiki( firstX );\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\n#define REP(i, x) for(int i=0;i<(int)(x);i++)\n#define REPS(i, x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i, x) for(int i=(int)(x)-1;i>=0;i--)\n#define RREPS(i, x) for(int i=(int)(x);i>0;i--)\n#define FOR(it, x) for(auto it=x.begin();it!=x.end();++it)\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nint d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v){\n        os << \"[\";\n        FOR(it, v) os << *it << \", \";\n        return os << \"]\";\n}\n\nint u[35][35];\nint sum[35][35];\nint H, W, s;\nint dp[35][35][35][35];\n\ninline int f(int x1, int y1, int x2, int y2){\n        return sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\ninline int g(int group, int power){\n        return (group<<16) | (s - power);\n}\n\ninline int comb(int x, int y){\n        if(x == -1 || y == -1) return -1;\n        return (((x>>16) + (y>>16)) << 16) + min(x&65535, y&65535);\n}\n\nint main(){\n        while(cin >> H >> W >> s, H){\n                memset(u, 0, sizeof(u));\n                memset(sum, 0, sizeof(sum));\n                REP(i, H)REP(j, W) cin >> u[i][j];\n                REPS(i, H)REPS(j, W){\n                        sum[i][j] = u[i-1][j-1] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n                }\n                int all = sum[H][W];\n                memset(dp, -1, sizeof(dp));\n                REPS(w, W)REPS(h, H)REP(y, H-h+1)REP(x, W-w+1){\n                        int &tar = dp[y][x][y+h][x+w];\n                        if(all - f(x, y, x+w, y+h) <= s) tar = g(1, all - f(x, y, x+w, y+h));\n                        for(int m=1;m<w;m++){\n                                tar = max(tar, comb(dp[y][x][y+h][x+m], dp[y][x+m][y+h][x+w]));\n                        }\n                        for(int m=1;m<h;m++){\n                                tar = max(tar, comb(dp[y][x][y+m][x+w], dp[y+m][x][y+h][x+w]));\n                        }\n                }\n                cout << (dp[0][0][H][W] >> 16) <<\" \" << (dp[0][0][H][W] & 65535) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 50\nint h,w,s;\nint t[MAX][MAX],u[MAX][MAX];\nint calc(int ay,int ax,int by,int bx){\n  return u[by][bx]-u[ay-1][bx]-u[by][ax-1]+u[ay-1][ax-1];\n}\nP dp[MAX][MAX][MAX][MAX];\n\nP rec(int ay,int ax,int by,int bx){\n  if(dp[ay][ax][by][bx].first!=-1)return dp[ay][ax][by][bx];\n  int sum=u[h][w]-calc(ay,ax,by,bx);\n  if(sum>s)return P(-1,1e8);\n  P res=P(1,s-sum);\n  for(int i=ay;i<by;i++){\n    P a=rec(ay,ax,i,bx),b=rec(i+1,ax,by,bx);\n    if(a.first==-1||b.first==-1)continue;\n    res=max(res,P(a.first+b.first,min(a.second,b.second)));\n  }\n  for(int j=ax;j<bx;j++){\n    P a=rec(ay,ax,by,j),b=rec(ay,j+1,by,bx);\n    if(a.first==-1||b.first==-1)continue;\n    res=max(res,P(a.first+b.first,min(a.second,b.second)));\n  }\n  return dp[ay][ax][by][bx]=res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w>>s;\n    if(h==0&&w==0&&s==0)break;\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin>>t[i][j];\n\tu[i][j]=t[i][j]+u[i-1][j]+u[i][j-1]-u[i-1][j-1];\n\tfor(int k=1;k<=h;k++)\n\t  for(int l=1;l<=w;l++)\n\t    dp[i][j][k][l].first=-1;\n      }\n    }\n    P ans=rec(1,1,h,w);\n    cout<<ans.first<<' '<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\npii dp[32][32][32][32];\nint integral[33][33];\n\nint partial_sum(int x1, int y1, int x2, int y2){\n\tint result = integral[y2 + 1][x2 + 1];\n\tresult -= integral[y2 + 1][x1];\n\tresult -= integral[y1][x2 + 1];\n\tresult += integral[y1][x1];\n\treturn result;\n}\n\npii recur(int x1, int y1, int x2, int y2, int r){\n\tif(dp[x1][y1][x2][y2].first >= 0){ return dp[x1][y1][x2][y2]; }\n\tpii result = pii(1, partial_sum(x1, y1, x2, y2));\n\tfor(int i = x1; i < x2; ++i){\n\t\tif(partial_sum(x1, y1, i, y2) < r){ continue; }\n\t\tif(partial_sum(i + 1, y1, x2, y2) < r){ continue; }\n\t\tpii a = recur(x1, y1, i, y2, r), b = recur(i + 1, y1, x2, y2, r);\n\t\tresult = max(result, pii(a.first + b.first, min(a.second, b.second)));\n\t}\n\tfor(int i = y1; i < y2; ++i){\n\t\tif(partial_sum(x1, y1, x2, i) < r){ continue; }\n\t\tif(partial_sum(x1, i + 1, x2, y2) < r){ continue; }\n\t\tpii a = recur(x1, y1, x2, i, r), b = recur(x1, i + 1, x2, y2, r);\n\t\tresult = max(result, pii(a.first + b.first, min(a.second, b.second)));\n\t}\n\tdp[x1][y1][x2][y2] = result;\n\treturn result;\n}\n\nint main(){\n\twhile(true){\n\t\tint h, w, s;\n\t\tcin >> h >> w >> s;\n\t\tif(h == 0 && w == 0 && s == 0){ break; }\n\t\tvector< vector<int> > u(h, vector<int>(w));\n\t\tint total = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> u[i][j];\n\t\t\t\ttotal += u[i][j];\n\t\t\t}\n\t\t}\n\t\tmemset(integral, 0, sizeof(integral));\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0, sum = 0; j < w; ++j){\n\t\t\t\tsum += u[i][j];\n\t\t\t\tintegral[i + 1][j + 1] = integral[i][j + 1] + sum;\n\t\t\t}\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tpii result = recur(0, 0, w - 1, h - 1, total - s);\n\t\tcout << result.first << \" \" << (s - (total - result.second)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\n/** 累積和 */\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/** /累積和 */\n\n\ntypedef tuple<int, int, int, int> Kukei;\n\nint H, W, S;\nint total_power;\nVVI tile;\nVVI c_tile;\nvector< vector< vector< vector<PII> > > > memo;\n\nbool can_group(int x1, int x2, int y1, int y2) {\n\treturn total_power - S <= sum_csum2<int>(c_tile, y1, y2, x1, x2);\n}\n\nPII dfs(int x1, int x2, int y1, int y2) {\n\tPII tmp = memo[y1][x1][y2][x2];\n\tif (tmp.first != -1) {\n\t\treturn tmp;\n\t}\n\t\n\tPII res(-1, -1);\n\n\tif (!can_group(x1, x2, y1, y2)) {\n\t\treturn memo[y1][x1][y2][x2] = res;\n\t}\n\n\tfor (int v = x1 + 1; v < x2; v++) {\n\t\tPII a = dfs(x1, v, y1, y2);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(v, x2, y1, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tfor (int h = y1 + 1; h < y2; h++) {\n\t\tPII a = dfs(x1, x2, y1, h);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(x1, x2, h, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tif (res.first == -1) {\n\t\tres = make_pair(1, sum_csum2<int>(c_tile, y1, y2, x1, x2));\n\t}\n\n\treturn memo[y1][x1][y2][x2] = res;\n}\n\nint main(void) {\n\twhile(cin >> H >> W >> S, H) {\n\t\ttile = VVI(H, VI(W, 0));\n\t\ttotal_power = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\ttotal_power += tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemo = vector< vector< vector< vector<PII> > > >(H + 1,\n\t\t\t\tvector< vector< vector<PII> > >(W + 1,\n\t\t\t\tvector< vector<PII> >(H + 1,\n\t\t\t\tvector<PII>(W + 1,\n\t\t\t\tmake_pair(-1, -1)))));\n\n\t\tc_tile = calc_csum2<int>(tile);\n\n\t\tPII ans = dfs(0, W, 0, H);\n\n\t\tcout << ans.first << \" \" << (S - total_power + ans.second) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*\nint pr[100010];\n//int inv[100010];\n*/ \nint beki(int wa,int rr,int warukazu){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa%warukazu;\n\tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n\tint zx=beki(wa,rr/2,warukazu);\n\treturn (zx*zx)%warukazu;\n}\n  /*\nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint a[35][35];\nint r[35][35]={0};\n\nint souwa(int ax,int ay,int bx,int by){\n\treturn r[bx][by]-r[ax-1][by]-r[bx][ay-1]+r[ax-1][ay-1];\n}\n\nint d;\n\npa memo[35][35][35][35];\n\npa saiki(int ax,int ay,int bx,int by){\n\tif(memo[ax][ay][bx][by].first>=0) return memo[ax][ay][bx][by];\n\tpa z=mp(-inf,-inf),z1,z2,zz;\n\tfor(int i=ax;i<bx;i++){\n\t\tz1=saiki(ax,ay,i,by),z2=saiki(i+1,ay,bx,by);\n\t\tzz=mp(z1.first+z2.first,min(z1.second,z2.second));\n\t\tz=max(z,zz);\n\t\t\n\t}\n\tfor(int j=ay;j<by;j++){\n\t\t\t\tz1=saiki(ax,ay,bx,j),z2=saiki(ax,j+1,bx,by);\n\t\tzz=mp(z1.first+z2.first,min(z1.second,z2.second));\n\t\tz=max(z,zz);\n\t}\n\tif(souwa(ax,ay,bx,by)>=d) if(z<mp(1ll,(souwa(ax,ay,bx,by)-d)))z=mp(1ll,(souwa(ax,ay,bx,by)-d));\n//\tif(ax==2 && ay==1)cout<<ax<<\" \"<<ay<<\" \"<<bx<<\" \"<<by<<\" \"<<z.first<<\" \"<<z.second<<endl;\n\tmemo[ax][ay][bx][by]=z;\n\treturn z;\n}\n\n\nsigned main(){\n\twhile(1){\n\tint h,w,s;\n\tcin>>h>>w>>s;\n\tint sum=0;\n\t\tif(h==0) return 0;\n\t\n\tfor(int i=0;i<35;i++)for(int i2=0;i2<35;i2++)for(int i3=0;i3<35;i3++)for(int i4=0;i4<35;i4++){\n\t\tmemo[i][i3][i2][i4]=mp(-1,9);\n\t}\n\t\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tcin>>a[i][j];\n\t\tsum += a[i][j];\n\t\tr[i][j]=r[i-1][j]+r[i][j-1]+a[i][j]-r[i-1][j-1];\n\t}\n\t d=sum-s;\n\t\n\tpa z=saiki(1,1,h,w);\n\t\n\tcout<<z.first<<\" \"<<z.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint sum;\nint H, W, S;\nint tab[40][40];\nPII memo[40][40][40][40];\nPII dfs(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2].first >= 0) return memo[x1][y1][x2][y2];\n  \n  int tot = 0;\n  for(int y=y1;y<y2;++y)\n\tfor(int x=x1;x<x2;++x)\n\t  tot += tab[y][x];\n  if(sum - tot > S) return memo[x1][y1][x2][y2] = MP(0,0);\n\n  PII& res = memo[x1][y1][x2][y2];\n  res = MP(1,tot);\n  for(int x=x1+1;x<x2;++x){\n\tPII p1 = dfs(x1,y1,x,y2);\n\tPII p2 = dfs(x,y1,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tres = max(res, MP(p1.first+p2.first, min(p1.second, p2.second)));\n  }\n\n  for(int y=y1+1;y<y2;++y){\n\tPII p1 = dfs(x1,y1,x2,y);\n\tPII p2 = dfs(x1,y,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tres = max(res, MP(p1.first+p2.first, min(p1.second, p2.second)));\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>W>>S,H){\n\tREP(y,H) REP(x,W) cin >> tab[y][x];\n\tsum = 0;\n\tREP(y,H) REP(x,W) sum += tab[y][x];\n\tfill((PII*)memo, (PII*)memo+40*40*40*40, MP(-1,0));\n\n\t\n\tPII pii = dfs(0,0,W,H);\n\tcout << pii.first << \" \" << S + pii.second - sum << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nstruct Imos2D {\n    vector<vector<int>> s;\n    Imos2D() {}\n    Imos2D(const vector<vector<int>> &a) {\n    #define rep(i, n) for (int i = 0; i < n; i++)\n        int h = a.size(), w = a[0].size();\n        s = vector<vector<int>>(h + 1, vector<int>(w + 1, 0));\n        rep(i, h) rep(j, w) s[i + 1][j + 1] = a[i][j];\n        rep(i, h + 1) rep(j, w) s[i][j + 1] += s[i][j];\n        rep(i, h) rep(j, w + 1) s[i + 1][j] += s[i][j];\n    #undef rep\n    }\n    int sum(int i, int j, int h, int w) {\n        return s[i + h][j + w] - s[i][j + w] - s[i + h][j] + s[i][j];\n    }\n};\n\nusing Pi = pair<int, int>;\nPi operator + (Pi a, Pi b) {\n    return Pi(a.first + b.first, min(a.second, b.second));\n}\nPi   dp[32][32][32 + 1][32 + 1];\nbool ok[32][32][32 + 1][32 + 1];\n\nint main() {\n    int H, W, S;\n    while (cin >> H >> W >> S, H) {\n        vector<vector<int>> a(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        Imos2D imos(a);\n        int all = imos.sum(0, 0, H, W);\n        memset(ok, false, sizeof(ok));\n        for (int h = 1; h <= H; h++) for (int w = 1; w <= W; w++) {\n            for (int i = 0; i + (h - 1) < H; i++) {\n                for (int j = 0; j + (w - 1) < W; j++) {\n                    int extra = S - (all - imos.sum(i, j, h, w));\n                    if (extra < 0) continue;\n                    ok[i][j][h][w] = true;\n                    Pi& res = dp[i][j][h][w];\n                    dp[i][j][h][w] = Pi(1, extra);\n                    for (int dh = 1; dh < h; dh++) {\n                        if (ok[i][j][dh][w] && ok[i + dh][j][h - dh][w]) {\n                            Pi tmp = dp[i][j][dh][w] + dp[i + dh][j][h - dh][w];\n                            res = max(res, tmp);\n                        }\n                    }\n                    for (int dw = 1; dw < w; dw++) {\n                        if (ok[i][j][h][dw] && ok[i][j + dw][h][w - dw]) {\n                            Pi tmp = dp[i][j][h][dw] + dp[i][j + dw][h][w - dw];\n                            res = max(res, tmp);\n                        }\n                    }\n                }\n            }\n        }\n        Pi ans = dp[0][0][H][W];\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*\nint pr[100010];\n//int inv[100010];\n*/ \nint beki(int wa,int rr,int warukazu){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa%warukazu;\n\tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n\tint zx=beki(wa,rr/2,warukazu);\n\treturn (zx*zx)%warukazu;\n}\n  /*\nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint a[35][35];\nint r[35][35]={0};\n\nint souwa(int ax,int ay,int bx,int by){\n\treturn r[bx][by]-r[ax-1][by]-r[bx][ay-1]+r[ax-1][ay-1];\n}\n\nint d;\n\npa memo[35][35][35][35];\n\npa saiki(int ax,int ay,int bx,int by){\n\tif(memo[ax][ay][bx][by].first!=-1) return memo[ax][ay][bx][by];\n\tpa z=mp(-inf,-inf),z1,z2,zz;\n\tfor(int i=ax;i<bx;i++){\n\t\tz1=saiki(ax,ay,i,by),z2=saiki(i+1,ay,bx,by);\n\t\tzz=mp(z1.first+z2.first,min(z1.second,z2.second));\n\t\tz=max(z,zz);\n\t\t\n\t}\n\tfor(int j=ay;j<by;j++){\n\t\t\t\tz1=saiki(ax,ay,bx,j),z2=saiki(ax,j+1,bx,by);\n\t\tzz=mp(z1.first+z2.first,min(z1.second,z2.second));\n\t\tz=max(z,zz);\n\t}\n\tif(souwa(ax,ay,bx,by)>=d) if(z<mp(1ll,(souwa(ax,ay,bx,by)-d)))z=mp(1ll,(souwa(ax,ay,bx,by)-d));\n//\tif(ax==2 && ay==1)cout<<ax<<\" \"<<ay<<\" \"<<bx<<\" \"<<by<<\" \"<<z.first<<\" \"<<z.second<<endl;\n\tmemo[ax][ay][bx][by]=z;\n\treturn z;\n}\n\n\nsigned main(){\n\twhile(1){\n\tint h,w,s;\n\tcin>>h>>w>>s;\n\tint sum=0;\n\t\tif(h==0) return 0;\n\t\n\tfor(int i=0;i<35;i++)for(int i2=0;i2<35;i2++)for(int i3=0;i3<35;i3++)for(int i4=0;i4<35;i4++){\n\t\tmemo[i][i3][i2][i4]=mp(-1,9);\n\t}\n\t\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tcin>>a[i][j];\n\t\tsum += a[i][j];\n\t\tr[i][j]=r[i-1][j]+r[i][j-1]+a[i][j]-r[i-1][j-1];\n\t}\n\t d=sum-s;\n\t\n\tpa z=saiki(1,1,h,w);\n\t\n\tcout<<z.first<<\" \"<<z.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint mp[35][35],smp[35][35],n,SUM,W,H;\nP mem[35][35][35][35];\nint used[35][35][35][35];\n\nint cal(int x1,int y1,int x2,int y2){\n  return smp[y2][x2]-(smp[y1-1][x2]+smp[y2][x1-1])+smp[y1-1][x1-1];\n}\n\nP dfs(int x,int y,int w,int h){\n  if(used[x][y][w][h]++) return mem[x][y][w][h];\n\n  P res=P(1,n-(SUM-cal(x,y,w,h)));\n  for(int i=x;i!=w;i++){\n    int m=max(SUM-cal(x,y,i,h),SUM-cal(i+1,y,w,h));\n    if(m<=n){\n      P a=dfs(x,y,i,h);\n      P b=dfs(i+1,y,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n\n  for(int i=y;i!=h;i++){\n    int m=max(SUM-cal(x,y,w,i),SUM-cal(x,i+1,w,h));\n    if(m<=n){\n      P a=dfs(x,y,w,i);\n      P b=dfs(x,i+1,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n  return mem[x][y][w][h]=res;\n}\n\nint main(){\n  while(1){\n  cin>>H>>W>>n;\n  if(!H&&!W&&!n)break;\n\n  memset(used,0,sizeof(used));\n  memset(mem,0,sizeof(mem));\n\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)cin>>mp[i][j],smp[i][j]=mp[i][j];\n\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i][j+1]+=smp[i][j];\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i+1][j]+=smp[i][j];\n  SUM=smp[H][W];\n  P ans=dfs(1,1,W,H);\n  cout <<ans.f<<\" \"<<ans.s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint h, w, s;\nint U[35][35];\nint allsum = 0;\n// dp[y1][x1][y2][x2] := ??????(y1, x1), ??????(y2, x2)???????????¢??????????????????, \n// ??°?????????????????????????????§??°, ?????§????????????\npair<int, int> dp[35][35][35][35];\n\n// O(hw)\ntemplate <class T>\nvector<vector<T>> Imos2D(const vector<vector<T>>& a) {\n\tint h = a.size(), w = a[0].size();\n\tvector<vector<T>> s(h + 1, vector<T>(w + 1, 0));\n\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) s[i + 1][j + 1] = a[i][j];\n\tfor (int i = 0; i < h + 1; ++i) for (int j = 0; j < w; ++j) s[i][j + 1] += s[i][j];\n\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w + 1; ++j) s[i + 1][j] += s[i][j];\n\treturn s;\n}\n// O(1)\ntemplate <class T>\nint sum(const vector<vector<T>>& s, int i, int j, int h, int w) {\n\treturn s[i + h][j + w] - s[i][j + w] + s[i][j] - s[i + h][j];\n}\n\npair<int, int> dfs(int y1, int x1, int y2, int x2, auto imos) {\n\tif(dp[y1][x1][y2][x2] != make_pair(-1, -1)) return dp[y1][x1][y2][x2];\n\tint yobi = s - (allsum - sum<int>(imos, y1, x1, y2 - y1 + 1, x2 - x1 + 1));\n\tif(yobi < 0) return make_pair(0, 0);\n\tauto ret = make_pair(1, yobi);\n\n\tfor (int i = x1; i < x2; ++i){\n\t\tif(s - (allsum - sum<int>(imos, y1, x1, y2 - y1 + 1, i - x1 + 1)) < 0) continue;\n\t\tif(s - (allsum - sum<int>(imos, y1, i + 1, y2 - y1 + 1, x2 - (i + 1) + 1)) < 0) continue;\n\t\tauto ret1 = dfs(y1, x1, y2, i, imos);\n\t\tauto ret2 = dfs(y1, i + 1, y2, x2, imos);\n\t\tchmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n\t}\n\n\tfor (int i = y1; i < y2; ++i){\n\t\tif(s - (allsum - sum<int>(imos, y1, x1, i - y1 + 1, x2 - x1 + 1)) < 0) continue;\n\t\tif(s - (allsum - sum<int>(imos, i + 1, x1, y2 - (i + 1) + 1, x2 - x1 + 1)) < 0) continue;\n\t\tauto ret1 = dfs(y1, x1, i, x2, imos);\n\t\tauto ret2 = dfs(i + 1, x1, y2, x2, imos);\n\t\tchmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> h >> w >> s;\n\t\tif(h == 0 && w == 0 && s == 0) break;\n\t\trep(i, h)rep(j, w) cin >> U[i][j];\n\t\tallsum = 0;\n\t\trep(i, h)rep(j, w) allsum += U[i][j];\n\n\t\tvector<vector<int>> u(h);\n\t\trep(i, h)rep(j, w) u[i].pb(U[i][j]);\n\t\tauto imos = Imos2D<int>(u);\n\n\t\trep(i, 35)rep(j, 35)rep(k, 35)rep(l, 35) dp[i][j][k][l] = make_pair(-1, -1);\n\t\tauto ans = dfs(0, 0, h - 1, w - 1, imos);\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint u[33][33];\nint dp[33][33][33][33][2];\nint sum[33][33];\nint h, w, s;\nint INF = 100000000;\n\nvoid f(int sy, int sx, int gy, int gx) {\n  if (dp[sy][sx][gy][gx][0] != INF) return;\n  int sm = sum[gy][gx] - sum[gy][sx] - sum[sy][gx] + sum[sy][sx];\n  if (sum[h][w] - sm > s) {\n    dp[sy][sx][gy][gx][0] = -INF;\n    return;\n  }\n  int res0 = 1, res1 = sm;\n  for (int i = sy + 1; i < gy; ++i) {\n    f(sy, sx, i, gx);\n    f(i, sx, gy, gx);\n    int a = dp[sy][sx][i][gx][0];\n    int b = dp[sy][sx][i][gx][1];\n    int c = dp[i][sx][gy][gx][0];\n    int d = dp[i][sx][gy][gx][1];\n    if (res0 < a + c || (res0 == a + c && res1 < min(b, d))){\n      res0 = a + c;\n      res1 = min(b, d);\n    }\n  }\n  for (int i = sx + 1; i < gx; ++i) {\n    f(sy, sx, gy, i);\n    f(sy, i, gy, gx);\n    int a = dp[sy][sx][gy][i][0];\n    int b = dp[sy][sx][gy][i][1];\n    int c = dp[sy][i][gy][gx][0];\n    int d = dp[sy][i][gy][gx][1];\n    if (res0 < a + c || (res0 == a + c && res1 < min(b, d))){\n      res0 = a + c;\n      res1 = min(b, d);\n    }\n  }\n  //cout << sy << \" \" << sx << \" \" << gy <<\" \" << gx << \" \" << res0 << \" \" << res1 << endl;\n  dp[sy][sx][gy][gx][0] = res0;\n  dp[sy][sx][gy][gx][1] = res1;\n}\n\nint main() {\n  for (;;) {\n    cin >> h >> w >> s;\n    if (h == 0 && w == 0 && s == 0) break;\n    rep (i, h) rep (j, w) cin >> u[i][j];\n    rep (i, h + 1) rep (j, w + 1) rep (ii, h + 1) rep (jj, w + 1) dp[i][j][ii][jj][0] = INF;\n    rep (i, h + 1) rep (j, w + 1) sum[i][j] = 0;\n    rep (i, h) rep (j, w) {\n      sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + u[i][j];\n      //cout << i << \" \" << j << \" \" << sum[i + 1][j + 1] << endl;\n    }\n    f(0, 0, h, w);\n    cout << dp[0][0][h][w][0] << \" \" << s - (sum[h][w] - dp[0][0][h][w][1]) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int g;\n    int e;\n    Data(){\n        g = e = -1;\n    }\n    Data(int g0, int e0){\n        g = g0;\n        e = e0;\n    }\n    bool operator<(const Data& d) const{\n        return g < d.g || (g == d.g && e < d.e);\n    }\n};\n\nbool check[32][32][32][32];\nData memo[32][32][32][32];\n\nData solve(int y1, int x1, int y2, int x2, int s)\n{\n    if(check[y1][x1][y2][x2])\n        return memo[y1][x1][y2][x2];\n\n    int tmp = 0;\n    for(int i=y1; i<=y2; ++i){\n        for(int j=x1; j<=x2; ++j){\n            tmp += memo[i][j][i][j].e;\n        }\n    }\n    if(tmp < s)\n        return Data();\n\n    Data ret(1, tmp);\n    for(int i=y1; i<y2; ++i){\n        Data d1 = solve(y1, x1, i, x2, s);\n        Data d2 = solve(i+1, x1, y2, x2, s);\n        if(d1.g == -1 || d2.g == -1)\n            continue;\n        Data d3(d1.g + d2.g, min(d1.e, d2.e));\n        ret = max(ret, d3);\n    }\n    for(int i=x1; i<x2; ++i){\n        Data d1 = solve(y1, x1, y2, i, s);\n        Data d2 = solve(y1, i+1, y2, x2, s);\n        if(d1.g == -1 || d2.g == -1)\n            continue;\n        Data d3(d1.g + d2.g, min(d1.e, d2.e));\n        ret = max(ret, d3);\n    }\n\n    check[y1][x1][y2][x2] = true;\n    memo[y1][x1][y2][x2] = ret;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int h, w, s;\n        cin >> h >> w >> s;\n        if(h == 0)\n            return 0;\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                for(int k=0; k<h; ++k){\n                    for(int l=0; l<w; ++l){\n                        check[i][j][k][l] = false;\n                        memo[i][j][k][l] = Data();\n                    }\n                }\n            }\n        }\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                memo[i][j][i][j].g = 1;\n                cin >> memo[i][j][i][j].e;\n                s -= memo[i][j][i][j].e;\n            }\n        }\n        s *= -1;\n\n        Data d = solve(0, 0, h-1, w-1, s);\n        cout << d.g << ' ' << (d.e-s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\ntypedef pair< int, int > Pii;\nconst int kInf = numeric_limits< int >::max() / 2;\n\nint H, W, S, T;\nint u[33][33], sum[33][33];\nPii f[33][33][33][33];\nbool vst[33][33][33][33];\n\nvoid read_plate(void);\nvoid preprocess(void);\nvoid solve(void);\nPii & dp(int, int, int, int);\n\nint main() {\n  while (cin >> H >> W >> S, H + W + S) {\n    read_plate();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read_plate(void) {\n  for (int i = 1; i <= H; ++i)\n    for (int j = 1; j <= W; ++j)\n      cin >> u[i][j];\n}\n\nvoid preprocess(void) {\n  fill(&sum[0][0], &sum[H + 1][0], 0);\n  for (int i = 1; i <= H; ++i)\n    for (int j = 1; j <= W; ++j)\n      sum[i][j] = u[i][j] + sum[i][j - 1];\n  for (int i = 1; i <= W; ++i)\n    for (int j = 1; j <= H; ++j)\n      sum[j][i] += sum[j - 1][i];\n  T = sum[H][W];\n}\n\nvoid solve(void) {\n  fill(&vst[0][0][0][0], &vst[H + 1][0][0][0], false);\n  Pii &res = dp(1, 1, H, W);\n  cout << res.first << \" \" << res.second << \"\\n\";\n}\n\nPii & dp(int x1, int y1, int x2, int y2) {\n  if (vst[x1][y1][x2][y2])  return f[x1][y1][x2][y2];\n\n  int rd, msd;\n  Pii &c = f[x1][y1][x2][y2];\n\n  vst[x1][y1][x2][y2] = true;\n  c = make_pair(-kInf, -kInf);\n  rd = sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];\n  msd = T - rd;\n  if (msd <= S)\n    c = make_pair(1, S - msd);\n\n  for (int i = x1 + 1; i <= x2; ++i) {\n    Pii &r1 = dp(x1, y1, i - 1, y2), &r2 = dp(i, y1, x2, y2);\n    if (r1.first + r2.first > c.first)\n      c.first = r1.first + r2.first, c.second = min(r1.second, r2.second);\n    else if (r1.first + r2.first == c.first &&\n             min(r1.second, r2.second) > c.second)\n      c.second = min(r1.second, r2.second);\n  }\n\n  for (int i = y1 + 1; i <= y2; ++i) {\n    Pii &r1 = dp(x1, y1, x2, i - 1), &r2 = dp(x1, i, x2, y2);\n    if (r1.first + r2.first > c.first)\n      c.first = r1.first + r2.first, c.second = min(r1.second, r2.second);\n    else if (r1.first + r2.first == c.first &&\n             min(r1.second, r2.second) > c.second)\n      c.second = min(r1.second, r2.second);\n  }\n\n  return c;\n}"
  },
  {
    "language": "C++",
    "code": "//32\n#include<iostream>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint h,w,s;\nint u[33][33];\nint mn;\nint um[33][33][33][33];\nint bm[33][33][33][33];\n\ntypedef pair<int,int> pii;\n\nint getp(int l,int t,int r,int b){\n  return u[b][r]-u[b][l]-u[t][r]+u[t][l];\n}\n\npii add(pii a,pii b){\n  return make_pair(a.first+b.first,min(a.second,b.second));\n}\n\npii dfs(int l,int t,int r,int b){\n  if(um[l][t][r][b]){\n    return make_pair(bm[l][t][r][b],um[l][t][r][b]);\n  }else{\n    pii rt=pii(1,getp(l,t,r,b));\n    for(int i=l+1;i<r;i++){\n      if(getp(l,t,i,b)>=mn&&getp(i,t,r,b)>=mn){\n\trt=max(rt,add(dfs(l,t,i,b),dfs(i,t,r,b)));\n      }\n    }\n    for(int j=t+1;j<b;j++){\n      if(getp(l,t,r,j)>=mn&&getp(l,j,r,b)>=mn){\n\trt=max(rt,add(dfs(l,t,r,j),dfs(l,j,r,b)));\n      }\n    }\n    um[l][t][r][b]=rt.second;\n    bm[l][t][r][b]=rt.first;\n    return rt;\n  }\n}\n \nint main(){\n  while(cin>>h>>w>>s,h|w|s){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tint c;\n\tcin>>c;\n\tu[i+1][j+1]=u[i+1][j]+u[i][j+1]-u[i][j]+c;\n      }\n    }\n    int us=getp(0,0,w,h);\n    mn=us-s;\n    fill(um[0][0][0],um[33][0][0],0);\n    fill(bm[0][0][0],bm[33][0][0],0);\n    pii r=dfs(0,0,w,h);\n    cout<<r.first<<' '<<r.second-mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40]; pair<int, int> dp[40][40][40][40];\ninline int rng(int x1, int y1, int x2, int y2) {\n\treturn sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2];\n}\npair<int, int> solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2].first != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tpair<int, int> ret = make_pair(1, rng_);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tpair<int, int> resl = solve(x1, y1, i, y2);\n\t\t\tpair<int, int> resr = solve(i, y1, x2, y2);\n\t\t\tpair<int, int> res = make_pair(resl.first + resr.first, min(resl.second, resr.second));\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tpair<int, int> resl = solve(x1, y1, x2, i);\n\t\t\tpair<int, int> resr = solve(x1, i, x2, y2);\n\t\t\tpair<int, int> res = make_pair(resl.first + resr.first, min(resl.second, resr.second));\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l].first = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tpair<int, int> ret = solve(0, 0, W, H);\n\t\tcout << ret.first << ' ' << ret.second - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h, s;\nint u[32][32];\nint dp[32][32][32][32];\nint tab[32][32];\n\nint func(int h1, int w1, int h2, int w2, int x){\n\tif(h1 >= 1 && w1 >= 1){\n\t\tif(tab[h2][w2]+tab[h1-1][w1-1]-tab[h2][w1-1]-tab[h1-1][w2] < x) return -INF;\n\t} else if(h1 >= 1 && w1 == 0){\n\t\tif(tab[h2][w2]-tab[h1-1][w2] < x) return -INF;\n\t} else if(h1 == 0 && w1 >= 1){\n\t\tif(tab[h2][w2]-tab[h2][w1-1] < x) return -INF;\n\t} else{\n\t\tif(tab[h2][w2] < x) return -INF;\n\t}\n\tif(h1==h2&&w1==w2&&u[h1][h2] >= x) return 1;\n\tif(dp[h1][w1][h2][w2] != INF) return dp[h1][w1][h2][w2];\n\tint ret = 1;\n\tfor(int i = h1; i <= h2-1; i++) ret = max(ret,func(h1,w1,i,w2,x)+func(i+1,w1,h2,w2,x));\n\tfor(int i = w1; i <= w2-1; i++) ret = max(ret,func(h1,w1,h2,i,x)+func(h1,i+1,h2,w2,x));\n\tdp[h1][w1][h2][w2] = ret;\n\treturn ret;\n}\n\nvoid solve(){\n\tint sum = 0;\n\trep(i,h) rep(j,w) cin >> u[i][j];\n\trep(i,h) rep(j,w) sum += u[i][j];\n\trep(i,h) rep(j,w) tab[i][j] = u[i][j];\n\trep(i,h) for(int j = 1; j < w; j++) tab[i][j] += tab[i][j-1];\n\tfor(int i = 1; i < h; i++) rep(j,w) tab[i][j] += tab[i-1][j];\n\trep(j,32) rep(k,32) rep(l,32) rep(l1,32) dp[j][k][l][l1] = INF;\n\tint ans = func(0,0,h-1,w-1,sum-s);\n\tint st = 0, en = 200000, i;\n\twhile(true){\n\t\tif(en-st==1) break;\n\t\ti = (st+en)/2;\n\t\trep(j,32) rep(k,32) rep(l,32) rep(l1,32) dp[j][k][l][l1] = INF;\n\t\tint p = func(0,0,h-1,w-1,sum-s+i);\n\t\tif(p >= ans){\n\t\t\tst = i;\n\t\t} else{\n\t\t\ten = i;\n\t\t}\n\t}\n\tcout << ans << \" \" << st << endl;\n}\n\nint main(){\n\twhile(cin >> h >> w >> s){\n\t\tif(w==0&&h==0&&s==0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,s,sum;\nP pmax(P a,P b){\n\tif(a>b)return a;\n\treturn b;\n}\nint u[33][33];\nP dp[33][33][33][33];\nP ret(P a,P b,int cnt){\n\tif(dp[a.first][a.second][b.first][b.second].first!=-1)\n\t\treturn dp[a.first][a.second][b.first][b.second];\n\tP ans(1,cnt);\n\tint s1=0,s2=0;\n\tfor(int i=a.first;i<b.first;i++){\n\t\t\n\t\tfor(int j=a.second;j<=b.second;j++){\n\t\t\ts1+=u[i][j];\n\t\t}\n\t\tif(sum-s1>s||sum-(cnt-s1)>s)\n\t\t\tcontinue;\n\t\tP x=ret(a,P(i,b.second),s1),y=ret(P(i+1,a.second),b,cnt-s1);\n\t\tans=pmax(ans,P(x.first+y.first,min(x.second,y.second)));\n\t}\n\tfor(int i=a.second;i<b.second;i++){\n\t\tfor(int j=a.first;j<=b.first;j++){\n\t\t\ts2+=u[j][i];\n\t\t}\n\t\tif(sum-s2>s||sum-(cnt-s2)>s)\n\t\t\tcontinue;\n\t\tP x=ret(a,P(b.first,i),s2),y=ret(P(a.first,i+1),b,cnt-s2);\n\t\tans=pmax(ans,P(x.first+y.first,min(x.second,y.second)));\n\t}\n\treturn dp[a.first][a.second][b.first][b.second]=ans;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tsum=0;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w)\n\t\tdp[i][j][k][l]=P(-1,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>u[i][j];\n\t\t\tsum+=u[i][j];\n\t\t}\n\t\tP ans=ret(P(0,0),P(h-1,w-1),sum);\n\t\tcout<<ans.first<<\" \"<<s-(sum-ans.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint h, w, s, u[50][50];\n\nint rect(int x1, int y1, int x2, int y2)\n{\n    return u[x2][y2] - u[x1][y2] - u[x2][y1] + u[x1][y1];\n}\n\npair<int,int> memo[36][36][36][36];\n\npair<int,int> recur(int x1, int y1, int x2, int y2)\n{\n    if (memo[x1][y1][x2][y2].first >= 0)\n\treturn memo[x1][y1][x2][y2];\n\n    pair<int,int> ret = mp(1, rect(x1, y1, x2, y2));\n    for (int x = x1 + 1; x < x2; ++x) {\n\tpair<int,int> l = recur(x1, y1, x, y2);\n\tpair<int,int> r = recur(x, y1, x2, y2);\n\tpair<int,int> m = mp(l.first + r.first, min(l.second, r.second));\n\tif (m.second >= rect(0, 0, w, h) - s)\n\t    ret = max(ret, m);\n    }\n    for (int y = y1 + 1; y < y2; ++y) {\n\tpair<int,int> l = recur(x1, y1, x2, y);\n\tpair<int,int> r = recur(x1, y, x2, y2);\n\tpair<int,int> m = mp(l.first + r.first, min(l.second, r.second));\n\tif (m.second >= rect(0, 0, w, h) - s)\n\t    ret = max(ret, m);\n    }\n    return memo[x1][y1][x2][y2] = ret;\n}\n\nvoid solve()\n{\n    rep(i, 36) rep(j, 36) rep(k, 36) rep(l, 36)\n\tmemo[i][j][k][l] = mp(-1, -1);\n\n    pair<int,int> ans = recur(0, 0, w, h);\n    cout << ans.first << ' ' << s + ans.second - rect(0, 0, w, h) << endl;\n}\n\nint main()\n{\n    while (cin >> h >> w >> s && h) {\n\tmemset(u, 0, sizeof(u));\n\trep(y, h) rep(x, w) cin >> u[x + 1][y + 1];\n\tfor (int y = 1; y <= h; ++y)\n\t    for (int x = 1; x <= w; ++x)\n\t\tu[x][y] += u[x - 1][y] + u[x][y - 1] - u[x - 1][y - 1];\n\n\tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 35\n\nstruct Point {\n\tint y, x, dir, cost;\n};\nstruct Ans {\n\tint cnt, sub_power;\n};\nint h, w, s;\nint u[MAX][MAX];\nAns dp[MAX][MAX][MAX][MAX];\nint sum;\nAns dfs(pair<Point,Point> g) {\n\tint i,j;\n\tif (dp[g.first.y][g.first.x][g.second.y][g.second.x].cnt != -1) {\n\t\treturn dp[g.first.y][g.first.x][g.second.y][g.second.x];\n\t}\n\tint cnt = (int)-1e7;\n\tint sub_power = 0;\n\n\tint psum = 0;\n\tREP(i, g.first.y, g.second.y+1) {\n\t\tREP(j, g.first.x, g.second.x+1) {\n\t\t\tpsum += u[i][j];\n\t\t}\n\t}\n\tif (psum >= sum - s) {\n\t\tcnt = 1;\n\t\tsub_power = psum - (sum - s);\n\t}\n\tREP(i, g.first.y, g.second.y) {\n\t\tauto ng1 = g;\n\t\tng1.second.y = i;\n\t\tauto ng2 = g;\n\t\tng2.first.y = i+1;\n\t\tint ncnt = dfs(ng1).cnt + dfs(ng2).cnt;\n\t\tint nsub_power = min(dfs(ng1).sub_power,dfs(ng2).sub_power);\n\t\tif (ncnt > cnt) {\n\t\t\tcnt = ncnt;\n\t\t\tsub_power = nsub_power;\n\t\t}\n\t\telse if (ncnt == cnt) {\n\t\t\tif (nsub_power > sub_power) {\n\t\t\t\tsub_power = nsub_power;\n\t\t\t}\n\t\t}\n\t}\t\n\n\tREP(i, g.first.x, g.second.x) {\n\t\tauto ng1 = g;\n\t\tng1.second.x = i;\n\t\tauto ng2 = g;\n\t\tng2.first.x = i+1;\n\t\tint ncnt = dfs(ng1).cnt + dfs(ng2).cnt;\n\t\tint nsub_power = min(dfs(ng1).sub_power, dfs(ng2).sub_power);\n\t\tif (ncnt > cnt) {\n\t\t\tcnt = ncnt;\n\t\t\tsub_power = nsub_power;\n\t\t}\n\t\telse if (ncnt == cnt) {\n\t\t\tif (nsub_power > sub_power) {\n\t\t\t\tsub_power = nsub_power;\n\t\t\t}\n\t\t}\n\t}\n\tdp[g.first.y][g.first.x][g.second.y][g.second.x] = { cnt,sub_power };\n\treturn { cnt,sub_power };\n}\nsigned main(void)\n{\n\tint i, j, k,l;\n\twhile (1) {\n\t\tcin >> h >> w >> s;\n\t\tif (h == 0) return 0;\n\t\trep(i, h) rep(j, w) rep(k, h) rep(l, w) {\n\t\t\tdp[i][j][k][l].cnt = -1;\n\t\t}\n\t\tsum = 0;\n\t\trep(i, h) rep(j, w) {\n\t\t\treader(u[i][j]);\n\t\t\tsum += u[i][j];\n\t\t}\n\t\tpair<Point, Point> g;\n\t\tg.first = {0,0};\n\t\tg.second = { h - 1,w - 1 };\n\t\twriterLn(dfs(g).cnt, dfs(g).sub_power);\n\t//\tdump(dp[0][0][0][1].cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\npii INIT = pii(-1, -1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\n\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y) {\n    return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\n// テ・ツーツ湘・ツ慊ーテ・ツ淞?(テ・ツ債甘ゥツ鳴? テ」ツ?ォテ」ツ?甘」ツ?妥」ツつ凝ァツュツ氾」ツ??\npii solve(int lx, int ly, int rx, int ry) {\n    pii& ans = memo[lx][ly][rx][ry];\n    if(ans != INIT) return ans;\n\n    // テ・ツーツ湘・ツ慊ーテ・ツ淞淌」ツ?ッテヲツ敖。テ、ツサツカテ」ツつ津ヲツコツ?」ツ?淌」ツ?陛」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァテ」ツ??ァツュツ氾」ツ?暗」ツ?ォテ・ツスツアテゥツ淞ソテ」ツ?療」ツ?ェテ」ツ??ヲツ?湘・ツ堕ウテ」ツ?ョテ」ツ?ェテ」ツ??・ツ?、テ」ツつ津ィツソツ氾」ツ??\n    int sum = getsum(lx, ly, rx, ry);\n    if(sum < E - S) return ans = pii(0, INF);\n\n    // テァツュツ氾」ツ??\n    ans = pii(1, S - (E - sum));\n\n    // テヲツィツェテ」ツ?ョテ・ツ按?・ツ可イ\n    rep(i,lx+1,rx) {\n        pii ra = solve(lx, ly, i, ry);\n        pii rb = solve(i, ly, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    // テァツクツヲテ」ツ?ョテ・ツ按?・ツ可イ\n    rep(i,ly+1,ry) {\n        pii ra = solve(lx, ly, rx, i);\n        pii rb = solve(lx, i, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n    return ans;\n}\n\nsigned main() {\n    while(cin >> H >> W >> S, H || W || S) {\n        memset(board, 0, sizeof(board));\n        rep(i,0,33) rep(j,0,33) rep(k,0,33) rep(l,0,33)\n            memo[i][j][k][l] = INIT;\n        rep(i,0,H) rep(j,0,W) cin >> board[i+1][j+1];\n        rep(i,0,H) rep(j,0,W) board[i+1][j+1] += board[i+1][j];\n        rep(j,0,W) rep(i,0,H) board[i+1][j+1] += board[i][j+1];\n\n        E = getsum(0, 0, H, W);\n        pii ans = solve(0, 0, H, W);\n        printf(\"%lld %lld\\n\", ans.first, ans.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nclass BIT {\nprivate:\n\tint size;\n\tvector<int> bit;\n\t\npublic:\n\tBIT(int n = 0):size(n), bit(n + 1, 0) {}\n\t\n\tvoid add(int i, int x) {\n\t\twhile(i <= size) {\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\n\tint sum(int i) const {\n\t\tint s = 0;\n\t\twhile(i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nclass BIT2D {\nprivate:\n\tint size;\n\tvector<BIT> bit;\npublic:\n\tBIT2D(int w = 0, int h = 0):size(w), bit(w + 1, BIT(h)) {};\n\n\tvoid add(int x, int y, int v) {\n\t\twhile(x <= size) {\n\t\t\tbit[x].add(y, v);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\n\tint sum(int x, int y) const {\n\t\tint s = 0;\n\t\twhile(x > 0) {\n\t\t\ts += bit[x].sum(y);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn s;\n\t}\n};\n\n#define group first\n#define r_power second\nconst int MAX = 33;\n\nint h, w, s;\nint lower;\npair<int, int> memo[MAX][MAX][MAX][MAX];\nBIT2D bit;\n\ninline int calc_sum(int sx, int sy, int tx, int ty) {\n\treturn bit.sum(tx, ty) - bit.sum(sx, ty) - bit.sum(tx, sy) + bit.sum(sx, sy);\n}\n\npair<int, int> dfs(int sx, int sy, int tx, int ty) {\n\tif(memo[sx][sy][tx][ty].group != 0)\n\t\treturn memo[sx][sy][tx][ty];\n\n\tconst int demand = calc_sum(sx, sy, tx, ty);\n\tif(demand < lower)\n\t\treturn memo[sx][sy][tx][ty] = make_pair(-1, -1);\n\n\tpair<int, int> res = make_pair(1, demand - lower);\n\n\tfor(int i = sx + 1; i < tx; ++i) {\n\t\tconst pair<int, int> a = dfs(sx, sy, i, ty), b = dfs(i, sy, tx, ty);\n\t\tif(a.group == -1 || b. group == -1)\n\t\t\tcontinue;\n\n\t\tchmax(res, make_pair(a.group + b.group, min(a.r_power, b.r_power)));\n\t}\n\n\tfor(int i = sy + 1; i < ty; ++i) {\n\t\tconst pair<int, int> a = dfs(sx, sy, tx, i), b = dfs(sx, i, tx, ty);\n\t\tif(a.group == -1 || b. group == -1)\n\t\t\tcontinue;\n\n\t\tchmax(res, make_pair(a.group + b.group, min(a.r_power, b.r_power)));\n\t}\n\n\treturn memo[sx][sy][tx][ty] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w >> s, h) {\n\t\tbit = BIT2D(w, h);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tint u;\n\t\t\t\tcin >> u;\n\t\t\t\tbit.add(j + 1, i + 1, u);\n\t\t\t}\n\t\t}\n\n\t\tlower = bit.sum(w, h) - s;\n\t\tfill(memo[0][0][0], memo[0][0][0] + MAX*MAX*MAX*MAX, make_pair(0, 0));\n\t\tconst pair<int, int> ans = dfs(0, 0, w, h);\n\t\tcout << ans.group << \" \" << ans.r_power << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n\nstruct p{\n\tint g,m;\n\tp(){}\n\tp(int g,int m):g(g),m(m){}\n};\n\nint h,w,s,sum[32][32];\np dp[32][32][32][32];\n\nint main(){\n\twhile(cin>>h>>w>>s&&h){\n\t\tmemset(sum,0,sizeof(sum));\n\t\tmemset(dp,0,sizeof(dp));\n\t\trep(i,h)rep(j,w){\n\t\t\tint u;\n\t\t\tcin>>u;\n\t\t\tif(j==0){\n\t\t\t\tif(i==0)sum[0][0]=u;\n\t\t\t\telse sum[i][0]=sum[i-1][0]+u;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i==0)sum[0][j]=sum[0][j-1]+u;\n\t\t\t\telse sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+u;\n\t\t\t}\n\t\t}\n\t\ts=sum[h-1][w-1]-s;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w){\n\t\t\tint S;\n\t\t\tif(j==0){\n\t\t\t\tif(i==0)S=sum[k][l];\n\t\t\t\telse S=sum[k][l]-sum[i-1][l];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i==0)S=sum[k][l]-sum[k][j-1];\n\t\t\t\telse S=sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1];\n\t\t\t}\n\t\t\tif(S>=s)dp[i][j][k][l]=p(1,S);\n\t\t}\n\t\trep2(H,1,h+1)rep2(W,1,w+1)rep(y,h-H+1)rep(x,w-W+1){\n\t\t\tint g=0,m=0;\n\t\t\trep(i,H-1){\n\t\t\t\tp U=dp[y][x][y+i][x+W-1],D=dp[y+i+1][x][y+H-1][x+W-1];\n\t\t\t\tif(U.g&&D.g&&U.m>=s&&D.m>=s&&(U.g+D.g>g||U.g+D.g==g&&min(U.m,D.m)>m)){g=U.g+D.g,m=min(U.m,D.m);}\n\t\t\t}\n\t\t\trep(i,W-1){\n\t\t\t\tp L=dp[y][x][y+H-1][x+i],R=dp[y][x+i+1][y+H-1][x+W-1];\n\t\t\t\tif(L.g&&R.g&&L.m>=s&&R.m>=s&&(L.g+R.g>g||L.g+R.g==g&&min(L.m,R.m)>m)){g=L.g+R.g,m=min(L.m,R.m);}\n\t\t\t}\n\t\t\tif(g)dp[y][x][y+H-1][x+W-1]=p(g,m);\n\t\t}\n\t\tcout<<dp[0][0][h-1][w-1].g<<\" \"<<dp[0][0][h-1][w-1].m-s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nP dp[33][33][33][33];\nint h,w,s,u[33][33] = {},sum = 0;\n\nint calc(int x1,int y1,int x2,int y2){\n\treturn u[x2][y2] - u[x1][y2] - u[x2][y1] + u[x1][y1];\n}\n\nP dfs(int x1,int y1,int x2,int y2){\n\tif(dp[x1][y1][x2][y2].first >= 1 || sum - calc(x1,y1,x2,y2) > s) return dp[x1][y1][x2][y2];\n\tfor(int i = y1 + 1;i < y2;i++){\n\t\tP p1 = dfs(x1,y1,x2,i),p2 = dfs(x1,i,x2,y2),p = P(p1.first + p2.first,min(p1.second,p2.second));\n\t\tdp[x1][y1][x2][y2] = max(dp[x1][y1][x2][y2],p);\n\t}\n\tfor(int i = x1 + 1;i < x2;i++){\n\t\tP p1 = dfs(x1,y1,i,y2),p2 = dfs(i,y1,x2,y2),p = P(p1.first + p2.first,min(p1.second,p2.second));\n\t\tdp[x1][y1][x2][y2] = max(dp[x1][y1][x2][y2],p);\n\t}\n\tif(dp[x1][y1][x2][y2].first <= 0) dp[x1][y1][x2][y2] = P(1,s - sum + calc(x1,y1,x2,y2));\n\treturn dp[x1][y1][x2][y2];\n}\n\nint main(){\n\twhile(cin >> h >> w >> s,h){\n\t\tsum = 0;\n\t\tfor(int i = 1;i <= h;i++){\n\t\t\tfor(int j = 1;j <= w;j++){\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tsum += u[i][j];\n\t\t\t\tu[i][j] += u[i - 1][j] + u[i][j - 1] - u[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i <= h;i++){\n\t\t\tfor(int j = 0;j <= w;j++){\n\t\t\t\tfor(int k = 0;k <= h;k++){\n\t\t\t\t\tfor(int l = 0;l <= w;l++){\n\t\t\t\t\t\tdp[i][j][k][l] = P(-INF,-INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0,0,h,w);\n\t\tcout << dp[0][0][h][w].first << \" \" << dp[0][0][h][w].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\ntypedef pair<int, int> P;\nP dp[33][33][33][33];\nbool used[33][33][33][33] = {};\nint h, w, s, di;\nint sum[34][34] = {};\nint d[33][33];\n\nP solve(int lx, int ly, int rx, int ry) {\n\tif (used[lx][ly][rx][ry]) return dp[lx][ly][rx][ry];\n\tused[lx][ly][rx][ry] = true;\n\tint s = sum[rx][ry]-sum[lx][ry]-sum[rx][ly]+sum[lx][ly];\n\tP res;\n\tif (s-di < 0) {\n\t\tres = P(-1000000, -1000000);\n\t} else {\n\t\tres = P(1, s-di);\n\t}\n\tfor (int i = lx+1; i < rx; i++) {\n\t\tP p1 = solve(lx, ly, i, ry);\n\t\tP p2 = solve(i, ly, rx, ry);\n\t\tP p = P(p1.first+p2.first, min(p1.second, p2.second));\n\t\tif (p.second < 0) continue;\n\t\tif (res.first < p.first) {\n\t\t\tres = p;\n\t\t} else if (res.first == p.first) {\n\t\t\tres.second = max(res.second, p.second);\n\t\t}\n\t}\n\tfor (int j = ly+1; j < ry; j++) {\n\t\tP p1 = solve(lx, ly, rx, j);\n\t\tP p2 = solve(lx, j, rx, ry);\n\t\tP p = P(p1.first+p2.first, min(p1.second, p2.second));\n\t\tif (p.second < 0) continue;\n\t\tif (res.first < p.first) {\n\t\t\tres = p;\n\t\t} else if (res.first == p.first) {\n\t\t\tres.second = max(res.second, p.second);\n\t\t}\n\t}\n\tdp[lx][ly][rx][ry] = res;\n\treturn res;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> h >> w >> s;\n\t\tfill_n(used[0][0][0], 33*33*33*33, false);\n\t\tfill_n(sum[0], 34*34, 0);\n\t\tif (!h) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tscanf(\"%d\", &(d[i][j]));\n\t\t\t\tsum[i+1][j+1] = d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tsum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\t//for (int i = 0; i <= h; i++) {\n\t\t//\tfor (int j = 0; j <= w; j++) {\n\t\t//\t\tprintf(\"%d \", sum[i][j]);\n\t\t//\t}\n\t\t//\tprintf(\"\\n\");\n\t\t//}\n\t\tdi = sum[h][w]-s;\n\t\t//printf(\"%d\\n\", di);\n\t\tP p = solve(0, 0, h, w);\n\t\t//P p1 = solve(0, 1, 4)\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t\t//printf(\"%d %d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\npair<int,int> operator+(const pair<int,int>&left, const pair<int,int> &right){\n\treturn MP(left.first+right.first,min(left.second,right.second));\n}\n\n\nint h,w,S;\nint sal;\npair<int,int> dp[32][32][32][32];\nint s[32][32];\n\nint sm(int a,int b,int c,int d){\n\tif(a==0&&b==0){\n\t\treturn s[c][d];\n\t}\n\tif(a==0){\n\t\treturn s[c][d]-s[c][b-1];\n\t}\n\tif(b==0){\n\t\treturn s[c][d]-s[a-1][d];\n\t}\n\treturn s[c][d]-s[c][b-1]-s[a-1][d]+s[a-1][b-1];\n}\n\n\npair<int,int> saiki(int a,int b,int c,int d){\n\tif(dp[a][b][c][d]!=MP(-1,-1)){\n\t\treturn dp[a][b][c][d];\n\t}\n\t// cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t// cout << sm(a,b,c,d) << endl;\n\tif(sm(a,b,c,d)<sal){\n\t\treturn dp[a][b][c][d] = MP(0,0);\n\t}\n\tpair<int,int> p = MP(1,sm(a,b,c,d)-sal); \n\tfor(int i=a;i<c;i++){\n\t\tif(saiki(a,b,i,d)==MP(0,0))continue;\n\t\tif(saiki(i+1,b,c,d)==MP(0,0))continue;\n\t\tp = max(p,saiki(a,b,i,d)+saiki(i+1,b,c,d));\n\t}\n\tfor(int i=b;i<d;i++){\n\t\tif(saiki(a,b,c,i)==MP(0,0))continue;\n\t\tif(saiki(a,i+1,c,d)==MP(0,0))continue;\n\t\tp = max(p,saiki(a,b,c,i)+saiki(a,i+1,c,d));\n\t}\n\treturn dp[a][b][c][d] = p;\n}\nint main(){\n\twhile(cin >> h >> w >> S && h!=0){\n\t\tFill(dp,MP(-1,-1));\n\t\tFill(s,0);\n\t\tvector<vector<int> > v(h,vector<int>(w));\n\t\tsal = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tsal += v[i][j];\n\t\t\t}\n\t\t}\n\t\tsal -=S;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\ts[i][j] = v[i][j];\n\t\t\t\t}else{\n\t\t\t\t\ts[i][j] = s[i][j-1] + v[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\ts[i][j] += s[i-1][j];\n\t\t\t}\n\t\t}\n\n\t\tauto x = saiki(0,0,h-1,w-1);\n\n\t\tcout << x.first << \" \" << x.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W,S;\nint A[33][33];\nint sum[33][33];\npint memo[33][33][33][33];\nint sumall;\nint f(int y1,int x1,int y2,int x2){\n    return sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1];\n}\n\npint dfs(int y1,int x1,int y2,int x2){\n    pint &ret=memo[y1][x1][y2][x2];\n    if(ret.fi!=-1)return ret;\n\n    if(sumall-f(y1,x1,y2,x2)>S)return pint(INT_MIN,INT_MIN);\n    ret=pint(1,f(y1,x1,y2,x2));\n    for(int i=y1+1;i<y2;i++){\n        pint p1=dfs(y1,x1,i,x2),p2=dfs(i,x1,y2,x2);\n        p1.fi+=p2.fi;chmin(p1.se,p2.se);\n        chmax(ret,p1);\n    }\n    for(int i=x1+1;i<x2;i++){\n        pint p1=dfs(y1,x1,y2,i),p2=dfs(y1,i,y2,x2);\n        p1.fi+=p2.fi;chmin(p1.se,p2.se);\n        chmax(ret,p1);\n    }\n    return ret;\n}\n\nvoid solve(){\n\n    rep(i,H)rep(j,W)cin>>A[i][j];\n\n    rep(i,H)rep(j,W)sum[i+1][j+1]=A[i][j]+sum[i+1][j]+sum[i][j+1]-sum[i][j];\n    fill_n(***memo,55*55*55*55,pint(-1,-1));\n    sumall=f(0,0,H,W);\n    pint p=dfs(0,0,H,W);\n    cout<<p.fi<<\" \"<<S-sumall+p.se<<endl;\n}\n\nsigned main(){\n    while(cin>>H>>W>>S,H||W||S)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint h, w, s, m, a[44][44];\npii dp[44][44][44][44];\n\nint r(int li, int lj, int ri, int rj) {\n\treturn a[ri][rj] - a[ri][lj-1] - a[li-1][rj] + a[li-1][lj-1];\n}\n\npii rec(int li, int lj, int ri, int rj) {\n\tif (dp[li][lj][ri][rj].fi!=0) return dp[li][lj][ri][rj];\n\tpii res = mp(1,s-(m-r(li,lj,ri,rj)));\n\treps(i,li,ri) { // ヨコに切る\n\t\tif (s-(m-r(li,lj,i,rj))<0) continue;\n\t\tif (s-(m-r(i+1,lj,ri,rj))<0) continue;\n\t\tpii x = rec(li,lj,i,rj), y = rec(i+1,lj,ri,rj);\n\t\tchmax(res, mp(x.fi+y.fi, min(x.se,y.se)));\n\t}\n\treps(j,lj,rj) { // タテに切る\n\t\tif (s-(m-r(li,lj,ri,j))<0) continue;\n\t\tif (s-(m-r(li,j+1,ri,rj))<0) continue;\n\t\tpii x = rec(li,lj,ri,j), y = rec(li,j+1,ri,rj);\n\t\tchmax(res, mp(x.fi+y.fi, min(x.se,y.se)));\n\t}\n\treturn dp[li][lj][ri][rj] = res;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> s;\n\t\tif (h==0) break;\n\t\tm = 0;\n\t\trepst(i,1,h) repst(j,1,w) {\n\t\t\tcin >> a[i][j];\n\t\t\tm += a[i][j];\n\t\t}\n\t\trepst(i,1,h) repst(j,1,w) a[i][j] += a[i][j-1];\n\t\trepst(j,1,w) repst(i,1,h) a[i][j] += a[i-1][j];\n\t\trep(i,33) rep(j,33) rep(k,33) rep(l,33) dp[i][j][k][l] = mp(0,inf);\n\t\tpii res = rec(1,1,h,w);\n\t\tcout << res.fi << ' ' << res.se << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<p.first<<\" \"<<p.second;return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nvector<pii> memo;\nvvi city;\nint t,s;\n\nconstexpr int getBitCoor(int y, int x){\n\treturn (y<<6)+x;\n}\n\npii solve(int ty, int tx, int by, int bx){\n\tint c=(getBitCoor(ty,tx)<<12)+getBitCoor(by,bx);\n\tif(memo[c].first!=0) {\n\t\treturn memo[c];\n\t}\n\tpii ans(1,city[ty][tx]-city[ty][bx]-city[by][tx]+city[by][bx]);\n\tif(t-ans.sc>s)ans={-1,0};\n\t\n\trange(x,tx+1,bx){\n\t\tauto a=solve(ty,tx,by,x);\n\t\tauto b=solve(ty,x,by,bx);\n\t\tif(a.fs==-1 or b.fs==-1) continue;\n\t\ta.fs+=b.fs;\n\t\ta.sc=min(a.sc,b.sc);\n\t\tif(ans.fs<a.fs or (ans.fs==a.fs and ans.sc<a.sc)){\n\t\t\tans=a;\n\t\t}\n\t}\n\trange(y,ty+1,by){\n\t\tauto a=solve(ty,tx,y,bx);\n\t\tauto b=solve(y,tx,by,bx);\n\t\tif(a.fs==-1 or b.fs==-1) continue;\n\t\ta.fs+=b.fs;\n\t\ta.sc=min(a.sc,b.sc);\n\t\tif(ans.fs<a.fs or (ans.fs==a.fs and ans.sc<a.sc)){\n\t\t\tans=a;\n\t\t}\n\t}\n\tif(ans.fs==0) ans.fs=-1;\n\t//cout<<pii(ty,tx)<<\",\"<<pii(by,bx)<<\" = \"<<ans<<endl;\n\treturn memo[c]=ans;\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint h,w;\n\twhile(cin>>h>>w>>s,h){\n\t\tt=0;\n\t\tmemo.resize(1<<24,pii(0,0));\n\t\tcity=vvi(h+1,vi(w+1,0));\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>city[i+1][j+1];\n\t\t\tt+=city[i+1][j+1];\n\t\t}\n\t\trep(i,h)rep(j,w){\n\t\t\tint lt=getBitCoor(i,j)<<12;\n\t\t\tint rb=getBitCoor(i+1,j+1);\n\t\t\tif(t-city[i+1][j+1]<=s){\n\t\t\t\tmemo[lt+rb]=pii(1,city[i+1][j+1]);\n\t\t\t}else{\n\t\t\t\tmemo[lt+rb]=pii(-1,0);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\trep(i,h+1)range(j,1,w+1) city[i][j]+=city[i][j-1];\n\t\trange(i,1,h+1)rep(j,w+1) city[i][j]+=city[i-1][j];\n\t\tauto ans=solve(0,0,h,w);\n\t\tans.sc=s-t+ans.sc;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 35;\n\nint h,w,s;\nint u[MAX_N][MAX_N];\nint cnt[MAX_N][MAX_N][MAX_N][MAX_N];\nP res[MAX_N][MAX_N][MAX_N][MAX_N];  //??°???????????° ????????????\n\nP dfs(int lx,int ly,int rx,int ry)\n{\n    if(res[lx][ly][rx][ry].first != 0){\n        return res[lx][ly][rx][ry];\n    }\n    P cand1,cand2;\n    P cand = P(1,(s-(cnt[0][0][h-1][w-1]-cnt[lx][ly][rx][ry])));\n    for(int i=lx;i < rx;i++){\n        if(cnt[0][0][h-1][w-1]-cnt[lx][ly][i][ry] <= s && cnt[0][0][h-1][w-1]-cnt[i+1][ly][rx][ry]<= s){\n            P p1 = dfs(lx,ly,i,ry);\n            P p2 = dfs(i+1,ly,rx,ry);\n            int tmin = min(p1.se,p2.se);\n            cand1 = P(p1.fi+p2.fi,tmin);\n            cand = max(cand,cand1);\n        }\n    }\n    for(int i=ly;i < ry;i++){\n        if(cnt[0][0][h-1][w-1]-cnt[lx][ly][rx][i] <= s && cnt[0][0][h-1][w-1]-cnt[lx][i+1][rx][ry] <= s){\n            P p1 = dfs(lx,ly,rx,i);\n            P p2 = dfs(lx,i+1,rx,ry);\n            int tmin = min(p1.se,p2.se);\n            cand2 = P(p1.fi+p2.fi,tmin);\n            cand = max(cand,cand2);\n        }\n    }\n    res[lx][ly][rx][ry] = cand;\n    return res[lx][ly][rx][ry];\n}\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> s;\n        if(h == 0){\n            break;\n        }\n        rep(i,h){\n            rep(j,w){\n                cin >> u[i+1][j+1];\n            }\n        }\n        rep(i,h){\n            u[i][0] = 0;\n        }\n        rep(j,w){\n            u[0][j] = 0;\n        }\n        rep(i,h+1){\n            rep(j,w){\n                u[i][j+1] = u[i][j+1] + u[i][j];\n            }\n        }\n        rep(i,h){\n            rep(j,w+1){\n                u[i+1][j] = u[i+1][j] + u[i][j];\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                for(int k = i;k < h;k++){\n                    for(int l = j;l < w;l++){\n                        cnt[i][j][k][l] = u[k+1][l+1] - u[k+1][j] - u[i][l+1] + u[i][j];\n                    }\n                }\n            }\n        }\n        P ans = dfs(0,0,h-1,w-1);\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint h,w,s;\npii dp[32][32][32][32];\nint field[32][32];\nint sumTbl[32][32];\nint allSum;\n\npii dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[minx][miny][maxx][maxy].first!=-1)return dp[minx][miny][maxx][maxy];\n\tint sum=0;\n\t// »ÝÌé`Ìùva\n\tfor(int i=miny;i<=maxy;i++){\n\t\tif(minx==0)sum+=sumTbl[i][maxx];\n\t\telse sum+=sumTbl[i][maxx]-sumTbl[i][minx-1];\n\t}\n\tpii res(1,sum);\n\t// yÌÇ±©Åª\n\tfor(int i=miny;i<maxy;i++){\n\t\t// ªµ½ç»ê¼êÌÌæÌaðßA»ê¼êÌaªðð½·©²×é\n\t\tint sum1=0;\n\t\tint sum2=0;\n\t\tfor(int j=miny;j<=i;j++){\n\t\t\tif(minx==0)sum1+=sumTbl[j][maxx];\n\t\t\telse sum1+=sumTbl[j][maxx]-sumTbl[j][minx-1];\n\t\t}\n\t\tfor(int j=i+1;j<=maxy;j++){\n\t\t\tif(minx==0)sum2+=sumTbl[j][maxx];\n\t\t\telse sum2+=sumTbl[j][maxx]-sumTbl[j][minx-1];\n\t\t}\n//\t\tfor(int j=miny;j<=i;j++)for(int k=minx;k<=maxx;k++)sum1+=field[j][k];\n//\t\tfor(int j=i+1;j<=maxy;j++)for(int k=minx;k<=maxx;k++)sum2+=field[j][k];\n\t\t// ðð½·\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\t// »ê¼êÌßèlðæ¾\n\t\t\tpii p1=dfs(minx,miny,maxx,i);\n\t\t\tpii p2=dfs(minx,i+1,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)\n\t\t\t\tres.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\tfor(int i=minx;i<maxx;i++){\n\t\t// ªµ½ç»ê¼êÌÌæÌaðßA»ê¼êÌaªðð½·©²×é\n\t\tint sum1=0;\n\t\tint sum2=0;\n\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\tif(minx==0)sum1+=sumTbl[j][i];\n\t\t\telse sum1+=sumTbl[j][i]-sumTbl[j][minx-1];\n\t\t}\n\t\tfor(int j=miny;j<=maxy;j++)sum2+=sumTbl[j][maxx]-sumTbl[j][i];\n//\t\tfor(int j=miny;j<=maxy;j++)for(int k=minx;k<=i;k++)sum1+=field[j][k];\n//\t\tfor(int j=miny;j<=maxy;j++)for(int k=i+1;k<=maxx;k++)sum2+=field[j][k];\n\t\t// ðð½·\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\t// »ê¼êÌßèlðæ¾\n\t\t\tpii p1=dfs(minx,miny,i,maxy);\n\t\t\tpii p2=dfs(i+1,miny,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)\n\t\t\t\tres.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\treturn dp[minx][miny][maxx][maxy]=res;\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>s&&(h|w|s)){\n\t\tallSum=0;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\t\tfor(int k=0;k<32;k++)for(int l=0;l<32;l++)dp[i][j][k][l]=pii(-1,-1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tallSum+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(j==0)sumTbl[i][j]=field[i][j];\n\t\t\t\telse sumTbl[i][j]=sumTbl[i][j-1]+field[i][j];\n\t\t\t}\n\t\t}\n\t\tpii res=dfs(0,0,w-1,h-1);\n\t\tcout<<res.first<<\" \"<<s-(allSum-res.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\npii dptab[32][32][32][32];\nint sum[32][32];\nint in[32][32];\nint h, w, s;\nint all;\nint segmin;\n\npii solve(pii ul, pii br) {\n\tif(dptab[ul.fi][ul.se][br.fi-1][br.se-1].fi + 1)\n\t\treturn dptab[ul.fi][ul.se][br.fi-1][br.se-1];\n\n\tint tmp = 0;\n\tif(br.fi > 0 && br.se > 0)\n\t\ttmp += sum[br.fi-1][br.se-1];\n\tif(ul.fi > 0 && br.se > 0)\n\t\ttmp -= sum[ul.fi-1][br.se-1];\n\tif(br.fi > 0 && ul.se > 0)\n\t\ttmp -= sum[br.fi-1][ul.se-1];\n\tif(ul.fi > 0 && ul.se > 0)\n\t\ttmp += sum[ul.fi-1][ul.se-1];\n\n\tif(tmp < segmin)\n\t\treturn dptab[ul.fi][ul.se][br.fi-1][br.se-1] = pii(0,-1);\n\n\tpii nex = pii(1, tmp-segmin);\n\tpii res0, res1;\n\tfor(int i = ul.fi+1; i < br.fi; i++) {\n\t\tres0 = solve(ul, pii(i, br.se));\n\t\tres1 = solve(pii(i, ul.se), br);\n\n\t\tif(res0.fi > 0 && res1.fi > 0) {\n\t\t\tif(res0.fi + res1.fi > nex.fi) {\n\t\t\t\tnex.fi = res0.fi + res1.fi;\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t\telse if(res0.fi + res1.fi == nex.fi && min(res0.se, res1.se) > nex.se) {\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = ul.se+1; i < br.se; i++) {\n\t\tres0 = solve(ul, pii(br.fi, i));\n\t\tres1 = solve(pii(ul.fi, i), br);\n\n\t\tif(res0.fi > 0 && res1.fi > 0) {\n\t\t\tif(res0.fi + res1.fi > nex.fi) {\n\t\t\t\tnex.fi = res0.fi + res1.fi;\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t\telse if(res0.fi + res1.fi == nex.fi && min(res0.se, res1.se) > nex.se) {\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t}\n\t}\n\treturn dptab[ul.fi][ul.se][br.fi-1][br.se-1] = nex;\n}\n\nint main() {\n\twhile(cin >> h >> w >> s, h || w || s) {\n\t\t// init\n\t\tfor(int i = 0; i < 32*32; i++) sum[0][i] = in[0][i] = 0;\n\t\tfor(int i = 0; i < 1024*1024; i++) dptab[0][0][0][i] = pii(-1,-1);\n\t\tall = 0;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tcin >> in[i][j];\n\t\t\t\tall += in[i][j];\n\t\t\t}\n\t\t}\n\t\tsegmin = all-s;\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tsum[i][j] = in[i][j];\n\t\t\t\tif(i-1 >= 0)\n\t\t\t\t\tsum[i][j] += sum[i-1][j];\n\t\t\t\tif(j-1 >= 0)\n\t\t\t\t\tsum[i][j] += sum[i][j-1];\n\t\t\t\tif(i-1 >= 0 && j-1 >= 0)\n\t\t\t\t\tsum[i][j] -= sum[i-1][j-1];\n\t\t\t}\n\t\t}\n\n\t\tpii res;\n\t\tres = solve(pii(0,0),pii(h,w));\n\t\tcout << res.fi << \" \" << res.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define GROUP first\n#define ENE   second\ntypedef pair<int,int> pii;\nconst int N = 32;\npii dp[N][N][N][N];\nint sum[N][N][N][N];\nint in[N][N];\nint psum[N][N];\n\nvoid compute(int y,int x,int y2,int x2){\n  if (y == y2 && x == x2){\n    sum[y][x][y2][x2]=in[y][x];\n    return;\n  }\n  sum[y][x][y2][x2]=psum[y2][x2];//-psum[y2][x]-psum[y][x2]+psum[y][x];\n\n  if (x-1 >= 0)sum[y][x][y2][x2]-=psum[y2][x-1];\n  if (y-1 >= 0)sum[y][x][y2][x2]-=psum[y-1][x2];\n  if (y-1 >= 0 && x-1 >= 0)sum[y][x][y2][x2]+=psum[y-1][x-1];\n}\n\nvoid precalc(int r,int c){\n  rep(i,r){\n    rep(j,c){\n      psum[i][j]=0;\n      rep(ii,i+1)rep(jj,j+1)psum[i][j]+=in[ii][jj];\n    }\n  }\n  rep(i,r){\n    REP(ii,i,r){\n      rep(j,c){\n        REP(jj,j,c){\n          compute(i,j,ii,jj);\n        }\n      }\n    }\n  }\n}\n\nbool isbigger(pii& ret,pii &a1,pii &a2,int req){\n  int retgroup=ret.GROUP,cmpgroup=a1.GROUP+a2.GROUP;\n  int minreq=min(a1.ENE,a2.ENE);\n  //if (minreq < req)return false;\n\n  if (retgroup < cmpgroup)return true;\n  if (retgroup == cmpgroup){\n    if(ret.ENE < min(a1.ENE,a2.ENE))return true;\n  }\n  return false;\n}\n\npii solve(int y,int x,int y2,int x2,int req){\n  int tmp=sum[y][x][y2][x2];\n  if (tmp < req)return make_pair(0,0);\n  if (y == y2 && x == x2)return make_pair(1,tmp-req);\n  pii &ret=dp[y][x][y2][x2];\n  if (ret.GROUP != -1)return ret;\n  if (tmp >= req){\n    ret.GROUP=1;\n    ret.ENE=tmp-req;\n  }\n  //cout << ret.GROUP <<\" \" << ret.ENE << endl;\n  //ver\n  REP(i,x,x2){\n    pii a1=solve(y,x,y2,i,req);\n    pii a2=solve(y,i+1,y2,x2,req);\n    if (isbigger(ret,a1,a2,req)){\n      ret.GROUP=a1.GROUP+a2.GROUP;\n      ret.ENE=min(a1.ENE,a2.ENE);\n    }\n  }\n\n  //hor\n  REP(i,y,y2){\n    pii a1=solve(y,x,i,x2,req);\n    pii a2=solve(i+1,x,y2,x2,req);\n    if (isbigger(ret,a1,a2,req)){\n      ret.GROUP=a1.GROUP+a2.GROUP;\n      ret.ENE=min(a1.ENE,a2.ENE);\n    }\n  }\n  return ret;\n}\n\n\n\nmain(){\n  int r,c,sup;\n  while(cin>>r>>c>>sup && r){\n    rep(i,r)rep(j,c)rep(k,r)rep(l,c){\n      dp[i][j][k][l].first=-1;\n      dp[i][j][k][l].second=-1;\n      sum[i][j][k][l]=0;\n    }\n    rep(i,r)rep(j,c)cin>>in[i][j];\n    precalc(r,c);\n    int req=psum[r-1][c-1]-sup;\n    pii ans=solve(0,0,r-1,c-1,req);\n    cout << ans.GROUP <<\" \" << ans.ENE << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\n/** 累積和 */\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/** /累積和 */\n\n\ntypedef tuple<int, int, int, int> Kukei;\n\nint H, W, S;\nint total_power;\nVVI tile;\nVVI c_tile;\nvector< vector< vector< vector<PII> > > > memo;\n\nbool can_group(int x1, int x2, int y1, int y2) {\n\treturn total_power - S <= sum_csum2<int>(c_tile, y1, y2, x1, x2);\n}\n\nPII dfs(int x1, int x2, int y1, int y2) {\n\tPII tmp = memo[y1][x1][y2][x2];\n\tif (tmp.first != -1) {\n\t\treturn tmp;\n\t}\n\t\n\tPII res(-1, -1);\n\n\tfor (int v = x1 + 1; v < x2; v++) {\n\t\tPII a = dfs(x1, v, y1, y2);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(v, x2, y1, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tfor (int h = y1 + 1; h < y2; h++) {\n\t\tPII a = dfs(x1, x2, y1, h);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(x1, x2, h, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tif (res.first == -1 && can_group(x1, x2, y1, y2)) {\n\t\tres = make_pair(1, sum_csum2<int>(c_tile, y1, y2, x1, x2));\n\t}\n\n\treturn memo[y1][x1][y2][x2] = res;\n}\n\nint main(void) {\n\twhile(cin >> H >> W >> S, H) {\n\t\ttile = VVI(H, VI(W, 0));\n\t\ttotal_power = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\ttotal_power += tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemo = vector< vector< vector< vector<PII> > > >(H + 1,\n\t\t\t\tvector< vector< vector<PII> > >(W + 1,\n\t\t\t\tvector< vector<PII> >(H + 1,\n\t\t\t\tvector<PII>(W + 1,\n\t\t\t\tmake_pair(-1, -1)))));\n\n\t\tc_tile = calc_csum2<int>(tile);\n\n\t\tPII ans = dfs(0, W, 0, H);\n\n\t\tcout << ans.first << \" \" << (S - total_power + ans.second) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define INF 100000000\n#define mp make_pair\n#define pii pair<int,int>\n\nint h,w,s;\nint board[55][55];\nint box[55][55];\n\n\nvoid boxset(){\n\tfor(int i=1;i<=h;i++)box[i][1] = board[i-1][0] + box[i-1][1];\n\tfor(int i=1;i<=w;i++)box[1][i] = board[0][i-1] + box[1][i-1];\n\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tbox[i][j] = box[i-1][j] + box[i][j-1] - box[i-1][j-1] + board[i-1][j-1];\n\t}\n}\n\nint boxget(int y1,int x1,int y2,int x2){\n\treturn box[y2][x2] - box[y1][x2] - box[y2][x1] + box[y1][x1];\n}\n\n\n//pair<int,int> : 分割数,区画内の和の最小値\n\npii marge(pii a, pii b){\n\treturn mp(a.first + b.first,  min(a.second, b.second));\n}\n\npii memo[55][55][55][55];\npii saiki(int y1,int x1,int y2,int x2){\n\tif(memo[y1][x1][y2][x2].first!=0) return memo[y1][x1][y2][x2];\n\t\n\tpii cand = mp(1, boxget(y1,x1,y2,x2));\n\t\n\tpii a1,b1,a2,b2;\n\t\n\t//左右分割\n\tfor(int i=y1+1; i<y2; i++){\n\t\tpii a = saiki(y1, x1, i, x2);\n\t\tpii b = saiki(i, x1, y2, x2);\n\t\t\n\t\tcand = max(marge(a,b), cand);\n\t}\n\t\n\t//上下分割\n\tfor(int i=x1+1; i<x2; i++){\n\t\tpii a = saiki(y1, x1, y2, i);\n\t\tpii b = saiki(y1, i, y2, x2);\n\t\tcand = max(marge(a,b), cand);\n\t}\n\t\n\tif(boxget(0,0,h,w) - cand.second > s)cand = mp(-INF,0);\n\treturn memo[y1][x1][y2][x2] = cand;\n}\n\nint main(){\n\t\n\twhile(1){\n\t\t//入力\n\t\tcin>>h>>w>>s;\n\t\tif(h==0)break;\n\t\t\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>board[i][j];\n\t\t\tfor(int k=0;k<h;k++)for(int p=0;p<w;p++)memo[i][j][k][p] = mp(0,0);\n\t\t}\n\t\t\n\t\t//二次元累積和計算\n\t\tboxset();\n\t\t\n\t\tpii ans = saiki(0,0,h,w);\n\t\tprintf(\"%d %d\\n\",ans.first, ans.second + s - boxget(0,0,h,w));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint sum[33][33],ub;\npii dp[32][32][33][33];\n\ninline int rectsum(int t,int l,int b,int r){\n\treturn sum[b][r]-sum[t][r]-sum[b][l]+sum[t][l];\n}\n\npii solve(int t,int l,int b,int r){\n\tif(~dp[t][l][b][r].first) return dp[t][l][b][r];\n\n\tif(rectsum(t,l,b,r)<ub) return make_pair(-1,-1);\n\n\tpii ans(1,rectsum(t,l,b,r)-ub); // ツつアツづェツ暗按湘」ツ閉ェツ環つオツづ按つ「\n\t// ツ可。ツ陛サツ古シツづ可閉ェツ環つキツづゥ\n\tfor(int i=t+1;i<b;i++){\n\t\tpii tmp1=solve(t,l,i,r);\n\t\tpii tmp2=solve(i,l,b,r);\n\t\tans=max(ans,make_pair(tmp1.first+tmp2.first,min(tmp1.second,tmp2.second)));\n\t}\n\t// ツ縦ツ陛サツ古シツづ可閉ェツ環つキツづゥ\n\tfor(int j=l+1;j<r;j++){\n\t\tpii tmp1=solve(t,l,b,j);\n\t\tpii tmp2=solve(t,j,b,r);\n\t\tans=max(ans,make_pair(tmp1.first+tmp2.first,min(tmp1.second,tmp2.second)));\n\t}\n\treturn dp[t][l][b][r]=ans;\n}\n\nint main(){\n\tfor(int h,w,s;scanf(\"%d%d%d\",&h,&w,&s),h;){\n\t\trep(i,h) rep(j,w) rep(k,h+1) rep(l,w+1) dp[i][j][k][l].first=-1;\n\n\t\trep(i,h) rep(j,w) {\n\t\t\tint u; scanf(\"%d\",&u);\n\t\t\tsum[i+1][j+1]=sum[i+1][j]+sum[i][j+1]-sum[i][j]+u;\n\t\t}\n\t\tub=sum[h][w]-s;\n\n\t\tpii ans=solve(0,0,h,w);\n\t\tprintf(\"%d %d\\n\",ans.first,ans.second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\n\nint h,w,s;\npii dp[32][32][32][32];\nint field[32][32];\nint sumTbl[32][32];\nint fSum[32][32][32][32];\nint allSum;\n\npii dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[minx][miny][maxx][maxy].first!=-1)return dp[minx][miny][maxx][maxy];\n\tint sum=fSum[minx][miny][maxx][maxy];\n\t// »ÝÌé`Ìùva\n//\tfor(int i=miny;i<=maxy;i++){\n//\t\tif(minx==0)sum+=sumTbl[i][maxx];\n//\t\telse sum+=sumTbl[i][maxx]-sumTbl[i][minx-1];\n//\t}\n\t//sum=fSum[minx][miny][maxx][maxy];\n\tpii res(1,sum);\n\t// yÌÇ±©Åª\n\tfor(int i=miny;i<maxy;i++){\n\t\t// ªµ½ç»ê¼êÌÌæÌaðßA»ê¼êÌaªðð½·©²×é\n\t\tint sum1=fSum[minx][miny][maxx][i];\n\t\tint sum2=fSum[minx][i+1][maxx][maxy];\n//\t\tfor(int j=miny;j<=i;j++){\n//\t\t\tif(minx==0)sum1+=sumTbl[j][maxx];\n//\t\t\telse sum1+=sumTbl[j][maxx]-sumTbl[j][minx-1];\n//\t\t}\n//\t\tfor(int j=i+1;j<=maxy;j++){\n//\t\t\tif(minx==0)sum2+=sumTbl[j][maxx];\n//\t\t\telse sum2+=sumTbl[j][maxx]-sumTbl[j][minx-1];\n//\t\t}\n\t\t// ðð½·\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\t// »ê¼êÌßèlðæ¾\n\t\t\tpii p1=dfs(minx,miny,maxx,i);\n\t\t\tpii p2=dfs(minx,i+1,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)\n\t\t\t\tres.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\tfor(int i=minx;i<maxx;i++){\n\t\t// ªµ½ç»ê¼êÌÌæÌaðßA»ê¼êÌaªðð½·©²×é\n\t\tint sum1=fSum[minx][miny][i][maxy];\n\t\tint sum2=fSum[i+1][miny][maxx][maxy];\n//\t\tint sum1=0;\n//\t\tint sum2=0;\n//\t\tfor(int j=miny;j<=maxy;j++){\n//\t\t\tif(minx==0)sum1+=sumTbl[j][i];\n//\t\t\telse sum1+=sumTbl[j][i]-sumTbl[j][minx-1];\n//\t\t}\n//\t\tfor(int j=miny;j<=maxy;j++)sum2+=sumTbl[j][maxx]-sumTbl[j][i];\n\t\t// ðð½·\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\t// »ê¼êÌßèlðæ¾\n\t\t\tpii p1=dfs(minx,miny,i,maxy);\n\t\t\tpii p2=dfs(i+1,miny,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)\n\t\t\t\tres.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\treturn dp[minx][miny][maxx][maxy]=res;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&(h|w|s)){\n\t\tallSum=0;\n\t\tfor(int i=0;i<32;i++)\n\t\t\tfor(int j=0;j<32;j++)\n\t\t\t\tfor(int k=0;k<32;k++)\n\t\t\t\t\tfor(int l=0;l<32;l++)dp[i][j][k][l].first=dp[i][j][k][l].second=-1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tallSum+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(j==0)sumTbl[i][j]=field[i][j];\n\t\t\t\telse sumTbl[i][j]=sumTbl[i][j-1]+field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=i;k<h;k++){\n\t\t\t\t\tfor(int l=j;l<w;l++){\n\t\t\t\t\t\tfSum[j][i][l][k]=0;\n\t\t\t\t\t\t// s²ÆÉÁZ\n\t\t\t\t\t\tfor(int m=i;m<=k;m++){\n\t\t\t\t\t\t\tif(j!=0)fSum[j][i][l][k]+=sumTbl[m][l]-sumTbl[m][j-1];\n\t\t\t\t\t\t\telse fSum[j][i][l][k]+=sumTbl[m][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpii res=dfs(0,0,w-1,h-1);\n\t\tcout<<res.first<<\" \"<<s-(allSum-res.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n \nint h, w, s, u[32][32];\nPi dp[33][33][33][33];\nint Sum[34][34];\nint ALL;\n \nint getSum(int x1, int y1, int x2, int y2)\n{\n    return(Sum[y2][x2] + Sum[y1][x1] - Sum[y1][x2] - Sum[y2][x1]);\n}\n \nPi rec(int x1, int y1, int x2, int y2)  // ????????????\n{\n    if(dp[x1][y1][x2][y2] != Pi(-1, -1)) return(dp[x1][y1][x2][y2]);\n    Pi ret = Pi(-114514, 114514);\n    int JUYO = ALL - getSum(x1, y1, x2, y2);\n    if(JUYO <= s) {\n        ret = Pi(1, -JUYO);\n        for(int xline = x1 + 1; xline < x2; xline++) {  // ??????kill\n            Pi Left   = rec(x1, y1, xline, y2);\n            if(Left.first == -114514) continue;\n            Pi Right  = rec(xline, y1, x2, y2);\n            if(Right.first == -114514) continue;\n            ret = max(ret, Pi(Left.first + Right.first, -max(-Left.second, -Right.second)));\n        }\n     \n        for(int yline = y1 + 1; yline < y2; yline++) {  // ?¨????kill\n            Pi Left   = rec(x1, y1, x2, yline);\n            if(Left.first == -114514) continue;\n            Pi Right  = rec(x1, yline, x2, y2);\n            if(Right.first == -114514) continue;\n            ret = max(ret, Pi(Left.first + Right.first, -max(-Left.second, -Right.second)));\n        }\n    }\n    return(dp[x1][y1][x2][y2] = ret);\n}\n \nint main()\n{\n    while(scanf(\"%d %d %d\", &h, &w, &s), h) {\n        fill_n(***dp, 33 * 33 * 33 * 33, Pi(-1, -1));\n        ALL = 0;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                scanf(\"%d\", &u[i][j]);\n                ALL += u[i][j];\n            }\n        }\n         \n        for(int i = 1; i <= h; i++) {\n            for(int j = 1; j <= w; j++) {\n                Sum[i][j] = Sum[i][j - 1] + Sum[i - 1][j] - Sum[i - 1][j - 1] + u[i - 1][j - 1];\n            }\n        }\n        Pi ret = rec(0, 0, w, h);\n        cout << ret.first << \" \" << s + ret.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\npair<int, int>memo[33][33][33][33];\n\nint field[32][32];\nint sum[33][33];\n\n\nint getsum(int l, int r, int u, int d) {\n\treturn sum[d][r] - sum[u][r] - sum[d][l] + sum[u][l];\n}\n\npair<int,int> getans(const int l, const int r, const int u, const int d, const int rest) {\n\tif (memo[l][r][u][d].first != -1)return memo[l][r][u][d];\n\tconst int sum(getsum(l, r, u, d));\n\tif (sum < rest)return memo[l][r][u][d] = make_pair(0, 0);\n\telse if(sum<2*rest)return memo[l][r][u][d] = make_pair(1, sum-rest);\n\telse {\n\t\tpair<int, int>ans= make_pair(1, sum - rest);\n\t\tfor (int y = u + 1; y < d; ++y) {\n\t\t\tpair<int, int>a(getans(l, r, u, y, rest));\n\t\t\tpair<int, int>b(getans(l, r, y, d, rest));\n\t\t\tif (a.first > 0 && b.first>0) {\n\t\t\t\tpair<int, int>nans = make_pair(a.first + b.first, min(a.second, b.second));\n\t\t\t\tans = max(ans, nans);\n\t\t\t}\n\t\t}\n\t\tfor (int x = l + 1; x < r; ++x) {\n\t\t\tpair<int, int>a(getans(l, x, u, d, rest));\n\t\t\tpair<int, int>b(getans(x, r, u, d, rest));\n\t\t\tif (a.first > 0 && b.first>0) {\n\t\t\t\tpair<int, int>nans = make_pair(a.first + b.first, min(a.second, b.second));\n\t\t\t\tans = max(ans, nans);\n\t\t\t}\n\t\t}\n\t\treturn memo[l][r][u][d] = ans;\n\t}\n}\nint H, W;\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 33; ++i) {\n\t\t\tfor (int j = 0; j < 33; ++j) {\n\t\t\t\tfor (int k = 0; k < 33; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 33; ++l) {\n\t\t\t\t\t\tmemo[i][j][k][l] = make_pair(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S;\n\t\tcin >> H >> W >> S;\n\t\tif (!H)break;\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(sum, 0, sizeof(sum));\n\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tfield[i][j] = a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tsum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + field[i][j];\n\t\t\t}\n\t\t}\n\t\tint over = sum[H][W] - S;\n\t\tpair<int, int>ans(getans(0, W, 0, H, over));\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi G;\npii dp[50][50][50][50];\nint n,m,q,sum;\npii f(int a,int b,int c,int d){\n\tif(dp[a][b][c][d].first!=inf)return dp[a][b][c][d];\n\tdp[a][b][c][d]=pii(0,0);\n\tloop(i,a,c)loop(j,b,d)dp[a][b][c][d].second+=G[i][j];\n\trep(i,c-a-1){\n\t\tpii ta=f(a,b,a+i+1,d);\n\t\tpii tb=f(a+i+1,b,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\trep(i,d-b-1){\n\t\tpii ta=f(a,b,c,b+i+1);\n\t\tpii tb=f(a,b+i+1,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\tif(dp[a][b][c][d].second<sum)dp[a][b][c][d]=pii(-inf,-inf);\n//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n//\tcout<<dp[a][b][c][d].first<<\" \"<<dp[a][b][c][d].second<<endl;\n\treturn dp[a][b][c][d];\n}\nint main(){\n\twhile(cin>>n>>m>>q,n+m+q){\n\t\tsum=-q;\n\t\tG=vvi(n,vi(m));\n\t\trep(i,n)rep(j,m)cin>>G[i][j];\n\t\trep(i,n)rep(j,m)sum+=G[i][j];\n\t\trep(i,50)rep(j,50)rep(k,50)rep(l,50)\n\t\t\tdp[i][j][k][l]=pii(inf,inf);\n\t\tf(0,0,n,m);\n\t\tcout<<1+dp[0][0][n][m].first<<\" \"<<dp[0][0][n][m].second-sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nconst pii INIT = pii(-1,-1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y){\n  return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\npii solve(int l, int t, int r, int b){\n  pii& ans = memo[l][t][r][b];\n  if(ans != INIT) return ans;\n\n  int sum = getsum(l,t,r,b);\n  if(sum < E - S) return ans = pii(0, 0);\n  \n  ans = pii(1, S - E + sum);\n  \n  for(int i = l+1; i < r; ++i){\n    pii ra = solve(l,t,i,b);\n    pii rb = solve(i,t,r,b);\n    pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n    ans = max(ans, temp);\n  }\n\n  for(int i = t+1; i < b; ++i){\n    pii ra = solve(l,t,r,i);\n    pii rb = solve(l,i,r,b);\n    pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n    ans = max(ans, temp);\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> H >> W >> S, H){\n    memset(board, 0, sizeof(board));\n    for(int i = 0; i < 33; ++i)\n      for(int j = 0; j < 33; ++j)\n\tfor(int k = 0; k < 33; ++k)\n\t  for(int l = 0; l < 33; ++l)\n\t    memo[i][j][k][l] = INIT;\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tcin >> board[i+1][j+1];\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tboard[i+1][j+1] += board[i+1][j];\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tboard[i+1][j+1] += board[i][j+1];\n\n    E = getsum(0,0,H,W);\n    pii ans = solve(0,0,H,W);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\ninline int rng(int x1, int y1, int x2, int y2) {\n\treturn sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2];\n}\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1000000 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = (resl + resr) * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = (resl + resr) * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << ret / 1000000 << ' ' << ret % 1000000 - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_H = 32, MAX_W = 32;\nint H, W;\nint F[MAX_H][MAX_W];\nint sum[MAX_H + 1][MAX_W + 1];\nvoid init() {\n    for (int i = 0; i <= H; i++) sum[i][0] = 0;\n    for (int j = 0; j <= W; j++) sum[0][j] = 0;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + F[i][j];\n}\n// (y, x) \\in [sy, gy) × [sx, gx) を満たす(y, x)について, F[y][x]の総和を返す\nint getSum(int sy, int sx, int gy, int gx) {\n    return sum[gy][gx] - sum[gy][sx] - sum[sy][gx] + sum[sy][sx];\n}\n\nint S;\nbool Input() {\n    cin >> H >> W >> S;\n    if (H == 0 && W == 0 && S == 0) return false;\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) cin >> F[i][j];\n    return true;\n}\n\nconst int INF = 1<<28;\n\nint u;\npair<int, int> memo[MAX_H][MAX_W][MAX_H + 1][MAX_W + 1];\npair<int, int> dfs(int sy, int sx, int gy, int gx) {\n    if (memo[sy][sx][gy][gx].first >= 0) return memo[sy][sx][gy][gx];\n    if (getSum(sy, sx, gy, gx) < u) return make_pair(0, 0);\n    pair<int, int> ret = make_pair(1, getSum(sy, sx, gy, gx));\n    for (int y = sy + 1; y < gy; y++) {\n        pair<int, int> p = dfs(sy, sx, y, gx);\n        pair<int, int> q = dfs(y, sx, gy, gx);\n        ret = max(ret, make_pair(p.first + q.first, min(p.second, q.second)));\n    }\n    for (int x = sx + 1; x < gx; x++) {\n        pair<int, int> p = dfs(sy, sx, gy, x);\n        pair<int, int> q = dfs(sy, x, gy, gx);\n        ret = max(ret, make_pair(p.first + q.first, min(p.second, q.second)));\n    }\n    return memo[sy][sx][gy][gx] = ret;\n}\nvoid Solve() {\n    init();\n    u = getSum(0, 0, H, W) - S;\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n        for (int y = 0; y <= H; y++) for (int x = 0; x <= W; x++) {\n            memo[i][j][y][x] = make_pair(-1, -1);\n        }\n    }\n    pair<int, int> Ans = dfs(0, 0, H, W);\n    cout << Ans.first << \" \" << Ans.second - u << endl;\n}\n\nint main() {\n    while (Input()) Solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\ntemplate<typename Type>\nvoid chmax(Type &A, Type B) {\n    A = max(A, B);\n}\n\nconst int INF = 1 << 28;\nint H, W, S, lim;\nint A[40][40], sum[40][40];\npair<int, int> dp[40][40][40][40];\n\nint get_sum(int lx, int ly, int rx, int ry) {\n    return sum[rx][ry] - sum[rx][ly] - sum[lx][ry] + sum[lx][ly];\n}\n\n// 左上、右下 (半開)\npair<int, int> solve(int lx, int ly, int rx, int ry) {\n    // printf(\"%d, %d, %d, %d\\n\", lx, ly, rx, ry);\n    pair<int, int> &val = dp[lx][ly][rx][ry];\n    if(val != make_pair(-1, -1)) return val;\n\n    int cur_sum = get_sum(lx, ly, rx, ry);\n    if(cur_sum < lim) {\n        return val = make_pair(-1, INF);\n    }\n    else {\n        val = make_pair(1, cur_sum - lim);\n    }\n\n    // split (x)\n    for(int i=lx+1; i<rx; i++) {\n        pair<int, int> vl = solve(lx, ly, i, ry);\n        pair<int, int> vr = solve(i, ly, rx, ry);\n        int rl = vl.first + vr.first;\n        int rr = min(vl.second, vr.second);\n        chmax(val, make_pair(rl, rr));\n    }\n\n    // split (y)\n    for(int i=ly+1; i<ry; i++) {\n        pair<int, int> vl = solve(lx, ly, rx, i);\n        pair<int, int> vr = solve(lx, i, rx, ry);\n        int rl = vl.first + vr.first;\n        int rr = min(vl.second, vr.second);\n        chmax(val, make_pair(rl, rr));\n    }\n    return val;\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d%d%d\", &H, &W, &S);\n        if(!H) break;\n\n        memset(A, 0, sizeof(A));\n        memset(sum, 0, sizeof(sum));\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                scanf(\"%d\", &A[i][j]);\n                sum[i+1][j+1] = A[i][j];\n            }\n        }\n\n        // left -> right\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                sum[i+1][j+1] += sum[i+1][j];\n            }\n        }\n\n        // up -> down\n        for(int j=0; j<W; j++) {\n            for(int i=0; i<H; i++) {\n                sum[i+1][j+1] += sum[i][j+1];\n            }\n        }\n\n        lim = get_sum(0, 0, H, W) - S;\n        fill(dp[0][0][0], dp[40][0][0], make_pair(-1, -1));\n        pair<int, int> ans = solve(0, 0, H, W);\n        printf(\"%d %d\\n\", ans.first, ans.second);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n#define F first\n#define S second\nP dp[33][33][33][33];\nint h,w,s,sum[33][33],a[33][33],SUM;\nint get(int ly,int lx,int ry,int rx){\n  return sum[ry+1][rx+1]-sum[ry+1][lx]-sum[ly][rx+1]+sum[ly][lx];\n}\nP dfs(int ly,int lx,int ry,int rx){\n  if(dp[ly][lx][ry][rx]!=P(0,1e9))return dp[ly][lx][ry][rx];\n  P res=P(1,s-(SUM-get(ly,lx,ry,rx)));//cout<<get(ly,lx,ry,rx)<<endl;\n  for(int i=lx;i<rx;i++){\n    if(s-(SUM-get(ly,lx,ry,i))<0)continue;\n    if(s-(SUM-get(ly,i+1,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,ry,i),res2=dfs(ly,i+1,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  for(int i=ly;i<ry;i++){\n    if(s-(SUM-get(ly,lx,i,rx))<0)continue;\n    if(s-(SUM-get(i+1,lx,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,i,rx),res2=dfs(i+1,lx,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  return dp[ly][lx][ry][rx]=res;\n}\n\nint main(){\n  while(cin>>h>>w>>s,s){\n    SUM=0;\n    r(i,h)r(j,w)cin>>a[i][j],SUM+=a[i][j];\n    r(i,33)r(j,33)r(k,33)r(l,33)dp[i][j][k][l]=P(0,1e9);\n    memset(sum,0,sizeof(sum));\n    r(i,h)r(j,w)sum[i+1][j+1]=a[i][j];\n    r(i,h+1)r(j,w)sum[i][j+1]+=sum[i][j];\n    r(j,w+1)r(i,h)sum[i+1][j]+=sum[i][j];\n\n    P p=dfs(0,0,h-1,w-1);\n    cout<<p.F<<' '<<p.S<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\ninline int solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2]) return dp[y1][x1][y2][x2];\n\tint ret = 1048576 + rng(x1, y1, x2, y2);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2), petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i), petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", (ret >> 20), ((ret - o) & 1048575));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint u[33][33];\nP memo[33][33][33][33];\nint h, w, s, ming;\n\nstruct group{\n\tint bx, by, ex, ey;\n\tgroup(int x, int y, int _x, int _y){\n\t\tbx = x;\n\t\tby = y;\n\t\tex = _x;\n\t\tey = _y;\n\t}\n};\n\nint calc(int bx, int by, int ex, int ey){\n\tint sum=0;\n\tif( bx > ex ) swap( bx, ex );\n\tif( by > ey ) swap( by, ey );\n\tfor(int y=by; y<ey; y++){\n\t\tfor(int x=bx; x<ex; x++){\n\t\t\tsum += u[y][x];\n\t\t}\n\t}\n\treturn sum;\n}\n\nP solve(int bx, int by, int ex, int ey){\n\tif( memo[bx][by][ex][ey].first ){\n\t\treturn memo[bx][by][ex][ey];\n\t}\n\tP result(1, calc(bx,by,ex,ey)-ming), tmp;\n//\tcout << \"calc: \" << calc(bx,by,ex,ey) << endl;\n//\tresult = max(result, tmp);\n\tfor(int y=by+1; y<ey; y++){\n\t\tif( calc(bx,by,ex,y) >= ming &&\n\t\t\tcalc(bx,y,ex,ey) >= ming ){\n\t\t\tP t1 = solve(bx,by,ex,y);\n\t\t\tP t2 = solve(bx,y,ex,ey);\n\t\t\ttmp.first = t1.first + t2.first;\n\t\t\ttmp.second = min(t1.second, t2.second);\n\t\t\tresult = max(result, tmp);\n//\tcout << \"calc2y: \" << calc(bx,by,ex,y)+calc(bx,y,ex,ey) << endl;\n//\tcout << tmp.first << \"  \" << tmp.second << endl; \n\t\t}\n\t}\n\tfor(int x=bx+1; x<ex; x++){\n\t\tif( calc(bx,by,x,ey) >= ming &&\n\t\t\tcalc(x,by,ex,ey) >= ming ){\n\t\t\tP t1 = solve(bx,by,x,ey);\n\t\t\tP t2 = solve(x,by,ex,ey);\n\t\t\ttmp.first = t1.first + t2.first;\n\t\t\ttmp.second = min(t1.second, t2.second);\n\t\t\tresult = max(result, tmp);\n//\tcout << \"calc2x: \" << calc(bx,by,x,ey)+calc(x,by,ex,ey) << endl;\n//\tcout << tmp.first << \"  \" << tmp.second << endl; \n\t\t}\n\t}\n//\tcout << result.first << \"  \" << result.second << endl; \n\tmemo[bx][by][ex][ey] = result;\n\treturn result;\n}\n\nint main(){\n\twhile(cin >> h >> w >> s, h|w|s){\n\t\tint sume=0;//, ans=0;\n\t\tfill( memo[0][0][0], memo[0][0][0]+33*33*33*33, P(0,0) );\n\t\tfor(int y=0; y<h; y++){\n\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\tcin >> u[y][x];\n\t\t\t\tsume += u[y][x];\n\t\t\t}\n\t\t}\n\t\tming = sume - s;\n//\t\tcout << \"ming: \" << ming << endl;\n\t\tP ans = solve(0,0,w,h);\n//\t\tqueue< vector<group> > que;\n//\t\tvector<group> grs;\n//\t\tgrs.push_back( group(0,0,w,h) );\n//\t\tque.push( group(0,0,w,h) );\n//\t\twhile( !que.empty() ){\n//\t\t\tvector<group> grs = que.front();\n//\t\t\tque.pop();\n//\t\t\tfor(int i=0; i<grs.size(); i++ ){\n//\t\t\t}\n//\t\t}\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, s;\nP memo[35][35][35][35];\nint u[35][35];\nint sum, diff;\n\nstruct CumulativeSum2D{\n    vector<vector<int> > data;\n    CumulativeSum2D(int H, int W) : data(H + 1, vector<int>(W + 1, 0)) {}\n    //要素(x,y)に値zを加える\n    void add(int x, int y, int z){\n        ++x, ++y;\n        if(x >= data.size() || y >= data[0].size()) return;\n        data[x][y] += z;\n    }\n    void build(){\n        for(int i = 1; i < data.size(); i++) {\n        for(int j = 1; j < data[i].size(); j++) {\n            data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n            }\n        }\n    }\n    //左上[sy, sx], 右下(gy, gx)の矩形内の和を求める(半開区間) (0-index)\n    int query(int sx, int sy, int gx, int gy){\n        return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n    }\n};\n\nCumulativeSum2D cs(35, 35);\n\nP solve(int y1, int x1, int y2, int x2){\n    if(memo[y1][x1][y2][x2].first != -1) return memo[y1][x1][y2][x2];\n    int inside = cs.query(y1, x1, y2, x2);    \n    if(inside < diff) return memo[y1][x1][y2][x2] = {-1, -1};\n    P res = {1, inside - diff};\n    rep(i, y1 + 1, y2){\n        P part1 = solve(y1, x1, i, x2);\n        P part2 = solve(i, x1, y2, x2);\n        if(part1.first == -1 || part2.first == -1) continue;\n        int parts = part1.first + part2.first;\n        int demand = min(part1.second, part2.second);\n        if(res.first < parts){\n            res = {parts, demand};\n        }else if(res.first == parts && res.second < demand){\n            res = {parts, demand};\n        }\n    }\n    rep(i, x1 + 1, x2){\n        P part1 = solve(y1, x1, y2, i);\n        P part2 = solve(y1, i, y2, x2);\n        if(part1.first == -1 || part2.first == -1) continue;\n        int parts = part1.first + part2.first;\n        int demand = min(part1.second, part2.second);\n        if(res.first < parts){\n            res = {parts, demand};\n        }else if(res.first == parts && res.second < demand){\n            res = {parts, demand};\n        }\n    }\n    return memo[y1][x1][y2][x2] = res;\n}\n\n\nint main(){\n    while(cin >> h >> w >> s, h){\n        sum = 0;\n        rep(i, 0, 35) rep(j, 0, 35) rep(k, 0, 35) rep(l, 0, 35) memo[i][j][k][l] = {-1, -1};\n        rep(i, 0, 35) rep(j, 0, 35) cs.data[i][j] = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> u[i][j];\n                sum += u[i][j];\n                cs.add(i, j, u[i][j]);\n            }\n        }\n        cs.build();\n        diff = sum - s;\n        P ans = solve(0, 0, h, w);\n        cout << ans.first << ' ' << ans.second << endl;\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint h, w, s, all;\nint town[32][32];\nP dp[1024][1024];\n\nvoid dfs(P lu, P rd) {\n  int p = lu.fi + lu.se * w, q = rd.fi + rd.se * w;\n\n  if (dp[p][q] != P(0, -INF)) return;\n\n  int sum = 0;\n  repl(i, lu.se, rd.se + 1) {\n    repl(j, lu.fi, rd.fi + 1) {\n      sum += town[i][j];\n    }\n  }\n\n  int maxDemmand = all - sum;\n  if (s >= maxDemmand) dp[p][q] = P(1, s - maxDemmand);\n\n  if ((all - s) * 2 <= sum) {\n    repl(i, lu.se, rd.se) {\n      int pp = lu.fi + (i + 1) * w, qq = rd.fi + i * w;\n      dfs(lu, P(rd.fi, i));\n      dfs(P(lu.fi, i + 1), rd);\n      maxch(dp[p][q], P(dp[p][qq].fi + dp[pp][q].fi, min(dp[p][qq].se, dp[pp][q].se)));\n    }\n    repl(i, lu.fi, rd.fi) {\n      int pp = i + 1 + lu.se * w, qq = i + rd.se * w;\n      dfs(lu, P(i, rd.se));\n      dfs(P(i + 1, lu.se), rd);\n      maxch(dp[p][q], P(dp[p][qq].fi + dp[pp][q].fi, min(dp[p][qq].se, dp[pp][q].se)));\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> h >> w >> s, h | w | s) {\n    all = 0;\n    rep(i, h)rep(j, w) {\n      cin >> town[i][j];\n      all += town[i][j];\n    }\n\n    rep(i, h * w)rep(j, h * w) dp[i][j] = P(0, -INF);\n    dfs(P(0, 0), P(w - 1, h - 1));\n\n    cout << dp[0][h * w - 1].fi << \" \" << dp[0][h * w - 1].se << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, ss;\nint a[34][34], s[35][35];\npii v[34][34][34][34];\nint u[34][34][34][34], flag;\n\nconst int inf = (int)1e9;\n\ninline pii combine(const pii &a, const pii &b) {\n\treturn make_pair(a.first + b.first, min(a.second, b.second));\n}\n\npii dp(int l, int b, int r, int t) {\n\t//cout << l << ' ' << r << ' ' << b << ' ' << t << ' ' << v[l][b][r][t]\n\tif (u[l][b][r][t] == flag)\n\t\treturn v[l][b][r][t];\n\tu[l][b][r][t] = flag;\n\tint sum = s[l][b] + s[r][t] - s[l][t] - s[r][b];\n\tif (ss - s[0][0] + sum < 0) return make_pair(-inf, -inf);\n\tpair<int, int> res(1, ss - s[0][0] + sum);\n\tfor (int i = l + 1; i < r; i++)\n\t\tres = max(res, combine(dp(l, b, i, t), dp(i, b, r, t)));\n\tfor (int i = b + 1; i < t; i++)\n\t\tres = max(res, combine(dp(l, b, r, i), dp(l, i, r, t)));\n\tv[l][b][r][t] = res;\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> n >> m >> ss) {\n\t\tif (!n && !m && !ss) break;\n\t\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> a[i][j];\n\t\tmemset(s, 0, sizeof(s));\n\t\tmemset(u, 0, sizeof(u));\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\ts[i][j] = s[i + 1][j] + s[i][j + 1] + a[i][j] - s[i + 1][j + 1];\n\t\tflag += 10;\n\t\tpii res = dp(0, 0, n, m);\n\t\tcout << res.first << ' ' << res.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nint H, W, s, fusoku;\nint u[40][40];\nint sum[40][40];\nconst int INF = 100*100*100;\npair<int, int> memo[33][33][33][33];\n\ninline int region_sum(int y, int x, int h, int w) {\n  return sum[y+h][x+w] + sum[y][x] - sum[y+h][x] - sum[y][x+w];\n}\n\npair<int, int> calc(int y, int x, int h, int w) {\n  if (memo[y][x][h][w].first != -1) { return memo[y][x][h][w]; }\n  int rs = region_sum(y, x, h, w);\n  if (rs < fusoku) {\n    return memo[y][x][h][w] = make_pair(-INF, -INF);\n  }\n  pair<int, int> ret = make_pair(1, rs);\n  for (int i = 1; i < h; ++i) {\n    pair<int, int> ret1 = calc(y, x, i, w);\n    pair<int, int> ret2 = calc(y+i, x, h-i, w);\n    ret = max(ret, make_pair(ret1.first + ret2.first, min(ret1.second, ret2.second)));\n  }\n  for (int i = 1; i < w; ++i) {\n    pair<int, int> ret1 = calc(y, x, h, i);\n    pair<int, int> ret2 = calc(y, x+i, h, w-i);\n    ret = max(ret, make_pair(ret1.first + ret2.first, min(ret1.second, ret2.second)));\n  }\n  return memo[y][x][h][w] = ret;\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &H, &W, &s), H|W|s) {\n    memset(memo, -1, sizeof(memo));\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        scanf(\"%d\", &u[y][x]);\n      }\n    }\n    memset(sum, 0, sizeof(sum));\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x <= W; ++x) {\n        sum[y][x] = sum[y-1][x] + sum[y][x-1] - sum[y-1][x-1] + u[y-1][x-1];\n      }\n    }\n    fusoku = sum[H][W] - s;\n    pair<int, int> ret = calc(0, 0, H, W);\n    printf(\"%d %d\\n\", ret.first, s - (sum[H][W] - ret.second));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint h,w,s;\nint rem;\nint u[35][35];\nint rui[35][35];\nP dp[35][35][35][35];\ninline int sum(int t,int b,int l,int r){\n    return rui[b][r]-rui[t-1][r]-rui[b][l-1]+rui[t-1][l-1];\n}\nP rec(int t,int b,int l,int r){\n    if(dp[t][b][l][r]!=P(-1,-1))return dp[t][b][l][r];\n    if(sum(t,b,l,r)<rem)return dp[t][b][l][r]=P(-INF,-INF);\n    P ret = P(1,sum(t,b,l,r));\n    for(int i=t;i<b;i++){\n        rec(t,i,l,r);\n        rec(i+1,b,l,r);\n        int num = dp[t][i][l][r].fi+dp[i+1][b][l][r].fi;\n        int smallest = min(dp[t][i][l][r].sec,dp[i+1][b][l][r].sec);\n        if(num<0)continue;\n        if(num>ret.fi){\n            ret.fi = num;\n            ret.sec = smallest;\n        }else if(num==ret.fi){\n            if(ret.sec<smallest)ret.sec = smallest;  \n        }\n    }\n    for(int i=l;i<r;i++){\n        rec(t,b,l,i);\n        rec(t,b,i+1,r);\n        int num = dp[t][b][l][i].fi+dp[t][b][i+1][r].fi;\n        int smallest = min(dp[t][b][l][i].sec,dp[t][b][i+1][r].sec);\n        if(num<0)continue;\n        if(num>ret.fi){\n            ret.fi = num;\n            ret.sec = smallest;\n        }else if(num==ret.fi){\n            if(ret.sec<smallest)ret.sec = smallest;  \n        }\n    }\n    //printf(\"t:%d b:%d l:%d r:%d number:%d smallest:%d\\n\",t,b,l,r,ret.fi,ret.sec);\n    return dp[t][b][l][r]=ret;\n}   \nint solve(){\n    scanf(\"%d %d %d\",&h,&w,&s);\n    if(h+w+s==0)return 1;\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            scanf(\"%d\",&u[i][j]);\n            rui[i][j]=u[i][j];\n        }\n    }\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            rui[i][j]+=rui[i][j-1];\n        }\n    }\n    for(int j=1;j<=w;j++){\n        for(int i=1;i<=h;i++){\n            rui[i][j]+=rui[i-1][j];\n        }\n    }\n    rem = sum(1,h,1,w)-s;\n    for(int i=0;i<35;i++){\n        for(int j=0;j<35;j++){\n            for(int k=0;k<35;k++){\n                for(int l=0;l<35;l++){\n                    dp[i][j][k][l]=P(-1,-1);\n                }\n            }\n        }\n    }\n    /*while(1){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        cout << sum(a,b,c,d) << endl;\n    }*/\n    P ans = rec(1,h,1,w);\n    printf(\"%d %d\\n\",ans.fi,s-(sum(1,h,1,w)-ans.sec));\n    return 0;\n}\nint main(){\n    while(!solve()){}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, T;\nvector< vector<int> > A;\nbool m1[32][32][32][32];\nP m2[32][32][32][32];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, getM(x1, y1, x2, y2)-T);\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> T, H || W || T) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[0][0][0]+32*32*32, false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tT = sum - T;\n\t\tassert(T >= 0);\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n\n\n#endif // 0\n\n#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int MAXN = (int) 35;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\nint H,W,S;\nint f[MAXN][MAXN][MAXN][MAXN];\nint g[MAXN][MAXN][MAXN][MAXN];\nint a[MAXN][MAXN];\nint TOTAL;\nint MI;\n\nint get_sum(int i,int j,int k,int t){\n    return a[k][t]-a[k][j-1]-a[i-1][t]+a[i-1][j-1];\n}\n\nvoid DFS(int I,int J,int K,int T){\n    f[I][J][K][T]=1;\n    g[I][J][K][T]=get_sum(I,J,K,T);\n    if(I==K&&J==T) return;\n    if(g[I][J][K][T]<MI) return;\n    for(int i=I;i<K;i++){\n        if(f[I][J][i][T]==-1) DFS(I,J,i,T);\n        if(f[i+1][J][K][T]==-1) DFS(i+1,J,K,T);\n        if(g[I][J][i][T]>=MI&&g[i+1][J][K][T]>=MI){\n            if(f[I][J][i][T]+f[i+1][J][K][T]>f[I][J][K][T]){\n                f[I][J][K][T]=f[I][J][i][T]+f[i+1][J][K][T];\n                g[I][J][K][T]=min(g[I][J][i][T],g[i+1][J][K][T]);\n            }\n            else if(f[I][J][i][T]+f[i+1][J][K][T]==f[I][J][K][T]){\n                int cur_mi=min(g[I][J][i][T],g[i+1][J][K][T]);\n                g[I][J][K][T]=max(g[I][J][K][T],cur_mi);\n            }\n        }\n    }\n    for(int j=J;j<T;j++){\n        if(f[I][J][K][j]==-1) DFS(I,J,K,j);\n        if(f[I][j+1][K][T]==-1) DFS(I,j+1,K,T);\n        if(g[I][J][K][j]>=MI&&g[I][j+1][K][T]>=MI){\n            if(f[I][J][K][j]+f[I][j+1][K][T]>f[I][J][K][T]){\n                f[I][J][K][T]=f[I][J][K][j]+f[I][j+1][K][T];\n                g[I][J][K][T]=min(g[I][J][K][j],g[I][j+1][K][T]);\n            }\n            else if(f[I][J][K][j]+f[I][j+1][K][T]==f[I][J][K][T]){\n                int cur_mi=min(g[I][J][K][j],g[I][j+1][K][T]);\n                g[I][J][K][T]=max(g[I][J][K][T],cur_mi);\n            }\n        }\n    }\n}\n\nvoid work(){\n    while(~scanf(\"%d%d%d\",&H,&W,&S)){\n        if(H==0&&W==0&&S==0) break;\n        TOTAL=0;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                scanf(\"%d\",&a[i][j]);\n                TOTAL+=a[i][j];\n                a[i][j]+=a[i][j-1];\n            }\n        }\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                a[i][j]+=a[i-1][j];\n            }\n        }\n//        for(int i=1;i<=H;i++){\n//            for(int j=1;j<=W;j++){\n//                printf(\"%d \",a[i][j]);\n//            }\n//            printf(\"\\n\");\n//        }\n        MI=TOTAL-S;\n        memset(f,-1,sizeof(f));\n        memset(g,-1,sizeof(g));\n        DFS(1,1,H,W);\n        printf(\"%d %d\\n\",f[1][1][H][W],g[1][1][H][W]-MI);\n    }\n}\n\nint main(){\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1048576 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", (ret >> 20), ((ret - o) & 1048575));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e17 + 9;\n\n#define int ll\n#define double ld\n\n//dp[y][x][ty][tx] = ????§???¢(y,x,ty,tx)??§???????????¨?????§??????(?????§?????°???????????°, ?????§?????????)\nP dp[32][32][32][32];\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\t\n\tint h, w, s;\n\twhile (cin >> h >> w >> s && h) {\n\t\trep(y, h)rep(x, w)rep(ty, h)rep(tx, w)dp[y][x][ty][tx] = P(-1, 0);\n\t\t\n\t\tint d[32][32];\n\t\tint sum = 0;\n\t\trep(y, h)rep(x, w) {\n\t\t\tcin >> d[y][x];\n\t\t\tsum += d[y][x];\n\t\t}\n\t\trep(y, h)rep(x, w) {\n\t\t\tdp[y][x][y][x] = P(sum - d[y][x] <= s ? 1 : 0, d[y][x]);\n\t\t}\n\t\tauto unite = [&](P t0, P t1) {\n\t\t\tif (t1.first == 0)swap(t0, t1);\n\n\t\t\tif (t0.first == 0) {\n\t\t\t\tif (t1.first <= 1) {\n\t\t\t\t\tauto ret = P(t1.first, t0.second + t1.second);\n\t\t\t\t\tif (sum - ret.second <= s)ret.first = 1;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn P(-1, -1);\n\t\t\t}\n\n\t\t\treturn P(t0.first + t1.first, min(t0.second, t1.second));\n\t\t};\n\t\t\n\t\tfunction<P(int, int, int, int)> solve = [&](int y,int x,int ty,int tx) {\n\t\t\tif (dp[y][x][ty][tx].first != -1) {\n\t\t\t\treturn dp[y][x][ty][tx];\n\t\t\t}\n\t\t\tP ret(-1, -1);\n\t\t\tfor (int ay = y; ay < ty; ay++) {\n\t\t\t\tret = max(unite(solve(y, x, ay, tx), solve(ay+1, x, ty, tx)), ret);\n\t\t\t}\n\t\t\tfor (int ax = x; ax < tx; ax++) {\n\t\t\t\tret = max(unite(solve(y, x, ty, ax), solve(y, ax+1, ty, tx)), ret);\n\t\t\t}\n\t\t\treturn dp[y][x][ty][tx] = ret;\n\t\t};\n\t\tauto ans = solve(0, 0, h-1, w-1);\n\t\tans.second = s - (sum - ans.second);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\ntypedef vector<pair<int,int>> vp;\ntypedef vector<vp> vvp;\ntypedef vector<vvp> vvvp;\ntypedef vector<vvvp> vvvvp;\n\nconst int INF=1e9;\nconst pair<int,int> UNSOLVED={-INF-1,INF+1};\nconst pair<int,int> BAD={-INF,-INF};\n\nint h,w,s;\nint all_sum;\n\npair<int,int> merge(pair<int,int> c1,pair<int,int> c2){\n  return {c1.first+c2.first,min(c1.second,c2.second)};\n}\n\npair<int,int> dfs(int i,int j,int ii,int jj,vvvvp& dp, const vvi& sum){\n  if(dp[i][j][ii][jj]!=UNSOLVED){\n    return dp[i][j][ii][jj];\n  }  \n  int val=sum[ii+1][jj+1]-sum[i][jj+1]-sum[ii+1][j]+sum[i][j];\n\n  if(all_sum-val>s){\n    return dp[i][j][ii][jj]=BAD;\n  }\n  \n  pair<int,int> res={1,s-(all_sum-val)};\n  for(int id=i;id<ii;id++){\n    auto chunk1=dfs(i,j,id,jj,dp,sum);\n    auto chunk2=dfs(id+1,j,ii,jj,dp,sum);\n    auto kouho=merge(chunk1,chunk2);\n    res=max(res,kouho);\n  }\n  \n  for(int jd=j;jd<jj;jd++){\n    auto chunk1=dfs(i,j,ii,jd,dp,sum);\n    auto chunk2=dfs(i,jd+1,ii,jj,dp,sum);\n    auto kouho=merge(chunk1,chunk2);\n    res=max(res,kouho);\n  }\n\n  return dp[i][j][ii][jj]=res;\n}\nint main(){\n  while(cin>>h>>w>>s,h){\n    vvi u(h,vi(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>u[i][j];\n      }\n    }\n    vvi sum(h+1,vi(w+1,0));\n    vvvvp dp(h,vvvp(w,vvp(h,vp(w,UNSOLVED))));\n    \n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+u[i-1][j-1];\n      }\n    }\n    all_sum=sum[h][w];\n    auto res=dfs(0,0,h-1,w-1,dp,sum);\n\n    cout<<res.first<<\" \"<<res.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1<<28)\ninline void cmax(int &a, int b) { if (a < b) a = b; }\n\nint n, m, S, f[32][32], _sum[40][40];\n\ninline int sum(int x1, int y1, int x2, int y2) {\n    return _sum[x2+1][y2+1]-_sum[x2+1][y1]-_sum[x1][y2+1]+_sum[x1][y1];\n}\n\nint dp[32][32][32][32];\n\nint solve(int lb) {\n    for (int w = 0; w < n; w++) rep (x1, n-w) {\n        const int x2 = x1+w;\n        for (int h = 0; h < m; h++) rep (y1, m-h) {\n            const int y2 = y1+h;\n            if (sum(x1, y1, x2, y2) < lb) {\n                dp[x1][x2][y1][y2] = -INF;\n                continue;\n            }\n            dp[x1][x2][y1][y2] = 1;\n            for (int i = x1; i < x2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][i][y1][y2]+dp[i+1][x2][y1][y2]);\n            }\n            for (int i = y1; i < y2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][x2][y1][i]+dp[x1][x2][i+1][y2]);\n            }\n        }\n    }\n    return dp[0][n-1][0][m-1];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &n, &m, &S);\n        if (n == 0) return 0;\n        rep (i, n) rep (j, m) scanf(\"%d\", f[i]+j);\n        rep (i, n) rep (j, m) {\n            _sum[i+1][j+1] = f[i][j]+_sum[i+1][j]+_sum[i][j+1]-_sum[i][j];\n        }\n        const int tot = sum(0, 0, n-1, m-1);\n        const int ans = solve(tot-S);\n        int l = 0, r = 120;\n        while (r-l>1) {\n            const int mid = (l+r) / 2;\n            if (solve(tot-S+mid) >= ans) l = mid;\n            else r = mid;\n        }\n        printf(\"%d %d\\n\", ans, l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint h, w, s;\nint p[32][32], sum[32][32];\npair<int, int> dp[32][32][32][32];\n\nint getSum(int sy, int sx, int gy, int gx)\n{\n\tint ret = sum[gy][gx];\n\tif (sy) ret -= sum[sy - 1][gx];\n\tif (sx) ret -= sum[gy][sx - 1];\n\tif (sy && sx) ret += sum[sy - 1][sx - 1];\n\t\n\treturn (ret);\n}\n\npair<int, int> calc(int sy, int sx, int gy, int gx)\n{\n\tif (~dp[sy][sx][gy][gx].first) return (dp[sy][sx][gy][gx]);\n\t\n\tint cost = sum[h - 1][w - 1] - getSum(sy, sx, gy, gx);\n\tif (cost > s) return make_pair(0, -1);\n\tpair<int, int> res = make_pair(1, -cost);\n\tpair<int, int> a, b, c;\n\t\n\tfor (int i = sy; i <= gy - 1; i++){\n\t\ta = calc(sy, sx, i, gx); b = calc(i + 1, sx, gy, gx);\n\t\tif (a.first == 0 || b.first == 0) continue;\n\t\tc = make_pair(a.first + b.first, min(a.second, b.second));\n\t\tif (res < c) res = c;\n\t}\n\t\n\tfor (int i = sx; i <= gx - 1; i++){\n\t\ta = calc(sy, sx, gy, i); b = calc(sy, i + 1, gy, gx);\n\t\tif (a.first == 0 || b.first == 0) continue;\n\t\tc = make_pair(a.first + b.first, min(a.second, b.second));\n\t\tif (res < c) res = c;\n\t}\n\t\n\treturn (dp[sy][sx][gy][gx] = res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d %d\", &h, &w, &s) && w){\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", &p[i][j]);\n\t\t\n\t\tfor (int i = 0; i < 32; i++)\n\t\t\tfor (int j = 0; j < 32; j++)\n\t\t\t\tfor (int k = 0; k < 32; k++)\n\t\t\t\t\tfor (int l = 0; l < 32; l++)\n\t\t\t\t\t\tdp[i][j][k][l].first = dp[i][j][k][l].second = -1;\n\t\t\n\t\tmemset(sum, 0, sizeof(sum));\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tsum[i][j] += p[i][j];\n\t\t\t\tif (i) sum[i][j] += sum[i - 1][j];\n\t\t\t\tif (j) sum[i][j] += sum[i][j - 1];\n\t\t\t\tif (i && j) sum[i][j] -= sum[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpair<int, int> res = calc(0, 0, h - 1, w - 1);\n\t\tprintf(\"%d %d\\n\", res.first, s + res.second);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\nvector<vector<int> > u;\nvector<vector<int> > sums;\nvector<vector<vector<vector<i_i> > > > memo;\nint h, w, s;\nint sum;\n\ni_i rec(i_i lu, i_i rd) {\n\tif(memo[lu.first][lu.second][rd.first][rd.second].first != INF) return memo[lu.first][lu.second][rd.first][rd.second];\n\telse {\n\t\tint sub = s - (sum - (sums[rd.first + 1][rd.second + 1] - sums[(lu.first + 1) - 1][rd.second + 1]\n\t\t\t\t\t\t - sums[rd.first + 1][(lu.second + 1) - 1] + sums[(lu.first + 1) - 1][(lu.second + 1) - 1]));\n\t\tif(sub < 0) {\n\t\t\treturn memo[lu.first][lu.second][rd.first][rd.second] = i_i(-1, -1);\n\t\t}\n\t\ti_i res = i_i(-1, -1);\n\t\tREP(i, rd.first - lu.first) {\n\t\t\ti_i lset = rec(lu, i_i(lu.first + i, rd.second));\n\t\t\ti_i rset = rec(i_i(lu.first + 1 + i, lu.second), rd);\n\t\t\tif(lset.first != -1 && rset.first != -1) {\n\t\t\t\tres = max(res, i_i(lset.first + rset.first, min(lset.second, rset.second)));\n\t\t\t}\n\t\t}\n\t\tREP(i, rd.second - lu.second) {\n\t\t\ti_i lset = rec(lu, i_i(rd.first, lu.second + i));\n\t\t\ti_i rset = rec(i_i(lu.first, lu.second + 1 + i), rd);\n\t\t\tif(lset.first != -1 && rset.first != -1) {\n\t\t\t\tres = max(res, i_i(lset.first + rset.first, min(lset.second, rset.second)));\n\t\t\t}\n\t\t}\n\t\tif(res.first != -1) return memo[lu.first][lu.second][rd.first][rd.second] = res;\n\t\telse {\n\t\t\treturn memo[lu.first][lu.second][rd.first][rd.second] = i_i(1, sub);\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>h>>w>>s;\n\t\tif(h == 0 && w == 0 && s == 0) break;\n\t\tsum = 0;\n\t\tu.resize(h);\n\t\tREP(i, h) u[i].resize(w);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin>>u[i][j];\n\t\t\t\tsum += u[i][j];\n\t\t\t}\n\t\t}\n\t\tsums.resize(h + 1);\n\t\tREP(i, h + 1) sums[i].resize(w + 1);\n\t\tREP(i, h + 1) {\n\t\t\tREP(j, w + 1) {\n\t\t\t\tif(i == 0 || j == 0) sums[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tsums[i][j] = u[i - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h + 1) {\n\t\t\tREP(j, w + 1) {\n\t\t\t\tif(j == 0) continue;\n\t\t\t\tsums[i][j] += sums[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tREP(j, w + 1) {\n\t\t\tREP(i, h + 1) {\n\t\t\t\tif(i == 0) continue;\n\t\t\t\tsums[i][j] += sums[i - 1][j];\n\t\t\t}\n\t\t}\n\t\tmemo.resize(h);\n\t\tREP(i, h) {\n\t\t\tmemo[i].resize(w);\n\t\t\tREP(j, w) {\n\t\t\t\tmemo[i][j].resize(h);\n\t\t\t\tREP(k, h) {\n\t\t\t\t\tmemo[i][j][k].resize(w);\n\t\t\t\t\tREP(l, w) {\n\t\t\t\t\t\tmemo[i][j][k][l] = i_i(INF, INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti_i ans = rec(i_i(0, 0), i_i(h - 1, w - 1));\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nPLL invalid = PLL(-1, -1);\nll sum_all;\nll bound;\nVV<VV<PLL>> dp;\nVV<ll> sum;\nll H, W, S;\n\nll calc_group_sum(ll h1, ll w1, ll h2, ll w2) {\n    return sum[h2][w2] - sum[h1][w2] - sum[h2][w1] + sum[h1][w1];\n}\n\nbool enable_split(ll h1, ll w1, ll h2, ll w2, bool h, ll sp) {\n    if(h) {\n        return calc_group_sum(h1, w1, sp, w2) >= bound &&\n               calc_group_sum(sp, w1, h2, w2) >= bound;\n    } else {\n        return calc_group_sum(h1, w1, h2, sp) >= bound &&\n               calc_group_sum(h1, sp, h2, w2) >= bound;\n    }\n}\n\nPLL calc(ll h1, ll w1, ll h2, ll w2) {\n    if(dp[h1][w1][h2][w2] != invalid) return dp[h1][w1][h2][w2];\n\n    PLL ret = PLL(1, calc_group_sum(h1, w1, h2, w2));\n    \n    for(ll sh = h1 + 1; sh < h2; sh++) {\n        if(!enable_split(h1, w1, h2, w2, true, sh)) continue;\n        auto hu = calc(h1, w1, sh, w2);\n        auto hd = calc(sh, w1, h2, w2);\n        auto tmp = make_pair(hu.first + hd.first,\n                             min(hu.second, hd.second));\n        if(tmp.first > ret.first) ret = tmp;\n        else if(tmp.first == ret.first && tmp.second > ret.second) ret = tmp;\n    }\n    \n    for(ll sw = w1 + 1; sw < w2; sw++) {\n        if(!enable_split(h1, w1, h2, w2, false, sw)) continue;\n        auto hl = calc(h1, w1, h2, sw);\n        auto hr = calc(h1, sw, h2, w2);\n        auto tmp = make_pair(hl.first + hr.first,\n                             min(hl.second, hr.second));\n        if(tmp.first > ret.first) ret = tmp;\n        else if(tmp.first == ret.first && tmp.second > ret.second) ret = tmp;\n    }\n    \n    return dp[h1][w1][h2][w2] = ret;\n}\n\nbool solve() {\n    cin >> H >> W >> S;\n\n    if(!(H + W + S)) return false;\n\n    dp = make_v(invalid, 33, 33, 33, 33);\n    sum = make_v<ll>(0, 33, 33);\n    \n    for(ll h = 0; h < H; h++) for(ll w = 0; w < W; w++) cin >> sum[h + 1][w + 1];\n    for(ll h = 0; h < H; h++) for(ll w = 0; w <= W; w++) sum[h + 1][w] += sum[h][w];\n    for(ll w = 0; w < W; w++) for(ll h = 0; h <= H; h++) sum[h][w + 1] += sum[h][w];\n\n    sum_all = calc_group_sum(0, 0, H, W);\n    bound = sum_all - S;\n\n    auto ans = calc(0, 0, H, W);\n    \n    cout << ans.first << ' ' << S - (sum_all - ans.second) << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 1e8;\n\nint main(){\n    int h,w,s;\n    while(cin>>h>>w>>s,h){\n        int u[32][32];\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin>>u[i][j];\n                s-=u[i][j];\n            }\n        }\n        s=-s;\n        cout<<s<<endl;\n        pair<int,int> dp[32][32][32][32]={};\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                if(u[i][j]>=s){\n                    dp[i][j][0][0]=make_pair(1,u[i][j]);\n                }else{\n                    dp[i][j][0][0]=make_pair(0,u[i][j]);\n                }\n            }\n        }\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                for(int y=h-i-1;y>=0;--y){\n                    for(int x=w-j-1;x>=0;--x){\n                        for(int hk=0;hk<i;++hk){\n                            auto p1=dp[y][x][hk][j], p2=dp[y+hk+1][x][i-hk-1][j];\n                            if(p1.first==0 || p2.first==0){\n                                auto p=make_pair(0, p1.second+p2.second);\n                                if(p.second>=s)p=make_pair(1, p1.second+p2.second);\n                                dp[y][x][i][j]=max(dp[y][x][i][j],p);\n                                continue;\n                            }\n                            dp[y][x][i][j]=max(dp[y][x][i][j],make_pair(p1.first+p2.first, min(p1.second,p2.second)));\n                        }\n                        for(int wk=0;wk<j;++wk){\n                            auto p1=dp[y][x][i][wk], p2=dp[y][x+wk+1][i][j-wk-1];\n                            if(p1.first==0 || p2.first==0){\n                                auto p=make_pair(0, p1.second+p2.second);\n                                if(p.second>=s)p=make_pair(1, p1.second+p2.second);\n                                dp[y][x][i][j]=max(dp[y][x][i][j],p);\n                                continue;\n                            }\n                            dp[y][x][i][j]=max(dp[y][x][i][j],make_pair(p1.first+p2.first, min(p1.second,p2.second)));\n                        }\n                    }\n                }\n            }\n        }\n        cout<<dp[0][0][h-1][w-1].first<<\" \"<<dp[0][0][h-1][w-1].second-s<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-14\n#define fi first\n#define se second\n#define all(v) v.begin(),v.end()\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\npii dp[34][34][34][34];\nint u[34][34];\nint jud;\n\npii update(pii ta,pii ma){\n\tif(ma.se < ta.se){\n\t\treturn ta;\n\t}else if(ma.se == ta.se){\n\t\tif(ma.fi < ta.fi){\n\t\t\treturn ta;\n\t\t}\n\t}\n\treturn ma;\n}\n\npii f(int sy,int sx,int ey,int ex){\n\t// cout << \" sy : \" << sy << \" sx : \" << sx << \n\t//         \" ey : \" << ey << \" ex : \" << ex <<\n\t//          endl; \n\tif(dp[sy][sx][ey][ex].fi!=0) return dp[sy][sx][ey][ex];\n\tif(sy == ey && sx == ex) {\n\t\t// cout << \"mp : \" << u[sy][sx]<<endl; \n\t\tdp[sy][sx][ey][ex] = mp(u[sy][sx],1);\n\t\treturn mp(u[sy][sx],1);\n\t}\n\tpii ma = mp(0,1);\n\n\t//?????????????????£???????????????\n\tfor (int y = sy; y <= ey; ++y)\n\t{\n\t\tfor (int x = sx; x <= ex; ++x)\n\t\t{\n\t\t \tma.fi += u[y][x];\n\t\t}\n\t}\n\t//????????????????????????\n\tfor(int x = sx;x < ex;x++){\n\t\tpii a1 = f(sy,sx,ey,x);\n\t\tpii a2 = f(sy,x+1,ey,ex);\n\t\tif(a1.fi < jud || a2.fi < jud) continue;\n\t\tpii ta = mp(min(a1.fi,a2.fi),a1.se+a2.se);\n\t\tma = update(ta,ma);\n\t}\n\n\tfor(int y = sy;y < ey;y++){\n\t\tpii a1 = f(sy,sx,y,ex);\n\t\tpii a2 = f(y+1,sx,ey,ex);\n\t\tif(a1.fi < jud || a2.fi < jud) continue;\n\t\tpii ta = mp(min(a1.fi,a2.fi),a1.se+a2.se);\n\t\tma = update(ta,ma);\n\t}\n\t// cout << \"ma : \" << ma.fi << \" \" << ma.se << endl;\n\tdp[sy][sx][ey][ex] = ma;\n\treturn ma;\n}\nint main(){\n\twhile(1){\n\t\trep(x1,34){\n\t\trep(x2,34){\n\t\trep(x3,34){\n\t\trep(x4,34){\n\t\t\tdp[x1][x2][x3][x4] = mp(0,0);\n\t\t}}}}\n\t\tint h,w,s;\n\t\tint sum = 0;\n\t\tcin >> h >> w >> s;\n\t\tif(h==0) break;\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\tcin >> u[y][x];\n\t\t\t\tsum += u[y][x];\n\t\t\t}\n\t\t}\n\t\tjud = sum - s;\n\t\tpii ans = f(0,0,h-1,w-1);\n\t\tcout << ans.se << \" \"<< ans.fi-jud << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w, s;\nint u[33][33];\nint sum[33][33];\nint S;\npint dp[33][33][33][33];\n\nint get(int sx, int sy, int gx, int gy) {\n  return sum[gy][gx] - sum[gy][sx] - sum[sy][gx] + sum[sy][sx];\n}\n\npint solve(int lx, int ly, int rx, int ry) {\n  pint &res = dp[lx][ly][rx][ry];\n  if(~res.first) return res;\n  int ss = get(lx, ly, rx, ry);\n  if(s - S + ss < 0) {\n    res = make_pair(0, inf);\n    return res;\n  }\n  res = make_pair(1, s - S + ss);\n  reps(x, lx+1, rx) {\n    pint ld = solve(lx, ly, x, ry);\n    pint rd = solve(x, ly, rx, ry);\n    pint tmp = make_pair(ld.first+rd.first, min(ld.second, rd.second));\n    chmax(res, tmp);\n  }\n  reps(y, ly+1, ry) {\n    pint ud = solve(lx, ly, rx, y);\n    pint dd = solve(lx, y, rx, ry);\n    pint tmp = make_pair(ud.first+dd.first, min(ud.second, dd.second));\n    chmax(res, tmp);\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> h >> w >> s, h || w || s) {\n    memset(u, 0, sizeof(u));\n    memset(sum, 0, sizeof(sum));\n    rep(i, h) rep(j, w) cin >> u[i][j], sum[i+1][j+1] = u[i][j];\n    rep(i, h) rep(j, w) {\n      sum[i+1][j+1] += sum[i+1][j] + sum[i][j+1] - sum[i][j];\n    }\n    rep(i, 33) rep(j, 33) rep(k, 33) rep(l, 33) {\n      dp[i][j][k][l] = make_pair(-1, -1);\n    }\n    S = get(0, 0, w, h);\n    pint ans = solve(0, 0, w, h);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing pr = pair<int, int>;\n\nint h, w, s, t;\nint a[32][32];\npr dp[33][33][33][33];\nint sum[33][33];\n\nint rsum(int bx, int ex, int by, int ey)\n{\n\treturn sum[ex][ey] - sum[ex][by] - sum[bx][ey] + sum[bx][by];\n}\n\npr calc(int bx, int ex, int by, int ey)\n{\n\tpr &res = dp[bx][ex][by][ey];\n\tif (~res.fi) return res;\n\tres = pr(1, rsum(bx, ex, by, ey) - t);\n\tloop(i, bx + 1, ex){\n\t\tpr vl(-INF, -INF), vr(-INF, -INF);\n\t\tif (rsum(bx, i, by, ey) >= t){\n\t\t\tvl = calc(bx, i, by, ey);\n\t\t}\n\t\tif (rsum(i, ex, by, ey) >= t){\n\t\t\tvr = calc(i, ex, by, ey);\n\t\t}\n\t\tchmax(res, pr(vl.fi + vr.fi, min(vl.se, vr.se)));\n\t}\n\tloop(i, by + 1, ey){\n\t\tpr vl(-INF, -INF), vr(-INF, -INF);\n\t\tif (rsum(bx, ex, by, i) >= t){\n\t\t\tvl = calc(bx, ex, by, i);\n\t\t}\n\t\tif (rsum(bx, ex, i, ey) >= t){\n\t\t\tvr = calc(bx, ex, i, ey);\n\t\t}\n\t\tchmax(res, pr(vl.fi + vr.fi, min(vl.se, vr.se)));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> s, h){\n\t\tt = -s;\n\t\trep(i, h) rep(j, w){\n\t\t\tcin >> a[i][j];\n\t\t\tt += a[i][j];\n\t\t\tsum[i + 1][j + 1] = a[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i][j];\n\t\t}\n\t\tfill_n(***dp, sq(sq(33)), pr(-1, -1));\n\t\tpr res = calc(0, h, 0, w);\n\t\tcout << res.fi << \" \" << res.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint c[40][40];\nint sum[40][40];\nint sum_all = 0;\nint h,w,s;\n\nint get_sum(int x1,int y1,int x2,int y2){\n\treturn sum[x2][y2] + sum[x1 - 1][y1 - 1] - sum[x1 - 1][y2] - sum[x2][y1 - 1];\n}\n\nP dp[40][40][40][40];\n\nP rec(int x1,int y1,int x2,int y2){\n\tif(dp[x1][y1][x2][y2].first != -1) return dp[x1][y1][x2][y2];\n\tP res = {1 , s - (sum_all - get_sum(x1,y1,x2,y2))};\n\tfor(int i = x1;i < x2;i++){\n\t\tif(sum_all - get_sum(x1, y1, i, y2) > s) continue;\n\t\tif(sum_all - get_sum(i + 1,y1,x2,y2) > s) continue;\n\t\tP l = rec(x1, y1, i, y2);\n\t\tP r = rec(i + 1,y1,x2,y2);\n\t\tP ans = {l.first + r.first,min(l.second,r.second)};\n\t\tres = max(res,ans);\n\t}\n\tfor(int i =  y1;i < y2;i++){\n\t\tif(sum_all - get_sum(x1,y1,x2,i) > s) continue;\n\t\tif(sum_all - get_sum(x1,i + 1,x2,y2) > s) continue;\n\t\tP l = rec(x1,y1,x2,i);\n\t\tP r = rec(x1,i + 1,x2,y2);\n\t\tP ans = {l.first + r.first , min(l.second , r.second)};\n\t\tres = max(res,ans);\n\t}\n\n\treturn dp[x1][y1][x2][y2] = res;\n}\n\n\nint main(){\n\twhile(cin >> h >> w >> s,h || w || s){\n\t\tsum_all = 0;\n\t\trep(i,1,h)rep(j,1,w) cin >> c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum_all += c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] = sum[i - 1][j] + c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] += sum[i][j - 1];\n\t\trep(i,1,h)rep(j,1,w)rep(k,1,h)rep(l,1,h) dp[i][j][k][l].first = dp[i][j][k][l].second = -1;\n\t\tcout << rec(1,1,h,w).first << \" \" << rec(1,1,h,w).second << endl;;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint const inf = 1<<28;\nint H,W,S;\nint a[33][33];\n\nint T;\nint sum[35][35];\npii dp[33][33][33][33];\n\ninline int s(int x, int y, int w, int h){\n    return sum[y+h][x+w]-sum[y][x+w]-sum[y+h][x]+sum[y][x];\n}\n\n// x,y,w,hの長方形でできる分割の数の最大、分割の最小\npair<int,int> f(int x, int y, int w, int h){\n    auto & res = dp[x][y][w][h];\n    if(res==mp(-1,-1)){\n        if(s(x,y,w,h) < T) return res = mp(-inf,inf);\n        else {\n            res = mp(1,s(x,y,w,h));\n            for(int i=1;i<w;i++){\n                int a1,b1,a2,b2;\n                tie(a1,b1)=f(x,y,i,h);\n                tie(a2,b2)=f(x+i,y,w-i,h);\n                res = max(res,mp(a1+a2,min(b1,b2)));\n            }\n            for(int i=1;i<h;i++){\n                int a1,b1,a2,b2;\n                tie(a1,b1)=f(x,y,w,i);\n                tie(a2,b2)=f(x,y+i,w,h-i);\n                res = max(res,mp(a1+a2,min(b1,b2)));\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> H >> W >> S && H){\n        rep(i,33)rep(j,33)rep(k,33)rep(l,33)dp[i][j][k][l] = mp(-1,-1);\n        rep(i,H)rep(j,W)cin >> a[i][j];\n        memset(sum,0,sizeof(sum));\n        rep(i,H)rep(j,W) sum[i+1][j+1] = a[i][j];\n        rep(i,H+1)rep(j,W+1) sum[i][j+1] += sum[i][j];\n        rep(i,H+1)rep(j,W+1) sum[i+1][j] += sum[i][j];\n        T = sum[H][W]-S;\n        int p,q;\n        tie(p,q) = f(0,0,W,H);\n        dump(p,q);\n        cout << p << \" \" << q-T << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nconst int W = 35;\npii dp[W][W][W][W];\nint check[W][W][W][W];\nint h, w, s, S;\nint u[W][W];\n\npii dfs(int a, int b, int c, int d) {\n\tpii &ret = dp[a][b][c][d];\n\tif (check[a][b][c][d])return ret;\n\tret.first = ret.second = 0;\n\tint sum = 0;\n\trep(i, a, c)rep(j, b, d)sum += u[i][j];\n\tif ((S - sum) <= s) {\n\t\tchmax(ret, pii(1, s - (S - sum)));\n\t}\n\trep(i, a + 1, c) {\n\t\tauto x = dfs(a, b, i, d);\n\t\tauto y = dfs(i, b, c, d);\n\t\tx.first += y.first;\n\t\tchmin(x.second, y.second);\n\t\tchmax(ret, x);\n\t}\n\trep(i, b + 1, d) {\n\t\tauto x = dfs(a, b, c, i);\n\t\tauto y = dfs(a, i, c, d);\n\t\tx.first += y.first;\n\t\tchmin(x.second, y.second);\n\t\tchmax(ret, x);\n\t}\n\tcheck[a][b][c][d] = 1;\n\treturn ret;\n\n}\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\twhile (cin >> h >> w >> s, h and w and s) {\n\t\tmemset(check, 0, sizeof(check));\n\t\tS = 0;\n\t\trep(i, 0, h)rep(j, 0, w)cin >> u[i][j], S += u[i][j];\n\t\tauto ans = dfs(0, 0, h, w);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\nint h,w,s;\nint field[33][33];\nint calcsum[33][33];\npair<int,int> memo[33][33][33][33]; // [y][x][y][x]\n\n// (x,y) = (l,t), ??????(l,t), ??????(r,b) ???????????¢???????????????\nint getRectDemandSum(int l, int t, int r, int b) {\n    int ret = 0;\n    ret += calcsum[b][r]; // [y][x]\n    if (l - 1 >= 0 && t - 1 >= 0) {\n        ret += calcsum[t - 1][l - 1];\n    }\n    if (t - 1 >= 0) {\n        ret -= calcsum[t - 1][r];\n    }\n    if (l - 1 >= 0) {\n        ret -= calcsum[b][l - 1];\n    }\n    return ret;\n}\n\n// <?????§??°???????????°, ?????§?????????>\npair<int,int> solve(int l, int t, int r, int b) {\n\n    if (memo[t][l][b][r].first != -1) return memo[t][l][b][r];\n\n    // ?????¶??????\n    int brake = getRectDemandSum(0,0,w-1,h-1) - getRectDemandSum(l,t,r,b);\n    pair<int,int> ret = make_pair(0,0);\n    if (brake <= s) {\n        ret = make_pair(1, brake);\n    }\n    // ?????´\n    for (int x=l; x<r; ++x) {\n        pair<int,int> u1 = solve(l,t,x,b);\n        pair<int,int> u2 = solve(x+1,t,r,b);\n        if (u1.first > 0 && u2.first > 0) {\n            pair<int,int> tmp = make_pair(u1.first + u2.first, max(u1.second, u2.second));\n            if (ret.first < tmp.first) {\n                ret = tmp;\n            } else if (ret.first == tmp.first && ret.second > tmp.second) {\n                ret = tmp;\n            }\n\n            //printf(\"\\tx\\t(%d,%d)-(%d,%d) -> (%d,%d)-(%d,%d):[%d %d] & (%d,%d)-(%d,%d):[%d %d]\\n\", l,t,r,b,l,t,x,b,u1.first,u1.second,x+1,t,r,b,u2.first,u2.second);\n        }\n    }\n\n    // ?°´???\n    for (int y=t; y<b; ++y) {\n        pair<int,int> u1 = solve(l,t,r,y);\n        pair<int,int> u2 = solve(l,y+1,r,b);\n        if (u1.first > 0 && u2.first > 0) {\n            pair<int,int> tmp = make_pair(u1.first + u2.first, max(u1.second, u2.second));\n            if (ret.first < tmp.first) {\n                ret = tmp;\n            } else if (ret.first == tmp.first && ret.second > tmp.second) {\n                ret = tmp;\n            }\n\n            //printf(\"\\ty\\t(%d,%d)-(%d,%d) -> (%d,%d)-(%d,%d):[%d %d] & (%d,%d)-(%d,%d):[%d %d]\\n\", l,t,r,b,l,t,r,y,u1.first,u1.second,l,y+1,r,b,u2.first,u2.second);\n        }\n    }\n\n    //printf(\"\\tlast\\t(%d,%d)-(%d,%d) => %d %d\\n\",l,t,r,b,ret.first,ret.second);\n\n    return memo[t][l][b][r] = ret;\n}\n\nint main() {\n    while (cin >> h >> w >> s, h || w || s) {\n        // init\n        for (int i=0; i<33; ++i) for (int j=0; j<33; ++j)\n            for (int k=0; k<33; ++k) for (int l=0; l<33; ++l) memo[i][j][k][l] = make_pair(-1,0);\n\n        for (int i=0; i<h; ++i) {\n            for (int j=0; j<w; ++j) {\n                cin >> field[i][j];\n            }\n        }\n\n        // copy\n        for (int i=0; i<h; ++i) for (int j=0; j<w; ++j) calcsum[i][j] = field[i][j];\n\n        // ?´???????\n        for (int i=0; i<h; ++i) for (int j=1; j<w; ++j) calcsum[i][j] += calcsum[i][j - 1];\n        for (int i=1; i<h; ++i) for (int j=0; j<w; ++j) calcsum[i][j] += calcsum[i - 1][j];\n\n        pair<int,int> ans = solve(0,0,w-1,h-1);\n        cout << ans.first << \" \" << s - ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\nint rec[34][34][34][34];\n\nvoid mkRec(){\n\tint i, j;\n\tfor(i = 1; i <= w; i++){\n\t\tfor(j = 1; j <= h; j++){\n\t\t\trec[i][j][i][j] = area[i][j];\n\t\t\tfor(int y = i - 1; y > 0; y--)\n\t\t\t\trec[y][j][i][j] = rec[y + 1][j][i][j] + area[y][j];\n\t\t\tfor(int y = i; y > 0; y--){\n\t\t\t\tint s = 0;\n\t\t\t\tfor(int x = j; x > 0; x--){\n\t\t\t\t\ts += rec[y][x][i][x];\n\t\t\t\t\trec[y][x][i][j] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\npair<int, int> split(int ax, int ay, int bx, int by){\n\tpair<int, int> max_group, group, g1, g2;\n\tint sum_e = 0;\n\tint i, j;\n\t\n\tif(memo[ax][ay][bx][by].first != 0) return memo[ax][ay][bx][by];\n\n\tif(sum - rec[ax][ay][bx][by] > s){\n//\t\tcout << \" :out\" << endl;\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\tmax_group.first = 1;\n\tmax_group.second = s - (sum - rec[ax][ay][bx][by]);\n\n\tfor(i = ax; i < bx; i++){\n\t\tg1 = split(ax, ay, i, by);\n\t\tg2 = split(i + 1, ay, bx, by);\n\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\tfor(i = ay; i < by; i++){\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i + 1, bx, by);\n\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n//\tcout << ax << \" : \" << ay << \" : \" << bx << \" : \" << by << endl << max_group.first << \" : \" << max_group.second << endl;\n\t\n\treturn memo[ax][ay][bx][by] = max_group;\n}\n\nint main(void){\n\tint i,j;\n\tint group_count;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemset(rec, 0, sizeof(rec));\n\t\tsum = 0;\n\t\tfor(i = 1; i <= w; i++)\n\t\t\tfor(j = 1; j <= h; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n\t\tmkRec();\n\t\tans = split(1, 1, w, h);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h,w,s,u[33][33]={},a[33][33][33][33]={},t,b[33][33][33][33]={};\nint Usum(int i,int j,int k,int l){\n    int R=0;\n    R=u[j+l][i+k]-u[j][i+k]-u[j+l][i]+u[j][i];\n    return R;\n}\n\nint main(){\n    while (cin >> h >> w >> s && h!=0){\n        for (int i=1; i<=w; i++){\n            for (int j=1; j<=h; j++){\n                cin >> u[i][j];\n                u[i][j] += u[i-1][j];\n                u[i][j] += u[i][j-1];\n                u[i][j] -= u[i-1][j-1];\n            }\n        }\n        t=u[w][h]-s;\n        for (int i=1; i<=h; i++){\t\t\t\t\t\t//??????\n            for (int j=0; j<=h-i; j++){\t\t\t\t\t//???\n                for (int k=1; k<=w; k++){               //???\n                    for (int l=0; l<=w-k; l++){\t\t\t//???\n                        if (Usum(j,l,i,k)>=t){\n\t\t\t\t\t\t\ta[j][l][i][k]=1;\n\t\t\t\t\t\t}\n                        else a[j][l][i][k]=-100000000;\n                        for (int m=1; m<i; m++){\n                            if (a[j][l][i][k]<a[j][l][m][k]+a[j+m][l][i-m][k]){\n\t\t\t\t\t\t\t\ta[j][l][i][k]=a[j][l][m][k]+a[j+m][l][i-m][k];\n\t\t\t\t\t\t\t\tif (b[j][l][m][k]<b[j+m][l][i-m][k]) b[j][l][i][k]=b[j][l][m][k];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j+m][l][i-m][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[j][l][i][k]==a[j][l][m][k]+a[j+m][l][i-m][k] && b[j][l][i][k]<b[j][l][m][k] && b[j][l][i][k]<b[j+m][l][i-m][k]){\n\t\t\t\t\t\t\t\tif (b[j][l][m][k]<b[j+m][l][i-m][k]) b[j][l][i][k]=b[j][l][m][k];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j+m][l][i-m][k];\n\t\t\t\t\t\t\t}\n                        }\n                        for (int m=1; m<k; m++){\n                            if (a[j][l][i][k]<a[j][l][i][m]+a[j][l+m][i][k-m]){\n\t\t\t\t\t\t\t\ta[j][l][i][k]=a[j][l][i][m]+a[j][l+m][i][k-m];\n\t\t\t\t\t\t\t\tif (b[j][l][i][m]<b[j][l+m][i][k-m]) b[j][l][i][k]=b[j][l][i][m];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j][l+m][i][k-m];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[j][l][i][k]==a[j][l][i][m]+a[j][l+m][i][k-m] && b[j][l][i][k]<b[j][l][i][m] && b[j][l][i][k]<b[j][l+m][i][k-m]){\n\t\t\t\t\t\t\t\tif (b[j][l][i][m]<b[j][l+m][i][k-m]) b[j][l][i][k]=b[j][l][i][m];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j][l+m][i][k-m];\n\t\t\t\t\t\t\t}\n                        }\n\t\t\t\t\t\tif (a[j][l][i][k]==1) b[j][l][i][k]=Usum(j,l,i,k)-t;\n                    }\n                }\n            }\n        }\n        cout << a[0][0][h][w] << \" \" << b[0][0][h][w] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n\nstruct p{\n\tint g,m;\n\tp(){}\n\tp(int g,int m):g(g),m(m){}\n};\n\nint h,w,s,sum[32][32];\np dp[32][32][32][32];\n\nint main(){\n\twhile(cin>>h>>w>>s&&h){\n\t\tmemset(sum,0,sizeof(sum));\n\t\tmemset(dp,0,sizeof(dp));\n\t\trep(i,h)rep(j,w){\n\t\t\tint u;\n\t\t\tcin>>u;\n\t\t\tif(j==0){\n\t\t\t\tif(i==0)sum[0][0]=u;\n\t\t\t\telse sum[i][0]=sum[i-1][0]+u;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i==0)sum[0][j]=sum[0][j-1]+u;\n\t\t\t\telse sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+u;\n\t\t\t}\n\t\t}\n\t\ts=sum[h-1][w-1]-s;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w){\n\t\t\tint S;\n\t\t\tif(j==0){\n\t\t\t\tif(i==0)S=sum[k][l];\n\t\t\t\telse S=sum[k][l]-sum[i-1][l];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i==0)S=sum[k][l]-sum[k][j-1];\n\t\t\t\telse S=sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1];\n\t\t\t}\n\t\t\tif(S>=s)dp[i][j][k][l]=p(1,S);\n\t\t}\n\t\trep2(H,1,h+1)rep2(W,1,w+1)rep(y,h-H+1)rep(x,w-W+1){\n\t\t\tint g=0,m=0;\n\t\t\trep(i,H-1){\n\t\t\t\tp U=dp[y][x][y+i][x+W-1],D=dp[y+i+1][x][y+H-1][x+W-1];\n\t\t\t\tif(U.g&&D.g&&U.m>=s&&D.m>=s&&(U.g+D.g>g||U.g+D.g==g&&min(U.m,D.m)>m)){g=U.g+D.g,m=min(U.m,D.m);}\n\t\t\t}\n\t\t\trep(i,W-1){\n\t\t\t\tp L=dp[y][x][y+H-1][x+i],R=dp[y][x+i+1][y+H-1][x+W-1];\n\t\t\t\tif(L.g&&R.g&&L.m>=s&&R.m>=s&&(L.g+R.g>g||L.g+R.g==g&&min(L.m,R.m)>m)){g=L.g+R.g,m=min(L.m,R.m);}\n\t\t\t}\n\t\t\tif(g)dp[y][x][y+H-1][x+W-1]=p(g,m);\n\t\t}\n\t\tcout<<dp[0][0][h-1][w-1].g<<\" \"<<dp[0][0][h-1][w-1].m-s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,s,sum;\nP pmax(P a,P b){\n\tif(a>b)return a;\n\treturn b;\n}\nint u[33][33];\nP dp[33][33][33][33];\nP ret(P a,P b,int cnt){\n\tif(dp[a.first][a.second][b.first][b.second].first!=-1)\n\t\treturn dp[a.first][a.second][b.first][b.second];\n\tP ans(1,cnt);\n\tint s1=0,s2=0;\n\tfor(int i=a.first;i<b.first;i++){\n\t\tfor(int j=a.second;j<=b.second;j++){\n\t\t\ts1+=u[i][j];\n\t\t}\n\t\tif(sum-s1>s)\n\t\t\tcontinue;\n\t\tif(sum-(cnt-s1)>s)\n\t\t\tbreak;\n\t\tP x=ret(a,P(i,b.second),s1),y=ret(P(i+1,a.second),b,cnt-s1);\n\t\tans=pmax(ans,P(x.first+y.first,min(x.second,y.second)));\n\t}\n\tfor(int i=a.second;i<b.second;i++){\n\t\tfor(int j=a.first;j<=b.first;j++){\n\t\t\ts2+=u[j][i];\n\t\t}\n\t\tif(sum-s2>s)\n\t\t\tcontinue;\n\t\tif(sum-(cnt-s2)>s)\n\t\t\tbreak;\n\t\tP x=ret(a,P(b.first,i),s2),y=ret(P(a.first,i+1),b,cnt-s2);\n\t\tans=pmax(ans,P(x.first+y.first,min(x.second,y.second)));\n\t}\n\treturn dp[a.first][a.second][b.first][b.second]=ans;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tsum=0;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w)\n\t\tdp[i][j][k][l]=P(-1,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>u[i][j];\n\t\t\tsum+=u[i][j];\n\t\t}\n\t\tP ans=ret(P(0,0),P(h-1,w-1),sum);\n\t\tcout<<ans.first<<\" \"<<s-(sum-ans.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#define INF 1000000\nusing namespace std;\ntypedef pair<int,int> P;\n\nint electro[32][32];   // w h\nP memo[32][32][32][32]; //sw sh ew eh\n \nint h,w,s;\n\nP divide(int sw,int sh,int ew,int eh){\n\tif(memo[sw][sh][ew-1][eh-1].first>0)\n\t\treturn memo[sw][sh][ew-1][eh-1];\n\tP res;\n\tint mtmp=electro[w-1][h-1];\n\tint etmp=electro[ew-1][eh-1];\n\tif(sw)\n\t\tetmp-=electro[sw-1][eh-1];\n\tif(sh)\n\t\tetmp-=electro[ew-1][sh-1];\n\tif(sw&&sh)\n\t\tetmp+=electro[sw-1][sh-1];\n\tmtmp-=etmp;\n\t\n\tres.first=1,res.second=s-mtmp;\n\tfor(int i=sw+1;i<ew;i++){\n\t\tP tmp,tmp2;\n\t\ttmp=divide(sw,sh,i,eh);\n\t\ttmp2=divide(i,sh,ew,eh);\n\t\ttmp.first+=tmp2.first;\n\t\ttmp.second=min(tmp.second,tmp2.second);\n\t\tif( (res.first < tmp.first&&0<=tmp.second) || (tmp.first == res.first&&0<=tmp.second&&res.second < tmp.second))\n\t\t\tres=tmp;\n\t}\n\n\tfor(int j=sh+1;j<eh;j++){\n\t\tP tmp,tmp2;\n\t\ttmp=divide(sw,sh,ew,j);\n\t\ttmp2=divide(sw,j,ew,eh);\n\t\ttmp.first+=tmp2.first;\n\t\ttmp.second=min(tmp.second,tmp2.second);\n\t\tif( (res.first < tmp.first&&0<=tmp.second) || (tmp.first == res.first&&0<=tmp.second&&res.second < tmp.second))\n\t\t\tres=tmp;\n\t}\n//\tcout << res.first << \" \"  <<res.second  << endl;\n\treturn memo[sw][sh][ew-1][eh-1]=res;\n}\n\nint main(void){\n\twhile(cin >> h >> w >> s,h|w|s){\n\t\tmemset(electro,0,sizeof(electro));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tcin >> electro[i][j];\n\t\t\t\tif(i)\n\t\t\t\t\telectro[i][j]+=electro[i-1][j];\n\t\t\t\tif(j)\n\t\t\t\t\telectro[i][j]+=electro[i][j-1];\n\t\t\t\tif(i&&j)\n\t\t\t\t\telectro[i][j]-=electro[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\t/*for(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tcout << electro[i][j] <<\" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tP ans=divide(0,0,w,h);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t//cout << memo[0][0][0][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nconst int IINF = INT_MAX;\n\nint h,w,supply,u[33][33],lower;\nii memo[33][33][33][33];//[upper left][upper left][lower right][lower right] := ii(the number of groups, maximum value)\nint dp[34][34];\n\nii dfs(int xL,int yL,int xR,int yR){\n  ii &ret = memo[xL][yL][xR][yR];\n  if( ret != ii(-1,-1) ) return ret;\n  int sum = dp[yR+1][xR+1] - dp[yR+1][xL] - dp[yL][xR+1] + dp[yL][xL];\n  if( sum < lower ) return ret; // invalid group\n\n  bool success = false;  \n  ret = ii(0,IINF);\n  // split : row\n  REP(x,xL,xR){\n    ii temp1 = dfs(xL,yL,x,yR);\n    ii temp2 = dfs(x+1,yL,xR,yR);\n    if( temp1 != ii(-1,-1) && temp2 != ii(-1,-1) ) {\n      success = true;\n      ii temp = ii(temp1.first+temp2.first,min(temp1.second,temp2.second));\n      if( ret < temp ) ret = temp;\n    }\n  }\n  \n  // split : column\n  REP(y,yL,yR){\n    ii temp1 = dfs(xL,yL,xR,y);\n    ii temp2 = dfs(xL,y+1,xR,yR);\n    if( temp1 != ii(-1,-1) && temp2 != ii(-1,-1) ) {\n      success = true;\n      ii temp = ii(temp1.first+temp2.first,min(temp1.second,temp2.second));\n      if( ret < temp ) ret = temp;\n    }\n  }\n  if( !success ) ret = ii(1,sum);\n  return ret;\n}\n\nint main(){\n  while( cin >> h >> w >> supply, h|w|supply ){\n    rep(i,h) rep(j,w) cin >> u[i][j];\n    rep(i,h+1) rep(j,w+1) rep(k,h+1) rep(l,w+1) memo[i][j][k][l] = ii(-1,-1);\n    rep(i,h+1) rep(j,w+1) dp[i][j] = 0;\n    REP(i,1,h+1) REP(j,1,w+1) dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + u[i-1][j-1];\n    lower = dp[h][w] - supply;\n    ii temp = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",temp.first,(int)abs(supply-(dp[h][w]-temp.second)));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint sum;\nint H, W, S;\nint tab[40][40];\nPII memo[40][40][40][40];\nPII dfs(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2].first >= 0) return memo[x1][y1][x2][y2];\n  \n  int tot = 0;\n  for(int y=y1;y<y2;++y)\n\tfor(int x=x1;x<x2;++x)\n\t  tot += tab[y][x];\n  if(sum - tot > S) return memo[x1][y1][x2][y2] = MP(0,0);\n\n  PII& res = memo[x1][y1][x2][y2];\n  res = MP(1,tot);\n  for(int x=x1+1;x<x2;++x){\n\tPII p1 = dfs(x1,y1,x,y2);\n\tPII p2 = dfs(x,y1,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tres = max(res, {p1.first+p2.first, min(p1.second, p2.second)});\n  }\n\n  for(int y=y1+1;y<y2;++y){\n\tPII p1 = dfs(x1,y1,x2,y);\n\tPII p2 = dfs(x1,y,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tres = max(res, {p1.first+p2.first, min(p1.second, p2.second)});\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>W>>S,H){\n\tREP(y,H) REP(x,W) cin >> tab[y][x];\n\tsum = 0;\n\tREP(y,H) REP(x,W) sum += tab[y][x];\n\tfill((PII*)memo, (PII*)memo+40*40*40*40, MP(-1,0));\n\n\t\n\tPII pii = dfs(0,0,W,H);\n\tcout << pii.first << \" \" << S + pii.second - sum << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x) << \" \" \n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npair<int,int> none = make_pair(-1,-1);\npair<int,int> didnotsolve = make_pair(-2,-2);\n// group,yobi\npair<int,int> solve(int lx,int uy,int rx,int dy,int s,vector<vector<vector<vector<pair<int,int>>>>>& memo,\n                                                    const vector<vector<vector<vector<int>>>>& sum){\n    if(memo[lx][uy][rx][dy] != didnotsolve){\n        return memo[lx][uy][rx][dy];\n    }\n    pair<int,int> ret = none;\n    int allsum = sum.front().front().back().back();\n    if(allsum - sum[lx][uy][rx][dy] > s){\n    }else{\n        ret = make_pair(1,(s-(allsum-sum[lx][uy][rx][dy])));\n    }\n    // horiz\n    for(int i=0;i<(dy-uy);i++){\n        pair<int,int> upper = solve(lx,uy,    rx,uy+i,s,memo,sum);\n        pair<int,int> lower = solve(lx,uy+i+1,rx,dy  ,s,memo,sum);\n        if(upper == none or lower == none) continue;\n        pair<int,int> here = make_pair(upper.first+lower.first,min(upper.second,lower.second));\n        ret = max(ret,here);\n    }\n    // vert\n    for(int i=0;i<(rx-lx);i++){\n        pair<int,int> upper = solve(lx    ,uy,lx+i,dy,s,memo,sum);\n        pair<int,int> lower = solve(lx+i+1,uy,rx  ,dy,s,memo,sum);\n        if(upper == none or lower == none) continue;\n        pair<int,int> here = make_pair(upper.first+lower.first,min(upper.second,lower.second));\n        ret = max(ret,here);\n    }\n    return memo[lx][uy][rx][dy] = ret;\n}\n\n// ret[i][j] = sum of all field in [0,i) x [0,j).\ntemplate<typename T>\nvector<vector<T>> calc_sum(const vector<vector<T>>& field){\n    int h = field.size();\n    int w = field[0].size();\n    vector<vector<T>> ret(h+1,vector<T>(w+1));\n    for(int y=1;y<=h;y++){\n        for(int x=0;x<w;x++){\n            ret[y][x+1] = ret[y][x] + field[y-1][x];\n        }\n    }\n    for(int x=0;x<w+1;x++){\n        for(int y=0;y<h;y++){\n            ret[y+1][x] = ret[y+1][x] + ret[y][x];\n        }\n    }\n    return ret;\n}\npair<int,int> doit(vector<vector<int>> field,int s){\n    int w = field[0].size();\n    int h = field.size();\n    vector<vector<vector<vector<pair<int,int>>>>> memo(w,vector<vector<vector<pair<int,int>>>>\n                                                      (h,vector<vector<pair<int,int>>>\n                                                      (w,vector<pair<int,int>>(h,didnotsolve))));\n    vector<vector<int>> sum = calc_sum(field);\n    vector<vector<vector<vector<int>>>> sum_memo(w,vector<vector<vector<int>>>\n                                                (h,vector<vector<int>>\n                                                (w,vector<int>(h,0))));\n\n    for(int uy=0;uy<h;uy++){\n        for(int dy=uy;dy<h;dy++){\n            for(int lx=0;lx<w;lx++){\n                for(int rx=lx;rx<w;rx++){\n                    sum_memo[lx][uy][rx][dy] = sum[dy+1][rx+1] - sum[uy][rx+1] - sum[dy+1][lx] + sum[uy][lx];\n                }\n            }\n        }\n    }\n    pair<int,int> ret = solve(0,0,w-1,h-1,s,memo,sum_memo);\n    return ret;\n}\n\nint main(){\n    while(true){\n        int h,w,s;\n        cin >> h >> w >> s;\n        if(h == 0 and w == 0 and s == 0) break;\n        vector<vector<int>> field(h,vector<int>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n            }\n        }\n        pair<int,int> ret = doit(field,s);\n        cout << ret.first << \" \" << ret.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,f,n)  for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass E{\npublic:\n  int split;\n  int power;\n  E(){}\n  E(int split,int power):split(split),power(power){}\n  bool operator<(const E& a)const{\n    if(split==a.split)return power<a.power;\n    return split<a.split;\n  }\n  E operator+(const E& a)const{\n    return E(split+a.split, min(power, a.power));\n  }\n};\n\n\nconst int H = 33;\nconst int INF = 1000000000;\nint h,w,s;\nint allpower;\nint board[H][H];\nint sum[H][H];\n\nE memo[H][H][H][H];\n\nvoid init(){\n  rep(i,H)rep(j,H)sum[i][j]=0;\n  rep(i,H)rep(j,H)rep(k,H)rep(p,H)memo[i][j][k][p] = E(-1,-1);\n}\n\nbool input(){\n  cin>>h>>w>>s;\n  if(h==0)return false;\n\n  rep(i,h){\n    rep(j,w){\n      cin>>board[i][j];\n    }\n  }\n\n  return true;\n}\n\nvoid mksum(){\n  rep(i,H)rep(j,H)sum[i][j] = 0;\n  reps(i,1,h+1){\n    reps(j,1,w+1){\n      sum[i][j] = sum[i-1][j] + sum[i][j-1] -sum[i-1][j-1] + board[i-1][j-1];\n    }\n  }\n\n  allpower = 0;\n  rep(i,h)rep(j,w)allpower += board[i][j];\n}\n\nint getsum(int y1,int x1,  int y2,int x2){\n  return sum[y2][x2] - sum[y1][x2] - sum[y2][x1] + sum[y1][x1];\n}\n\nE solve_dp(int y1,int x1,int y2,int x2){\n  if(memo[y1][x1][y2][x2].split!=-1)return memo[y1][x1][y2][x2];\n\n  int power = getsum(y1,x1,y2,x2);\n  if(allpower-power>s)return E(-INF,-INF);\n\n  E ret(1, s-(allpower-power));\n  reps(i,y1+1,y2){\n    ret = max(ret, solve_dp(y1,x1,i,x2)+solve_dp(i,x1,y2,x2));\n  }\n  reps(i,x1+1,x2){\n    ret = max(ret, solve_dp(y1,x1,y2,i)+solve_dp(y1,i,y2,x2));\n  }\n  return memo[y1][x1][y2][x2]=ret;\n}\n\npair<int,int> solve(){\n  pair<int,int> ret;\n  mksum();\n  E res = solve_dp(0,0,h,w);\n  ret.first = res.split;\n  ret.second = res.power;\n  return ret;\n}\n\nint main(){\n  while(init(),input()){\n    pair<int,int> ret = solve();\n    printf(\"%d %d\\n\",ret.first, ret.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, S;\nvector< vector<int> > A;\nbool m1[40][40][40][40];\nP m2[40][40][40][40];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, S-(getM(0, 0, W, H) - getM(x1, y1, x2, y2)));\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> S, H || W || S) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[39][39][40], false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define N 32\n#define INF (1e8)\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\npii dp[N+1][N+1][N+1][N+1];\nint h,w,s,sum,l;\nint u[N][N];\n\npii add(pii a,pii b){\n\tpii r = make_pair(a.first+b.first,min(a.second,b.second));\n\treturn r;\n}\n\npii dfs(int x0,int y0,int x1,int y1){\n\tif(dp[x0][y0][x1][y1].first > 0)return dp[x0][y0][x1][y1];\n\tpii r;\n\tint p=0;\n\tfor(int i=x0;i<x1;i++)for(int j=y0;j<y1;j++)p+=u[i][j];\n\tr = make_pair(1,p);\n\tfor(int i=x0+1;i<x1;i++){\n\t\tpii t = add( dfs(x0,y0,i,y1), dfs(i,y0,x1,y1) );\n\t\tif(t.second >= l) r = max(r,t);\n\t}\n\tfor(int i=y0+1;i<y1;i++){\n\t\tpii t = add( dfs(x0,y0,x1,i), dfs(x0,i,x1,y1) );\n\t\tif(t.second >= l) r = max(r,t);\n\t}\n\treturn dp[x0][y0][x1][y1] = r;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d%d%d\",&h,&w,&s);\n\t\tif(!(h*w*s))break;\n\t\tsum = 0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\trep(i,h)rep(j,w){\n\t\t\tscanf(\"%d\",u[i]+j);\n\t\t\tsum += u[i][j];\n\t\t}\n\t\tl = sum - s;\n\t\tpii ans = dfs(0,0,h,w);\n\t\tprintf(\"%d %d\\n\",ans.first,l - ans.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h,w,s,all;\nint u[35][35] = {0};\nint f[35][35] = {0};\n// メモ化, DP\nP dp[35][35][35][35];\n\n// [x1,x2] && [y1,y2] の領域の総和を計算する.\nint sum(int x1, int y1, int x2, int y2){\n\tx2++; y2++;\n\treturn f[y2-1][x2-1] - f[y2-1][x1-1] - f[y1-1][x2-1] + f[y1-1][x1-1];\n}\n\n// 初期化.\nvoid init(){\n\tfor(int i=0 ; i < 35 ; i++ ){\n\t\tfor(int j=0 ; j < 35 ; j++ ){\n\t\t\tfor(int k=0 ; k < 35 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 35 ; l++ ){\n\t\t\t\t\tdp[i][j][k][l].first = dp[i][j][k][l].second = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// メモ化再帰, P.first := 最大グループ数, P.second := 最大予備力.\nP dfs(int lx, int ly, int rx, int ry){\n\tif( dp[lx][ly][rx][ry].first != 0 ) return dp[lx][ly][rx][ry];\n\t\n\tP res = P( 1 , s - (all - sum(lx,ly,rx,ry)) );\n\t\n\t// 水平に分割\n\tfor(int y=ly ; y < ry ; y++ ){\n\t\tif( all - s > sum(lx,ly,rx,y) ) continue;\n\t\tif( all - s > sum(lx,y+1,rx,ry) ) continue;\n\t\tP a = dfs( lx , ly  , rx , y );\n\t\tP b = dfs( lx , y+1 , rx , ry );\n\t\tP now = P( a.first + b.first , min(a.second,b.second) );\n\t\tres = max( res , now );\n\t}\n\t\n\t// 垂直に分割\n\tfor(int x=lx ; x < rx ; x++ ){\n\t\tif( all - s > sum(lx,ly,x,ry) ) continue;\n\t\tif( all - s > sum(x+1,ly,rx,ry) ) continue;\n\t\tP a = dfs(lx,ly,x,ry);\n\t\tP b = dfs(x+1,ly,rx,ry);\n\t\tP now = P( a.first + b.first , min(a.second,b.second) );\n\t\tres = max( res , now );\n\t}\n\treturn dp[lx][ly][rx][ry] = res;\n}\n\nint main(){\n\twhile( cin >> h >> w >> s, h || w || s ){\n\t\t//入力 + 累積和化\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tfor(int x = 1 ; x <= w ; x++ ){\n\t\t\t\tcin >> u[y][x];\n\t\t\t\tf[y][x] = u[y][x] + f[y][x-1];\n\t\t\t}\n\t\t}\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tfor(int x = 1 ; x <= w ; x++ ){\n\t\t\t\tf[y][x] += f[y-1][x];\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tall = sum(1,1,w,h);\n\t\tP ans = dfs( 1 , 1 , w , h );\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 33\n\n\nint h, w, s, u[SIZE][SIZE] = {};\nint sum_u[SIZE][SIZE] = {};\npair<int, int> dp[SIZE][SIZE][SIZE][SIZE]; //Group, rest\n\nint rangeSum(int t, int l, int b, int r){\n  return sum_u[t][l] + sum_u[b][r] - sum_u[t][r] - sum_u[b][l];\n}\n\npair<int,int> merge(pair<int,int> a, pair<int,int> b){\n  return {a.first + b.first, min(a.second, b.second)};\n}\n\nint solve(){\n  \n  scanf(\"%d%d%d\", &h, &w, &s);\n\n  int L = -s;\n  \n  if(h == 0) return false;\n  \n  for(int i=1;i<=h;i++){\n    for(int j=1;j<=w;j++){\n      scanf(\"%d\", u[i]+j);\n      sum_u[i][j] = sum_u[i][j-1] + u[i][j];\n      L += u[i][j];\n    }\n  }\n\n  //debug(L);\n  \n  for(int i=1;i<=h;i++){\n    for(int j=0;j<=w;j++){\n      sum_u[i][j] += sum_u[i-1][j];\n    }\n  }\n\n  for(int t=0;t<h;t++){\n    for(int l=0;l<w;l++){\n\n      for(int b=t+1;b<=h;b++){\n        for(int r=l+1;r<=w;r++){\n          int res = rangeSum(t,l,b,r);\n          if(res >= L && res <= s)\n            dp[t][l][b][r] = {1, res - L};\n          else\n            dp[t][l][b][r] = {0, -INF};\n        }\n      }\n      \n    }\n  }\n\n  \n  for(int p=1;p<=h;p++){\n    for(int q=1;q<=w;q++){\n      for(int t=0;t+p<=h;t++){\n        for(int l=0;l+q<=w;l++){\n\n          int b = t+p;\n          int r = l+q;\n          \n          for(int i=t+1;i<b;i++){\n            if(dp[t][l][i][r].first && dp[i][l][b][r].first){\n              dp[t][l][b][r] = max(dp[t][l][b][r],\n                                   merge(dp[t][l][i][r], dp[i][l][b][r]));\n            }\n          }\n\n          for(int i=l+1;i<r;i++){\n            if(dp[t][l][b][i].first && dp[t][i][b][r].first){\n              dp[t][l][b][r] = max(dp[t][l][b][r],\n                                   merge(dp[t][l][b][i], dp[t][i][b][r]));\n            }\n          }\n        }\n      }\n      \n    }\n  }\n\n  printf(\"%d %d\\n\", dp[0][0][h][w].first, dp[0][0][h][w].second);\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\nint h, w, s, u[33][33], sum;\n\nvoid makeImos() {\n\tfor_(y,1,h+1) for_(x,0,w) u[y][x+1] += u[y][x];\n\tfor_(x,1,w+1) for_(y,0,h) u[y+1][x] += u[y][x];\n\tsum = u[h][w];\n}\n\nint getImos(int l, int t, int r, int b) { return u[b][r] + u[t][l] - u[b][l] - u[t][r]; }\n\nconst pii ini(-1, -1);\npii dp[33][33][33][33];\n\npii rec(int l, int t, int r, int b) {\t\n\tpii& res = dp[l][t][r][b];\n\t\n\tif (res != ini) return res;\n\t\n\tint power = getImos(l, t, r, b);\n\tif (sum - power > s) return res = pii(0, 0);\n\t\n\tres = pii(1, s - (sum - power));\n\t\n\tfor_(y,t+1,b) {\n\t\tpii nxt_a = rec(l, t, r, y);\n\t\tpii nxt_b = rec(l, y, r, b);\n\t\tpii nxt_p(nxt_a.first + nxt_b.first, min(nxt_a.second, nxt_b.second));\n\t\tres = max(res, nxt_p);\n\t}\n\t\n\tfor_(x,l+1,r) {\n\t\tpii nxt_a = rec(l, t, x, b);\n\t\tpii nxt_b = rec(x, t, r, b);\n\t\tpii nxt_p(nxt_a.first + nxt_b.first, min(nxt_a.second, nxt_b.second));\n\t\tres = max(res, nxt_p);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tmakeImos();\n\tfor_(i,0,33) for_(j,0,33) for_(ii,0,33) for_(jj,0,33) dp[i][j][ii][jj] = ini;\n\tpii ans = rec(0, 0, w, h);\n\tcout << ans.first << \" \" << ans.second << endl;\n}\n\nint main() {\n\twhile (cin >> h >> w >> s) {\n\t\tif (h == 0) break;\n\t\tmemset(u, 0, sizeof(u));\n\t\tfor_(y,0,h) for_(x,0,w) cin >> u[y+1][x+1];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int g;\n    int e;\n    Data(){\n        g = e = -1;\n    }\n    Data(int g0, int e0){\n        g = g0;\n        e = e0;\n    }\n    bool operator<(const Data& d) const{\n        return g < d.g || (g == d.g && e < d.e);\n    }\n};\n\nbool check[32][32][32][32];\nData memo[32][32][32][32];\n\nData solve(int y1, int x1, int y2, int x2, int s)\n{\n    if(check[y1][x1][y2][x2])\n        return memo[y1][x1][y2][x2];\n\n    int tmp = 0;\n    for(int i=y1; i<=y2; ++i){\n        for(int j=x1; j<=x2; ++j){\n            tmp += memo[i][j][i][j].e;\n        }\n    }\n    if(tmp < s)\n        return Data();\n\n    Data ret(1, tmp);\n    for(int i=y1; i<y2; ++i){\n        Data d1 = solve(y1, x1, i, x2, s);\n        Data d2 = solve(i+1, x1, y2, x2, s);\n        if(d1.g == -1 || d2.g == -1)\n            continue;\n        Data d3(d1.g + d2.g, min(d1.e, d2.e));\n        ret = max(ret, d3);\n    }\n    for(int i=x1; i<x2; ++i){\n        Data d1 = solve(y1, x1, y2, i, s);\n        Data d2 = solve(y1, i+1, y2, x2, s);\n        if(d1.g == -1 || d2.g == -1)\n            continue;\n        Data d3(d1.g + d2.g, min(d1.e, d2.e));\n        ret = max(ret, d3);\n    }\n\n    check[y1][x1][y2][x2] = true;\n    memo[y1][x1][y2][x2] = ret;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int h, w, s;\n        cin >> h >> w >> s;\n        if(h == 0)\n            return 0;\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                for(int k=0; k<h; ++k){\n                    for(int l=0; l<w; ++l){\n                        check[i][j][k][l] = false;\n                        memo[i][j][k][l] = Data();\n                    }\n                }\n            }\n        }\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                memo[i][j][i][j].g = 1;\n                cin >> memo[i][j][i][j].e;\n                s -= memo[i][j][i][j].e;\n            }\n        }\n        s *= -1;\n\n        Data d = solve(0, 0, h-1, w-1, s);\n        cout << d.g << ' ' << (d.e-s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int MAX_WH = 33;\nint H, W, s;\nint G[MAX_WH][MAX_WH];\nint S[MAX_WH][MAX_WH];\npair<int, int> T[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\n\nint make() {\n  for(int h = 0; h <= H; ++h) {\n    for(int w = 0; w <= W; ++w) {\n      S[h][w] = 0;\n      for(int i = 0; i < h; ++i) {\n\tfor(int j = 0; j < w; ++j) {\n\t  S[h][w] += G[i][j];\n\t}\n      }\n    }\n  }\n}\n\nint sum(int sx, int sy, int ex, int ey) {\n  return S[ey][ex] - S[ey][sx] - S[sy][ex] + S[sy][sx];\n}\n\npair<int, int> solve(int sx, int sy, int ex, int ey) {\n  pair<int, int> &res = T[sy][sx][ey][ex];\n  pair<int, int> p1, p2;\n  if(res.first == -1) {\n    res.first = 1;\n    res.second = -1 * (sum(0,0,W,H) - sum(sx,sy,ex,ey));\n    for(int i = sx+1; i < ex; ++i) {\n      int d = max(sum(0,0,W,H) - sum(sx, sy, i, ey),\n\t\t  sum(0,0,W,H) - sum(i, sy, ex, ey));\n      if(d <= s) {\n\tp1 = solve(sx,sy,i,ey);\n\tp2 = solve(i,sy,ex,ey);\n        res = max(res, make_pair(p1.first+p2.first, min(p1.second, p2.second)));\n      }\n    }\n    for(int i = sy+1; i < ey; ++i) {\n      int d = max(sum(0,0,W,H) - sum(sx, sy, ex, i),\n\t\t  sum(0,0,W,H) - sum(sx, i, ex, ey));\n      if(d <= s) {\n\tp1 = solve(sx,sy,ex,i);\n\tp2 = solve(sx,i,ex,ey);\n        res = max(res, make_pair(p1.first+p2.first, min(p1.second, p2.second)));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> H >> W >> s && (H || W || s)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    make();\n    fill(T[0][0][0], T[MAX_WH][0][0], make_pair(-1,-1));\n    pair<int, int> ans = solve(0,0,W,H);\n    cout << ans.first <<  \" \" << s+ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n\n\n#endif // 0\n\n#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int MAXN = (int) 35;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\nint H,W,S;\nint f[MAXN][MAXN][MAXN][MAXN];\nint g[MAXN][MAXN][MAXN][MAXN];\nint a[MAXN][MAXN];\nint TOTAL;\nint MI;\n\nint get_sum(int i,int j,int k,int t){\n    return a[k][t]-a[k][j-1]-a[i-1][t]+a[i-1][j-1];\n}\n\nvoid DFS(int I,int J,int K,int T){\n    f[I][J][K][T]=1;\n    g[I][J][K][T]=get_sum(I,J,K,T);\n    if(I==K&&J==T) return;\n    if(g[I][J][K][T]<MI) return;\n    for(int i=I;i<K;i++){\n        if(f[I][J][i][T]==-1) DFS(I,J,i,T);\n        if(f[i+1][J][K][T]==-1) DFS(i+1,J,K,T);\n        if(g[I][J][i][T]>=MI&&g[i+1][J][K][T]>=MI){\n            if(f[I][J][i][T]+f[i+1][J][K][T]>f[I][J][K][T]){\n                f[I][J][K][T]=f[I][J][i][T]+f[i+1][J][K][T];\n                g[I][J][K][T]=min(g[I][J][i][T],g[i+1][J][K][T]);\n            }\n            else if(f[I][J][i][T]+f[i+1][J][K][T]==f[I][J][K][T]){\n                int cur_mi=min(g[I][J][i][T],g[i+1][J][K][T]);\n                g[I][J][K][T]=max(g[I][J][K][T],cur_mi);\n            }\n        }\n    }\n    for(int j=J;j<T;j++){\n        if(f[I][J][K][j]==-1) DFS(I,J,K,j);\n        if(f[I][j+1][K][T]==-1) DFS(I,j+1,K,T);\n        if(g[I][J][K][j]>=MI&&g[I][j+1][K][T]>=MI){\n            if(f[I][J][K][j]+f[I][j+1][K][T]>f[I][J][K][T]){\n                f[I][J][K][T]=f[I][J][K][j]+f[I][j+1][K][T];\n                g[I][J][K][T]=min(g[I][J][K][j],g[I][j+1][K][T]);\n            }\n            else if(f[I][J][K][j]+f[I][j+1][K][T]==f[I][J][K][T]){\n                int cur_mi=min(g[I][J][K][j],g[I][j+1][K][T]);\n                g[I][J][K][T]=max(g[I][J][K][T],cur_mi);\n            }\n        }\n    }\n}\n\nvoid work(){\n    while(~scanf(\"%d%d%d\",&H,&W,&S)){\n        if(H==0&&W==0&&S==0) break;\n        TOTAL=0;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                scanf(\"%d\",&a[i][j]);\n                TOTAL+=a[i][j];\n                a[i][j]+=a[i][j-1];\n            }\n        }\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                a[i][j]+=a[i-1][j];\n            }\n        }\n//        for(int i=1;i<=H;i++){\n//            for(int j=1;j<=W;j++){\n//                printf(\"%d \",a[i][j]);\n//            }\n//            printf(\"\\n\");\n//        }\n        MI=TOTAL-S;\n        memset(f,-1,sizeof(f));\n        memset(g,-1,sizeof(g));\n        DFS(1,1,H,W);\n        printf(\"%d %d\\n\",f[1][1][H][W],g[1][1][H][W]-MI);\n    }\n}\n\nint main(){\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\n#define F first\n#define S second\nP dp[33][33][33][33];\nint h,w,s,sum[33][33],a[33][33],SUM;\nvoid dpp(){\n  r(i,33)r(j,33)r(k,33)r(l,33)dp[i][j][k][l]=P(0,1e9);\n  memset(sum,0,sizeof(sum));\n  r(i,h)r(j,w)sum[i+1][j+1]=a[i][j];\n  r(i,h+1)r(j,w)sum[i][j+1]+=sum[i][j];\n  r(j,w+1)r(i,h)sum[i+1][j]+=sum[i][j];\n}\nint get(int ly,int lx,int ry,int rx){\n  return sum[ry+1][rx+1]-sum[ry+1][lx]-sum[ly][rx+1]+sum[ly][lx];\n}\nP dfs(int ly,int lx,int ry,int rx){\n  if(dp[ly][lx][ry][rx]!=P(0,1e9))return dp[ly][lx][ry][rx];\n  P res=P(1,SUM-get(ly,lx,ry,rx));//cout<<get(ly,lx,ry,rx)<<endl;\n  for(int i=lx;i<rx;i++){\n    if(s-(SUM-get(ly,lx,ry,i))<0)continue;\n    if(s-(SUM-get(ly,i+1,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,ry,i),res2=dfs(ly,i+1,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  for(int i=ly;i<ry;i++){\n    if(s-(SUM-get(ly,lx,i,rx))<0)continue;\n    if(s-(SUM-get(i+1,lx,ry,rx))<0)continue;\n    P res1=dfs(ly,lx,i,rx),res2=dfs(i+1,lx,ry,rx);\n    res=max(res,P(res1.F+res2.F,min(res1.S,res2.S)));\n  }\n  return dp[ly][lx][ry][rx]=res;\n}\n\nint main(){\n  while(cin>>h>>w>>s,s){\n    SUM=0;\n    r(i,h)r(j,w)cin>>a[i][j],SUM+=a[i][j];\n    dpp();\n    P p=dfs(0,0,h-1,w-1);\n    cout<<p.F<<' '<<p.S<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int num, p;\n};\n\nbool operator<(const data &l, const data &r) {\n  if(l.num != r.num) return l.num < r.num;\n  return l.p < r.p;\n}\nbool operator!=(const data &l, const data &r) {\n  return l.num != r.num || l.p != r.p;\n}\nbool operator==(const data &l, const data &r) {\n  return l.num == r.num && l.p == r.p;\n}\n\nint h, w, s;\nvector<vector<int>> u, sum;\ndata dummy, ans;\ndata dp[40][40][40][40];\n\nvoid resetdp();\nint calcsum(int down, int up, int left, int right);\ndata solve(int down, int up, int left, int right);\n\nint main() {\n  dummy = {-1, -1};\n  while(1) {\n    cin >> h >> w >> s;\n    if(h + w + s == 0) break;\n    u.assign(h, vector<int>(w, 0));\n    sum.assign(h, vector<int>(w, 0));\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j) cin >> u[i][j];\n    resetdp();\n    ans = solve(0, h - 1, 0, w - 1);\n    cout << ans.num << \" \" << ans.p << endl;\n  }\n  return 0;\n}\n\nvoid resetdp() {\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < h; ++j)\n      for(int k = 0; k < w; ++k)\n        for(int l = 0; l < w; ++l) dp[i][j][k][l] = dummy;\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j) {\n      sum[i][j] = u[i][j];\n      if(i != 0) sum[i][j] += sum[i - 1][j];\n      if(j != 0) sum[i][j] += sum[i][j - 1];\n      if(i != 0 && j != 0) sum[i][j] -= sum[i - 1][j - 1];\n    }\n}\n\nint calcsum(int down, int up, int left, int right) {\n  int nans = 0;\n  nans = sum[up][right];\n  if(down != 0) nans -= sum[down - 1][right];\n  if(left != 0) nans -= sum[up][left - 1];\n  if(left != 0 && down != 0)\n    nans += sum[down - 1][left - 1];\n  return nans;\n}\n\ndata solve(int down, int up, int left, int right) {\n  if(dp[down][up][left][right] != dummy)\n    return dp[down][up][left][right];\n  data nowans = {1, s - sum[h - 1][w - 1] +\n                        calcsum(down, up, left, right)};\n  if(nowans.p < 0) return dummy;\n  for(int i = down; i < up; ++i) {\n    data now1 = solve(down, i, left, right),\n         now2 = solve(i + 1, up, left, right);\n    if(now1 == dummy || now2 == dummy) continue;\n    now1.num += now2.num;\n    now1.p = min(now1.p, now2.p);\n    nowans = max(now1, nowans);\n  }\n  for(int i = left; i < right; ++i) {\n    data now1 = solve(down, up, left, i),\n         now2 = solve(down, up, i + 1, right);\n    if(now1 == dummy || now2 == dummy) continue;\n    now1.num += now2.num;\n    now1.p = min(now1.p, now2.p);\n    nowans = max(now1, nowans);\n  }\n\n  return dp[down][up][left][right] = nowans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 35\n\nint w, h;\nint s[MAX][MAX];\nint dp[MAX][MAX];\nint cost[MAX][MAX][4];\nint c[4];\nstruct Point {\n\tint y, x, dir, cost;\n};\n//bool next_flag(Point& now) {\n//\tint i;\n//\tbool flag = false;\n//\trep(i, 4) {\n//\t\tint ny = now.y + dy[i];\n//\t\tint nx = now.x + dx[i];\n//\t\tif (ny < 0 || h <= ny) continue;\n//\t\tif (nx < 0 || w <= nx) continue;\n//\t\tif (cost[ny][nx] > cost[now.y][now.x]) flag = true;\n//\t}\n//\treturn flag;\n//}\nint ddir[] = { 0,3,2,1 };\nvoid bfs() {\n\tint i, j, k;\n\trep(i, h) rep(j, w) rep(k, 4) cost[i][j][k] = INT_MAX;\n\tqueue<Point> q;\n\tq.push({ 0,0,1,0 });\n\tcost[0][0][1] = 0;\n\twhile (q.size()) {\n\t\tPoint now = q.front(); q.pop();\n\t\trep(i, 4) {\n\t\t\tint ndir = (now.dir + ddir[i]) % 4;\n\t\t\tint ny = now.y + dy[ndir];\n\t\t\tint nx = now.x + dx[ndir];\n\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\tif (nx < 0 || w <= nx) continue;\n\n\t\t\tint ncost = now.cost;\n\t\t\tif (s[now.y][now.x] != i) ncost += c[i];\n\n\t\t\tif (ncost < cost[ny][nx][ndir]) {\n\t\t\t\tcost[ny][nx][ndir] = ncost;\n\t\t\t\tq.push({ ny,nx,ndir,ncost });\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(void)\n{\n\tint i, j, k;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) rep(j, w) reader(s[i][j]);\n\t\trep(i, 4) reader(c[i]);\n\t\tbfs();\n\t\tint ans = INT_MAX;\n\t\trep(i, 4) {\n\t\t\tif (cost[h - 1][w - 1][i] < ans) {\n\t\t\t\tans = cost[h - 1][w - 1][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint H, W, S, U[35][35];\nint sum[35][35][35][35];\npair<int, int> dp[35][35][35][35];\n//dp[y1][x1][y2][x2]: [(y1,x1),(y2,x2)]??? ????????¢??? <?????§??°???????????°, ?????????>\n//dp[0][0][H-1][W-1]??????????????????\n\npair<int, int> dfs(int y1, int x1, int y2, int x2){\n  if(dp[y1][x1][y2][x2].F != -INF){\n     return dp[y1][x1][y2][x2];\n  }\n\n  //first: ?????????????????¨????????????????????°??????????????¨??????????????°??????????????????????????¨??????????????????1?????\\??????\n  //second: ????????????????????°??????????????£?????´??????????????????????????\\????????????\n  pair<int, int> ret = make_pair(1, S-(sum[0][0][H-1][W-1]-sum[y1][x1][y2][x2]));\n\n  //?????´??????\n  for(int cutx=x1; cutx<x2; cutx++){\n    int suml = sum[y1][x1][y2][cutx];\n    int sumr = sum[y1][cutx+1][y2][x2];\n    if(sum[0][0][H-1][W-1]-suml > S || sum[0][0][H-1][W-1]-sumr > S) continue;\n    pair<int, int>  l = dfs(y1,x1,y2,cutx);\n    pair<int, int>  r = dfs(y1,cutx+1,y2,x2);\n    pair<int, int> tmp = make_pair(l.F+r.F, min(l.S,r.S));  //???????????????????????§?¨?????????????\n    ret = max(ret, tmp);  //F->S????????§????????????????????§????????§OK\n  }\n\n  //?°´?????????\n  for(int cuty=y1; cuty<y2; cuty++){\n    int suml = sum[y1][x1][cuty][x2];\n    int sumr = sum[cuty+1][x1][y2][x2];\n    if(sum[0][0][H-1][W-1]-suml > S || sum[0][0][H-1][W-1]-sumr > S) continue;\n    pair<int, int>  l = dfs(y1,x1,cuty,x2);\n    pair<int, int>  r = dfs(cuty+1,x1,y2,x2);\n    pair<int, int> tmp = make_pair(l.F+r.F, min(l.S,r.S));  //???????????????????????§?¨?????????????\n    ret = max(ret, tmp);  //F->S????????§????????????????????§????????§OK\n  }\n\n  //???????????§??\\???????????§?????????????????????????????????????????????????±???????????????§???\n  //????????§dp?????\\??????????????????????????????????????????????????????????????????????????????????????¢?´¢?????????dp?????????????????§?????????\n  return dp[y1][x1][y2][x2] = ret;\n}\n\n\nint main() {\n  while(1){\n    cin>>H>>W>>S;\n    if(H==0&&W==0&&S==0) break;\n    REP(i,0,H){\n      REP(j,0,W){\n        cin>>U[i][j];\n      }\n    }\n    //????????????????¨?????????????????????????\n    REP(i,0,H){\n      REP(j,0,W){\n        REP(ranH,0,H-i)REP(ranW,0,W-j){\n          int tmp = 0;\n          REP(k,i,i+ranH+1){\n            REP(l,j,j+ranW+1){\n              tmp += U[k][l];\n            }\n          }\n          sum[i][j][i+ranH][j+ranW] = tmp;\n        }\n      }\n    }\n    //?????????\n    REP(i,0,H){\n      REP(j,0,W){\n        REP(k,0,H){\n          REP(l,0,W){\n            dp[i][j][k][l] = make_pair(-INF,-INF);\n          }\n        }\n      }\n    }\n\n    pair<int, int> ans = dfs(0,0,H-1,W-1);\n    cout<<ans.F<<\" \"<<ans.S<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// ¶ãÌÀWÆEºÌÀWÅÍÍðwèµA±ÌÍÍÌÅåO[vðL¯\npair<int,int> dp[32][32][32][32];\nint h,w,s;\nint field[32][32];\nint sumDemand;\n\npair<int,int> dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[miny][minx][maxy][maxx].first!=-1)\n\t\treturn dp[miny][minx][maxy][maxx];\n\t// »ÝÌêðâd³¹½Æ«ÉAùvªð´¦È¢©Ç¤©\n\tint decDemand=0;\n\tfor(int i = miny; i <= maxy; i++){\n\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\tdecDemand+=field[i][j];\n\t\t}\n\t}\n\tif(sumDemand - decDemand > s){\n\t\treturn make_pair(-1,0);\n\t}\n\n\tint pre=sumDemand-decDemand;\n\n\tpair<int,int> maxGroup;\n\tmaxGroup.first=1;\n\tmaxGroup.second=pre;\n\n\t// «èû·×Äð·\n\t// ¡Øè\n\tfor(int i = miny; i < maxy; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,maxx,i);\n\t\tpair<int,int> ret2=dfs(minx,i+1,maxx,maxy);\n\t\t// ±Ì«èûÍsÂ\\\n\t\tif(ret1.first==-1||ret2.first==-1)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\n\t}\n\t// tateØè\n\tfor(int i = minx; i < maxx; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,i,maxy);\n\t\tpair<int,int> ret2=dfs(i+1,miny,maxx,maxy);\n\t\tif(ret1.first==-1||ret2.first==-2)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t}\n\tdp[miny][minx][maxy][maxx]=maxGroup;\n\treturn maxGroup;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&!(h==0&&s==0&&w==0)){\n\t\tfor(int i = 0; i < 32; i++)\n\t\t\tfor(int j = 0; j < 32; j++)\n\t\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t\t\tfill(dp[i][j][k],dp[i][j][k]+32,make_pair(-1,0));\n\t\tsumDemand=0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tsumDemand+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mxg=dfs(0,0,w-1,h-1);\n\t\tcout<<mxg.first<<\" \"<<s-mxg.second<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ¶ãÌÀWÆEºÌÀWÅÍÍðwèµA±ÌÍÍÌÅåO[vðL¯\npair<int,int> dp[32][32][32][32];\nint h,w,s;\nint field[32][32];\nint sumDemand;\n\n\npair<int,int> dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[miny][minx][maxy][maxx].first!=-1)\n\t\treturn dp[miny][minx][maxy][maxx];\n\t// »ÝÌêðâd³¹½Æ«ÉAùvªð´¦È¢©Ç¤©\n\tint decDemand=0;\n\tfor(int i = miny; i <= maxy; i++){\n\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\tdecDemand+=field[i][j];\n\t\t}\n\t}\n\tif(sumDemand - decDemand > s){\n\t\treturn make_pair(-1,0);\n\t}\n\n\tint pre=sumDemand-decDemand;\n\n\tpair<int,int> maxGroup;\n\tmaxGroup.first=1;\n\tmaxGroup.second=pre;\n\n\t// «èû·×Äð·\n\t// ¡Øè\n\tfor(int i = miny; i < maxy; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,maxx,i);\n\t\tpair<int,int> ret2=dfs(minx,i+1,maxx,maxy);\n\t\t// ±Ì«èûÍsÂ\\\n\t\tif(ret1.first==-1||ret2.first==-1)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\n\t}\n\t// tateØè\n\tfor(int i = minx; i < maxx; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,i,maxy);\n\t\tpair<int,int> ret2=dfs(i+1,miny,maxx,maxy);\n\t\tif(ret1.first==-1||ret2.first==-2)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t}\n\tdp[miny][minx][maxy][maxx]=maxGroup;\n\treturn maxGroup;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&!(h==0&&s==0&&w==0)){\n\t\tfor(int i = 0; i < 32; i++)\n\t\t\tfor(int j = 0; j < 32; j++)\n\t\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t\t\tfill(dp[i][j][k],dp[i][j][k]+32,make_pair(-1,-1));\n\t\tsumDemand=0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tsumDemand+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mxg=dfs(0,0,w-1,h-1);\n\t\tcout<<mxg.first<<\" \"<<s-mxg.second<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\n#define MAX_SZ 33\n\nint dp_g[MAX_SZ][MAX_SZ][MAX_SZ][MAX_SZ]; // group\nint dp_y[MAX_SZ][MAX_SZ][MAX_SZ][MAX_SZ]; // yobi-power\nint u[MAX_SZ][MAX_SZ];\nint rui[MAX_SZ][MAX_SZ];\n\nclass Solve {\npublic:\n\n    int l_cost; // 最小グループ\n\n\n    int kukei(int a, int b, int x, int y) {\n        a--, b--, x--, y--;\n        int ret = rui[x][y];\n        if (b >= 0)ret -= rui[x][b];\n        if (a >= 0)ret -= rui[a][y];\n        if (a >= 0 && b >= 0)ret += rui[a][b];\n\n        return ret;\n    }\n\n    pair<int, int> rec(int a, int b, int x, int y) {\n\n        int &ret_g = dp_g[a][b][x][y];\n        int &ret_y = dp_y[a][b][x][y];\n        if (ret_g != -1) return make_pair(ret_g, ret_y);\n\n        ret_g = 1;\n        ret_y = kukei(a, b, x, y);\n\n        for (int i = a + 1; i < x; ++i) {\n            // [a, b) -> [a, i) + [i, b)\n//            int tmp = rec(a, i, x, y) + rec(i, b, x, y);\n\n            auto A = rec(a, b, i, y);\n            auto B = rec(i, b, x, y);\n            int tmp_g = A.first + B.first;\n            int tmp_y = min(A.second, B.second);\n\n            if (tmp_y < l_cost) {\n                continue;\n            }\n            if (tmp_g > ret_g) {\n                ret_g = tmp_g;\n                ret_y = tmp_y;\n            } else if (tmp_g == ret_g && tmp_y > ret_y) {\n                ret_g = tmp_g;\n                ret_y = tmp_y;\n            }\n        }\n\n        for (int i = b + 1; i < y; ++i) {\n            auto A = rec(a, b, x, i);\n            auto B = rec(a, i, x, y);\n            int tmp_g = A.first + B.first;\n            int tmp_y = min(A.second, B.second);\n\n            if (tmp_y < l_cost) {\n                continue;\n            }\n            if (tmp_g > ret_g) {\n                ret_g = tmp_g;\n                ret_y = tmp_y;\n            } else if (tmp_g == ret_g && tmp_y > ret_y) {\n                ret_g = tmp_g;\n                ret_y = tmp_y;\n            }\n\n        }\n\n\n        if (ret_y < l_cost) {\n            ret_g = 0;\n            ret_y = INF;\n            return make_pair(ret_g, ret_y);\n        }\n\n        return make_pair(ret_g, ret_y);\n//        return ret;\n    }\n\n    bool solve() {\n        int h, w, s;\n        cin >> h >> w >> s;\n        if (h == 0) return false;\n        memset(dp_g, -1, sizeof(dp_g));\n        memset(dp_y, -1, sizeof(dp_y));\n\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> u[i][j];\n            }\n            for (int j = 0; j < w; ++j) {\n                if (j == 0) rui[i][j] = u[i][j];\n                else rui[i][j] = rui[i][j - 1] + u[i][j];\n            }\n        }\n        for (int j = 0; j < w; ++j) {\n            for (int i = 1; i < h; ++i) {\n                rui[i][j] += rui[i - 1][j];\n            }\n        }\n\n        l_cost = kukei(0, 0, h, w) - s;\n\n        auto tapu = rec(0, 0, h, w);\n        Int g = tapu.first;\n        Int y = tapu.second - l_cost;\n\n        cout << g << \" \" << y << endl;\n\n\n//        int ans = rec(0, 0, h, w);\n\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (Solve().solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 100000000\n#define MOD 1000000007\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tP::COST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<P::COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\n\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\n\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\t// 幅と高さは入れ替えておく。めんどくさいので。\n\t\tREAD(int, W, H, s);\n\t\tif (!(W | H | s)){ break; }\n\t\tvevector<int> field = read<int>(W, H);\n\n\t\t// 累積地図に変換\n\t\tREP(x, W) field[x].insert(field[x].begin(), 0);\n\t\tfield.insert(field.begin(), vector<int>(H + 1, 0));\n\t\tFOR(x, 1, W + 1) REP(y, H + 1) field[x][y] += field[x - 1][y];\n\t\tREP(x, W + 1) FOR(y, 1, H + 1) field[x][y] += field[x][y - 1];\n\n\t\tint total = field[W][H];\n\t\tint cap = total - s;\n\n\t\t//分割統治 [x][y][w][h]の四角形の中で最大の分割数と予備電力\n\t\tauto memo = vevevevector<pair<int, int>>(W, H, W + 1, H + 1);\n\t\t\n\t\t// 分割統治法で調べる\n\t\tFOR(w, 1, W + 1) FOR(h, 1, H + 1) REP(x, W - w + 1) REP(y, H - h + 1)\n\t\t{\n\t\t\tint t = field[x + w][y + h] - field[x][y + h] - field[x + w][y] + field[x][y];\n\t\t\tauto r = pair<int, int>(t >= cap ? 1 : 0, t - cap);\n\n\t\t\tauto fn = [](pair<int, int> r, const pair<int, int>&s1, const pair<int, int> &s2) -> pair<int, int>\n\t\t\t{\n\t\t\t\tif (s1.first && s2.first)\n\t\t\t\t{\n\t\t\t\t\tif (s1.first + s2.first > r.first) // 分割すべき\n\t\t\t\t\t{\n\t\t\t\t\t\tr.first = s1.first + s2.first;\n\t\t\t\t\t\tr.second = min(s1.second, s2.second);\n\t\t\t\t\t}\n\t\t\t\t\telse if (s1.first + s2.first == r.first) // 分割すべき？\n\t\t\t\t\t{\n\t\t\t\t\t\tr.second = max(r.second, min(s1.second, s2.second));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t};\n\n\t\t\tFOR(sx, 1, w) r = fn(r, memo[x][y][sx][h], memo[x + sx][y][w - sx][h]);\n\t\t\tFOR(sy, 1, h) r = fn(r, memo[x][y][w][sy], memo[x][y + sy][w][h - sy]);\n\n\t\t\tmemo[x][y][w][h] = r;\n\t\t\t//write(vector<int>{x, y, w, h, r.first, r.second});\n\t\t}\n\t\t\n\t\twrite(memo[0][0][W][H].first, memo[0][0][W][H].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, s, o, a[40][40], sum[40][40];\nint rng(int x1, int y1, int x2, int y2) {\n\treturn sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2];\n}\npair<int, int> solve(int x1, int y1, int x2, int y2) {\n\tint rng_ = rng(x1, y1, x2, y2);\n\tpair<int, int> ret = make_pair(1, rng_);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tpair<int, int> resl = solve(x1, y1, i, y2);\n\t\t\tpair<int, int> resr = solve(i, y1, x2, y2);\n\t\t\tpair<int, int> res = make_pair(resl.first + resr.first, min(resl.second, resr.second));\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tpair<int, int> resl = solve(x1, y1, x2, i);\n\t\t\tpair<int, int> resr = solve(x1, i, x2, y2);\n\t\t\tpair<int, int> res = make_pair(resl.first + resr.first, min(resl.second, resr.second));\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\t//cout << y1 << ' ' << x1 << ' ' << y2 << ' ' << x2 << ' ' << ret.first << ' ' << ret.second << endl;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> H >> W >> s, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\to = sum[H][W] - s;\n\t\tpair<int, int> ret = solve(0, 0, W, H);\n\t\tcout << ret.first << ' ' << ret.second - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint h,w,s;\nint p[32][32],sum[32][32];\npair<int, int> dp[32][32][32][32];\n\nint getSum(int sy, int sx, int gy, int gx){\n\tint ret = sum[gy][gx];\n\tif (sy) ret -= sum[sy - 1][gx];\n\tif (sx) ret -= sum[gy][sx - 1];\n\tif (sy && sx) ret += sum[sy - 1][sx - 1];\n\treturn (ret);\n}\n\npair<int, int> calc(int sy, int sx, int gy, int gx){\n\tif (~dp[sy][sx][gy][gx].first) return (dp[sy][sx][gy][gx]);\n\n\tint cost = sum[h - 1][w - 1] - getSum(sy, sx, gy, gx);\n\tif (cost > s) return make_pair(0, -1);\n\tpair<int, int> res = make_pair(1, -cost);\n\tpair<int, int> a, b, c;\n\n\tfor (int i = sy; i <= gy - 1; i++){\n\t\ta = calc(sy, sx, i, gx); b = calc(i + 1, sx, gy, gx);\n\t\tif (a.first == 0 || b.first == 0) continue;\n\t\tc = make_pair(a.first + b.first, min(a.second, b.second));\n\t\tif (res < c) res = c;\n\t}\n\n\tfor (int i = sx; i <= gx - 1; i++){\n\t\ta = calc(sy, sx, gy, i); b = calc(sy, i + 1, gy, gx);\n\t\tif (a.first == 0 || b.first == 0) continue;\n\t\tc = make_pair(a.first + b.first, min(a.second, b.second));\n\t\tif (res < c) res = c;\n\t}\n\n\treturn (dp[sy][sx][gy][gx] = res);\n}\n\nint main() {\n  while(scanf(\"%d %d %d\", &h,&w,&s) && w){\n    for(int i=0;i < h;i++){\n      for(int j=0;j < w;j++) scanf(\"%d\",&p[i][j] );\n    }\n\n    for(int i=0;i < 32;i++){\n      for(int j=0;j < 32;j++){\n        for(int k=0;k < 32;k++){\n          for(int l=0;l < 32;l++) dp[i][j][k][l].first = dp[i][j][k][l].second = -1;\n        }\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n\n    for(int i=0;i < h;i++){\n      for(int j=0;j < w;j++){\n        sum[i][j] += p[i][j];\n        if(i) sum[i][j] += sum[i-1][j];\n        if(j) sum[i][j] += sum[i][j-1];\n        if (i&&j) sum[i][j] -= sum[i-1][j-1];\n      }\n    }\n    pair<int, int> res = calc(0, 0, h - 1, w - 1);\n\t\tprintf(\"%d %d\\n\", res.first, s + res.second);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, s, S;\nint u[35][35];\nP dp[35][35][35][35];\n\n\nint getpow(int sx, int tx, int sy, int ty)\n{\n\tint ret = 0;\n\tfor(int i = sx; i <= tx; i++){\n\t\tfor(int j = sy; j <= ty; j++){\n\t\t\tret += u[i][j];\n\t\t}\n\t}\n\treturn s - (S - ret);\n}\n\nP dfs(int sx, int tx, int sy, int ty)\n{\n\t//cout << sx << tx << sy << ty << endl;\n\t\n\tif(dp[sx][tx][sy][ty] != make_pair(-1, -1)) return dp[sx][tx][sy][ty];\n\t\n\tP ret = make_pair(1, getpow(sx, tx, sy, ty));\n\tif(ret.second < 0) return make_pair(-inf, -inf);\n\t\n\tP res1, res2;\n\tfor(int i = sx; i <= tx-1; i++){\n\t\tres1 = dfs(sx, i, sy, ty);\n\t\tres2 = dfs(i+1, tx, sy, ty);\n\t\tret = max(ret, make_pair(res1.first + res2.first, min(res1.second, res2.second)) );\n\t}\n\tfor(int i = sy; i <= ty-1; i++){\n\t\tres1 = dfs(sx, tx, sy, i);\n\t\tres2 = dfs(sx, tx, i+1, ty);\n\t\tret = max(ret, make_pair(res1.first + res2.first, min(res1.second, res2.second)) );\n\t}\n\treturn dp[sx][tx][sy][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> h >> w >> s;\n\t\tif(h == 0 && w == 0 && s == 0) break;\n\t\t\n\t\tS = 0;\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tcin >> u[x][y];\n\t\t\t\tS += u[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\tfor(int l = 0; l < h; l++){\n\t\t\t\t\t\tdp[i][j][k][l] = make_pair(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tP ans = dfs(0, w-1, 0, h-1);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint h,w,u,s;\nint dat[35][35];\nint rui[35][35];\n\nmp dp[35][35][35][35];\n\nint gets(int sy,int sx,int gy,int gx){\n\treturn rui[gy+1][gx+1]-rui[gy+1][sx]-rui[sy][gx+1]+rui[sy][sx];\n}\n\nmp memo(int sy,int sx,int gy,int gx){\n\tmp& res=dp[sy][sx][gy][gx];\n\tif(res.fir!=-2)return res;\n\t{\n\t\tint rs=s-gets(sy,sx,gy,gx);\n\t\t//printf(\"%d %d %d %d %d\\n\",sy,sx,gy,gx,rs);\n\t\tif(rs<=u)res = mp(1,u-rs);\n\t\telse res = mp(-1,-1);\n\t}\n\treg(y,sy,gy-1){\n\t\tmp pa=memo(sy,sx,y,gx);\n\t\tmp pb=memo(y+1,sx,gy,gx);\n\t\tif(pa.fir==-1 || pb.fir==-1)continue;\n\t\tmp tp(pa.fir+pb.fir,min(pa.sec,pb.sec));\n\t\tif(tp>res)res=tp;\n\t}\n\treg(x,sx,gx-1){\n\t\tmp pa=memo(sy,sx,gy,x);\n\t\tmp pb=memo(sy,x+1,gy,gx);\t\n\t\tif(pa.fir==-1 || pb.fir==-1)continue;\n\t\tmp tp(pa.fir+pb.fir,min(pa.sec,pb.sec));\n\t\tif(tp>res)res=tp;\n\t}\t\n\treturn res;\n}\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d%d\",&h,&w,&u);\n\t\tif(h==0)break;\n\t\trep(y,h)rep(x,w)scanf(\"%d\",&dat[y][x]);\n\t\trep(i,35)rep(j,35)rep(p,35)rep(q,35)dp[i][j][p][q]=mp(-2,-2);\n\t\tmemst(rui,0);\n\t\ts=0;\n\t\treg(y,1,h)reg(x,1,w){\n\t\t\ts+=dat[y-1][x-1];\n\t\t\trui[y][x]=rui[y-1][x]+rui[y][x-1]-rui[y-1][x-1]+dat[y-1][x-1];\n\t\t}\n\t\tmp ans=memo(0,0,h-1,w-1);\n\t\tprintf(\"%d %d\\n\",ans.fir,ans.sec);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1000000;\n\nint H, W, S;\nint sum;\n\nP dp[33][33][33][33];\n\nP div(mat &v, int x, int y, int h, int w) {\n    if (dp[x][y][h][w].first) return dp[x][y][h][w]; \n\n    auto Area = [&]() -> int {\n        int punder = (x > 0 && y > 0) ? v[x - 1][y - 1] : 0;\n        int funder = (x > 0) ? v[x - 1][y + w - 1] : 0;\n        int ptop = (y > 0) ? v[x + h - 1][y - 1] : 0;\n        int ftop = v[x + h - 1][y + w - 1]; \n\n        return ftop - funder - ptop + punder;\n    };\n\n    if (Area() < sum - S) return P(-INF, -INF);\n\n    P res = P(1, S - (sum - Area()));\n\n    auto Max = [&](P p) {\n        if (p.first > res.first) {\n            res.first = p.first;\n            res.second = p.second;\n        } else if (p.first == res.first) {\n           res.second = max(res.second, p.second);\n        }\n    };\n\n    for (int i = 1; i < h; i++) {\n        P p1 = div(v, x, y, i, w);\n        P p2 = div(v, x + i, y, h - i, w);\n\n        if (p1.first <= 0 && p2.first <= 0) continue;\n\n        P tmp = P(p1.first + p2.first, min(p1.second, p2.second));\n        Max(tmp);\n    }\n\n    for (int j = 1; j < w; j++) {\n        P p1 = div(v, x, y, h, j);\n        P p2 = div(v, x, y + j, h, w - j);\n\n        if (p1.first <= 0 && p2.first <= 0) continue;\n\n        P tmp = P(p1.first + p2.first, min(p1.second, p2.second));\n        Max(tmp);\n    }\n\n\n    return dp[x][y][h][w] = res;\n}\n\nvoid solve(mat d) {\n    auto v = d;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int up = i > 0 ? v[i - 1][j] : 0;\n            int left = j > 0 ? v[i][j - 1] : 0;\n            int sub = (i > 0 && j > 0) ? v[i - 1][j - 1] : 0;\n            v[i][j] += up + left - sub;\n        }\n    }\n\n    P res = div(v, 0, 0, H, W);\n\n    cout << res.first << \" \" << res.second << endl;\n}\n\nint main() {\n    while (cin >> H >> W >> S, H || W || S) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        dp[i][j][k][l].first = 0;\n                        dp[i][j][k][l].second = 0;\n                    }\n                }\n            }\n        }\n\n        mat d(H, vec(W));\n        sum = 0;\n        for (auto &v : d) {\n            for (auto &c : v) {\n                cin >> c;\n                sum += c;\n            }\n        }\n\n        solve(d);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <set>\n#include <sys/timeb.h>\n#include <fstream>\n#include <random>\n#include <regex>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\n//#define DEBUG_\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\n\n#ifdef DEBUG_\n#define DEB\n#else\n#define DEB if(false)\n#endif\n\n#ifdef DEBUG_\n#define dump(...) DUMPOUT<<\"  \"; \\\ndump_func(string(#__VA_ARGS__) + \":\", \"[\" + to_string(__LINE__) + \":\" + __FUNCTION__ + \"]\"); \\\nDUMPOUT<<\"    \"; \\\ndump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<Pll> vPll;\ntypedef vector<Pd>vPd;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef vector<vector<vector<ll> > > vvvll;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n\tDUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n\tDUMPOUT << head;\n\tif (sizeof...(Tail) <= 1) {\n\t\tDUMPOUT << \" \";\n\t}\n\telse {\n\t\tDUMPOUT << \", \";\n\t}\n\tdump_func(std::move(tail)...);\n}\n\n// vector\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec) is >> x;\n\treturn is;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// vector\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n\tos << \"{\";\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tos << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// map\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, map<T, U>& map_var) {\n\tos << \"{\";\n\trepi(itr, map_var) {\n\t\tos << \"(\" << itr->first << \",\" << itr->second << \")\";\n\t\titr++;\n\t\tif (itr == map_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// set\ntemplate<typename T>\nostream& operator << (ostream& os, set<T>& set_var) {\n\tos << \"{\";\n\trepi(itr, set_var) {\n\t\tos << \"  \" << *itr << endl;\n\t\titr++;\n\t\tif (itr == set_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\nstring YN(bool y, int id = 0) { if (id)cout << id; return (y ? \"YES\" : \"NO\"); }\nstring yn(bool y, int id = 0) { if (id)cout << id; return (y ? \"Yes\" : \"No\"); }\nstring ON(bool y, int id = 0) { if (id)cout << id; return (y ? \"OK\" : \"NG\"); }\n\nint dir4[4][2] = { { 0,-1 },{ -1,0 },{ 1,0 },{ 0,1 } };\nint dir8[8][2] = { { -1,-1 },{ 0,-1 },{ 1,-1 },{ -1,0 },{ 1,0 },{ -1,1 },{ 0,1 },{ 1,1 } };\n\n// [a,b)\nint irand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_int_distribution<int> dist(a, b - 1);\n\treturn dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_real_distribution<double> dist(a, b);\n\treturn dist(Rand);\n}\nstruct Edge {\n\tint from, to, cost;\n};\nusing Graph = vec<vec<Edge>>;\n\n//======================================================\n\nPi solve(const vvi &ucum, Pi lu, Pi rd, int lack, vec<vec<vvPi>> &memo, int depth = 0) {\n\tif (memo[lu.first][lu.second][rd.first][rd.second] != mp(-2, -2)) {\n\t\treturn memo[lu.first][lu.second][rd.first][rd.second];\n\t}\n\n\tint sum = ucum[rd.first + 1][rd.second + 1] - ucum[rd.first + 1][lu.second] - ucum[lu.first][rd.second + 1] + ucum[lu.first][lu.second];\n\n\t//cerr << string(depth, ' ') << lu << \",\" << rd << \",\" << sum << endl;\n\tif (sum < lack)return memo[lu.first][lu.second][rd.first][rd.second] = mp(-1, -1);\n\tif (sum < lack * 2)return memo[lu.first][lu.second][rd.first][rd.second] = mp(1, sum - lack);\n\n\tPi best = mp(1, sum - lack);\n\trepr(i, lu.first, rd.first) {\n\t\t// 横分割\n\t\tPi res1 = solve(ucum, lu, mp(i, rd.second), lack, memo, depth+1);\n\t\tPi res2 = solve(ucum, mp(i + 1, lu.second), rd, lack, memo, depth+1);\n\t\t//cerr << string(depth, ' ') << lu << \", \" << mp(i, rd.second) << res1 << endl;\n\t\t//cerr << string(depth, ' ') << mp(i + 1, lu.second) << \", \" << rd << res2 << endl;\n\t\tif (res1.first == -1 || res2.first == -1)continue;\n\t\tPi res = mp(res1.first + res2.first, min(res1.second, res2.second));\n\t\tif (res.first > best.first) {\n\t\t\tbest = res;\n\t\t}\n\t\telse if (res.first == best.first && res.second > best.second) {\n\t\t\tbest = res;\n\t\t}\n\t}\n\trepr(j, lu.second, rd.second) {\n\t\t// 縦分割\n\t\tPi res1 = solve(ucum, lu, mp(rd.first, j), lack, memo, depth+1);\n\t\tPi res2 = solve(ucum, mp(lu.first, j + 1), rd, lack, memo, depth+1);\n\t\t//cerr << string(depth, ' ') << lu << \", \" << mp(rd.first, j) << res1 << endl;\n\t\t//cerr << string(depth, ' ') << mp(lu.first, j + 1) << \", \" << rd << res2 << endl;\n\t\tif (res1.first == -1 || res2.first == -1)continue;\n\t\tPi res = mp(res1.first + res2.first, min(res1.second, res2.second));\n\t\tif (res.first > best.first) {\n\t\t\tbest = res;\n\t\t}\n\t\telse if (res.first == best.first && res.second > best.second) {\n\t\t\tbest = res;\n\t\t}\n\t}\n\treturn memo[lu.first][lu.second][rd.first][rd.second] = best;\n}\n\nint main() {\n\twhile (true) {\n\t\tint h, w, s;\n\t\tcin >> h >> w >> s;\n\t\tif (h == 0 && w == 0 && s == 0) break;\n\t\tvvi ucum(h+1, vi(w+1, 0));\n\t\trep(i, h)rep(j, w) {\n\t\t\tcin >> ucum[i + 1][j + 1];\n\t\t}\n\t\trepr(i, 1, h + 1)rep(j, w + 1) {\n\t\t\tucum[i][j] += ucum[i - 1][j];\n\t\t}\n\t\trepr(j, 1, w + 1)rep(i, h + 1) {\n\t\t\tucum[i][j] += ucum[i][j - 1];\n\t\t}\n\t\tint total = ucum[h][w];\n\t\tint lack = total - s;\n\n\t\tvec<vec<vvPi>> memo(h, vec<vvPi>(w, vvPi(h, vPi(w, mp(-2, -2)))));\n\n\t\tPi ans = solve(ucum, mp(0, 0), mp(h - 1, w - 1), lack, memo);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nint sum;\nint gdiv;\nint yobi;\nint h, w, s;\nvector<pair<vvi,int>> cells(1);\nvoid dfs() {\n\tbool divb = false;\n\tREP(i,cells.size()) {\n\t\t//vdiv\n\t\tFOR(j, 1, cells[i].first[0].size()){\n\t\t\tint left = 0;\n\t\t\tint right = 0;\n\t\t\tvvi leftv(cells[i].first.size(),vi(j));\n\t\t\tvvi rightv(cells[i].first.size(), vi(cells[i].first[0].size()-j));\n\t\t\tREP(k, cells[i].first.size()) {\n\t\t\t\tREP(l, cells[i].first[k].size()) {\n\t\t\t\t\tif (l < j) {\n\t\t\t\t\t\tleft += cells[i].first[k][l];\n\t\t\t\t\t\tleftv[k][l]= cells[i].first[k][l];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright += cells[i].first[k][l];\n\t\t\t\t\t\trightv[k][l-j] = cells[i].first[k][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (left < sum - s || right < sum - s)\n\t\t\t\tcontinue;\n\t\t\tdivb = true;\n\t\t\tvector<pair<vvi,int>> copy = cells;\n\t\t\tcells.erase(cells.begin() + i);\n\t\t\tcells.push_back({ leftv,left });\n\t\t\tcells.push_back({ rightv,right });\n\t\t\tdfs();\n\t\t\tcells = copy;\n\t\t}\n\t\t//hdiv\n\t\tFOR(j, 1, cells[i].first.size()) {\n\t\t\tint top = 0;\n\t\t\tint bottom = 0;\n\t\t\tvvi topv(j, vi(cells[i].first[0].size()));\n\t\t\tvvi bottomv(cells[i].first.size()-j, vi(cells[i].first[0].size()));\n\t\t\tREP(k, cells[i].first.size()) {\n\t\t\t\tREP(l, cells[i].first[k].size()) {\n\t\t\t\t\tif (k < j) {\n\t\t\t\t\t\ttop += cells[i].first[k][l];\n\t\t\t\t\t\ttopv[k][l] = cells[i].first[k][l];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbottom += cells[i].first[k][l];\n\t\t\t\t\t\tbottomv[k-j][l] = cells[i].first[k][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (top < sum - s || bottom < sum - s)\n\t\t\t\tcontinue;\n\t\t\tdivb = true;\n\t\t\tvector<pair<vvi, int>> copy = cells;\n\t\t\tcells.erase(cells.begin() + i);\n\t\t\tcells.push_back({ topv,top });\n\t\t\tcells.push_back({ bottomv,bottom });\n\t\t\tdfs();\n\t\t\tcells = copy;\n\t\t}\n\t}\n\tif (!divb) {\n\t\tint mi=1e9;\n\t\tREP(i, cells.size()) {\n\t\t\tif (sum - cells[i].second > s) {\n\t\t\t\tdivb = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmi = min(mi, cells[i].second);\n\t\t}\n\t\tif (divb)\n\t\t\treturn;\n\t\tif (cells.size() > gdiv) {\n\t\t\tgdiv = cells.size();\n\t\t\tyobi = s-(sum - mi);\n\t\t}else if (cells.size() == gdiv) {\n\t\t\tyobi =max(yobi, s - (sum - mi));\n\t\t}\n\n\t}\n}\nint main() {\n\t\n\twhile (cin>>h>>w>>s,h) {\n\t\tsum=0;\n\t\tgdiv = 0;\n\t\tyobi = 0;\n\t\tcells.clear();\n\t\tcells.resize(1);\n\t\tcells[0].first.resize(h, vi(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> cells[0].first[i][j];\n\t\t\t\tsum += cells[0].first[i][j];\n\t\t\t}\n\t\t}\n\t\tcells[0].second = sum;\n\t\tdfs();\n\t\tcout << gdiv << \" \" << yobi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\ntemplate<typename A, size_t N, typename T>\nvoid stfill(A (&arr)[N], const T &val){\n    fill((T*)arr, (T*)(arr+N), val);\n}\n\nint h, w, s, low;\nint u[100][100], su[101][101];\n\nint mm[33][33][33][33][2];\n\nvoid init() {\n    stfill(u, 0);\n    stfill(su, 0);\n    stfill(mm, 0);\n}\n\n// x1 <= x < x2, y1 <= y < y2\nint sum(int y1, int x1, int y2, int x2) {\n    return su[y2][x2] - su[y2][x1] - su[y1][x2] + su[y1][x1];\n}\n\n/**\n * @returns {P} {number of groups, minimum group demand}\n */\nP calc(int y1, int x1, int y2, int x2) {\n    if (mm[y1][x1][y2][x2][0]) {\n        return make_pair(mm[y1][x1][y2][x2][0], mm[y1][x1][y2][x2][1]);\n    }\n\n    int total = sum(y1, x1, y2, x2);\n    if (total < low) {\n        return make_pair(0, 0);\n    }\n    \n    P res = make_pair(1, total);\n    for (int i=y1+1; i<y2; ++i) {\n        P up = calc(y1, x1, i, x2);\n        P down = calc(i, x1, y2, x2);\n        if ( ! up.first || ! down.first) continue;\n        P t = make_pair(up.first + down.first, min(up.second, down.second));\n        res = max(res, t);\n    }\n    for (int i=x1+1; i<x2; ++i) {\n        P left = calc(y1, x1, y2, i);\n        P right = calc(y1, i, y2, x2);\n        if ( ! left.first || ! right.first) continue;\n        P t = make_pair(left.first + right.first, min(left.second, right.second));\n        res = max(res, t);\n    }\n    mm[y1][x1][y2][x2][0] = res.first;\n    mm[y1][x1][y2][x2][1] = res.second;\n    return res;\n}\n\nint main()\n{\n    while (cin >> h >> w >> s) {\n        if ( ! h) break;\n        init();\n        \n        for (int i=0; i<h; ++i) {\n            for (int j=0; j<w; ++j) {\n                cin >> u[i][j];\n            }\n        }\n        for (int i=1; i<=h; ++i) {\n            for (int j=1; j<=w; ++j) {\n                su[i][j] = su[i-1][j] + su[i][j-1] - su[i-1][j-1] + u[i-1][j-1];\n            }\n        }\n        low = sum(0, 0, h, w) - s;\n        \n        P res = calc(0, 0, h, w);\n        cout << res.first << \" \" << res.second - low << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint h, w, s;\n\nconst int MAX_N = 40;\n//const int MAX_P = MAX_N * MAX_N;\n\npair<int, int> dp[MAX_N][MAX_N][MAX_N][MAX_N];\n\n\nvoid cumulativeSum(int s[MAX_N][MAX_N], int h, int w){\n    //?????????????´????(1,1)\n    rep(i,h + 1) rep(j,w + 1) s[i][j + 1] += s[i][j];\n    rep(i,h + 1) rep(j,w + 1) s[i + 1][j] += s[i][j];\n}\n\n//(i,j)????????????(k,l)???????????¨??????????????¢\nint sum(int j, int i, int l, int k, int s[MAX_N][MAX_N]){\n    return s[k][l] - s[i - 1][l] - s[k][j - 1] + s[i - 1][j - 1];\n}\n\npair<int, int> dfs(int lx, int ly, int rx, int ry, int g[MAX_N][MAX_N]){\n    if(dp[ly][lx][ry][rx].first != -1) return dp[ly][lx][ry][rx];\n\n    int total = sum(1,1,w,h,g);\n    pair<int, int> res = make_pair(1, s - (total - sum(lx,ly,rx,ry,g)));\n\n    range(i,ly, ry){\n        if(total - sum(lx,ly,rx,i,g) > s || total - sum(lx,i + 1,rx,ry,g) > s) continue;\n        pair<int, int> a = dfs(lx,ly,rx,i,g);\n        pair<int, int> b = dfs(lx,i + 1,rx,ry,g);\n        pair<int, int> cal = make_pair(a.first + b.first, min(a.second, b.second));\n        res = max(res, cal);\n    }\n\n    range(i,lx, rx){\n        if(total - sum(lx,ly,i,ry,g) > s || total - sum(i + 1,ly,rx,ry,g) > s) continue;\n        pair<int, int> a = dfs(lx,ly,i,ry,g);\n        pair<int, int> b = dfs(i + 1,ly,rx,ry,g);\n        pair<int, int> cal = make_pair(a.first + b.first, min(a.second, b.second));\n        res = max(res, cal);\n    }\n    return dp[ly][lx][ry][rx] = res;\n}\n\nint main(){\n    while(cin >> h >> w >> s, h||w){\n\n        int g[MAX_N][MAX_N] = {0};\n        rep(i,h){\n            rep(j,w){\n                cin >> g[i + 1][j + 1];\n            }\n        }\n\n        rep(i,MAX_N) rep(j,MAX_N) rep(k,MAX_N) rep(l,MAX_N) dp[i][j][k][l] = make_pair(-1,-1);\n        cumulativeSum(g,h,w);\n        //rep(i,h + 1){ rep(j,w + 1){ cout << g[i][j] << ' ' ; } cout << endl; }\n        //    rep(ry,h - 1){\n        //        rep(rx,w - 1){\n        //            range(ly,ry + 1,h){\n        //                range(lx,rx + 1,w){\n        //                    dp[\n        //                }\n        //            }\n        //        }\n        //    }\n        pair<int, int> p = dfs(1,1,w,h,g);\n        cout << p.first << ' ' << p.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define mp make_pair\n\nusing namespace std;\n\nint h, w, s;\nint u[32][32];\nint sm[33][33][33][33];\nint all;\npair<int, int> memo[33][33][33][33];\n\nint calcs(int x1, int y1, int x2, int y2){\n  if(sm[x1][y1][x2][y2]) return sm[x1][y1][x2][y2];\n  if(x1 + 1 == x2 && y1 + 1 == y2)\n    return sm[x1][y1][x2][y2] = u[y1][x1];\n\n  int ret;\n  if(y1 + 1 == y2){\n    ret = calcs(x1, y1, x2 - 1, y2) + calcs(x2 - 1, y1, x2, y2);\n  }else{\n    ret = calcs(x1, y1, x2, y2 - 1) + calcs(x1, y2 - 1, x2, y2);\n  }\n  return sm[x1][y1][x2][y2] = ret;\n}\n\npair<int, int> solve(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2].first != -1)\n    return memo[x1][y1][x2][y2];\n\n  int sum = sm[x1][y1][x2][y2];\n  int tmp = all - sum;\n  pair<int, int> ret;\n  if(tmp <= s) ret = mp(1, s - tmp);\n  else ret = mp(-1, -1);\n\n  for(int xx = x1 + 1; xx < x2; xx++){\n    pair<int, int> r1 = solve(x1, y1, xx, y2);\n    pair<int, int> r2 = solve(xx, y1, x2, y2);\n\n    if(r1.first == -1 || r2.first == -1) continue;\n\n    pair<int, int> r3 = mp(r1.first + r2.first, min(r1.second, r2.second));\n    ret = max(ret, r3);\n  }\n  for(int yy = y1 + 1; yy < y2; yy++){\n    pair<int, int> r1 = solve(x1, y1, x2, yy);\n    pair<int, int> r2 = solve(x1, yy, x2, y2);\n    pair<int, int> r3 = mp(r1.first + r2.first, min(r1.second, r2.second));\n\n    if(r1.first == -1 || r2.first == -1) continue;\n\n    ret = max(ret, r3);\n  }\n\n  return memo[x1][y1][x2][y2] = ret;\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h, &w, &s), h + w + s){\n    REP(i,h) REP(j,w) scanf(\"%d\", &u[i][j]);\n    REP(i,h) REP(j,w)\n      for(int k = i; k < h; k++)\n\tfor(int l = j; l < w; l++)\n\t  sm[j][i][l+1][k+1] = 0;\n\n    REP(i,h) REP(j,w)\n      for(int k = i; k < h; k++)\n\tfor(int l = j; l < w; l++){\n\t  calcs(j, i, l + 1, k + 1);\n\t  memo[j][i][l+1][k+1].first = -1;\n\t}\n    all = sm[0][0][w][h];\n\n    pair<int, int> ret = solve(0, 0, w, h);\n\n    printf(\"%d %d\\n\", ret.first, ret.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint h, w, s;\nint total;\nint field[40][40];\nint cumsum[40][40];\nP memo[40][40][40][40];\nbool visited[40][40][40][40];\n\nP dfs(int sh, int sw, int eh, int ew){\n    if(visited[sh][sw][eh][ew]) return memo[sh][sw][eh][ew];\n    int area = cumsum[eh-1][ew-1];\n    if(0 < sh) area -= cumsum[sh-1][ew-1];\n    if(0 < sw) area -= cumsum[eh-1][sw-1];\n    if(0 < sh && 0 < sw) area += cumsum[sh-1][sw-1];\n\n    int demand = total - area;\n    if(demand > s) return P(-1, -1);\n    P ret(1, s - demand);\n    for(int i=sh+1;i<eh;i++){\n        P res1 = dfs(sh, sw, i, ew), res2 = dfs(i, sw, eh, ew);\n        if(res1.first != -1 && res2.first != -1){\n            P res(res1.first + res2.first, min(res1.second, res2.second));\n            ret = max(ret, res);\n        }\n    }\n    for(int j=sw+1;j<ew;j++){\n        P res1 = dfs(sh, sw, eh, j), res2 = dfs(sh, j, eh, ew);\n        if(res1.first != -1 && res2.first != -1){\n            P res(res1.first + res2.first, min(res1.second, res2.second));\n            ret = max(ret, res);\n        }\n    }\n    visited[sh][sw][eh][ew] = true;\n    memo[sh][sw][eh][ew] = ret;\n    return ret;\n}\n\nint main(){\n    while(true){\n        cin >> h >> w >> s;\n        if(h == 0) break;\n\n        total = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                total += field[i][j];\n            }\n        }\n\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cumsum[i][j] = 0;\n                for(int k=0;k<=i;k++){\n                    for(int l=0;l<=j;l++){\n                        cumsum[i][j] += field[k][l];\n                    }\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        P ans = dfs(0, 0, h, w);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\nint rec[34][34][34][34];\n\nvoid mkRec(){\n\tint i, j;\n\tfor(i = 1; i <= w; i++){\n\t\tfor(j = 1; j <= h; j++){\n\t\t\trec[i][j][i][j] = area[i][j];\n\t\t\tfor(int y = i - 1; y > 0; y--)\n\t\t\t\trec[y][j][i][j] = rec[y + 1][j][i][j] + area[y][j];\n\t\t\tfor(int y = i; y > 0; y--){\n\t\t\t\tint s = 0;\n\t\t\t\tfor(int x = j; x > 0; x--){\n\t\t\t\t\ts += rec[y][x][i][x];\n\t\t\t\t\trec[y][x][i][j] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\npair<int, int> split(int ax, int ay, int bx, int by){\n\tpair<int, int> max_group, group, g1, g2;\n\tint sum_e = 0;\n\tint i, j;\n\t\n\tif(memo[ax][ay][bx][by].first != 0) return memo[ax][ay][bx][by];\n\n\t/*\n\tif(sum - rec[ax][ay][bx][by] > s){\n//\t\tcout << \" :out\" << endl;\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t*/\n\tmax_group.first = 1;\n\tmax_group.second = s - (sum - rec[ax][ay][bx][by]);\n\n\tfor(i = ax; i < bx; i++){\n\t\tif(sum - rec[ax][ay][i][by] > s || \n\t\t   sum - rec[i+1][ay][bx][by] > s) continue;\n\t\tg1 = split(ax, ay, i, by);\n\t\tg2 = split(i + 1, ay, bx, by);\n//\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\tfor(i = ay; i < by; i++){\n\t\tif(sum - rec[ax][ay][bx][i] > s || \n\t\t   sum - rec[ax][i+1][bx][by] > s) continue;\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i + 1, bx, by);\n//\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n//\tcout << ax << \" : \" << ay << \" : \" << bx << \" : \" << by << endl << max_group.first << \" : \" << max_group.second << endl;\n\t\n\treturn memo[ax][ay][bx][by] = max_group;\n}\n\nint main(void){\n\tint i,j;\n\tint group_count;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemset(rec, 0, sizeof(rec));\n\t\tsum = 0;\n\t\tfor(i = 1; i <= w; i++)\n\t\t\tfor(j = 1; j <= h; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n\t\tmkRec();\n\t\tans = split(1, 1, w, h);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 100000000\n#define MOD 1000000007\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\n\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\n\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\t// 幅と高さは入れ替えておく。めんどくさいので。\n\t\tREAD(int, W, H, s);\n\t\tif (!(W | H | s)){ break; }\n\t\tvevector<int> field = read<int>(W, H);\n\n\t\t// 累積地図に変換\n\t\tREP(x, W) field[x].insert(field[x].begin(), 0);\n\t\tfield.insert(field.begin(), vector<int>(H + 1, 0));\n\t\tFOR(x, 1, W + 1) REP(y, H + 1) field[x][y] += field[x - 1][y];\n\t\tREP(x, W + 1) FOR(y, 1, H + 1) field[x][y] += field[x][y - 1];\n\n\t\tint total = field[W][H];\n\t\tint cap = total - s;\n\n\t\t//分割統治 [x][y][w][h]の四角形の中で最大の分割数と予備電力\n\t\tauto memo = vevevevector<pair<int, int>>(W, H, W + 1, H + 1);\n\t\t\n\t\t// 分割統治法で調べる\n\t\tFOR(w, 1, W + 1) FOR(h, 1, H + 1) REP(x, W - w + 1) REP(y, H - h + 1)\n\t\t{\n\t\t\tint t = field[x + w][y + h] - field[x][y + h] - field[x + w][y] + field[x][y];\n\t\t\tauto r = pair<int, int>(t >= cap ? 1 : 0, t - cap);\n\n\t\t\tauto fn = [](pair<int, int> r, const pair<int, int>&s1, const pair<int, int> &s2) -> pair<int, int>\n\t\t\t{\n\t\t\t\tif (s1.first && s2.first)\n\t\t\t\t{\n\t\t\t\t\tif (s1.first + s2.first > r.first) // 分割すべき\n\t\t\t\t\t{\n\t\t\t\t\t\tr.first = s1.first + s2.first;\n\t\t\t\t\t\tr.second = min(s1.second, s2.second);\n\t\t\t\t\t}\n\t\t\t\t\telse if (s1.first + s2.first == r.first) // 分割すべき？\n\t\t\t\t\t{\n\t\t\t\t\t\tr.second = max(r.second, min(s1.second, s2.second));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t};\n\n\t\t\tFOR(sx, 1, w) r = fn(r, memo[x][y][sx][h], memo[x + sx][y][w - sx][h]);\n\t\t\tFOR(sy, 1, h) r = fn(r, memo[x][y][w][sy], memo[x][y + sy][w][h - sy]);\n\n\t\t\tmemo[x][y][w][h] = r;\n\t\t\t//write(vector<int>{x, y, w, h, r.first, r.second});\n\t\t}\n\t\t\n\t\twrite(memo[0][0][W][H].first, memo[0][0][W][H].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef pair<int,int> P;//??°???????????° ?????????\n\nP dp[32][32][32][32];//yl,yr,xl,xr\nint U[32][32];//y,x\nconst P ZERO = P(0,0);\n\nint U_sum[32][32];\n\nint u_min;//??°?????????????¶???????????????????\n\nP f(int yl, int yr, int xl, int xr){//xl<=xr, yl<=yr ???????????§??????????????¨\n    if(dp[yl][yr][xl][xr]!=ZERO){\n        return dp[yl][yr][xl][xr];\n    }\n    if(yl==yr&&xl==xr){\n        return dp[yl][yr][xl][xr]=P(u_min<=U[yl][xl]?1:0,U[yl][xl]);            \n    }\n\n    int max_u=U_sum[yr][xr]-(yl?U_sum[yl-1][xr]:0)-(xl?U_sum[yr][xl-1]:0)+(xl&&yl?U_sum[yl-1][xl-1]:0);\n    int max_d=(u_min<=max_u?1:0);\n\n    //x?????????\n    for(int x=xl;x<xr;x++){\n        P pl=f(yl,yr,xl,x);\n        P pr=f(yl,yr,x+1,xr);\n        if(pl.first&&pr.first){\n            int d=pl.first+pr.first;\n            int u=min(pl.second,pr.second);\n            if(d>max_d){\n                max_d=d;\n                max_u=u;\n            }else if(d==max_d){\n                max_u=max(max_u,u);\n            }\n        }\n    }\n    //y?????????\n    for(int y=yl;y<yr;y++){\n        P pl=f(yl,y,xl,xr);\n        P pr=f(y+1,yr,xl,xr);\n        if(pl.first&&pr.first){\n            int d=pl.first+pr.first;\n            int u=min(pl.second,pr.second);\n            if(d>max_d){\n                max_d=d;\n                max_u=u;\n            }else if(d==max_d){\n                max_u=max(max_u,u);\n            }\n        }\n    }\n    return dp[yl][yr][xl][xr]=P(max_d,max_u);\n}\n\nint main(){\n    int h,w,s;\n    while(cin>>h>>w>>s,h){\n        fill(dp[0][0][0],dp[32][0][0],ZERO);\n        u_min=-s;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>U[i][j];\n                u_min+=U[i][j];\n            }\n        }\n        //?´????????????????\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                U_sum[i][j]=(j?U_sum[i][j-1]:0)+U[i][j];\n            }\n        }\n        for(int i=1;i<h;i++){\n            for(int j=0;j<w;j++){\n                U_sum[i][j]+=U_sum[i-1][j];\n            }\n        }\n        auto p = f(0,h-1,0,w-1);\n        cout<<p.first<<' '<<p.second-u_min<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define num first\n#define energy second\n#define INF (1<<16)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint cum[64][64];\nint H,W,S,sum;\nP dp[40][40][40][40];\n\nint count(int x1,int y1,int x2,int y2){\n  return cum[y2-1][x2-1] - cum[y2-1][x1-1] - cum[y1-1][x2-1] + cum[y1-1][x1-1];\n}\n\nP dfs(int x1, int y1, int x2, int y2){\n  if(~dp[x1][y1][x2][y2].num) return dp[x1][y1][x2][y2];\n  if(cum[H][W] - count(x1,y1,x2,y2) > S) return MP(-INF, INF);\n  P res = P(1, S-(cum[H][W]-count(x1,y1,x2,y2)));\n  for(int i=x1+1;i<x2;i++){\n    P a = dfs(x1, y1, i, y2);\n    P b = dfs(i, y1, x2, y2);\n    P c = P(a.num+b.num, min(a.energy, b.energy));\n    res = max(res, c);\n  }\n  for(int i=y1+1;i<y2;i++){\n    P a = dfs(x1, y1, x2, i);\n    P b = dfs(x1, i, x2, y2);\n    P c = P(a.num+b.num, min(a.energy, b.energy));\n    res = max(res, c);\n  }\n  return dp[x1][y1][x2][y2] = res;\n}\n\n\nint main(){\n  while(scanf(\"%d%d%d\",&H,&W,&S) && H||W||S){\n    memset(cum, 0, sizeof(cum));\n    rep(i,40) rep(j,40) rep(k,40) rep(l,40) dp[i][j][k][l] = MP(-1,-1);\n    rep(i,H) rep(j,W) scanf(\"%d\", &cum[i+1][j+1]);\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cum[i][j] += cum[i][j-1];\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cum[i][j] += cum[i-1][j];\n    sum = cum[H][W];\n\n    P res = dfs(1,1,W+1,H+1);\n    printf(\"%d %d\\n\", res.first, res.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1<<28)\ninline void cmax(int &a, int b) { if (a < b) a = b; }\n\nint n, m, S, f[32][32], _sum[40][40];\n\ninline int sum(int x1, int y1, int x2, int y2) {\n    return _sum[x2+1][y2+1]-_sum[x2+1][y1]-_sum[x1][y2+1]+_sum[x1][y1];\n}\n\nint dp[32][32][32][32];\n\nint solve(int lb) {\n    for (int w = 0; w < n; w++) rep (x1, n-w) {\n        const int x2 = x1+w;\n        for (int h = 0; h < m; h++) rep (y1, m-h) {\n            const int y2 = y1+h;\n            if (sum(x1, y1, x2, y2) < lb) {\n                dp[x1][x2][y1][y2] = -INF;\n                continue;\n            }\n            dp[x1][x2][y1][y2] = 1;\n            for (int i = x1; i < x2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][i][y1][y2]+dp[i+1][x2][y1][y2]);\n            }\n            for (int i = y1; i < y2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][x2][y1][i]+dp[x1][x2][i+1][y2]);\n            }\n        }\n    }\n    return dp[0][n-1][0][m-1];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &n, &m, &S);\n        if (n == 0) return 0;\n        rep (i, n) rep (j, m) scanf(\"%d\", f[i]+j);\n        rep (i, n) rep (j, m) {\n            _sum[i+1][j+1] = f[i][j]+_sum[i+1][j]+_sum[i][j+1]-_sum[i][j];\n        }\n        const int tot = sum(0, 0, n-1, m-1);\n        const int ans = solve(tot-S);\n        int l = 0, r = S+1;\n        while (r-l>1) {\n            const int mid = (l+r) / 2;\n            if (solve(tot-S+mid) >= ans) l = mid;\n            else r = mid;\n        }\n        printf(\"%d %d\\n\", ans, l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint h, w, s, sum;\npii dp[50][50][50][50];\nint fld[50][50];\n\npii solve(int lx, int ly, int rx, int ry)\n{\n\tif (dp[lx][ly][rx][ry].first >= 0) return dp[lx][ly][rx][ry];\n\tint cnt = 0;\n\tFOR(i, lx, rx)FOR(j, ly, ry) cnt += fld[i][j];\n\tif (cnt<sum - s) return dp[lx][ly][rx][ry] = pii(-INF, -INF);\n\tpii res = pii(1, cnt);\n\tif (rx - lx > 1)\n\t{\n\t\tFOR(i, lx+1, rx)\n\t\t{\n\t\t\tpii tmp;\n\t\t\tpii a = solve(lx, ly, i, ry);\n\t\t\tpii b = solve(i, ly, rx, ry);\n\t\t\ttmp.first = a.first + b.first;\n\t\t\ttmp.second = min(a.second, b.second);\n\t\t\tif (res.first < tmp.first || (res.first == tmp.first&&res.second<tmp.second)) res = tmp;\n\t\t}\n\t}\n\tif (ry - ly > 1)\n\t{\n\t\tFOR(i, ly+1, ry)\n\t\t{\n\t\t\tpii tmp;\n\t\t\tpii a = solve(lx, ly, rx, i);\n\t\t\tpii b = solve(lx, i, rx, ry);\n\t\t\ttmp.first = a.first + b.first;\n\t\t\ttmp.second = min(a.second, b.second);\n\t\t\tif (res.first < tmp.first || (res.first == tmp.first&&res.second<tmp.second)) res = tmp;\n\t\t}\n\t}\n\treturn dp[lx][ly][rx][ry] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> s, h)\n\t{\n\t\tsum = 0;\n\t\tREP(i, 50)REP(j, 50)REP(k, 50)REP(l, 50) dp[i][j][k][l] = pii(-1, -1);\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tcin >> fld[i][j];\n\t\t\tsum += fld[i][j];\n\t\t}\n\t\tpii ans = solve(0, 0, h, w);\n\t\tcout << ans.first <<\" \"<< ans.second - (sum - s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\n#define group first\n#define power second\n\nusing namespace std;\n\nconst int MAX = 33;\nconst int NONE = -1;\n\nint h, w, s;\nint total_demand;\nvector<vector<int>> town;\nvector<vector<int>> sum;\npair<int, int> memo[MAX][MAX][MAX][MAX]; //<??°???????????°, ?????????>\n\n\nint calc(int x1, int x2, int y1, int y2) {\n\t// ??¨?????¢????????????????±???????\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\npair<int, int> update(pair<int, int> a, pair<int, int> b, pair<int, int> res) {\n\tpair<int, int> tmp = {a.group + b.group, min(a.power, b.power)};\n\treturn max(res, tmp);\n}\n\npair<int, int> dfs(int sx, int ex, int sy, int ey) {\n\tif(memo[sx][ex][sy][ey].group != NONE) return memo[sx][ex][sy][ey];\n\tint demand = calc(sx, ex, sy, ey);\n\tif(total_demand - demand > s) {\n\t\tmemo[sx][ex][sy][ey] = {0, 0};\n\t\treturn memo[sx][ex][sy][ey];\n\t}\n\tpair<int, int> res = make_pair(1, s - (total_demand - demand));\n\tfor(int x = sx+1; x < ex; ++x) {\n\t\t//?????????\n\t\tpair<int, int> a = dfs(x, ex, sy, ey), b = dfs(sx, x, sy, ey);\n\t\tif(a.group == 0 || b.group == 0) continue;\n\t\tres = update(a, b, res);\n\t}\n\t\n\tfor(int y = sy+1; y < ey; ++y) {\n\t\t//?¨???????\n\t\tpair<int, int> a = dfs(sx, ex, sy, y), b = dfs(sx, ex, y, ey);\n\t\tif(a.group == 0 || b.group == 0) continue;\n\t\tres = update(a, b, res);\n\t}\n\t\n\tmemo[sx][ex][sy][ey] = res;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> h >> w >> s, h) {\n\t\ttown.assign(h, vector<int>(w, 0));\n\t\tsum.assign(h+1, vector<int>(w+1, 0));\t\n\t\ttotal_demand = 0;\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> town[y][x];\n\t\t\t\ttotal_demand += town[y][x];\n\t\t\t}\n\t\t}\n\t\tfill_n((pair<int, int>*)memo, MAX*MAX*MAX*MAX, make_pair(NONE, NONE));\n\n\t\tfor(int y = 1; y <= h; ++y) {\n\t\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\t\tsum[y][x] = sum[y][x-1] + sum[y-1][x] - sum[y-1][x-1] + town[y-1][x-1];\n\t\t\t}\n\t\t}\n\n\t\tpair<int, int> ans = dfs(0, w, 0, h);\n\t\tcout << ans.group << \" \" << ans.power << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nconst int MAXH = 33;\nconst int MAXW = 33;\nint h, w, s, t, all;\nint u[MAXH][MAXW];\nPair mem[MAXW][MAXH][MAXW][MAXH];\nint S[MAXH][MAXW];\n\nint sum(int x1, int y1, int x2, int y2) {\n  return S[y2][x2] - S[y2][x1] - S[y1][x2] + S[y1][x1];\n}\n\nPair rec(int x1, int y1, int x2, int y2) {\n  Pair &res = mem[x1][y1][x2][y2];\n  if (res.first != -1) return res;\n  res = Pair(1, sum(x1, y1, x2, y2));\n  for (int i = x1+1; i < x2; ++i) {\n    if (all - sum(x1, y1, i, y2) <= s &&\n        all - sum(i, y1, x2, y2) <= s) {\n      Pair p = rec(x1, y1, i, y2);\n      Pair q = rec(i, y1, x2, y2);\n      Pair v(p.first + q.first, min(p.second, q.second));\n      if (res < v) res = v;\n    }\n  }\n  for (int i = y1+1; i < y2; ++i) {\n    if (all - sum(x1, y1, x2, i) <= s &&\n        all - sum(x1, i, x2, y2) <= s) {\n      Pair p = rec(x1, y1, x2, i);\n      Pair q = rec(x1, i, x2, y2);\n      Pair v(p.first + q.first, min(p.second, q.second));\n      if (res < v) res = v;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (cin >> h >> w >> s && (h|w|s)) {\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> u[i][j];\n      }\n    }\n\n    memset(S, 0, sizeof(S));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        S[i+1][j+1] += S[i+1][j] + u[i][j];\n      }\n    }\n    for (int j = 0; j < w; ++j) {\n      for (int i = 0; i < h; ++i) {\n        S[i+1][j+1] += S[i][j+1];\n      }\n    }\n\n    all = sum(0, 0, w, h);\n    fill(mem[0][0][0], mem[MAXW][0][0], Pair(-1, -1));\n    Pair res = rec(0, 0, w, h);\n    cout << res.first << \" \" << s - all + res.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n\ntypedef pair<int,int> P;\n\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\nint rec[34][34][34][34];\n\n\nint count(int ax, int ay, int bx, int by){\n\tint i, j, sum_c = 0;\n\tif(rec[ax][ay][bx][by] != 0) return rec[ax][ay][bx][by];\n\tfor(i = ax; i <= bx; i++){\n\t\tfor(j = ay; j <= by; j++){\n\t\t\tsum_c += area[i][j];\n\t\t}\n\t}\n\treturn rec[ax][ay][bx][by] = sum_c;\n}\n\n\nP split(int ax, int ay, int bx, int by){\n\tP max_group, group, g1, g2;\n\tint sum_e = 0;\n\tint i, j;\t\n//\tcout << ax << ay << bx << by << endl;\n\tif(memo[ax][ay][bx][by].first != 0) return memo[ax][ay][bx][by];\n\tmax_group = P(1, s - (sum - count(ax,ay,bx,by)));\n//cout << \" :\" << max_group.second << endl;\n\tfor(i = ay; i < by; i++){\n\t\tif(sum - count(ax,ay,bx,i)\t> s || \n\t\t   sum - count(ax,i+1,bx,by) > s) continue;\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i+1, bx, by);\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\tfor(j = ax; j < bx; j++){\n\t\tif(sum - count(ax, ay, j, by) > s || \n\t\t   sum - count(j + 1, ay, bx, by) > s) continue;\n\t\tg1 = split(ax, ay, j, by);\n\t\tg2 = split(j + 1, ay, bx, by);\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n//\tcout << ax << ay << bx << by << endl;\n//\tcout << max_group.first << \" : \" << max_group.second << endl << endl;\n\treturn memo[ax][ay][bx][by] = max_group;\n}\n\n\nint main(void){\n\tint i,j;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemset(rec, 0, sizeof(rec));\n\t\tsum = 0;\n\t\tfor(i = 1; i <= w; i++){\n\t\t\tfor(j = 1; j <= h; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n\t\t}\n\t\tans = split(1, 1, w, h);\n\t\tcout << ans.first << \" \" << ans.second << endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define f first\n#define s second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h,w,s,u[34][34];\nP memo[34][34][34][34];\n\nP rec(int x1,int y1,int x2,int y2){\n\t\n\tP a,b,res;\n\t\n\tif(memo[x1][y1][x2][y2]!=P(0,INF))return memo[x1][y1][x2][y2];\n\t\n\tif(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])>s)return P(0,INF);\n\t\n\tres=P(1,s-(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])));\n\t\n\tfor(int i=y1+1;i<y2;i++){\n\t\ta=rec(x1,y1,x2,i);\n\t\tb=rec(x1,i,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\tfor(int i=x1+1;i<x2;i++){\n\t\ta=rec(x1,y1,i,y2);\n\t\tb=rec(i,y1,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\treturn memo[x1][y1][x2][y2]=res;\n}\n\nint main(void){\n\t\n\twhile(cin >> h >> w >> s,h|w|s){\n\t\t\n\t\th++,w++;\n\t\tfill(u[0],u[33],0);\n\t\t\n\t\tfor(int i=0;i<34;i++)\n\t\t\tfor(int j=0;j<34;j++)\n\t\t\t\tfor(int k=0;k<34;k++)\n\t\t\t\t\tfor(int l=0;l<34;l++)memo[i][j][k][l]=P(0,INF);\n\t\t\n\t\tfor(int i=1;i<h;i++)\n\t\t\tfor(int j=1;j<w;j++)cin >> u[i][j];\n\t\t\n\t\tfor(int i=1;i<h;i++)\n\t\t\tfor(int j=1;j<w;j++)\n\t\t\t\tu[i][j]+=u[i-1][j]+u[i][j-1]-u[i-1][j-1];\n\t\t\n\t\tP ans=rec(1,1,w,h);\n\t\tcout << ans.f << \" \" << ans.s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i =0;i<n;++i)\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define FOR(it,a ) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntypedef pair<int,int> PI;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\n\nint h,w,s;\nint u[100][100];\n\nint sum[100][100];\n\nPI memo[50][50][50][50];//group, yobi\n\nPI rec(int x1,int y1,int x2,int y2){\n  auto&  ans =memo[x1][y1][x2][y2];\n  if(ans.F>=0)  return ans;\n  //ans = mp(-1,0);\n  int su =sum[x2][y2]-sum[x2][y1]-sum[x1][y2]+sum[x1][y1];\n  int all = sum[h][w];\n  int saiju = all - su;\n  if(saiju <= s)\n    ans=mp(1,s-saiju);\n  \n  for(int x=x1+1;x<x2;++x){\n    auto p = rec(x1,y1,x,y2);\n    auto p2 = rec(x,y1,x2,y2);\n    ans=max(ans,mp(p.F+p2.F,min(p.S,p2.S)));\n  }\n  \n  for(int y=y1+1;y<y2;++y){\n    auto p = rec(x1,y1,x2,y);\n    auto p2 = rec(x1,y,x2,y2);\n    ans=max(ans,mp(p.F+p2.F,min(p.S,p2.S)));\n  }\n  \n  //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << ans.F << \" \" << ans.S << endl;\n  return ans;\n}\n\nvoid solve(){\n  rep(i,h)rep(j,w) cin >> u[i][j];\n  rep(i,h)rep(j,w)\n    sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] + u[i][j] - sum[i][j];\n  //cout << sum[h][w] << endl;\n  memset(memo,-1,sizeof(memo));\n  auto ans = rec(0,0,h,w);\n  cout << ans.F << \" \" << ans.S << endl;\n  //cout << rec(0,0,h,w) << endl;\n}\n\n\nint main(){\n  while(cin >>h  >> w>>s,h) solve();  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, S;\nvector< vector<int> > A;\nbool m1[40][40][40][40];\nP m2[40][40][40][40];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, S-(getM(0, 0, W, H) - getM(x1, y1, x2, y2)));\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tif (a1.first < 0 || a2.first < 0) continue;\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tif (a1.first < 0 || a2.first < 0) continue;\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> S, H || W || S) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[39][39][40], false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nint h, w, s;\n\nP solve(int x1, int y1, int x2, int y2, vector<vector<vector<vector<P>>>>& dp, vector<vector<int>> const& acc, int const sum) {\n    P& r = dp[x1][y1][x2][y2];\n    if(r != P{0, 0}) {\n        return r;\n    }\n    int t = acc[y2][x2] - acc[y1][x2] - acc[y2][x1] + acc[y1][x1];\n    if(sum - t > s) {\n        r = make_pair(-1, -1);\n    } else {\n        r = make_pair(1, s - (sum - t));\n    }\n    for(int i=x1+1; i<x2; ++i) {\n        auto c1 = solve(x1, y1, i, y2, dp, acc, sum);\n        auto c2 = solve(i, y1, x2, y2, dp, acc, sum);\n        if(c1.first == 0 || c2.first == 0) {\n            continue;\n        }\n        if(c1.first + c2.first > r.first) {\n            r.first = c1.first + c2.first;\n            r.second = min(c1.second, c2.second);\n        } else if(c1.first + c2.first == r.first) {\n            r.second = max(r.second, min(c1.second, c2.second));\n        }\n    }\n    for(int i=y1+1; i<y2; ++i) {\n        auto c1 = solve(x1, y1, x2, i, dp, acc, sum);\n        auto c2 = solve(x1, i, x2, y2, dp, acc, sum);\n        if(c1.first == 0 || c2.first == 0) {\n            continue;\n        }\n        if(c1.first + c2.first > r.first) {\n            r.first = c1.first + c2.first;\n            r.second = min(c1.second, c2.second);\n        } else if(c1.first + c2.first == r.first) {\n            r.second = max(r.second, min(c1.second, c2.second));\n        }\n    }\n    return r;\n}\n\n\n\nint main() {\n    while(cin >> h >> w >> s, h) {\n        vector<vector<int>> v(h, vector<int>(w));\n        vector<vector<int>> acc(h+1, vector<int>(w+1));\n        vector<vector<vector<vector<P>>>> dp(w+1, vector<vector<vector<P>>>(h+1, vector<vector<P>>(w+1, vector<P>(h+1))));\n        int sum = 0;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                int u; cin >> u;\n                //cin >> v[i][j];\n                sum += u;\n                acc[i+1][j+1] = u;\n            }\n        }\n        for(int i=1; i<=h; ++i) {\n            for(int j=0; j<w; ++j) {\n                acc[i][j+1] += acc[i][j];\n            }\n        }\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<=w; ++j) {\n                acc[i+1][j] += acc[i][j];\n            }\n        }\n        \n        auto res = solve(0, 0, w, h, dp, acc, sum);\n        cout << res.first << \" \" << res.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint H, W, S, U[32][32], L;\nint sm[64][64], dp[32][32][32][32], memo[32][32][32][32];\n\ninline void cmax(int& a, int b) { if(a<b) a = b; }\n\ninline int sum(int i, int j, int l, int r) {\n    return sm[j+1][r+1]-sm[i][r+1]-sm[j+1][l]+sm[i][l];\n}\n\nint rec(int i, int j, int l, int r) {\n    if(dp[i][j][l][r]==1) return sum(i, j, l, r)-L;\n    if(memo[i][j][l][r]!=-1) return memo[i][j][l][r];\n    int ans = 0;\n    for(int a=l; a<r; a++) if(dp[i][j][l][a] && dp[i][j][a+1][r]) {\n        if(dp[i][j][l][r]==dp[i][j][l][a]+dp[i][j][a+1][r]) {\n            cmax(ans, min(rec(i, j, l, a), rec(i, j, a+1, r)));\n        }\n    }\n    for(int a=i; a<j; a++) if(dp[i][a][l][r] && dp[a+1][j][l][r]) {\n        if(dp[i][j][l][r]==dp[i][a][l][r]+dp[a+1][j][l][r]) {\n            cmax(ans, min(rec(i, a, l, r), rec(a+1, j, l, r)));\n        }\n    }\n    return memo[i][j][l][r] = ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d%d\", &H, &W, &S);\n        if(H==0 && W==0 && S==0) return 0;\n        rep(i, H) rep(j, W) scanf(\"%d\", U[i]+j);\n        rep(i, H) rep(j, W) {\n            sm[i+1][j+1] = U[i][j]-sm[i][j]+sm[i][j+1]+sm[i+1][j];\n        }\n        L = sm[H][W]-S;\n        rep(h, H) rep(i, H-h) {\n            const int j = i+h;\n            rep(w, W) rep(l, W-w) {\n                const int r = l+w;\n                dp[i][j][l][r] = sum(i, j, l, r)>=L;\n                for(int a=l; a<r; a++) if(dp[i][j][l][a] && dp[i][j][a+1][r]) {\n                    cmax(dp[i][j][l][r], dp[i][j][l][a]+dp[i][j][a+1][r]);\n                }\n                for(int a=i; a<j; a++) if(dp[i][a][l][r] && dp[a+1][j][l][r]) {\n                    cmax(dp[i][j][l][r], dp[i][a][l][r]+dp[a+1][j][l][r]);\n                }\n            }\n        }\n        memset(memo, -1, sizeof(memo));\n        printf(\"%d %d\\n\", dp[0][H-1][0][W-1], rec(0, H-1, 0, W-1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 32\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint H, W, S, sum;\nint u[MAX][MAX];\npii memo[MAX][MAX][MAX][MAX];\n\nint get_cost(int h1, int w1, int h2, int w2)\n{\n    int cost = 0;\n    for (int i = h1; i <= h2; i++) {\n        for (int j = w1; j <= w2; j++) {\n            cost += u[i][j];\n        }\n    }\n    return cost;\n}\n\npii solve(int h1, int w1, int h2, int w2)    \n{\n    pii res = memo[h1][w1][h2][w2];\n    if (res.first != -1) {\n        return res;\n    }\n    \n    res = pii(1, S - (sum - get_cost(h1, w1, h2, w2)));\n    for (int i = h1; i <= h2-1; i++) {\n        int c1 = get_cost(h1, w1, i, w2);\n        int c2 = get_cost(i+1, w1, h2, w2);\n        \n        if (sum - c1 <= S && sum - c2 <= S) {\n            pii n1 = solve(h1, w1, i, w2);\n            pii n2 = solve(i+1, w1, h2, w2);\n            pii n = pii(n1.first + n2.first, min(n1.second, n2.second));\n            res = max(res, n);\n        }        \n    }\n\n    for (int i = w1; i <= w2-1; i++) {\n        int c1 = get_cost(h1, w1, h2, i);\n        int c2 = get_cost(h1, i+1, h2, w2);\n        \n        if (sum - c1 <= S && sum - c2 <= S) {\n            pii n1 = solve(h1, w1, h2, i);\n            pii n2 = solve(h1, i+1, h2, w2);\n            pii n = pii(n1.first + n2.first, min(n1.second, n2.second));\n            res = max(res, n);\n        } \n    }\n    return memo[h1][w1][h2][w2] = res;\n}\n\nint main()\n{\n    while (cin >> H >> W >> S, H) {\n        sum = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> u[i][j];\n                sum += u[i][j];\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        memo[i][j][k][l] = pii(-1, -1);\n                    }\n                }\n            }\n        }\n        \n        pii res = solve(0, 0, H-1, W-1);\n        cout << res.first << \" \" << res.second << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nbool vis[40][40][40][40];\nPI memo[40][40][40][40];\nint sum[40][40];\nint in[40][40];\nint h,w,s;\n\nint su(int x1,int y1,int x2,int y2){\n  return\n    sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1];\n}\n\nPI rec(int x1,int y1,int x2,int y2){\n  if(vis[x1][y1][x2][y2])\n    return memo[x1][y1][x2][y2];\n  vis[x1][y1][x2][y2]=true;\n  int all=su(0,0,h,w);  \n  PI &ret=memo[x1][y1][x2][y2]=mp(1,s-(all-su(x1,y1,x2,y2)));\n\n  for(int x=x1+1;x<x2;++x){\n    if(all-su(x1,y1,x,y2)>s) continue;\n    if(all-su(x,y1,x2,y2)>s) continue;\n    PI a(rec(x1,y1,x,y2));\n    PI b(rec(x,y1,x2,y2));\n    ret=max(ret,mp(a.F+b.F,min(a.S,b.S)));\n  }\n\n  for(int y=y1+1;y<y2;++y){\n    if(all-su(x1,y1,x2,y)>s) continue;\n    if(all-su(x1,y,x2,y2)>s) continue;    \n    PI a(rec(x1,y1,x2,y));\n    PI b(rec(x1,y,x2,y2));\n    ret=max(ret,mp(a.F+b.F,min(a.S,b.S)));    \n  }\n  //cout << x1 << ' ' << y1 << ' ' << x2 << ' ' << y2 << ' ' << ret.F << ' ' << ret.S << endl;\n  return ret;\n}\n\nvoid solve(){\n  rep(i,h)rep(j,w) cin >> in[i][j];\n  rep(i,h)rep(j,w)\n    sum[i+1][j+1]=sum[i+1][j]+sum[i][j+1]-sum[i][j]+in[i][j];\n  CLR(vis);\n  PI ans(rec(0,0,h,w));\n  cout << ans.F <<  ' ' << ans.S << endl;\n}\n\nint main(){\n  while(cin >> h >> w >> s && h) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, s;\nint sumMin;\t\t//??°?????????????????????\nint u[32][32];\nint ru[33][33];\nP dp[33][33][33][33];\n\nint yobi(int ly, int lx, int ry, int rx) {\n\treturn ru[ry][rx] - ru[ry][lx] - ru[ly][rx] + ru[ly][lx] - sumMin;\n}\n\nP dfs(int ly, int lx, int ry, int rx) {\n\tif (dp[ly][lx][ry][rx].first != -1) {\n\t\treturn dp[ly][lx][ry][rx];\n\t}\n\t\n\tP ret = P(1, yobi(ly, lx, ry, rx));\n\t\n\t//[ly, y), [y, ry)\n\tfor (int y = ly + 1; y < ry; y++) {\n\t\tif (yobi(ly, lx, y, rx) >= 0 && yobi(y, lx, ry, rx) >= 0) {\n\t\t\tP res1 = dfs(ly, lx, y, rx);\n\t\t\tP res2 = dfs(y, lx, ry, rx);\n\t\t\t\n\t\t\tif (ret.first < res1.first + res2.first || (ret.first == res1.first + res2.first && ret.second < min(res1.second, res2.second))) {\n\t\t\t\tret.first = res1.first + res2.first;\n\t\t\t\tret.second = min(res1.second, res2.second);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = lx + 1; x < rx; x++) {\n\t\tif (yobi(ly, lx, ry, x) >= 0 && yobi(ly, x, ry, rx) >= 0) {\n\t\t\tP res1 = dfs(ly, lx, ry, x);\n\t\t\tP res2 = dfs(ly, x, ry, rx);\n\t\t\t\n\t\t\tif (ret.first < res1.first + res2.first || (ret.first == res1.first + res2.first && ret.second < min(res1.second, res2.second))) {\n\t\t\t\tret.first = res1.first + res2.first;\n\t\t\t\tret.second = min(res1.second, res2.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[ly][lx][ry][rx] = ret;\n}\n\nint main() {\n\twhile (cin >> h >> w >> s) {\n\t\tif (!h) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tru[i + 1][j + 1] = u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tru[i][j] += ru[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tru[i][j] += ru[i - 1][j];\n\t\t\t}\n\t\t}\n\t\tsumMin = ru[h][w] - s;\n\t\t\n\t\tfor (int i = 0; i <= h; i++) for (int j = 0; j <= w; j++) for (int k = 0; k <= h; k++) for (int l = 0; l <= w; l++) dp[i][j][k][l].first = -1;\n\t\tP ans = dfs(0, 0, h, w);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\npair<int, int> dp[35][35][35][35];\nbool checked[35][35][35][35];\n\nint solve_testcase() {\n    int H, W, S; scanf(\"%d%d%d\", &H, &W, &S);\n    if(H == 0 and W == 0 and S == 0) return 1;\n\n    int U[35][35] = {}, sum = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            scanf(\"%d\", &U[i+1][j+1]);\n            sum += U[i+1][j+1];\n            U[i+1][j+1] += U[i][j+1] + U[i+1][j] - U[i][j];\n        }\n    }\n\n    const pair<int, int> NIL(-1, -1);\n    fill(dp[0][0][0], dp[H][0][0], NIL);\n    fill(checked[0][0][0], checked[H][0][0], false);\n    auto dfs = [&](auto &&self, int lx, int rx, int ly, int ry)\n        -> pair<int, int> {\n        if(checked[lx][rx][ly][ry]) return dp[lx][rx][ly][ry];\n        checked[lx][rx][ly][ry] = true;\n        \n        pair<int, int> res = NIL;\n        int rect_sum = U[rx][ry] - U[lx][ry] - U[rx][ly] + U[lx][ly];\n        if(sum - rect_sum <= S) {\n            res = make_pair(1, rect_sum);\n        }\n        for(int x=lx+1; x<rx; x++) {\n            auto z0 = self(self, lx, x, ly, ry);\n            auto z1 = self(self, x, rx, ly, ry);\n            if(z0 == NIL or z1 == NIL) continue;\n            pair<int, int> cand(z0.first + z1.first, min(z0.second, z1.second));\n            chmax(res, cand);\n        }\n        for(int y=ly+1; y<ry; y++) {\n            auto z0 = self(self, lx, rx, ly, y);\n            auto z1 = self(self, lx, rx, y, ry);\n            if(z0 == NIL or z1 == NIL) continue;\n            pair<int, int> cand(z0.first + z1.first, min(z0.second, z1.second));\n            chmax(res, cand);\n        }\n        return dp[lx][rx][ly][ry] = res;\n    };\n\n    auto ans = dfs(dfs, 0, H, 0, W);\n    printf(\"%d %d\\n\", ans.first, S - (sum - ans.second));\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int > P;\nvector<vector<int> > ita(32, vector<int>(32, 0));\nvector<vector<int> > itasum(33, vector<int>(33, 0));\nvector<vector<vector<vector<P > > > > dp(33, vector<vector<vector<P > > >(33, vector<vector<P > >(33, vector<P >(33, P(-1, -1)))));\nP cut(int, int, int, int);\nint over;\n\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 33; i++) {\n\t\t\tfor (int j = 0; j < 33; j++) {\n\t\t\t\tfor (int k = 0; k < 33; k++) {\n\t\t\t\t\tfor (int l = 0; l < 33; l++) {\n\t\t\t\t\t\tdp[i][j][k][l] = P(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint h, w, s;\n\t\tcin >> h >> w >> s;\n\t\tif (h == 0)return 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> ita[i][j];\n\t\t\t\tsum += ita[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 33; i++) {\n\t\t\titasum[i][0] = 0;\n\t\t\titasum[0][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tint r = 0;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k <= i; k++) {\n\t\t\t\t\tr += ita[k][j];\n\t\t\t\t}\n\t\t\t\titasum[i+1][j+1] = r;\n\t\t\t\t//cout << r << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\n\t\tover = sum - s;\n\t\t//cout << over << endl;\n\t\tP cutnum = cut(0, 0, h, w);\n\t\tcout << cutnum.first <<\" \"<< cutnum.second << endl;\n\t}\n}\n\n\nP cut(int sx, int sy, int ex, int ey) {\n\tP empty = make_pair(-1, -1);\n\tif (dp[sx][sy][ex][ey] != empty)return dp[sx][sy][ex][ey];\n\tif (itasum[ex][ey] - itasum[sx][ey] - itasum[ex][sy] + itasum[sx][sy] < over)return P(0,0);\n\tvector<P> sol;\n\tsol.push_back(P(0, 0));\n\tfor (int i = sx + 1; i < ex; i++) {\n\t\tP P1 = cut(sx, sy, i, ey);\n\t\tP P2 = cut(i, sy, ex, ey);\n\t\tif (P1.first == 0 || P2.first == 0) { \n\t\t\tsol.push_back(P(0, 0)); \n\t\t}else {\n\t\t\tP p = make_pair(P1.first + P2.first, min(P1.second, P2.second));\n\t\t\tsol.push_back(p);\n\t\t}\n\t}\n\tfor (int i = sy + 1; i < ey; i++) {\n\t\tP P1 = cut(sx, sy,ex, i);\n\t\tP P2 = cut(sx, i, ex, ey);\n\t\tif (P1.first == 0 || P2.first == 0) { \n\t\t\tsol.push_back(P(0, 0)); \n\t\t}else {\n\t\t\tP p = make_pair(P1.first + P2.first, min(P1.second, P2.second));\n\t\t\tsol.push_back(p);\n\t\t}\n\t}\n\tsort(sol.begin(), sol.end());\n\tif (sol.back().first == 0) {\n\t\tdp[sx][sy][ex][ey] = P(1, itasum[ex][ey] - itasum[sx][ey] - itasum[ex][sy] + itasum[sx][sy]-over);\n\t\treturn P(1, itasum[ex][ey] - itasum[sx][ey] - itasum[ex][sy] + itasum[sx][sy]-over);\n\t}\n\tdp[sx][sy][ex][ey] = sol.back();\n\t//cout << sx << \" \" ;\n\treturn sol.back();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf (int)(1e9)\n\nint A[33][33];\npair<int, int> dp[33][33][33][33];\nint u[33][33];\nint visit[33][33][33][33];\nint s;\n\nint sum(int x, int y){\n  if(x < 0 || y < 0){\n    return 0;\n  }\n  else{\n    return A[x][y];\n  }\n}\n\nint sum(int x1, int y1, int x2, int y2){\n  return sum(x2 - 1, y2 - 1) - sum(x1 - 1, y2 - 1) - sum(x2 - 1, y1 - 1) + sum(x1 - 1, y1 - 1);\n}\n\npair<int, int> solve(int x1, int y1, int x2, int y2){\n//  printf(\"solve(%d, %d, %d, %d)\\n\", x1, y1, x2, y2);\n  if(visit[x1][y1][x2][y2] == 1){\n    return dp[x1][y1][x2][y2];\n  }\n  visit[x1][y1][x2][y2] = 1;\n  int i, j;\n  pair<int, int> ans(-1, inf), res1, res2;\n  if(sum(x1, y1, x2, y2) >= s){\n    ans = pair<int, int>(1, sum(x1, y1, x2, y2));\n  }\n//  printf(\"ini_ans = (%d, %d)\\n\", ans.first, ans.second);\n  for(i = x1 + 1; i < x2; i++){\n    res1 = solve(x1, y1, i, y2);\n    res2 = solve(i, y1, x2, y2);\n    if(res1.first < 0 || res2.first < 0){\n      continue;\n    }\n    if(ans.first < res1.first + res2.first){\n      ans = pair<int, int>(res1.first + res2.first, min(res1.second, res2.second));\n    }\n    else if(ans.first == res1.first + res2.first){\n      ans.second = max(ans.second, min(res1.second, res2.second));\n    }\n  }\n  for(j = y1 + 1; j < y2; j++){\n    res1 = solve(x1, y1, x2, j);\n    res2 = solve(x1, j, x2, y2);\n    if(res1.first < 0 || res2.first < 0){\n      continue;\n    }\n    if(ans.first < res1.first + res2.first){\n      ans = pair<int, int>(res1.first + res2.first, min(res1.second, res2.second));\n    }\n    else if(ans.first == res1.first + res2.first){\n      ans.second = max(ans.second, min(res1.second, res2.second));\n    }\n  }\n  dp[x1][y1][x2][y2] = ans;\n//  printf(\"dp[%d][%d][%d][%d] = (%d, %d)\\n\", x1, y1, x2, y2, ans.first, ans.second);\n  return ans;\n}\n\nint main(){\n  while(1){\n    int H, W, i, j, k, l;\n    scanf(\"%d%d%d\", &H, &W, &s);\n    if(H == 0){\n      return 0;\n    }\n    s = -s;\n    for(i = 0; i < H; i++){\n      for(j = 0; j < W; j++){\n        scanf(\"%d\", &u[i][j]);\n        s += u[i][j];\n      }\n    }\n//    printf(\"s = %d\\n\", s);\n    for(i = 0; i < H; i++){\n      for(j = 0; j < W; j++){\n        if(i == 0 && j == 0){\n          A[i][j] = u[i][j];\n        }\n        else if(i == 0){\n          A[i][j] = A[i][j - 1] + u[i][j];\n        }\n        else if(j == 0){\n          A[i][j] = A[i - 1][j] + u[i][j];\n        }\n        else{\n          A[i][j] = A[i - 1][j] + A[i][j - 1] - A[i - 1][j - 1] + u[i][j];\n        }\n      }\n    }\n    for(i = 0; i <= H; i++){\n      for(j = 0; j <= W; j++){\n        for(k = 0; k <= H; k++){\n          for(l = 0; l <= W; l++){\n            dp[i][j][k][l] = pair<int, int>(-1, inf);\n            visit[i][j][k][l] = 0;\n          }\n        }\n      }\n    }\n    pair<int, int> ans = solve(0, 0, H, W);\n    printf(\"%d %d\\n\", ans.first, ans.second - s);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INF = 1001001001;\n\nint dev[32][32][33][33];\nint sup[32][32][33][33];\n\nint main()\n{\n\tint h, w, s;\n\twhile(scanf(\"%d%d%d\", &h, &w, &s), h){\n\t\tint d[32][32];\n\t\trep(i, h) rep(j, w)\n\t\t\tscanf(\"%d\", &d[i][j]);\n\n\t\tint sum[33][33] = {{0}};\n\t\trep(i, h) rep(j, w)\n\t\t\tsum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + d[i][j];\n\n\t\ts = sum[h][w] - s;\n\t\treps(i, 1, h+1) reps(j, 1, w+1) rep(y, h-i+1) rep(x, w-j+1){\n\t\t\tdev[y][x][i][j] = 1;\n\t\t\tsup[y][x][i][j] = sum[y+i][x+j] - sum[y+i][x] - sum[y][x+j] + sum[y][x];\n\t\t\treps(k, 1, i){\n\t\t\t\tint supsa = min(sup[y][x][k][j], sup[y+k][x][i-k][j]);\n\t\t\t\tif(supsa >= s){\n\t\t\t\t\tint devsa = dev[y][x][k][j] + dev[y+k][x][i-k][j] - dev[y][x][i][j];\n\t\t\t\t\tif(devsa>0 || (devsa==0 && supsa > sup[y][x][i][j])){\n\t\t\t\t\t\tdev[y][x][i][j] += devsa;\n\t\t\t\t\t\tsup[y][x][i][j] = supsa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treps(k, 1, j){\n\t\t\t\tint supsa = min(sup[y][x][i][k], sup[y][x+k][i][j-k]);\n\t\t\t\tif(supsa >= s){\n\t\t\t\t\tint devsa = dev[y][x][i][k] + dev[y][x+k][i][j-k] - dev[y][x][i][j];\n\t\t\t\t\tif(devsa>0 || (devsa==0 && supsa > sup[y][x][i][j])){\n\t\t\t\t\t\tdev[y][x][i][j] += devsa;\n\t\t\t\t\t\tsup[y][x][i][j] = supsa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dev[0][0][h][w], sup[0][0][h][w]-s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int alpha, beta;\n};\n\nP dp[32][32][32][32];\n\nP rec(int l, int t, int r, int b, int acc, vector<vector<int> > a){\n    \n    //cout << l << \" \" << t << \" \" << r << \" \" << b << \" \" << endl;\n    P res;\n    res.alpha = 0;\n    res.beta = 0;    \n    int sum = 0;\n    //合計がアなら0を返す\n    for(int i = t; i < b; i++){    \n        for(int j = l; j < r; j++){\n            sum += a[i][j];\n        }\n    }\n\n    if(sum < acc){\n        return res;\n    }\n\n    //分けて再帰呼び出し\n    \n    //縦\n    for(int i = t + 1; i < b; i++){\n\n        P left, right;\n\n        //左\n        if(dp[l][t][r][i].alpha != 0){\n            left = dp[l][t][r][i];            \n        }else{\n            left = rec(l, t, r, i, acc, a);\n        }\n\n        //右\n        if(dp[l][i][r][b].alpha != 0){\n            right = dp[l][i][r][b];\n        }else{\n            right = rec(l, i, r, b, acc, a);\n        }\n\n        if(left.alpha != 0 && right.alpha != 0){\n            if(res.alpha < left.alpha + right.alpha){\n                res.alpha = left.alpha + right.alpha;\n                res.beta = min(left.beta, right.beta);\n            }else if(res.alpha == left.alpha + right.alpha){\n                res.beta = max(res.beta, min(left.beta, right.beta));\n            }\n        }\n    }\n\n    //横\n    for(int i = l + 1; i < r; i++){\n\n        P left, right;\n\n        //左\n        if(dp[l][t][i][b].alpha != 0){\n            left = dp[l][t][i][b];            \n        }else{\n            left = rec(l, t, i, b, acc, a);\n        }\n\n        //右\n        if(dp[i][t][r][b].alpha != 0){\n            right = dp[i][t][r][b];\n        }else{\n            right = rec(i, t, r, b, acc, a);\n        }\n\n        if(left.alpha != 0 && right.alpha != 0){\n            if(res.alpha < left.alpha + right.alpha){\n                res.alpha = left.alpha + right.alpha;\n                res.beta = min(left.beta, right.beta);\n            }else if(res.alpha == left.alpha + right.alpha){\n                res.beta = max(res.beta, min(left.beta, right.beta));\n            }\n        }\n    }\n\n    if(res.alpha == 0){\n        res.alpha = 1;\n        res.beta = sum - acc;\n    }\n\n    dp[l][t][r][b] = res;\n    return res;\n}\n\nint main(){\n\n    while(1){\n        \n        memset(dp, 0, sizeof(dp));\n\n        int num, power;\n        int h, w, s; cin >> h >> w >> s;\n        if(!h) break;\n\n        int sum = 0;\n        vector<vector<int> > a(h, vector<int> (w));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> a[i][j];\n                sum += a[i][j];\n            }\n        }\n\n        int acc = sum - s;\n        P ans = rec(0, 0, w, h, acc, a);\n        \n        //答え\n        cout << ans.alpha << \" \" << ans.beta << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint u[32][32];\nint S[33][33];\nPII memo[33][33][33][33];\n\ninline int getSum(int sx,int sy,int ex, int ey){\n\treturn S[ey][ex] - S[ey][sx] - S[sy][ex] + S[sy][sx];\n}\n\nPII DFS(int sx,int sy,int ex, int ey, int s){\n\tif(memo[sx][sy][ex][ey].first != -1)return memo[sx][sy][ex][ey];\n\tPII ret = MP(-1,-1);\n\t//縦割り\n\tFOR(i, sx+1, ex){\n\t\tPII ret1 = DFS(sx, sy, i, ey, s);\n\t\tPII ret2 = DFS(i, sy, ex, ey ,s);\n\t\tif(ret1.first != 0 && ret2.first != 0){\n\t\t\tPII tret = MP(ret1.first+ret2.first, min(ret1.second, ret2.second));\n\t\t\tret = max(ret, tret);\n\t\t}\n\t}\n\t//横割り\n\tFOR(i, sy+1, ey){\n\t\tPII ret1 = DFS(sx, sy, ex, i ,s);\n\t\tPII ret2 = DFS(sx, i, ex, ey ,s);\n\t\tif(ret1.first != 0 && ret2.first != 0){\n\t\t\tPII tret = MP(ret1.first+ret2.first, min(ret1.second, ret2.second));\n\t\t\tret = max(ret, tret);\n\t\t}\n\t}\n\tif(ret.first == -1){\n\t\tif(getSum(sx,sy,ex,ey) >= s)return memo[sx][sy][ex][ey] = MP(1, getSum(sx,sy,ex,ey) - s);\n\t\telse return memo[sx][sy][ex][ey] = MP(0, 0);\n\t}\n\telse return memo[sx][sy][ex][ey]=ret;\n}\n\nint main(){\t\n\twhile(1){\n\t\tint h,w,s;\n\t\tcin>>h>>w>>s;\n\t\tmemset(S, 0, sizeof(S));\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tif(h==0)return 0;\n\t\tREP(i,h)REP(j,w)scanf(\"%d\", &u[i][j]);\n\t\tREP(i,h)REP(j,w)S[i+1][j+1] = S[i][j+1]+S[i+1][j]-S[i][j]+u[i][j];\n\t\tPII ret = DFS(0,0,w,h,S[h][w] - s);\n\t\tcout << ret.first << \" \" << ret.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\npair<int,int>dp[33][33][33][33];\nint a[32][32];\nint sum[33][33];\nint lim;\npair<int,int>f(int lx,int rx,int ly,int ry)\n{\n\tif(dp[lx][rx][ly][ry].first>=0)return dp[lx][rx][ly][ry];\n\tint gs=sum[rx][ry]-sum[rx][ly]-sum[lx][ry]+sum[lx][ly];\n\tif(gs<lim)\n\t{\n\t\treturn dp[lx][rx][ly][ry]={-114514,0};\n\t}\n\tpair<int,int>ret={1,gs-lim};\n\tpair<int,int>p,q,r;\n\tfor(int i=lx+1;i<rx;i++)\n\t{\n\t\tp=f(lx,i,ly,ry);\n\t\tq=f(i,rx,ly,ry);\n\t\tr={p.first+q.first,min(p.second,q.second)};\n\t\tif(ret<r)ret=r;\n\t}\n\tfor(int i=ly+1;i<ry;i++)\n\t{\n\t\tp=f(lx,rx,ly,i);\n\t\tq=f(lx,rx,i,ry);\n\t\tr={p.first+q.first,min(p.second,q.second)};\n\t\tif(ret<r)ret=r;\n\t}\n\treturn dp[lx][rx][ly][ry]=ret;\n}\nmain()\n{\n\tint H,W,S;\n\twhile(cin>>H>>W>>S,H)\n\t{\n\t\tfor(int i=0;i<=H;i++)for(int j=0;j<=H;j++)for(int k=0;k<=W;k++)for(int l=0;l<=W;l++)\n\t\t\tdp[i][j][k][l].first=-1;\n\t\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t\t\tcin>>a[i][j];\n\t\tfor(int i=1;i<=H;i++)for(int j=1;j<=W;j++)\n\t\t{\n\t\t\tsum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i-1][j-1];\n\t\t}\n\t\tlim=sum[H][W]-S;\n\t\tpair<int,int>p=f(0,H,0,W);\n\t\tcout<<p.first<<\" \"<<p.second<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\nusing namespace std;\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n\n//ここから編集\nint h, w, s;\nint a[35][35];\nint sum[35][35];\n\npair<int, int> dp[35][35][35][35];\nint t = 0;\n\nint calc(int y1, int x1, int y2, int x2){\n  return sum[y2+1][x2+1] - sum[y2+1][x1] - sum[y1][x2+1] + sum[y1][x1];\n}\n\npair<int, int> rec(int y1, int x1, int y2, int x2){\n\n  if(dp[y1][x1][y2][x2] != make_pair(0, INT_MAX)) return dp[y1][x1][y2][x2];\n\n  pair<int, int> res = make_pair(1, s - (t - calc(y1, x1, y2, x2)));\n\n  /* 分割を全て試す */\n  for(int i=x1; i<x2; i++){\n    if(s - (t - calc(y1, x1, y2, i)) < 0) continue;\n    if(s - (t - calc(y1, i+1, y2, x2)) < 0) continue;\n\n    pair<int, int> res1 = rec(y1, x1, y2, i);\n    pair<int, int> res2 = rec(y1, i+1, y2, x2);\n\n    chmax(res, make_pair(res1.first + res2.first, min(res1.second, res2.second)));\n  }\n\n  for(int i=y1; i<y2; i++){\n    if(s - (t - calc(y1, x1, i, x2)) < 0) continue;\n    if(s - (t - calc(i+1, x1, y2, x2)) < 0) continue;\n\n    pair<int, int> res1 = rec(y1, x1, i, x2);\n    pair<int, int> res2 = rec(i+1, x1, y2, x2);\n\n    chmax(res, make_pair(res1.first + res2.first, min(res1.second, res2.second)));\n  }\n\n  return dp[y1][x1][y2][x2] = res;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  \n  while(cin >> h >> w >> s){\n    if(h == 0 && w == 0 && s == 0) break;\n    memset(a, 0, sizeof(a));\n    memset(sum, 0, sizeof(sum));\n    t = 0;\n    REP(i,h){\n      REP(j,w){\n        cin >> a[i][j];\n        t += a[i][j];\n      }\n    }\n\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        sum[i+1][j+1] = a[i][j];\n      }\n    }\n    for(int i=0; i<=h; i++){\n      for(int j=0; j<w; j++){\n        sum[i][j+1] += sum[i][j];\n      }\n    }\n    for(int j=0; j<=w; j++){\n      for(int i=0; i<h; i++){\n        sum[i+1][j] += sum[i][j];\n      }\n    }\n\n    REP(i,35) REP(j,35)REP(k,35)REP(l,35) dp[i][j][k][l] = make_pair(0, INT_MAX);\n    auto ans = rec(0, 0, h-1, w-1);\n\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nint sum[33][33];\nint ba[33][33];\nint h,w,s;\nint S;\npii memo[33][33][33][33];\n\nint sum2(int x1,int y1, int x2,int y2){\n  int res = sum[x2][y2];\n  if (x1) res -= sum[x1-1][y2];\n  if (y1) res -= sum[x2][y1-1];\n  if (x1&&y1) res += sum[x1-1][y1-1];\n  return res;\n}\n\npii solve(int x1,int y1, int x2,int y2) {\n  if (memo[x1][y1][x2][y2].first >= 0) return memo[x1][y1][x2][y2];\n  if (S - sum2(x1,y1,x2-1,y2-1) > s) return pii(0,0);\n  \n  int res = 1;\n  int hoge = s - (S - sum2(x1,y1,x2-1,y2-1));\n  for (int x=x1+1; x<x2; ++x) {\n    pii aa = solve(x1, y1, x, y2);\n    pii bb = solve(x, y1, x2, y2);\n    int a = aa.first, b = bb.first;\n    if (a&&b) {\n      if (res < a+b) {\n        res = a+b;\n        hoge = min(aa.second, bb.second);\n      } else if (res == a+b) {\n        hoge = max(hoge, min(aa.second,bb.second));\n      }\n    }\n  }\n  for (int y=y1+1; y<y2; ++y) {\n    pii aa = solve(x1, y1, x2, y);\n    pii bb = solve(x1, y, x2, y2);\n    int a = aa.first, b = bb.first;\n    if (a&&b) {\n      if (res < a+b) {\n        res = a+b;\n        hoge = min(aa.second, bb.second);\n      } else if (res == a+b) {\n        hoge = max(hoge, min(aa.second,bb.second));\n      }\n    }\n  }\n  return memo[x1][y1][x2][y2] = pii(res,hoge);\n}\n\nint main() {\n\n  while(cin >> h>>w>>s,h) {\n\n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba[x][y];\n      }\n    }\n\n    REP(y,h) {\n      REP(x,w) {\n        int tmp = ba[x][y];\n        if (x) tmp += sum[x-1][y];\n        if (y) tmp += sum[x][y-1];\n        if (x&&y) tmp -= sum[x-1][y-1];\n        sum[x][y] = tmp;\n      }\n    }\n    S = sum[w-1][h-1];\n    REP(x1,w)REP(x2,w+1)REP(y1,h)REP(y2,h+1)\n      memo[x1][y1][x2][y2] = pii(-1,0);\n    pii res = solve(0,0,w,h);\n    cout << res.first << \" \"  << res.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst pii dam = pii(-1, -1);\nint h, w, s;\nint u[32][32], cu[32][32];\nint all;\npii dp[32][32][32][32];\n\nint sum(int i, int j, int k, int l) {\n  int res = cu[k][l];\n  if (i) res -= cu[i-1][l];\n  if (j) res -= cu[k][j-1];\n  if (i && j) res += cu[i-1][j-1];\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> h >> w >> s, h) {\n    all = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> u[i][j];\n        cu[i][j] = u[i][j];\n        all += u[i][j];\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 1; j < w; j++) {\n        cu[i][j] += cu[i][j-1];\n      }\n    }\n    for (int j = 0; j < w; j++) {\n      for (int i = 1; i < h; i++) {\n        cu[i][j] += cu[i-1][j];\n      }\n    }\n    \n    for (int dy = 0; dy < h; dy++) {\n      for (int dx = 0; dx < w; dx++) {\n        for (int i = 0; i+dy < h; i++) {\n          for (int j = 0; j+dx < w; j++) {\n            int k = i+dy, l = j+dx;\n            pii tmp = dam;\n            if (s - (all - sum(i, j, k, l)) >= 0) {\n              tmp = pii(1, s - (all - sum(i, j, k, l)));\n            }\n            for (int m = i; m < k; m++) {\n              pii U = dp[i][j][m][l], D = dp[m+1][j][k][l];\n              if (U == dam || D == dam) continue;\n              if (U.first + D.first == tmp.first) {\n                tmp = pii(tmp.first, max(tmp.second, min(U.second, D.second)));\n              } else if (U.first + D.first > tmp.first) {\n                tmp = pii(U.first + D.first, min(U.second, D.second));\n              }\n            }\n            for (int m = j; m < l; m++) {\n              pii L = dp[i][j][k][m], R = dp[i][m+1][k][l];\n              if (L == dam || R == dam) continue;\n              if (L.first + R.first == tmp.first) {\n                tmp = pii(tmp.first, max(tmp.second, min(L.second, R.second)));\n              } else if (L.first + R.first > tmp.first) {\n                tmp = pii(L.first + R.first, min(L.second, R.second));\n              }\n            }\n            dp[i][j][k][l] = tmp;\n          }\n        }\n      }\n    }\n    cout << dp[0][0][h-1][w-1].first << \" \" << dp[0][0][h-1][w-1].second  << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\npii INIT = pii(-1, -1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\n\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y) {\n    return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\npii solve(int lx, int ly, int rx, int ry) {\n    pii& ans = memo[lx][ly][rx][ry];\n    if(ans != INIT) return ans;\n\n    int sum = getsum(lx, ly, rx, ry);\n    if(sum < E - S) return ans = pii(0, INF);\n\n    ans = pii(1, S - max(sum, E - sum));\n\n    // テヲツィツェテ」ツ?ョテ・ツ按?・ツ可イ\n    rep(i,lx+1,rx) {\n        pii ra = solve(lx, ly, i, ry);\n        pii rb = solve(i, ly, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    // テァツクツヲテ」ツ?ョテ・ツ按?・ツ可イ\n    rep(i,ly+1,ry) {\n        pii ra = solve(lx, ly, rx, i);\n        pii rb = solve(lx, i, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    //printf(\"lx = %lld, ly = %lld, rx = %lld, ry = %lld, val = (%lld, %lld)\\n\",\n    //    lx, ly, rx, ry, ans.first, ans.second);\n    //printf(\"sum: %lld\\n\\n\", sum);\n    return ans;\n}\n\nsigned main() {\n    while(cin >> H >> W >> S, H || W || S) {\n        memset(board, 0, sizeof(board));\n        rep(i,0,33) rep(j,0,33) rep(k,0,33) rep(l,0,33)\n            memo[i][j][k][l] = INIT;\n        rep(i,0,H) rep(j,0,W) cin >> board[i+1][j+1];\n        rep(i,0,H) rep(j,0,W) board[i+1][j+1] += board[i+1][j];\n        rep(j,0,W) rep(i,0,H) board[i+1][j+1] += board[i][j+1];\n\n        /*\n        rep(i,0,H) {\n            rep(j,0,W) {\n                printf(\"%lld \", board[i+1][j+1]);\n            }\n            cout << endl;\n        }\n        */\n\n        E = getsum(0, 0, H, W);\n        // printf(\"debug: E = %lld\\n\", E);\n        pii ans = solve(0, 0, H, W);\n        printf(\"%lld %lld\\n\", ans.first, ans.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (bit & (1LL << i))\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<typename T> using VVVV = std::vector<std::vector<std::vector<std::vector<T>>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = {0, -1, 0, 1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nclass CumulativeSum {\n\npublic:\n    std::vector<long long> memo1;               // 1次元用の累積和表\n    std::vector<std::vector<long long>> memo2;  // 2次元用の累積和表\n\n    CumulativeSum() {}\n\n    void build(const std::vector<long long> &line) {\n        this->memo1.assign(line.size() + 1, 0);\n\n        for (long long i = 0; i < line.size(); ++i) {\n            this->memo1[i + 1] = this->memo1[i] + line[i];\n        }\n    }\n\n    // 2次元の累積和表を作成\n    void build(const std::vector<std::vector<long long>> &board) {\n        int height = board.size();\n        int width = board[0].size();\n        this->memo2.assign(height + 1, std::vector<long long>(width + 1, 0));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                memo2[y + 1][x + 1] = board[y][x] + memo2[y + 1][x];\n            }\n            for (int x = 0; x < width; ++x) {\n                memo2[y + 1][x + 1] += memo2[y][x + 1];\n            }\n        }\n    }\n\n    long long sum(int left, int right) {\n        return this->memo1[right] - this->memo1[left];\n    }\n\n    /*\n    (y1, x1)から(y2, x2)の合計を返す．(y2, x2)は含まない\n    座標はmemoを作成したboard準拠\n    (ex, sum(0, 0, 2, 2)なら(0, 0), (0, 1), (1, 0), (1, 1)の合計を返す)\n    */\n    long long sum(int y1, int x1, int y2, int x2) {\n        return this->memo2[y2][x2] - this->memo2[y2][x1] - this->memo2[y1][x2] + this->memo2[y1][x1];\n    }\n};\n\nVVVV<pair<int, int>> dp;\npair<int, int> dfs(int y1, int x1, int y2, int x2, const VV<LL> &f, int supply, CumulativeSum &cs, int total) {\n    int syj = supply - (total - cs.sum(y1, x1, y2, x2));\n\n    if (dp[y1][x1][y2][x2] != make_pair(-2, -2)) {\n        return dp[y1][x1][y2][x2];\n    }\n\n    // 不正\n    if (syj < 0) {\n        return make_pair(-1, -1);\n    }\n\n    // 分割しない\n    pair<int, int> ans = make_pair(1, syj);\n\n    // yで分割\n    FOR(y, y1 + 1, y2) {\n        auto a = dfs(y1, x1, y, x2, f, supply, cs, total);\n        auto b = dfs(y, x1, y2, x2, f, supply, cs, total);\n        if (a.first == -1 or b.first == -1) {\n            continue;\n        }\n        chmax(ans, make_pair(a.first + b.first, min(a.second, b.second)));\n    }\n\n    // xで分割\n    FOR(x, x1 + 1, x2) {\n        auto a = dfs(y1, x1, y2, x, f, supply, cs, total);\n        auto b = dfs(y1, x, y2, x2, f, supply, cs, total);\n        if (a.first == -1 or b.first == -1) {\n            continue;\n        }\n        chmax(ans, make_pair(a.first + b.first, min(a.second, b.second)));\n    }\n\n    return dp[y1][x1][y2][x2] = ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int H, W, S;\n        cin >> H >> W >> S;\n        if (H + W + S == 0) {\n            break;\n        }\n\n        dp.assign(33, VVV<pair<int, int>>(33, VV<pair<int, int>>(33, V<pair<int, int>>(33, make_pair(-2, -2)))));\n\n        int total = 0;\n        VV<LL> f(H, V<LL>(W, 0));\n        FOR(i, 0, H) {\n            FOR(j, 0, W) {\n                cin >> f[i][j];\n                total += f[i][j];\n            }\n        }\n\n        CumulativeSum cs;\n        cs.build(f);\n\n        auto ans = dfs(0, 0, H, W, f, S, cs, total);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint H, W, S, U;\nint a[35][35];\nPii dp[35][35][35][35];\n\nPii merge(Pii p, Pii q) {\n    return Pii(p.first + q.first, min(p.second, q.second));\n}\n\nint calcSum(int x1, int y1, int x2, int y2) {\n    return a[x1][y1] - a[x2][y1] - a[x1][y2] + a[x2][y2];\n}\n\nPii dfs(int x1, int y1, int x2, int y2) {\n    // cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n    Pii& ret = dp[x1][y1][x2][y2];    // (#group, mergin)\n    if (ret != Pii(0, inf)) return ret;\n\n    if (calcSum(x1, y1, x2, y2) >= U) {\n        ret = Pii(1, calcSum(x1, y1, x2, y2) - U);\n    } else {\n        return ret;\n    }\n\n    rep2(c, y1 + 1, y2) {\n        ret = max(ret, merge(dfs(x1, y1, x2, c), dfs(x1, c, x2, y2)));\n    }\n    rep2(r, x1 + 1, x2) {\n        ret = max(ret, merge(dfs(x1, y1, r, y2), dfs(r, y1, x2, y2)));\n    }\n\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> H >> W >> S, H) {\n        rep(i, H + 1) rep(j, W + 1) a[i][j] = 0;\n        rep(i, H) rep(j, W) cin >> a[i][j];\n        rep(i, H) {\n            rrep(j, W) {\n                a[i][j] += a[i][j + 1];\n            }\n        }\n        rep(j, W) {\n            rrep(i, H) {\n                a[i][j] += a[i + 1][j];\n            }\n        }\n        U = calcSum(0, 0, H, W) - S;\n        assert(U > 0);\n\n        rep(i, H + 1) rep(j, W + 1) rep(k, H + 1) rep(l, W + 1) dp[i][j][k][l] = Pii(0, inf);\n        printP(dfs(0, 0, H, W));\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W,S;\nint A[55][55];\nint sum[55][55];\npint memo[55][55][55][55];\nint sumall;\nint f(int y1,int x1,int y2,int x2){\n    return sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1];\n}\n\npint dfs(int y1,int x1,int y2,int x2){\n    pint &ret=memo[y1][x1][y2][x2];\n    if(ret.fi!=-1)return ret;\n\n    if(sumall-f(y1,x1,y2,x2)>S)return pint(INT_MIN,INT_MIN);\n    ret=pint(1,f(y1,x1,y2,x2));\n    for(int i=y1+1;i<y2;i++){\n        pint p1=dfs(y1,x1,i,x2),p2=dfs(i,x1,y2,x2);\n        p1.fi+=p2.fi;chmin(p1.se,p2.se);\n        chmax(ret,p1);\n    }\n    for(int i=x1+1;i<x2;i++){\n        pint p1=dfs(y1,x1,y2,i),p2=dfs(y1,i,y2,x2);\n        p1.fi+=p2.fi;chmin(p1.se,p2.se);\n        chmax(ret,p1);\n    }\n    return ret;\n}\n\nvoid solve(){\n\n    rep(i,H)rep(j,W)cin>>A[i][j];\n\n    rep(i,H)rep(j,W)sum[i+1][j+1]=A[i][j]+sum[i+1][j]+sum[i][j+1]-sum[i][j];\n    fill_n(***memo,55*55*55*55,pint(-1,-1));\n    sumall=f(0,0,H,W);\n    pint p=dfs(0,0,H,W);\n    cout<<p.fi<<\" \"<<S-sumall+p.se<<endl;\n}\n\nsigned main(){\n    while(cin>>H>>W>>S,H||W||S)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, S;\nvector< vector<int> > A;\nbool m1[32][32][32][32];\nP m2[32][32][32][32];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, S-(getM(0, 0, W, H) - getM(x1, y1, x2, y2)));\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> S, H || W || S) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[31][31][32], false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define rep(i,from,to) for(int i=from; i<to; ++i)\n#define REP(i,from,to) for(int i=from; i<=to; ++i)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, P> area;\ntypedef struct answer answer;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nstruct answer {\n\tint group, yobi;\n\tanswer(int group, int yobi) {\n\t\tthis->group = group;\n\t\tthis->yobi = yobi;\n\t}\n\tanswer() {\n\t\t*this = answer(1, 0);\n\t}\n\tbool operator<(const answer& a) const {\n\t\tif (group == a.group) {\n\t\t\treturn yobi < a.yobi;\n\t\t} else {\n\t\t\treturn group < a.group;\n\t\t}\n\t}\n\tbool operator==(const answer& a) const {\n\t\treturn group == a.group && yobi == a.yobi;\n\t}\n\tbool operator!=(const answer& a) const {\n\t\treturn !(*this == a);\n\t}\n};\n\nint h, w, s;\nconst int maxh = 33;\nint g[maxh][maxh];\nint sum[maxh][maxh];\nint total;\nanswer dp[maxh][maxh][maxh][maxh];\nconst answer INIT = answer(1, 0);\nint totalpower(area a) {\n\tP &p1 = a.first, &p2 = a.second;\n\tint i1 = p1.first, j1 = p1.second;\n\tint i2 = p2.first, j2 = p2.second;\n\treturn sum[i2][j2] - sum[i1 - 1][j2] - sum[i2][j1 - 1] + sum[i1 - 1][j1 - 1];\n}\n\nanswer dfs(area a, int restpower) { //rest: ???????????????\n\tP &p1 = a.first, &p2 = a.second;\n\tint i1 = p1.first, j1 = p1.second;\n\tint i2 = p2.first, j2 = p2.second;\n//\tprintf(\"area: (%d, %d) , (%d, %d)\\nrestpower: %d\\n\\n\", i1, j1, i2, j2,\n//\t\t\trestpower);\n\tif (dp[i1][j1][i2][j2] != INIT) {\n\t\treturn dp[i1][j1][i2][j2];\n\t}\n\tanswer ret = answer(1, restpower);\n\trep(j, j1, j2)\n\t{\n\t\tarea left = area(P(i1, j1), P(i2, j));\n\t\tarea right = area(P(i1, j + 1), P(i2, j2));\n\t\tint powL = totalpower(left), powR = totalpower(right);\n\t\tint restL = restpower - powR, restR = restpower - powL;\n\t\tif (restL >= 0 && restR >= 0) {\n\t\t\tanswer L = dfs(left, restL);\n\t\t\tanswer R = dfs(right, restR);\n\t\t\tanswer tmp = answer(L.group + R.group, min(L.yobi, R.yobi));\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\n\trep(i, i1, i2)\n\t{\n\t\tarea upper = area(P(i1, j1), P(i, j2));\n\t\tarea down = area(P(i + 1, j1), P(i2, j2));\n\t\tint powP = totalpower(upper), powN = totalpower(down);\n\t\tint restP = restpower - powN, restN = restpower - powP;\n\t\tif (restP >= 0 && restN >= 0) {\n\t\t\tanswer UP = dfs(upper, restP);\n\t\t\tanswer DOWN = dfs(down, restN);\n\t\t\tanswer tmp = answer(UP.group + DOWN.group, min(UP.yobi, DOWN.yobi));\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn dp[i1][j1][i2][j2] = ret;\n}\n\nvoid init() {\n\tmemset(g, 0, sizeof(g));\n\tmemset(sum, 0, sizeof(sum));\n\trep(i1,0,maxh)\n\t{\n\t\trep(j1,0,maxh)\n\t\t{\n\t\t\trep(i2,0,maxh)\n\t\t\t{\n\t\t\t\trep(j2,0,maxh)\n\t\t\t\t{\n\t\t\t\t\tdp[i1][j1][i2][j2] = INIT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve() {\n\twhile (cin >> h >> w >> s, h || w || s) {\n\t\tinit();\n\t\tvector<area> sep;\n\t\tREP(i, 1, h)\n\t\t{\n\t\t\tREP(j,1,w)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tsum[1][1] = g[1][1];\n\t\tREP(i, 1, h)\n\t\t{\n\t\t\tREP(j,1,w)\n\t\t\t{\n\t\t\t\tif (i == 1 && j == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]\n\t\t\t\t\t\t+ g[i][j];\n\t\t\t}\n\t\t}\n\t\tarea whole = area(P(1, 1), P(h, w));\n\t\ttotal = totalpower(whole);\n\t\tanswer ans = dfs(whole, s);\n//\t\tcout << \"group: \" << ans.group << endl;\n//\t\tcout << \"yobi: \" << ans.yobi << endl;\n\t\tcout << ans.group << \" \" << ans.yobi << endl;\n\t}\n\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint p;\n\nint f(int yi, int xi, int yj, int xj, const vector<vector<int>> &r ){\n    int ret = r[yj-1][xj-1];\n    if(yj-1>=0 && xi-1>=0)ret -= r[yj-1][xi-1];\n    if(yi-1>=0 && xj-1>=0)ret -= r[yi-1][xj-1];\n    if(yi-1>=0 && xi-1>=0)ret += r[yi-1][xi-1];\n    \n    return ret;\n}\n\npii merge(pii a, pii b){\n    pii ret;\n    ret.first = a.first+b.first;\n    ret.second = min(a.second, b.second);\n    if(ret.second>=p)return ret;\n    else return pii(-INF, -INF);\n}\n\npii dp[33][33][33][33];\npii dfs(int yi, int xi, int yj, int xj, const vector<vector<int>> &inp, const vector<vector<int>> &r){\n    if(dp[yi][xi][yj][xj]!=pii(-INF, -INF)) return dp[yi][xi][yj][xj];\n    pii ret = pii(-INF, -INF);\n    \n    int res = f(yi, xi, yj, xj, r);\n    if(res>=p)ret = pii(1, res);\n    else return dp[yi][xi][yj][xj] = pii(-INF, -INF);\n    \n    for(int i=yi+1;i<yj;i++){\n        ret = max(ret, merge(dfs(yi,xi,i,xj,inp,r), dfs(i,xi,yj,xj,inp,r)));\n    }\n\n    for(int j=xi+1;j<xj;j++){\n        ret = max(ret, merge(dfs(yi,xi,yj,j,inp,r), dfs(yi,j,yj,xj,inp,r)));\n    }\n    \n    return dp[yi][xi][yj][xj] = ret;\n}\n\nint main(){\n    int h,w,s;\n    while(cin>>h>>w>>s&&(h||w||s)){\n        rep(i,33)rep(j,33)rep(k,33)rep(l,33)dp[i][j][k][l] = pii(-INF, -INF);\n        vector<vector<int>> inp(h, vector<int>(w));\n        rep(i,h) rep(j,w) cin>>inp[i][j];\n        int sum = 0;\n        rep(i,h) rep(j,w) sum += inp[i][j];\n        p = sum-s;\n\n        vector<vector<int>> r = inp;\n        for(int i=1;i<h;i++) rep(j,w) r[i][j] += r[i-1][j];\n        for(int j=1;j<w;j++) rep(i,h) r[i][j] += r[i][j-1];\n        \n        \n        int a,b;\n        tie(a,b) = dfs(0,0,h,w,inp, r);\n        cout<<a<<\" \"<<b-sum+s<<endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\npii dp[33][33][33][33]; // num of groups, yobi\n\nint h, w, s;\nint min_pow;\nint field[33][33];\n\npii pii_sum(pii a, pii b) {\n    if (a.second >= 0 && b.second >= 0) {\n        return pii(a.first+b.first, min(a.second, b.second));\n    }\n    if (a.first == 1 && b.first == 1) {\n        return pii(1, min_pow + a.second + b.second);\n    }\n    return pii(-INF, -INF);\n}\n\npii solve(int u, int d, int l, int r) {\n    if (dp[u][d][l][r].first > 0) {\n        return dp[u][d][l][r];\n    }\n\n    if (u==d && l==r) {\n        return dp[u][d][l][r] = pii(1, field[u][l]-min_pow);\n    }\n    \n    pii output = pii(-INF, -INF);\n    for (int i=u; i<d; i++) {\n        output = max(output, pii_sum(solve(u, i, l, r),\n                    solve(i+1, d, l, r)));\n    }\n    for (int i=l; i<r; i++) {\n        output = max(output, pii_sum(solve(u, d, l, i),\n                    solve(u, d, i+1, r)));\n    }\n#ifdef DEBUG\n    cout << u << \" \" << d << \" \" << l << \" \" << r << endl;\n    cout << output.first << \" \" << output.second << endl;\n#endif\n    return dp[u][d][l][r] = output;\n}\n\nint main(){\n    while(1) {\n        cin >> h >> w >> s;\n        if (h==0) break;\n\n        // initialize dp\n        REP(i, h) {\n            for (int j=i; j<h; j++) {\n                REP(k, w) {\n                    for (int l=k; l<w; l++) {\n                        dp[i][j][k][l] = pii(0, 0);\n                    }\n                }\n            }\n        }\n\n        int sum_supply = 0;\n        REP(i, h) {\n            REP(j, w) {\n                cin >> field[i][j];\n                sum_supply += field[i][j];\n            }\n        }\n        min_pow = sum_supply - s;\n#ifdef DEBUG\n        cout << min_pow << endl;\n#endif\n\n        pii p = solve(0, h-1, 0, w-1);\n        cout << p.first << ' ' << p.second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1176&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nvoid calc_Sum();\npair<int,int> dfs(int sy, int sx, int ty, int tx);\nint h, w, s;\nint u[33][33];\nint Sum[33][33][33][33];\npair<int, int> dp[33][33][33][33];\n\nvoid calc_Sum() {\n\tfor (int sy = 0; sy < h;sy++) {\n\t\tfor (int sx = 0; sx < w;sx++) {\n\t\t\tfor (int ty = sy; ty < h; ty++) {\n\t\t\t\tfor (int tx = sx; tx < w;tx++) {\n\t\t\t\t\tif (sy == ty && sx == tx) { Sum[sy][sx][ty][tx] = u[ty][tx]; continue; }\n\t\t\t\t\tif (sy == ty) { Sum[sy][sx][ty][tx] = Sum[sy][sx][ty][tx - 1] + u[ty][tx]; continue; }\n\t\t\t\t\tif (sx == tx) { Sum[sy][sx][ty][tx] = Sum[sy][sx][ty - 1][tx] + u[ty][tx]; continue; }\n\t\t\t\t\tSum[sy][sx][ty][tx] = Sum[sy][sx][ty - 1][tx] + Sum[sy][sx][ty][tx - 1] \n\t\t\t\t\t\t\t\t\t\t\t\t- Sum[sy][sx][ty - 1][tx - 1] + u[ty][tx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\npair<int, int> dfs(int sy, int sx, int ty, int tx) {\n\tif (dp[sy][sx][ty][tx].first != -1 && dp[sy][sx][ty][tx].second != -1) return dp[sy][sx][ty][tx];\n\n\tint demand = Sum[0][0][h - 1][w - 1] - Sum[sy][sx][ty][tx];\n\tif (demand > s) return dp[sy][sx][ty][tx] = make_pair(0, -1);\n\tauto ret = make_pair(1, -demand);\n\n\t/* horizontal */\n\tfor (int i = sy;i < ty;i++) {\n\t\tauto c1 = dfs(sy, sx, i, tx), c2 = dfs(i + 1, sx, ty, tx);\n\t\tif (c1.first == 0 || c2.first == 0)continue;\n\t\tauto x = make_pair(c1.first + c2.first, min(c1.second, c2.second));\n\t\tif (ret < x)ret = x;\n\t}\n\n\t/* vertical */\n\tfor (int i = sx; i < tx; i++) {\n\t\tauto c1 = dfs(sy, sx, ty, i), c2 = dfs(sy, i + 1, ty, tx);\n\t\tif (c1.first == 0 || c2.first == 0)continue;\n\t\tauto x = make_pair(c1.first + c2.first, min(c1.second, c2.second));\n\t\tif (ret < x) ret = x;\n\t}\n\treturn dp[sy][sx][ty][tx] = ret;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w >> s, h | w | s) {\n\t\tfill(u[0], u[33], 0);\n\t\tfill(Sum[0][0][0], Sum[33][33][33], 0);\n\t\tfill(dp[0][0][0], dp[33][33][33], make_pair(-1, -1));\n\t\tfor (int i = 0;i < h;i++)for (int j = 0; j < w;j++)cin >> u[i][j];\n\t\tcalc_Sum();\n\t\tauto ans = dfs(0, 0, h - 1, w - 1);\n\t\tcout << ans.first << \" \" << s + ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint field[33][33];\nint sum[33][33];\nint num[33][33][33][33];\nint msz[33][33][33][33];\n\nint H,W,S;\nint all;\n\nconst int inf=1<<29;\n\nint get(int i1,int i2,int j1,int j2){\n\ti1--;j1--;\n\treturn sum[i2][j2]-sum[i1][j2]-sum[i2][j1]+sum[i1][j1];\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d\",&H,&W,&S);\n\t\tif(H==0&&W==0) return 0;\n\t\tfor(int i=1;i<=H;i++)for(int j=1;j<=W;j++)scanf(\"%d\",&field[i][j]);\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor(int i=1;i<=H;i++) for(int j=1;j<=W;j++){\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+field[i][j];\n\t\t}\n\t\tint x=sum[H][W]-S;\n\t\tmemset(num,-1,sizeof(num));\n\t\tmemset(msz,-1,sizeof(msz));\n\t\tfor(int i=1;i<=H;i++)for(int j=1;j<=W;j++){\n\t\t\tif(field[i][j]<x){\n\t\t\t\tnum[i][i][j][j]=-inf;\n\t\t\t\tmsz[i][i][j][j]=-inf;\n\t\t\t}else{\n\t\t\t\tnum[i][i][j][j]=1;\n\t\t\t\tmsz[i][i][j][j]=field[i][j];\n\t\t\t}\n\t\t}\n//\t\tprintf(\"aa%d %d\\n\",get(1,2,1,2),sum[2][3]);\n\t\tfor(int id=0;id<=H-1;id++) for(int jd=0;jd<=W-1;jd++){\n\t\tif(id==0&&jd==0) continue;\n\t\t\tfor(int i=1;i+id<=H;i++){\n\t\t\t\tfor(int j=1;j+jd<=W;j++){\n\t\t\t\t\tint i1=i,i2=i+id,j1=j,j2=j+jd;\n\t\t\t\t\tint cAll=get(i1,i2,j1,j2);\n\t\t\t\t\tif(cAll<x){\n\t\t\t\t\t\tnum[i1][i2][j1][j2]=-inf;\n\t\t\t\t\t\tmsz[i1][i2][j1][j2]=-inf;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnum[i1][i2][j1][j2]=1;\n\t\t\t\t\tmsz[i1][i2][j1][j2]=cAll;\n\t\t\t\t\tif(id!=0){\n\t\t\t\t\t\tfor(int si=i1;si<i2;si++){\n\t\t\t\t\t\t\t//[i][si],[si+1][i2]\n\t\t\t\t\t\t\tint nnum=num[i1][si][j1][j2]+num[si+1][i2][j1][j2];\n\t\t\t\t\t\t\tint nmsz=min(msz[i1][si][j1][j2],msz[si+1][i2][j1][j2]);\n\t\t\t\t\t\t\tint &cnum=num[i1][i2][j1][j2];\n\t\t\t\t\t\t\tint &cmsz=msz[i1][i2][j1][j2];\n\t\t\t\t\t\t\tif(cnum<nnum||(cnum==nnum&&cmsz<nmsz)){\n\t\t\t\t\t\t\t\tcnum=nnum;\n\t\t\t\t\t\t\t\tcmsz=nmsz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(jd!=0){\n\t\t\t\t\t\tfor(int sj=j1;sj<j2;sj++){\n\t\t\t\t\t\t\tint nnum=num[i1][i2][j1][sj]+num[i1][i2][sj+1][j2];\n\t\t\t\t\t\t\tint nmsz=min(msz[i1][i2][j1][sj],msz[i1][i2][sj+1][j2]);\n\t\t\t\t\t\t\tint &cnum=num[i1][i2][j1][j2];\n\t\t\t\t\t\t\tint &cmsz=msz[i1][i2][j1][j2];\n\t\t\t\t\t\t\tif(cnum<nnum||(cnum==nnum&&cmsz<nmsz)){\n\t\t\t\t\t\t\t\tcnum=nnum;\n\t\t\t\t\t\t\t\tcmsz=nmsz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",num[1][H][1][W],msz[1][H][1][W]-x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1000000007LL\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define fir first\n#define pb push_back\n#define pi pair<int,int>\n#define sec second\n#define sz size()\n#define vi vector<int>\n\nint h,w,S,u[40][40],s[40][40];\npi dp[40][40][40][40];\n\nint sum(int y1,int x1,int y2,int x2){\n\treturn s[y2+1][x2+1]-s[y1][x2+1]-s[y2+1][x1]+s[y1][x1];\n}\n\npi f(int y1,int x1,int y2,int x2){\n\tpi& res=dp[y1][x1][y2][x2];\n\tif(res.fir!=-1)return res;\n\tint mysum=0;//=sum(y1,x1,y2,x2);\n\trep2(i,y1,y2+1)rep2(j,x1,x2+1)mysum+=u[i][j];\n\tif(mysum<S)return res=pi(-INF,0);\n\tres=pi(1,mysum-S);\n\trep2(i,y1,y2){\n\t\tpi p=f(y1,x1,i,x2),q=f(i+1,x1,y2,x2);\n\t\tpi r=pi(p.fir+q.fir,min(p.sec,q.sec));\n\t\tres=max(res,r);\n\t}\n\trep2(j,x1,x2){\n\t\tpi p=f(y1,x1,y2,j),q=f(y1,j+1,y2,x2);\n\t\tpi r=pi(p.fir+q.fir,min(p.sec,q.sec));\n\t\tres=max(res,r);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>h>>w>>S && h){\n\t\trep(i,h)rep(j,w)cin>>u[i][j];\n\t\trep2(i,1,h+1)rep2(j,1,w+1){\n\t\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+u[i-1][j-1];\n\t\t}\n\t\tS=s[h][w]-S;\n\t\trep(i,40)rep(j,40)rep(k,40)rep(l,40)dp[i][j][k][l]=pi(-1,0);\n\t\tpi ans=f(0,0,h-1,w-1);\n\t\tcout<<ans.fir<<\" \"<<ans.sec<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\ntypedef pair<int,int> pii;\n\nint H,W,s;\nvector< vector<int> > G;\n\npii MEMO[32][32][32][32];//<??°???????????°????????????>\n\nint ALLSUM[32][32];\n\npii rec(int y,int x,int h,int w){\n  if(MEMO[y][x][h][w].first!=0)return MEMO[y][x][h][w];\n\n  int rect_sum=ALLSUM[y+h-1][x+w-1];\n  if(y>0 && x>0)rect_sum+=ALLSUM[y-1][x-1];\n  if(y>0)rect_sum-=ALLSUM[y-1][x+w-1];\n  if(x>0)rect_sum-=ALLSUM[y+h-1][x-1];\n  if(s<ALLSUM[H-1][W-1]-rect_sum)return make_pair(-1,-1);\n  \n  if(w==1&& h==1){\n    return make_pair(1,s-ALLSUM[H-1][W-1]+G[y][x]);\n  }\n  \n  pii ret=make_pair(1,s-ALLSUM[H-1][W-1]+rect_sum);\n  rep(i,h-1){\n    //i=0 to h-2;\n    pii ret1=rec(y,x,i+1,w);\n    pii ret2=rec(y+i+1,x,h-(i+1),w);\n    pii tmp;\n    if(ret1.first==-1 || ret2.first==-1)continue;\n    tmp.first=ret1.first+ret2.first;\n    tmp.second=min(ret1.second,ret2.second);\n    ret=max(ret,tmp);\n  }\n  rep(i,w-1){\n    pii ret1=rec(y,x,h,i+1);\n    pii ret2=rec(y,x+i+1,h,w-(i+1));\n    pii tmp;\n    if(ret1.first==-1 || ret2.first==-1)continue;\n    tmp.first=ret1.first+ret2.first;\n    tmp.second=min(ret1.second,ret2.second);\n    ret=max(ret,tmp);\n  }\n  return MEMO[y][x][h][w]=ret;\n}\n\nint main()\n{\n  while(true){\n    G.clear();\n    rep(i,32)rep(j,32)rep(k,32)rep(l,32)MEMO[i][j][k][l]=make_pair(0,0);\n    rep(i,32)rep(j,32)ALLSUM[i][j]=0;\n    \n    cin>>H>>W>>s;\n    if(!H and !W and !s)break;\n    G.resize(H,vector<int>(W));\n    rep(i,H)rep(j,W)scanf(\"%d\",&G[i][j]);\n\n    rep(i,H){\n      rep(j,W){\n        ALLSUM[i][j]=G[i][j];\n        if(j>0)ALLSUM[i][j]+=ALLSUM[i][j-1];\n      }\n    }\n    rep(i,H){\n      rep(j,W){\n        if(i>0)ALLSUM[i][j]+=ALLSUM[i-1][j];\n      }\n    }\n\n    \n    pii ans=rec(0,0,H,W);\n    printf(\"%d %d\\n\",ans.first,ans.second);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define f first\n#define s second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h,w,s,u[34][34];\nP memo[34][34][34][34];\n\nP rec(int x1,int y1,int x2,int y2){\n\t\n\tif(memo[x1][y1][x2][y2]!=P(0,INF))return memo[x1][y1][x2][y2];\n\t\n\tif(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])>s)return P(0,INF);\n\t\n\tP res=P(1,s-(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])));\n\t\n\tfor(int i=x1+1;i<x2;i++){\n\t\tP a=rec(x1,y1,i,y2);\n\t\tP b=rec(i,y1,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\tfor(int i=y1+1;i<y2;i++){\n\t\tP a=rec(x1,y1,x2,i);\n\t\tP b=rec(x1,i,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\treturn memo[x1][y1][x2][y2]=res;\n}\n\nint main(void){\n\t\n\twhile(cin >> h >> w >> s,h|w|s){\n\t\t\n\t\tfor(int i=0;i<34;i++)\n\t\t\tfor(int j=0;j<34;j++)\n\t\t\t\tfor(int k=0;k<34;k++)\n\t\t\t\t\tfor(int l=0;l<34;l++)\n\t\t\t\t\t\tmemo[i][j][k][l]=P(0,INF);\n\t\t\n\t\tfill(u[0],u[33],0);\n\t\th++,w++;\n\t\t\n\t\tfor(int i=1;i<h;i++){\n\t\t\tfor(int j=1;j<w;j++){\n\t\t\t\tcin >> u[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<h;i++){\n\t\t\tfor(int j=1;j<w;j++){\n\t\t\t\tu[i][j]+=u[i-1][j]+u[i][j-1]-u[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tP ans=rec(1,1,w,h);\n\t\tcout << ans.f << \" \" << ans.s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1048576 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << (ret >> 20) << ' ' << ((ret - o) & 1048575) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nconst int MAX = 40;\nint us[MAX][MAX];\nint sm[MAX][MAX];\n\n// [u, d) * [l, r)\nint query(int u,int d,int l,int r){\n  return (sm[u][l]+sm[d][r])-(sm[u][r]+sm[d][l]);\n}\n\nint h,w,s;\n\nusing P = pair<int, int>;\nint used[MAX][MAX][MAX][MAX];\nP dp[MAX][MAX][MAX][MAX];\n\nP dfs(int u,int d,int l,int r){\n  if(sm[h][w]-query(u,d,l,r)>s) return P(-MAX*MAX,-MAX*MAX);\n  if(used[u][d][l][r]) return dp[u][d][l][r];\n  used[u][d][l][r]=1;\n  P res(1,s-(sm[h][w]-query(u,d,l,r)));\n  for(int m=u+1;m<d;m++){\n    P x=dfs(u,m,l,r);\n    P y=dfs(m,d,l,r);\n    chmax(res,P(x.first+y.first,min(x.second,y.second)));\n  }\n  for(int m=l+1;m<r;m++){\n    P x=dfs(u,d,l,m);\n    P y=dfs(u,d,m,r);\n    chmax(res,P(x.first+y.first,min(x.second,y.second)));\n  }\n  return dp[u][d][l][r]=res;\n}\n\nint solve(){\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      cin>>us[i][j];\n\n  memset(sm,0,sizeof(sm));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      sm[i+1][j+1]=us[i][j];\n\n  for(int i=0;i<=h;i++)\n    for(int j=1;j<=w;j++)\n      sm[i][j]+=sm[i][j-1];\n\n  for(int i=1;i<=h;i++)\n    for(int j=0;j<=w;j++)\n      sm[i][j]+=sm[i-1][j];\n\n  memset(used,0,sizeof(used));\n  P res=dfs(0,h,0,w);\n  cout<<res.first<<' '<<res.second<<newl;\n  return 0;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  while(cin>>h>>w>>s,h) solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n \nint h, w, s;\nint U[35][35];\nint allsum = 0;\n// dp[y1][x1][y2][x2] := ??????(y1, x1), ??????(y2, x2)????????????¢??????????????????, \n// ???°??????????????????????????????§???°, ??????§????????????\npair<int, int> dp[35][35][35][35];\n \n// O(hw)\ntemplate <class T>\nvector<vector<T>> Imos2D(const vector<vector<T>>& a) {\n    int h = a.size(), w = a[0].size();\n    vector<vector<T>> s(h + 1, vector<T>(w + 1, 0));\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) s[i + 1][j + 1] = a[i][j];\n    for (int i = 0; i < h + 1; ++i) for (int j = 0; j < w; ++j) s[i][j + 1] += s[i][j];\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w + 1; ++j) s[i + 1][j] += s[i][j];\n    return s;\n}\n// O(1)\ntemplate <class T>\nint sum(const vector<vector<T>>& s, int i, int j, int h, int w) {\n    return s[i + h][j + w] - s[i][j + w] + s[i][j] - s[i + h][j];\n}\n \npair<int, int> dfs(int y1, int x1, int y2, int x2, auto& imos) {\n    if(dp[y1][x1][y2][x2] != make_pair(0, INF)) return dp[y1][x1][y2][x2];\n     \n    int yobi = s - (allsum - sum<int>(imos, y1, x1, y2 - y1 + 1, x2 - x1 + 1));\n    // if(yobi < 0) return make_pair(0, INF);\n    auto ret = make_pair(1, yobi);\n \n    for (int i = x1; i < x2; ++i){\n        if(s - (allsum - sum<int>(imos, y1, x1, y2 - y1 + 1, i - x1 + 1)) < 0) continue;\n        if(s - (allsum - sum<int>(imos, y1, i + 1, y2 - y1 + 1, x2 - (i + 1) + 1)) < 0) continue;\n        auto ret1 = dfs(y1, x1, y2, i, imos);\n        auto ret2 = dfs(y1, i + 1, y2, x2, imos);\n        chmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n    }\n \n    for (int i = y1; i < y2; ++i){\n        if(s - (allsum - sum<int>(imos, y1, x1, i - y1 + 1, x2 - x1 + 1)) < 0) continue;\n        if(s - (allsum - sum<int>(imos, i + 1, x1, y2 - (i + 1) + 1, x2 - x1 + 1)) < 0) continue;\n        auto ret1 = dfs(y1, x1, i, x2, imos);\n        auto ret2 = dfs(i + 1, x1, y2, x2, imos);\n        chmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n    }\n    return dp[y1][x1][y2][x2] = ret;\n}\n \nint main(void) {\n    while(1) {\n        scanf(\"%d %d %d\", &h, &w, &s);\n         \n        if(h == 0 && w == 0 && s == 0) break;\n        rep(i, h)rep(j, w) scanf(\"%d\", &U[i][j]);\n        allsum = 0;\n        rep(i, h)rep(j, w) allsum += U[i][j];\n \n        vector<vector<int>> u(h);\n        rep(i, h)rep(j, w) u[i].pb(U[i][j]);\n        auto imos = Imos2D<int>(u);\n        rep(i, 35)rep(j, 35)rep(k, 35)rep(l, 35) dp[i][j][k][l] = make_pair(0, INF);\n \n        auto ans = dfs(0, 0, h - 1, w - 1, imos);\n        printf(\"%d %d\\n\", ans.fi, ans.se);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nvvi G;\npii dp[34][34][34][34];\nint n,m,q,sum;\npii f(int a,int b,int c,int d){\n\tif(dp[a][b][c][d].first!=inf)return dp[a][b][c][d];\n\tdp[a][b][c][d]=pii(0,0);\n\tloop(i,a,c)loop(j,b,d)dp[a][b][c][d].second+=G[i][j];\n\trep(i,c-a-1){\n\t\tpii ta=f(a,b,a+i+1,d);\n\t\tpii tb=f(a+i+1,b,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\trep(i,d-b-1){\n\t\tpii ta=f(a,b,c,b+i+1);\n\t\tpii tb=f(a,b+i+1,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\tif(dp[a][b][c][d].second<sum)dp[a][b][c][d]=pii(-inf,-inf);\n//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n//\tcout<<dp[a][b][c][d].first<<\" \"<<dp[a][b][c][d].second<<endl;\n\treturn dp[a][b][c][d];\n}\nint main(){\n\twhile(cin>>n>>m>>q,n+m+q){\n\t\tsum=-q;\n\t\tG=vvi(n,vi(n));\n\t\trep(i,n)rep(j,m)cin>>G[i][j];\n\t\trep(i,n)rep(j,m)sum+=G[i][j];\n\t\trep(i,34)rep(j,34)rep(k,34)rep(l,34)\n\t\t\tdp[i][j][k][l]=pii(inf,inf);\n\t\tf(0,0,n,m);\n\t\tcout<<1+dp[0][0][n][m].first<<\" \"<<dp[0][0][n][m].second-sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point &p) const { return x == p.x && y == p.y; }\n    bool operator!= (const Point &p) const { return x != p.x || y != p.y; }\n    bool operator< (const Point &p) const { return x == p.x ? y < p.y : x < p.x;}\n};\nPoint hasi[2];\ntypedef pair<int, int> pint;\nint fld[33][33];\nint h, w, s, sum;\npint dp[33][33][33][33];//dp[i][j][k][l] := (j, i) ????????? (l, k) ?????????(????????????)???????????¢?????????????????´????????°\npint dfs(Point a, Point b){\n    if(a < hasi[0] || hasi[1] < a || b < hasi[0] || hasi[1] < b) return pint(0, 0);\n    if(dp[a.y][a.x][b.y][b.x] != pint(-1, -1)) return dp[a.y][a.x][b.y][b.x];\n    int bubunwa = 0;\n    REP(i, a.y, b.y)\n      REP(j, a.x, b.x)\n        bubunwa += fld[i][j];\n    if(sum - bubunwa > s)\n      return dp[a.y][a.x][b.y][b.x] = pint(0, s - (sum - bubunwa));\n    pint res(1, s - (sum - bubunwa));\n    REP(i, a.x + 1, b.x){\n        pint temp1 = dfs(a, Point(i, b.y)), temp2 = dfs(Point(i, a.y), b);\n        pint temp(temp1.first + temp2.first, min(temp1.second, temp2.second));\n        res = max(temp, res);\n    }\n    REP(i, a.y + 1, b.y){\n        pint temp1 = dfs(a, Point(b.x, i)), temp2 = dfs(Point(a.x, i), b);\n        pint temp(temp1.first + temp2.first, min(temp1.second, temp2.second));\n        res = max(temp, res);\n    }\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\n\nint main(){\n    while(scanf(\"%d%d%d\", &h, &w, &s) && h){\n        sum = 0;\n        rep(i, h) rep(j, w){\n            scanf(\"%d\", &fld[i][j]);\n            sum += fld[i][j];\n        }\n        rep(i, 33) rep(j, 33) rep(k, 33) rep(l, 33) dp[i][j][k][l] = pint(-1, -1);\n        hasi[0] = Point(0, 0);\n        hasi[1] = Point(w, h);\n        pint ans = dfs(Point(0, 0), Point(w, h));\n        printf(\"%d %d\\n\", ans.first, ans.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i =0;i<n;++i)\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define FOR(it,a ) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntypedef pair<int,int> PI;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\n\nint h,w,s;\nint u[100][100];\n\nint sum[100][100];\n\nPI memo[50][50][50][50];//group, yobi\n\nPI rec(int x1,int y1,int x2,int y2){\n  auto&  ans =memo[x1][y1][x2][y2];\n  if(ans.F>=0)  return ans;\n  //ans = mp(-1,0);\n  int su =sum[x2][y2]-sum[x2][y1]-sum[x1][y2]+sum[x1][y1];\n  int all = sum[h][w];\n  int saiju = all - su;\n  if(saiju <= s)\n    ans=mp(1,s-saiju);\n  \n  for(int x=x1+1;x<x2;++x){\n    auto p = rec(x1,y1,x,y2);\n    auto p2 = rec(x,y1,x2,y2);\n    ans=max(ans,mp(p.F+p2.F,min(p.S,p2.S)));\n  }\n  \n  for(int y=y1+1;y<y2;++y){\n    auto p = rec(x1,y1,x2,y);\n    auto p2 = rec(x1,y,x2,y2);\n    ans=max(ans,mp(p.F+p2.F,min(p.S,p2.S)));\n  }\n  \n  //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << ans.F << \" \" << ans.S << endl;\n  return ans;\n}\n\nvoid solve(){\n  rep(i,h)rep(j,w) cin >> u[i][j];\n  rep(i,h)rep(j,w)\n    sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] + u[i][j] - sum[i][j];\n  //cout << sum[h][w] << endl;\n  memset(memo,-1,sizeof(memo));\n  auto ans = rec(0,0,h,w);\n  cout << ans.F << \" \" << ans.S << endl;\n  //cout << rec(0,0,h,w) << endl;\n}\n\n\nint main(){\n  while(cin >>h  >> w>>s,h) solve();  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\ninline int solve(int x1, int y1, int x2, int y2) {\n\tif (!dp[y1][x1][y2][x2]) return dp[y1][x1][y2][x2];\n\tint ret = 1048576 + rng(x1, y1, x2, y2);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2), petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i), petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", (ret >> 20), ((ret - o) & 1048575));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,s,all;\nint fie[35][35];\nint sum[35][35];\nint dp[35][35][35][35];\nint min_dem[35][35][35][35];\nint flag=0;\n\nP check(int lx,int rx,int ly,int ry){\n\tif(dp[lx][rx][ly][ry]!=0){\n\t\treturn P(dp[lx][rx][ly][ry],min_dem[lx][rx][ly][ry]);\n\t}\n\tif(all-(sum[rx][ry]-sum[rx][ly]-sum[lx][ry]+sum[lx][ly])>s)return P(-1,-1);\n\tdp[lx][rx][ly][ry]=1;\n\tmin_dem[lx][rx][ly][ry]=sum[rx][ry]-sum[rx][ly]-sum[lx][ry]+sum[lx][ly];\n\tfor(int i=lx+1;i<rx;i++){\n\t\tP c=check(lx,i,ly,ry),d=check(i,rx,ly,ry);\n\t\tif(c.first==-1 || d.first==-1)continue;\n\t\tif(c.first+d.first==dp[lx][rx][ly][ry] && min(c.second,d.second)>min_dem[lx][rx][ly][ry]){\n\t\t\tdp[lx][rx][ly][ry]=c.first+d.first;\n\t\t\tmin_dem[lx][rx][ly][ry]=min(c.second,d.second);\n\t\t}\n\t\tif(c.first+d.first>dp[lx][rx][ly][ry]){\n\t\t\tdp[lx][rx][ly][ry]=c.first+d.first;\n\t\t\tmin_dem[lx][rx][ly][ry]=min(c.second,d.second);\n\t\t}\n\t}\n\tfor(int i=ly+1;i<ry;i++){\n\t\tP c=check(lx,rx,ly,i),d=check(lx,rx,i,ry);\n\t\tif(c.first==-1 || d.first==-1)continue;\n\t\tif(c.first+d.first==dp[lx][rx][ly][ry] && min(c.second,d.second)>min_dem[lx][rx][ly][ry]){\n\t\t\tdp[lx][rx][ly][ry]=c.first+d.first;\n\t\t\tmin_dem[lx][rx][ly][ry]=min(c.second,d.second);\n\t\t}\n\t\tif(c.first+d.first>dp[lx][rx][ly][ry]){\n\t\t\tdp[lx][rx][ly][ry]=c.first+d.first;\n\t\t\tmin_dem[lx][rx][ly][ry]=min(c.second,d.second);\n\t\t}\n\t}\n\treturn P(dp[lx][rx][ly][ry],min_dem[lx][rx][ly][ry]);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&s);\n\t\tif(h+w+s==0)break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(min_dem,0,sizeof(min_dem));\n\t\tall=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tall+=fie[j][i];\n\t\t\t}\n\t\t}\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tsum[j][i]=sum[j-1][i]+fie[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=w;i++){\n\t\t\tfor(int j=1;j<=h;j++){\n\t\t\t\tsum[i][j]+=sum[i][j-1];\n\t\t\t}\n\t\t}\n\t\tP res=check(0,w,0,h);\n\t\tprintf(\"%d %d\\n\",res.first,s-all+res.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\npair<int,int> dp[33][33][33][33];\nint in[33][33];\nint sum[33][33];\nint h,w,s,whs;\n\nint f() {\n  int ts;\n  for(int i=0; i<h; ++i) {\n    ts = 0;\n    for(int j=0; j<w; ++j) {\n      ts += in[i][j];\n      sum[i][j] = ts;\n    }\n  }\n\n  for(int i=0; i<w; ++i) {\n    ts = 0;\n    for(int j=0; j<h; ++j) {\n      ts += sum[j][i];\n      sum[j][i] = ts;\n    }\n  }\n\n  // for(int i=0; i<h; ++i) {\n  //   for(int j=0; j<w; ++j)\n  //     cout<<sum[i][j]<<\" \";\n  //   cout<<endl;\n  // }\n\n}\n\nint sumsq(int ux,int uy,int dx,int dy) {\n  return sum[dy][dx] - (uy==0?0:sum[uy-1][dx])\n    - (ux==0?0:sum[dy][ux-1]) + ((uy==0||ux==0)?0:sum[uy-1][ux-1]);\n}\n\npair<int,int> maxx(pair<int,int> p,pair<int,int> q) {\n  if(p.first > q.first) return p;\n  if(q.first > p.first) return q;\n  if(p.second > q.second) return p;\n  return q;\n}\n\npair<int,int> f(pair<int,int> p,pair<int,int> q) {\n  return make_pair(p.first+q.first, min(p.second,q.second));\n}\n\npair<int,int> rec(int ux,int uy,int dx,int dy) {\n  //  cout<<ux<<\" \"<<uy<<\" \"<<dx<<\" \"<<dy<<\" \"<<sumsq(ux,uy,dx,dy)<<endl;\n  if(dp[ux][uy][dx][dy] != make_pair(-1,-1)) return dp[ux][uy][dx][dy];\n  if(whs - sumsq(ux,uy,dx,dy) > s) return make_pair(-1,0);\n\n  pair<int,int> ret = make_pair(0,0);\n  for(int i=ux; i<dx; ++i) {\n    pair<int,int> t1 = rec(ux,uy,i,dy);\n    pair<int,int> t2 = rec(i+1,uy,dx,dy);\n    if(t1.first == -1 || t2.first == -1) continue;\n    ret = maxx(ret,f(t1,t2));\n  }\n\n  for(int i=uy; i<dy; ++i) {\n    pair<int,int> t1 = rec(ux,uy,dx,i),t2 = rec(ux,i+1,dx,dy);\n    if(t1.first == -1 || t2.first == -1) continue;\n    ret = maxx(ret,f(t1,t2));\n  }\n\n  if(ret == make_pair(0,0)) {\n    //    cout<<\"! \"<<ux<<\" \"<<uy<<\" \"<<dx<<\" \"<<dy<<\" \"<<1<<\" \"<<s - (whs - sumsq(ux,uy,dx,dy))<<endl;\n    return dp[ux][uy][dx][dy] = make_pair(1,s - (whs - sumsq(ux,uy,dx,dy)));\n  }\n  //  cout<<ux<<\" \"<<uy<<\" \"<<dx<<\" \"<<dy<<\" \"<<ret.first<<\" \"<<ret.second<<endl;\n  return dp[ux][uy][dx][dy] = ret;\n}\n\nint main() {\n  while(cin>>h>>w>>s, h|w|s) {\n    for(int i=0; i<33; ++i)\n      for(int j=0; j<33; ++j)\n        for(int k=0; k<33; ++k)\n          for(int l=0; l<33; ++l)\n            dp[i][j][k][l] = make_pair(-1,-1);\n\n    memset(in, -1, sizeof(in));\n    for(int i=0; i<h; ++i)\n      for(int j=0; j<w; ++j)\n        cin>>in[i][j];\n    memset(sum, 0, sizeof(sum));\n    f();\n    whs = sum[h-1][w-1];\n    pair<int,int> p = rec(0,0,w-1,h-1);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n\nint h,w,s, total;\nint u[32][32], sep[32][32][32][32], pow[32][32][32][32];\nbool calced[32][32][32][32];\nint imos[33][33];\n\nvoid init(){\n    REP(i,h) REP(j,w) REP(k,h) REP(l,w){\n        sep[i][j][k][l] = pow[i][j][k][l] = -1;\n        calced[i][j][k][l] = false;\n    }\n    \n    REP(i,h) imos[i][0] = 0;\n    REP(j,w) imos[0][j] = 0;\n    REP(i,h) REP(j,w) imos[i+1][j+1] = u[i][j];\n    REP(i,h+1) REP(j,w) imos[i][j+1] += imos[i][j];\n    REP(i,h) REP(j,w+1) imos[i+1][j] += imos[i][j];\n}\n\nint getsum(int ay, int ax, int by, int bx){\n    return imos[ay][ax] +imos[by+1][bx+1] -imos[ay][bx+1] -imos[by+1][ax];\n}\n\nvoid solve(int ay, int ax, int by, int bx){\n    if(calced[ay][ax][by][bx]) return;\n\n    pair<int, int> res(1, s -(total -getsum(ay,ax,by,bx)));\n    if(res.second < 0){\n        calced[ay][ax][by][bx] = true;\n        return;\n    }\n    \n    for(int i=ay; i<by; i++){\n        solve(ay, ax, i, bx);\n        solve(i+1, ax, by, bx);\n        int val1 = sep[ay][ax][i][bx], val2 = sep[i+1][ax][by][bx];\n        if(val1>=0 && val2>=0 && val1+val2 >= res.first){\n            int cap = min(pow[ay][ax][i][bx], pow[i+1][ax][by][bx]);\n            if(val1+val2 == res.first){\n                res.second = max(res.second, cap);\n            }else{\n                res.first = val1+val2;\n                res.second = cap;\n            }\n        }\n    }\n    for(int i=ax; i<bx; i++){\n        solve(ay, ax, by, i);\n        solve(ay, i+1, by, bx);\n        int val1 = sep[ay][ax][by][i], val2 = sep[ay][i+1][by][bx];\n        if(val1>=0 && val2>=0 && val1+val2 >= res.first){\n            int cap = min(pow[ay][ax][by][i], pow[ay][i+1][by][bx]);\n            if(val1+val2 == res.first){\n                res.second = max(res.second, cap);\n            }else{\n                res.first = val1+val2;\n                res.second = cap;\n            }\n        }\n    }\n    \n    calced[ay][ax][by][bx] = true;\n    sep[ay][ax][by][bx] = res.first;\n    pow[ay][ax][by][bx] = res.second;\n}\n\nint main(){\n    while(1){\n        cin >> h >> w >> s;\n        if(h==0) break;\n\n        total=0;\n        REP(i, h) REP(j, w){\n            cin >> u[i][j];\n            total += u[i][j];\n        }\n        \n        init();\n        solve(0, 0, h-1, w-1);\n        cout << sep[0][0][h-1][w-1] << \" \" << pow[0][0][h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,int> dp[32][32][32][32];\nint m[32][32];\nint S[33][33];\nint p;\npair<int,int> solve(int a,int b,int c,int d){\n\tif(~(dp[a][b][c][d].first))return dp[a][b][c][d];\n\tpair<int,int> q=make_pair(-99999999,0);\n\tif(S[b+1][d+1]-S[b+1][c]-S[a][d+1]+S[a][c]>=p){\n\t\tq=make_pair(1,S[b+1][d+1]-S[b+1][c]-S[a][d+1]+S[a][c]-p);\n\t}\n\tfor(int i=a;i<b;i++){\n\t\tpair<int,int> L=solve(a,i,c,d);\n\t\tpair<int,int> R=solve(i+1,b,c,d);\n\t\tR.first+=L.first;\n\t\tR.second=min(L.second,R.second);\n\t\tq=max(q,R);\n\t}\n\tfor(int i=c;i<d;i++){\n\t\tpair<int,int> L=solve(a,b,c,i);\n\t\tpair<int,int> R=solve(a,b,i+1,d);\n\t\tR.first+=L.first;\n\t\tR.second=min(L.second,R.second);\n\t\tq=max(q,R);\n\t}\n\treturn dp[a][b][c][d]=q;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=i;j<a;j++)\n\t\t\t\tfor(int k=0;k<b;k++)\n\t\t\t\t\tfor(int l=k;l<b;l++)\n\t\t\t\t\t\tdp[i][j][k][l]=make_pair(-1,-1);\n\t\tint s=0;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\t\t\ts+=m[i][j];\n\t\t\t}\n\t\tp=s-c;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tS[i+1][j+1]=m[i][j];\n\t\tfor(int i=1;i<=a;i++)\n\t\t\tfor(int j=1;j<=b;j++)\n\t\t\t\tS[i][j]+=S[i-1][j];\n\t\tfor(int i=1;i<=a;i++)\n\t\t\tfor(int j=1;j<=b;j++)\n\t\t\t\tS[i][j]+=S[i][j-1];\n\t\tpair<int,int> ret=solve(0,a-1,0,b-1);\n\t\tprintf(\"%d %d\\n\",ret.first,ret.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 35\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,s,n[N][N],S,A[N][N];\nP memo[N][N][N][N];\n\nint getsum(int u,int d,int l,int r){\n  return A[d][r]-A[d][l-1]-A[u-1][r]+A[u-1][l-1];\n}\n\nP dfs(int u,int d,int l,int r){\n  if(memo[u][d][l][r].first!=-1)return memo[u][d][l][r];\n  for(int i=u;i<d;i++){\n    if(!(S-getsum(u,i,l,r)<=s&&S-getsum(i+1,d,l,r)<=s))continue;\n    P r1=dfs(u,i,l,r),r2=dfs(i+1,d,l,r);\n    memo[u][d][l][r]=max(memo[u][d][l][r],P(r1.first+r2.first,min(r1.second,r2.second)));\n  }\n  for(int i=l;i<r;i++){\n    if(!(S-getsum(u,d,l,i)<=s&&S-getsum(u,d,i+1,r)<=s))continue;\n    P r1=dfs(u,d,l,i),r2=dfs(u,d,i+1,r);\n    memo[u][d][l][r]=max(memo[u][d][l][r],P(r1.first+r2.first,min(r1.second,r2.second)));\n  }\n  if(memo[u][d][l][r].first==-1)memo[u][d][l][r]=P(1,s-(S-getsum(u,d,l,r)));\n  return memo[u][d][l][r];\n}\n\nint main(){\n  while(1){\n    cin>>h>>w>>s;\n    if(!h&&!w&&!s)break;\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++)cin>>n[i][j];\n    memset(memo,-1,sizeof(memo));\n    memset(A,0,sizeof(A));\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++)A[i][j]=A[i][j-1]+n[i][j];\n    for(int j=1;j<=w;j++)\n      for(int i=2;i<=h;i++)A[i][j]+=A[i-1][j];\n    S=A[h][w];\n    P ans=dfs(1,h,1,w);\n    cout<<ans.first<<' '<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nint main()\n{\n    while (true) {\n        int h, w, s; cin >> h >> w >> s;\n        if (h == 0 && w == 0 && s == 0) {\n            break;\n        }\n        auto u = make_v<int>(h, w);\n        int u_sum = 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> u[i][j];\n                u_sum += u[i][j];\n            }\n        }\n\n        auto us = make_v<int>(h+1, w+1);\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                us[i+1][j+1] = us[i+1][j] + us[i][j+1] - us[i][j] + u[i][j];\n            }\n        }\n\n        auto dp = make_vector<int>(h+1, h+1, w+1, w+1, -1);\n        auto res = make_vector<int>(h+1, h+1, w+1, w+1, -1);\n        for (int a = 0; a <= h; ++a) {\n            for (int b = 0; b <= w; ++b) {\n                for (int i = 0; i+a <= h; ++i) {\n                    for (int j = 0; j+b <= w; ++j) {\n\n                        int ts = us[i+a][j+b] - us[i+a][j] - us[i][j+b] + us[i][j];\n                        if (ts >= u_sum - s) {\n                            if (dp[i][i+a][j][j+b] == 1) {\n                                chmax(res[i][i+a][j][j+b], ts - (u_sum - s));\n                            } else if (dp[i][i+a][j][j+b] < 1) {\n                                dp[i][i+a][j][j+b] = 1;\n                                res[i][i+a][j][j+b] = ts - (u_sum - s);\n                            }\n                        }\n\n                        for (int r = i+1; r < i+a; ++r) {\n                            if (dp[i][r][j][j+b] == -1 ||\n                                dp[r][i+a][j][j+b] == -1) {\n                                continue;\n                            }\n                            if (dp[i][i+a][j][j+b] ==\n                                    dp[i][r][j][j+b] + dp[r][i+a][j][j+b]) {\n                                chmax(res[i][i+a][j][j+b],\n                                    min(res[i][r][j][j+b], res[r][i+a][j][j+b]));\n                            } else if (dp[i][i+a][j][j+b] <\n                                    dp[i][r][j][j+b] + dp[r][i+a][j][j+b]) {\n                                dp[i][i+a][j][j+b] =\n                                    dp[i][r][j][j+b] + dp[r][i+a][j][j+b];\n                                res[i][i+a][j][j+b] =\n                                    min(res[i][r][j][j+b], res[r][i+a][j][j+b]);\n                            }\n                        }\n\n                        for (int c = j+1; c < j+b; ++c) {\n                            if (dp[i][i+a][j][c] == -1 ||\n                                dp[i][i+a][c][j+b] == -1) {\n                                continue;\n                            }\n                            if (dp[i][i+a][j][j+b] ==\n                                    dp[i][i+a][j][c] + dp[i][i+a][c][j+b]) {\n                                chmax(res[i][i+a][j][j+b],\n                                    min(res[i][i+a][j][c], res[i][i+a][c][j+b]));\n                            } else if (dp[i][i+a][j][j+b] <\n                                    dp[i][i+a][j][c] + dp[i][i+a][c][j+b]) {\n                                dp[i][i+a][j][j+b] =\n                                    dp[i][i+a][j][c] + dp[i][i+a][c][j+b];\n                                res[i][i+a][j][j+b] =\n                                    min(res[i][i+a][j][c], res[i][i+a][c][j+b]);\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", dp[0][h][0][w], res[0][h][0][w]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid print_YES_NO(bool answer){cout<<(answer?\"YES\":\"NO\")<<endl;}\nvoid print_Yes_No(bool answer){cout<<(answer?\"Yes\":\"No\")<<endl;}\nvoid print_POSSIBLE_IMPOSSIBLE(bool answer){cout<<(answer?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;}\n\nint n,m,p;\nint dp[32][32][33][33][2];\nint t[35][35];\nint ts[35][35];\n\nint check(int a,int b,int c,int d){\n\tif(dp[a][b][c][d][0]!=-1)return dp[a][b][c][d][0];\n\tint e=ts[c][d]-ts[a][d]-ts[c][b]+ts[a][b];\n\tif(e>=p)dp[a][b][c][d][1]=e-p,e=1;\n\telse e=0;\n\tint f,g;\n\tfor(int i=a+1;i<c;i++){\n\t\tf=check(a,b,i,d)+check(i,b,c,d);\n\t\tg=min(dp[a][b][i][d][1],dp[i][b][c][d][1]);\n\t\tif(e<f)e=f,dp[a][b][c][d][1]=g;\n\t\tif(e==f)dp[a][b][c][d][1]=max(dp[a][b][c][d][1],g);\n\t}\n\tfor(int i=b+1;i<d;i++){\n\t\tf=check(a,b,c,i)+check(a,i,c,d);\n\t\tg=min(dp[a][b][c][i][1],dp[a][i][c][d][1]);\n\t\tif(e<f)e=f,dp[a][b][c][d][1]=g;\n\t\tif(e==f)dp[a][b][c][d][1]=max(dp[a][b][c][d][1],g);\n\t}\n\tdp[a][b][c][d][0]=e;\n\treturn e;\n}\n\nint main(){\n\tint i,j,k;\n\tint a,b,c;\n\twhile(cin>>n>>m>>p){\n\t\tif(n==0)break;\n\t\tmemset(t,0,sizeof(t));\n\t\tmemset(ts,0,sizeof(ts));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\ta=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tcin>>t[i][j];\n\t\t\t\ta+=t[i][j];\n\t\t\t}\n\t\t}\n\t\tp=a-p;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tts[i+1][j+1]=ts[i][j+1]+ts[i+1][j]-ts[i][j]+t[i][j];\n\t\t\t}\n\t\t}\n\t\tcheck(0,0,n,m);\n\t\tcout<<dp[0][0][n][m][0]<<\" \"<<dp[0][0][n][m][1]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W,S;\nint A[33][33];\nint sum[33][33];\npint memo[33][33][33][33];\nint sumall;\nint f(int y1,int x1,int y2,int x2){\n    return sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1];\n}\n\npint dfs(int y1,int x1,int y2,int x2){\n    pint &ret=memo[y1][x1][y2][x2];\n    if(ret.fi!=-1)return ret;\n\n    if(sumall-f(y1,x1,y2,x2)>S)return pint(INT_MIN,INT_MIN);\n    ret=pint(1,f(y1,x1,y2,x2));\n    for(int i=y1+1;i<y2;i++){\n        pint p1=dfs(y1,x1,i,x2),p2=dfs(i,x1,y2,x2);\n        p1.fi+=p2.fi;chmin(p1.se,p2.se);\n        chmax(ret,p1);\n    }\n    for(int i=x1+1;i<x2;i++){\n        pint p1=dfs(y1,x1,y2,i),p2=dfs(y1,i,y2,x2);\n        p1.fi+=p2.fi;chmin(p1.se,p2.se);\n        chmax(ret,p1);\n    }\n    return ret;\n}\n\nvoid solve(){\n\n    rep(i,H)rep(j,W)cin>>A[i][j];\n\n    rep(i,H)rep(j,W)sum[i+1][j+1]=A[i][j]+sum[i+1][j]+sum[i][j+1]-sum[i][j];\n    fill_n(***memo,33*33*33*33,pint(-1,-1));\n    sumall=f(0,0,H,W);\n    pint p=dfs(0,0,H,W);\n    cout<<p.fi<<\" \"<<S-sumall+p.se<<endl;\n}\n\nsigned main(){\n    while(cin>>H>>W>>S,H||W||S)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w, s;\nint u[40][40];\nint sum[40][40];\npair<int, int> memo[40][40][40][40];\n\npair<int, int> calc(int lx, int ly, int rx, int ry) {\n  int area = sum[h][w] - (sum[ry][rx] - sum[ry][lx] - sum[ly][rx] + sum[ly][lx]);\n  if (memo[lx][ly][rx][ry].first != -1) { return memo[lx][ly][rx][ry]; }\n  pair<int, int> ret(-100, -100);\n  if (area <= s) {\n    ret = make_pair(1, s - area);\n  }\n  FOR(x, lx + 1, rx) {\n    pair<int, int> lret = calc(lx, ly, x, ry);\n    pair<int, int> rret = calc(x, ly, rx, ry);\n    ret = max(ret, make_pair(lret.first + rret.first, min(lret.second, rret.second)));\n  }\n  FOR(y, ly + 1, ry) {\n    pair<int, int> lret = calc(lx, ly, rx, y);\n    pair<int, int> rret = calc(lx, y, rx, ry);\n    ret = max(ret, make_pair(lret.first + rret.first, min(lret.second, rret.second)));\n  }\n  return memo[lx][ly][rx][ry] = ret;\n\n}\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &s), h|w|s) {\n    MEMSET(sum, 0);\n    MEMSET(memo, -1);\n    REP(y, h) {\n      REP(x, w) {\n        scanf(\"%d\", &u[y][x]);\n        sum[y + 1][x + 1] = sum[y + 1][x] + sum[y][x + 1] - sum[y][x] + u[y][x];\n      }\n    }\n    pair<int, int> ans = calc(0, 0, w, h);\n    printf(\"%d %d\\n\", ans.first, ans.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\n/** 累積和 */\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/** /累積和 */\n\n\ntypedef tuple<int, int, int, int> Kukei;\n\nint H, W, S;\nint total_power;\nVVI tile;\nVVI c_tile;\nvector< vector< vector< vector<PII> > > > memo;\n\nbool can_group(int x1, int x2, int y1, int y2) {\n\treturn total_power - S <= sum_csum2<int>(c_tile, y1, y2, x1, x2);\n}\n\nPII dfs(int x1, int x2, int y1, int y2) {\n\tauto &tmp = memo[y1][x1][y2][x2];\n\tif (tmp.first != -1) {\n\t\treturn tmp;\n\t}\n\t\n\tPII res(-1, -1);\n\n\tfor (int v = x1 + 1; v < x2; v++) {\n\t\tPII a = dfs(x1, v, y1, y2);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(v, x2, y1, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tfor (int h = y1 + 1; h < y2; h++) {\n\t\tPII a = dfs(x1, x2, y1, h);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(x1, x2, h, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tif (res.first == -1 && can_group(x1, x2, y1, y2)) {\n\t\tres = make_pair(1, sum_csum2<int>(c_tile, y1, y2, x1, x2));\n\t}\n\n\treturn tmp = res;\n}\n\nint main(void) {\n\twhile(cin >> H >> W >> S, H) {\n\t\ttile = VVI(H, VI(W, 0));\n\t\ttotal_power = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\ttotal_power += tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemo = vector< vector< vector< vector<PII> > > >(H + 1,\n\t\t\t\tvector< vector< vector<PII> > >(W + 1,\n\t\t\t\tvector< vector<PII> >(H + 1,\n\t\t\t\tvector<PII>(W + 1,\n\t\t\t\tmake_pair(-1, -1)))));\n\n\t\tc_tile = calc_csum2<int>(tile);\n\n\t\tPII ans = dfs(0, W, 0, H);\n\n\t\tcout << ans.first << \" \" << (S - total_power + ans.second) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 35;\n\nint h,w,s;\nint u[MAX_N][MAX_N];\nint cnt[MAX_N][MAX_N][MAX_N][MAX_N];\nP res[MAX_N][MAX_N][MAX_N][MAX_N];  //??°???????????° ????????????\n\nP dfs(int lx,int ly,int rx,int ry)\n{\n    if(res[lx][ly][rx][ry].first != 0){\n        return res[lx][ly][rx][ry];\n    }\n    P cand1,cand2;\n    P cand = P(1,(s-(cnt[0][0][h-1][w-1]-cnt[lx][ly][rx][ry])));\n    for(int i=lx;i < rx;i++){\n        if(cnt[0][0][h-1][w-1]-cnt[lx][ly][i][ry] <= s && cnt[0][0][h-1][w-1]-cnt[i+1][ly][rx][ry]<= s){\n            P p1 = dfs(lx,ly,i,ry);\n            P p2 = dfs(i+1,ly,rx,ry);\n            int tmin = min(p1.se,p2.se);\n            cand1 = P(p1.fi+p2.fi,tmin);\n            cand = max(cand,cand1);\n        }\n    }\n    for(int i=ly;i < ry;i++){\n        if(cnt[0][0][h-1][w-1]-cnt[lx][ly][rx][i] <= s && cnt[0][0][h-1][w-1]-cnt[lx][i+1][rx][ry] <= s){\n            P p1 = dfs(lx,ly,rx,i);\n            P p2 = dfs(lx,i+1,rx,ry);\n            int tmin = min(p1.se,p2.se);\n            cand2 = P(p1.fi+p2.fi,tmin);\n            cand = max(cand,cand2);\n        }\n    }\n    res[lx][ly][rx][ry] = cand;\n    return res[lx][ly][rx][ry];\n}\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> s;\n        if(h == 0){\n            break;\n        }\n        rep(i,h){\n            rep(j,w){\n                rep(k,h){\n                    rep(l,w){\n                        res[i][j][k][l] = P(0,0);\n                    }\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                cin >> u[i+1][j+1];\n            }\n        }\n        rep(i,h){\n            u[i][0] = 0;\n        }\n        rep(j,w){\n            u[0][j] = 0;\n        }\n        rep(i,h+1){\n            rep(j,w){\n                u[i][j+1] = u[i][j+1] + u[i][j];\n            }\n        }\n        rep(i,h){\n            rep(j,w+1){\n                u[i+1][j] = u[i+1][j] + u[i][j];\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                for(int k = i;k < h;k++){\n                    for(int l = j;l < w;l++){\n                        cnt[i][j][k][l] = u[k+1][l+1] - u[k+1][j] - u[i][l+1] + u[i][j];\n                    }\n                }\n            }\n        }\n        P ans = dfs(0,0,h-1,w-1);\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int alpha, beta;\n};\n\nP dp[32][32][32][32];\n\nP rec(int l, int t, int r, int b, int acc, vector<vector<int> >& a){\n    \n    //cout << l << \" \" << t << \" \" << r << \" \" << b << \" \" << endl;\n    P res;\n    res.alpha = 0;\n    res.beta = 0;    \n    int sum = 0;\n    //合計がアなら0を返す\n    for(int i = t; i < b; i++){    \n        for(int j = l; j < r; j++){\n            sum += a[i][j];\n        }\n    }\n\n    if(sum < acc){\n        return res;\n    }\n\n    //分けて再帰呼び出し\n    \n    //縦\n    for(int i = t + 1; i < b; i++){\n\n        P left, right;\n\n        //左\n        if(dp[l][t][r][i].alpha != 0){\n            left = dp[l][t][r][i];            \n        }else{\n            left = rec(l, t, r, i, acc, a);\n        }\n\n        //右\n        if(dp[l][i][r][b].alpha != 0){\n            right = dp[l][i][r][b];\n        }else{\n            right = rec(l, i, r, b, acc, a);\n        }\n\n        if(left.alpha != 0 && right.alpha != 0){\n            if(res.alpha < left.alpha + right.alpha){\n                res.alpha = left.alpha + right.alpha;\n                res.beta = min(left.beta, right.beta);\n            }else if(res.alpha == left.alpha + right.alpha){\n                res.beta = max(res.beta, min(left.beta, right.beta));\n            }\n        }\n    }\n\n    //横\n    for(int i = l + 1; i < r; i++){\n\n        P left, right;\n\n        //左\n        if(dp[l][t][i][b].alpha != 0){\n            left = dp[l][t][i][b];            \n        }else{\n            left = rec(l, t, i, b, acc, a);\n        }\n\n        //右\n        if(dp[i][t][r][b].alpha != 0){\n            right = dp[i][t][r][b];\n        }else{\n            right = rec(i, t, r, b, acc, a);\n        }\n\n        if(left.alpha != 0 && right.alpha != 0){\n            if(res.alpha < left.alpha + right.alpha){\n                res.alpha = left.alpha + right.alpha;\n                res.beta = min(left.beta, right.beta);\n            }else if(res.alpha == left.alpha + right.alpha){\n                res.beta = max(res.beta, min(left.beta, right.beta));\n            }\n        }\n    }\n\n    if(res.alpha == 0){\n        res.alpha = 1;\n        res.beta = sum - acc;\n    }\n\n    dp[l][t][r][b] = res;\n    return res;\n}\n\nint main(){\n\n    while(1){\n        \n        memset(dp, 0, sizeof(dp));\n\n        int num, power;\n        int h, w, s; cin >> h >> w >> s;\n        if(!h) break;\n\n        int sum = 0;\n        vector<vector<int> > a(h, vector<int> (w));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> a[i][j];\n                sum += a[i][j];\n            }\n        }\n\n        int acc = sum - s;\n        P ans = rec(0, 0, w, h, acc, a);\n        \n        //答え\n        cout << ans.alpha << \" \" << ans.beta << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nint H, W, S;\nint u[35][35];\nint su[35][35];\nint p = 0;\n\npair<int,int> memo[35][35][35][35];\n\npair<int, int> best_splitting(int lh, int rh, int lw, int rw) {\n    pair<int, int>* ptr = &memo[lh][rh][lw][rw];\n    if (ptr->first >= 0) {\n        return *ptr;\n    }\n\n    int sum_of_area = su[lh][lw] - su[rh][lw] - su[lh][rw] + su[rh][rw];\n\n    pair<int, int> ret = make_pair(-1, -1);\n    if (sum_of_area >= p) {\n        ret = make_pair(1, sum_of_area - p);\n    } else {\n        return *ptr = ret;\n    }\n\n    for (int dh = lh+1; dh < rh; ++dh) {\n        auto s1 = best_splitting(lh, dh, lw, rw);\n        auto s2 = best_splitting(dh, rh, lw, rw);\n\n        if (s1.first < 0 || s2.first < 0) {\n            continue;\n        }\n\n        auto cand = make_pair(s1.first+s2.first, min(s1.second, s2.second));\n        if (cand > ret) {\n            ret = cand;\n        }\n    }\n\n    for (int dw = lw+1; dw < rw; ++dw) {\n        auto s1 = best_splitting(lh, rh, lw, dw);\n        auto s2 = best_splitting(lh, rh, dw, rw);\n\n        if (s1.first < 0 || s2.first < 0) {\n            continue;\n        }\n\n        auto cand = make_pair(s1.first+s2.first, min(s1.second, s2.second));\n        if (cand > ret) {\n            ret = cand;\n        }\n    }\n\n    return *ptr = ret;\n}\n\nbool solve() {\n    cin >> H >> W >> S;\n    if (H == 0 && W == 0 && S == 0) {\n        return false;\n    }\n\n    p = 0;\n    for (int j = 0; j < 35; ++j) {\n        fill(u[j], u[j]+35, 0);\n        fill(su[j], su[j]+35, 0);\n    }\n\n    for (int j = 1; j <= H; ++j) {\n        for (int k = 1; k <= W; ++k) {\n            cin >> u[j][k];\n            p += u[j][k];\n        }\n    }\n    p -= S;\n\n    for (int j = H; j > 0; --j) {\n        for (int k = W; k > 0; --k) {\n            su[j][k] = u[j][k] + su[j+1][k] + su[j][k+1] - su[j+1][k+1];\n        }\n    }\n\n    for (int j = 0; j < 35; ++j) {\n        for (int k = 0; k < 35; ++k) {\n            for (int l = 0; l < 35; ++l) {\n                fill(memo[j][k][l], memo[j][k][l]+35, make_pair(-1, -1));\n            }\n        }\n    }\n\n    auto result = best_splitting(1, H+1, 1, W+1);\n    cout << result.first << ' ' << result.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\npii dptab[32][32][32][32];\nint sum[32][32];\nint in[32][32];\nint h, w, s;\nint all;\nint segmin;\n\npii solve(pii ul, pii br) {\n\tif(dptab[ul.fi][ul.se][br.fi-1][br.se-1].fi + 1)\n\t\treturn dptab[ul.fi][ul.se][br.fi-1][br.se-1];\n\n\tint tmp = 0;\n\tif(br.fi > 0 && br.se > 0)\n\t\ttmp += sum[br.fi-1][br.se-1];\n\tif(ul.fi > 0 && br.se > 0)\n\t\ttmp -= sum[ul.fi-1][br.se-1];\n\tif(br.fi > 0 && ul.se > 0)\n\t\ttmp -= sum[br.fi-1][ul.se-1];\n\tif(ul.fi > 0 && ul.se > 0)\n\t\ttmp += sum[ul.fi-1][ul.se-1];\n\n\tif(tmp < segmin)\n\t\treturn dptab[ul.fi][ul.se][br.fi-1][br.se-1] = pii(0,-1);\n\n\tpii nex = pii(1, tmp-segmin);\n\tpii res0, res1;\n\tfor(int i = ul.fi+1; i < br.fi; i++) {\n\t\tres0 = solve(ul, pii(i, br.se));\n\t\tres1 = solve(pii(i, ul.se), br);\n\n\t\tif(res0.fi > 0 && res1.fi > 0) {\n\t\t\tif(res0.fi + res1.fi > nex.fi) {\n\t\t\t\tnex.fi = res0.fi + res1.fi;\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t\telse if(res0.fi + res1.fi == nex.fi && min(res0.fi, res0.se) > nex.se) {\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = ul.se+1; i < br.se; i++) {\n\t\tres0 = solve(ul, pii(br.fi, i));\n\t\tres1 = solve(pii(ul.fi, i), br);\n\n\t\tif(res0.fi > 0 && res1.fi > 0) {\n\t\t\tif(res0.fi + res1.fi > nex.fi) {\n\t\t\t\tnex.fi = res0.fi + res1.fi;\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t\telse if(res0.fi + res1.fi == nex.fi && min(res0.fi, res0.se) > nex.se) {\n\t\t\t\tnex.se = min(res0.se, res1.se);\n\t\t\t}\n\t\t}\n\t}\n\treturn dptab[ul.fi][ul.se][br.fi-1][br.se-1] = nex;\n}\n\nint main() {\n\twhile(cin >> h >> w >> s, h || w || s) {\n\t\t// init\n\t\tfor(int i = 0; i < 32*32; i++) sum[0][i] = in[0][i] = 0;\n\t\tfor(int i = 0; i < 1024*1024; i++) dptab[0][0][0][i] = pii(-1,-1);\n\t\tall = 0;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tcin >> in[i][j];\n\t\t\t\tall += in[i][j];\n\t\t\t}\n\t\t}\n\t\tsegmin = all-s;\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tsum[i][j] = in[i][j];\n\t\t\t\tif(i-1 >= 0)\n\t\t\t\t\tsum[i][j] += sum[i-1][j];\n\t\t\t\tif(j-1 >= 0)\n\t\t\t\t\tsum[i][j] += sum[i][j-1];\n\t\t\t\tif(i-1 >= 0 && j-1 >= 0)\n\t\t\t\t\tsum[i][j] -= sum[i-1][j-1];\n\t\t\t}\n\t\t}\n\n\t\tpii res;\n\t\tres = solve(pii(0,0),pii(h,w));\n\t\tcout << res.fi << \" \" << res.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntypedef pair<int, int> P;\n\nint H, W, T;\nvector< vector<int> > A;\nbool m1[32][32][32][32];\nP m2[32][32][32][32];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, getM(x1, y1, x2, y2)-T);\n\tif (res.second < 0) {\n\t\tres = P(-inf, 0);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> T, H || W || T) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[31][31][32], false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tT = sum - T;\n\t\tP ans = solve(0, 0, W, H);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint h,w,s;\npii dp[32][32][32][32];\nint field[32][32];\nint sumTbl[32][32];\nint allSum;\n\npii dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[minx][miny][maxx][maxy].first!=-1)return dp[minx][miny][maxx][maxy];\n\tint sum=0;\n\tfor(int i=miny;i<=maxy;i++){\n\t\tif(minx==0)sum+=sumTbl[i][maxx];\n\t\telse sum+=sumTbl[i][maxx]-sumTbl[i][minx-1];\n\t}\n\tpii res(1,sum);\n\tfor(int i=miny;i<maxy;i++){\n\t\tint sum1=0;\n\t\tint sum2=0;\n\t\tfor(int j=miny;j<=i;j++){\n\t\t\tif(minx==0)sum1+=sumTbl[j][maxx];\n\t\t\telse sum1+=sumTbl[j][maxx]-sumTbl[j][minx-1];\n\t\t}\n\t\tfor(int j=i+1;j<=maxy;j++){\n\t\t\tif(minx==0)sum2+=sumTbl[j][maxx];\n\t\t\telse sum2+=sumTbl[j][maxx]-sumTbl[j][minx-1];\n\t\t}\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\tpii p1=dfs(minx,miny,maxx,i);\n\t\t\tpii p2=dfs(minx,i+1,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)\n\t\t\t\tres.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\tfor(int i=minx;i<maxx;i++){\n\t\tint sum1=0;\n\t\tint sum2=0;\n\t\tfor(int j=miny;j<=maxy;j++){\n\t\t\tif(minx==0)sum1+=sumTbl[j][i];\n\t\t\telse sum1+=sumTbl[j][i]-sumTbl[j][minx-1];\n\t\t}\n\t\tfor(int j=miny;j<=maxy;j++)sum2+=sumTbl[j][maxx]-sumTbl[j][i];\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\tpii p1=dfs(minx,miny,i,maxy);\n\t\t\tpii p2=dfs(i+1,miny,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)\n\t\t\t\tres.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\treturn dp[minx][miny][maxx][maxy]=res;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&(h|w|s)){\n\t\tallSum=0;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\t\tfor(int k=0;k<32;k++)for(int l=0;l<32;l++)dp[i][j][k][l].first=dp[i][j][k][l].second=-1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tallSum+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(j==0)sumTbl[i][j]=field[i][j];\n\t\t\t\telse sumTbl[i][j]=sumTbl[i][j-1]+field[i][j];\n\t\t\t}\n\t\t}\n\t\tpii res=dfs(0,0,w-1,h-1);\n\t\tcout<<res.first<<\" \"<<s-(allSum-res.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1<<28)\ninline void cmax(int &a, int b) { if (a < b) a = b; }\n\nint n, m, S, f[32][32], _sum[32][32];\n\ninline int sum(int x1, int y1, int x2, int y2) {\n    return _sum[x2+1][y2+1]-_sum[x2+1][y1]-_sum[x1][y2+1]+_sum[x1][y1];\n}\n\nint dp[32][32][32][32];\n\nint solve(int lb) {\n    for (int w = 0; w < n; w++) rep (x1, n-w) {\n        const int x2 = x1+w;\n        for (int h = 0; h < m; h++) rep (y1, m-h) {\n            const int y2 = y1+h;\n            if (sum(x1, y1, x2, y2) < lb) {\n                dp[x1][x2][y1][y2] = -INF;\n                continue;\n            }\n            dp[x1][x2][y1][y2] = 1;\n            for (int i = x1; i < x2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][i][y1][y2]+dp[i+1][x2][y1][y2]);\n            }\n            for (int i = y1; i < y2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][x2][y1][i]+dp[x1][x2][i+1][y2]);\n            }\n        }\n    }\n    return dp[0][n-1][0][m-1];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &n, &m, &S);\n        if (n == 0) return 0;\n        rep (i, n) rep (j, m) scanf(\"%d\", f[i]+j);\n        rep (i, n) rep (j, m) {\n            _sum[i+1][j+1] = f[i][j]+_sum[i+1][j]+_sum[i][j+1]-_sum[i][j];\n        }\n        const int tot = sum(0, 0, n-1, m-1);\n        const int ans = solve(tot-S);\n        int l = 0, r = S+1;\n        while (r-l>1) {\n            const int mid = (l+r) / 2;\n            if (solve(tot-S+mid) >= ans) l = mid;\n            else r = mid;\n        }\n        printf(\"%d %d\\n\", ans, l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define mp make_pair\n\nusing namespace std;\n\nint h, w, s;\nint u[32][32];\nint sm[33][33][33][33];\nint all;\npair<int, int> memo[33][33][33][33];\n\nint calcs(int x1, int y1, int x2, int y2){\n  if(sm[x1][y1][x2][y2]) return sm[x1][y1][x2][y2];\n  if(x1 + 1 == x2 && y1 + 1 == y2)\n    return sm[x1][y1][x2][y2] = u[y1][x1];\n\n  int ret;\n  if(y1 + 1 == y2){\n    ret = calcs(x1, y1, x2 - 1, y2) + calcs(x2 - 1, y1, x2, y2);\n  }else{\n    ret = calcs(x1, y1, x2, y2 - 1) + calcs(x1, y2 - 1, x2, y2);\n  }\n  return sm[x1][y1][x2][y2] = ret;\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h, &w, &s), h + w + s){\n    REP(i,h) REP(j,w) scanf(\"%d\", &u[i][j]);\n    REP(i,h) REP(j,w)\n      for(int k = i; k < h; k++)\n\tfor(int l = j; l < w; l++)\n\t  sm[j][i][l+1][k+1] = 0;\n\n    REP(i,h) REP(j,w)\n      for(int k = i; k < h; k++)\n\tfor(int l = j; l < w; l++){\n\t  calcs(j, i, l + 1, k + 1);\n\t  memo[j][i][l+1][k+1].first = -1;\n\t}\n    all = sm[0][0][w][h];\n\n    for(int ww = 1; ww <= w; ww++){\n      for(int hh = 1; hh <= h; hh++){\n\tfor(int xx = 0; xx + ww <= w; xx++){\n\t  for(int yy = 0; yy + hh <= h; yy++){\n\t    int sum = sm[xx][yy][xx + ww][yy + hh];\n\t    int tmp = all - sum;\n\t    pair<int, int> ret(-1, -1);\n\n\t    if(tmp <= s) ret = mp(1, s - tmp);\n\n\t    for(int www = 1; www < ww; www++){\n\t      pair<int, int> r1 = memo[xx][yy][xx + www][yy + hh];\n\t      pair<int, int> r2 = memo[xx + www][yy][xx + ww][yy + hh];\n\n\t      if(r1.first == -1 || r2.first == -1) continue;\n\n\t      pair<int, int> r3 = mp(r1.first + r2.first, min(r1.second, r2.second));\n\t      ret = max(ret, r3);\n\t    }\n\t    for(int hhh = 1; hhh < hh; hhh++){\n\t      pair<int, int> r1 = memo[xx][yy][xx + ww][yy + hhh];\n\t      pair<int, int> r2 = memo[xx][yy + hhh][xx + ww][yy + hh];\n\t      \n\t      if(r1.first == -1 || r2.first == -1) continue;\n\t      \n\t      pair<int, int> r3 = mp(r1.first + r2.first, min(r1.second, r2.second));\n\t      ret = max(ret, r3);\n\t    }\n\n\t    memo[xx][yy][xx + ww][yy + hh] = ret;\n\t  }\n\t}\n      }\n    }\n    \n    pair<int, int> ret = memo[0][0][w][h];\n    \n    printf(\"%d %d\\n\", ret.first, ret.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint h, w, s;\nint U[35][35];\nint allsum = 0;\nint sum[35][35];\n// dp[y1][x1][y2][x2] := ??????(y1, x1), ??????(y2, x2)???????????¢??????????????????, \n// ??°?????????????????????????????§??°, ?????§????????????\npair<int, int> dp[35][35][35][35];\n\nvoid sum2D(int h, int w) {\n\trep(y, h + 1)rep(x, w + 1) sum[y][x] = 0;\n\trep(y, h)rep(x, w) sum[y + 1][x + 1] = U[y][x]; // ?????????????????????\n\trep(y, h + 1)rep(x, w) sum[y][x + 1] += sum[y][x]; // ?¨?\n\trep(y, h)rep(x, w + 1) sum[y + 1][x] += sum[y][x]; // ???\n}\nint calcSum(int y1, int x1, int y2, int x2) {\n\treturn sum[y2 + 1][x2 + 1] - sum[y2 + 1][x1] - sum[y1][x2 + 1] + sum[y1][x1];\n}\n\npair<int, int> dfs(int y1, int x1, int y2, int x2) {\n\tif(dp[y1][x1][y2][x2] != make_pair(0, INF)) return dp[y1][x1][y2][x2];\n\t\n\tauto ret = make_pair(1, s - (allsum - calcSum(y1, x1, y2, x2)));\n\n\tfor (int i = x1; i < x2; ++i){\n\t\tif(s - (allsum - calcSum(y1, x1, y2, i)) < 0) continue;\n\t\tif(s - (allsum - calcSum(y1, i + 1, y2, x2)) < 0) continue;\n\t\tauto ret1 = dfs(y1, x1, y2, i);\n\t\tauto ret2 = dfs(y1, i + 1, y2, x2);\n\t\tchmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n\t}\n\n\tfor (int i = y1; i < y2; ++i){\n\t\tif(s - (allsum - calcSum(y1, x1, i, x2)) < 0) continue;\n\t\tif(s - (allsum - calcSum(i + 1, x1, y2, x2)) < 0) continue;\n\t\tauto ret1 = dfs(y1, x1, i, x2);\n\t\tauto ret2 = dfs(i + 1, x1, y2, x2);\n\t\tchmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\n\nint main(void) {\n\twhile(1) {\n\t\tscanf(\"%d %d %d\", &h, &w, &s);\n\n\t\tif(h == 0 && w == 0 && s == 0) break;\n\t\trep(i, h)rep(j, w) scanf(\"%d\", &U[i][j]);\n\t\tallsum = 0;\n\t\trep(i, h)rep(j, w) allsum += U[i][j];\n\t\tsum2D(h, w);\n\t\trep(i, 35)rep(j, 35)rep(k, 35)rep(l, 35) dp[i][j][k][l] = make_pair(0, INF);\n\t\tauto ans = dfs(0, 0, h - 1, w - 1);\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\npii dp[32][32][32][32];\nsigned main() {\n    while (1) {\n        REP(i, 32) REP(j, 32) REP(k, 32) REP(l, 32) dp[i][j][k][l] = {INF, INF};\n\n        int h, w, s;\n        cin >> h >> w >> s;\n\n        if (h == 0 && w == 0 && s == 0) break;\n\n        vector<vector<int>> u(h, vector<int>(w));\n        cin >> u;\n\n        int S = 0;\n        FORE(r, u) FORE(c, r) S += c;\n        int mn = S - s;\n\n        auto rec = [&](auto f, int y1, int x1, int y2, int x2) -> pii {\n            auto &MEMO = dp[y1][x1][y2][x2];\n            if (MEMO.first != INF) return MEMO;\n\n            int ps = 0;\n            REPF(x, x1, x2) {\n                REPF(y, y1, y2) {\n                    ps += u[y][x];\n                }\n            }\n\n            pii ret = {1, ps};\n            REPF(x, x1 + 1, x2) {\n                pii a = f(f, y1, x1, y2, x);\n                pii b = f(f, y1, x, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            REPF(y, y1 + 1, y2) {\n                pii a = f(f, y1, x1, y, x2);\n                pii b = f(f, y, x1, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            return MEMO = ret;\n        };\n\n        auto ans = rec(rec, 0, 0, h, w);\n        cout << ans.first << \" \" << s - (S - ans.second) << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma comment (linker, \"/STACK:526000000\")\n#define  _CRT_SECURE_NO_WARNINGS\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\npair<int, int> ans[32][32][32][32];\nint val[32][32] = {};\n\nint grid_val(pair<int, int> left, pair<int, int> right) {\n\tint ans = val[right.first][right.second];\n\tif (left.first != 0) {\n\t\tans -= val[left.first - 1][right.second];\n\t}\n\tif (left.second != 0) {\n\t\tans -= val[right.first][left.second - 1];\n\t}\n\tif (left.first != 0 && left.second != 0) {\n\t\tans += val[left.first - 1][left.second - 1];\n\t}\n\treturn ans;\n}\n\nint s;\n\npair<int, int> dfs(pair<int, int> left, pair<int, int> right) {\n\tif (ans[left.first][left.second][right.first][right.second].second != 1e9) return ans[left.first][left.second][right.first][right.second];\n\t//yoko\n\tpair<int, int> final_ans = mp(1, grid_val(left,right) - s);\n\tfor (int q = left.first + 1; q <= right.first; ++q) {\n\t\tif (grid_val(mp(left.first, left.second), mp(q - 1, right.second)) >= s) {\n\t\t\tif (grid_val(mp(q, left.second), mp(right.first, right.second)) >= s) {\n\t\t\t\tpair<int, int> now = dfs(mp(left.first, left.second), mp(q - 1, right.second));\n\t\t\t\tpair<int,int> tmp = dfs(mp(q, left.second), mp(right.first, right.second));\n\t\t\t\tnow.first += tmp.first;\n\t\t\t\tnow.second = min(tmp.second,now.second);\n\t\t\t\tif (final_ans.first < now.first||(final_ans.first == now.first&&final_ans.second < now.second)) {\n\t\t\t\t\tfinal_ans = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int q = left.second + 1; q <= right.second; ++q) {\n\t\tif (grid_val(mp(left.first, left.second), mp(right.first, q-1)) >= s) {\n\t\t\tif (grid_val(mp(left.first,q), mp(right.first, right.second)) >= s) {\n\t\t\t\tpair<int, int> now = dfs(mp(left.first, left.second), mp(right.first, q - 1));\n\t\t\t\tpair<int, int> tmp = dfs(mp(left.first, q), mp(right.first, right.second));\n\t\t\t\tnow.first += tmp.first;\n\t\t\t\tnow.second = min(tmp.second, now.second);\n\t\t\t\tif (final_ans.first < now.first || (final_ans.first == now.first && final_ans.second < now.second)) {\n\t\t\t\t\tfinal_ans = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans[left.first][left.second][right.first][right.second] = final_ans;\n}\n\nvoid solve(){\n\tvector<pair<int, int>> final_ans;\n\twhile (true) {\n\t\tint h, w;\n\t\tcin >> h >> w >> s;\n\t\tif (h == 0) {\n\t\t\tREP(i, final_ans.size()) {\n\t\t\t\tcout << final_ans[i].first << \" \" << final_ans[i].second << endl;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tREP(q, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tREP(t, h) {\n\t\t\t\t\tREP(p, w) {\n\t\t\t\t\t\tans[q][j][t][p] = mp(0, 1e9);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tcin >> val[i][q];\n\t\t\t\tif (q != 0) val[i][q] += val[i][q - 1];\n\t\t\t}\n\t\t}\n\t\tREP(q, w) {\n\t\t\tfor (int i = 1; i < h; ++i) {\n\t\t\t\tval[i][q] += val[i - 1][q];\n\t\t\t}\n\t\t}\n\t\ts = val[h - 1][w - 1] - s;\n\t\tpair<int, int> ans = dfs(mp(0, 0), mp(h - 1, w - 1));\n\t\tfinal_ans.push_back(ans);\n\t}\n}\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\npii dp[32][32][32][32];\nsigned main() {\n    while (1) {\n        REP(i, 32) REP(j, 32) REP(k, 32) REP(l, 32) dp[i][j][k][l] = {INF, INF};\n\n        int h, w, s;\n        cin >> h >> w >> s;\n        vector<vector<int>> u(h, vector<int>(w));\n        cin >> u;\n\n        int S = 0;\n        FORE(r, u) FORE(c, r) S += c;\n        int mn = S - s;\n\n        auto rec = [&](auto f, int y1, int x1, int y2, int x2) -> pii {\n            auto &MEMO = dp[y1][x1][y2][x2];\n            if (MEMO.first != INF) return MEMO;\n\n            int ps = 0;\n            REPF(x, x1, x2) {\n                REPF(y, y1, y2) {\n                    ps += u[y][x];\n                }\n            }\n\n            pii ret = {1, ps};\n            REPF(x, x1 + 1, x2) {\n                pii a = f(f, y1, x1, y2, x);\n                pii b = f(f, y1, x, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            REPF(y, y1 + 1, y2) {\n                pii a = f(f, y1, x1, y, x2);\n                pii b = f(f, y, x1, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            return MEMO = ret;\n        };\n\n        auto ans = rec(rec, 0, 0, h, w);\n        cout << ans.first << \" \" << s - (S - ans.second) << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint H, W, S;\nint U[32][32];\nint UU[33][33];\n\nint getUsum(int sx, int sy, int tx, int ty)\n{\n\treturn (UU[ty + 1][tx + 1] - UU[ty + 1][sx] - UU[sy][tx + 1] + UU[sy][sx]);\n}\n\nint Usum, Glimit;\n\nbool ismemo[32][32][32][32];\npair<int, int> memo[32][32][32][32];\n\npair<int, int> rec(int sx, int sy, int tx, int ty)\n{\n\tif (ismemo[sx][sy][tx][ty]) return memo[sx][sy][tx][ty];\n\n\tif (getUsum(sx, sy, tx, ty) < Glimit)\n\t{\n\t\tismemo[sx][sy][tx][ty] = true;\n\t\treturn memo[sx][sy][tx][ty] = pair<int, int>(0, INF);\n\t}\n\n\tpair<int, int> ans(1, getUsum(sx, sy, tx, ty));\n\trep(x, sx, tx)\n\t{\n\t\tauto le = rec(sx, sy, x, ty);\n\t\tif (le.first == 0) continue;\n\t\tauto ri = rec(x + 1, sy, tx, ty);\n\t\tif (ri.first == 0) continue;\n\n\t\tint gnum = le.first + ri.first;\n\t\tint sum = min(le.second, ri.second);\n\n\t\tif (ans.first < gnum)\n\t\t{\n\t\t\tans.first = gnum;\n\t\t\tans.second = sum;\n\t\t}\n\t\telse if (ans.first == gnum)\n\t\t{\n\t\t\tans.second = max(ans.second, sum);\n\t\t}\n\t}\n\n\trep(y, sy, ty)\n\t{\n\t\tauto le = rec(sx, sy, tx, y);\n\t\tif (le.first == 0) continue;\n\t\tauto ri = rec(sx, y + 1, tx, ty);\n\t\tif (ri.first == 0) continue;\n\n\t\tint gnum = le.first + ri.first;\n\t\tint sum = min(le.second, ri.second);\n\n\t\tif (ans.first < gnum)\n\t\t{\n\t\t\tans.first = gnum;\n\t\t\tans.second = sum;\n\t\t}\n\t\telse if (ans.first == gnum)\n\t\t{\n\t\t\tans.second = max(ans.second, sum);\n\t\t}\n\t}\n\n\tismemo[sx][sy][tx][ty] = true;\n\treturn memo[sx][sy][tx][ty] = ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> H >> W >> S)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(y, 0, H) rep(x, 0, W) cin >> U[y][x];\n\t\trep(y, 0, H + 1) rep(x, 0, W + 1) UU[y][x] = 0;\n\t\trep(y, 1, H + 1) rep(x, 1, W + 1) UU[y][x] = U[y - 1][x - 1] + UU[y - 1][x] + UU[y][x - 1] - UU[y - 1][x - 1];\n\n\t\tUsum = getUsum(0, 0, W - 1, H - 1);\n\t\tGlimit = Usum - S;\n\n\t\trep(i, 0, 32) rep(ii, 0, 32) rep(j, 0, 32) rep(jj, 0, 32) ismemo[i][ii][j][jj] = false;\n\t\tauto ans = rec(0, 0, W - 1, H - 1);\n\n\t\tcout << ans.first << \" \" << (ans.second - Glimit) << endl;\n\n\t\t//return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint H, W, S;\nint U[32][32];\npair<int,int> memo[32][32][32+1][32+1];\nint sum[32+1][32+1];\nvoid init() {\n    for (int i = 0; i < 32; ++i) {\n    for (int j = 0; j < 32; ++j) {\n    for (int k = 0; k < 32+1; ++k) {\n    for (int l = 0; l < 32+1; ++l) {\n        memo[i][j][k][l] = { -1, -1 };\n    }\n    }\n    }\n    }\n    for (int y = 0; y < H+1; ++y) sum[y][0] = 0;\n    for (int x = 0; x < W+1; ++x) sum[0][x] = 0;\n    for (int y = 1; y < H+1; ++y) {\n        for (int x = 1; x < W+1; ++x) {\n            sum[y][x] = U[y-1][x-1] + sum[y-1][x] + sum[y][x-1] - sum[y-1][x-1];\n        }\n    }\n}\nint sum_rect(int y, int x, int ey, int ex) {\n    return sum[ey][ex] - sum[ey][x] - sum[y][ex] + sum[y][x];\n}\npair<int,int> solve(int y, int x, int ey, int ex) {\n    if (memo[y][x][ey][ex].first != -1) return memo[y][x][ey][ex];\n// cerr << \"f \" << y << \" \" << x << ' ' << ey << ' ' << ex << endl;\n    if (S < sum[H][W] - sum_rect(y,x,ey,ex)) return memo[y][x][ey][ex] = { -1000000, 0 };\n    pair<int,int> p = { 1, sum_rect(y,x,ey,ex) };\n    for (int i = y+1; i < ey; ++i) {\n        pair<int,int> a = solve(y,x,i,ex);\n        if (a.first < 0) continue;\n        pair<int,int> b = solve(i,x,ey,ex);\n        if (b.first < 0) continue;\n        p = max(p, make_pair( a.first + b.first, min(a.second, b.second) ));\n    }\n    for (int i = x+1; i < ex; ++i) {\n        pair<int,int> a = solve(y,x,ey,i);\n        if (a.first < 0) continue;\n        pair<int,int> b = solve(y,i,ey,ex);\n        if (b.first < 0) continue;\n        p = max(p, make_pair( a.first + b.first, min(a.second, b.second) ));\n    }\n    return memo[y][x][ey][ex] = p;\n}\nint main() {\n    while (true) {\n        cin >> H >> W >> S;\n        if (H == 0 and W == 0 and S == 0) break;\n        for (int y = 0; y < H; ++y) {\n            for (int x = 0; x < W; ++x) {\n                cin >> U[y][x];\n            }\n        }\n        init();\n        pair<int,int> p = solve(0, 0, H, W);\n        cout << p.first << ' ' << (S + p.second - sum[H][W]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint H, W, S, U;\nint a[35][35];\nPii dp[35][35][35][35];\n\nPii merge(Pii p, Pii q) {\n    return Pii(p.first + q.first, min(p.second, q.second));\n}\n\nint calcSum(int x1, int y1, int x2, int y2) {\n    return a[x1][y1] - a[x2][y1] - a[x1][y2] + a[x2][y2];\n}\n\nPii dfs(int x1, int y1, int x2, int y2) {\n    Pii& ret = dp[x1][y1][x2][y2];    // (#group, mergin)\n    if (ret != Pii(0, inf)) return ret;\n\n    if (calcSum(x1, y1, x2, y2) >= U) {\n        ret = Pii(1, calcSum(x1, y1, x2, y2) - U);\n    }\n\n    rep2(c, y1 + 1, y2) {\n        ret = max(ret, merge(dfs(x1, y1, x2, c), dfs(x1, c, x2, y2)));\n    }\n    rep2(r, x1 + 1, x2) {\n        ret = max(ret, merge(dfs(x1, y1, r, y2), dfs(r, y1, x2, y2)));\n    }\n\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> H >> W >> S, H) {\n        rep(i, H + 1) rep(j, W + 1) a[i][j] = 0;\n        rep(i, H) rep(j, W) cin >> a[i][j];\n        rep(i, H) {\n            rrep(j, W) {\n                a[i][j] += a[i][j + 1];\n            }\n        }\n        rep(j, W) {\n            rrep(i, H) {\n                a[i][j] += a[i + 1][j];\n            }\n        }\n        U = calcSum(0, 0, H, W) - S;\n        assert(U > 0);\n\n        rep(i, H + 1) rep(j, W + 1) rep(k, H + 1) rep(l, W + 1) dp[i][j][k][l] = Pii(0, inf);\n        printP(dfs(0, 0, H, W));\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\n//各nodeには、グループ分けの個数と、その中での予備力の最大値をもつ。\nP ans[32][32][32][32];\nbool used[32][32][32][32];\nint sum[32][32][32][32];\nint h, w, s;\nint u[32][32];\nvoid init() {\n\trep(i, 32) {\n\t\trep(j, 32) {\n\t\t\trep(k, 32) {\n\t\t\t\trep(l, 32) {\n\t\t\t\t\tused[i][j][k][l] = false;\n\t\t\t\t\tsum[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tsum[0][0][i][j] = u[i][j];\n\t\t\tif (i > 0) {\n\t\t\t\tsum[0][0][i][j] += sum[0][0][i - 1][j];\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tsum[0][0][i][j] += sum[0][0][i][j - 1];\n\t\t\t}\n\t\t\tif (i > 0 && j > 0){\n\t\t\t\tsum[0][0][i][j] -= sum[0][0][i - 1][j - 1];\n\t\t    }\n\t\t}\n\t}\n\trep(lx, h) {\n\t\trep(ly, w) {\n\t\t\trep(rx, h) {\n\t\t\t\trep(ry, w) {\n\t\t\t\t\tsum[lx][ly][rx][ry] = sum[0][0][rx][ry];\n\t\t\t\t\tif (lx > 0) {\n\t\t\t\t\t\tsum[lx][ly][rx][ry] -= sum[0][0][lx - 1][ry];\n\t\t\t\t\t}\n\t\t\t\t\tif (ly > 0) {\n\t\t\t\t\t\tsum[lx][ly][rx][ry] -= sum[0][0][rx][ly - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (lx > 0 && ly > 0) {\n\t\t\t\t\t\tsum[lx][ly][rx][ry] += sum[0][0][lx - 1][ly - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nP dfs(int lx, int ly, int rx, int ry) {\n\tif (used[lx][ly][rx][ry])return ans[lx][ly][rx][ry];\n\tused[lx][ly][rx][ry] = true;\n\tP res = { 1,s-(sum[0][0][h-1][w-1]-sum[lx][ly][rx][ry]) };\n\t//cout << lx << \" \" << ly << \" \" << rx << \" \" << ry << \" \" << res.second << endl;\n\tif (res.second < 0) {\n\t\tres.first = -mod;\n\t}\n\tRep(x, lx, rx) {\n\t\tP s1 = dfs(lx, ly, x, ry); P s2 = dfs(x + 1, ly, rx, ry);\n\t\tP s3 = { s1.first + s2.first,min(s1.second, s2.second) };\n\t\tres = max(res, s3);\n\t}\n\tRep(y, ly, ry) {\n\t\tP s1 = dfs(lx, ly, rx, y); P s2 = dfs(lx, y + 1, rx, ry);\n\t\tP s3 = { s1.first + s2.first,min(s1.second , s2.second) };\n\t\tres = max(res, s3);\n\t}\n\treturn ans[lx][ly][rx][ry] = res;\n}\nint main(){\n\twhile (cin >> h >> w >> s, h) {\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> u[i][j];\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tP out = dfs(0, 0, h - 1, w - 1);\n\t\tcout << out.first << \" \" << out.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint h, w, s, U;\nint u[33][33];\nP dp[33][33][33][33];\n\nint get_sum(int ai, int aj, int bi, int bj){\n    return u[bi][bj] - u[bi][aj] - u[ai][bj] + u[ai][aj];\n}\n\n// 左上(ai,aj),右下(bi,bj)の矩形\nP rec(int ai, int aj, int bi, int bj){\n    if(dp[ai][aj][bi][bj] != make_pair(-1,-1)){\n        return dp[ai][aj][bi][bj];\n    }\n\n    P res = {0, 0};\n    // そのまま\n    if(U - get_sum(ai, aj, bi, bj) <= s){\n        res = {1, s - U + get_sum(ai, aj, bi, bj)};\n    }\n    // 上下に分割\n    for(int ni = ai+1; ni<bi; ni++){\n        P x, y;\n        x = rec(ai, aj, ni, bj);\n        y = rec(ni, aj, bi, bj);\n        x.first += y.first;\n        x.second = min(x.second, y.second);\n        res = max(res, x);\n    }\n    // 左右に分割\n    for(int nj = aj+1; nj<bj; nj++){\n        P x, y;\n        x = rec(ai, aj, bi, nj);\n        y = rec(ai, nj, bi, bj);\n        x.first += y.first;\n        x.second = min(x.second, y.second);\n        res = max(res, x);\n    }\n    return dp[ai][aj][bi][bj] = res;\n}\n\nint main() {\n    while(cin >> h >> w >> s, h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> u[i+1][j+1];\n                u[i+1][j+1] += u[i][j+1] + u[i+1][j] - u[i][j];\n            }\n        }\n        U = u[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                for(int k=0;k<=h;k++){\n                    fill(dp[i][j][k], dp[i][j][k]+w+1, make_pair(-1,-1));\n                }\n            }\n        }\n        P ans = rec(0,0,h,w);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint group(vector<vector<int>> &S, int d){\n  int h = S.size() - 1;\n  int w = S[0].size() - 1;\n  vector<vector<vector<vector<int>>>> dp(h + 1, vector<vector<vector<int>>>(h + 1, vector<vector<int>>(w + 1, vector<int>(w + 1, -INF))));\n  for (int height = 0; height <= h; height++){\n    for (int width = 0; width <= w; width++){\n      for (int y1 = 0; y1 <= h - height; y1++){\n        for (int x1 = 0; x1 <= w - width; x1++){\n          int y2 = y1 + height;\n          int x2 = x1 + width;\n          if (S[y2][x2] - S[y2][x1] - S[y1][x2] + S[y1][x1] >= d){\n            dp[y1][y2][x1][x2] = 1;\n          }\n          for (int k = x1 + 1; k < x2; k++){\n            dp[y1][y2][x1][x2] = max(dp[y1][y2][x1][x2], dp[y1][y2][x1][k] + dp[y1][y2][k][x2]);\n          }\n          for (int k = y1 + 1; k < y2; k++){\n            dp[y1][y2][x1][x2] = max(dp[y1][y2][x1][x2], dp[y1][k][x1][x2] + dp[k][y2][x1][x2]);\n          }\n        }\n      }\n    }\n  }\n  return dp[0][h][0][w];\n}\nint main(){\n  while (1){\n    int h, w, s;\n    cin >> h >> w >> s;\n    if (h == 0 && w == 0 && s == 0){\n      break;\n    }\n    vector<vector<int>> u(h, vector<int>(w));\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        cin >> u[i][j];\n      }\n    }\n    vector<vector<int>> S(h + 1, vector<int>(w + 1, 0));\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        S[i + 1][j + 1] = u[i][j];\n      }\n    }\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        S[i][j] += S[i][j - 1];\n      }\n    }\n    for (int j = 1; j <= w; j++){\n      for (int i = 1; i <= h; i++){\n        S[i][j] += S[i - 1][j];\n      }\n    }\n    int d = S[h][w] - s;\n    int ans1 = group(S, d);\n    int tv = d;\n    int fv = S[h][w] + 1;\n    while (fv - tv > 1){\n      int mid = (tv + fv) / 2;\n      if (group(S, mid) == ans1){\n        tv = mid;\n      } else {\n        fv = mid;\n      }\n    }\n    int ans2 = tv - d;\n    cout << ans1 << ' ' << ans2 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cerr\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\npair<int, int> dp[32][32][32][32];\nint rsum[33][33];\nint psum[33][33][33][33];\nvector<vector<int>> g(32, vector<int>(32, 0));\n\n//(x1, y1):左上, (x2, y2):右下\npair<int, int> dfs(int y1, int x1, int y2, int x2, int total, int limit) {\n  //cerr << y1 << \" \" << x1 << \" \" << y2 << \" \" << x2 << endl;\n  if (dp[y1][x1][y2][x2].second != 0) return dp[y1][x1][y2][x2];\n  //何もしない\n  if (total - psum[y1+1][x1+1][y2+1][x2+1] <= limit) {\n    dp[y1][x1][y2][x2] = {limit - (total - psum[y1+1][x1+1][y2+1][x2+1]), 1};\n  }\n  else {\n    //これ以上はどう頑張っても分割不可\n    return dp[y1][x1][y2][x2];\n  }\n  //水平に切る\n  for (int i = y1; i < y2; i++) {\n    //上側\n    int ny1 = y1;\n    int nx1 = x1;\n    int ny2 = i;\n    int nx2 = x2;\n    pair<int, int> up = dfs(ny1, nx1, ny2, nx2, total, limit);\n    //下側\n    ny1 = i+1;\n    nx1 = x1;\n    ny2 = y2;\n    nx2 = x2;\n    pair<int, int> bt = dfs(ny1, nx1, ny2, nx2, total, limit);\n    if (up.second == 0 || bt.second == 0) continue; // 分割できなかった\n    int cnt = up.second + bt.second;\n    if (dp[y1][x1][y2][x2].second < cnt) {\n        dp[y1][x1][y2][x2] = {min(up.first, bt.first), cnt};\n    }\n    else if (dp[y1][x1][y2][x2].second == cnt) {\n      if (dp[y1][x1][y2][x2].first < min(up.first, bt.first)) {\n        dp[y1][x1][y2][x2] = {min(up.first, bt.first), cnt};\n      }\n    }\n  }\n  //垂直に切る\n  for (int j = x1; j < x2; j++) {\n    //左側\n    int ny1 = y1;\n    int nx1 = x1;\n    int ny2 = y2;\n    int nx2 = j;\n    pair<int, int> l = dfs(ny1, nx1, ny2, nx2, total, limit);\n    //右側\n    ny1 = y1;\n    nx1 = j+1;\n    ny2 = y2;\n    nx2 = x2;\n    pair<int, int> r = dfs(ny1, nx1, ny2, nx2, total, limit);\n    int cnt = l.second + r.second;\n    if (l.second == 0 || r.second == 0) continue; // 分割できなかった\n    if (dp[y1][x1][y2][x2].second < cnt) {\n        dp[y1][x1][y2][x2] = {min(l.first, r.first), cnt};\n    }\n    else if (dp[y1][x1][y2][x2].second == cnt) {\n      if (dp[y1][x1][y2][x2].first < min(l.first, r.first)) {\n        dp[y1][x1][y2][x2] = {min(l.first, r.first), cnt};\n      }\n    }\n  }\n  return dp[y1][x1][y2][x2];\n}\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while (true) {\n    int h, w, s;\n    cin >> h >> w >> s;\n    if (h == 0) break;\n    int total = 0;\n    rep(i, h)rep(j, w) {\n      cin >> g[i][j];\n      total += g[i][j];\n    }\n    int limit =   s;\n    rep(i, 33)rep(j, 33)rep(k, 33)rep(l, 33) psum[i][j][k][l] = 0;\n    rep(i, 33)rep(j, 33) rsum[i][j] = 0;\n    rep(i, h)rep(j, w) {\n      rsum[i+1][j+1] = rsum[i+1][j] + rsum[i][j+1] - rsum[i][j] + g[i][j];\n    }\n    rep(i, h)rep(j, w)rep(k, h)rep(l, w) {\n      psum[i+1][j+1][k+1][l+1] = rsum[k+1][l+1] - rsum[i][l+1] - rsum[k+1][j] + rsum[i][j];\n    }\n    rep(i, 32)rep(j, 32)rep(k, 32)rep(l, 32) dp[i][j][k][l] = {INF, 0};\n    pair<int, int> ans = dfs(0, 0, h-1, w-1, total, limit);\n    cout << ans.second << \" \" << ans.first << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nint sum;\nint h, w, s;\nvvi cells;\nvvi wa;\npii dp[32][32][32][32];\npii dfs(int lx,int ly,int rx,int ry) {\n\tif (dp[lx][ly][rx][ry].first != -1)\n\t\treturn dp[lx][ly][rx][ry];\n\tint kukanwa = wa[ry][rx];\n\tif (ly - 1 >= 0)\n\t\tkukanwa -= wa[ly - 1][rx];\n\tif (lx - 1 >= 0)\n\t\tkukanwa -= wa[ry][lx - 1];\n\tif (ly - 1 >= 0&& lx - 1 >= 0)\n\t\tkukanwa += wa[ly - 1][lx - 1];\n\tpii res = {1,s-(sum-kukanwa)};\n\tif (res.second < 0)\n\t\treturn{ -1e9,1e9 };\n\t//vdiv\n\tFOR(i, lx + 1, rx+1) {\n\t\tpii p1 = dfs(lx, ly, i-1, ry);\n\t\tpii p2 = dfs(i, ly, rx, ry);\n\t\tpii res2 = { p1.first + p2.first,min(p1.second,p2.second) };\n\t\tres = max(res, res2);\n\t}\n\t//hdiv\n\tFOR(i, ly + 1, ry + 1) {\n\t\tpii p1 = dfs(lx, ly, rx, i-1);\n\t\tpii p2 = dfs(lx, i, rx, ry);\n\t\tpii res2 = { p1.first + p2.first,min(p1.second,p2.second) };\n\t\tres = max(res, res2);\n\t}\n\tdp[lx][ly][rx][ry] = res;\n\treturn res;\n}\nint main() {\n\twhile (cin>>h>>w>>s,h) {\n\t\tsum=0;\n\t\tcells.clear();\n\t\tcells.resize(h, vi(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> cells[i][j];\n\t\t\t\tsum += cells[i][j];\n\t\t\t}\n\t\t}\n\t\twa = cells;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twa[i][j] += wa[i - 1][j];\n\t\t\t\tif (j != 0)\n\t\t\t\t\twa[i][j] += wa[i][j-1];\n\t\t\t\tif(i!=0&&j!=0)\n\t\t\t\t\twa[i][j] -= wa[i-1][j - 1];\n\t\t\t}\n\t\t}\n\t\tREP(i, h)\n\t\t\tREP(j, w)\n\t\t\tREP(k, h)\n\t\t\tREP(l, w)\n\t\t\tdp[j][i][l][k] = {-1,0};\n\t\tpii p=dfs(0,0,w-1,h-1);\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, T;\nvector< vector<int> > A;\nbool m1[40][40][40][40];\nP m2[40][40][40][40];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, getM(x1, y1, x2, y2)-T);\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> T, H || W || T) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[0][0][0]+40*40*40, false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tT = sum - T;\n\t\tassert(T >= 0);\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi G;\npii dp[50][50][50][50];\nint n,m,q,sum;\npii f(int a,int b,int c,int d){\n\tif(dp[a][b][c][d].first!=inf)return dp[a][b][c][d];\n\tdp[a][b][c][d]=pii(0,0);\n\tdp[a][b][c][d].second=G[c][d]-G[a][d]-G[c][b]+G[a][b];\n//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<dp[a][b][c][d].second<<endl;\n//\tloop(i,a,c)loop(j,b,d)dp[a][b][c][d].second+=G[i][j];\n\trep(i,c-a-1){\n\t\tpii ta=f(a,b,a+i+1,d);\n\t\tpii tb=f(a+i+1,b,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\trep(i,d-b-1){\n\t\tpii ta=f(a,b,c,b+i+1);\n\t\tpii tb=f(a,b+i+1,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\tif(dp[a][b][c][d].second<sum)dp[a][b][c][d]=pii(-inf,-inf);\n//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n//\tcout<<dp[a][b][c][d].first<<\" \"<<dp[a][b][c][d].second<<endl;\n\treturn dp[a][b][c][d];\n}\nint main(){\n\twhile(cin>>n>>m>>q,n+m+q){\n\t\tsum=-q;\n\t\tG=vvi(n+1,vi(m+1));\n\t\trep(i,n)rep(j,m)cin>>G[i+1][j+1];\n\t\trep(i,n)rep(j,m)G[i+1][j+1]+=G[i][j+1]+G[i+1][j]-G[i][j];\n\t\tsum=G[n][m]-q;\n\t\trep(i,50)rep(j,50)rep(k,50)rep(l,50)\n\t\t\tdp[i][j][k][l]=pii(inf,inf);\n\t\tf(0,0,n,m);\n\t\tcout<<1+dp[0][0][n][m].first<<\" \"<<dp[0][0][n][m].second-sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<20)\nint h,w,s;\nint u[32][32];\nstruct Group{\n\tint n,yobi;\n}dp[32][32][32][32];\n\nint total[32][32];\nint calc(int y1,int y2,int x1,int x2){\n\tint a,b,c,d;\n\tb=c=d=0;\n\ta = total[y2][x2];\n\tif(x1)b = total[y2][x1-1];\n\tif(y1)c = total[y1-1][x2];\n\tif(y1&&x1)d = total[y1-1][x1-1];\n\treturn a-b-c+d;\n}\nGroup dfs(int y1,int y2,int x1,int x2){\n\tif(dp[y1][y2][x1][x2].n!=-1)return dp[y1][y2][x1][x2];\n\tGroup res={-1,-1},a,b,t;\n\tif(s<total[h-1][w-1]-calc(y1,y2,x1,x2)){\n\t\tres.n = -INF;\n\t\treturn dp[y1][y2][x1][x2]=res;\n\t}\n\tres.n = 1;\n\tres.yobi = s-(total[h-1][w-1]-calc(y1,y2,x1,x2));\n\tfor(int i=x1;i<x2;i++){\n\t\ta = dfs(y1,y2,x1,i);\n\t\tb = dfs(y1,y2,i+1,x2);\n\t\tt.n = a.n+b.n;\n\t\tt.yobi = min(a.yobi,b.yobi);\n\t\tif(res.n < t.n)res = t;\n\t\telse if(res.n==t.n && res.yobi<t.yobi)res=t;\n\t}\n\tfor(int i=y1;i<y2;i++){\n\t\ta = dfs(y1,i,x1,x2);\n\t\tb = dfs(i+1,y2,x1,x2);\n\t\tt.n = a.n+b.n;\n\t\tt.yobi = min(a.yobi,b.yobi);\n\t\tif(res.n < t.n)res = t;\n\t\telse if(res.n==t.n && res.yobi<t.yobi)res=t;\n\t}\n\treturn dp[y1][y2][x1][x2]=res;\n}\nint main(){\n\t\n\twhile(cin>>h>>w>>s,h|w|s){\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>u[y][x];\n\t\t\t\ttotal[y][x] = u[y][x];\n\t\t\t}\n\t\tfor(int y=1;y<h;y++)total[y][0] += total[y-1][0];\n\t\tfor(int x=1;x<w;x++)total[0][x] += total[0][x-1];\n\t\tfor(int y=1;y<h;y++)\n\t\t\tfor(int x=1;x<w;x++)\n\t\t\t\ttotal[y][x] += total[y-1][x]+total[y][x-1]-total[y-1][x-1];\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tGroup ans = dfs(0,h-1,0,w-1);\n\t\tcout<<ans.n<<' '<<ans.yobi<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1048576 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", ret >> 20, (ret - 0) & 1048575);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "typedef pair<int,int> P;\n\nint h,w,s,all,t[32][32];\nint rec[32][32][32][32]; //長方形の合計[ly][lx][hy][hx]\nP dp[32][32][32][32]; //メモ化\n\n//全ての(lx,ly)〜(hx,hy)の長方形合計を計算\nvoid mkRec(){\n  memset(rec,0,sizeof(rec));\n\n  rep(i,h){\n    rep(j,w){\n      rec[i][j][i][j] = t[i][j];\n\n      for(int y=i-1;y>=0;y--)\n        rec[y][j][i][j] = rec[y+1][j][i][j] + t[y][j];\n\n      for(int y=i;y>=0;y--){\n        int sum = 0;\n        for(int x=j;x>=0;x--){\n          sum += rec[y][x][i][x];\n          rec[y][x][i][j] = sum;\n        }\n      }\n    }\n  }\n}\n\n//戻り型 : P. first : 最大グループ数. second : 最大予備力\nP dfs(int lx,int ly,int hx,int hy){\n  if(dp[ly][lx][hy][hx].first != 0) return dp[ly][lx][hy][hx];\n\n  P res = P(1,s-(all-rec[ly][lx][hy][hx]));\n\n  //水平分割\n  for(int i=ly;i<hy;i++){\n    if(all - rec[ly][lx][i][hx] > s ||\n       all - rec[i+1][lx][hy][hx] > s) continue;\n    P a = dfs(lx,ly,hx,i);\n    P b = dfs(lx,i+1,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  //垂直分割\n  for(int j=lx;j<hx;j++){\n    if(all - rec[ly][lx][hy][j] > s ||\n       all - rec[ly][j+1][hy][hx] > s) continue;\n    P a = dfs(lx,ly,j,hy);\n    P b = dfs(j+1,ly,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  return dp[ly][lx][hy][hx] = res;\n}\n\nint main(void){\n  while(scanf(\"%d%d%d\",&h,&w,&s),h||w||s){\n    all = 0;\n    rep(i,h){\n      rep(j,w){\n        scanf(\"%d\",&t[i][j]);\n        all += t[i][j];\n      }\n    }\n\n    mkRec();\n\n    memset(dp,0,sizeof(dp));\n    P p = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",p.first,p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\npii dp[33][33][33][33];\nsigned main() {\n    while (1) {\n        REP(i, 33) REP(j, 33) REP(k, 33) REP(l, 33) dp[i][j][k][l] = {INF, INF};\n\n        int h, w, s;\n        cin >> h >> w >> s;\n        if (h == 0 && w == 0 && s == 0) break;\n        vector<vector<int>> u(h, vector<int>(w));\n        cin >> u;\n\n        int S = 0;\n        FORE(r, u) FORE(c, r) S += c;\n        int mn = S - s;\n\n        REP(i, h) REP(j, w - 1) u[i][j + 1] += u[i][j];\n        REP(i, w) REP(j, h - 1) u[j + 1][i] += u[j][i];\n\n        auto rec = [&](auto f, int y1, int x1, int y2, int x2) -> pii {\n            auto &MEMO = dp[y1][x1][y2][x2];\n            if (MEMO.first != INF) return MEMO;\n\n            int ps = u[y2 - 1][x2 - 1]\n                        - (x1 > 0 ? u[y2 - 1][x1 - 1] : 0)\n                        - (y1 > 0 ? u[y1 - 1][x2 - 1] : 0)\n                        + (x1 > 0 && y1 > 0 ? u[y1 - 1][x1 - 1] : 0);\n\n            pii ret = {1, ps};\n            REPF(x, x1 + 1, x2) {\n                pii a = f(f, y1, x1, y2, x);\n                pii b = f(f, y1, x, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            REPF(y, y1 + 1, y2) {\n                pii a = f(f, y1, x1, y, x2);\n                pii b = f(f, y, x1, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            return MEMO = ret;\n        };\n\n        auto ans = rec(rec, 0, 0, h, w);\n        cout << ans.first << \" \" << s - (S - ans.second) << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> result;\nint h,w,s;\nresult dp[33][33][33][33];\nbool done[33][33][33][33];\nint sum[33][33];\nint g[33][33];\n\nint get(int a,int b,int c,int d)\n{\n  return sum[d][c]-sum[b][c]-sum[d][a]+sum[b][a];\n}\n\nresult solve(int a,int b,int c,int d)\n{\n  result& res = dp[a][b][c][d];\n  if( done[a][b][c][d] ) return res;\n  res = result(1,s-(get(0,0,w,h)-get(a,b,c,d)));\n  //printf(\"%d %d %d %d\\n\",a,b,c,d);\n  if( res.second < 0 ) res = result(0,0);\n  for( int i = a+1; i < c; i++ ) {\n    result p = solve(a,b,i,d);\n    result q = solve(i,b,c,d);\n    res = max(res,result(p.first+q.first,min(p.second,q.second)));\n  }\n  for( int i = b+1; i < d; i++ ) {\n    result p = solve(a,b,c,i);\n    result q = solve(a,i,c,d);\n    res = max(res,result(p.first+q.first,min(p.second,q.second)));\n  }\n  done[a][b][c][d] = true;\n  return res;\n}\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d%d\",&h,&w,&s); if(h+w+s==0)break;\n    for( int i = 0; i < h; i++ ) {\n      for( int j = 0; j < w; j++ ) {\n        scanf(\"%d\", g[i]+j);\n      }\n    }\n    for( int i = 0; i < h; i++ ) {\n      for( int j = 0; j < w; j++ ) {\n        sum[i+1][j+1] = sum[i+1][j]+g[i][j];\n      }\n    }\n    for( int i = 0; i < h; i++ ) {\n      for( int j = 0; j <= w; j++ ) {\n        sum[i+1][j] += sum[i][j];\n      }\n    }\n    memset(done,0,sizeof(done));\n    result res = solve(0,0,w,h);\n    if( w == 1 && h == 1 ) res = result(1,0);\n    printf(\"%d %d\\n\",res.first,res.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define N 32\n#define INF (1e8)\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\npii dp[N+1][N+1][N+1][N+1];\nint h,w,s,sum,l;\nint u[N][N];\n\npii add(pii a,pii b){\n\tpii r = make_pair(a.first+b.first,min(a.second,b.second));\n\treturn r;\n}\n\npii dfs(int x0,int y0,int x1,int y1){\n\tif(dp[x0][y0][x1][y1].first > 0)return dp[x0][y0][x1][y1];\n\tpii r;\n\tint p=0;\n\tfor(int i=x0;i<x1;i++)for(int j=y0;j<y1;j++)p+=u[i][j];\n\tr = make_pair(1,p);\n\tfor(int i=x0+1;i<x1;i++){\n\t\tpii t = add( dfs(x0,y0,i,y1), dfs(i,y0,x1,y1) );\n\t\tif(t.second >= l) r = max(r,t);\n\t}\n\tfor(int i=y0+1;i<y1;i++){\n\t\tpii t = add( dfs(x0,y0,x1,i), dfs(x0,i,x1,y1) );\n\t\tif(t.second >= l) r = max(r,t);\n\t}\n\treturn dp[x0][y0][x1][y1] = r;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d%d%d\",&h,&w,&s);\n\t\tif(!(h*w*s))break;\n\t\tsum = 0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\trep(i,h)rep(j,w){\n\t\t\tscanf(\"%d\",u[i]+j);\n\t\t\tsum += u[i][j];\n\t\t}\n\t\tl = sum - s;\n\t\tpii ans = dfs(0,0,h,w);\n\t\tprintf(\"%d %d\\n\",ans.first,ans.second - l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,s,sum;\nstruct P{\n\tint y,x;\n\tP(){}\n\tP(int y,int x):y(y),x(x){}\n};\nP pmax(P a,P b){\n\tif(a.y!=b.y){\n\t\tif(a.y>b.y)\n\t\t\treturn a;\n\t\treturn b;\n\t}else{\n\t\tif(a.x>b.x)\n\t\t\treturn a;\n\t\treturn b;\n\t}\n}\nint u[32][32];\nP dp[32][32][32][32];\nP ret(P a,P b,int cnt){\n\tif(dp[a.y][a.x][b.y][b.x].y!=-1)\n\t\treturn dp[a.y][a.x][b.y][b.x];\n\tP ans(1,cnt);\n\tint s1=0,s2=0;\n\tfor(int i=a.y;i<b.y;i++){\n\t\tfor(int j=a.x;j<=b.x;j++){\n\t\t\ts1+=u[i][j];\n\t\t}\n\t\tif(sum-s1>s)\n\t\t\tcontinue;\n\t\tif(sum-(cnt-s1)>s)\n\t\t\tbreak;\n\t\tP x=ret(a,P(i,b.x),s1),y=ret(P(i+1,a.x),b,cnt-s1);\n\t\tans=pmax(ans,P(x.y+y.y,min(x.x,y.x)));\n\t}\n\tfor(int i=a.x;i<b.x;i++){\n\t\tfor(int j=a.y;j<=b.y;j++){\n\t\t\ts2+=u[j][i];\n\t\t}\n\t\tif(sum-s2>s)\n\t\t\tcontinue;\n\t\tif(sum-(cnt-s2)>s)\n\t\t\tbreak;\n\t\tP x=ret(a,P(b.y,i),s2),y=ret(P(a.y,i+1),b,cnt-s2);\n\t\tans=pmax(ans,P(x.y+y.y,min(x.x,y.x)));\n\t}\n\treturn dp[a.y][a.x][b.y][b.x]=ans;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tsum=0;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w)\n\t\tdp[i][j][k][l]=P(-1,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>u[i][j];\n\t\t\tsum+=u[i][j];\n\t\t}\n\t\tP ans=ret(P(0,0),P(h-1,w-1),sum);\n\t\tcout<<ans.y<<\" \"<<s-(sum-ans.x)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define f first\n#define s second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h,w,s,u[34][34];\nP memo[34][34][34][34];\n\nP rec(int x1,int y1,int x2,int y2){\n\t\n\tP a,b,res;\n\t\n\tif(memo[x1][y1][x2][y2]!=P(0,INF))return memo[x1][y1][x2][y2];\n\t\n\tif(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])>s)return P(0,INF);\n\t\n\tres=P(1,s-(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])));\n\t\n\tfor(int i=y1+1;i<y2;i++){\n\t\ta=rec(x1,y1,x2,i);\n\t\tb=rec(x1,i,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\tfor(int i=x1+1;i<x2;i++){\n\t\ta=rec(x1,y1,i,y2);\n\t\tb=rec(i,y1,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\treturn memo[x1][y1][x2][y2]=res;\n}\n\nint main(void){\n\t\n\twhile(cin >> h >> w >> s,h++|w++|s){\n\t\t\n\t\tfill(u[0],u[33],0);\n\t\t\n\t\tfor(int i=0;i<34;i++)\n\t\t\tfor(int j=0;j<34;j++)\n\t\t\t\tfor(int k=0;k<34;k++)\n\t\t\t\t\tfor(int l=0;l<34;l++)memo[i][j][k][l]=P(0,INF);\n\t\t\n\t\tfor(int i=1;i<h;i++)\n\t\t\tfor(int j=1;j<w;j++)cin >> u[i][j];\n\t\t\n\t\tfor(int i=1;i<h;i++)\n\t\t\tfor(int j=1;j<w;j++)\n\t\t\t\tu[i][j]+=u[i-1][j]+u[i][j-1]-u[i-1][j-1];\n\t\t\n\t\tP ans=rec(1,1,w,h);\n\t\tcout << ans.f << \" \" << ans.s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint mp[35][35],smp[35][35],n,SUM=0,W,H;\nP mem[35][35][35][35];\nint used[35][35][35][35];\n\nint cal(int x1,int y1,int x2,int y2){\n  return smp[y2][x2]-(smp[y1-1][x2]+smp[y2][x1-1])+smp[y1-1][x1-1];\n}\n\nP dfs(int x,int y,int w,int h){\n  \n  if(used[x][y][w][h]++) return mem[x][y][w][h];\n\n  P res=P(1,n-(SUM-cal(x,y,w,h)));\n  for(int i=x;i!=w;i++){\n    int m=max(SUM-cal(x,y,i,h),SUM-cal(i+1,y,w,h));\n    if(m<=n){\n      P a=dfs(x,y,i,h);\n      P b=dfs(i+1,y,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n\n  for(int i=y;i!=h;i++){\n    int m=max(SUM-cal(x,y,w,i),SUM-cal(x,i+1,w,h));\n    if(m<=n){\n      P a=dfs(x,y,w,i);\n      P b=dfs(x,i+1,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n  return mem[x][y][w][h]=res;\n}\n\nint main(){\n  while(1){\n  cin>>H>>W>>n;\n  if(!H&&!W&&!n)break;\n\n  memset(mp,0,sizeof(mp)),memset(smp,0,sizeof(smp));\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)cin>>mp[i][j],smp[i][j]=mp[i][j];\n\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i][j+1]+=smp[i][j];\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i+1][j]+=smp[i][j];\n  SUM=smp[H][W];\n  P ans=dfs(1,1,W,H);\n  cout <<ans.first<<\" \"<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nint h, w, s;\nint U[33][33];\npair<int,int> DP[33][33][33][33];\nconst pair<int,int> zero(0,0);\nint rect_sum(int t, int l, int b, int r){\n  return U[b][r] - U[t][r] - U[b][l] + U[t][l];\n}\n\npair<int,int> dfs(int t, int l, int b, int r){\n  if(DP[t][l][b][r] != zero) return DP[t][l][b][r];\n  pair<int,int> ret(1,s-(U[h][w]-rect_sum(t,l,b,r)));\n  for(int i = t+1; i < b; ++i){\n    if(U[h][w] - min(rect_sum(t,l,i,r),rect_sum(i,l,b,r)) > s) continue;\n    pair<int,int> ret_l = dfs(t,l,i,r), ret_r = dfs(i,l,b,r);\n    pair<int,int> ret_(ret_l.first+ret_r.first, min(ret_l.second, ret_r.second));\n    ret = max(ret, ret_);\n  }\n  for(int i = l+1; i < r; ++i){\n    if(U[h][w] - min(rect_sum(t,l,b,i),rect_sum(t,i,b,r)) > s) continue;\n    pair<int,int> ret_l = dfs(t,l,b,i), ret_r = dfs(t,i,b,r);\n    pair<int,int> ret_(ret_l.first+ret_r.first, min(ret_l.second, ret_r.second));\n    ret = max(ret, ret_);\n  }\n  //cerr << \"t, l, b, r = \" << t << \" \" << l << \" \" << b << \" \" << r << \", ret = \" << ret.first << \", \" << ret.second << endl;\n  DP[t][l][b][r] = ret;\n  return ret;\n}\n\nint main(){\n  while(cin >> h >> w >> s, h){\n    for(int i = 0; i <= h; ++i) U[i][0] = 0;\n    for(int j = 0; j <= w; ++j) U[0][j] = 0;\n    for(int i = 0; i <= h; ++i)\n      for(int j = 0; j <= w; ++j)\n        for(int k = 0; k <= h; ++k)\n          for(int l = 0; l <= w; ++l)\n            DP[i][j][k][l] = zero;\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        cin >> U[i+1][j+1];\n    for(int i = 1; i <= h; ++i){\n      for(int j = 1; j <= w; ++j)\n        U[i][j] += U[i][j-1];\n      for(int j = 1; j <= w; ++j)\n        U[i][j] += U[i-1][j];\n    }\n    pair<int,int> ans = dfs(0,0,h,w);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nvvi G;\npii dp[33][33][33][33];\nint n,m,q,sum;\npii f(int a,int b,int c,int d){\n\tif(dp[a][b][c][d].first!=inf)return dp[a][b][c][d];\n\tdp[a][b][c][d]=pii(0,0);\n\tloop(i,a,c)loop(j,b,d)dp[a][b][c][d].second+=G[i][j];\n\trep(i,c-a-1){\n\t\tpii ta=f(a,b,a+i+1,d);\n\t\tpii tb=f(a+i+1,b,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\trep(i,d-b-1){\n\t\tpii ta=f(a,b,c,b+i+1);\n\t\tpii tb=f(a,b+i+1,c,d);\n\t\tif(min(ta.second,tb.second)==-inf)continue;\n\t\tif(dp[a][b][c][d].first<1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].first=1+ta.first+tb.first;\n\t\t\tdp[a][b][c][d].second=min(ta.second,tb.second);\n\t\t}else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n\t\t\tdp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n\t\t}\n\t}\n\tif(dp[a][b][c][d].second<sum)dp[a][b][c][d]=pii(-inf,-inf);\n//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n//\tcout<<dp[a][b][c][d].first<<\" \"<<dp[a][b][c][d].second<<endl;\n\treturn dp[a][b][c][d];\n}\nint main(){\n\twhile(cin>>n>>m>>q,n+m+q){\n\t\tsum=-q;\n\t\tG=vvi(n,vi(n));\n\t\trep(i,n)rep(j,m)cin>>G[i][j];\n\t\trep(i,n)rep(j,m)sum+=G[i][j];\n\t\trep(i,33)rep(j,33)rep(k,33)rep(l,33)\n\t\t\tdp[i][j][k][l]=pii(inf,inf);\n\t\tf(0,0,n,m);\n\t\tcout<<1+dp[0][0][n][m].first<<\" \"<<dp[0][0][n][m].second-sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint h,w,s;\nint cost[32][32];\nint sum[33][33];\nint num[32][32][32][32];\nint cap[32][32][32][32];\nint M;\n\nint calc_sum(int x1,int y1,int x2,int y2){\n\tx1++;y1++;x2++;y2++;\n\treturn sum[y2][x2]-sum[y2][x1-1]-sum[y1-1][x2]+sum[y1-1][x1-1];\n}\n\ntypedef pair<int,int> A;\n\nA dfs(int x1,int y1,int x2,int y2){\n\tif(num[y1][x1][y2][x2]>=0) return make_pair(num[y1][x1][y2][x2],cap[y1][x1][y2][x2]);\n\tif(calc_sum(x1,y1,x2,y2)<M) return make_pair(0,10000000);\n\tA res=make_pair(1,calc_sum(x1,y1,x2,y2)-M);\n\n\tfor(int x=x1;x+1<=x2;x++){\n\t\tif(calc_sum(x1,y1,x,y2)<M || calc_sum(x+1,y1,x2,y2)<M) continue;\n\t\tA ans1=dfs(x1,y1,x,y2);\n\t\tA ans2=dfs(x+1,y1,x2,y2);\n\t\tA temp=make_pair(ans1.first+ans2.first,min(ans1.second,ans2.second));\n\t\tif(temp.first>res.first) res=temp;\n\t\telse if(temp.first==res.first && temp.second>res.second) res=temp;\n\t}\n\n\tfor(int y=y1;y+1<=y2;y++){\n\t\tif(calc_sum(x1,y1,x2,y)<M || calc_sum(x1,y+1,x2,y2)<M) continue;\n\t\tA ans1=dfs(x1,y1,x2,y);\n\t\tA ans2=dfs(x1,y+1,x2,y2);\n\t\tA temp=make_pair(ans1.first+ans2.first,min(ans1.second,ans2.second));\n\t\tif(temp.first>res.first) res=temp;\n\t\telse if(temp.first==res.first && temp.second>res.second) res=temp;\n\t}\n\tnum[y1][x1][y2][x2]=res.first;\n\tcap[y1][x1][y2][x2]=res.second;\n\t\n\treturn res;\n}\n\nvoid solve()\n{\n\tmemset(num,-1,sizeof(num));\n\tmemset(sum,0,sizeof(sum));\n\tfor(int y=1;y<=h;y++){\n\t\tfor(int x=1;x<=w;x++){\n\t\t\tint t;cin>>t; \n\t\t\tcost[y-1][x-1]=t;\n\t\t\tsum[y][x]=sum[y][x-1];\n\t\t\tsum[y][x]+=cost[y-1][x-1];\n\t\t}\n\t}\n\n\tfor(int x=1;x<=w;x++){\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tsum[y][x]+=sum[y-1][x];\n\t\t}\n\t}\n\n\tM=calc_sum(0,0,w-1,h-1)-s;\n\tA Ans=dfs(0,0,w-1,h-1);\n\tcout<<Ans.first<<\" \"<<Ans.second<<endl;\n}\n\nint main()\n{\n\twhile(cin>>h>>w>>s && !(h==0 && w==0 && s==0)){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nint h,w,s;\npii dp[32][32][32][32];\nint field[32][32];\nint sumTbl[32][32];\nint fSum[32][32][32][32];\nint allSum;\n\npii dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[minx][miny][maxx][maxy].first!=-1)return dp[minx][miny][maxx][maxy];\n\t// »ÝÌé`Ìùva\n\tint sum=fSum[minx][miny][maxx][maxy];\n\tpii res(1,sum);\n\t// yÌÇ±©Åª\n\tfor(int i=miny;i<maxy;i++){\n\t\t// ªµ½ç»ê¼êÌÌæÌaðßA»ê¼êÌaªðð½·©²×é\n\t\tint sum1=fSum[minx][miny][maxx][i];\n\t\tint sum2=fSum[minx][i+1][maxx][maxy];\n\t\t// ðð½·\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\t// »ê¼êÌßèlðæ¾\n\t\t\tpii p1=dfs(minx,miny,maxx,i);\n\t\t\tpii p2=dfs(minx,i+1,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)res.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\tfor(int i=minx;i<maxx;i++){\n\t\t// ªµ½ç»ê¼êÌÌæÌaðßA»ê¼êÌaªðð½·©²×é\n\t\tint sum1=fSum[minx][miny][i][maxy];\n\t\tint sum2=fSum[i+1][miny][maxx][maxy];\n\t\t// ðð½·\n\t\tif(allSum-sum1<=s&&allSum-sum2<=s){\n\t\t\t// »ê¼êÌßèlðæ¾\n\t\t\tpii p1=dfs(minx,miny,i,maxy);\n\t\t\tpii p2=dfs(i+1,miny,maxx,maxy);\n\t\t\tif(res.first<p1.first+p2.first){\n\t\t\t\tres.first=p1.first+p2.first;\n\t\t\t\tres.second=min(p1.second,p2.second);\n\t\t\t}\n\t\t\telse if(res.first==p1.first+p2.first)res.second=max(res.second,min(p1.second,p2.second));\n\t\t}\n\t}\n\tdp[minx][miny][maxx][maxy].first=res.first;\n\tdp[minx][miny][maxx][maxy].second=res.second;\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&(h|w|s)){\n\t\tallSum=0;\n\t\tfor(int i=0;i<32;i++)\n\t\t\tfor(int j=0;j<32;j++)\n\t\t\t\tfor(int k=0;k<32;k++)\n\t\t\t\t\tfor(int l=0;l<32;l++)dp[i][j][k][l].first=dp[i][j][k][l].second=-1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tallSum+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(j==0)sumTbl[i][j]=field[i][j];\n\t\t\t\telse sumTbl[i][j]=sumTbl[i][j-1]+field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=i;k<h;k++){\n\t\t\t\t\tfor(int l=j;l<w;l++){\n\t\t\t\t\t\tfSum[j][i][l][k]=0;\n\t\t\t\t\t\t// s²ÆÉÁZ\n\t\t\t\t\t\tfor(int m=i;m<=k;m++){\n\t\t\t\t\t\t\tif(j!=0)fSum[j][i][l][k]+=sumTbl[m][l]-sumTbl[m][j-1];\n\t\t\t\t\t\t\telse fSum[j][i][l][k]+=sumTbl[m][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii res=dfs(0,0,w-1,h-1);\n\t\tcout<<res.first<<\" \"<<s-(allSum-res.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <iostream>\nusing namespace std;\n\nint dp[33][33][33][33][2];\n\nint get_sum(int sum_table[33][33], int sy, int sx, int ey, int ex) {\n\treturn sum_table[ey][ex]-sum_table[ey][sx]-sum_table[sy][ex]+sum_table[sy][sx];\n}\n\nint a = 24;\nint b = 0;\nint c = 32;\nint d = 1;\n\nvoid calc(int table[33][33], int sum_table[33][33], int *group, int *yojo, int dec, int sh, int sw, int eh, int ew) {\n\tif(dp[sh][sw][eh][ew][0]>=0) {\n\t\t*group = dp[sh][sw][eh][ew][0];\n\t\t*yojo = dp[sh][sw][eh][ew][1];\n\t\treturn;\n\t}\n\t*group = 1;\n\t*yojo = dec-get_sum(sum_table,sh,sw,eh,ew);\n\t//if(sh==a&&sw==b&&eh==c&&ew==d) cout << \"all\" << \" : \" << *group << \",\" << *yojo << endl;\n\tif(*yojo>0) {\n\t\t*group = 0;\n\t\tdp[sh][sw][eh][ew][0] = *group;\n\t\tdp[sh][sw][eh][ew][1] = *yojo;\n\t\treturn;\n\t}\n\tfor(int h = sh+1; h < eh; h++) {\n\t\tint _g1,_y1,_g2,_y2;\n\t\tcalc(table,sum_table,&_g1,&_y1,dec,sh,sw,h,ew);\n\t\tcalc(table,sum_table,&_g2,&_y2,dec,h,sw,eh,ew);\n\t\t//if(sh==a&&sw==b&&eh==c&&ew==d) cout << \"h=\" << h << \" : \" << _g1 << \",\" << _y1 << \",\" << _g2 << \",\" << _y2 << endl;\n\t\tif(_g1*_g2==0) continue;\n\t\tif(*group<=_g1+_g2) {\n\t\t\tif(*group<_g1+_g2) *yojo = max(_y1,_y2);\n\t\t\telse *yojo = min(*yojo,max(_y1,_y2));\n\t\t\t*group = _g1+_g2;\n\t\t}\n\t}\n\tfor(int w = sw+1; w < ew; w++) {\n\t\tint _g1,_y1,_g2,_y2;\n\t\tcalc(table,sum_table,&_g1,&_y1,dec,sh,sw,eh,w);\n\t\tcalc(table,sum_table,&_g2,&_y2,dec,sh,w,eh,ew);\n\t\t//if(sh==a&&sw==b&&eh==c&&ew==d) cout << \"w=\" << w << \" : \" << _g1 << \",\" << _y1 << \",\" << _g2 << \",\" << _y2 << endl;\n\t\tif(_g1*_g2==0) continue;\n\t\tif(*group<=_g1+_g2) {\n\t\t\tif(*group<_g1+_g2) *yojo = max(_y1,_y2);\n\t\t\telse *yojo = min(*yojo,max(_y1,_y2));\n\t\t\t*group = _g1+_g2;\n\t\t}\n\t}\n\t//if(sh==a&&sw==b&&eh==c&&ew==d) cout << \"bst\" << \" : \" << *group << \",\" << *yojo << endl;\n\tdp[sh][sw][eh][ew][0] = *group;\n\tdp[sh][sw][eh][ew][1] = *yojo;\n\t//cout << sh << \" \" << sw << \" \" << eh << \" \" << ew << \" : \" << *group << \" \" << *yojo << endl;\n}\n\nint main() {\n\twhile(true) {\n\t\tint h,w,s;\n\t\tcin >> h >> w >> s;\n\t\tif(h==0) break;\n\t\tint table[33][33];\n\t\tint sum_table[33][33] = {};\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tsum_table[i+1][j+1] = table[i][j]+sum_table[i+1][j]+sum_table[i][j+1]-sum_table[i][j];\n\t\t\t}\n\t\t}\n\t\t//cout << sum_table[h][w] << endl;\n\t\tmemset(dp, -1, 33*33*33*33*2*sizeof(int));\n\t\tint dec = get_sum(sum_table,0,0,h,w)-s;\n\t\tint group,yojo;\n\t\tcalc(table,sum_table,&group,&yojo,dec,0,0,h,w);\n\t\tcout << group << \" \" << (-yojo) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\ntypedef pair< int, int > P;\n\nint H,W,SUPPLY,SUM;\nint demand[32][32];\nP dp[32][32][32][32];\n\nint calc_demand_sum(int row1,int col1,int row2,int col2){\n\tint A = 0,B = 0,C = 0;\n\n\tif(row1 == 0 || col1 == 0){\n\t\tC = 0;\n\t}else{\n\t\tC = demand[row1-1][col1-1];\n\t}\n\n\tif(row1 == 0){\n\t\tB = 0;\n\t}else{\n\t\tB = demand[row1-1][col2];\n\t}\n\n\tif(col1 == 0){\n\t\tA = 0;\n\t}else{\n\t\tA = demand[row2][col1-1];\n\t}\n\n\treturn demand[row2][col2]-A-B+C;\n}\n\nP recursive(int row1,int col1,int row2,int col2){\n\n\t if(dp[row1][col1][row2][col2].first != -1)return dp[row1][col1][row2][col2];\n\n\t    P ret = P(-BIG_NUM, BIG_NUM);\n\n\t    int tmp_value = SUM - calc_demand_sum(row1,col1,row2,col2);\n\t    if(tmp_value <= SUPPLY) {\n\t        ret.first = 1;\n\t        ret.second = -tmp_value;\n\n\t        for(int bottom_row = row1; bottom_row < row2; bottom_row++){\n\n\t\t\t\tP ret_a = recursive(row1,col1,bottom_row,col2);\n\t\t\t\tif(ret_a.first == -BIG_NUM)continue;\n\t\t\t\tP ret_b = recursive(bottom_row+1,col1,row2,col2);\n\t\t\t\tif(ret_b.first == -BIG_NUM)continue;\n\n\t\t\t\tP ret_c;\n\t\t\t\tret_c.first = ret_a.first+ret_b.first;\n\t\t\t\tret_c.second = min(ret_a.second,ret_b.second);\n\n\t\t\t\tret = max(ret,ret_c);\n\t\t\t}\n\n\t\t\tfor(int mid_col = col1; mid_col < col2; mid_col++){\n\n\t\t\t\tP ret_a = recursive(row1,col1,row2,mid_col);\n\t\t\t\tif(ret_a.first == -BIG_NUM)continue;\n\t\t\t\tP ret_b = recursive(row1,mid_col+1,row2,col2);\n\t\t\t\tif(ret_b.first == -BIG_NUM)continue;\n\n\t\t\t\tP ret_c;\n\t\t\t\tret_c.first = ret_a.first+ret_b.first;\n\t\t\t\tret_c.second = min(ret_a.second,ret_b.second);\n\n\t\t\t\tret = max(ret,ret_c);\n\t\t\t}\n\t    }\n\t    return dp[row1][col1][row2][col2] = ret;\n}\n\nvoid func(){\n\n\tSUM = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&demand[row][col]);\n\t\t\tSUM += demand[row][col];\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 1; col < W; col++){\n\t\t\tdemand[row][col] += demand[row][col-1];\n\t\t}\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tfor(int row = 1; row < H; row++){\n\t\t\tdemand[row][col] += demand[row-1][col];\n\t\t}\n\t}\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\n\t\t\t\t\tdp[a][b][c][d].first = -1;\n\t\t\t\t\tdp[a][b][c][d].second = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tP ans = recursive(0,0,H-1,W-1);\n\n\tprintf(\"%d %d\\n\",ans.first,SUPPLY+ans.second);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&SUPPLY);\n\t\tif(H == 0 && W == 0 && SUPPLY == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll INFLL = (1ll<<60);\n\nint h,w;\nll u[35][35],s;\nbool done[35][35][35][35];\nP memo[35][35][35][35];\n\nP solve(int xl, int xr, int yl, int yr){\n\tint i;\n\tll t;\n\tP p,vl,vr;\n\tt = u[xr][yr] - u[xl][yr] - u[xr][yl] + u[xl][yl];\n\tif(done[xl][xr][yl][yr]){\n\t\treturn memo[xl][xr][yl][yr];\n\t}\n\tdone[xl][xr][yl][yr] = true;\n\tif(u[h][w] - t > s){\n\t\tmemo[xl][xr][yl][yr].first = -INFLL;\n\t\tmemo[xl][xr][yl][yr].second = -INFLL;\n\t\treturn memo[xl][xr][yl][yr];\n\t}\n\tmemo[xl][xr][yl][yr].first = 1ll;\n\tmemo[xl][xr][yl][yr].second = s + t - u[h][w];\n\tfor(i=xl+1; i<xr; ++i){\n\t\tvl = solve(xl,i,yl,yr);\n\t\tvr = solve(i,xr,yl,yr);\n\t\tp.first = vl.first + vr.first;\n\t\tp.second = min(vl.second,vr.second);\n\t\tif(p.first > memo[xl][xr][yl][yr].first){\n\t\t\tmemo[xl][xr][yl][yr].first = p.first;\n\t\t\tmemo[xl][xr][yl][yr].second = p.second;\n\t\t}else if(p.first == memo[xl][xr][yl][yr].first && p.second > memo[xl][xr][yl][yr].second){\n\t\t\tmemo[xl][xr][yl][yr].second = p.second;\n\t\t}\n\t}\n\tfor(i=yl+1; i<yr; ++i){\n\t\tvl = solve(xl,xr,yl,i);\n\t\tvr = solve(xl,xr,i,yr);\n\t\tp.first = vl.first + vr.first;\n\t\tp.second = min(vl.second,vr.second);\n\t\tif(p.first > memo[xl][xr][yl][yr].first){\n\t\t\tmemo[xl][xr][yl][yr].first = p.first;\n\t\t\tmemo[xl][xr][yl][yr].second = p.second;\n\t\t}else if(p.first == memo[xl][xr][yl][yr].first && p.second > memo[xl][xr][yl][yr].second){\n\t\t\tmemo[xl][xr][yl][yr].second = p.second;\n\t\t}\n\t}\n\treturn memo[xl][xr][yl][yr];\n}\n\nostream& operator <<(ostream& o, const P &rhs){\n\to << rhs.first << \" \" << rhs.second;\n\treturn o;\n}\n\nint main(void){\n\tint i,j;\n\twhile(cin >> h >> w >> s){\n\t\tif(!(h||w||s)){\n\t\t\tbreak;\n\t\t}\n\t\tfill(done[0][0][0],done[35][0][0],false);\n\t\tfill(u[0],u[35],0ll);\n\t\tfor(i=0; i<h; ++i){\n\t\t\tfor(j=0; j<w; ++j){\n\t\t\t\tcin >> u[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\tfor(i=0; i<=h; ++i){\n\t\t\tfor(j=0; j<=w; ++j){\n\t\t\t\tu[i+1][j] += u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(i=0; i<=h; ++i){\n\t\t\tfor(j=0; j<=w; ++j){\n\t\t\t\tu[i][j+1] += u[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve(0,h,0,w) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nint h,w,s,total;\npii dp[32][32][32][32];\npii search(int x1,int y1,int x2,int y2,vvi &u){\n\tif(dp[x1][y1][x2][y2].first>0){\n\t\treturn dp[x1][y1][x2][y2];\n\t}\n\tif(x1==x2&&y1==y2){\n\t\treturn make_pair(1,total-u[x1][y1]);\n\t}\n\tint t=0;\n\tFOR(i,x1,x2+1)FOR(j,y1,y2+1)\n\t\tt+=u[i][j];\n\tpii best=make_pair(1,total-t);\n\tFOR(i,x1,x2){\n\t\tpii p1=search(x1,y1,i,y2,u),p2=search(i+1,y1,x2,y2,u);\n\t\tint ff=p1.first+p2.first,ss=max(p1.second,p2.second);\n\t\tif(ss>s)continue;\n\t\tif(best.first<ff||(best.first==ff&&best.second>ss)){\n\t\t\tbest.first=ff;\n\t\t\tbest.second=ss;\n\t\t}\n\t}\n\tFOR(i,y1,y2){\n\t\tpii p1=search(x1,y1,x2,i,u),p2=search(x1,i+1,x2,y2,u);\n\t\tint ff=p1.first+p2.first,ss=max(p1.second,p2.second);\n\t\tif(ss>s)continue;\n\t\tif(best.first<ff||(best.first==ff&&best.second>ss)){\n\t\t\tbest.first=ff;\n\t\t\tbest.second=ss;\n\t\t}\n\t}\n\treturn dp[x1][y1][x2][y2]=best;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h){\n\t\tvvi u(w,vi(h,0));\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcin>>u[j][i];\n\t\t\t}\n\t\t}\n\t\tREP(i,32)REP(j,32)REP(k,32)REP(l,32)\n\t\t\tdp[i][j][k][l]=make_pair(0,0);\n\t\ttotal=0;\n\t\tREP(i,w)REP(j,h)\n\t\t\ttotal+=u[i][j];\n\t\tpii p=search(0,0,w-1,h-1,u);\n\t\tcout<<p.first<<\" \"<<s-p.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nconst int IINF = INT_MAX;\n\nint h,w,supply,u[33][33],lower;\nii memo[33][33][33][33];//[upper left][upper left][lower right][lower right] := ii(the number of groups, maximum value)\nint dp[34][34];\n\nii dfs(int xL,int yL,int xR,int yR){\n  ii &ret = memo[xL][yL][xR][yR];\n  if( ret != ii(-1,-1) ) return ret;\n  int sum = dp[yR+1][xR+1] - dp[yR+1][xL] - dp[yL][xR+1] + dp[yL][xL];\n  if( sum < lower ) return ret; // invalid group\n\n  bool success = false;  \n  ret = ii(0,IINF);\n  // split : row\n  REP(x,xL,xR){\n    ii temp1 = dfs(xL,yL,x,yR);\n    ii temp2 = dfs(x+1,yL,xR,yR);\n    if( temp1 != ii(-1,-1) && temp2 != ii(-1,-1) ) {\n      success = true;\n      ii temp = ii(temp1.first+temp2.first,min(temp1.second,temp2.second));\n      if( ret < temp ) ret = temp;\n    }\n  }\n  \n  // split : column\n  REP(y,yL,yR){\n    ii temp1 = dfs(xL,yL,xR,y);\n    ii temp2 = dfs(xL,y+1,xR,yR);\n    if( temp1 != ii(-1,-1) && temp2 != ii(-1,-1) ) {\n      success = true;\n      ii temp = ii(temp1.first+temp2.first,min(temp1.second,temp2.second));\n      if( ret < temp ) ret = temp;\n    }\n  }\n  if( !success ) ret = ii(1,sum);\n  return ret;\n}\n\nint main(){\n  while( cin >> h >> w >> supply, h|w|supply ){\n    rep(i,h) rep(j,w) cin >> u[i][j];\n    rep(i,h+1) rep(j,w+1) rep(k,h+1) rep(l,w+1) memo[j][i][l][k] = ii(-1,-1);\n    rep(i,h+1) rep(j,w+1) dp[i][j] = 0;\n    REP(i,1,h+1) REP(j,1,w+1) dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + u[i-1][j-1];\n    lower = dp[h][w] - supply;\n    ii temp = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",temp.first,(int)abs(supply-(dp[h][w]-temp.second)));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\nint H,W,S,x[40][40];\npair<int,int> dp[40][40][40][40];\nvector<tuple<int,int,int,int,int> >vec;\nint getsum(int ax,int ay,int bx,int by){\n\tint v=0;\n\tfor(int i=ax;i<=bx;i++){\n\t\tfor(int j=ay;j<=by;j++){\n\t\t\tv+=x[i][j];\n\t\t}\n\t}\n\treturn v;\n}\nvoid init(){\n\tfor(int i=0;i<1600;i++){\n\t\tfor(int j=0;j<1600;j++){\n\t\t\tdp[i/40][i%40][j/40][j%40]=make_pair(0,0);\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W>>S;int sum=0;\n\t\tinit();if(H==0 && W==0 && S==0)break;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>x[i][j];sum+=x[i][j];\n\t\t\t}\n\t\t}\n\t\tsum=sum-S;vec.clear();\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int k=i;k<H;k++){\n\t\t\t\t\tfor(int l=j;l<W;l++){\n\t\t\t\t\t\tint area=(k-i+1)*(l-j+1);\n\t\t\t\t\t\tint W=getsum(i,j,k,l);\n\t\t\t\t\t\tif(W<sum)continue;\n\t\t\t\t\t\tdp[i][j][k][l]=make_pair(1,W-sum);\n\t\t\t\t\t\tvec.push_back(make_tuple(area,i,j,k,l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\tfor(int i=0;i<(int)vec.size();i++){\n\t\t\tint lx=get<1>(vec[i]),ly=get<2>(vec[i]);\n\t\t\tint rx=get<3>(vec[i]),ry=get<4>(vec[i]);\n\t\t\tfor(int j=lx;j<rx;j++){\n\t\t\t\tpair<int,int>J1=dp[lx][ly][j][ry];\n\t\t\t\tpair<int,int>J2=dp[j+1][ly][rx][ry];\n\t\t\t\tif(dp[lx][ly][rx][ry].first<J1.first+J2.first){\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t\telse if(dp[lx][ly][rx][ry].first==J1.first+J2.first){\n\t\t\t\t\tif(dp[lx][ly][rx][ry].second>min(J1.second,J2.second))continue;\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=ly;j<ry;j++){\n\t\t\t\tpair<int,int>J1=dp[lx][ly][rx][j];\n\t\t\t\tpair<int,int>J2=dp[lx][j+1][rx][ry];\n\t\t\t\tif(dp[lx][ly][rx][ry].first<J1.first+J2.first){\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t\telse if(dp[lx][ly][rx][ry].first==J1.first+J2.first){\n\t\t\t\t\tif(dp[lx][ly][rx][ry].second>min(J1.second,J2.second))continue;\n\t\t\t\t\tdp[lx][ly][rx][ry].first=J1.first+J2.first;\n\t\t\t\t\tdp[lx][ly][rx][ry].second=min(J1.second,J2.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][0][H-1][W-1].first<<' '<<dp[0][0][H-1][W-1].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int maxh = 35, maxw = 35;\nint csum[maxh][maxw];\nvoid init(VVI vec) {\n  assert(vec.size());\n  REP(i, vec.size()) REP(j, vec[0].size()) {\n    if(!i && !j) csum[i][j] = vec[i][j];\n    else if(!i) csum[i][j] = csum[i][j-1] + vec[i][j];\n    else if(!j) csum[i][j] = csum[i-1][j] + vec[i][j];\n    else csum[i][j] = csum[i-1][j] + csum[i][j-1] - csum[i-1][j-1] + vec[i][j];\n  }\n}\n// 閉区間, 0-indexedで矩形範囲の合計\nint cumsum(int sx, int sy, int gx, int gy) {\n  if(!sx && !sy) return csum[gy][gx];\n  if(!sx) return csum[gy][gx] - csum[sy-1][gx];\n  if(!sy) return csum[gy][gx] - csum[gy][sx-1];\n  return csum[gy][gx] - csum[gy][sx-1] - csum[sy-1][gx] + csum[sy-1][sx-1];\n}\n\nint h, w, s;\nPII dp[35][35][35][35];\nPII func(int sx, int sy, int gx, int gy) {\n  // cout << sx << \" \" << sy << \" \" << gx << \" \" << gy << endl;\n  if(dp[sx][sy][gx][gy] != PII{-1, -1}) return dp[sx][sy][gx][gy];\n  // cout << cumsum(0, 0, w-1, h-1) << \" \" << cumsum(sx, sy, gx, gy) << endl;\n  if(cumsum(0, 0, w-1, h-1) - cumsum(sx, sy, gx, gy) > s) return {-1, -1};\n  // 分割しない\n  int group = 1, ret = cumsum(sx, sy, gx, gy);\n  // 縦で割る\n  FOR(i, sx, gx) {\n    // cout << \"i:\" << i << endl;\n    PII vl = func(sx, sy, i, gy);\n    PII vr = func(i+1, sy, gx, gy);\n    if(group < vl.first + vr.first || (group == vl.first+vr.first && ret < min(vl.second, vr.second))) {\n      group = vl.first + vr.first;\n      ret = min(vl.second, vr.second);\n    }\n  }\n  // 横で割る\n  FOR(i, sy, gy) {\n    // cout << \"i;\" << i << endl;\n    PII vl = func(sx, sy, gx, i);\n    PII vr = func(sx, i+1, gx, gy);\n    if(group < vl.first + vr.first || (group == vl.first+vr.first && ret < min(vl.second, vr.second))) {\n      group = vl.first + vr.first;\n      ret = min(vl.second, vr.second);\n    }\n  }\n  // cout << sx << \" \" << sy << \" \" << gx << \" \" << gy << \" \" << group << \",\" << ret << endl;\n  return dp[sx][sy][gx][gy] = {group, ret};\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> h >> w >> s;\n    if(!h) break;\n    VVI vec(h, VI(w));\n    REP(i, h) REP(j, w) cin >> vec[i][j];\n\n    init(vec);\n    REP(i1, 35) REP(i2, 35) REP(i3, 35) REP(i4, 35) dp[i1][i2][i3][i4] = {-1, -1};\n    PII ret = func(0, 0, w-1, h-1);\n    cout << ret.first << \" \" << s - cumsum(0,0,w-1,h-1) + ret.second << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint h, w, s;\n\nconstexpr int kMaxWH = 33;\n\n#define F first\n#define S second\n\n// 未定義，不可能\nconstexpr int kUnd = -2;\nconstexpr int kImp = -1;\n\n// (グループ数, 予備力)\npii memo[kMaxWH][kMaxWH][kMaxWH][kMaxWH];\n\n// 消費電力の和\nint sum[kMaxWH + 1][kMaxWH + 1];\n\nint field[kMaxWH][kMaxWH];\n\npii dfs(pii lu, pii rd){\n    if(memo[lu.F][lu.S][rd.F][rd.S] != mp(kUnd, kUnd)){\n        return memo[lu.F][lu.S][rd.F][rd.S];\n    }\n\n    int yobi =  s - (sum[h][w] - (sum[rd.F + 1][rd.S + 1] - sum[rd.F + 1][lu.S] - sum[lu.F][rd.S + 1] + sum[lu.F][lu.S]));\n    if(yobi < 0){\n        memo[lu.F][lu.S][rd.F][rd.S] = mp(kImp, kImp);\n        return mp(kImp, kImp);\n    }\n\n    pii ret = mp(kImp, kImp);\n    range(y, lu.F, rd.F){\n        pii ret1 = dfs(mp(lu.F, lu.S), mp(y, rd.S));\n        pii ret2 = dfs(mp(y + 1, lu.S), mp(rd.F, rd.S));\n\n        if(ret1 == mp(kImp, kImp) || ret2 == mp(kImp, kImp)) continue;\n\n        ret = max(ret, mp(ret1.F + ret2.F, min(ret1.S, ret2.S)));\n    }\n    range(x, lu.S, rd.S){\n        pii ret1 = dfs(mp(lu.F, lu.S), mp(rd.F, x));\n        pii ret2 = dfs(mp(lu.F, x + 1), mp(rd.F, rd.S));\n\n        if(ret1 == mp(kImp, kImp) || ret2 == mp(kImp, kImp)) continue;\n\n        ret = max(ret, mp(ret1.F + ret2.F, min(ret1.S, ret2.S)));\n    }\n\n    if(ret == mp(kImp, kImp)){\n        ret = mp(1, yobi);\n    }\n\n    memo[lu.F][lu.S][rd.F][rd.S] = ret;\n    return ret;\n}\n\nint main(void){\n    for(; cin >> h >> w >> s, h;){\n        rep(y, h) rep(x, w) cin >> field[y][x];\n\n        rep(y, h) rep(x, w) rep(yy, h) rep(xx, w) memo[y][x][yy][xx] = mp(kUnd, kUnd);\n\n        rep(y, h + 1) sum[y][0] = 0;\n        rep(x, w + 1) sum[0][x] = 0;\n        rep(y, h){\n            rep(x, w){\n                sum[y + 1][x + 1] = sum[y][x + 1] + sum[y + 1][x] + field[y][x] - sum[y][x];\n            }\n        }\n\n        pii res = dfs(mp(0, 0), mp(h - 1, w - 1));\n        cout << res.F << \" \" << res.S << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1176&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nvoid initialize();\nvoid calc_Sum();\npair<int,int> dfs(int sy, int sx, int ty, int tx);\nint h, w, s;\nint u[33][33];\nint Sum[33][33][33][33];\npair<int, int> dp[33][33][33][33];\n\nvoid initialize() {\n\tfor (int i = 0; i < 33;i++)for (int j = 0; j < 33;j++)u[i][j] = 0;\n\tfor(int i = 0;i < 33;i++)\n\t\tfor(int j = 0; j < 33;j++)\n\t\t\tfor(int k = 0; k < 33;k++)\n\t\t\t\tfor (int l = 0; l < 33;l++) {\n\t\t\t\t\tSum[i][j][k][l] = 0;\n\t\t\t\t\tdp[i][j][k][l] = { -1,-1 };\n\t\t\t\t}\n}\n\nvoid calc_Sum() {\n\tfor (int sy = 0; sy < h;sy++) {\n\t\tfor (int sx = 0; sx < w;sx++) {\n\t\t\tfor (int ty = sy; ty < h; ty++) {\n\t\t\t\tfor (int tx = sx; tx < w;tx++) {\n\t\t\t\t\tif (sy == ty && sx == tx) { Sum[sy][sx][ty][tx] = u[ty][tx]; continue; }\n\t\t\t\t\tif (sy == ty) { Sum[sy][sx][ty][tx] = Sum[sy][sx][ty][tx - 1] + u[ty][tx]; continue; }\n\t\t\t\t\tif (sx == tx) { Sum[sy][sx][ty][tx] = Sum[sy][sx][ty - 1][tx] + u[ty][tx]; continue; }\n\t\t\t\t\tSum[sy][sx][ty][tx] = Sum[sy][sx][ty - 1][tx] + Sum[sy][sx][ty][tx - 1] \n\t\t\t\t\t\t\t\t\t\t\t\t- Sum[sy][sx][ty - 1][tx - 1] + u[ty][tx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\npair<int, int> dfs(int sy, int sx, int ty, int tx) {\n\tif (dp[sy][sx][ty][tx].first != -1 && dp[sy][sx][ty][tx].second != -1) return dp[sy][sx][ty][tx];\n\n\tint demand = Sum[0][0][h - 1][w - 1] - Sum[sy][sx][ty][tx];\n\tif (demand > s) return dp[sy][sx][ty][tx] = make_pair(0, -1);\n\tauto ret = make_pair(1, demand);\n\n\t/* horizontal */\n\tfor (int i = sy;i < ty;i++) {\n\t\tauto c1 = dfs(sy, sx, i, tx), c2 = dfs(i + 1, sx, ty, tx);\n\t\tif (c1.first == 0 || c2.first == 0)continue;\n\t\tauto x = make_pair(c1.first + c2.first, max(c1.second, c2.second));\n\t\tif (ret.first < x.first) {\n\t\t\tret = x; continue;\n\t\t}\n\t\tif (ret.first == x.first) {\n\t\t\tif (ret.second > x.second) {\n\t\t\t\tret = x; continue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* vertical */\n\tfor (int i = sx; i < tx; i++) {\n\t\tauto c1 = dfs(sy, sx, ty, i), c2 = dfs(sy, i + 1, ty, tx);\n\t\tif (c1.first == 0 || c2.first == 0)continue;\n\t\tauto x = make_pair(c1.first + c2.first, max(c1.second, c2.second));\n\t\tif (ret.first < x.first) {\n\t\t\tret = x; continue;\n\t\t}\n\t\tif (ret.first == x.first) {\n\t\t\tif (ret.second > x.second) {\n\t\t\t\tret = x; continue;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[sy][sx][ty][tx] = ret;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> h >> w >> s, h | w | s) {\n\t\tinitialize();\n\t\tfor (int i = 0;i < h;i++)for (int j = 0; j < w;j++)cin >> u[i][j];\n\t\tcalc_Sum();\n\t\tauto ans = dfs(0, 0, h - 1, w - 1);\n\t\tcout << ans.first << \" \" << s - ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 33\n\n\nint h, w, s, u[SIZE][SIZE] = {};\nint sum_u[SIZE][SIZE] = {};\npair<int, int> dp[SIZE][SIZE][SIZE][SIZE]; //Group, rest\n\nint rangeSum(int t, int l, int b, int r){\n  return sum_u[t][l] + sum_u[b][r] - sum_u[t][r] - sum_u[b][l];\n}\n\npair<int,int> merge(pair<int,int> a, pair<int,int> b){\n  return {a.first + b.first, min(a.second, b.second)};\n}\n\nint solve(){\n  \n  scanf(\"%d%d%d\", &h, &w, &s);\n\n  int L = -s;\n  \n  if(h == 0) return false;\n  \n  for(int i=1;i<=h;i++){\n    for(int j=1;j<=w;j++){\n      scanf(\"%d\", u[i]+j);\n      sum_u[i][j] = sum_u[i][j-1] + u[i][j];\n      L += u[i][j];\n    }\n  }\n  \n  for(int i=1;i<=h;i++){\n    for(int j=0;j<=w;j++){\n      sum_u[i][j] += sum_u[i-1][j];\n    }\n  }\n\n  for(int t=0;t<h;t++){\n    for(int l=0;l<w;l++){\n\n      for(int b=t+1;b<=h;b++){\n        for(int r=l+1;r<=w;r++){\n          int res = rangeSum(t,l,b,r);\n          if(res >= L)\n            dp[t][l][b][r] = {1, res - L};\n          else\n            dp[t][l][b][r] = {0, -INF};\n        }\n      }\n      \n    }\n  }\n\n  \n  for(int p=1;p<=h;p++){\n    for(int q=1;q<=w;q++){\n      for(int t=0;t+p<=h;t++){\n        for(int l=0;l+q<=w;l++){\n          if(p == 1 && q == 1) continue;\n          \n          int b = t+p;\n          int r = l+q;\n          \n          for(int i=t+1;i<b;i++){\n            if(dp[t][l][i][r].first && dp[i][l][b][r].first){\n              dp[t][l][b][r] = max(dp[t][l][b][r],\n                                   merge(dp[t][l][i][r], dp[i][l][b][r]));\n            }\n          }\n\n          for(int i=l+1;i<r;i++){\n            if(dp[t][l][b][i].first && dp[t][i][b][r].first){\n              dp[t][l][b][r] = max(dp[t][l][b][r],\n                                   merge(dp[t][l][b][i], dp[t][i][b][r]));\n            }\n          }\n        }\n      }\n      \n    }\n  }\n\n  printf(\"%d %d\\n\", dp[0][0][h][w].first, dp[0][0][h][w].second);\n  \n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\ntemplate<typename T>\nstruct RectangleSum {\n\tint H, W;\n\tvector<vector<T>> sum;\n\tRectangleSum(vector<vector<T>> v)\n\t\t:H(v.size()), W(v.front().size()), sum(H + 1, vector<T>(W + 1)) {\n\t\trep(i, 0, H + 1)rep(j, 0, W + 1) {\n\t\t\tsum[i][j] = (i == 0 || j == 0) ? 0 :\n\t\t\t\tsum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i - 1][j - 1];\n\t\t}\n\t}\n\t//[si, ti), [sj, tj)\n\tT get(int si, int sj, int ti, int tj) {\n\t\treturn sum[ti][tj] - sum[si][tj] - sum[ti][sj] + sum[si][sj];\n\t}\n};\n\n\nusing P = pair<int, int>;\nP dp[33][33][33][33];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int h, w, s; cin >> h >> w >> s&&h;) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tint all = 0;\n\t\tvector<vector<int>> u(h, vector<int>(w));\n\t\trep(i, 0, h) {\n\t\t\trep(j, 0, w) {\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tall += u[i][j];\n\t\t\t}\n\t\t}\n\n\t\tRectangleSum<int> rs(u);\n\n\t\t// (?????§??°???????????°. ?????§?????????)\n\t\tfunction<P(int, int, int, int)> dfs = [&](int si, int sj, int ti, int tj) {\n\t\t\tif (dp[si][sj][ti][tj].first != 0)\n\t\t\t\treturn dp[si][sj][ti][tj];\n\t\t\tP ret(1, s - (all - rs.get(si, sj, ti, tj)));\n\t\t\trep(i, si, ti) {\n\t\t\t\tif (all - rs.get(si, sj, i, tj) > s\n\t\t\t\t\t|| all - rs.get(i, sj, ti, tj) > s)\n\t\t\t\t\tcontinue;\n\t\t\t\tP a = dfs(si, sj, i, tj);\n\t\t\t\tP b = dfs(i, sj, ti, tj);\n\t\t\t\tP c(a.first + b.first, min(a.second, b.second));\n\t\t\t\tchmax(ret, c);\n\t\t\t}\n\t\t\trep(j, sj, tj) {\n\t\t\t\tif (all - rs.get(si, sj, ti, j) > s\n\t\t\t\t\t|| all - rs.get(si, j, ti, tj) > s)\n\t\t\t\t\tcontinue;\n\t\t\t\tP a = dfs(si, sj, ti, j);\n\t\t\t\tP b = dfs(si, j, ti, tj);\n\t\t\t\tP c(a.first + b.first, min(a.second, b.second));\n\t\t\t\tchmax(ret, c);\n\t\t\t}\n\t\t\treturn dp[si][sj][ti][tj] = ret;\n\t\t};\n\n\t\tint a, b;\n\t\ttie(a, b) = dfs(0, 0, h, w);\n\t\tcout << a << \" \" << b << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nint smp[35][35],n,SUM,W,H,used[35][35][35][35];\nP mem[35][35][35][35];\n\nint cal(int x1,int y1,int x2,int y2){\n  return smp[y2][x2]-(smp[y1-1][x2]+smp[y2][x1-1])+smp[y1-1][x1-1];\n}\n\nP dfs(int x,int y,int w,int h){\n  if(used[x][y][w][h]++) return mem[x][y][w][h];\n\n  P res=P(1,n-(SUM-cal(x,y,w,h)));\n  for(int i=x;i!=w;i++){\n    int m=max(SUM-cal(x,y,i,h),SUM-cal(i+1,y,w,h));\n    if(m<=n){\n      P a=dfs(x,y,i,h);\n      P b=dfs(i+1,y,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n\n  for(int i=y;i!=h;i++){\n    int m=max(SUM-cal(x,y,w,i),SUM-cal(x,i+1,w,h));\n    if(m<=n){\n      P a=dfs(x,y,w,i);\n      P b=dfs(x,i+1,w,h);\n      res=max(res,P((a.f+b.f),min(a.s,b.s)));\n    }\n  }\n  return mem[x][y][w][h]=res;\n}\n\nint main(){\n  while(1){\n  cin>>H>>W>>n;\n  if(!H&&!W&&!n)break;\n  memset(used,0,sizeof(used)),memset(mem,0,sizeof(mem));\n\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<=W;j++)cin>>smp[i][j];\n\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i][j+1]+=smp[i][j];\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++) smp[i+1][j]+=smp[i][j];\n  SUM=smp[H][W];\n  P ans=dfs(1,1,W,H);\n  cout <<ans.f<<\" \"<<ans.s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, T;\nvector< vector<int> > A;\nbool m1[50][50][50][50];\nP m2[50][50][50][50];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, getM(x1, y1, x2, y2)-T);\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> T, H || W || T) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[0][0][0]+50*50*50, false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tT = sum - T;\n\t\tassert(T >= 0);\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\n/** 累積和 */\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/** /累積和 */\n\n\ntypedef tuple<int, int, int, int> Kukei;\n\nint H, W, S;\nint total_power;\nmap<Kukei, PII> memo;\nVVI tile;\nVVI c_tile;\n\nbool can_group(int x1, int x2, int y1, int y2) {\n\treturn total_power - S <= sum_csum2<int>(c_tile, y1, y2, x1, x2);\n}\n\nPII dfs(int x1, int x2, int y1, int y2) {\n\tauto kukei = make_tuple(x1, x2, y1, y2);\n\tif (memo.count(kukei)) {\n\t\treturn memo[kukei];\n\t}\n\t\n\tPII res(-1, -1);\n\n\tfor (int v = x1 + 1; v < x2; v++) {\n\t\tPII a = dfs(x1, v, y1, y2);\n\t\tPII b = dfs(v, x2, y1, y2);\n\n\t\tif (a.first != -1 && b.first != -1) {\n\t\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t\t}\n\t}\n\n\tfor (int h = y1 + 1; h < y2; h++) {\n\t\tPII a = dfs(x1, x2, y1, h);\n\t\tPII b = dfs(x1, x2, h, y2);\n\n\t\tif (a.first != -1 && b.first != -1) {\n\t\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t\t}\n\t}\n\n\tif (res.first == -1 && can_group(x1, x2, y1, y2)) {\n\t\tres = make_pair(1, sum_csum2<int>(c_tile, y1, y2, x1, x2));\n\t}\n\n\treturn memo[kukei] = res;\n}\n\nint main(void) {\n\twhile(cin >> H >> W >> S, H) {\n\t\ttile = VVI(H, VI(W, 0));\n\t\ttotal_power = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\ttotal_power += tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemo.clear();\n\t\tc_tile = calc_csum2<int>(tile);\n\n\t\tPII ans = dfs(0, W, 0, H);\n\n\t\tcout << ans.first << \" \" << (S - total_power + ans.second) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define INF 1000000000\n\nint h, w, s;\nint u[34][34];\nint sum[34][34];\npii memo[34][34][34][34];\n\npii recur(int low, int high, int left, int right){\n\tif(memo[low][high][left][right].first == -1){\n\t\tint need = sum[high][right] + sum[low-1][left-1] - sum[low-1][right] - sum[high][left-1];\n\t\tpii r(1, s - (sum[h][w] - need));\n\t\tif(r.second < 0){\n\t\t\tr = pii(-INF, -INF);\n\t\t}\n\t\telse{\n\t\t\tfor(int i = low; i < high; ++i){\n\t\t\t\tpii p1 = recur(low, i, left, right);\n\t\t\t\tpii p2 = recur(i + 1, high, left, right);\n\t\t\t\tpii q(p1.first + p2.first, min(p1.second, p2.second));\n\t\t\t\tr = max(r, q);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = left; i < right; ++i){\n\t\t\t\tpii p1 = recur(low, high, left, i);\n\t\t\t\tpii p2 = recur(low, high, i + 1, right);\n\t\t\t\tpii q(p1.first + p2.first, min(p1.second, p2.second));\n\t\t\t\tr = max(r, q);\n\t\t\t}\n\t\t}\n\t\tmemo[low][high][left][right] = r;\n\t}\n\treturn memo[low][high][left][right];\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\", &h, &w, &s), h){\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tscanf(\"%d\", &u[i][j]);\n\t\t}\n\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tsum[i][j] = sum[i][j-1] + u[i][j];\n\t\t}\n\t\t\n\t\tfor(int j = 1; j <= w; ++j)\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tsum[i][j] += sum[i-1][j];\n\t\t}\n\n\t\tfor(int i = 0; i < 34; ++i)\n\t\tfor(int j = 0; j < 34; ++j)\n\t\tfor(int k = 0; k < 34; ++k)\n\t\tfor(int l = 0; l < 34; ++l){\n\t\t\tmemo[i][j][k][l] = pii(-1, -1);\n\t\t}\n\n\t\tpii ans = recur(1, h, 1, w);\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\n/** 累積和 */\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/** /累積和 */\n\n\ntypedef tuple<int, int, int, int> Kukei;\n\nint H, W, S;\nint total_power;\nVVI tile;\nVVI c_tile;\nvector< vector< vector< vector<PII> > > > memo;\n\nbool can_group(int x1, int x2, int y1, int y2) {\n\treturn total_power - S <= sum_csum2<int>(c_tile, y1, y2, x1, x2);\n}\n\nPII dfs(int x1, int x2, int y1, int y2) {\n\tPII tmp = memo[y1][x1][y2][x2];\n\tif (tmp.first != -1) {\n\t\treturn tmp;\n\t}\n\t\n\tPII res(-1, -1);\n\n\tif (!can_group(x1, x2, y1, y2)) {\n\t\treturn memo[y1][x1][y2][x2] = res;\n\t}\n\n\tfor (int v = x1 + 1; v < x2; v++) {\n\t\tif (!can_group(x1, v, y1, y2) || !can_group(v, x2, y1, y2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII a = dfs(x1, v, y1, y2);\n\t\tPII b = dfs(v, x2, y1, y2);\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tfor (int h = y1 + 1; h < y2; h++) {\n\t\tif (!can_group(x1, x2, y1, h) || !can_group(x1, x2, h, y2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII a = dfs(x1, x2, y1, h);\n\t\tPII b = dfs(x1, x2, h, y2);\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tif (res.first == -1) {\n\t\tres = make_pair(1, sum_csum2<int>(c_tile, y1, y2, x1, x2));\n\t}\n\n\treturn memo[y1][x1][y2][x2] = res;\n}\n\nint main(void) {\n\twhile(cin >> H >> W >> S, H) {\n\t\ttile = VVI(H, VI(W, 0));\n\t\ttotal_power = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\ttotal_power += tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemo = vector< vector< vector< vector<PII> > > >(H + 1,\n\t\t\t\tvector< vector< vector<PII> > >(W + 1,\n\t\t\t\tvector< vector<PII> >(H + 1,\n\t\t\t\tvector<PII>(W + 1,\n\t\t\t\tmake_pair(-1, -1)))));\n\n\t\tc_tile = calc_csum2<int>(tile);\n\n\t\tPII ans = dfs(0, W, 0, H);\n\n\t\tcout << ans.first << \" \" << (S - total_power + ans.second) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nP dp[32][32][32][32];\nint score0[32][32];\nint score[32][32][32][32];\nint field[32][32];\n\nint main(){\n  int h, w, s;\n  while(cin >> h >> w >> s && (h || w || s)){\n    \n    memset(score, 0, sizeof(score));\n    memset(score0, 0, sizeof(score0));\n    \n    int sum = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\t\tcin >> field[i][j];\n\t\tif(i != 0){\n\t\t  score0[i][j] += score0[i-1][j];\n\t\t}\n\t\tif(j != 0){\n\t\t  score0[i][j] += score0[i][j-1];\n\t\t}\n\t\tif(i != 0 && j != 0){\n\t\t  score0[i][j] -= score0[i-1][j-1];\n\t\t}\n\t\tscore0[i][j] += field[i][j];\n\t\tsum += field[i][j];\n\t\t\n\t  }\n\n    }\n\n\tsum -= s;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0; k <= i; k++){\n\t\t\t\tfor(int l = 0; l <= j; l++){\n\t\t\t\t\tif(k == 0 && l == 0){\n\t\t\t\t\t\tscore[k][i][l][j] = score0[i][j];\n\t\t\t\t\t}else if(k == 0 && l != 0){\n\t\t\t\t\t\tscore[k][i][l][j] = score0[i][j] - score0[i][l-1];\n\t\t\t\t\t}else if(k != 0 && l == 0){\n\t\t\t\t\t\tscore[k][i][l][j] = score0[i][j] - score0[k-1][j];\n\t\t\t\t    }else{\n\t\t\t      score[k][i][l][j] = score0[i][j] - score0[i][l-1] \n\t\t\t\t\t- score0[k-1][j] + score0[k-1][l-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\t\n\tfill(&dp[0][0][0][0], &dp[31][31][31][31]+1, P(0, 0));\n    for(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tfor(int k = 0; k + i <= h; k++){\n\t\t\t\tfor(int l = 0; l + j <= w; l++){\n\t\t\t\t\tbool f = false;\n\t\t\t\t\tfor(int m = k + 1; m < k + i; m++){\n\t\t\t\t\t\tif(score[k][m-1][l][l+j-1] >= sum &&  score[m][k+i-1][l][l+j-1] >= sum){\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tint num = dp[k][m-k][l][j].first + dp[m][i-(m-k)][l][j].first;\n\t\t\t\t\t\t\tint pow = min(dp[k][m-k][l][j].second,dp[m][i-(m-k)][l][j].second);\n\t\t\t\t\t\t\tif(dp[k][i][l][j].first < num || dp[k][i][l][j].first == num && dp[k][i][l][j].second < pow){\n\t\t\t\t\t\t\t\tdp[k][i][l][j].first = num;\n\t\t\t\t\t\t\t\tdp[k][i][l][j].second = pow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int m = l + 1; m < l + j; m++){\n\t\t\t\t\t\tif(score[k][k+i-1][l][m-1] >= sum &&  score[k][k+i-1][m][l+j-1] >= sum){\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tint num = dp[k][i][l][m-l].first + dp[k][i][m][j-(m-l)].first;\n\t\t\t\t\t\t\tint pow = min(dp[k][i][l][m-l].second, dp[k][i][m][j-(m-l)].second);\n\t\t\t\t\t\t\tif(dp[k][i][l][j].first < num || dp[k][i][l][j].first == num && dp[k][i][l][j].second < pow){\n\t\t\t\t\t\t\t\tdp[k][i][l][j].first = num;\n\t\t\t\t\t\t\t\tdp[k][i][l][j].second = pow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!f){\n\t\t\t\t\t\tdp[k][i][l][j].first = 1;\n\t\t\t\t\t\tdp[k][i][l][j].second = score[k][k+i-1][l][l+j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    cout << dp[0][h][0][w].first << \" \" << dp[0][h][0][w].second - sum << endl;\n    \n  }\n    \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint h, w, s;\nint U[35][35];\nint allsum = 0;\n// dp[y1][x1][y2][x2] := ??????(y1, x1), ??????(y2, x2)???????????¢??????????????????, \n// ??°?????????????????????????????§??°, ?????§????????????\npair<int, int> dp[35][35][35][35];\n\n// O(hw)\ntemplate <class T>\nvector<vector<T>> Imos2D(const vector<vector<T>>& a) {\n\tint h = a.size(), w = a[0].size();\n\tvector<vector<T>> s(h + 1, vector<T>(w + 1, 0));\n\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) s[i + 1][j + 1] = a[i][j];\n\tfor (int i = 0; i < h + 1; ++i) for (int j = 0; j < w; ++j) s[i][j + 1] += s[i][j];\n\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w + 1; ++j) s[i + 1][j] += s[i][j];\n\treturn s;\n}\n// O(1)\ntemplate <class T>\nint sum(const vector<vector<T>>& s, int i, int j, int h, int w) {\n\treturn s[i + h][j + w] - s[i][j + w] + s[i][j] - s[i + h][j];\n}\n\npair<int, int> dfs(int y1, int x1, int y2, int x2, auto imos) {\n\tif(dp[y1][x1][y2][x2] != make_pair(0, INF)) return dp[y1][x1][y2][x2];\n\t\n\tint yobi = s - (allsum - sum<int>(imos, y1, x1, y2 - y1 + 1, x2 - x1 + 1));\n\t// if(yobi < 0) return make_pair(0, INF);\n\tauto ret = make_pair(1, yobi);\n\n\tfor (int i = x1; i < x2; ++i){\n\t\tif(s - (allsum - sum<int>(imos, y1, x1, y2 - y1 + 1, i - x1 + 1)) < 0) continue;\n\t\tif(s - (allsum - sum<int>(imos, y1, i + 1, y2 - y1 + 1, x2 - (i + 1) + 1)) < 0) continue;\n\t\tauto ret1 = dfs(y1, x1, y2, i, imos);\n\t\tauto ret2 = dfs(y1, i + 1, y2, x2, imos);\n\t\tchmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n\t}\n\n\tfor (int i = y1; i < y2; ++i){\n\t\tif(s - (allsum - sum<int>(imos, y1, x1, i - y1 + 1, x2 - x1 + 1)) < 0) continue;\n\t\tif(s - (allsum - sum<int>(imos, i + 1, x1, y2 - (i + 1) + 1, x2 - x1 + 1)) < 0) continue;\n\t\tauto ret1 = dfs(y1, x1, i, x2, imos);\n\t\tauto ret2 = dfs(i + 1, x1, y2, x2, imos);\n\t\tchmax(ret, make_pair(ret1.fi + ret2.fi, min(ret1.se, ret2.se)));\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\n\nint main(void) {\n\twhile(1) {\n\t\tscanf(\"%d %d %d\", &h, &w, &s);\n\t\t\n\t\tif(h == 0 && w == 0 && s == 0) break;\n\t\trep(i, h)rep(j, w) scanf(\"%d\", &U[i][j]);\n\t\tallsum = 0;\n\t\trep(i, h)rep(j, w) allsum += U[i][j];\n\n\t\tvector<vector<int>> u(h);\n\t\trep(i, h)rep(j, w) u[i].pb(U[i][j]);\n\t\tauto imos = Imos2D<int>(u);\n\t\trep(i, 35)rep(j, 35)rep(k, 35)rep(l, 35) dp[i][j][k][l] = make_pair(0, INF);\n\n\t\tauto ans = dfs(0, 0, h - 1, w - 1, imos);\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint c[40][40];\nint sum[40][40];\nint sum_all = 0;\nint h,w,s;\n\nint get_sum(int x1,int y1,int x2,int y2){\n\treturn sum[x2][y2] + sum[x1 - 1][y1 - 1] - sum[x1 - 1][y2] - sum[x2][y1 - 1];\n}\n\nP dp[40][40][40][40];\n\nP rec(int x1,int y1,int x2,int y2){\n\tif(dp[x1][y1][x2][y2].first != -1) return dp[x1][y1][x2][y2];\n\tP res = {1 , s - (sum_all - get_sum(x1,y1,x2,y2))};\n\tfor(int i = x1;i < x2;i++){\n\t\tif(sum_all - get_sum(x1, y1, i, y2) > s) continue;\n\t\tif(sum_all - get_sum(i + 1,y1,x2,y2) > s) continue;\n\t\tP l = rec(x1, y1, i, y2);\n\t\tP r = rec(i + 1,y1,x2,y2);\n\t\tP ans = {l.first + r.first,min(l.second,r.second)};\n\t\tres = max(res,ans);\n\t}\n\tfor(int i =  y1;i < y2;i++){\n\t\tif(sum_all - get_sum(x1,y1,x2,i) > s) continue;\n\t\tif(sum_all - get_sum(x1,i + 1,x2,y2) > s) continue;\n\t\tP l = rec(x1,y1,x2,i);\n\t\tP r = rec(x1,i + 1,x2,y2);\n\t\tP ans = {l.first + r.first , min(l.second , r.second)};\n\t\tres = max(res,ans);\n\t}\n\n\treturn dp[x1][y1][x2][y2] = res;\n}\n\n\nint main(){\n\twhile(cin >> h >> w >> s,h || w || s){\n\t\tsum_all = 0;\n\t\trep(i,1,h)rep(j,1,w)rep(k,1,h)rep(l,1,w) dp[i][j][k][l].first = dp[i][j][k][l].second = -1;\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] = 0;\n\t\trep(i,1,h)rep(j,1,w) c[i][j] = 0;\n\t\trep(i,1,h)rep(j,1,w) cin >> c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum_all += c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] = sum[i - 1][j] + c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] += sum[i][j - 1];\n\t\tcout << rec(1,1,h,w).first << \" \" << rec(1,1,h,w).second << endl;;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint h,w,s;\nint rem;\nint u[35][35];\nint rui[35][35];\nP dp[35][35][35][35];\ninline int sum(int t,int b,int l,int r){\n\treturn rui[b][r]-rui[t-1][r]-rui[b][l-1]+rui[t-1][l-1];\n}\nP rec(int t,int b,int l,int r){\n\tif(dp[t][b][l][r]!=P(-1,-1))return dp[t][b][l][r];\n\tif(sum(t,b,l,r)<rem)return dp[t][b][l][r]=P(-INF,-INF);\n\tP ret = P(1,sum(t,b,l,r));\n\tfor(int i=t;i<b;i++){\n\t\trec(t,i,l,r);\n\t\trec(i+1,b,l,r);\n\t\tint num = dp[t][i][l][r].fi+dp[i+1][b][l][r].fi;\n\t\tint smallest = min(dp[t][i][l][r].sec,dp[i+1][b][l][r].sec);\n\t\tif(num<0)continue;\n\t\tif(num>ret.fi){\n\t\t\tret.fi = num;\n\t\t\tret.sec = smallest;\n\t\t}else if(num==ret.fi){\n\t\t\tif(ret.sec<smallest)ret.sec = smallest;\t\n\t\t}\n\t}\n\tfor(int i=l;i<r;i++){\n\t\trec(t,b,l,i);\n\t\trec(t,b,i+1,r);\n\t\tint num = dp[t][b][l][i].fi+dp[t][b][i+1][r].fi;\n\t\tint smallest = min(dp[t][b][l][i].sec,dp[t][b][i+1][r].sec);\n\t\tif(num<0)continue;\n\t\tif(num>ret.fi){\n\t\t\tret.fi = num;\n\t\t\tret.sec = smallest;\n\t\t}else if(num==ret.fi){\n\t\t\tif(ret.sec<smallest)ret.sec = smallest;\t\n\t\t}\n\t}\n\t//printf(\"t:%d b:%d l:%d r:%d number:%d smallest:%d\\n\",t,b,l,r,ret.fi,ret.sec);\n\treturn dp[t][b][l][r]=ret;\n}\t\nint solve(){\n\tscanf(\"%d %d %d\",&h,&w,&s);\n\tif(h+w+s==0)return 1;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tscanf(\"%d\",&u[i][j]);\n\t\t\trui[i][j]=u[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\trui[i][j]+=rui[i][j-1];\n\t\t}\n\t}\n\tfor(int j=1;j<=w;j++){\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trui[i][j]+=rui[i-1][j];\n\t\t}\n\t}\n\trem = sum(1,h,1,w)-s;\n\tfor(int i=0;i<35;i++){\n\t\tfor(int j=0;j<35;j++){\n\t\t\tfor(int k=0;k<35;k++){\n\t\t\t\tfor(int l=0;l<35;l++){\n\t\t\t\t\tdp[i][j][k][l]=P(-1,-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*while(1){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tcout << sum(a,b,c,d) << endl;\n\t}*/\n\tP ans = rec(1,h,1,w);\n\tprintf(\"%d %d\\n\",ans.fi,s-(sum(1,h,1,w)-ans.sec));\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int alpha, beta;\n};\n\nP dp[32][32][32][32];\n\nP rec(int l, int t, int r, int b, int acc, vector<vector<int> >& a){\n    \n    //cout << l << \" \" << t << \" \" << r << \" \" << b << \" \" << endl;\n    P res;\n    res.alpha = 0;\n    res.beta = 0;    \n    int sum = 0;\n    //合計がアなら0を返す\n    for(int i = t; i < b; i++){    \n        for(int j = l; j < r; j++){\n            sum += a[i][j];\n        }\n    }\n\n    if(sum < acc){\n        return res;\n    }\n\n    //分けて再帰呼び出し\n    \n    //縦\n    for(int i = t + 1; i < b; i++){\n\n        P left, right;\n\n        //左\n        if(dp[l][t][r][i].alpha != 0){\n            left = dp[l][t][r][i];            \n        }else{\n            left = rec(l, t, r, i, acc, a);\n        }\n\n        //右\n        if(dp[l][i][r][b].alpha != 0){\n            right = dp[l][i][r][b];\n        }else{\n            right = rec(l, i, r, b, acc, a);\n        }\n\n        if(left.alpha != 0 && right.alpha != 0){\n            if(res.alpha < left.alpha + right.alpha){\n                res.alpha = left.alpha + right.alpha;\n                res.beta = min(left.beta, right.beta);\n            }else if(res.alpha == left.alpha + right.alpha){\n                res.beta = max(res.beta, min(left.beta, right.beta));\n            }\n        }\n    }\n\n    //横\n    for(int i = l + 1; i < r; i++){\n\n        P left, right;\n\n        //左\n        if(dp[l][t][i][b].alpha != 0){\n            left = dp[l][t][i][b];            \n        }else{\n            left = rec(l, t, i, b, acc, a);\n        }\n\n        //右\n        if(dp[i][t][r][b].alpha != 0){\n            right = dp[i][t][r][b];\n        }else{\n            right = rec(i, t, r, b, acc, a);\n        }\n\n        if(left.alpha != 0 && right.alpha != 0){\n            if(res.alpha < left.alpha + right.alpha){\n                res.alpha = left.alpha + right.alpha;\n                res.beta = min(left.beta, right.beta);\n            }else if(res.alpha == left.alpha + right.alpha){\n                res.beta = max(res.beta, min(left.beta, right.beta));\n            }\n        }\n    }\n\n    if(res.alpha == 0){\n        res.alpha = 1;\n        res.beta = sum - acc;\n    }\n\n    dp[l][t][r][b] = res;\n    return res;\n}\n\nint main(){\n\n    while(1){\n        \n        memset(dp, 0, sizeof(dp));\n\n        int num, power;\n        int h, w, s; cin >> h >> w >> s;\n        if(!h) break;\n\n        int sum = 0;\n        vector<vector<int> > a(h, vector<int> (w));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> a[i][j];\n                sum += a[i][j];\n            }\n        }\n\n        int acc = sum - s;\n        P ans = rec(0, 0, w, h, acc, a);\n        \n        //答え\n        cout << ans.alpha << \" \" << ans.beta << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef pair<int,int> P;\nint h,w,s,all,t[32][32];\nint rec[32][32][32][32]; //長方形の合計[ly][lx][hy][hx]\nP dp[32][32][32][32]; //メモ化\n\n//全ての(lx,ly)〜(hx,hy)の長方形合計を計算\nvoid mkRec(){\n  memset(rec,0,sizeof(rec));\n\n  rep(i,h){\n    rep(j,w){\n      rec[i][j][i][j] = t[i][j];\n\n      for(int y=i-1;y>=0;y--)\n        rec[y][j][i][j] = rec[y+1][j][i][j] + t[y][j];\n\n      for(int y=i;y>=0;y--){\n        int sum = 0;\n        for(int x=j;x>=0;x--){\n          sum += rec[y][x][i][x];\n          rec[y][x][i][j] = sum;\n        }\n      }\n    }\n  }\n}\n\n//戻り型 : P. first : 最大グループ数. second : 最大予備力\nP dfs(int lx,int ly,int hx,int hy){\n  if(dp[ly][lx][hy][hx].first != 0) return dp[ly][lx][hy][hx];\n\n  P res = P(1,s-(all-rec[ly][lx][hy][hx]));\n\n  //水平分割\n  for(int i=ly;i<hy;i++){\n    if(all - rec[ly][lx][i][hx] > s ||\n       all - rec[i+1][lx][hy][hx] > s) continue;\n    P a = dfs(lx,ly,hx,i);\n    P b = dfs(lx,i+1,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  //垂直分割\n  for(int j=lx;j<hx;j++){\n    if(all - rec[ly][lx][hy][j] > s ||\n       all - rec[ly][j+1][hy][hx] > s) continue;\n    P a = dfs(lx,ly,j,hy);\n    P b = dfs(j+1,ly,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  return dp[ly][lx][hy][hx] = res;\n}\n\nint main(void){\n  while(scanf(\"%d%d%d\",&h,&w,&s),h||w||s){\n    all = 0;\n    rep(i,h){\n      rep(j,w){\n        scanf(\"%d\",&t[i][j]);\n        all += t[i][j];\n      }\n    }\n\n    mkRec();\n\n    memset(dp,0,sizeof(dp));\n    P p = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",p.first,p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 33\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint h,w,s,sum=0;\nint u[MAX][MAX];\npii mem[MAX][MAX][MAX][MAX];\n\npii rec(int a,int b,int c,int d){\n  if(0<=mem[a][b][c][d].f)return mem[a][b][c][d];\n  pii res(0,inf);\n  if(a+1==c){\n    int r=0;\n    FOR(i,b,d)r+=u[a][i];\n    if(r<sum)return mp(0,inf);\n    res=mp(1,r);\n  }\n  if(b+1==d){\n    int r=0;\n    FOR(i,a,c)r+=u[i][b];\n    if(r<sum)return mp(0,inf);\n    res=mp(1,r);\n  }\n  FOR(i,a+1,c){\n    pii l=rec(a,b,i,d);\n    pii r=rec(i,b,c,d);\n    l.f+=r.f;\n    l.s=min(l.s,r.s);\n    res=max(res,l);\n  }\n  FOR(i,b+1,d){\n    pii l=rec(a,b,c,i);\n    pii r=rec(a,i,c,d);\n    l.f+=r.f;\n    l.s=min(l.s,r.s);\n    res=max(res,l);\n  }\n  mem[a][b][c][d]=res;\n  return res;\n}\n\nint main()\n{\n  while(cin>>h>>w>>s && h){\n    memset(mem,-1,sizeof(mem));\n    sum=0;\n    FOR(i,0,h){\n      FOR(j,0,w){\n        cin>>u[i][j];\n        sum+=u[i][j];\n      }\n    }\n    sum-=s;\n    pii res=rec(0,0,h,w);\n    cout<<res.f<<\" \"<<res.s-sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<p.first<<\" \"<<p.second;return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nvector<pii> memo;\nvvi city;\nint t,s;\n\nconstexpr int getBitCoor(int y, int x){\n\treturn (y<<5)+x;\n}\n\npii solve(int ty, int tx, int by, int bx){\n\tint c=(getBitCoor(ty,tx)<<10)+getBitCoor(by,bx);\n\tif(memo[c].first!=0) {\n\t\treturn memo[c];\n\t}\n\tpii ans(1,city[ty][tx]-city[ty][bx+1]-city[by+1][tx]+city[by+1][bx+1]);\n\tif(t-ans.sc>s)ans={-1,0};\n\t//cout<<\"default: \"<<pii(ty,tx)<<\",\"<<pii(by,bx)<<\":\"<<ans<<endl;\n\t\n\trange(x,tx,bx){\n\t\tauto a=solve(ty,tx,by,x);\n\t\tauto b=solve(ty,x+1,by,bx);\n\t\tif(a.fs==-1 or b.fs==-1) continue;\n\t\ta.fs+=b.fs;\n\t\ta.sc=min(a.sc,b.sc);\n\t\tif(ans.fs<a.fs or (ans.fs==a.fs and ans.sc<a.sc)){\n\t\t\tans=a;\n\t\t}\n\t}\n\trange(y,ty,by){\n\t\tauto a=solve(ty,tx,y,bx);\n\t\tauto b=solve(y+1,tx,by,bx);\n\t\tif(a.fs==-1 or b.fs==-1) continue;\n\t\ta.fs+=b.fs;\n\t\ta.sc=min(a.sc,b.sc);\n\t\tif(ans.fs<a.fs or (ans.fs==a.fs and ans.sc<a.sc)){\n\t\t\tans=a;\n\t\t}\n\t}\n\tif(ans.fs==0) ans.fs=-1;\n\t//cout<<pii(ty,tx)<<\",\"<<pii(by,bx)<<\" = \"<<ans<<endl;\n\treturn memo[c]=ans;\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint h,w;\n\twhile(cin>>h>>w>>s,h){\n\t\tt=0;\n\t\tmemo.resize(1<<20,pii(0,0));\n\t\tcity=vvi(h+1,vi(w+1,0));\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>city[i+1][j+1];\n\t\t\tt+=city[i+1][j+1];\n\t\t}\n\t\trep(i,h)rep(j,w){\n\t\t\tint lt=getBitCoor(i,j)<<10;\n\t\t\tint rb=getBitCoor(i,j);\n\t\t\tif(t-city[i+1][j+1]<=s){\n\t\t\t\tmemo[lt+rb]=pii(1,city[i+1][j+1]);\n\t\t\t}else{\n\t\t\t\tmemo[lt+rb]=pii(-1,0);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\trep(i,h+1)range(j,1,w+1) city[i][j]+=city[i][j-1];\n\t\trange(i,1,h+1)rep(j,w+1) city[i][j]+=city[i-1][j];\n\t\tauto ans=solve(0,0,h-1,w-1);\n\t\tans.sc=s-t+ans.sc;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint p[35][35];\nint memo[33][33][33][33];\nint M = 1000000007;\n\n//[l, r), [u, d)\n// max bunkatu\nint dfs(int l, int r, int u, int d, int mi) {\n    if (memo[l][r][u][d] != -1) return memo[l][r][u][d];\n    int sum = 0;\n    for (int i = l; i < r; ++i) {\n        for (int j = u; j < d; ++j) {\n            sum += p[i][j];\n        }\n    }\n    if (sum < mi) {\n        return memo[l][r][u][d] = -M;\n    }\n    int ret = 1;\n    for (int i = l + 1; i < r; ++i) {\n        ret = max(ret, dfs(l, i, u, d, mi) + dfs(i, r, u, d, mi));\n    }\n    for (int i = u + 1; i < d; ++i) {\n        ret = max(ret, dfs(l, r, u, i, mi) + dfs(l, r, i, d, mi));\n    }\n    return memo[l][r][u][d] = ret;\n}\nint main() {\n    while (1) {\n        int h, w, s;\n        cin >> h >> w >> s;\n        if (!h) return 0;\n        int sum = 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> p[i][j];\n                sum += p[i][j];\n            }\n        }\n        for (int i = 0; i < 33; ++i) {\n            for (int j = i + 1; j < 33; ++j) {\n                for (int k = 0; k < 33; ++k) {\n                    for (int l = k + 1; l < 33; ++l) {\n                        memo[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n        int ma = dfs(0, h, 0, w, sum - s);\n        int ok = sum - s, ng = sum + 1;\n        while (ok + 1 < ng) {\n            int m = (ok + ng) / 2;\n            for (int i = 0; i < 33; ++i) {\n                for (int j = i + 1; j < 33; ++j) {\n                    for (int k = 0; k < 33; ++k) {\n                        for (int l = k + 1; l < 33; ++l) {\n                            memo[i][j][k][l] = -1;\n                        }\n                    }\n                }\n            }\n            if (dfs(0, h, 0, w, m) == ma) {\n                ok = m;\n            }\n            else {\n                ng = m;\n            }\n        }\n        cout << ma << \" \" << (s- sum + ok) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint h, w, s, a[32][32], sum[33][33];\npi dp[32][32][32][32];\n\npi rec(int y, int x, int Y, int X){\n\tpi &res = dp[y][x][Y][X];\n\tif(res.first != -1) return res;\n\t\n\tres = mp(-inf, 0);\n\tif(sum[Y + 1][X + 1] - sum[Y + 1][x] - sum[y][X + 1] + sum[y][x] >= s){\n\t\tres = mp(1, sum[Y + 1][X + 1] - sum[Y + 1][x] - sum[y][X + 1] + sum[y][x] - s);\n\t}\n\tif(y < Y) for(int i = y; i < Y; i++){\n\t\tpi a = rec(y, x, i, X), b = rec(i + 1, x, Y, X);\n\t\ta.first += b.first;\n\t\ta.second = min(a.second, b.second);\n\t\tres = max(a, res);\n\t}\n\tif(x < X) for(int i = x; i < X; i++){\n\t\tpi a = rec(y, x, Y, i), b = rec(y, i + 1, Y, X);\n\t\ta.first += b.first;\n\t\ta.second = min(a.second, b.second);\n\t\tres = max(a, res);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> h >> w >> s, h){\n\t\ts *= -1;\n\t\trep(i, h) rep(j, w){\n\t\t\tcin >> a[i][j];\n\t\t\ts += a[i][j];\n\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\trep(k, h) rep(l, w) dp[i][j][k][l] = mp(-1, 0);\n\t\t}\n\t\tpi ans = rec(0, 0, h - 1, w - 1);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n#define sumof(a, b, c, d) (sum[a-1][b-1] + sum[c][d] - sum[a-1][d] - sum[c][b-1])\n#define INF (1<<28)\ntypedef pair<int, int> P;\nint h, w, s;\nint u[33][33];\nint sum[33][33];\nP dp[33][33][33][33];\nbool solve(){\n\tcin >> h >> w >> s;\n\tif(h == 0 && w == 0 && s == 0)return false;\n\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tcin >> u[i][j];\n\t\t\tsum[i][j] = u[i][j] - sum[i-1][j-1] + sum[i][j-1] + sum[i-1][j];\n\t\t}\n\t}\n\n\tint limit = sumof(1, 1, h, w) - s;\n\tfor(int i = 1;i <= h;i++){\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tfor(int k = i;k <= h;k++){\n\t\t\t\tfor(int l = j;l <= w;l++){\n\t\t\t\t\tint surplus = sumof(i, j, k, l) - limit;\n\t\t\t\t\tif(surplus < 0)\n\t\t\t\t\t\tdp[i][j][k][l] = P(-INF, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i][j][k][l] = P(1, surplus);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tfor(int k = 1;k+i <= h;k++){\n\t\t\t\tfor(int l = 1;l+j <= w;l++){\n\t\t\t\t\tP &tmp = dp[k][l][k+i][l+j];\n\t\t\t\t\t\n\t\t\t\t\tfor(int mid = k;mid < k+i;mid++){\n\t\t\t\t\t\tint cnt, surplus;\n\t\t\t\t\t\tcnt = dp[k][l][mid][l+j].first + dp[mid+1][l][k+i][l+j].first;\n\t\t\t\t\t\tsurplus = min(dp[k][l][mid][l+j].second, dp[mid+1][l][k+i][l+j].second);\n\t\t\t\t\t\ttmp = max(tmp, P(cnt, surplus));\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tfor(int mid = l;mid < l+j;mid++){\n\t\t\t\t\t\tint cnt, surplus;\n\t\t\t\t\t\tcnt = dp[k][l][k+i][mid].first + dp[k][mid+1][k+i][l+j].first;\n\t\t\t\t\t\tsurplus = min(dp[k][l][k+i][mid].second, dp[k][mid+1][k+i][l+j].second);\n\t\t\t\t\t\ttmp = max(tmp, P(cnt, surplus));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[1][1][h][w].first << \" \" << dp[1][1][h][w].second << endl;\n\treturn true;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nstruct Split{\npublic:\n  int number;\n  int reserve;\n  Split():number(0),reserve(0){}\n  Split(int num,int res):number(num),reserve(res){}\n  bool operator<(const Split &hoge) {\n    return number<hoge.number || (number==hoge.number && reserve<hoge.reserve);\n  }\n  Split operator+(const Split &hoge) {\n    if (number<=0 || hoge.number<=0)\n      return Split();\n    else\n      return Split(number+hoge.number,std::min(reserve,hoge.reserve));\n  }\n};\n\nSplit dp[50][50][50][50];\nint demand[50][50];\nint h,w,supply,total;\n\nvoid init() {\n  total = 0;\n  for(int i=0; i<32; i++)\n    for(int j=0; j<32; j++)\n      for(int k=0; k<32; k++)\n\tfor(int l=0; l<32; l++)\n\t  dp[i][j][k][l] = Split();\n}\n\nint main() {\n  while(scanf(\"%d %d %d\",&h,&w,&supply),h>0) {\n    init();\n    for (int y=0; y<h; y++)\n      for (int x=0; x<w; x++) {\n\tscanf(\"%d\",&demand[x][y]);\n\ttotal += demand[x][y];\n      }\n\n    for(int wd=1; wd<=w; wd++)\n      for(int hg=1; hg<=h; hg++)\n\tfor(int x=0; x+wd<=w; x++)\n\t  for(int y=0; y+hg<=h; y++) {\n\t    Split tmp,ans;\n\t    for(int sx=x+1; sx<x+wd; sx++) {\n\t      tmp = dp[x][sx][y][y+hg]+dp[sx][x+wd][y][y+hg];\n\t      ans = ans<tmp?tmp:ans;\n\t    }\n\t    for(int sy=y+1; sy<y+hg; sy++) {\n\t      tmp = dp[x][x+wd][y][sy]+dp[x][x+wd][sy][y+hg];\n\t      ans = ans<tmp?tmp:ans;\n\t    } \n\n\t    int sum=0;\n\t    for(int x1=x; x1<x+wd; x1++)\n\t      for(int y1=y; y1<y+hg; y1++)\n\t\tsum += demand[x1][y1];\n\t    int reserve = supply-total+sum;\n\t    if(reserve>=0) {\n\t      tmp = Split(1,reserve);\n\t      ans = ans<tmp?tmp:ans;\n\t    }\n\t    dp[x][x+wd][y][y+hg] = ans;\n\t  }\n\n\n    printf(\"%d %d\\n\",dp[0][w][0][h].number,dp[0][w][0][h].reserve);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint h, w, s;\nint u[32][32];\nint a[33][33];\nP dp[33][33][33][33];\n\nvoid integrate(){\n\trep(i, h + 1){\n\t\tfill_n(a[i], w + 1, 0);\n\t}\n\trep(i, h){\n\t\trep(j, w){\n\t\t\ta[i + 1][j + 1] = u[i][j];\n\t\t}\n\t}\n\trep(i, h){\n\t\trep(j, w + 1){\n\t\t\ta[i + 1][j] += a[i][j];\n\t\t}\n\t}\n\trep(i, h + 1){\n\t\trep(j, w){\n\t\t\ta[i][j + 1] += a[i][j];\n\t\t}\n\t}\n}\n\nint area(int s, int t, int u, int v){\n\treturn a[u][v] - a[s][v] - a[u][t] + a[s][t];\n}\n\nvoid init(){\n\trep(i, h + 1){\n\t\trep(j, w + 1){\n\t\t\trep(k, h + 1){\n\t\t\t\tfill_n(dp[i][j][k], w + 1, P(0, 0));\n\t\t\t}\n\t\t}\n\t}\n}\n\nP& ap(int a, int b, int c, int d){\n\treturn dp[a][b][c][d];\n}\n\nint& af(int a, int b, int c, int d){\n\treturn ap(a, b, c, d).first;\n}\n\nP unite(const P& p, const P& q){\n\treturn P(p.first + q.first, min(p.second, q.second));\n}\n\nP dfs(int a, int b, int c, int d){\n\tif(af(a, b, c, d)){\n\t\treturn ap(a, b, c, d);\n\t}\n\n\tif(c - a == 1 && d - b == 1){\n\t\treturn P(1, u[a][b] - s);\n\t}\n\n\tP p(1, area(a, b, c, d) - s);\n\tfor(int i = a + 1; i < c; ++i){\n\t\tif(area(a, b, i, d) < s || area(i, b, c, d) < s){\n\t\t\tcontinue;\n\t\t}\n\t\tP x = dfs(a, b, i, d);\n\t\tP y = dfs(i, b, c, d);\n\t\tP z = unite(x, y);\n\t\tp = max(z, p);\n\t}\n\tfor(int i = b + 1; i < d; ++i){\n\t\tif(area(a, b, c, i) < s || area(a, i, c, d) < s){\n\t\t\tcontinue;\n\t\t}\n\t\tP x = dfs(a, b, c, i);\n\t\tP y = dfs(a, i, c, d);\n\t\tP z = unite(x, y);\n\t\tp = max(z, p);\n\t}\n\treturn ap(a, b, c, d) = p;\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\", &h, &w, &s), h){\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tscanf(\"%d\", &u[i][j]);\n\t\t\t}\n\t\t}\n\t\tintegrate();\n\t\ts = area(0, 0, h, w) - s;\n\t\tinit();\n\t\tP p = dfs(0, 0, h, w);\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Score {\n    Score() = default;\n    Score(int g, int p) : group{g}, preparation{p} {}\n    bool operator<(const Score& s) const\n    {\n        if (group < s.group) {\n            return true;\n        } else if (s.group < group) {\n            return false;\n        }\n        if (preparation < s.preparation) {\n            return true;\n        }\n        return false;\n    }\n    Score operator+(const Score& s) const\n    {\n        return Score{group + s.group, min(preparation, s.preparation)};\n    }\n    int group;\n    int preparation;\n};\n\nint main()\n{\n    while (true) {\n        int h, w, s;\n        cin >> h >> w >> s;\n        if (h == 0 and w == 0 and s == 0) {\n            break;\n        }\n        vector<vector<int>> need(h, vector<int>(w));\n        vector<vector<int>> sum(h, vector<int>(w, 0));\n        vector<vector<vector<vector<Score>>>> dp(h + 1, vector<vector<vector<Score>>>(h + 1, vector<vector<Score>>(w + 1, vector<Score>(w + 1, Score{0, 0}))));\n        int needsum = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> need[i][j];\n                needsum += need[i][j];\n                if (i == 0 and j == 0) {\n                    sum[i][j] = need[i][j];\n                } else if (i == 0) {\n                    sum[i][j] = sum[i][j - 1] + need[i][j];\n                } else if (j == 0) {\n                    sum[i][j] = sum[i - 1][j] + need[i][j];\n                } else {\n                    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + need[i][j];\n                }\n            }\n        }\n\n        const int necessary = needsum - s;\n        for (int lint = 1; lint <= h; lint++) {\n            for (int rint = 1; rint <= w; rint++) {\n                for (int l1 = 0; l1 <= h - lint; l1++) {\n                    for (int r1 = 0; r1 <= w - rint; r1++) {\n                        const int l2 = l1 + lint;\n                        const int r2 = r1 + rint;\n                        Score maxscore = Score{0, numeric_limits<int>::min()};\n                        int needsum = sum[l2 - 1][r2 - 1];\n                        if (l1 > 0) {\n                            needsum -= sum[l1 - 1][r2 - 1];\n                        }\n                        if (r1 > 0) {\n                            needsum -= sum[l2 - 1][r1 - 1];\n                        }\n                        if (r1 > 0 and l1 > 0) {\n                            needsum += sum[l1 - 1][r1 - 1];\n                        }\n                        if (needsum >= necessary) {\n                            maxscore.group = 1;\n                            maxscore.preparation = needsum - necessary;\n                        } else {\n                            maxscore.group = 0;\n                            maxscore.preparation = necessary - needsum;\n                        }\n\n                        for (int l = l1 + 1; l < l2; l++) {\n                            const Score s1 = dp[l1][l][r1][r2];\n                            const Score s2 = dp[l][l2][r1][r2];\n                            const Score s = s1 + s2;\n                            if (maxscore < s) {\n                                maxscore = s;\n                            }\n                        }\n                        for (int r = r1 + 1; r < r2; r++) {\n                            const Score s1 = dp[l1][l2][r1][r];\n                            const Score s2 = dp[l1][l2][r][r2];\n                            const Score s = s1 + s2;\n                            if (maxscore < s) {\n                                maxscore = s;\n                            }\n                        }\n                        dp[l1][l2][r1][r2] = maxscore;\n                        // cout << \"l1: \" << l1 << \" l2: \" << l2 << \" r1: \" << r1 << \" r2: \" << r2 << endl;\n                        // cout << dp[l1][l2][r1][r2].group << \" \" << dp[l1][l2][r1][r2].preparation << endl;\n                    }\n                }\n            }\n        }\n        const Score ans = dp[0][h][0][w];\n        cout << ans.group << \" \" << ans.preparation << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nconst pii INIT = pii(-1,-1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y){\n  return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\npii solve(int l, int t, int r, int b){\n  pii& ans = memo[l][t][r][b];\n  if(ans != INIT) return ans;\n\n  int sum = getsum(l,t,r,b);\n  if(sum < E - S) return ans = pii(0, 0);\n  \n  ans = pii(1, S - E + sum);\n  \n  for(int i = l+1; i < r; ++i){\n    pii ra = solve(l,t,i,b);\n    pii rb = solve(i,t,r,b);\n    pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n    ans = max(ans, temp);\n  }\n\n  for(int i = t+1; i < b; ++i){\n    pii ra = solve(l,t,r,i);\n    pii rb = solve(l,i,r,b);\n    pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n    ans = max(ans, temp);\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> H >> W >> S, H){\n    memset(board, 0, sizeof(board));\n    for(int i = 0; i < 33; ++i)\n      for(int j = 0; j < 33; ++j)\n\tfor(int k = 0; k < 33; ++k)\n\t  for(int l = 0; l < 33; ++l)\n\t    memo[i][j][k][l] = INIT;\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tcin >> board[i+1][j+1];\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tboard[i+1][j+1] += board[i+1][j];\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tboard[i+1][j+1] += board[i][j+1];\n\n    E = getsum(0,0,H,W);\n    pii ans = solve(0,0,H,W);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1000000 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = (resl / 1000000 + resr / 1000000) * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = (resl / 1000000 + resr / 1000000) * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << ret / 1000000 << ' ' << ret % 1000000 - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n\ntypedef pair<int,int> P;\n\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\nint rec[34][34][34][34];\n\n\nint count(int ax, int ay, int bx, int by){\n\tint i, j, sum_c = 0;\n\tif(rec[ax][ay][bx][by] != 0) return rec[ax][ay][bx][by];\n\tfor(i = ax; i <= bx; i++){\n\t\tfor(j = ay; j <= by; j++){\n\t\t\tsum_c += area[i][j];\n\t\t}\n\t}\n\treturn rec[ax][ay][bx][by] = sum_c;\n}\n\n\nP split(int ax, int ay, int bx, int by){\n\tP max_group, group, g1, g2;\n\tint sum_e = 0;\n\tint i, j;\n\t\n\tif(memo[ax][ay][bx][by].first != 0) return memo[ax][ay][bx][by];\n\n\tmax_group = P(1, s - (sum - count(ax,ay,bx,by)));\n\n\tfor(i = ay; i < by; i++){\n\t\tif(sum - count(ax,ay,bx,i)\t> s || \n\t\t   sum - count(ax,i+1,bx,by) > s) continue;\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i+1, bx, by);\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\tfor(j = ax; j < bx; j++){\n\t\tif(sum - count(ax,ay,j,by) > s || \n\t\t   sum - count(j+1,ay,bx,by) > s) continue;\n\t\tg1 = split(ax, ay, j, by);\n\t\tg2 = split(j + 1, ay, bx, by);\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\treturn memo[ax][ay][bx][by] = max_group;\n}\n\n\nint main(void){\n\tint i,j;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tsum = 0;\n\t\tfor(i = 1; i <= w; i++){\n\t\t\tfor(j = 1; j <= h; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n\t\t}\n\t\tans = split(1, 1, h, w);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nint mem[32][32][32][32];//mem[a][b][c][d]はarray[a][b]->array[c][d]の最大領域数を記録\nint mem2[32][32][32][32];//mem2[a][b][c][d]はarray[a][b]->array[c][d]の最大領域数時の最小需要量の最大を記録\n\n//指定の間の配列の合計を返す\nint sumOfMatrix(int a[32][32],int sx,int sy,int tx,int ty){\n\tint res=0;\n\tfor(int i=sy;i<ty;i++){\n\t\tfor(int j=sx;j<tx;j++){\n\t\t\tres+=a[i][j];\n\t\t}\n\t}\n\n\treturn res;\n}\n//デバッグ用の配列表示\nvoid viewMatrix(int a[32][32],int sx,int sy,int tx,int ty){\n\tint res=0;\n\tfor(int i=sy;i<ty;i++){\n\t\tfor(int j=sx;j<tx;j++){\n\t\t\tprintf(\"%3d \",a[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n//再帰的に探索する．a[sy][sx]->a[ty][tx]の最大分割数とそのときの最小の使用量の最大のペアを出力\npair<int,int> solve(int a[32][32],int sx,int sy,int tx,int ty,int sum, int sval){\n\tpair<int,int> p;\n\tpair<int,int> pls[4];\n\tpair<int,int> mp1,mp2;\n\t\n\t//出力するpを，領域数を1，その領域の使用量として初期化する．\n\tp.first = 1;\n\tp.second = sumOfMatrix(a,sx,sy,tx,ty);\n\n\t//plsというペア配列を初期化\n\tfor(int i=0;i<4;i++){\n\t\tpls[i].first=0;\n\t\tpls[i].second=10000;//使用料は十分大きい値とする．\n\t}\n\t//mp1,mp2の領域数を０で初期化\n\tmp1.first=0;\n\tmp2.first=0;\n\n\t//mp1には横(xに対して)に割った場合の最大値\n\t//mp2には縦(yに対して)に割った場合の最大値\n\t//ｘ方向に二つ以上に分割できるなら\n\tif((tx-sx)>1){\n\t\t//sx->x,x+1->txに分割する．\n\t\tfor(int x=sx;x<tx;x++){\n\n\t\t\t//分割した先の二つの領域ともに供給量制約を満たすなら\n\t\t\tif((sumOfMatrix(a,sx,sy,x+1,ty)>=sval)&&(sumOfMatrix(a,x+1,sy,tx,ty)>=sval)){\n\n\t\t\t\t//sx->x+1に割った方について\n\t\t\t\t//メモを確認して探索済みかどうかをチェックする．\n\t\t\t\tif(mem[sx][sy][x+1][ty]==0){//探索していないなら\n\t\t\t\t\tpls[0]=solve(a,sx,sy,x+1,ty,sum,sval);//sx->x+1に割った方の値をpls[0]に代入する\n\n\t\t\t\t\tmem[sx][sy][x+1][ty]=pls[0].first;//メモに値を与えて，次に探索する場合はこちらを参照するようにする．\n\t\t\t\t\tmem2[sx][sy][x+1][ty]=pls[0].second;//その時の最小の最大値をmem2にもメモする．\n\t\t\t\t}else{\n\t\t\t\t\t//メモがあるならばメモの値を与える．\n\t\t\t\t\tpls[0].first=mem[sx][sy][x+1][ty];\n\t\t\t\t\tpls[0].second=mem2[sx][sy][x+1][ty];\n\t\t\t\t}\n\n\t\t\t\t//x+1->txに割った方についても同様にする．\n\t\t\t\tif(mem[x+1][sy][tx][ty]==0){\n\t\t\t\t\tpls[1]=solve(a,x+1,sy,tx,ty,sum,sval);\n\n\t\t\t\t\tmem[x+1][sy][tx][ty]=pls[1].first;\n\t\t\t\t\tmem2[x+1][sy][tx][ty]=pls[1].second;\n\t\t\t\t}else{\n\t\t\t\t\tpls[1].first=mem[x+1][sy][tx][ty];\n\t\t\t\t\tpls[1].second=mem2[x+1][sy][tx][ty];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//元の大きさに対して，今での割り方のなかで最大なものと今回割った場合の値を比較する．\n\t\t\tif(mp1.first<(pls[0].first+pls[1].first)){\n\t\t\t\tmp1.first=pls[0].first+pls[1].first;//今までより大きいなら領域数を更新\n\t\t\t\tmp1.second=min(pls[0].second,pls[1].second);//その場合は小さい方の需要量を与える．\n\t\t\t}\n\t\t\tif(mp1.first==(pls[0].first+pls[1].first)){//もし値が同じなら，pls[0]と[1]の小さい方と今までとを比較して”大きい方”を選ぶ\n\t\t\t\tmp1.second=max(mp1.second,min(pls[0].second,pls[1].second));\n\t\t\t}\n\n\n\t\t}\n\t}\n\t//ｙについても同じ事をする．\n\tif((ty-sy)>1){\n\t\tfor(int y=sy;y<ty;y++){\n\t\t\tif((sumOfMatrix(a,sx,sy,tx,y+1)>=sval)&&(sumOfMatrix(a,sx,y+1,tx,ty)>=sval)){\n\t\t\t\tif(mem[sx][sy][tx][y+1]==0){\n\t\t\t\t\tpls[2]=solve(a,sx,sy,tx,y+1,sum,sval);\n\n\t\t\t\t\tmem[sx][sy][tx][y+1]=pls[2].first;\n\t\t\t\t\tmem2[sx][sy][tx][y+1]=pls[2].second;\n\t\t\t\t}else{\n\t\t\t\t\tpls[2].first=mem[sx][sy][tx][y+1];\n\t\t\t\t\tpls[2].second=mem2[sx][sy][tx][y+1];\n\t\t\t\t}\n\t\t\t\tif(mem[sx][y+1][tx][ty]==0){\n\t\t\t\t\tpls[3]=solve(a,sx,y+1,tx,ty,sum,sval);\n\n\t\t\t\t\tmem[sx][y+1][tx][ty]=pls[3].first;\n\t\t\t\t\tmem2[sx][y+1][tx][ty]=pls[3].second;\n\t\t\t\t}else{\n\t\t\t\t\tpls[3].first=mem[sx][y+1][tx][ty];\n\t\t\t\t\tpls[3].second=mem2[sx][y+1][tx][ty];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp2.first<(pls[2].first+pls[3].first)){\n\t\t\t\tmp2.first=pls[2].first+pls[3].first;\n\t\t\t\tmp2.second=min(pls[2].second,pls[3].second);\n\t\t\t}\n\t\t\tif(mp2.first==(pls[2].first+pls[3].first)){\n\t\t\t\tmp2.second=max(mp2.second,min(pls[2].second,pls[3].second));\n\t\t\t}\n\t\t}\n\t}\n\n\t//xに割ったものの分割数の最大値と，yに割ったものの分割数の最大値を比較する．\n\tif((mp1.first) > (mp2.first)){//mp1>mp2ということはmp[1,2]!=0\n\t\tp.first=mp1.first;\n\t\tp.second=mp1.second;\n\t}\n\telse{\n\t\t//最小値が一緒の場合は需要量ができるだけ大きい方をえらぶ\n\t\tif((mp1.first) == (mp2.first)){\n\t\t\tmp2.second=max(mp1.second,mp2.second);\n\t\t}\n\t\t//上の条件式ではmp2も0の可能性があるので，確認する.\n\t\tif(mp2.first!=0){//mpが0じゃない＝ということは1度は再起しているので\n\t\t\tp.first=mp2.first;\n\t\t\tp.second=mp2.second;\n\t\t}\n\t}\n\t//上のifに引っかからなかったということはそれは再起の底だから最初に設定したpをそのまま出力する．\n\n\treturn p;\n}\n\n\nint main(void){\n\tint h,w,s;\n\n\tint table[32][32];\n\n\tint sum;\n\tint sval;\n\n\tpair<int,int> res;\n\n\twhile(true){\n\t\t//データを初期化\n\t\tfor(int i=0;i<32;i++){\n\t\t\tfor(int j=0;j<32;j++) table[i][j]=-1;\n\t\t}\n\t\t//メモの初期化\n\t\tfor(int i=0;i<32;i++){\n\t\t\tfor(int j=0;j<32;j++){\n\t\t\t\tfor(int k=0;k<32;k++){\n\t\t\t\t\tfor(int l=0;l<32;l++){\n\t\t\t\t\t\tmem[i][j][k][l]=0;\n\t\t\t\t\t\tmem2[i][j][k][l]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//hを入力\n\t\tcin >> h;\n\t\tif(h==0) break;\n\t\tcin >> w;\n\t\tcin >> s;\n\t\tsum=0;\n\t\t//tableに入力\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tsum+=table[i][j];\n\t\t\t}\n\t\t}\n\t\t//svalは許容する最大需要量（ようするに需要量の合計から供給量を引いた数）\n\t\tsval=sum-s;\n\n\t\tres=solve(table,0,0,w,h,sum,sval);\t\n\t\t\n\t\tcout << res.first << \" \" << (res.second-sval) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint sum;\nint H, W, S;\nint tab[32][32];\nPII memo[32][32][32][32];\nPII dfs(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2].first >= 0) return memo[x1][y1][x2][y2];\n  \n  int tot = 0;\n  for(int y=y1;y<y2;++y)\n\tfor(int x=x1;x<x2;++x)\n\t  tot += tab[y][x];\n  if(sum - tot > S) return memo[x1][y1][x2][y2] = MP(0,0);\n\n  int mx = 1, g = tot;\n  for(int x=x1+1;x<x2;++x){\n\tPII p1 = dfs(x1,y1,x,y2);\n\tPII p2 = dfs(x,y1,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tif(mx < p1.first + p2.first){\n\t  mx = p1.first + p2.first;\n\t  g = min(p1.second, p2.second);\n\t}\n\telse if(mx == p1.first + p2.first){\n\t  g = max(g, min(p1.second, p2.second));\n\t}\n  }\n\n  for(int y=y1+1;y<y2;++y){\n\tPII p1 = dfs(x1,y1,x2,y);\n\tPII p2 = dfs(x1,y,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tif(mx < p1.first + p2.first){\n\t  mx = p1.first + p2.first;\n\t  g = min(p1.second, p2.second);\n\t}\n\telse if(mx == p1.first + p2.first){\n\t  g = max(g, min(p1.second, p2.second));\n\t}\n  }\n\n  return memo[x1][y1][x2][y2] = MP(mx,g);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>W>>S,H){\n\tREP(y,H) REP(x,W) cin >> tab[y][x];\n\tsum = 0;\n\tREP(y,H) REP(x,W) sum += tab[y][x];\n\tREP(i1,32) REP(i2,32) REP(i3,32) REP(i4,32)\n\t  memo[i1][i2][i3][i4].first = -1;\n\n\t\n\tPII pii = dfs(0,0,W,H);\n\tcout << pii.first << \" \" << S + pii.second - sum << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nconst int N = 40;\n\nint h, w, s, u[N][N], a[N][N], total;\n\nvoid input()\n{\n    memset(u, 0, sizeof(u));\n    memset(a, 0, sizeof(a));\n\n    rep(i, h) rep(j, w) {\n        cin >> u[i][j];\n        a[i + 1][j + 1] = a[i + 1][j] + a[i][j + 1] - a[i][j] + u[i][j];\n    }\n    total = a[h][w];\n}\n\ninline int acc(int x, int y, int xx, int yy)\n{\n    return a[yy][xx] - a[y][xx] - a[yy][x] + a[y][x];\n}\n\ntypedef pair<int, int> pii;\n\npii f(pii a, pii b)\n{\n    return mp(a.first + b.first, min(a.second, b.second));\n}\n\npii mem[N][N][N][N];\n\npii recur(int x, int y, int xx, int yy)\n{\n    pii& ret = mem[x][y][xx][yy];\n    if (ret.first >= 0) return ret;\n\n    int part = acc(x, y, xx, yy);\n    if (total - part > s) return mp(-1, -1);\n\n    ret = mp(1, s - (total - part));\n    repi(mx, x + 1, xx) {\n        pii tmp = f(recur(x, y, mx, yy), recur(mx, y, xx, yy));\n        ret = max(ret, tmp);\n    }\n    repi(my, y + 1, yy) {\n        pii tmp = f(recur(x, y, xx, my), recur(x, my, xx, yy));\n        ret = max(ret, tmp);\n    }\n    return ret;\n}\n\nvoid solve()\n{\n    memset(mem, -1, sizeof(mem));\n\n    pii ans = recur(0, 0, w, h);\n    cout << ans.first << ' ' << ans.second << endl;\n}\n\nint main()\n{\n    while (cin >> h >> w >> s and h) {\n        input();\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-10;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\ntypedef pair<int,int> pii;\nint h,w,s;\npii dp[40][40][40][40];\nint sums[40][40];\nint field[101][101];\nint allDemands;\n\nint getRangeNum(int minx,int miny,int maxx,int maxy){\n\tminx++;miny++;maxx++;maxy++;\n\treturn sums[maxy][maxx]-sums[miny-1][maxx]-sums[maxy][minx-1]+sums[miny-1][minx-1];\n}\n\npii dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[minx][miny][maxx][maxy].first>=0)return dp[minx][miny][maxx][maxy];\n\tpii res=pii(0,0);\n\tbool fin=false;\n\t// split y\n\tfor(int i=miny+1;i<=maxy;i++){\n\t\tint a=getRangeNum(minx,miny,maxx,i-1);\n\t\tint b=getRangeNum(minx,i,maxx,maxy);\n\t\tif(allDemands-a>s||allDemands-b>s)\n\t\t\tcontinue;\n\t\tfin=true;\n\t\tpii p1=dfs(minx,miny,maxx,i-1);\n\t\tpii p2=dfs(minx,i,maxx,maxy);\n\t\tpii cand=pii(p1.first+p2.first,min(p1.second,p2.second));\n\t\tres=max(res,cand);\n\t}\n\t// split x\n\tfor(int i=minx+1;i<=maxx;i++){\n\t\tint a=getRangeNum(minx,miny,i-1,maxy);\n\t\tint b=getRangeNum(i,miny,maxx,maxy);\n\t\tif(allDemands-a>s||allDemands-b>s)\n\t\t\tcontinue;\n\t\tfin=true;\n\t\tpii p1=dfs(minx,miny,i-1,maxy);\n\t\tpii p2=dfs(i,miny,maxx,maxy);\n\t\tpii cand=pii(p1.first+p2.first,min(p1.second,p2.second));\n\t\tres=max(res,cand);\n\t}\n\tif(!fin)\n\t\tres=pii(1,getRangeNum(minx,miny,maxx,maxy));\n\treturn dp[minx][miny][maxx][maxy]=res;\n}\n\nvoid solve(){\n\n\twhile(cin>>h>>w>>s&&(h|w|s)){\n\t\tfor(int i=0;i<33;i++)\n\t\t\tfor(int j=0;j<33;j++)\n\t\t\t\tfor(int k=0;k<33;k++)\n\t\t\t\t\tfor(int l=0;l<33;l++)\n\t\t\t\t\t\tdp[i][j][k][l]=pii(-1,-1);\n\t\tallDemands=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tallDemands+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tmemset(sums,0,sizeof(sums));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tsums[i+1][j+1]=sums[i][j+1]+sums[i+1][j]-sums[i][j]+field[i][j];\n\t\t\t}\n\t\t}\n\t\tpii p=dfs(0,0,w-1,h-1);\n\t\tcout<<p.first<<\" \"<<s-(allDemands-p.second)<<endl;\n\t}\n\n}\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint const inf = 1<<28;\nint H,W,S;\nint a[33][33];\n\nint T;\nint sum[35][35];\npii dp[33][33][33][33];\n\nint s(int x, int y, int w, int h){\n    return sum[y+h][x+w]-sum[y][x+w]-sum[y+h][x]+sum[y][x];\n}\n\n// x,y,w,hの長方形でできる分割の数の最大、分割の最小\npii f(int x, int y, int w, int h){\n    auto & res = dp[x][y][w][h];\n    if(res!=mp(-1,-1)) return res;\n    if(s(x,y,w,h) < T) return res = mp(-inf,inf);\n    res = mp(1,s(x,y,w,h));\n    for(int i=1;i<w;i++){\n        int a1,b1,a2,b2;\n        tie(a1,b1)=f(x,y,i,h);\n        tie(a2,b2)=f(x+i,y,w-i,h);\n        res = max(res,mp(a1+a2,min(b1,b2)));\n    }\n    for(int i=1;i<h;i++){\n        int a1,b1,a2,b2;\n        tie(a1,b1)=f(x,y,w,i);\n        tie(a2,b2)=f(x,y+i,w,h-i);\n        res = max(res,mp(a1+a2,min(b1,b2)));\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> H >> W >> S && H){\n        rep(i,33)rep(j,33)rep(k,33)rep(l,33)dp[i][j][k][l] = mp(-1,-1);\n        rep(i,H)rep(j,W)cin >> a[i][j];\n        memset(sum,0,sizeof(sum));\n        rep(i,H)rep(j,W) sum[i+1][j+1] = a[i][j];\n        rep(i,H+1)rep(j,W+1) sum[i][j+1] += sum[i][j];\n        rep(i,H+1)rep(j,W+1) sum[i+1][j] += sum[i][j];\n        T = sum[H][W]-S;\n        int p,q;\n        tie(p,q) = f(0,0,W,H);\n        cout << p << \" \" << q-sum[H][W]+S << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\n/** 累積和 */\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/** /累積和 */\n\n\ntypedef tuple<int, int, int, int> Kukei;\n\nint H, W, S;\nint total_power;\nVVI tile;\nVVI c_tile;\nvector< vector< vector< vector<PII> > > > memo;\n\nbool can_group(int x1, int x2, int y1, int y2) {\n\treturn total_power - S <= sum_csum2<int>(c_tile, y1, y2, x1, x2);\n}\n\nPII dfs(int x1, int x2, int y1, int y2) {\n\tPII tmp = memo[y1][x1][y2][x2];\n\tif (tmp.first != -1) {\n\t\treturn tmp;\n\t}\n\t\n\tPII res(-1, -1);\n\n\tfor (int v = x1 + 1; v < x2; v++) {\n\t\tPII a = dfs(x1, v, y1, y2);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(v, x2, y1, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tfor (int h = y1 + 1; h < y2; h++) {\n\t\tPII a = dfs(x1, x2, y1, h);\n\n\t\tif (a.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tPII b = dfs(x1, x2, h, y2);\n\n\t\tif (b.first == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = max(res, make_pair(a.first + b.first, min(a.second, b.second)));\n\t}\n\n\tif (res.first == -1 && can_group(x1, x2, y1, y2)) {\n\t\tres = make_pair(1, sum_csum2<int>(c_tile, y1, y2, x1, x2));\n\t}\n\n\treturn memo[y1][x1][y2][x2] = res;\n}\n\nint main(void) {\n\twhile(cin >> H >> W >> S, H) {\n\t\ttile = VVI(H, VI(W, 0));\n\t\ttotal_power = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\ttotal_power += tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemo = vector< vector< vector< vector<PII> > > >(H + 1,\n\t\t\t\tvector< vector< vector<PII> > >(W + 1,\n\t\t\t\tvector< vector<PII> >(H + 1,\n\t\t\t\tvector<PII>(W + 1,\n\t\t\t\tmake_pair(-1, -1)))));\n\n\t\tc_tile = calc_csum2<int>(tile);\n\n\t\tPII ans = dfs(0, W, 0, H);\n\n\t\tcout << ans.first << \" \" << (S - total_power + ans.second) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint area[33][33][33][33];\npair<int,int> dp[33][33][33][33];\nint H,W,provided_power;\n\npair<int,int> dfs(int lx,int ly,int rx,int ry){\n  if(dp[lx][ly][rx][ry].first != -1) return dp[lx][ly][rx][ry];\n\n  if(area[0][0][W-1][H-1] - area[lx][ly][rx][ry] > provided_power){\n    dp[lx][ly][rx][ry].first = 0;\n    return dp[lx][ly][rx][ry];\n  }\n\n  int diff = abs((area[0][0][W-1][H-1] - area[lx][ly][rx][ry]) - provided_power);\n  pair<int,int> res(1,diff);\n  for(int x=lx;x+1<=rx;x++){\n    pair<int,int> left = dfs(lx,ly,x,ry);\n    pair<int,int> right = dfs(x+1,ly,rx,ry);\n\n    if(left.first > 0 && right.first > 0){\n      pair<int,int> tmp = make_pair(left.first + right.first,min(left.second,right.second));\n      res = max(tmp,res);\n    }\n  }\n\n  for(int y=ly;y+1<=ry;y++){\n    pair<int,int> upper = dfs(lx,ly,rx,y);\n    pair<int,int> lower = dfs(lx,y+1,rx,ry);\n    if(upper.first > 0 && lower.first > 0){\n      pair<int,int> tmp = make_pair(upper.first + lower.first,min(upper.second,lower.second));\n      res = max(tmp,res);\n    }\n  }\n\n  return (dp[lx][ly][rx][ry] = res);\n}\n\nint main(){\n  while(~scanf(\"%d %d %d\",&H,&W,&provided_power)){\n    if(H==0 && W==0 && provided_power == 0) break;\n    int stage[33][33];\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tint needs;\n\tscanf(\"%d\",&needs);\n\tstage[y][x] = needs;\n      }\n    }\n\n    //compute area\n    memset(area,0,sizeof(area));\n    for(int ly=0;ly<H;ly++){\n      for(int lx=0;lx<W;lx++){\n\tfor(int ry=0;ry<H;ry++){\n\t  for(int rx=0;rx<W;rx++){\n\t    int sum = 0;\n\t    for(int y=ly;y<=ry;y++){\n\t      for(int x=lx;x<=rx;x++){\n\t\tsum += stage[y][x];\n\t      }\n\t    }\n\t    //init dp\n\t    dp[lx][ly][rx][ry].first = -1;\n\t    dp[lx][ly][rx][ry].second = INF;\n\n\t    area[lx][ly][rx][ry] = sum;\n\t  }\n\t}\n      }\n    }\n\n    pair<int,int> res = dfs(0,0,W-1,H-1);\n    printf(\"%d %d\\n\",res.first,res.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint h,w,s,as;\nint g[33][33];\nint sum[33][33];\npint dp[33][33][33][33];\npint dfs(int lx,int ly,int rx,int ry){\n    if(dp[ly][lx][ry][rx].first!=-1) return dp[ly][lx][ry][rx];\n    pint ret={0,0};\n    int ts=sum[ry+1][rx+1]-sum[ly][rx+1]-sum[ry+1][lx]+sum[ly][lx];\n    if(as-ts>s) return ret;\n    else ret={1,ts};\n    for(int i=lx;i<rx;++i){\n        pint l=dfs(lx,ly,i,ry),r=dfs(i+1,ly,rx,ry);\n        ret=max(ret,{l.first+r.first,min(l.second,r.second)});\n    }\n    for(int i=ly;i<ry;++i){\n        pint l=dfs(lx,ly,rx,i),r=dfs(lx,i+1,rx,ry);\n        ret=max(ret,{l.first+r.first,min(l.second,r.second)});\n    }\n    return dp[ly][lx][ry][rx]=ret;\n}\nint main(){\n    while(cin>>h>>w>>s,h){\n        as=0;\n        memset(sum,0,sizeof(sum));\n        rep(i,h)rep(j,w) cin>>g[i][j],as+=g[i][j];\n        rep(i,h)rep(j,w) sum[i+1][j+1]+=g[i][j]+sum[i][j+1]+sum[i+1][j]-sum[i][j];\n        rep(i,h)rep(j,w)rep(k,h)rep(l,w) dp[i][j][k][l]={-1,0};\n        pint ans=dfs(0,0,w-1,h-1);\n        cout<<ans.first<<\" \"<<s-as+ans.second<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\npii INIT = pii(-1, -1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\n\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y) {\n    return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\n// ?°???°??? (??????) ??????????????????\npii solve(int lx, int ly, int rx, int ry) {\n    pii& ans = memo[lx][ly][rx][ry];\n    if(ans != INIT) return ans;\n\n    // ?°???°???????????¶???????????????????????§??????????????±???????????????????????????????????????\n    int sum = getsum(lx, ly, rx, ry);\n    if(sum < E - S) return ans = pii(0, INF);\n\n    // ??????\n    ans = pii(1, S - (E - sum));\n\n    // ?¨??????????\n    rep(i,lx+1,rx) {\n        pii ra = solve(lx, ly, i, ry);\n        pii rb = solve(i, ly, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    // ????????????\n    rep(i,ly+1,ry) {\n        pii ra = solve(lx, ly, rx, i);\n        pii rb = solve(lx, i, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    //printf(\"lx = %lld, ly = %lld, rx = %lld, ry = %lld, val = (%lld, %lld)\\n\",\n    //    lx, ly, rx, ry, ans.first, ans.second);\n    //printf(\"sum: %lld\\n\\n\", sum);\n    return ans;\n}\n\nsigned main() {\n    while(cin >> H >> W >> S, H || W || S) {\n        memset(board, 0, sizeof(board));\n        rep(i,0,33) rep(j,0,33) rep(k,0,33) rep(l,0,33)\n            memo[i][j][k][l] = INIT;\n        rep(i,0,H) rep(j,0,W) cin >> board[i+1][j+1];\n        rep(i,0,H) rep(j,0,W) board[i+1][j+1] += board[i+1][j];\n        rep(j,0,W) rep(i,0,H) board[i+1][j+1] += board[i][j+1];\n\n        /*\n        rep(i,0,H) {\n            rep(j,0,W) {\n                printf(\"%lld \", board[i+1][j+1]);\n            }\n            cout << endl;\n        }\n        */\n\n        E = getsum(0, 0, H, W);\n        // printf(\"debug: E = %lld\\n\", E);\n        pii ans = solve(0, 0, H, W);\n        printf(\"%lld %lld\\n\", ans.first, ans.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\npii dp[32][32][32][32];\n\nint main() {\n\tint h, w, s;\n\twhile (cin >> h >> w >> s, h) {\n\t\tll t = 0;\n\t\trep(i, h)rep(j, w)fill(dp[i][j][0], dp[i][j][h], pii());\n\t\trep(i, h)rep(j, w) {\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tdp[i][j][i][j] = { 1,u };\n\t\t\tt += u;\n\t\t}\n\t\tt -= s;\n\t\trep(i, h)rep(j, w){\n\t\t\tif (i == 0 && j == 0)continue;\n\t\t\trep(k, h - i)rep(l, w - j) {\n\t\t\t\tpii m;\n\t\t\t\trep(n, i) {\n\t\t\t\t\tif (dp[k][l][k + n][l + j].second < t || dp[k + n + 1][l][k + i][l + j].second < t)cmax(m, { 1,dp[k][l][k + n][l + j].second + dp[k + n + 1][l][k + i][l + j].second });\n\t\t\t\t\telse {\n\t\t\t\t\t\tpii a = { dp[k][l][k + n][l + j].first + dp[k + n + 1][l][k + i][l + j].first,min(dp[k][l][k + n][l + j].second,dp[k + n + 1][l][k + i][l + j].second) };\n\t\t\t\t\t\tcmax(m, a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(n, j) {\n\t\t\t\t\tif (dp[k][l][k + i][l + n].second < t || dp[k][l + n + 1][k + i][l + j].second < t)cmax(m, { 1,dp[k][l][k + i][l + n].second + dp[k][l + n + 1][k + i][l + j].second });\n\t\t\t\t\telse {\n\t\t\t\t\t\tpii a = { dp[k][l][k + i][l + n].first + dp[k][l + n + 1][k + i][l + j].first,min(dp[k][l][k + i][l + n].second,dp[k][l + n + 1][k + i][l + j].second) };\n\t\t\t\t\t\tcmax(m, a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[k][l][k + i][l + j] = m;\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][0][h - 1][w - 1].first << \" \" << dp[0][0][h - 1][w - 1].second - t << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint c[40][40];\nint sum[40][40];\nint sum_all = 0;\nint h,w,s;\n\nint get_sum(int x1,int y1,int x2,int y2){\n\treturn sum[x2][y2] + sum[x1 - 1][y1 - 1] - sum[x1 - 1][y2] - sum[x2][y1 - 1];\n}\n\nP dp[40][40][40][40];\n\nP rec(int x1,int y1,int x2,int y2){\n\tif(dp[x1][y1][x2][y2].first != -1) return dp[x1][y1][x2][y2];\n\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << get_sum(x1,y1,x2,y2) << endl;\n\tP res = {1 , s - (sum_all - get_sum(x1,y1,x2,y2))};\n\tfor(int i = x1;i < x2;i++){\n\t\tif(sum_all - get_sum(x1, y1, i, y2) > s) continue;\n\t\tif(sum_all - get_sum(i + 1,y1,x2,y2) > s) continue;\n\t\tP l = rec(x1, y1, i, y2);\n\t\tP r = rec(i + 1,y1,x2,y2);\n\t\tP ans = {l.first + r.first,min(l.second,r.second)};\n\t\tres = max(res,ans);\n\t}\n\tfor(int i =  y1;i < y2;i++){\n\t\tif(sum_all - get_sum(x1,y1,x2,i) > s) continue;\n\t\tif(sum_all - get_sum(x1,i + 1,x2,y2) > s) continue;\n\t\tP l = rec(x1,y1,x2,i);\n\t\tP r = rec(x1,i + 1,x2,y2);\n\t\tP ans = {l.first + r.first , min(l.second , r.second)};\n\t\tres = max(res,ans);\n\t}\n\n\treturn dp[x1][y1][x2][y2] = res;\n}\n\n\nint main(){\n\twhile(cin >> h >> w >> s,h || w || s){\n\t\tsum_all = 0;\n\t\trep(i,1,h)rep(j,1,w) cin >> c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum_all += c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] = sum[i - 1][j] + c[i][j];\n\t\trep(i,1,h)rep(j,1,w) sum[i][j] += sum[i][j - 1];\n\t\trep(i,1,h)rep(j,1,w)rep(k,1,h)rep(l,1,h) dp[i][j][k][l].first = dp[i][j][k][l].second = -1;\n\t\tcout << rec(1,1,h,w).first << \" \" << rec(1,1,h,w).second << endl;;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class T, class U>\nusing Pair = std::pair<T, U>;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <size_t N>\nusing Bits = std::bitset<N>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nBool solve() {\n    Int h, w, s;\n    std::cin >> h >> w >> s;\n    if (h == 0) return false;\n\n    Vector<Vector<Int>> usum(h + 1, Vector<Int>(w + 1, 0));\n    for (Int x = 1; x <= h; ++x) {\n        for (Int y = 1; y <= w; ++y) {\n            std::cin >> usum[x][y];\n            usum[x][y] += usum[x][y - 1] + usum[x - 1][y] - usum[x - 1][y - 1];\n        }\n    }\n    s = usum[h][w] - s;\n    // 各区画はsを下回ってはならない\n\n    // 1-indexed、閉区間\n    auto sum = [&](Int lx, Int ly, Int rx, Int ry) {\n        return usum[rx][ry] - usum[rx][ly - 1] -\n               usum[lx - 1][ry] + usum[lx - 1][ly - 1];\n    };\n\n    auto dp = genv<Pair<Int, Int>>(h, w, h, w, std::make_pair(INF, INF));\n\n    // 区画数、予備力\n    std::function<Pair<Int, Int>(Int, Int, Int, Int)> dfs =\n        [&](Int lx, Int ly, Int rx, Int ry) {\n            auto& ret = dp[lx - 1][ly - 1][rx - 1][ry - 1];\n            if (ret.first != INF) return ret;\n\n            Int p = sum(lx, ly, rx, ry);\n            if (p < s) {\n                return ret = std::make_pair(-INF, INF);\n            } else {\n                ret = std::make_pair(1, p - s);\n            }\n\n            for (Int x = lx; x < rx; ++x) {\n                auto l = dfs(lx, ly, x, ry);\n                auto r = dfs(x + 1, ly, rx, ry);\n                auto res = std::make_pair(\n                    l.first + r.first,\n                    std::min(l.second, r.second));\n                if (ret.first < res.first ||\n                    (ret.first == res.first && ret.second < res.second)) {\n                    ret = res;\n                }\n            }\n\n            for (Int y = ly; y < ry; ++y) {\n                auto l = dfs(lx, ly, rx, y);\n                auto r = dfs(lx, y + 1, rx, ry);\n                auto res = std::make_pair(\n                    l.first + r.first,\n                    std::min(l.second, r.second));\n                if (ret.first < res.first ||\n                    (ret.first == res.first && ret.second < res.second)) {\n                    ret = res;\n                }\n            }\n            return ret;\n        };\n\n    auto ans = dfs(1, 1, h, w);\n    std::cout << ans.first << ' ' << ans.second << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint W,H,S,A;\nint field[35][35];\nint dp0[35][35][35];\nint dp[35][35][35][35];\nP memo[35][35][35][35];\n\nP dfs(int l, int t, int r, int b)\n{\n\tif(memo[l][t][r][b].first != 0) return memo[l][t][r][b];\n\n\tP res = make_pair(1, S-(A-dp[l][t][r][b]));\n\tfor(int i=l+1; i<r; i++){\n\t\tif(A-dp[l][t][i][b] > S || A-dp[i][t][r][b] > S) continue;\n\n\t\tP left = dfs(l,t,i,b);\n\t\tP right = dfs(i,t,r,b);\n\n\t\tP lr = make_pair(left.first + right.first, min(left.second, right.second));\n\t\tres = max(res, lr);\n\t}\n\n\tfor(int i=t+1; i<b; i++){\n\t\tif(A-dp[l][t][r][i] > S || A-dp[l][i][r][b] > S) continue;\n\n\t\tP top = dfs(l,t,r,i);\n\t\tP bot = dfs(l,i,r,b);\n\n\t\tP mid = make_pair(top.first + bot.first, min(top.second, bot.second));\n\t\tres = max(res, mid);\n\t}\n\n\tmemo[l][t][r][b] = res;\n\n\treturn memo[l][t][r][b];\n\n\t\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int l=0; l<W; l++){\n\t\tint sum = 0;\n\t\tfor(int r=l+1; r <=W; r++) {\n\t\t\tsum += field[i][r-1];\n\t\t\tdp0[i][l][r] = sum;\n\t\t}\n\t}\n\n\tfor(int l=0; l<W; l++)\n\tfor(int r=l+1; r<=W; r++) {\n\t\tfor(int t=0; t<H; t++) {\n\t\t\tint sum = 0;\n\t\t\tfor(int b=t+1; b<=H; b++) {\n\t\t\t\tsum += dp0[b-1][l][r];\n\t\t\t\tdp[l][t][r][b] = sum;\n\t\t\t}\n\t\t}\n\t}\n\n\tA = dp[0][0][W][H];\n\n\tP res = dfs(0,0,W,H);\n\tcout << res.first << \" \" << res.second << endl;\n}\n\nint main()\n{\n\twhile(cin >> H >> W >> S,(W||H||S)) {\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t\tcin >> field[i][j];\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint h,w,s;\nint cost[32][32];\nint sum[33][33];\nint num[32][32][32][32];\nint cap[32][32][32][32];\nint M;\n\nint calc_sum(int x1,int y1,int x2,int y2){\n\tx1++;y1++;x2++;y2++;\n\treturn sum[y2][x2]-sum[y2][x1-1]-sum[y1-1][x2]+sum[y1-1][x1-1];\n}\n\ntypedef pair<int,int> A;\n\nA dfs(int x1,int y1,int x2,int y2){\n\tif(num[y1][x1][y2][x2]>=0) return make_pair(num[y1][x1][y2][x2],cap[y1][x1][y2][x2]);\n\tif(calc_sum(x1,y1,x2,y2)<M) return make_pair(0,10000000);\n\tA res=make_pair(1,calc_sum(x1,y1,x2,y2)-M);\n\n\tfor(int x=x1;x+1<=x2;x++){\n\t\tif(calc_sum(x1,y1,x,y2)<M || calc_sum(x+1,y1,x2,y2)<M) continue;\n\t\tA ans1=dfs(x1,y1,x,y2);\n\t\tA ans2=dfs(x+1,y1,x2,y2);\n\t\tA temp=make_pair(ans1.first+ans2.first,min(ans1.second,ans2.second));\n\t\tif(temp.first>res.first) res=temp;\n\t\telse if(temp.first==res.first && temp.second>res.second) res=temp;\n\t}\n\n\tfor(int y=y1;y+1<=y2;y++){\n\t\tif(calc_sum(x1,y1,x2,y)<M || calc_sum(x1,y+1,x2,y2)<M) continue;\n\t\tA ans1=dfs(x1,y1,x2,y);\n\t\tA ans2=dfs(x1,y+1,x2,y2);\n\t\tA temp=make_pair(ans1.first+ans2.first,min(ans1.second,ans2.second));\n\t\tif(temp.first>res.first) res=temp;\n\t\telse if(temp.first==res.first && temp.second>res.second) res=temp;\n\t}\n\tnum[y1][x1][y2][x2]=res.first;\n\tcap[y1][x1][y2][x2]=res.second;\n\t\n\treturn res;\n}\n\nvoid solve()\n{\n\tmemset(num,-1,sizeof(num));\n\tmemset(sum,0,sizeof(sum));\n\tfor(int y=1;y<=h;y++){\n\t\tfor(int x=1;x<=w;x++){\n\t\t\tint t;cin>>t; \n\t\t\tcost[y-1][x-1]=t;\n\t\t\tsum[y][x]=sum[y][x-1];\n\t\t\tsum[y][x]+=cost[y-1][x-1];\n\t\t}\n\t}\n\n\tfor(int x=1;x<=w;x++){\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tsum[y][x]+=sum[y-1][x];\n\t\t}\n\t}\n\n\tM=calc_sum(0,0,w-1,h-1)-s;\n\tcout<<M<<endl;\n\tA Ans=dfs(0,0,w-1,h-1);\n\tcout<<Ans.first<<\" \"<<Ans.second<<endl;\n}\n\nint main()\n{\n\twhile(cin>>h>>w>>s && !(h==0 && w==0 && s==0)){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, S;\nvector< vector<int> > A;\nbool m1[40][40][40][40];\nP m2[40][40][40][40];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, S-(getM(0, 0, W, H) - getM(x1, y1, x2, y2)));\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tif (a1.first < 0 || a2.first < 0) continue;\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tif (a1.first < 0 || a2.first < 0) continue;\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> S, H || W || S) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[0][0][0]+40*40*40, false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\nint h, w, s, s2;\nint dp[35][35][35][35];\nint dp2[35][35][35][35];\nint m[35][35];\nint ssum[35][35];\n\npii go(int l, int r, int u, int b) {\n\tif(dp[l][r][u][b] != -1) return mp(dp[l][r][u][b], dp2[l][r][u][b]);\n\tint opt_gn, opt_md;\n\tif(r - l == 1 && b - u == 1) {\n\t\topt_gn = 1;\n\t\topt_md = m[u][l] - s2;\n\t}\n\telse {\n\t\topt_gn = 1, opt_md = ssum[b][r] - ssum[b][l] - ssum[u][r] + ssum[u][l] - s2;\n\t\tREP(i, l + 1, r - 1) {\n\t\t\tpii p1 = go(l, i, u, b);\n\t\t\tpii p2 = go(i, r, u, b);\n\t\t\tif(p1.snd < 0 || p2.snd < 0) continue;\n\t\t\tif(opt_gn < p1.fst + p2.fst) {\n\t\t\t\topt_gn = p1.fst + p2.fst;\n\t\t\t\topt_md = min(p1.snd, p2.snd);\n\t\t\t}\n\t\t\telse if(opt_gn == p1.fst + p2.fst) {\n\t\t\t\topt_md = max(opt_md, min(p1.snd, p2.snd));\n\t\t\t}\n\t\t}\n\t\tREP(i, u + 1, b - 1) {\n\t\t\tpii p1 = go(l, r, u, i);\n\t\t\tpii p2 = go(l, r, i, b);\n\t\t\tif(p1.snd < 0 || p2.snd < 0) continue;\n\t\t\tif(opt_gn < p1.fst + p2.fst) {\n\t\t\t\topt_gn = p1.fst + p2.fst;\n\t\t\t\topt_md = min(p1.snd, p2.snd);\n\t\t\t}\n\t\t\telse if(opt_gn == p1.fst + p2.fst) {\n\t\t\t\topt_md = max(opt_md, min(p1.snd, p2.snd));\n\t\t\t}\n\t\t}\n\t}\n\treturn mp(dp[l][r][u][b] = opt_gn, dp2[l][r][u][b] = opt_md);\n}\n\nint main(){\n\tfor (; cin >> h >> w >> s, (h | w | s) != 0; ) {\n\t\ts2 = 0;\n\t\trep(i, h) rep(j, w) {\n\t\t\tcin >> m[i][j];\n\t\t\ts2 += m[i][j];\n\t\t}\n\t\ts2 -= s;\n\t\tmemset(ssum, 0, sizeof(ssum));\n\t\trep(i, h) rep(j, w) ssum[i + 1][j + 1] = m[i][j];\n\t\trep(i, h) rep(j, w) ssum[i + 1][j + 1] += ssum[i + 1][j];\n\t\trep(i, w) rep(j, h) ssum[j + 1][i + 1] += ssum[j][i + 1];\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tmemset(dp2, -1, sizeof(dp2));\n\t\tgo(0, w, 0, h);\n\t\tcout << dp[0][w][0][h] << ' ' << dp2[0][w][0][h] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define reps(i,j,k) for(int i=j;i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define fr first\n#define sc second\n#define fs fr\n#define pb push_back\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class S, class T>\nostream &operator<<(ostream &out, const pair<S,T> &p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\nint h,w,s,pwr;\nint u[40][40];\npii memo[40][40][40][40];\n//hankaikukan\n//fr : number of groups\n//sc : own power\npii ini(0,1e8);\npii dfs(int x1,int y1,int x2,int y2){\n\tint sum = 0;\n\tif(memo[x1][y1][x2][y2] != ini)return memo[x1][y1][x2][y2];\n\treps(i,y1,y2){\n\t\treps(j,x1,x2){\n\t\t\tsum += u[i][j];\n\t\t}\n\t}\n\tcout << x1 <<\", \" << y1 << \", \" << x2 << \", \" << y2 << \", \" << sum << endl;\n\tif(pwr - sum > s)return ini;\n\n\tpii best = ini;\n\treps(i,y1+1,y2){\n\t\tpii p1 = dfs(x1,y1,x2,i);\n\t\tpii p2 = dfs(x1,i,x2,y2);\n\t\tif(p1 == ini || p2 == ini)continue;\t\n\t\tpii p(p1.fr + p2.fr,min(p1.sc, p2.sc));\n\t\tif(best.fr == p.fr ? best.sc > p.sc : best.fr < p.fr){\n\t\t\tbest = p;\n\t\t}\n\t}\n\treps(j,x1+1,x2){\n\t\tpii p1 = dfs(x1,y1,j,y2);\n\t\tpii p2 = dfs(j,y1,x2,y2);\n\t\tif(p1 == ini || p2 == ini)continue;\n\t\tpii p(p1.fr + p2.fr,min(p1.sc,p2.sc));\n\t\tif(best.fr == p.fr ? best.sc > p.sc : best.fr < p.fr){\n\t\t\tbest = p;\n\t\t}\n\t}\n\tmemo[x1][y1][x2][y2] = best;\n\treturn best;\n}\n\nint N = 40;\nint main(){\n\twhile(cin >> h >> w >> s,h){\n\t\tpwr = 0;\n\t\t//fill(memo[0][0][0], memo[40][40][40], ini);\n\t\trep(i,N) rep(j,N) rep(k,N) rep(l,N) memo[i][j][k][l] = ini;\n\t\trep(i,h)\n\t\t\trep(j,w){\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tpwr += u[i][j];\n\t\t\t}\n\t\tcout << dfs(0,0,w,h) << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n\ntypedef pair<int,int> P;\n\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\nint rec[34][34][34][34];\n\n\nvoid mkRec(){\n\tint i, j;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\trec[i][j][i][j] = area[i][j];\n\t\t\t\n\t\t\tfor(int y = i - 1; y >= 0; y--)\n\t\t\t\trec[y][j][i][j] = rec[y + 1][j][i][j] + area[y][j];\n\t\t\t\n\t\t\tfor(int y = i; y >= 0; y--){\n\t\t\t\tint s = 0;\n\t\t\t\tfor(int x = j; x >= 0; x--){\n\t\t\t\t\ts += rec[y][x][i][x];\n\t\t\t\t\trec[y][x][i][j] = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nP split(int ax, int ay, int bx, int by){\n\tP max_group, group, g1, g2;\n\tint sum_e = 0;\n\tint i, j;\n\t\n\tif(memo[ay][ax][by][bx].first != 0) return memo[ay][ax][by][bx];\n\n\tmax_group = P(1, max_group.second = s - (sum - rec[ay][ax][by][bx]));\n\n\tfor(i = ay; i < by; i++){\n\t\tif(sum - rec[ay][ax][i][bx]\t> s || \n\t\t   sum - rec[i+1][ax][by][bx] > s) continue;\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i+1, bx, by);\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\tfor(j = ax; j < bx; j++){\n\t\tif(sum - rec[ay][ax][by][j] > s || \n\t\t   sum - rec[ay][j+1][by][bx] > s) continue;\n\t\tg1 = split(ax, ay, j, by);\n\t\tg2 = split(j + 1, ay, bx, by);\n\t\tgroup = pair<int, int>(g1.first + g2.first, min(g1.second, g2.second));\n\t\tmax_group = max(max_group, group);\n\t}\n\treturn memo[ay][ax][by][bx] = max_group;\n}\n\n\nint main(void){\n\tint i,j;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tsum = 0;\n\t\tfor(i = 0; i < h; i++){\n\t\t\tfor(j = 0; j < w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n\t\t}\n\t\tmkRec();\n\t\tans = split(0, 0, w - 1, h - 1);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 35\n\nint w, h;\nint s[MAX][MAX];\nint dp[MAX][MAX];\nint cost[MAX][MAX][4];\nint c[4];\nstruct Point {\n\tint y, x, dir, cost;\n};\n//bool next_flag(Point& now) {\n//\tint i;\n//\tbool flag = false;\n//\trep(i, 4) {\n//\t\tint ny = now.y + dy[i];\n//\t\tint nx = now.x + dx[i];\n//\t\tif (ny < 0 || h <= ny) continue;\n//\t\tif (nx < 0 || w <= nx) continue;\n//\t\tif (cost[ny][nx] > cost[now.y][now.x]) flag = true;\n//\t}\n//\treturn flag;\n//}\nint ddir[] = { 0,3,2,1 };\nvoid bfs() {\n\tint i, j, k;\n\trep(i, h) rep(j, w) rep(k, 4) cost[i][j][k] = INT_MAX;\n\tqueue<Point> q;\n\tq.push({ 0,0,1,0 });\n\tcost[0][0][1] = 0;\n\twhile (q.size()) {\n\t\tPoint now = q.front(); q.pop();\n\t\trep(i, 4) {\n\t\t\tint ndir = (now.dir + ddir[i]) % 4;\n\t\t\tint ny = now.y + dy[ndir];\n\t\t\tint nx = now.x + dx[ndir];\n\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\tif (nx < 0 || w <= nx) continue;\n\n\t\t\tint ncost = now.cost;\n\t\t\tif (s[now.y][now.x] != i) ncost += c[i];\n\n\t\t\tif (ncost < cost[ny][nx][ndir]) {\n\t\t\t\tcost[ny][nx][ndir] = ncost;\n\t\t\t\tq.push({ ny,nx,ndir,ncost });\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(void)\n{\n\tint i, j, k;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) rep(j, w) reader(s[i][j]);\n\t\trep(i, 4) reader(c[i]);\n\t\tbfs();\n\t\tint ans = INT_MAX;\n\t\trep(i, 4) {\n\t\t\tif (cost[h - 1][w - 1][i] < ans) {\n\t\t\t\tans = cost[h - 1][w - 1][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\ninline int solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2]) return dp[y1][x1][y2][x2];\n\tint ret = 1048576 + rng(x1, y1, x2, y2);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2), petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i), petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048575, resr & 1048575);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &ra), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tprintf(\"%d %d\\n\", (ret >> 20), ((ret - o) & 1048575));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define f first\n#define s second\n\npii NO=mp(-10000,-10000);\npii dp[33][33][33][33];\nint ck[33][33][33][33];\nint sum[33][33];\nint a[33][33];\nint T,cs,n,m,s,tot;\n\ninline int get(int x1, int y1, int x2, int y2) {\n\treturn sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];\n}\n\npii go(int x1, int y1, int x2, int y2) {\n\tif(tot-get(x1,y1,x2,y2)>s) return NO;\n\t\n\tpii &ret=dp[x1][y1][x2][y2];\n\tif(ck[x1][y1][x2][y2]==cs) return ret;\n\tck[x1][y1][x2][y2]=cs,ret=mp(1,get(x1,y1,x2,y2));\n\n\tif(x1<x2) {\n\t\tfor(int nx=x1+1;nx<=x2;++nx) {\n\t\t\tpii t1=go(x1,y1,nx-1,y2);\n\t\t\tpii t2=go(nx,y1,x2,y2);\n\t\t\tif(ret.f < t1.f+t2.f) {\n\t\t\t\tret.f = t1.f+t2.f;\n\t\t\t\tret.s = min(t1.s,t2.s);\n\t\t\t}\n\t\t\telse if(ret.f == t1.f+t2.f && ret.s < min(t1.s,t2.s)) {\n\t\t\t\tret.s = min(t1.s,t2.s);\n\t\t\t}\n\t\t}\n\t}\n\tif(y1<y2) {\n\t\tfor(int ny=y1+1;ny<=y2;++ny) {\n\t\t\tpii t1=go(x1,y1,x2,ny-1);\n\t\t\tpii t2=go(x1,ny,x2,y2);\n\t\t\tif(ret.f < t1.f+t2.f) {\n\t\t\t\tret.f = t1.f+t2.f;\n\t\t\t\tret.s = min(t1.s,t2.s);\n\t\t\t}\n\t\t\telse if(ret.f == t1.f+t2.f && ret.s < min(t1.s,t2.s)) {\n\t\t\t\tret.s = min(t1.s,t2.s);\n\t\t\t}\n\t\t}\n\t} return ret;\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\twhile(scanf(\"%d%d%d\",&n,&m,&s),n) {\n\t\tcs++;\n\t\tfor(int i=1;i<=n;++i) for(int j=1;j<=m;++j)\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\tfor(int i=1;i<=n;++i) for(int j=1;j<=m;++j)\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]+a[i][j]-sum[i-1][j-1];\n\t\ttot=sum[n][m];\n\t\tpii ans=go(1,1,n,m);\n\t\tprintf(\"%d %d\\n\",ans.f,s-(tot-ans.s));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint h, w, sup, sig;\nllint u[35][35];\nP memo[35][35][35][35];\nllint sum[35][35];\n\nllint get(llint sx, llint sy, llint tx, llint ty)\n{\n\treturn sum[tx][ty] - sum[sx-1][ty] - sum[tx][sy-1] + sum[sx-1][sy-1];\n}\n\nP dfs(llint sx, llint sy, llint tx, llint ty)\n{\n\tif(memo[sx][sy][tx][ty].first != -1) return memo[sx][sy][tx][ty];\n\t\n\tllint asum = get(sx, sy, tx, ty);\n\tif(asum < sig - sup) return memo[sx][sy][tx][ty] = P(-inf, -inf);\n\t\n\tP ret = P(1, asum);\n\tfor(int x = sx+1; x <= tx; x++){\n\t\tP res = dfs(sx, sy, x-1, ty), res2 = dfs(x, sy, tx, ty);\n\t\tret = max(ret, P(res.first+res2.first, min(res.second, res2.second)));\n\t}\n\tfor(int y = sy+1; y <= ty; y++){\n\t\tP res = dfs(sx, sy, tx, y-1), res2 = dfs(sx, y, tx, ty);\n\t\tret = max(ret, P(res.first+res2.first, min(res.second, res2.second)));\n\t}\n\t//cout << sx << \" \" << sy << \" \" << tx << \" \" << ty << \" \" << ret.first << \" \" << ret.second  << endl;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> h >> w >> sup;\n\t\tif(h == 0 && w == 0 && sup == 0) break;\n\t\t\n\t\tsig = 0;\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tcin >> u[x][y];\n\t\t\t\tsig += u[x][y];\n\t\t\t}\n\t\t}\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tsum[x][y] = sum[x-1][y] + sum[x][y-1] - sum[x-1][y-1] + u[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int sx = 1; sx <= w; sx++){\n\t\t\tfor(int sy = 1; sy <= h; sy++){\n\t\t\t\tfor(int tx = 1; tx <= w; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= h; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = P(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tP res = dfs(1, 1, w, h);\n\t\tcout << res.first << \" \" << sup-(sig-res.second) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<long long int>>M;\n\nlong long int FIRSTCOST;\nlong long int H, W, S;\n\ntypedef pair<long long int, long long int> RETURN;\ntypedef pair<pair<long long int, long long int>, pair<long long int, long long int>> POINT;\n\nlong long int cost( POINT  P ) {\n\treturn M[P.first.first][P.first.second] + M[P.second.first][P.second.second] - M[P.first.first][P.second.second] - M[P.second.first][P.first.second];\n}\n\nvector<vector<vector<vector<RETURN>>>>dp;\n\nRETURN saiki( POINT P ) {\n\tif( FIRSTCOST - cost( P ) > S ) {\n\t\treturn make_pair( -1, -1 );\n\t}\n\tif( dp[P.first.first][P.first.second][P.second.first][P.second.second].first != -2 ) {\n\t\treturn dp[P.first.first][P.first.second][P.second.first][P.second.second];\n\t}\n\t//cout << FIRSTCOST - cost( P ) << \" \" << S << endl;\n\tRETURN ret = make_pair( 1, S - (FIRSTCOST - cost( P )) );\n\tfor( size_t i = P.first.first + 1; i < P.second.first; i++ ) {\n\t\tPOINT up = P, down = P;\n\t\tup.second.first = i;\n\t\tdown.first.first = i;\n\t\tauto retup = saiki( up );\n\t\tauto retdown = saiki( down );\n\t\tif( retup.first != -1 && retdown.first != -1 ) {\n\t\t\tRETURN retmemo = make_pair( retup.first + retdown.first, min( retup.second, retdown.second ) );\n\t\t\tif( ret.first < retmemo.first || (ret.first == retmemo.first&&ret.second < retmemo.second) ) {\n\t\t\t\tret = retmemo;\n\t\t\t}\n\t\t}\n\t}\n\tfor( size_t j = P.first.second + 1; j < P.second.second; j++ ) {\n\t\tPOINT right = P, left = P;\n\t\tleft.second.second = j;\n\t\tright.first.second = j;\n\t\tauto retleft = saiki( left );\n\t\tauto retright = saiki( right );\n\t\tif( retleft.first != -1 && retright.first != -1 ) {\n\t\t\tRETURN retmemo = make_pair( retleft.first + retright.first, min( retleft.second, retright.second ) );\n\t\t\tif( ret.first < retmemo.first || (ret.first == retmemo.first&&ret.second < retmemo.second) ) {\n\t\t\t\tret = retmemo;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[P.first.first][P.first.second][P.second.first][P.second.second] = ret;\n}\n\nint main() {\n\twhile( cin >> H >> W >> S, H || W || S ) {\n\t\tdp = vector<vector<vector<vector<RETURN>>>>( H + 1, vector<vector<vector<RETURN>>>( W + 1, vector<vector<RETURN>>( H + 1, vector<RETURN>( W + 1, RETURN( -2, -2 ) ) ) ) );\n\t\tM = vector<vector<long long int>>( H + 1, vector<long long int>( W + 1 ) );\n\t\tfor( size_t i = 1; i <= H; i++ ) {\n\t\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\t\tfor( size_t i = 0; i < H + 1; i++ ) {\n\t\t\tfor( size_t j = 1; j < W + 1; j++ ) {\n\t\t\t\tM[i][j] += M[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\tfor( size_t i = 0; i < W + 1; i++ ) {\n\t\t\tfor( size_t j = 1; j < H + 1; j++ ) {\n\t\t\t\tM[j][i] += M[j - 1][i];\n\t\t\t}\n\t\t}\n\n\t\tPOINT firstX = make_pair( make_pair( 0, 0 ), make_pair( H, W ) );\n\t\tFIRSTCOST = cost( firstX );\n\t\tauto ans = saiki( firstX );\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, s;\nint u[100][100];\nint sum[110][100];\nP dp[35][35][35][35];\n\nint getSum(int lx, int ly, int rx, int ry) {\n\treturn sum[ry + 1][rx + 1] - sum[ry + 1][lx] - sum[ly][rx + 1] + sum[ly][lx];\n}\nP f(int lx, int ly, int rx, int ry) {\n\t//cout << lx << \" \" << ly << \" \" << rx << \" \" << ry << endl;\n\tif(dp[lx][ly][rx][ry].first != 0) return dp[lx][ly][rx][ry];\n\tint d = sum[h][w] - getSum(lx, ly, rx, ry);\n\tP ret = P(1, s - d);\n\tfor(int i = ly; i < ry; i++) {\n\t\tint d1 = sum[h][w] - getSum(lx, ly, rx, i);\n\t\tint d2 = sum[h][w] - getSum(lx, i + 1, rx, ry);\n\t\tif(d1 > s || d2 > s) continue;\n\t\tP a = f(lx, ly, rx, i);\n\t\tP b = f(lx, i + 1, rx, ry);\n\t\tP p = P(a.first + b.first, min(a.second, b.second));\n\t\tret = max(ret, p);\n\t}\n\tfor(int j = lx; j < rx; j++) {\n\t\tint d1 = sum[h][w] - getSum(lx, ly, j, ry);\n\t\tint d2 = sum[h][w] - getSum(j + 1, ly, rx, ry);\n\t\tif(d1 > s || d2 > s) continue;\n\t\tP a = f(lx, ly, j, ry);\n\t\tP b = f(j + 1, ly, rx, ry);\n\t\tP p = P(a.first + b.first, min(a.second, b.second));\n\t\tret = max(ret, p);\n\t}\n\treturn dp[lx][ly][rx][ry] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t;\n\twhile(cin >> h >> w >> s, h) {\n\t\tfor(int i = 0; i < 35; i++) {\n\t\t\tfor(int j = 0; j < 35; j++) {\n\t\t\t\tfor(int k = 0; k < 35; k++) {\n\t\t\t\t\tfor(int l = 0; l < 35; l++) {\n\t\t\t\t\t\tdp[i][j][k][l] = P(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tcin >> u[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= h; i++) {\n\t\t\tfor(int j = 1; j <= w; j++) {\n\t\t\t\tsum[i][j] = u[i - 1][j - 1] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\n\t\tP ans = f(0, 0, w - 1, h - 1);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1000000;\n\nint H, W, S;\nint sum;\n\nP dp[33][33][33][33];\n\nP div(mat &v, int x, int y, int h, int w) {\n    if (dp[x][y][h][w].first > 0) return dp[x][y][h][w]; \n\n    auto Area = [&]() -> int {\n        int punder = (x > 0 && y > 0) ? v[x - 1][y - 1] : 0;\n        int funder = (x > 0) ? v[x - 1][y + w - 1] : 0;\n        int ptop = (y > 0) ? v[x + h - 1][y - 1] : 0;\n        int ftop = v[x + h - 1][y + w - 1]; \n\n        return ftop - funder - ptop + punder;\n    };\n\n    if (Area() < sum - S) return P(-INF, -INF);\n\n    P res = P(1, S - (sum - Area()));\n\n    auto Max = [&](P p) {\n        if (p.first > res.first) {\n            res.first = p.first;\n            res.second = p.second;\n        } else if (p.first == res.first) {\n           res.second = max(res.second, p.second);\n        }\n    };\n\n    for (int i = 1; i < h; i++) {\n        P p1 = div(v, x, y, i, w);\n        P p2 = div(v, x + i, y, h - i, w);\n\n        if (p1.first <= 0 && p2.first <= 0) continue;\n\n        P tmp = P(p1.first + p2.first, min(p1.second, p2.second));\n        Max(tmp);\n    }\n\n    for (int j = 1; j < w; j++) {\n        P p1 = div(v, x, y, h, j);\n        P p2 = div(v, x, y + j, h, w - j);\n\n        if (p1.first <= 0 && p2.first <= 0) continue;\n\n        P tmp = P(p1.first + p2.first, min(p1.second, p2.second));\n        Max(tmp);\n    }\n\n    dp[x][y][h][w].first = res.first;\n    dp[x][y][h][w].second = res.second;\n\n\n    return res;\n}\n\nvoid solve(mat d) {\n    auto v = d;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int up = i > 0 ? v[i - 1][j] : 0;\n            int left = j > 0 ? v[i][j - 1] : 0;\n            int sub = (i > 0 && j > 0) ? v[i - 1][j - 1] : 0;\n            v[i][j] += up + left - sub;\n        }\n    }\n\n    P res = div(v, 0, 0, H, W);\n\n    cout << res.first << \" \" << res.second << endl;\n}\n\nint main() {\n    while (cin >> H >> W >> S, H || W || S) {\n        for (int i = 0; i < 33; i++) {\n            for (int j = 0; j < 33; j++) {\n                for (int k = 0; k < 33; k++) {\n                    for (int l = 0; l < 33; l++) {\n                        dp[i][j][k][l].first = -1;\n                        dp[i][j][k][l].second = -1;\n                    }\n                }\n            }\n        }\n\n        mat d(H, vec(W));\n        sum = 0;\n        for (auto &v : d) {\n            for (auto &c : v) {\n                cin >> c;\n                sum += c;\n            }\n        }\n\n        solve(d);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n//#define dprintf(arg1, ... ) printf( arg1, __VA_ARGS__)\n#define dprintf(arg1, ... ) \n\nint map[32][32];\nint supply;\nint h, w;\n\nint alldemand;\n\nstruct s_ret {\n\tint cnt;\n\tint regmin;\n};\n\nstruct s_ret memo[32][33][32][33];\n\n\ninline int max ( int a, int b ) {\n\treturn (a>b)? a : b;\n}\ninline int min ( int a, int b ) {\n\treturn (a<b)? a : b;\n}\n\nint sum_region( int x0, int x1, int y0, int y1 ) {\n\tint sum = 0;\n\t\n\tfor ( int i=y0; i<y1; i++ ) {\n\t\tfor ( int j=x0; j<x1; j++ ) {\n\t\t\tsum += map[i][j];\n\t\t}\n\t}\n\t\n\treturn sum;\n}\n\nstruct s_ret divide( int x0, int x1, int y0, int y1 ) {\n\t\n\tif ( memo[x0][x1][y0][y1].cnt != -1 ) {\n\t\treturn memo[x0][x1][y0][y1];\n\t}\n\n\t\n\tdprintf(\"CALL %d %d %d %d\\n\", x0, x1, y0, y1);\n\t\n\tint sumreg = sum_region(x0, x1, y0, y1);\n\tif ( sumreg < (alldemand-supply) ) {\n\t\tmemo[x0][x1][y0][y1].cnt = 0;\n\t\tdprintf(\" Ah\\n\", 0);\n\t\treturn memo[x0][x1][y0][y1];\n\t}\n\t\n\t\n\tstruct s_ret ret = { 1, 0 };\n\t\n\tstruct s_ret r1, r2;\n\t\n\tbool hukabun = true;\n\t\n\tif ( (x1-x0) > 1 ) {\n\t\t// ツ縦ツづ可環づゥ\n\t\tfor ( int i=(x0+1); i<x1; i++ ) {\n\t\t\tr1 = divide ( x0, i, y0, y1 );\n\t\t\tif ( r1.cnt == 0 ) { continue; }\n\t\t\tr2 = divide ( i, x1, y0, y1 );\n\t\t\tif ( r2.cnt == 0 ) { continue; }\n\t\t\t\n\t\t\thukabun = false;\n\t\t\t\n\t\t\tif ( ret.cnt < (r1.cnt + r2.cnt) ) {\n\t\t\t\tret.cnt = (r1.cnt + r2.cnt);\n\t\t\t\tret.regmin = min ( r1.regmin, r2.regmin );\n\t\t\t} else if ( ret.cnt == (r1.cnt + r2.cnt) ) {\n\t\t\t\tret.regmin = max ( ret.regmin, min ( r1.regmin, r2.regmin ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif ( (y1-y0) > 1 ) {\n\t\t// ツ可。ツづ可環づゥ\n\t\tfor ( int i=(y0+1); i<y1; i++ ) {\n\t\t\tr1 = divide ( x0, x1, y0, i );\n\t\t\tif ( r1.cnt == 0 ) { continue; }\n\t\t\tr2 = divide ( x0, x1, i, y1 );\n\t\t\tif ( r2.cnt == 0 ) { continue; }\n\t\t\t\n\t\t\thukabun = false;\n\t\t\t\n\t\t\tif ( ret.cnt < (r1.cnt + r2.cnt) ) {\n\t\t\t\tret.cnt = (r1.cnt + r2.cnt);\n\t\t\t\tret.regmin = min ( r1.regmin, r2.regmin );\n\t\t\t} else if ( ret.cnt == (r1.cnt + r2.cnt) ) {\n\t\t\t\tret.regmin = max ( ret.regmin, min ( r1.regmin, r2.regmin ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif ( /*ret.regmin == 0*/ hukabun ) {\n\t\tdprintf(\"  HUKABUN %d %d %d %d : return %d, sum %d\\n\",x0, x1, y0, y1, ret.cnt, sumreg);\n\t\tret.regmin = sumreg;\n\t}\n\t\n\tdprintf(\" %d %d %d %d : return %d, sum %d\\n\",x0, x1, y0, y1, ret.cnt, ret.regmin);\n\t\n\n\tmemo[x0][x1][y0][y1] = ret;\n\t\n\treturn ret;\n}\n\nint main(void) {\n\t\n\twhile(1) {\n\t\tscanf(\"%d %d %d\", &h, &w, &supply);\n\t\tif ( h == 0 && w == 0 && supply == 0 ) { break; }\n\t\t\n\t\talldemand = 0;\n\t\tfor ( int i=0; i<h; i++ ) {\n\t\t\tfor ( int j=0; j<w; j++ ) {\n\t\t\t\tscanf(\"%d\", &(map[i][j]) );\n\t\t\t\talldemand += map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( int i=0; i<(32*33*32*33); i++ ) {\n\t\t\tmemo[0][0][0][i].cnt = -1;\n\t\t}\n\t\t\n\t\tstruct s_ret r = divide( 0, w, 0, h );\n\t\tprintf(\"%d %d\\n\", r.cnt, supply - (alldemand - r.regmin) );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint h,w,s;\nint u[33][33];\n\nint sum[33][33];\nint U;\n\npi dp[33][33][33][33];\n\ninline void init()\n{\n    memset(sum,0,sizeof(sum));\n    U=0;\n    rep(i,33)rep(j,33)rep(k,33)rep(l,33) dp[i][j][k][l]=pi(-1,-1);\n\n}\n\ninline int SUM(int lx, int ly, int rx, int ry)\n{\n    return sum[ry][rx] - sum[ly-1][rx] - sum[ry][lx-1] + sum[ly-1][lx-1];\n}\n\npi dfs(int lx, int ly, int rx, int ry)\n{\n    if(dp[lx][ly][rx][ry].fi>=0) return dp[lx][ly][rx][ry];\n\n    pi ret(1,s-U+SUM(lx,ly,rx,ry));\n\n    // ????????????\n    for(int i=lx; i<rx; ++i)\n    {\n        if(U-SUM(lx,ly,i,ry)<=s && U-SUM(i+1,ly,rx,ry)<=s)\n        {\n            pi A = dfs(lx,ly,i,ry), B = dfs(i+1,ly,rx,ry);\n            ret = max(ret, pi(A.fi+B.fi, min(A.se,B.se)));\n        }\n    }\n\n    // ?¨??????????\n    for(int i=ly; i<ry; ++i)\n    {\n        if(U-SUM(lx,ly,rx,i)<=s && U-SUM(lx,i+1,rx,ry)<=s)\n        {\n            pi A = dfs(lx,ly,rx,i), B = dfs(lx,i+1,rx,ry);\n            ret = max(ret, pi(A.fi+B.fi, min(A.se,B.se)));\n        }\n    }\n\n    return dp[lx][ly][rx][ry] = ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d %d\", &h, &w, &s),h)\n    {\n        init();\n\n        rep(i,h)rep(j,w)\n        {\n            scanf(\" %d\", &u[i+1][j+1]);\n            U+=u[i+1][j+1];\n        }\n\n        sum[1][1]=u[1][1];\n        for(int i=2; i<=w; ++i) sum[1][i] = sum[1][i-1]+u[1][i];\n        for(int i=2; i<=h; ++i) sum[i][1] = sum[i-1][1]+u[i][1];\n        for(int i=2; i<=h; ++i)for(int j=2; j<=w; ++j) sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + u[i][j];\n\n        pi a = dfs(1,1,w,h);\n        printf(\"%d %d\\n\", a.fi, a.se);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint h,w,s;\nint f[64][64];\npair<int,int> memo[33][33][33][33];\npair<int,int> merge(pair<int,int> a,pair<int,int> b)\n{\n  return make_pair(a.first+b.first,min(a.second,b.second));\n}\npair<int,int> solve(int u,int l,int b,int r)\n{\n  if(memo[u][l][b][r].first!=-1) return memo[u][l][b][r];\n  pair<int,int> answer=make_pair(0,f[b][r]-f[u][r]-f[b][l]+f[u][l]);\n  if(answer.second>=s){\n    answer.first=1;\n    answer.second-=s;\n  }\n  FOR(i,u+1,b) answer=max(answer,merge(solve(u,l,i,r),solve(i,l,b,r)));\n  FOR(i,l+1,r) answer=max(answer,merge(solve(u,l,b,i),solve(u,i,b,r)));\n  return memo[u][l][b][r]=answer;\n}\nint main(void)\n{\n  for(;;){\n    cin >> h >> w >> s;\n    if(!h) return 0;\n    REP(i,64) REP(j,64) f[i][j]=0;\n    REP(i,h) REP(j,w) cin >> f[i+1][j+1];\n    REP(i,h+1) REP(j,w) f[i][j+1]+=f[i][j];\n    REP(i,h) REP(j,w+1) f[i+1][j]+=f[i][j];\n    s=f[h][w]-s;\n    REP(i,33) REP(j,33) REP(k,33) REP(l,33) memo[i][j][k][l].first=-1;\n    int g,p;\n    tie(g,p)=solve(0,0,h,w);\n    cout << g << ' ' << p << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\npii dp[33][33][33][33];\nint h,w,s;\nint vv[33][33];\nint lim;\nint calc(int a,int b,int c,int d){\n\tif(a==0&&b==0) return vv[c][d];\n\tif(a==0){\n\t\treturn vv[c][d]-vv[c][b-1];\n\t}\n\tif(b==0){\n\t\treturn vv[c][d]-vv[a-1][d];\n\t}\n\treturn vv[c][d]-vv[a-1][d]-vv[c][b-1]+vv[a-1][b-1];\n}\npii foo(int a,int b,int c,int d){\n\tpii ret=pii(1,calc(a,b,c,d));\n\tif(dp[a][b][c][d].F!=-1) return dp[a][b][c][d];\n\treep(i,a,c){\n\t\tif(calc(a,b,i,d)>=lim&&calc(i+1,b,c,d)>=lim){\n\t\t\tpii aa=foo(a,b,i,d);\n\t\t\tpii bb=foo(i+1,b,c,d);\n\t\t\tif(ret.F<aa.F+bb.F){\n\t\t\t\tret.F=aa.F+bb.F;\n\t\t\t\tret.S=min(aa.S,bb.S);\n\t\t\t}\n\t\t\telse if(ret.F==aa.F+bb.F){\n\t\t\t\tret.S=max(ret.S,min(aa.S,bb.S));\n\t\t\t}\n\t\t}\n\t}\n\treep(i,b,d){\n\t\tif(calc(a,b,c,i)>=lim&&calc(a,i+1,c,d)>=lim){\n\t\t\tpii aa=foo(a,b,c,i);\n\t\t\tpii bb=foo(a,i+1,c,d);\n\t\t\tif(ret.F<aa.F+bb.F){\n\t\t\t\tret.F=aa.F+bb.F;\n\t\t\t\tret.S=min(aa.S,bb.S);\n\t\t\t}\n\t\t\telse if(ret.F==aa.F+bb.F){\n\t\t\t\tret.S=max(ret.S,min(aa.S,bb.S));\n\t\t\t}\n\t\t}\n\t}\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<ret.F<<\" \"<<ret.S-vv[h-1][w-1]<<endl;\n\treturn dp[a][b][c][d]=ret;\n}\nvoid mainmain(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\trep(i,33){\n\t\t\trep(j,33){\n\t\t\t\trep(k,33){\n\t\t\t\t\trep(l,33){\n\t\t\t\t\t\tdp[i][j][k][l]=pii(-1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvint in;\n\t\tinitvv(in,h,w);\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tvv[i][j]=in[i][j];\n\t\t\t}\n\t\t}\n\t\treep(i,1,h){\n\t\t\tvv[i][0]+=vv[i-1][0];\n\t\t}\n\t\treep(i,1,w){\n\t\t\tvv[0][i]+=vv[0][i-1];\n\t\t}\n\t\treep(i,1,h){\n\t\t\treep(j,1,w){\n\t\t\t\tvv[i][j]+=vv[i-1][j]+vv[i][j-1]-vv[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\tlim=vv[h-1][w-1]-s;\n\t\t// cout<<lim<<endl;\n\t\tpii ans=foo(0,0,h-1,w-1);\n\t\t/*\n\t\t??°???????????????????????§?????¶?????? ??? ??????????????????1??°?????????????????????????????¨?????????????????°?????????????????????????¨?????????§??? ??? ????????????????¶?????????????????????????\n\t\t??°????????????????????????????????°???????????°??????????¨?1, 2????????¶??????????????°???????????????????????§?????§??§???????????°???????????????\n\t\t??°??????????????????????¨?1, 2, 3????????¶??????????????°???????????????????????§?????§????????????????????????????????°?????????????????°?????????????????????????????¨?????????????????¨?????§?????¶??????????????§?????????\n\t\t*/\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\treep(k,i,h){\n\t\t\t\t\treep(l,j,w){\n\t\t\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l<<\" \"<<dp[i][j][k][l].F<<\" \"<<dp[i][j][k][l].S-vv[h-1][w-1]<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans.F<<\" \"<<-lim+ans.S<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nint H, W, S;\n\nint M;\nint field[32][32];\nint sum[32][32][32][32];\npii dp[32][32][32][32];\n\nint group_sum(int x1, int y1, int x2, int y2) {\n    if (sum[x1][y1][x2][y2] != -1) return sum[x1][y1][x2][y2];\n    if (x1 == x2 && y1 == y2) {\n        return sum[x1][y1][x1][y1] = field[y1][x1];\n    }\n\n    int m = 0;\n    FOR(x, x1, x2) {\n        m = group_sum(x1, y1, x, y2) + group_sum(x + 1, y1, x2, y2);\n    }\n    FOR(y, y1, y2) {\n        m = group_sum(x1, y1, x2, y) + group_sum(x1, y + 1, x2, y2);\n    }\n    return sum[x1][y1][x2][y2] = m;\n}\n\npii rec(int x1, int y1, int x2, int y2) {\n    if (dp[x1][y1][x2][y2].first != -1) return dp[x1][y1][x2][y2];\n    pii ma = {0, 0};\n    int r = S - (M - sum[x1][y1][x2][y2]);\n    if (r >= 0) {\n        ma = {1, r};\n    }\n    FOR(x, x1, x2) {\n        pii a = rec(x1, y1, x, y2), b = rec(x + 1, y1, x2, y2);\n        ma = max(ma, {a.first + b.first, min(a.second, b.second)});\n    }\n    FOR(y, y1, y2) {\n        pii a = rec(x1, y1, x2, y), b = rec(x1, y + 1, x2, y2);\n        ma = max(ma, {a.first + b.first, min(a.second, b.second)});\n    }\n    return dp[x1][y1][x2][y2] = ma;\n}\n\nint main() {\n    while (cin >> H >> W >> S, H | W | S) {\n        M = 0;\n        REP(y, H) REP(x, W) {\n            cin >> field[y][x];\n            M += field[y][x];\n        }\n\n        fill_n((int *)sum, 32 * 32 * 32 * 32, -1);\n        fill_n((pii *)dp, 32 * 32 * 32 * 32, make_pair(-1, 0));\n\n        group_sum(0, 0, W - 1, H - 1);\n        pii res = rec(0, 0, W - 1, H - 1);\n        cout << res.first << \" \" << res.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint h,w,s;\nint cost[32][32];\nint sum[33][33];\nint num[32][32][32][32];\nint cap[32][32][32][32];\nint M;\n\nint calc_sum(int x1,int y1,int x2,int y2){\n\tx1++;y1++;x2++;y2++;\n\treturn sum[y2][x2]-sum[y2][x1-1]-sum[y1-1][x2]+sum[y1-1][x1-1];\n}\n\ntypedef pair<int,int> A;\n\nA dfs(int x1,int y1,int x2,int y2){\n\tif(num[y1][x1][y2][x2]>=0) return make_pair(num[y1][x1][y2][x2],cap[y1][x1][y2][x2]);\n\tif(calc_sum(x1,y1,x2,y2)<M) return make_pair(0,10000000);\n\tA res=make_pair(1,calc_sum(x1,y1,x2,y2)-M);\n\n\tfor(int x=x1;x+1<=x2;x++){\n\t\tif(calc_sum(x1,y1,x,y2)<M || calc_sum(x+1,y1,x2,y2)<M) continue;\n\t\tA ans1=dfs(x1,y1,x,y2);\n\t\tA ans2=dfs(x+1,y1,x2,y2);\n\t\tA temp=make_pair(ans1.first+ans2.first,min(ans1.second,ans2.second));\n\t\tif(temp.first>res.first) res=temp;\n\t\telse if(temp.first==res.first && temp.second>res.second) res=temp;\n\t}\n\n\tfor(int y=y1;y+1<=y2;y++){\n\t\tif(calc_sum(x1,y1,x2,y)<M || calc_sum(x1,y+1,x2,y2)<M) continue;\n\t\tA ans1=dfs(x1,y1,x2,y);\n\t\tA ans2=dfs(x1,y+1,x2,y2);\n\t\tA temp=make_pair(ans1.first+ans2.first,min(ans1.second,ans2.second));\n\t\tif(temp.first>res.first) res=temp;\n\t\telse if(temp.first==res.first && temp.second>res.second) res=temp;\n\t}\n\tnum[y1][x1][y2][x2]=res.first;\n\tcap[y1][x1][y2][x2]=res.second;\n\t\n\treturn res;\n}\n\nvoid solve()\n{\n\tmemset(num,-1,sizeof(num));\n\tmemset(sum,0,sizeof(sum));\n\tfor(int y=1;y<=h;y++){\n\t\tfor(int x=1;x<=w;x++){\n\t\t\tint t;cin>>t; \n\t\t\tcost[y-1][x-1]=t;\n\t\t\tsum[y][x]=sum[y][x-1];\n\t\t\tsum[y][x]+=cost[y-1][x-1];\n\t\t}\n\t}\n\n\tfor(int x=1;x<=w;x++){\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tsum[y][x]+=sum[y-1][x];\n\t\t}\n\t}\n\n\tM=calc_sum(0,0,w-1,h-1)-s;\n\tcout<<M<<endl;\n\tA Ans=dfs(0,0,w-1,h-1);\n\tcout<<Ans.first<<\" \"<<Ans.second<<endl;\n}\n\nint main()\n{\n\twhile(cin>>h>>w>>s && !(h==0 && w==0 && s==0)){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi G;\npii dp[50][50][50][50];\nint n,m,q,sum;\npii f(int a,int b,int c,int d){\n    if(dp[a][b][c][d].first!=inf)return dp[a][b][c][d];\n    dp[a][b][c][d]=pii(0,0);\n    dp[a][b][c][d].second=G[c][d]-G[a][d]-G[c][b]+G[a][b];\n//  cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<dp[a][b][c][d].second<<endl;\n//  loop(i,a,c)loop(j,b,d)dp[a][b][c][d].second+=G[i][j];\n    rep(i,c-a-1){\n        pii ta=f(a,b,a+i+1,d);\n        pii tb=f(a+i+1,b,c,d);\n        if(min(ta.second,tb.second)==-inf)continue;\n        if(dp[a][b][c][d].first<1+ta.first+tb.first){\n            dp[a][b][c][d].first=1+ta.first+tb.first;\n            dp[a][b][c][d].second=min(ta.second,tb.second);\n        }else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n            dp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n        }\n    }\n    rep(i,d-b-1){\n        pii ta=f(a,b,c,b+i+1);\n        pii tb=f(a,b+i+1,c,d);\n        if(min(ta.second,tb.second)==-inf)continue;\n        if(dp[a][b][c][d].first<1+ta.first+tb.first){\n            dp[a][b][c][d].first=1+ta.first+tb.first;\n            dp[a][b][c][d].second=min(ta.second,tb.second);\n        }else if(dp[a][b][c][d].first==1+ta.first+tb.first){\n            dp[a][b][c][d].second=max(dp[a][b][c][d].second,min(ta.second,tb.second));\n        }\n    }\n    if(dp[a][b][c][d].second<sum)dp[a][b][c][d]=pii(-inf,-inf);\n//  cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n//  cout<<dp[a][b][c][d].first<<\" \"<<dp[a][b][c][d].second<<endl;\n    return dp[a][b][c][d];\n}\nint main(){\n    while(cin>>n>>m>>q,n+m+q){\n        sum=-q;\n        G=vvi(n+1,vi(m+1));\n        rep(i,n)rep(j,m)cin>>G[i+1][j+1];\n        rep(i,n)rep(j,m)G[i+1][j+1]+=G[i][j+1]+G[i+1][j]-G[i][j];\n        sum=G[n][m]-q;\n        rep(i,50)rep(j,50)rep(k,50)rep(l,50)\n            dp[i][j][k][l]=pii(inf,inf);\n        f(0,0,n,m);\n        cout<<1+dp[0][0][n][m].first<<\" \"<<dp[0][0][n][m].second-sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) (t / 102400)\n#define snd(t) (t % 102400)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint H, W, S;\nint map[32][32];\nll dp[32][32][32][32];\n\nint sum(int x0, int x1, int y0, int y1){\n    --x0;\n    --y0;\n\n    int res = map[y1][x1];\n    \n    if(x0 >= 0){\n        res -= map[y1][x0];\n    }\n    if(y0 >= 0){\n        res -= map[y0][x1];\n    }\n    if(x0 >= 0 && y0 >= 0){\n        res += map[y0][x0];\n    }\n\n    return res;\n}\n\nint rec(int x0, int x1, int y0, int y1){\n    ll &res = dp[x0][x1][y0][y1];\n    if(res != -1){return res;}\n    \n    {\n        int x = S - (map[H-1][W-1] - sum(x0, x1, y0, y1));\n        if(x >= 0){\n            res = 1 * 102400 + x;\n        }\n    }\n\n    if(x0 < x1){\n        for(int i=x0;i<x1;++i){\n            ll res_s1 = rec(x0, i, y0, y1), res_s2 = rec(i+1, x1, y0, y1);\n            res = std::max(res, (fst(res_s1) + fst(res_s2)) * 102400 + std::min(snd(res_s1), snd(res_s2)));\n        }\n    }\n\n    if(y0 < y1){\n        for(int i=y0;i<y1;++i){\n            ll res_s1 = rec(x0, x1, y0, i), res_s2 = rec(x0, x1, i+1, y1);\n            res = std::max(res, (fst(res_s1) + fst(res_s2)) * 102400 + std::min(snd(res_s1), snd(res_s2)));\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> H >> W >> S;\n        if(H == 0){return 0;}\n\n        memset(dp, -1ll, sizeof(dp));\n    \n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                std::cin >> map[i][j];\n            }\n        }\n\n        for(int i=0;i<H;++i){\n            for(int j=1;j<W;++j){\n                map[i][j] += map[i][j-1];\n            }\n        }\n\n        for(int i=0;i<W;++i){\n            for(int j=1;j<H;++j){\n                map[j][i] += map[j-1][i];\n            }\n        }\n    \n        ll res = rec(0, W-1, 0, H-1);\n        printf(\"%lld %lld\\n\", fst(res), snd(res));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define INF 1000000\nint h, w, s;\nint area[34][34];\nint sum;\npair<int, int> memo[34][34][34][34];\n\n/*\nint check(int ax, int ay, int bx, int by){\n\tint i, j;\n\tint sum_e = 0;\n\tfor(i = ax; i <= bx; i++){\n\t\tfor(j = ay; j <= by; j++){\n\t\t\tsum_e += area[i][j];\n\t\t}\n\t}\n\tif(sum_e >= sum - s) return 1;\n\telse return 0;\n}\n*/\n\n\npair<int, int> split(int ax, int ay, int bx, int by){\n\tpair<int, int> max_group, group, g1, g2;\n\tmax_group = pair<int, int>(-1, -1);\n//\tmax_group.first = 0;\n//\tmax_group.second = 1;\n\tint sum_e = 0;\n\tint i, j;\n\t\n//\tcout << \"Point :\" << ax << \" : \" << ay << \" : \" << bx << \" : \" << by << endl;\n\t\n\tif(memo[ax][ay][bx][by].second != 0){\n//\t\tcout << \"\t\t:usememo\" << endl;\n\t\treturn memo[ax][ay][bx][by];\n\t}\n\tfor(i = ax; i <= bx; i++){\n\t\tfor(j = ay; j <= by; j++){\n\t\t\tsum_e += area[i][j];\n\t\t}\n\t}\n//\tcout <<\"sum_e:\" <<  sum_e << endl;\n\tif(sum - sum_e > s){\n//\t\tcout << \"\t\t:out\" << endl;\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\tmax_group.first = 1;\n\tmax_group.second = sum - sum_e;\n\n\t\n\tfor(i = ax; i < bx; i++){\n\t\tif(ax == bx) break;\n\t\tg1 = split(ax, ay, i, by);\n\t\tg2 = split(i + 1, ay, bx, by);\n\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup.first = g1.first + g2.first;\n\t\tgroup.second = max(g1.second, g2.second);\n\t\tif(group.first > max_group.first) max_group = group;\n\t\telse if(group.first == max_group.first && group.second < max_group.second) max_group = group;\n\t}\n\tfor(i = ay; i < by; i++){\n\t\tif(ay == by) break;\n\t\tg1 = split(ax, ay, bx, i);\n\t\tg2 = split(ax, i + 1, bx, by);\n\t\tif(g1.first == -1 || g2.first == -1) continue;\n\t\tgroup.first = g1.first + g2.first;\n\t\tgroup.second = max(g1.second, g2.second);\t\t\n\t\tif(group.first > max_group.first) max_group = group;\n\t\telse if(group.first == max_group.first && group.second < max_group.second) max_group = group;\n\t}\n\n\t\n//\tcout << ax << \" : \" << ay << \" : \" << bx << \" : \" << by << endl << max_group.first << \" : \" << max_group.second << endl;\t\n\tmemo[ax][ay][bx][by] = max_group;\n\t\n\treturn max_group;\n}\n\nint main(void){\n\tint i,j;\n\tint group_count;\n\tpair<int, int> ans;\n\twhile(cin >> h >> w >> s , h){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tsum = 0;\n\t\tfor(i = 1; i <= w; i++)\n\t\t\tfor(j = 1; j <= h; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tsum += area[i][j];\n\t\t\t}\n//\t\tcout << sum << endl;\n\t\tans = split(1, 1, w, h);\n\t\t\n\t\tcout << ans.first << \" \" << s - ans.second <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint h,w,s;\nint u[33][33];\nP dp[32][32][33][33];\nint area(int i, int j, int a, int b)\n{\n\treturn u[i+a][j+b]-u[i][j+b]-u[i+a][j]+u[i][j];\n}\nvoid exec()\n{\n\tcin >> h >> w >> s;\n\tif(h==0&&w==0&&s==0)exit(0);\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>u[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tu[i][j]+=u[i][j-1];\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tu[i][j]+=u[i-1][j];\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tint total=area(0,0,h,w);\n\tint bound=total-s;\n\tfor(int a=1;a<=h;a++){\n\t\tfor(int b=1;b<=w;b++){\n\t\t\tfor(int i=0;i+a<=h;i++){\n\t\t\t\tfor(int j=0;j+b<=w;j++){\n\t\t\t\t\tP v(0,0);\n\t\t\t\t\tint ar=area(i,j,a,b);\n\t\t\t\t\tif(ar>=bound){\n\t\t\t\t\t\tv=P(1,ar);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=1;p<a;p++){\n\t\t\t\t\t\tint f0=dp[i][j][p][b].first;\n\t\t\t\t\t\tint f1=dp[i+p][j][a-p][b].first;\n\t\t\t\t\t\tint s0=dp[i][j][p][b].second;\n\t\t\t\t\t\tint s1=dp[i+p][j][a-p][b].second;\n\t\t\t\t\t\tif(f0&&f1){\n\t\t\t\t\t\t\tv=max(v,P(f0+f1,min(s0,s1)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int q=1;q<b;q++){\n\t\t\t\t\t\tint f0=dp[i][j][a][q].first;\n\t\t\t\t\t\tint f1=dp[i][j+q][a][b-q].first;\n\t\t\t\t\t\tint s0=dp[i][j][a][q].second;\n\t\t\t\t\t\tint s1=dp[i][j+q][a][b-q].second;\n\t\t\t\t\t\tif(f0&&f1){\n\t\t\t\t\t\t\tv=max(v,P(f0+f1,min(s0,s1)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][a][b]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][0][h][w].first << \" \" << dp[0][0][h][w].second-bound << endl;\n}\nint main() {\n\twhile(1)exec();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w, s;\nint lower;\nint sum[33][33];\nint u[32][32];\nint memoCnt[32][32][32][32];\nint memoMinNeed[32][32][32][32];\n\nint getNeed(int a, int b, int c, int d){\n    return sum[c + 1][d + 1] - sum[c + 1][b] - sum[a][d + 1] + sum[a][b];\n}\n\npair<int, int> func(int a, int b, int c, int d){\n\n    //cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\n    int temp = memoCnt[a][b][c][d];\n    if(temp != -1){\n        return make_pair(temp, memoMinNeed[a][b][c][d]);\n    }\n\n    if(a == c && b == d){\n        int cnt, minNeed;\n        if(u[a][b] >= lower){\n            cnt = 1;\n            minNeed = u[a][b];\n        }\n        else{\n            cnt = 0;\n            minNeed = u[a][b];\n        }\n\n        memoCnt[a][b][c][d] = cnt;\n        memoMinNeed[a][b][c][d] = minNeed;\n        return make_pair(cnt, minNeed);\n    }\n\n    int tempSum = getNeed(a, b, c, d);\n    if(tempSum < lower){\n        memoCnt[a][b][c][d] = 0;\n        memoMinNeed[a][b][c][d] = tempSum;\n        return make_pair(0, tempSum);\n    }\n\n    pair<int, int> tempPair = make_pair(1, tempSum);\n    for(int i = a; i < c; i++){\n        auto temp1 = func(a, b, i, d);\n        auto temp2 = func(i + 1, b, c, d);\n        auto temp3 = make_pair(temp1.first + temp2.first, min(temp1.second, temp2.second));\n        if(temp3 > tempPair){\n            tempPair = temp3;\n        }\n    }\n    for(int i = b; i < d; i++){\n        auto temp1 = func(a, b, c, i);\n        auto temp2 = func(a, i + 1, c, d);\n        auto temp3 = make_pair(temp1.first + temp2.first, min(temp1.second, temp2.second));\n        if(temp3 > tempPair){\n            tempPair = temp3;\n        }\n    }\n\n    memoCnt[a][b][c][d] = tempPair.first;\n    memoMinNeed[a][b][c][d] = tempPair.second;\n    return tempPair;\n}\n\nint main(){\n\n    while(true){\n        cin >> h >> w >> s;\n        if(h == 0){\n            break;\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> u[i][j];\n            }\n        }\n\n        memset(sum, 0, sizeof(sum));\n        memset(memoCnt, -1, sizeof(memoCnt));\n        memset(memoMinNeed, -1, sizeof(memoMinNeed));\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + u[i - 1][j - 1];\n            }\n        }\n\n        lower = sum[h][w] - s;\n\n        pair<int, int> ans = func(0, 0, h - 1, w - 1);\n\n        cout << ans.first << \" \" << ans.second - lower << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,s,sum;\nstruct P{\n\tint y,x;\n\tinline P(){}\n\tinline P(int y,int x):y(y),x(x){}\n};\nP pmax(P a,P b){\n\tif(a.y!=b.y){\n\t\treturn a.y>b.y?a:b;\n\t}else{\n\t\treturn a.x>b.x?a:b;\n\t}\n}\nint u[32][32];\nP dp[32][32][32][32];\nP ret(P a,P b,int cnt){\n\tif(dp[a.y][a.x][b.y][b.x].y!=-1)\n\t\treturn dp[a.y][a.x][b.y][b.x];\n\tP ans(1,cnt);\n\tint s1=0,s2=0;\n\tfor(int i=a.y;i<b.y;i++){\n\t\tfor(int j=a.x;j<=b.x;j++){\n\t\t\ts1+=u[i][j];\n\t\t}\n\t\tif(sum-(cnt-s1)>s)\n\t\t\tbreak;\n\t\t\n\t\tif(sum-s1>s)\n\t\t\tcontinue;\n\t\tP x=ret(a,P(i,b.x),s1),y=ret(P(i+1,a.x),b,cnt-s1);\n\t\tans=pmax(ans,P(x.y+y.y,min(x.x,y.x)));\n\t}\n\tfor(int i=a.x;i<b.x;i++){\n\t\tfor(int j=a.y;j<=b.y;j++){\n\t\t\ts2+=u[j][i];\n\t\t}\n\t\tif(sum-(cnt-s2)>s)\n\t\t\tbreak;\n\t\tif(sum-s2>s)\n\t\t\tcontinue;\n\t\t\n\t\tP x=ret(a,P(b.y,i),s2),y=ret(P(a.y,i+1),b,cnt-s2);\n\t\tans=pmax(ans,P(x.y+y.y,min(x.x,y.x)));\n\t}\n\treturn dp[a.y][a.x][b.y][b.x]=ans;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tsum=0;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w)\n\t\tdp[i][j][k][l]=P(-1,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>u[i][j];\n\t\t\tsum+=u[i][j];\n\t\t}\n\t\tP ans=ret(P(0,0),P(h-1,w-1),sum);\n\t\tcout<<ans.y<<\" \"<<s-(sum-ans.x)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nvector< vector<int> > power,cusum;\n\nint h,w,s,must_cut;\n\nint main(){\n    cin >> h >> w >> s;\n    while(h>0){\n        power=vector< vector<int> >(h+1,vector<int>(w+1,0));\n        cusum=vector< vector<int> >(h+1,vector<int>(w+1,0));\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> power.at(i).at(j);\n                cusum.at(i).at(j)=power.at(i).at(j)+cusum.at(i-1).at(j)+cusum.at(i).at(j-1)-cusum.at(i-1).at(j-1);\n            }\n        }\n        must_cut=cusum.at(h).at(w)-s;\n        vector< vector< vector< vector< pair<int,int> > > > > dp(w+1,vector< vector< vector< pair<int,int> > > >(w+1,vector< vector< pair<int,int> > >(h+1,vector< pair<int,int> >(h+1,make_pair(0,0)))));\n        for(int k1=1;k1<=w;k1++){\n            for(int i1=0;i1+k1<=w;i1++){\n                for(int k2=1;k2<=h;k2++){\n                    for(int i2=0;i2+k2<=h;i2++){\n                        pair<int,int> cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                        for(int l1=1;l1<k1;l1++){\n                            pair<int,int> ref_p=make_pair(dp.at(i1).at(i1+l1).at(i2).at(i2+k2).first+dp.at(i1+l1).at(i1+k1).at(i2).at(i2+k2).first,\n                            min(dp.at(i1).at(i1+l1).at(i2).at(i2+k2).second,dp.at(i1+l1).at(i1+k1).at(i2).at(i2+k2).second));\n                            if(cur_p.first<ref_p.first){\n                                dp.at(i1).at(i1+k1).at(i2).at(i2+k2)=ref_p;\n                                cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                            }else if(cur_p.first==ref_p.first){\n                                dp.at(i1).at(i1+k1).at(i2).at(i2+k2)=make_pair(cur_p.first,max(cur_p.second,ref_p.second));\n                                cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                            }\n                        }\n                        for(int l2=1;l2<k2;l2++){\n                            pair<int,int> ref_p=make_pair(dp.at(i1).at(i1+k1).at(i2).at(i2+l2).first+dp.at(i1).at(i1+k1).at(i2+l2).at(i2+k2).first,\n                            min(dp.at(i1).at(i1+k1).at(i2).at(i2+l2).second,dp.at(i1).at(i1+k1).at(i2+l2).at(i2+k2).second));\n                            //cout << \"cur:\" << cur_p.first << \" \" << cur_p.second << \" ref:\" << ref_p.first << \" \" << ref_p.second << endl;\n                            if(cur_p.first<ref_p.first){\n                                dp.at(i1).at(i1+k1).at(i2).at(i2+k2)=ref_p;\n                                cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                            }else if(cur_p.first==ref_p.first){\n                                dp.at(i1).at(i1+k1).at(i2).at(i2+k2)=make_pair(cur_p.first,max(cur_p.second,ref_p.second));\n                                cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                            }\n                        }\n                        int allofarea=cusum.at(i2+k2).at(i1+k1)-cusum.at(i2).at(i1+k1)-cusum.at(i2+k2).at(i1)+cusum.at(i2).at(i1);\n                        if(allofarea>=must_cut){\n                            pair<int,int> ref_p=make_pair(1,allofarea-must_cut);\n                            if(cur_p.first<ref_p.first){\n                                dp.at(i1).at(i1+k1).at(i2).at(i2+k2)=ref_p;\n                                cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                            }else if(cur_p.first==ref_p.first){\n                                dp.at(i1).at(i1+k1).at(i2).at(i2+k2)=make_pair(cur_p.first,max(cur_p.second,ref_p.second));\n                                cur_p=dp.at(i1).at(i1+k1).at(i2).at(i2+k2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /*\n        for(int k1=1;k1<=w;k1++){\n            for(int i1=0;i1+k1<=w;i1++){\n                for(int k2=1;k2<=h;k2++){\n                    for(int i2=0;i2+k2<=h;i2++){\n                        cout << i1 << \" \" << k1 << \" \" << i2 << \" \" << k2 << \" \" << endl;\n                        cout << dp.at(i1).at(i1+k1).at(i2).at(i2+k2).first << \" \" << dp.at(i1).at(i1+k1).at(i2).at(i2+k2).second << endl;\n                    }\n                }\n            }\n        }\n        */\n        pair<int,int> ans=dp.at(0).at(w).at(0).at(h);\n        cout << ans.first << \" \" << ans.second << endl;\n        cin >> h >> w >> s;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 33\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint h,w,s,sum=0;\nint u[MAX][MAX];\npii mem[MAX][MAX][MAX][MAX];\n\npii rec(int a,int b,int c,int d){\n  if(mem[a][b][c][d].f!=-1)return mem[a][b][c][d];\n  int r=0;\n  FOR(i,a,c)FOR(j,b,d)r+=u[i][j];\n  if(r<sum){\n    mem[a][b][c][d]=mp(0,inf);\n    return mp(0,inf);\n  }\n  pii res(1,r);\n  FOR(i,a+1,c){\n    pii l=rec(a,b,i,d);\n    pii r=rec(i,b,c,d);\n    l.f+=r.f;\n    l.s=min(l.s,r.s);\n    res=max(res,l);\n  }\n  FOR(i,b+1,d){\n    pii l=rec(a,b,c,i);\n    pii r=rec(a,i,c,d);\n    l.f+=r.f;\n    l.s=min(l.s,r.s);\n    res=max(res,l);\n  }\n  mem[a][b][c][d]=res;\n  return res;\n}\n\nint main()\n{\n  while(cin>>h>>w>>s && h){\n    memset(mem,-1,sizeof(mem));\n    sum=0;\n    FOR(i,0,h){\n      FOR(j,0,w){\n        cin>>u[i][j];\n        sum+=u[i][j];\n      }\n    }\n    sum-=s;\n    pii res=rec(0,0,h,w);\n    cout<<res.f<<\" \"<<res.s-sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nP sch(int h, int w, int top, int l, const vvi &u, const vvi &suv, int over, vector<vector<vector<vector<P>>>> &memo) {\n  int mag = 1;\n  int ma = suv[top+h][l+w] - suv[top][l+w] - suv[top+h][l] + suv[top][l] - over;\n  P res = make_pair(mag, ma);\n  if(ma < 0) return {-1, -1};\n  for(int i=0;i<h-1;++i) {\n    if(ma + over < 2 * over) break;\n    P p1, p2;\n    if(memo[i+1][w][top][l] == make_pair(-1, -1)) {\n      p1 = sch(i+1, w, top, l, u, suv, over, memo);\n      memo[i+1][w][top][l] = p1;\n    } else {\n      p1 = memo[i+1][w][top][l];\n    }\n    if(memo[h-i-1][w][top+i+1][l] == make_pair(-1, -1)) {\n      p2 = sch(h-i-1, w, top+i+1, l, u, suv, over, memo);\n      memo[h-i-1][w][top+i+1][l] = p2;\n    } else {\n      p2 = memo[h-i-1][w][top+i+1][l];\n    }\n    if(p1.first == -1 || p2.first == -1) continue;\n    P tmp = make_pair(p1.first + p2.first, min(p1.second, p2.second));\n    res = max(res, tmp);\n  }\n  for(int i=0;i<w-1;++i) {\n    if(ma + over < 2 * over) break;\n    P p1, p2;\n    if(memo[h][i+1][top][l] == make_pair(-1, -1)) {\n      p1 = sch(h, i+1, top, l, u, suv, over, memo);\n      memo[h][i+1][top][l] = p1;\n    } else {\n      p1 = memo[h][i+1][top][l];\n    }\n    if(memo[h][w-i-1][top][l+i+1] == make_pair(-1, -1)) {\n      p2 = sch(h, w-i-1, top, l+i+1, u, suv, over, memo);\n      memo[h][w-i-1][top][l+i+1] = p2;\n    } else {\n      p2 = memo[h][w-i-1][top][l+i+1];\n    }\n    if(p1.first == -1 || p2.first == -1) continue;\n    P tmp = make_pair(p1.first + p2.first, min(p1.second, p2.second));\n    res = max(res, tmp);\n  }\n  return res;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int h, w, s; cin >> h >> w >> s;\n    if(h == 0) break;\n    vvi u(h, vi(w));\n    vvi suv(h+1, vi(w+1, 0));\n    int su = 0;\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        cin >> u[i][j];\n        su += u[i][j];\n        suv[i+1][j+1] = suv[i+1][j] + suv[i][j+1] - suv[i][j] + u[i][j];\n      }\n    }\n    int over = su - s;\n    vector<vector<vector<vector<P>>>> memo(h+1, vector<vector<vector<P>>>(w+1, vector<vector<P>>(h+1, vector<P>(w+1, {-1, -1}))));\n    P ans = sch(h, w, 0, 0, u, suv, over, memo);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint sum;\nint H, W, S;\nint tab[32][32];\nPII memo[32][32][32][32];\nPII dfs(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2].first >= 0) return memo[x1][y1][x2][y2];\n  \n  int tot = 0;\n  for(int y=y1;y<y2;++y)\n\tfor(int x=x1;x<x2;++x)\n\t  tot += tab[y][x];\n  if(sum - tot > S) return memo[x1][y1][x2][y2] = MP(0,-1);\n\n  int mx = 1, g = tot;\n  for(int x=x1+1;x<x2;++x){\n\tPII p1 = dfs(x1,y1,x,y2);\n\tPII p2 = dfs(x,y1,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tif(mx < p1.first + p2.first){\n\t  mx = p1.first + p2.first;\n\t  g = min(p1.second, p2.second);\n\t}\n\telse if(mx == p1.first + p2.first){\n\t  g = max(g, min(p1.second, p2.second));\n\t}\n  }\n\n  for(int y=y1+1;y<y2;++y){\n\tPII p1 = dfs(x1,y1,x2,y);\n\tPII p2 = dfs(x1,y,x2,y2);\n\tif(p1.first <= 0 || p2.first <= 0) continue;\n\tif(mx < p1.first + p2.first){\n\t  mx = p1.first + p2.first;\n\t  g = min(p1.second, p2.second);\n\t}\n\telse if(mx == p1.first + p2.first){\n\t  g = max(g, min(p1.second, p2.second));\n\t}\n  }\n\n  return memo[x1][y1][x2][y2] = MP(mx,g);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>W>>S,H){\n\tREP(y,H) REP(x,W) cin >> tab[y][x];\n\tsum = 0;\n\tREP(y,H) REP(x,W) sum += tab[y][x];\n\tfill((PII*)memo, (PII*)memo+32*32*32*32, MP(-1,-1));\n\t\n\tPII pii = dfs(0,0,W,H);\n\tcout << pii.first << \" \" << S + pii.second - sum << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,s;\nint sum;\nP pmax(P a,P b){\n\tif(a>b)\n\treturn a;\n\treturn b;\n}\nint u[35][35];\nP dp[33][33][33][33];\n//must\n//sum-local<=s\n//plus=s-(sum-local)\nP ret(P a,P b,int cnt){\n\tif(dp[a.first][a.second][b.first][b.second].first!=-1)\n\t\treturn dp[a.first][a.second][b.first][b.second];\n\tP ans(1,cnt);\n\tint s1=0,s2=0;\n\tfor(int i=a.first;i<b.first;i++){\n\t\t\n\t\tfor(int j=a.second;j<=b.second;j++){\n\t\t\ts1+=u[i][j];\n\t\t}\n\t\tif(sum-s1>s||sum-(cnt-s1)>s)\n\t\t\tcontinue;\n\t\tP x=ret(a,P(i,b.second),s1),y=ret(P(i+1,a.second),b,cnt-s1);\n\t\tans=pmax(ans,P(x.first+y.first,min(x.second,y.second)));\n\t}\n\tfor(int i=a.second;i<b.second;i++){\n\t\tfor(int j=a.first;j<=b.first;j++){\n\t\t\ts2+=u[j][i];\n\t\t}\n\t\tif(sum-s2>s||sum-(cnt-s2)>s)\n\t\t\tcontinue;\n\t\tP x=ret(a,P(b.first,i),s2),y=ret(P(a.first,i+1),b,cnt-s2);\n\t\tans=pmax(ans,P(x.first+y.first,min(x.second,y.second)));\n\t}\n\treturn dp[a.first][a.second][b.first][b.second]=ans;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tsum=0;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tfor(int k=0;k<h;k++)\n\t\tfor(int l=0;l<w;l++)\n\t\tdp[i][j][k][l]=P(-1,0);\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>u[i][j];\n\t\t\tsum+=u[i][j];\n\t\t}\n\t\tP ans=ret(P(0,0),P(h-1,w-1),sum);\n\t\tcout<<ans.first<<\" \"<<s-(sum-ans.second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i =0;i<n;++i)\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define FOR(it,a ) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntypedef pair<int,int> PI;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\n\nint h,w,s;\nint u[100][100];\n\nint sum[100][100];\n\nPI memo[50][50][50][50];//group, yobi\nbool vis[50][50][50][50];//group, yobi\n\nPI rec(int x1,int y1,int x2,int y2){\n  auto&  ans =memo[x1][y1][x2][y2];\n  if(ans.F>=0)  return ans;\n  ans=mp(0,10000000000000);\n  assert(vis[x1][y1][x2][y2]==0);\n  vis[x1][y1][x2][y2]=1;\n  //ans = mp(-1,0);\n  int su =sum[x2][y2]-sum[x2][y1]-sum[x1][y2]+sum[x1][y1];\n  int all = sum[h][w];\n  int saiju = all - su;\n  if(saiju <= s)\n    ans=mp(1,s-saiju);\n  \n  \n  for(int x=x1+1;x<x2;++x){\n    auto p = rec(x1,y1,x,y2);\n    auto p2 = rec(x,y1,x2,y2);\n    ans=max(ans,mp(p.F+p2.F,min(p.S,p2.S)));\n  }\n  \n  for(int y=y1+1;y<y2;++y){\n    auto p = rec(x1,y1,x2,y);\n    auto p2 = rec(x1,y,x2,y2);\n    ans=max(ans,mp(p.F+p2.F,min(p.S,p2.S)));\n  }\n  \n  //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << ans.F << \" \" << ans.S << endl;\n  return ans;\n}\n\nvoid solve(){\n  rep(i,h)rep(j,w) cin >> u[i][j];\n  rep(i,h)rep(j,w)\n    sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] + u[i][j] - sum[i][j];\n  //cout << sum[h][w] << endl;\n  memset(memo,-1,sizeof(memo));\n  memset(vis,0,sizeof(vis));\n  auto ans = rec(0,0,h,w);\n  cout << ans.F << \" \" << ans.S << endl;\n  //cout << rec(0,0,h,w) << endl;\n}\n\n\nint main(){\n  while(cin >>h  >> w>>s,h) solve();  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst int HMAX=32,WMAX=32;\n\nint grid[HMAX][WMAX];\nstatic pii dp[HMAX][WMAX][HMAX+1][WMAX+1]; // (最大グループ数,最大グループ数での最小消費電力)\nint umin;\n\nvoid solve(int i1,int j1,int i2,int j2)\n{\n\tif(dp[i1][j1][i2][j2]!=mp(-1,-1))\n\t\treturn;\n\tdp[i1][j1][i2][j2]=mp(0,0); // (0,0)ならば解なし\n\t\n\tint usum=0;\n\trepi(i,i1,i2) repi(j,j1,j2)\n\t\tusum+=grid[i][j];\n\tif(usum<umin)\n\t\treturn;\n\tdp[i1][j1][i2][j2]=mp(1,usum);\n\t\n\trepi(i,i1,i2){\n\t\tsolve(i1,j1,i,j2);\n\t\tsolve(i,j1,i2,j2);\n\t\t\n\t\tpii& top=dp[i1][j1][i][j2],bottom=dp[i][j1][i2][j2];\n\t\tif(top==mp(0,0) || bottom==mp(0,0))\n\t\t\tcontinue;\n\t\t\n\t\tpii temp(top.first+bottom.first,min(top.second,bottom.second));\n\t\tdp[i1][j1][i2][j2]=max(dp[i1][j1][i2][j2],temp);\n\t}\n\trepi(j,j1,j2){\n\t\tsolve(i1,j1,i2,j);\n\t\tsolve(i1,j,i2,j2);\n\t\tpii& left=dp[i1][j1][i2][j],right=dp[i1][j][i2][j2];\n\t\tif(left==mp(0,0) || right==mp(0,0))\n\t\t\tcontinue;\n\t\t\n\t\tpii temp(left.first+right.first,min(left.second,right.second));\n\t\tdp[i1][j1][i2][j2]=max(dp[i1][j1][i2][j2],temp);\n\t}\n}\n\nint main()\n{\n\tfor(int h,w,s;scanf(\"%d%d%d\",&h,&w,&s),h|w|s;){\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&grid[i][j]);\n\t\tint usum=0;\n\t\trep(i,h) rep(j,w) usum+=grid[i][j];\n\t\t\n\t\tumin=usum-s; // 1つのグループの消費電力は (Σ u_ij)-s 以上でなければならない\n\t\tmemset(dp,-1,sizeof dp);\n\t\t\n\t\tsolve(0,0,h,w);\n\t\tint g=dp[0][0][h][w].first;\n\t\tint r=dp[0][0][h][w].second-umin;\n\t\tprintf(\"%d %d\\n\",g,r);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\n\nint sum[40][40];\ntemplate <class T, class U>\nvoid calc_sq_sum(T res, U data, int w, int h)\n{\n\tfor (int y = 0; y <= h; ++y)\n\t\tres[y][0] = 0;\n\tfor (int x = 0; x <= w; ++x)\n\t\tres[0][x] = 0;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tres[y + 1][x + 1] = res[y][x + 1] + res[y + 1][x] - res[y][x] + data[y][x];\n}\ntemplate <class U, class T>\nU sq_sum(T sum, int x1, int y1, int x2, int y2)\n{\n\treturn sum[y2 + 1][x2 + 1] + sum[y1][x1] - (sum[y2 + 1][x1] + sum[y1][x2 + 1]);\n}\n//template <class T, class U>\n//U sq_sum_by_size(T res, int x, int y, int w, int h)\n//{\n//\treturn sq_sum(res, x, y, x + w - 1, y + h - 1);\n//}\n\nint h, w, s, u[40][40];\nint total_power;\nint group[40][40][40][40], power[40][40][40][40];\nvoid recur(int x1, int y1, int x2, int y2)\n{\n\tint& g = group[x1][y1][x2][y2];\n\tint& p = power[x1][y1][x2][y2];\n\tif (g != -1)\n\t\treturn;\n\telse if (total_power - sq_sum<int>(sum, x1, y1, x2, y2) > s)\n\t{\n\t\tg = -(1 << 24);\n\t\treturn;\n\t}\n\n\tg = 1;\n\tp = sq_sum<int>(sum, x1, y1, x2, y2);\n\tfor (int x = x1; x < x2; ++x)\n\t{\n\t\trecur(x1, y1, x, y2);\n\t\trecur(x + 1, y1, x2, y2);\n\n\t\tint tg = group[x1][y1][x][y2] + group[x + 1][y1][x2][y2];\n\t\tint tp = min(power[x1][y1][x][y2], power[x + 1][y1][x2][y2]);\n\t\tif (tg > g || tg == g && tp > p)\n\t\t\tg = tg, p = tp;\n\t}\n\tfor (int y = y1; y < y2; ++y)\n\t{\n\t\trecur(x1, y1, x2, y);\n\t\trecur(x1, y + 1, x2, y2);\n\n\t\tint tg = group[x1][y1][x2][y] + group[x1][y + 1][x2][y2];\n\t\tint tp = min(power[x1][y1][x2][y], power[x1][y + 1][x2][y2]);\n\t\tif (tg > g || tg == g && tp > p)\n\t\t\tg = tg, p = tp;\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> h >> w >> s, h)\n\t{\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\tcin >> u[i][j];\n\t\tcalc_sq_sum(sum, u, w, h);\n\t\ttotal_power = sq_sum<int>(sum, 0, 0, w - 1, h - 1);\n\n\t\tCL(group, -1);\n\t\trecur(0, 0, w - 1, h - 1);\n\n\t\tint g = group[0][0][w - 1][h - 1];\n\t\tint p = s - (total_power - power[0][0][w - 1][h - 1]);\n\t\tcout << g << \" \" << p << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nint mem[32][32][32][32];//mem[a][b][c][d]はarray[a][b]->array[c][d]の最大領域数を記録\nint mem2[32][32][32][32];//mem2[a][b][c][d]はarray[a][b]->array[c][d]の最大領域数時の最小需要量の最大を記録\n\n//指定の間の配列の合計を返す\nint sumOfMatrix(int a[32][32],int sx,int sy,int tx,int ty){\n\tint res=0;\n\tfor(int i=sy;i<ty;i++){\n\t\tfor(int j=sx;j<tx;j++){\n\t\t\tres+=a[i][j];\n\t\t}\n\t}\n\n\treturn res;\n}\n//デバッグ用の配列表示\nvoid viewMatrix(int a[32][32],int sx,int sy,int tx,int ty){\n\tint res=0;\n\tfor(int i=sy;i<ty;i++){\n\t\tfor(int j=sx;j<tx;j++){\n\t\t\tprintf(\"%3d \",a[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n//再帰的に探索する．a[sy][sx]->a[ty][tx]の最大分割数とそのときの最小の使用量の最大のペアを出力\npair<int,int> solve(int a[32][32],int sx,int sy,int tx,int ty,int sum, int sval){\n\tpair<int,int> p;\n\tpair<int,int> pls[4];\n\tpair<int,int> mp1,mp2;\n\t\n\t//出力するpを，領域数を1，その領域の使用量として初期化する．\n\tp.first = 1;\n\tp.second = sumOfMatrix(a,sx,sy,tx,ty);\n\n\t//plsというペア配列を初期化\n\tfor(int i=0;i<4;i++){\n\t\tpls[i].first=0;\n\t\tpls[i].second=10000;//使用料は十分大きい値とする．\n\t}\n\t//mp1,mp2の領域数を０で初期化\n\tmp1.first=0;\n\tmp2.first=0;\n\n\t//mp1には横(xに対して)に割った場合の最大値\n\t//mp2には縦(yに対して)に割った場合の最大値\n\t//ｘ方向に二つ以上に分割できるなら\n\tif((tx-sx)>1){\n\t\t//sx->x,x+1->txに分割する．\n\t\tfor(int x=sx;x<tx;x++){\n\n\t\t\t//分割した先の二つの領域ともに供給量制約を満たすなら\n\t\t\tif((sumOfMatrix(a,sx,sy,x+1,ty)>=sval)&&(sumOfMatrix(a,x+1,sy,tx,ty)>=sval)){\n\n\t\t\t\t//sx->x+1に割った方について\n\t\t\t\t//メモを確認して探索済みかどうかをチェックする．\n\t\t\t\tif(mem[sx][sy][x+1][ty]==0){//探索していないなら\n\t\t\t\t\tpls[0]=solve(a,sx,sy,x+1,ty,sum,sval);//sx->x+1に割った方の値をpls[0]に代入する\n\n\t\t\t\t\tmem[sx][sy][x+1][ty]=pls[0].first;//メモに値を与えて，次に探索する場合はこちらを参照するようにする．\n\t\t\t\t\tmem2[sx][sy][x+1][ty]=pls[0].second;//その時の最小の最大値をmem2にもメモする．\n\t\t\t\t}else{\n\t\t\t\t\t//メモがあるならばメモの値を与える．\n\t\t\t\t\tpls[0].first=mem[sx][sy][x+1][ty];\n\t\t\t\t\tpls[0].second=mem2[sx][sy][x+1][ty];\n\t\t\t\t}\n\n\t\t\t\t//x+1->txに割った方についても同様にする．\n\t\t\t\tif(mem[x+1][sy][tx][ty]==0){\n\t\t\t\t\tpls[1]=solve(a,x+1,sy,tx,ty,sum,sval);\n\n\t\t\t\t\tmem[x+1][sy][tx][ty]=pls[1].first;\n\t\t\t\t\tmem2[x+1][sy][tx][ty]=pls[1].second;\n\t\t\t\t}else{\n\t\t\t\t\tpls[1].first=mem[x+1][sy][tx][ty];\n\t\t\t\t\tpls[1].second=mem2[x+1][sy][tx][ty];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//元の大きさに対して，今での割り方のなかで最大なものと今回割った場合の値を比較する．\n\t\t\tif(mp1.first<(pls[0].first+pls[1].first)){\n\t\t\t\tmp1.first=pls[0].first+pls[1].first;//今までより大きいなら領域数を更新\n\t\t\t\tmp1.second=min(pls[0].second,pls[1].second);//その場合は小さい方の需要量を与える．\n\t\t\t}\n\t\t\tif(mp1.first==(pls[0].first+pls[1].first)){//もし値が同じなら，pls[0]と[1]の小さい方と今までとを比較して”大きい方”を選ぶ\n\t\t\t\tmp1.second=max(mp1.second,min(pls[0].second,pls[1].second));\n\t\t\t}\n\n\n\t\t}\n\t}\n\t//ｙについても同じ事をする．\n\tif((ty-sy)>1){\n\t\tfor(int y=sy;y<ty;y++){\n\t\t\tif((sumOfMatrix(a,sx,sy,tx,y+1)>=sval)&&(sumOfMatrix(a,sx,y+1,tx,ty)>=sval)){\n\t\t\t\tif(mem[sx][sy][tx][y+1]==0){\n\t\t\t\t\tpls[2]=solve(a,sx,sy,tx,y+1,sum,sval);\n\n\t\t\t\t\tmem[sx][sy][tx][y+1]=pls[2].first;\n\t\t\t\t\tmem2[sx][sy][tx][y+1]=pls[2].second;\n\t\t\t\t}else{\n\t\t\t\t\tpls[2].first=mem[sx][sy][tx][y+1];\n\t\t\t\t\tpls[2].second=mem2[sx][sy][tx][y+1];\n\t\t\t\t}\n\t\t\t\tif(mem[sx][y+1][tx][ty]==0){\n\t\t\t\t\tpls[3]=solve(a,sx,y+1,tx,ty,sum,sval);\n\n\t\t\t\t\tmem[sx][y+1][tx][ty]=pls[3].first;\n\t\t\t\t\tmem2[sx][y+1][tx][ty]=pls[3].second;\n\t\t\t\t}else{\n\t\t\t\t\tpls[3].first=mem[sx][y+1][tx][ty];\n\t\t\t\t\tpls[3].second=mem2[sx][y+1][tx][ty];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mp2.first<(pls[2].first+pls[3].first)){\n\t\t\t\tmp2.first=pls[2].first+pls[3].first;\n\t\t\t\tmp2.second=min(pls[2].second,pls[3].second);\n\t\t\t}\n\t\t\tif(mp2.first==(pls[2].first+pls[3].first)){\n\t\t\t\tmp2.second=max(mp2.second,min(pls[2].second,pls[3].second));\n\t\t\t}\n\t\t}\n\t}\n\n\t//xに割ったものの分割数の最大値と，yに割ったものの分割数の最大値を比較する．\n\tif((mp1.first) > (mp2.first)){//mp1>mp2ということはmp[1,2]!=0\n\t\tp.first=mp1.first;\n\t\tp.second=mp1.second;\n\t}\n\telse{\n\t\t//最小値が一緒の場合は需要量ができるだけ大きい方をえらぶ\n\t\tif((mp1.first) == (mp2.first)){\n\t\t\tmp2.second=max(mp1.second,mp2.second);\n\t\t}\n\t\t//上の条件式ではmp2も0の可能性があるので，確認する.\n\t\tif(mp2.first!=0){//mpが0じゃない＝ということは1度は再起しているので\n\t\t\tp.first=mp2.first;\n\t\t\tp.second=mp2.second;\n\t\t}\n\t}\n\t//上のifに引っかからなかったということはそれは再起の底だから最初に設定したpをそのまま出力する．\n\n\treturn p;\n}\n\n\nint main(void){\n\tint h,w,s;\n\n\tint table[32][32];\n\n\tint sum;\n\tint sval;\n\n\tpair<int,int> res;\n\n\twhile(true){\n\t\t//データを初期化\n\t\tfor(int i=0;i<32;i++){\n\t\t\tfor(int j=0;j<32;j++) table[i][j]=-1;\n\t\t}\n\t\t//メモの初期化\n\t\tfor(int i=0;i<32;i++){\n\t\t\tfor(int j=0;j<32;j++){\n\t\t\t\tfor(int k=0;k<32;k++){\n\t\t\t\t\tfor(int l=0;l<32;l++){\n\t\t\t\t\t\tmem[i][j][k][l]=0;\n\t\t\t\t\t\tmem2[i][j][k][l]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//hを入力\n\t\tcin >> h;\n\t\tif(h==0) break;\n\t\tcin >> w;\n\t\tcin >> s;\n\t\tsum=0;\n\t\t//tableに入力\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tsum+=table[i][j];\n\t\t\t}\n\t\t}\n\t\t//svalは許容する最大需要量（ようするに需要量の合計から供給量を引いた数）\n\t\tsval=sum-s;\n\n\t\tres=solve(table,0,0,w,h,sum,sval);\t\n\t\t\n\t\tcout << res.first << \" \" << (res.second-sval) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define INF 100000000\n#define mp make_pair\n#define pii pair<int,int>\n\nint h,w,s;\nint board[55][55];\nint box[55][55];\n\n\nvoid boxset(){\n\tfor(int i=1;i<=h;i++)box[i][1] = board[i-1][0] + box[i-1][1];\n\tfor(int i=1;i<=w;i++)box[1][i] = board[0][i-1] + box[1][i-1];\n\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tbox[i][j] = box[i-1][j] + box[i][j-1] - box[i-1][j-1] + board[i-1][j-1];\n\t}\n}\n\nint boxget(int y1,int x1,int y2,int x2){\n\treturn box[y2][x2] - box[y1][x2] - box[y2][x1] + box[y1][x1];\n}\n\n\n//pair<int,int> : 分割数,区画内の和の最小値\n\npii marge(pii a, pii b){\n\treturn mp(a.first + b.first,  min(a.second, b.second));\n}\n\npii memo[33][33][33][33];\npii saiki(int y1,int x1,int y2,int x2){\n\tif(memo[y1][x1][y2][x2].first!=0) return memo[y1][x1][y2][x2];\n\t\n\tpii cand = mp(1, boxget(y1,x1,y2,x2));\n\t\n\tpii a1,b1,a2,b2;\n\t\n\t//左右分割\n\tfor(int i=y1+1; i<y2; i++){\n\t\tpii a = saiki(y1, x1, i, x2);\n\t\tpii b = saiki(i, x1, y2, x2);\n\t\t\n\t\tcand = max(marge(a,b), cand);\n\t}\n\t\n\t//上下分割\n\tfor(int i=x1+1; i<x2; i++){\n\t\tpii a = saiki(y1, x1, y2, i);\n\t\tpii b = saiki(y1, i, y2, x2);\n\t\tcand = max(marge(a,b), cand);\n\t}\n\t\n\tif(boxget(0,0,h,w) - cand.second > s)cand = mp(-INF,0);\n\treturn memo[y1][x1][y2][x2] = cand;\n}\n\nint main(){\n\t\n\twhile(1){\n\t\t//入力\n\t\tcin>>h>>w>>s;\n\t\tif(h==0)break;\n\t\t\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>board[i][j];\n\t\t\n\t\tfor(int i=0;i<=h;i++)for(int j=0;j<=w;j++){\n\t\t\tfor(int k=0;k<=h;k++)for(int p=0;p<=w;p++){\n\t\t\t\tmemo[i][j][k][p] = mp(0,0);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//二次元累積和計算\n\t\tboxset();\n\t\t\n\t\tpii ans = saiki(0,0,h,w);\n\t\tprintf(\"%d %d\\n\",ans.first, ans.second + s - boxget(0,0,h,w));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\npii INIT = pii(-1, -1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\n\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y) {\n    return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\n// ?°???°??? (??????) ??????????????????\npii solve(int lx, int ly, int rx, int ry) {\n    pii& ans = memo[lx][ly][rx][ry];\n    if(ans != INIT) return ans;\n\n    // ?°???°???????????¶???????????????????????§??????????????±???????????????????????????????????????\n    int sum = getsum(lx, ly, rx, ry);\n    if(sum < E - S) return ans = pii(0, INF);\n\n    // ??????\n    ans = pii(1, S - (E - sum));\n\n    // ?¨??????????\n    rep(i,lx+1,rx) {\n        pii ra = solve(lx, ly, i, ry);\n        pii rb = solve(i, ly, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    // ????????????\n    rep(i,ly+1,ry) {\n        pii ra = solve(lx, ly, rx, i);\n        pii rb = solve(lx, i, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n    return ans;\n}\n\nsigned main() {\n    while(cin >> H >> W >> S, H || W || S) {\n        memset(board, 0, sizeof(board));\n        rep(i,0,33) rep(j,0,33) rep(k,0,33) rep(l,0,33)\n            memo[i][j][k][l] = INIT;\n        rep(i,0,H) rep(j,0,W) cin >> board[i+1][j+1];\n        rep(i,0,H) rep(j,0,W) board[i+1][j+1] += board[i+1][j];\n        rep(j,0,W) rep(i,0,H) board[i+1][j+1] += board[i][j+1];\n\n        E = getsum(0, 0, H, W);\n        pii ans = solve(0, 0, H, W);\n        printf(\"%lld %lld\\n\", ans.first, ans.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, T;\nvector< vector<int> > A;\nbool m1[32][32][32][32];\nP m2[32][32][32][32];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, getM(x1, y1, x2, y2)-T);\n\tif (res.second < 0) {\n\t\tres = P(-inf, 0);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> T, H || W || T) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[31][31][32], false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tT = sum - T;\n\t\tP ans = solve(0, 0, W, H);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint DP[33][33][33][33];\nint rem[33][33][33][33];\n\nint h, w, s;\nint u[40][40];\n\nint S(int y, int x){\n\tif(y < 0 || x < 0 || y >= h || x >= w){\n\t\treturn 0;\n\t}\n\treturn u[y][x];\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> h >> w >> s;\n\t\tif(h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tu[i][j] += u[i - 1][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 40; i++){\n\t\t\tfor(int j = 1; j < 40; j++){\n\t\t\t\tu[i][j] += u[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tint th = u[h - 1][w - 1] - s;\n\t\tfor(int i = 0; i < w; i++)for(int l = 0; l < h; l++)\n\t\tfor(int j = 0; j < h; j++)for(int k = 0; k < w; k++){\n\t\t\tDP[i][j][k][l] = 0;\n\t\t\trem[i][j][k][l] = 0;\n\t\t\tif(i <= k && j <= l){\n\t\t\t\tint hoge = S(l, k) - S(l, i - 1) - S(j - 1, k) + S(j - 1, i - 1);\n\t\t\t\tif(hoge >= th){\n\t\t\t\t\tDP[i][j][k][l] = 1;\n\t\t\t\t\trem[i][j][k][l] = hoge - th;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int dx = 0; dx < w; dx++)for(int dy = 0; dy < h; dy++)\n\t\tfor(int sx = 0; sx + dx < w; sx++)for(int sy = 0; sy + dy < h; sy++){\n\t\t\tint gx = sx + dx;\n\t\t\tint gy = sy + dy;\n\t\t\tfor(int px = sx; px < gx; px++){\n\t\t\t\tint ret = DP[sx][sy][px][gy] + DP[px + 1][sy][gx][gy];\n\t\t\t\tint ret2 = min(rem[sx][sy][px][gy], rem[px + 1][sy][gx][gy]);\n\t\t\t\t\n\t\t\t\tif(DP[sx][sy][gx][gy] < ret){\n\t\t\t\t\tDP[sx][sy][gx][gy] = ret;\n\t\t\t\t\trem[sx][sy][gx][gy] = ret2;\n\t\t\t\t}else if(DP[sx][sy][gx][gy] == ret){\n\t\t\t\t\trem[sx][sy][gx][gy] = max(rem[sx][sy][gx][gy], ret2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int py = sy; py < gy; py++){\n\t\t\t\tint ret = DP[sx][sy][gx][py] + DP[sx][py + 1][gx][gy];\n\t\t\t\tint ret2 = min(rem[sx][sy][gx][py], rem[sx][py + 1][gx][gy]);\n\t\t\t\t\n\t\t\t\tif(DP[sx][sy][gx][gy] < ret){\n\t\t\t\t\tDP[sx][sy][gx][gy] = ret;\n\t\t\t\t\trem[sx][sy][gx][gy] = ret2;\n\t\t\t\t}else if(DP[sx][sy][gx][gy] == ret){\n\t\t\t\t\trem[sx][sy][gx][gy] = max(rem[sx][sy][gx][gy], ret2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << DP[0][0][w - 1][h - 1] << \" \" << rem[0][0][w - 1][h - 1] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,s,sum;\nstruct P{\n\tint y,x;\n\tinline P(){}\n\tinline P(int y,int x):y(y),x(x){}\n};\nP pmax(P a,P b){\n\tif(a.y!=b.y){\n\t\tif(a.y>b.y)\n\t\t\treturn a;\n\t\treturn b;\n\t}else{\n\t\tif(a.x>b.x)\n\t\t\treturn a;\n\t\treturn b;\n\t}\n}\nint u[32][32];\nP dp[32][32][32][32];\nP ret(P a,P b,int cnt){\n\tif(dp[a.y][a.x][b.y][b.x].y!=-1)\n\t\treturn dp[a.y][a.x][b.y][b.x];\n\tP ans(1,cnt);\n\tint s1=0,s2=0;\n\tfor(int i=a.y;i<b.y;i++){\n\t\tfor(int j=a.x;j<=b.x;j++){\n\t\t\ts1+=u[i][j];\n\t\t}\n\t\tif(sum-s1>s)\n\t\t\tcontinue;\n\t\tif(sum-(cnt-s1)>s)\n\t\t\tbreak;\n\t\tP x=ret(a,P(i,b.x),s1),y=ret(P(i+1,a.x),b,cnt-s1);\n\t\tans=pmax(ans,P(x.y+y.y,min(x.x,y.x)));\n\t}\n\tfor(int i=a.x;i<b.x;i++){\n\t\tfor(int j=a.y;j<=b.y;j++){\n\t\t\ts2+=u[j][i];\n\t\t}\n\t\tif(sum-s2>s)\n\t\t\tcontinue;\n\t\tif(sum-(cnt-s2)>s)\n\t\t\tbreak;\n\t\tP x=ret(a,P(b.y,i),s2),y=ret(P(a.y,i+1),b,cnt-s2);\n\t\tans=pmax(ans,P(x.y+y.y,min(x.x,y.x)));\n\t}\n\treturn dp[a.y][a.x][b.y][b.x]=ans;\n}\nint main(){\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tsum=0;\n\t\trep(i,h)rep(j,w)rep(k,h)rep(l,w)\n\t\tdp[i][j][k][l]=P(-1,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>u[i][j];\n\t\t\tsum+=u[i][j];\n\t\t}\n\t\tP ans=ret(P(0,0),P(h-1,w-1),sum);\n\t\tcout<<ans.y<<\" \"<<s-(sum-ans.x)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint sumi[35][35];\nint H, W, S;\n\nint sum(int i, int j, int k, int l) {\n  return sumi[k][l] - (i ? sumi[i-1][l] : 0) - (j ? sumi[k][j-1] : 0) + (i && j ? sumi[i-1][j-1] : 0);\n}\n\ntypedef pair<int, int> pii; // pattern, yobi\n\npii dp[35][35][35][35];\n\nint yobi(int i, int j, int k, int l) {\n  return S - sum(0, 0, H-1, W-1) + sum(i, j, k, l);\n}\n\npii dfs(int i, int j, int k, int l) {\n  auto& ret = dp[i][j][k][l];\n  if(ret.first != -1) { return ret; }\n\n  ret = {1, yobi(i, j, k, l)};\n\n  REP(a, i, k) {\n    if(yobi(i, j, a, l) < 0) continue;\n    if(yobi(a+1, j, k, l) < 0) continue;\n    auto x = dfs(i, j, a, l);\n    auto y = dfs(a+1, j, k, l);\n    ret = max(ret, {x.first + y.first, min(x.second, y.second)}); // テ、ツサツサテヲツ?湘」ツ?ョ -> テ、ツコツ暗・ツつ凖・ツ環崚」ツ?ョテヲツ慊?・ツーツ湘・ツ?、テ」ツつ津ヲツ慊?・ツ、ツァテ・ツ個?\n  }\n\n  REP(b, j, l) {\n    if(yobi(i, j, k, b) < 0) continue;\n    if(yobi(i, b+1, k, l) < 0) continue;\n    auto x = dfs(i, j, k, b);\n    auto y = dfs(i, b+1, k, l);\n    ret = max(ret, {x.first + y.first, min(x.second, y.second)});\n  }\n\n  return ret;\n}\n\nint main() {\n\n  for(; cin >> H >> W >> S && (H|W|S);) {\n    vector<vector<int>> U(H, vector<int>(W));\n    rep(i, H) rep(j, W) {\n      cin >> U[i][j];\n    }\n\n    zero(sumi);\n\n    rep(i, H) rep(j, W) {\n      sumi[i][j] = U[i][j];\n      if(i) sumi[i][j] += sumi[i-1][j];\n      if(j) sumi[i][j] += sumi[i][j-1];\n      if(i && j) sumi[i][j] -= sumi[i-1][j-1];\n    }\n\n    rep(i, 35) rep(j, 35) rep(k, 35) rep(l, 35) dp[i][j][k][l] = {-1,-1};\n\n    auto k = dfs(0, 0, H-1, W-1);\n    cout << k.first << \" \" << k.second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_WID = 35;\nconst int INF = 1<<24;\nint H, W, S;\nint T;\n\nbool visited[MAX_WID][MAX_WID][MAX_WID][MAX_WID];\npair<int,int> memo[MAX_WID][MAX_WID][MAX_WID][MAX_WID];\nint us[MAX_WID][MAX_WID];\nint accum[MAX_WID][MAX_WID];\n\n// [x1,x2), [y1, y2)\nint sum(int x1, int y1, int x2, int y2){\n\treturn accum[x2][y2] + accum[x1][y1] - accum[x1][y2] - accum[x2][y1];\n}\n\nvoid init(){\n\tmemset(accum, 0, sizeof(accum));\n\tmemset(visited, 0, sizeof(visited));\n\n\tfor(int i=0; i<H; i++)for(int j=0; j<W; j++){\n\t\taccum[i+1][j+1] = accum[i+1][j] + accum[i][j+1] - accum[i][j] + us[i][j];\n\t}\n\n\tT = accum[H][W] - S;\n}\n\npair<int,int> rec(int x1, int y1, int x2, int y2){\n\tif(visited[x1][y1][x2][y2]) return memo[x1][y1][x2][y2];\n\tvisited[x1][y1][x2][y2] = true;\n\tpair<int,int>& ret = memo[x1][y1][x2][y2];\n\tif(sum(x1,y1,x2,y2) < T){\n\t\treturn ret = make_pair(-INF,-INF);\n\t}\n\tret = make_pair(1,sum(x1,y1,x2,y2));\n\n\tfor(int x=x1+1; x<x2; x++){\n\t\tpair<int,int> t1 = rec(x1, y1, x, y2), t2 = rec(x, y1, x2, y2);\n\t\tpair<int,int> t(t1.first + t2.first, min(t1.second, t2.second));\n\t\tret = max(ret, t);\n\t}\n\n\tfor(int y=y1+1; y<y2; y++){\n\t\tpair<int,int> t1 = rec(x1, y1, x2, y), t2 = rec(x1, y, x2, y2);\n\t\tpair<int,int> t(t1.first + t2.first, min(t1.second, t2.second));\n\t\tret = max(ret, t);\n\t}\n\n\treturn ret;\n}\n\nvoid solve(){\n\tinit();\n\tpair<int,int> ans = rec(0,0,H,W);\n\tprintf(\"%d %d\\n\", ans.first, S - (accum[H][W] - ans.second));\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\",&H,&W,&S),H){\n\t\tfor(int i=0; i<H; i++)for(int j=0; j<W; j++){\n\t\t\tscanf(\"%d\", us[i]+j);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<20)\nint h,w,s;\nint u[32][32];\nstruct Group{\n\tint n,yobi;\n}dp[32][32][32][32];\n\nint total[32][32];\nint calc(int y1,int y2,int x1,int x2){\n\tint a,b,c,d;\n\tb=c=d=0;\n\ta = total[y2][x2];\n\tif(x1)b = total[y2][x1-1];\n\tif(y1)c = total[y1-1][x2];\n\tif(y1&&x1)d = total[y1-1][x1-1];\n\treturn a-b-c+d;\n}\nGroup dfs(int y1,int y2,int x1,int x2){\n\tif(dp[y1][y2][x1][x2].n!=-1)return dp[y1][y2][x1][x2];\n\tGroup res={-1,-1},a,b,t;\n\tif(s<total[h-1][w-1]-calc(y1,y2,x1,x2)){\n\t\tres.n = -INF;\n\t\treturn dp[y1][y2][x1][x2]=res;\n\t}\n\tres.n = 1;\n\tres.yobi = s-(total[h-1][w-1]-calc(y1,y2,x1,x2));\n\tfor(int i=x1;i<x2;i++){\n\t\ta = dfs(y1,y2,x1,i);\n\t\tb = dfs(y1,y2,i+1,x2);\n\t\tt.n = a.n+b.n;\n\t\tt.yobi = min(a.yobi,b.yobi);\n\t\tif(res.n < t.n)res = t;\n\t\telse if(res.n==t.n && res.yobi<t.yobi)res=t;\n\t}\n\tfor(int i=y1;i<y2;i++){\n\t\ta = dfs(y1,i,x1,x2);\n\t\tb = dfs(i+1,y2,x1,x2);\n\t\tt.n = a.n+b.n;\n\t\tt.yobi = min(a.yobi,b.yobi);\n\t\tif(res.n < t.n)res = t;\n\t\telse if(res.n==t.n && res.yobi<t.yobi)res=t;\n\t}\n\treturn dp[y1][y2][x1][x2]=res;\n}\nint main(){\n\t\n\twhile(cin>>h>>w>>s,h|w|s){\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>u[y][x];\n\t\t\t\ttotal[y][x] = u[y][x];\n\t\t\t}\n\t\tfor(int y=1;y<h;y++)total[y][0] += total[y-1][0];\n\t\tfor(int x=1;x<w;x++)total[0][x] += total[0][x-1];\n\t\tfor(int y=1;y<h;y++)\n\t\t\tfor(int x=1;x<w;x++)\n\t\t\t\ttotal[y][x] += total[y-1][x]+total[y][x-1]-total[y-1][x-1];\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tGroup ans = dfs(0,h-1,0,w-1);\n\t\tcout<<ans.n<<' '<<ans.yobi<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\nvector<vector<int> > u;\nvector<vector<int> > sums;\nvector<vector<vector<vector<i_i> > > > memo;\nint h, w, s;\nint sum;\n \ni_i rec(i_i lu, i_i rd) {\n    if(memo[lu.first][lu.second][rd.first][rd.second].first != INF) return memo[lu.first][lu.second][rd.first][rd.second];\n    else {\n        int sub = s - (sum - (sums[rd.first + 1][rd.second + 1] - sums[(lu.first + 1) - 1][rd.second + 1]\n                         - sums[rd.first + 1][(lu.second + 1) - 1] + sums[(lu.first + 1) - 1][(lu.second + 1) - 1]));\n        if(sub < 0) {\n            return memo[lu.first][lu.second][rd.first][rd.second] = i_i(-1, -1);\n        }\n        i_i res = i_i(-1, -1);\n        REP(i, rd.first - lu.first) {\n            i_i lset = rec(lu, i_i(lu.first + i, rd.second));\n            i_i rset = rec(i_i(lu.first + 1 + i, lu.second), rd);\n            if(lset.first != -1 && rset.first != -1) {\n                res = max(res, i_i(lset.first + rset.first, min(lset.second, rset.second)));\n            }\n        }\n        REP(i, rd.second - lu.second) {\n            i_i lset = rec(lu, i_i(rd.first, lu.second + i));\n            i_i rset = rec(i_i(lu.first, lu.second + 1 + i), rd);\n            if(lset.first != -1 && rset.first != -1) {\n                res = max(res, i_i(lset.first + rset.first, min(lset.second, rset.second)));\n            }\n        }\n        if(res.first != -1) return memo[lu.first][lu.second][rd.first][rd.second] = res;\n        else {\n            return memo[lu.first][lu.second][rd.first][rd.second] = i_i(1, sub);\n        }\n    }\n}\n \nint main(void) {\n    while(true) {\n        cin>>h>>w>>s;\n        if(h == 0 && w == 0 && s == 0) break;\n        sum = 0;\n        u.resize(h);\n        REP(i, h) u[i].resize(w);\n        REP(i, h) {\n            REP(j, w) {\n                cin>>u[i][j];\n                sum += u[i][j];\n            }\n        }\n        sums.resize(h + 1);\n        REP(i, h + 1) sums[i].resize(w + 1);\n        REP(i, h + 1) {\n            REP(j, w + 1) {\n                if(i == 0 || j == 0) sums[i][j] = 0;\n                else {\n                    sums[i][j] = u[i - 1][j - 1];\n                }\n            }\n        }\n        REP(i, h + 1) {\n            REP(j, w + 1) {\n                if(j == 0) continue;\n                sums[i][j] += sums[i][j - 1];\n            }\n        }\n        REP(j, w + 1) {\n            REP(i, h + 1) {\n                if(i == 0) continue;\n                sums[i][j] += sums[i - 1][j];\n            }\n        }\n        memo.resize(h);\n        REP(i, h) {\n            memo[i].resize(w);\n            REP(j, w) {\n                memo[i][j].resize(h);\n                REP(k, h) {\n                    memo[i][j][k].resize(w);\n                    REP(l, w) {\n                        memo[i][j][k][l] = i_i(INF, INF);\n                    }\n                }\n            }\n        }\n        i_i ans = rec(i_i(0, 0), i_i(h - 1, w - 1));\n        cout<<ans.first<<\" \"<<ans.second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40]; pair<int, int> dp[40][40][40][40];\nint rng(int x1, int y1, int x2, int y2) {\n\treturn sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2];\n}\npair<int, int> solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2].first != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tpair<int, int> ret = make_pair(1, rng_);\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tpair<int, int> resl = solve(x1, y1, i, y2);\n\t\t\tpair<int, int> resr = solve(i, y1, x2, y2);\n\t\t\tpair<int, int> res = make_pair(resl.first + resr.first, min(resl.second, resr.second));\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tpair<int, int> resl = solve(x1, y1, x2, i);\n\t\t\tpair<int, int> resr = solve(x1, i, x2, y2);\n\t\t\tpair<int, int> res = make_pair(resl.first + resr.first, min(resl.second, resr.second));\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\t//cout << y1 << ' ' << x1 << ' ' << y2 << ' ' << x2 << ' ' << ret.first << ' ' << ret.second << endl;\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l].first = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tpair<int, int> ret = solve(0, 0, W, H);\n\t\tcout << ret.first << ' ' << ret.second - o << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) (t / 102400)\n#define snd(t) (t % 102400)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint H, W, S;\nint map[32][32];\nll dp[32 * 32 * 32 * 32];\n\ninline int sum(int x0, int x1, int y0, int y1){\n    --x0;\n    --y0;\n\n    int res = map[y1][x1];\n    \n    if(x0 >= 0){\n        res -= map[y1][x0];\n    }\n    if(y0 >= 0){\n        res -= map[y0][x1];\n    }\n    if(x0 >= 0 && y0 >= 0){\n        res += map[y0][x0];\n    }\n\n    return res;\n}\n\ninline int index(int x0, int x1, int y0, int y1){\n    return y1 + 32 * (y0 + 32 * (x1 + 32 * x0));\n}\n\nll rec(int x0, int x1, int y0, int y1){\n    ll &res = dp[index(x0, x1, y0, y1)];\n    if(res != -1){return res;}\n    \n    {\n        int x = S - (map[H-1][W-1] - sum(x0, x1, y0, y1));\n        if(x >= 0){\n            res = 102400 + x;\n        }\n    }\n\n    for(int i=x0;i<x1;++i){\n        ll res_s1 = rec(x0, i, y0, y1), res_s2 = rec(i+1, x1, y0, y1);\n        res = std::max(res, (fst(res_s1) + fst(res_s2)) * 102400 + std::min(snd(res_s1), snd(res_s2)));\n    }\n\n    for(int i=y0;i<y1;++i){\n        ll res_s1 = rec(x0, x1, y0, i), res_s2 = rec(x0, x1, i+1, y1);\n        res = std::max(res, (fst(res_s1) + fst(res_s2)) * 102400 + std::min(snd(res_s1), snd(res_s2)));\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> H >> W >> S;\n        if(H == 0){return 0;}\n\n        memset(dp, -1ll, sizeof(dp));\n    \n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                std::cin >> map[i][j];\n            }\n        }\n\n        for(int i=0;i<H;++i){\n            for(int j=1;j<W;++j){\n                map[i][j] += map[i][j-1];\n            }\n        }\n\n        for(int i=0;i<W;++i){\n            for(int j=1;j<H;++j){\n                map[j][i] += map[j-1][i];\n            }\n        }\n        \n        ll res = rec(0, W-1, 0, H-1);\n        printf(\"%lld %lld\\n\", fst(res), snd(res));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nint field[33][33];\nint sum[33][33];\nint num[33][33][33][33];\nint msz[33][33][33][33];\n\nint H,W,S;\nint all;\n\nconst int inf=1<<29;\n\nint get(int i1,int i2,int j1,int j2){\n\ti1--;j1--;\n\treturn sum[i2][j2]-sum[i1][j2]-sum[i2][j1]+sum[i1][j1];\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d\",&H,&W,&S);\n\t\tif(H==0&&W==0) return 0;\n\t\tfor(int i=1;i<=H;i++)for(int j=1;j<=W;j++)scanf(\"%d\",&field[i][j]);\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor(int i=1;i<=H;i++) for(int j=1;j<=W;j++){\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+field[i][j];\n\t\t}\n\t\tint x=sum[H][W]-S;\n\t\tmemset(num,-1,sizeof(num));\n\t\tmemset(msz,-1,sizeof(msz));\n\t\tfor(int i=1;i<=H;i++)for(int j=1;j<=W;j++){\n\t\t\tif(field[i][j]<x){\n\t\t\t\tnum[i][i][j][j]=-inf;\n\t\t\t\tmsz[i][i][j][j]=-inf;\n\t\t\t}else{\n\t\t\t\tnum[i][i][j][j]=1;\n\t\t\t\tmsz[i][i][j][j]=field[i][j];\n\t\t\t}\n\t\t}\n//\t\tprintf(\"aa%d %d\\n\",get(1,2,1,2),sum[2][3]);\n\t\tfor(int id=0;id<=H-1;id++) for(int jd=0;jd<=W-1;jd++){\n\t\tif(id==0&&jd==0) continue;\n\t\t\tfor(int i=1;i+id<=H;i++){\n\t\t\t\tfor(int j=1;j+jd<=W;j++){\n\t\t\t\t\tint i1=i,i2=i+id,j1=j,j2=j+jd;\n\t\t\t\t\tint cAll=get(i1,i2,j1,j2);\n\t\t\t\t\tif(cAll<x){\n\t\t\t\t\t\tnum[i1][i2][j1][j2]=-inf;\n\t\t\t\t\t\tmsz[i1][i2][j1][j2]=-inf;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnum[i1][i2][j1][j2]=1;\n\t\t\t\t\tmsz[i1][i2][j1][j2]=cAll;\n\t\t\t\t\tif(id!=0){\n\t\t\t\t\t\tfor(int si=i1;si<i2;si++){\n\t\t\t\t\t\t\t//[i][si],[si+1][i2]\n\t\t\t\t\t\t\tint nnum=num[i1][si][j1][j2]+num[si+1][i2][j1][j2];\n\t\t\t\t\t\t\tint nmsz=min(msz[i1][si][j1][j2],msz[si+1][i2][j1][j2]);\n\t\t\t\t\t\t\tint &cnum=num[i1][i2][j1][j2];\n\t\t\t\t\t\t\tint &cmsz=msz[i1][i2][j1][j2];\n\t\t\t\t\t\t\tif(cnum<nnum||(cnum==nnum&&cmsz<nmsz)){\n\t\t\t\t\t\t\t\tcnum=nnum;\n\t\t\t\t\t\t\t\tcmsz=nmsz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(jd!=0){\n\t\t\t\t\t\tfor(int sj=j1;sj<j2;sj++){\n\t\t\t\t\t\t\tint nnum=num[i1][i2][j1][sj]+num[i1][i2][sj+1][j2];\n\t\t\t\t\t\t\tint nmsz=min(msz[i1][i2][j1][sj],msz[i1][i2][sj+1][j2]);\n\t\t\t\t\t\t\tint &cnum=num[i1][i2][j1][j2];\n\t\t\t\t\t\t\tint &cmsz=msz[i1][i2][j1][j2];\n\t\t\t\t\t\t\tif(cnum<nnum||(cnum==nnum&&cmsz<nmsz)){\n\t\t\t\t\t\t\t\tcnum=nnum;\n\t\t\t\t\t\t\t\tcmsz=nmsz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",num[1][H][1][W],msz[1][H][1][W]-x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint h,w,s,u[35][35],rui[35][35],sum;\n//(max,min_sum)\nP dp[35][35][35][35];\nP rec(int a,int b,int c,int d){\n\tif(dp[a][b][c][d].sc != -INF) return dp[a][b][c][d];\n\tif(rui[b][d]-rui[a-1][d]-rui[b][c-1]+rui[a-1][c-1] >= sum-s){\n\t\tdp[a][b][c][d] = mp(1,(rui[b][d]-rui[a-1][d]-rui[b][c-1]+rui[a-1][c-1]));\n\t}\n\telse return mp(-INF,-INF);\n\tfor(int i=a;i<b;i++){\n\t\tP f = rec(a,i,c,d), s = rec(i+1,b,c,d);\n\t\tdp[a][b][c][d] = max(dp[a][b][c][d],mp(f.fi+s.fi,min(f.sc,s.sc)));\n\t}\n\tfor(int i=c;i<d;i++){\n\t\tP f = rec(a,b,c,i), s = rec(a,b,i+1,d);\n\t\tdp[a][b][c][d] = max(dp[a][b][c][d],mp(f.fi+s.fi,min(f.sc,s.sc)));\n\t\t\n\t}\n\treturn dp[a][b][c][d];\n}\nint main(){\n\twhile(1){\n\t\tcin>>h>>w>>s;\n\t\tif(h==0&&w==0&&s==0) return 0; sum = 0;\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) cin>>u[i][j],sum+=u[i][j];\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) rui[i][j]=u[i][j]+rui[i-1][j]+rui[i][j-1]-rui[i-1][j-1];\n\t\tfor(int i=1;i<=h;i++) for(int ii=i;ii<=h;ii++)\n\t\tfor(int j=1;j<=w;j++) for(int jj=j;jj<=w;jj++) dp[i][ii][j][jj] = mp(-INF,-INF);\n\t\tP ans = rec(1,h,1,w);\n\t\tcout<<ans.fi<<\" \"<<s-(sum-ans.sc)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nint H, W, S;\nint u[35][35];\nint su[35][35];\nint p = 0;\n\npair<int,int> memo[35][35][35][35];\n\npair<int, int> best_splitting(int lh, int rh, int lw, int rw) {\n    pair<int, int>* ptr = &memo[lh][rh][lw][rw];\n    if (ptr->first >= 0) {\n        return *ptr;\n    }\n\n    int sum_of_area = su[lh][lw] - su[rh][lw] - su[lh][rw] + su[rh][rw];\n\n    pair<int, int> ret = make_pair(-1, -1);\n    if (sum_of_area >= p) {\n        ret = make_pair(1, sum_of_area - p);\n    } else {\n        return *ptr = ret;\n    }\n\n    for (int dh = lh+1; dh < rh; ++dh) {\n        auto s1 = best_splitting(lh, dh, lw, rw);\n        auto s2 = best_splitting(dh, rh, lw, rw);\n\n        if (s1.first < 0 || s2.first < 0) {\n            continue;\n        }\n\n        auto cand = make_pair(s1.first+s2.first, min(s1.second, s2.second));\n        if (cand > ret) {\n            ret = cand;\n        }\n    }\n\n    for (int dw = lw+1; dw < rw; ++dw) {\n        auto s1 = best_splitting(lh, rh, lw, dw);\n        auto s2 = best_splitting(lh, rh, dw, rw);\n\n        if (s1.first < 0 || s2.first < 0) {\n            continue;\n        }\n\n        auto cand = make_pair(s1.first+s2.first, min(s1.second, s2.second));\n        if (cand > ret) {\n            ret = cand;\n        }\n    }\n\n    return *ptr = ret;\n}\n\nbool solve() {\n    cin >> H >> W >> S;\n    if (H == 0 && W == 0 && S == 0) {\n        return false;\n    }\n\n    p = 0;\n    for (int j = 0; j < 35; ++j) {\n        fill(u[j], u[j]+35, 0);\n        fill(su[j], su[j]+35, 0);\n    }\n\n    for (int j = 1; j <= H; ++j) {\n        for (int k = 1; k <= W; ++k) {\n            cin >> u[j][k];\n            p += u[j][k];\n        }\n    }\n    p -= S;\n\n    for (int j = H; j > 0; --j) {\n        for (int k = W; k > 0; --k) {\n            su[j][k] = u[j][k] + su[j+1][k] + su[j][k+1] - su[j+1][k+1];\n        }\n    }\n\n    for (int j = 0; j < 35; ++j) {\n        for (int k = 0; k < 35; ++k) {\n            for (int l = 0; l < 35; ++l) {\n                fill(memo[j][k][l], memo[j][k][l]+35, make_pair(-1, -1));\n            }\n        }\n    }\n\n    auto result = best_splitting(1, H+1, 1, W+1);\n    cout << result.first << ' ' << result.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define DP(a,b,c,d) ((dpn[a][b][c][d]<<8)+(dpm[a][b][c][d]))\nusing namespace std;\n\nint sum[32][32][33][33];\nint dpn[32][32][33][33];\nint dpm[32][32][33][33];\nint S;\n\nvoid dp(int X,int Y,int W,int H){\n\tint w,h;\n\tif(sum[X][Y][W][H]<S) return;\n\tdpn[X][Y][W][H] = 1;\n\tdpm[X][Y][W][H] = sum[X][Y][W][H]-S;\n\tif(sum[X][Y][W][H]<2*S) return;\n\tfor(h=1;h<H;h++){\n\t\tif(dpn[X][Y][W][h] && dpn[X][Y+h][W][H-h])\n//\t\t\tprintf(\"dp(%d,%d,%d,%d) %d<%d+%d\\n\",X,Y,W,H,DP(X,Y,W,H), DP(X,Y,W,h), DP(X,Y+h,W,H-h));\n\t\t\tif(DP(X,Y,W,H) < DP(X,Y,W,h) + DP(X,Y+h,W,H-h) - max(dpm[X][Y][W][h],dpm[X][Y+h][W][H-h])){\n\t\t\t\tdpn[X][Y][W][H] = dpn[X][Y][W][h]+dpn[X][Y+h][W][H-h];\n\t\t\t\tdpm[X][Y][W][H] = min(dpm[X][Y][W][h],dpm[X][Y+h][W][H-h]);\n\t\t\t}\n\t}\n\tfor(w=1;w<W;w++){\n\t\tif(dpn[X][Y][w][H] && dpn[X+w][Y][W-w][H])\n//\t\t\tprintf(\"dp(%d,%d,%d,%d) %d<%d+%d\\n\",X,Y,W,H,DP(X,Y,W,H), DP(X,Y,w,H), DP(X+w,Y,W-w,H));\n\t\t\tif(DP(X,Y,W,H) < DP(X,Y,w,H) + DP(X+w,Y,W-w,H) - max(dpm[X][Y][w][H],dpm[X+w][Y][W-w][H])){\n\t\t\t\tdpn[X][Y][W][H] = dpn[X][Y][w][H]+dpn[X+w][Y][W-w][H];\n\t\t\t\tdpm[X][Y][W][H] = min(dpm[X][Y][w][H],dpm[X+w][Y][W-w][H]);\n\t\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,H,W,x,y,h,w,s;\n\twhile(cin>>H>>W>>s,H){\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tmemset(dpn, 0, sizeof(dpn));\n\t\tmemset(dpm, 0, sizeof(dpm));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t\tcin>>sum[j][i][1][1];\n\t\tfor(h=1;h<=H;h++)\n\t\t\tfor(w=1;w<=W;w++)\n\t\t\t\tfor(y=0;y<=H-h;y++)\n\t\t\t\t\tfor(x=0;x<=W-w;x++)\n\t\t\t\t\t\tif(w !=1)sum[x][y][w][h]=sum[x][y][w-1][h]+sum[x+w-1][y][1][h];\n\t\t\t\t\t\telse if(h!=1)sum[x][y][w][h]=sum[x][y][w][h-1]+sum[x][y+h-1][w][1];\n\t\tS=sum[0][0][W][H] - s;\n//\t\tcout<<\"S=\"<<S<<endl;\n\t\tfor(h=1;h<=H;h++)\n\t\t\tfor(w=1;w<=W;w++)\n\t\t\t\tfor(y=0;y<=H-h;y++)\n\t\t\t\t\tfor(x=0;x<=W-w;x++)\n\t\t\t\t\t\tdp(x,y,w,h);\n//\t\tfor(h=1;h<=H;h++)\n//\t\t\tfor(w=1;w<=W;w++)\n//\t\t\t\tfor(y=0;y<=H-h;y++)\n//\t\t\t\t\tfor(x=0;x<=W-w;x++)\n//\t\t\t\t\t\tprintf(\"(%d,%d) %d*%d = %d,%d,%d\\n\",x,y,w,h,sum[x][y][w][h],dpn[x][y][w][h],dpm[x][y][w][h]);\n\t\t\n\t\tcout<<dpn[0][0][W][H]<<' '<<dpm[0][0][W][H]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nint main(){\n    ll h,w,s;\n    while(cin>>h>>w>>s){\n        if(h==0){break;}\n    vector<vector<ll>> A(h,vector<ll>(w,0));\n    ll sum=0;\n    for(auto &I:A){for(auto &T:I){cin>>T; sum+=T;}}\n    ll X=sum-s;\n    for(int i=1;i<h;i++){\n        for(int j=0;j<w;j++){A[i][j]+=A[i-1][j];}\n    }\n    for(int i=0;i<h;i++){\n        for(int j=1;j<w;j++){A[i][j]+=A[i][j-1];}\n    }\n    vector<vector<vector<vector<pll>>>> dp(h,vector<vector<vector<pll>>>(w,vector<vector<pll>>(h,vector<pll>(w,{-1,0}))));\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int x=i;x<h;x++){\n                for(int y=j;y<w;y++){\n                    ll sum=A[x][y];\n                    if(i!=0){sum-=A[i-1][y];}\n                    if(j!=0){sum-=A[x][j-1];}\n                    if(i!=0 && j!=0){sum+=A[i-1][j-1];}\n                    if(sum>=X){dp[i][j][x][y]={1,sum};}\n                }\n            }\n        }\n    }\n    for(int dh=0;dh<h;dh++){\n        for(int dw=0;dw<w;dw++){\n            for(int i=0;i+dh<h;i++){\n                for(int j=0;j+dw<w;j++){\n                    for(int k=0;k<dh;k++){\n                        pll &L=dp[i][j][i+k][j+dw];\n                        pll &R=dp[i+k+1][j][i+dh][j+dw];\n                        pll &N=dp[i][j][i+dh][j+dw];\n                        if(L.F==-1 || R.F==-1){continue;}\n                        if(pll(L.F+R.F,min(L.S,R.S))>N){N=pll(L.F+R.F,min(L.S,R.S));}\n                    }\n                    for(int k=0;k<dw;k++){\n                        pll &L=dp[i][j][i+dh][j+k];\n                        pll &R=dp[i][j+k+1][i+dh][j+dw];\n                        pll &N=dp[i][j][i+dh][j+dw];\n                        if(L.F==-1 || R.F==-1){continue;}\n                        if(pll(L.F+R.F,min(L.S,R.S))>N){N=pll(L.F+R.F,min(L.S,R.S));}\n                    }\n                }\n            }\n        }\n    }\n    cout<<dp[0][0][h-1][w-1].F<<\" \"<<dp[0][0][h-1][w-1].S-X<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a))\nusing namespace std;\n//global\nint h, w;\nint need_e;\nint town[33][33] = { 0 };\n\n\n\nstruct Group{\n\tint min_cost;\n\tint g_num;\n};\nGroup dp[32][32][33][33] = { 0 };\n\nint get_sum(int s_x, int s_y, int _h, int _w){\n\tint sum = 0;\n\trep(i, s_x, s_x + _h)rep(j, s_y, s_y + _w)sum += town[i][j];\n\treturn(sum);\n}\n\nvoid calc(int s_x, int s_y, int _h, int _w){\n\t\n\tGroup one, two,c;\n\tc.g_num = 1;\n\tc.min_cost = get_sum(s_x, s_y, _h, _w);\n\trep(i, 1, _h ){\n\t\tone = dp[s_x][s_y][i][_w];\n\t\ttwo = dp[s_x + i][s_y][_h - i][_w];\n\t\t//printf(\"[%d,%d],h=%d,h-i=%d,one=%d,two=%d\\n\", s_x, s_x+i, i, _h-i, one.min_cost, two.min_cost);\n\t\tif (one.min_cost < need_e || two.min_cost < need_e)continue;\n\t\tone.g_num = one.g_num + two.g_num;\n\t\tone.min_cost = (one.min_cost < two.min_cost) ? one.min_cost : two.min_cost;\n\t\tif (c.g_num < one.g_num)c = one;\n\t\telse if (c.g_num == one.g_num&&c.min_cost < one.min_cost)c = one;\n\t}\n\trep(i, 1, _w){\n\t\tone = dp[s_x][s_y][_h][i];\n\t\ttwo = dp[s_x][s_y+i][_h][_w-i];\n\t\tif (one.min_cost < need_e || two.min_cost < need_e)continue;\n\t\tone.g_num = one.g_num + two.g_num;\n\t\tone.min_cost = (one.min_cost < two.min_cost) ? one.min_cost : two.min_cost;\n\t\tif (c.g_num < one.g_num)c = one;\n\t\telse if (c.g_num == one.g_num&&c.min_cost < one.min_cost)c = one;\n\t}\n\tdp[s_x][s_y][_h][_w] = c;\n\t//printf(\"[%d,%d],h=%d,w=%d,g_num=%d,min_cost=%d\\n\", s_x, s_y, _h, _w,c.g_num,c.min_cost);\n}\n\nvoid solve(){\n\tint m = h > w ? h : w;\n\trep(height, 2, m + 1){\n\t\trep(width, 1, height)\n\t\t\trep(i, 0, h - width+1)\n\t\t\trep(j, 0, w - width+1){\n\t\t\t\tif (i + height <= h&&j + width <= w)\n\t\t\t\t\tcalc(i, j, height, width);\n\t\t\t\tif (i + width <= h&&j + height <= w)\n\t\t\t\t\tcalc(i, j, width, height);\n\t\t\t}\n\t\trep(i, 0, h - height+1)rep(j, 0, w - height+1)\n\t\t\tcalc(i, j, height, height);\n\t}\n\n}\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> h >> w >> need_e;\n\t\tif (need_e == 0)return(0);\n\t\trep(i, 0, h)rep(j, 0, w){\n\t\t\tcin >> town[i][j];\n\t\t\tdp[i][j][1][1].min_cost = town[i][j];\n\t\t\tdp[i][j][1][1].g_num = 1;\n\t\t}\n\t\tneed_e = get_sum(0, 0, h, w) - need_e;\n\t\t//cout << need_e << endl;\n\t\tsolve();\n\t\tprintf(\"%d %d\\n\", dp[0][0][h][w].g_num, dp[0][0][h][w].min_cost - need_e);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 32\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint H, W, S, sum;\nint u[MAX][MAX];\npii memo[MAX][MAX][MAX][MAX];\n\nint get_cost(int h1, int w1, int h2, int w2)\n{\n    int cost = 0;\n    for (int i = h1; i <= h2; i++) {\n        for (int j = w1; j <= w2; j++) {\n            cost += u[i][j];\n        }\n    }\n    return cost;\n}\n\npii solve(int h1, int w1, int h2, int w2)    \n{\n    pii res = memo[h1][w1][h2][w2];\n    if (res.first != -1) {\n        return res;\n    }\n    \n    res = pii(1, S - (sum - get_cost(h1, w1, h2, w2)));\n    for (int i = h1; i <= h2-1; i++) {\n        int c1 = get_cost(h1, w1, i, w2);\n        int c2 = get_cost(i+1, w1, h2, w2);\n        \n        if (sum - c1 <= S && sum - c2 <= S) {\n            pii n1 = solve(h1, w1, i, w2);\n            pii n2 = solve(i+1, w1, h2, w2);\n            pii n = pii(n1.first + n2.first, min(n1.second, n2.second));\n            res = max(res, n);\n        }        \n    }\n\n    for (int i = w1; i <= w2-1; i++) {\n        int c1 = get_cost(h1, w1, h2, i);\n        int c2 = get_cost(h1, i+1, h2, w2);\n        \n        if (sum - c1 <= S && sum - c2 <= S) {\n            pii n1 = solve(h1, w1, h2, i);\n            pii n2 = solve(h1, i+1, h2, w2);\n            pii n = pii(n1.first + n2.first, min(n1.second, n2.second));\n            res = max(res, n);\n        } \n    }\n    return memo[h1][w1][h2][w2] = res;\n}\n\nint main()\n{\n    while (cin >> H >> W >> S, H) {\n        sum = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> u[i][j];\n                sum += u[i][j];\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        memo[i][j][k][l] = pii(-1, -1);\n                    }\n                }\n            }\n        }\n        \n        pii res = solve(0, 0, H-1, W-1);\n        cout << res.first << \" \" << res.second << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1<<28)\ninline void cmax(int &a, int b) { if (a < b) a = b; }\n\nint n, m, S, f[32][32], _sum[40][40];\n\ninline int sum(int x1, int y1, int x2, int y2) {\n    return _sum[x2+1][y2+1]-_sum[x2+1][y1]-_sum[x1][y2+1]+_sum[x1][y1];\n}\n\nint dp[32][32][32][32];\n\nint solve(int lb) {\n    for (int w = 0; w < n; w++) rep (x1, n-w) {\n        const int x2 = x1+w;\n        for (int h = 0; h < m; h++) rep (y1, m-h) {\n            const int y2 = y1+h;\n            if (sum(x1, y1, x2, y2) < lb) {\n                dp[x1][x2][y1][y2] = -INF;\n                continue;\n            }\n            dp[x1][x2][y1][y2] = 1;\n            for (int i = x1; i < x2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][i][y1][y2]+dp[i+1][x2][y1][y2]);\n            }\n            for (int i = y1; i < y2; i++) {\n                cmax(dp[x1][x2][y1][y2], dp[x1][x2][y1][i]+dp[x1][x2][i+1][y2]);\n            }\n        }\n    }\n    return dp[0][n-1][0][m-1];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &n, &m, &S);\n        if (n == 0) return 0;\n        rep (i, n) rep (j, m) scanf(\"%d\", f[i]+j);\n        rep (i, n) rep (j, m) {\n            _sum[i+1][j+1] = f[i][j]+_sum[i+1][j]+_sum[i][j+1]-_sum[i][j];\n        }\n        const int tot = sum(0, 0, n-1, m-1);\n        const int ans = solve(tot-S);\n        int l = 0, r = min(S+1, 120*32);\n        while (r-l>1) {\n            const int mid = (l+r) / 2;\n            if (solve(tot-S+mid) >= ans) l = mid;\n            else r = mid;\n        }\n        printf(\"%d %d\\n\", ans, l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint h,w,s;\nvector<vi> in,v;\npii dp[35][35][35][35];\n\nvoid init(){\n    v = in;\n    rep(i,h)rep(j,w-1)v[i][j+1] += v[i][j];\n    rep(i,h-1)rep(j,w)v[i+1][j] += v[i][j];\n}\nint sum(int ax, int ay, int bx, int by){\n    int ret = v[bx][by];\n    if(ax)ret -= v[ax-1][by];\n    if(ay)ret -= v[bx][ay-1];\n    if(ax && ay)ret += v[ax-1][ay-1];\n    return ret;\n}\n\npii f(int a, int b, int c, int d){//最大グループ数、グループ需要のうち最大\n    if(dp[a][b][c][d] != pii(-1,-1))return dp[a][b][c][d];\n    if(sum(0,0,h-1,w-1) - sum(a,b,c,d) > s)return pii(-1,-1);\n    int group = 1, ret = sum(a,b,c,d);//分割しないとき\n    loop(i,b,d){//たて\n        pii x = f(a,b,c,i), y = f(a,i+1,c,d);\n        if(group < x.first + y.first || (\n            group == x.first + y.first && ret < min(x.second, y.second))){\n            group = x.first + y.first;\n            ret = min(x.second, y.second);\n        }\n    }\n    loop(i,a,c){//よこ\n        pii x = f(a,b,i,d), y = f(i+1,b,c,d);\n        if(group < x.first + y.first || (\n            group == x.first + y.first && ret < min(x.second, y.second))){\n            group = x.first + y.first;\n            ret = min(x.second, y.second);\n        }\n    }\n    return dp[a][b][c][d] = pii(group, ret);\n}\n\nsigned main(void) {\n    while(cin >> h >> w >> s, h){\n        in = vector<vi>(h,vi(w));\n        rep(i,h)rep(j,w)cin >> in[i][j];\n        init();\n        rep(a,35)rep(b,35)rep(c,35)rep(d,35)dp[a][b][c][d] = pii(-1,-1);\n        pii ans = f(0,0,h-1,w-1);\n        cout << ans.first << \" \" << s-sum(0,0,h-1,w-1)+ans.second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\nint h,w,s;\nint map[32][32];\nint all;\npair<int,int> memo[32][32][33][33];\nbool use[32][32][33][33];\n\npair<int,int> rec(int y1,int x1,int y2,int x2,int sum){\n  pair<int,int> res,hoge1,hoge2;\n  int a=1,b=0;\n  int tmp;\n  bool flag = false;\n\n  if(use[y1][x1][y2][x2])return memo[y1][x1][y2][x2];\n\n  tmp = 0;\n  for(int i=x1+1;i<x2;i++){\n\n    for(int j=y1;j<y2;j++)tmp += map[j][i-1];\n\n    if( all-tmp <= s && all-(sum-tmp) <= s){\n      flag = true;\n      hoge1 = rec(y1,x1,y2,i,tmp);\n      hoge2 = rec(y1,i,y2,x2,sum-tmp);\n      if(hoge1.first+hoge2.first > a){\n\ta = hoge1.first + hoge2.first;\n\tb = max(hoge1.second,hoge2.second);\n      }else if(hoge1.first + hoge2.first == a && max(hoge1.second,hoge2.second) < b){\n\tb = max(hoge1.second,hoge2.second);\n      }\n    }\n  }\n\n  tmp = 0;\n  for(int i=y1+1;i<y2;i++){\n\n    for(int j=x1;j<x2;j++)tmp += map[i-1][j];\n\n    if( all-tmp <= s && all-(sum-tmp) <= s){\n      flag = true;\n      hoge1 = rec(y1,x1,i,x2,tmp);\n      hoge2 = rec(i,x1,y2,x2,sum-tmp);\n      if(hoge1.first+hoge2.first > a){\n\ta = hoge1.first + hoge2.first;\n\tb = max(hoge1.second,hoge2.second);\n      }else if(hoge1.first + hoge2.first == a && max(hoge1.second,hoge2.second) < b){\n\tb = max(hoge1.second,hoge2.second);\n      }\n    }\n  }\n\n  if(!flag){\n    res.first = 1;\n    res.second = all - sum;\n  }else{\n    res.first = a;\n    res.second = b;\n  }\n  memo[y1][x1][y2][x2] = res;\n  use[y1][x1][y2][x2] = true;\n  return res;\n}\n\n\nint main(){\n  pair<int,int> ans;\n  while(1){\n    cin >> h >> w >> s;\n    if(!h && !w && !s)break;\n\n    all = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> map[i][j];\n\tall += map[i][j];\n      }\n    }\n \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<=h;k++){\n\t  for(int l=0;l<=w;l++){\n\t    memo[i][j][k][l].first = -1;\n\t    memo[i][j][k][l].second = -1;\n\t    use[i][j][k][l] = false;\n\t  }\n\t}\n      }\n    }\n\n    ans = rec(0,0,h,w,all);\n    cout << ans.first << \" \" << s - ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i = 0; i < (n); i++) \n \n \nint dp[32][32][32][32][3];\nint hyou[32][32];\nint Sh[32][32];\nint sumH(int x1, int y1, int x2, int y2) {\n\tif (x1 == 0 and y1 == 0) {\n\t\treturn Sh[y2][x2];\n\t}\n\tif (x1 == 0) {\n\t\treturn (Sh[y2][x2] - Sh[y1 - 1][x2]);\n\t}\n\tif (y1 == 0) {\n\t\treturn Sh[y2][x2] - Sh[y2][x1 - 1];\n\t}\n\treturn Sh[y2][x2] - Sh[y2][x1 - 1] - Sh[y1 - 1][x2] + Sh[y1 - 1][x1 - 1];\n}\n \nint main() {\n\tint H, W, S, k;\n\twhile (cin >> H >> W >> k, H) {\n\t\tS = 0;\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\thyou[i][j] = a;\n\t\t\t\tS += a;\n\t\t\t}\n\t\t}\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tif (i == 0 and j == 0) Sh[i][j] = hyou[i][j];\n\t\t\t\telse if (i == 0) Sh[i][j] = hyou[i][j] + Sh[i][j - 1];\n\t\t\t\telse if (j == 0) Sh[i][j] = hyou[i][j] + Sh[i - 1][j];\n\t\t\t\telse Sh[i][j] = Sh[i][j - 1] + Sh[i - 1][j] - Sh[i - 1][j - 1] + hyou[i][j];\n\t\t\t}\n\t\t}\n\t\tint m = S - k;\n\t\trep(w, W) {\n\t\t\trep(h, H) {\n\t\t\t\trep(x, W) {\n\t\t\t\t\tif (x + w >= W) break;\n\t\t\t\t\trep(y, H) {\n\t\t\t\t\t\tif (y + h >= H) break;\n\t\t\t\t\t\tint s = sumH(x, y, x + w, y + h);\n\t\t\t\t\t\tif (s >= S - k) {\n\t\t\t\t\t\t\tdp[y][x][y + h][x + w][0] = s;\n\t\t\t\t\t\t\tdp[y][x][y + h][x + w][1] = 1;\n\t\t\t\t\t\t\tdp[y][x][y + h][x + w][2] = k - (S - s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[y][x][y + h][x + w][0] = s;\n\t\t\t\t\t\t\tdp[y][x][y + h][x + w][1] = 0;\n\t\t\t\t\t\t\tdp[y][x][y + h][x + w][2] = k - (S - s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int w2 = x; w2 < x + w ; w2++) {\n\t\t\t\t\t\t\tif (dp[y][x][y + h][w2][1] + dp[y][w2 + 1][y + h][x + w][1] > dp[y][x][y + h][x + w][1]) {\n\t\t\t\t\t\t\t\tdp[y][x][y + h][x + w][1] = dp[y][x][y + h][w2][1] + dp[y][w2 + 1][y + h][x + w][1];\n\t\t\t\t\t\t\t\tdp[y][x][y + h][x + w][2] = min(dp[y][x][y + h][w2][2], dp[y][w2 + 1][y + h][x + w][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dp[y][x][y + h][w2][1] + dp[y][w2 + 1][y + h][x + w][1] == dp[y][x][y + h][x + w][1]) {\n\t\t\t\t\t\t\t\tdp[y][x][y + h][x + w][2] = max(dp[y][x][y + h][x + w][2], min(dp[y][x][y + h][w2][2], dp[y][w2 + 1][y + h][x + w][2]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int h2 = y; h2 < h + y; h2++) {\n\t\t\t\t\t\t\tif (dp[y][x][h2][x + w][1] + dp[h2 + 1][x][y + h][x + w][1] > dp[y][x][y + h][x + w][1]) {\n\t\t\t\t\t\t\t\tdp[y][x][y + h][x + w][1] = dp[y][x][h2][x + w][1] + dp[h2 + 1][x][y + h][x + w][1];\n\t\t\t\t\t\t\t\tdp[y][x][y + h][x + w][2] = min(dp[y][x][h2][x + w][2], dp[h2 + 1][x][y + h][x + w][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dp[y][x][h2][x + w][1] + dp[h2 + 1][x][y + h][x + w][1] == dp[y][x][y + h][x + w][1]) {\n\t\t\t\t\t\t\t\tdp[y][x][y + h][x + w][2] = max(dp[y][x][y + h][x + w][2], min(dp[y][x][h2][x + w][2], dp[h2 + 1][x][y + h][x + w][2]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][0][H - 1][W - 1][1] << \" \" << dp[0][0][H - 1][W - 1][2] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1048576 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048576, resr & 1048576);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = ((resl + resr) >> 20 << 20) + min(resl & 1048576, resr & 1048576);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << (ret >> 20) << ' ' << ((ret & 1048576) - o) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ¶ãÌÀWÆEºÌÀWÅÍÍðwèµA±ÌÍÍÌÅåO[vðL¯\npair<int,int> dp[32][32][32][32];\nint h,w,s;\nint field[32][32];\nint sumDemand;\n\n\npair<int,int> dfs(int minx,int miny,int maxx,int maxy){\n\tif(dp[miny][minx][maxy][maxx].first!=-1)\n\t\treturn dp[miny][minx][maxy][maxx];\n\t// »ÝÌêðâd³¹½Æ«ÉAùvªð´¦È¢©Ç¤©\n\tint decDemand=0;\n\tfor(int i = miny; i <= maxy; i++){\n\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\tdecDemand+=field[i][j];\n\t\t}\n\t}\n\tif(sumDemand - decDemand > s){\n\t\treturn make_pair(-1,0);\n\t}\n\n\tint pre=sumDemand-decDemand;\n\n\tpair<int,int> maxGroup;\n\tmaxGroup.first=1;\n\tmaxGroup.second=pre;\n\n\t// «èû·×Äð·\n\t// ¡Øè\n\tfor(int i = miny; i < maxy; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,maxx,i);\n\t\tpair<int,int> ret2=dfs(minx,i+1,maxx,maxy);\n\t\t// ±Ì«èûÍsÂ\\\n\t\tif(ret1.first==-1||ret2.first==-1)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\n\t}\n\t// tateØè\n\tfor(int i = minx; i < maxx; i++){\n\t\tpair<int,int> ret1=dfs(minx,miny,i,maxy);\n\t\tpair<int,int> ret2=dfs(i+1,miny,maxx,maxy);\n\t\tif(ret1.first==-1||ret2.first==-2)\n\t\t\tcontinue;\n\t\tint mtp=max(ret1.second,ret2.second);\n\t\tpair<int,int> div= make_pair(ret1.first+ret2.first,mtp);\n\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t\tmaxGroup=max(maxGroup,div);\n\t\tmaxGroup.second=-maxGroup.second;\n\t\tdiv.second=-div.second;\n\t}\n\tdp[miny][minx][maxy][maxx]=maxGroup;\n\treturn maxGroup;\n}\n\nint main(){\n\twhile(cin>>h>>w>>s&&!(h==0&&s==0&&w==0)){\n\t\tfor(int i = 0; i < 32; i++)\n\t\t\tfor(int j = 0; j < 32; j++)\n\t\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t\t\tfill(dp[i][j][k],dp[i][j][k]+32,make_pair(-1,0));\n\t\tsumDemand=0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tsumDemand+=field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mxg=dfs(0,0,w-1,h-1);\n\t\tcout<<mxg.first<<\" \"<<s-mxg.second<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint W,H,S,A;\nint field[35][35];\nint dp0[35][35][35];\nint dp[35][35][35][35];\nP memo[35][35][35][35];\n\nP dfs(int l, int t, int r, int b)\n{\n\tif(memo[l][t][r][b].first != 0) return memo[l][t][r][b];\n\n\tP res = make_pair(1, S-(A-dp[l][t][r][b]));\n\tfor(int i=l; i<r; i++){\n\t\tif(A-dp[l][t][i][b] > S || A-dp[i+1][t][r][b] > S) continue;\n\n\t\tP left = dfs(l,t,i,b);\n\t\tP right = dfs(i+1,t,r,b);\n\n\t\tP lr = make_pair(left.first + right.first, min(left.second, right.second));\n\t\tres = max(res, lr);\n\t}\n\n\tfor(int i=t; i<b; i++){\n\t\tif(A-dp[l][t][r][i] > S || A-dp[l][i+1][r][b] > S) continue;\n\n\t\tP top = dfs(l,t,r,i);\n\t\tP bot = dfs(l,i+1,r,b);\n\n\t\tP mid = make_pair(top.first + bot.first, min(top.second, bot.second));\n\t\tres = max(res, mid);\n\t}\n\n\tmemo[l][t][r][b] = res;\n\n\treturn memo[l][t][r][b];\n\n\t\n}\n\nvoid solve()\n{\n\tmemset(dp, 0, sizeof(dp));\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++){\n\t\tdp[j][i][j][i] = field[j][i];\n\n\t\tfor(int y=i-1; y>=0; y--)\n\t\t\tdp[j][y][j][i] = dp[j][y+1][j][i] + field[j][y];\n\n\t\tfor(int y=i; y>=0; y--) {\n\t\t\tint sum = 0;\n\t\t\tfor(int x=j; x>=0; x--) {\n\t\t\t\tsum += dp[x][y][x][i];\n\t\t\t\tdp[x][y][j][i] = sum;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(memo, 0, sizeof(memo));\n\tA = dp[0][0][W-1][H-1];\n\tP res = dfs(0,0,W-1,H-1);\n\tcout << res.first << \" \" << res.second << endl;\n}\n\nint main()\n{\n\twhile(cin >> H >> W >> S,(W||H||S)) {\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tcin >> field[j][i];\n\t\t}\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\npii INIT = pii(-1, -1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\n\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y) {\n    return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\n// ?°???°??? (??????) ??????????????????\npii solve(int lx, int ly, int rx, int ry) {\n    pii& ans = memo[lx][ly][rx][ry];\n    if(ans != INIT) return ans;\n\n    // ?°???°???????????¶???????????????????????§??????????????±???????????????????????????????????????\n    int sum = getsum(lx, ly, rx, ry);\n    if(sum < E - S) return ans = pii(0, INF);\n\n    // ??????\n    ans = pii(1, sum);\n\n    // ?¨??????????\n    rep(i,lx+1,rx) {\n        pii ra = solve(lx, ly, i, ry);\n        pii rb = solve(i, ly, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n\n    // ????????????\n    rep(i,ly+1,ry) {\n        pii ra = solve(lx, ly, rx, i);\n        pii rb = solve(lx, i, rx, ry);\n        pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n        chmax(ans, temp);\n    }\n    return ans;\n}\n\nsigned main() {\n    while(cin >> H >> W >> S, H || W || S) {\n        memset(board, 0, sizeof(board));\n        rep(i,0,33) rep(j,0,33) rep(k,0,33) rep(l,0,33)\n            memo[i][j][k][l] = INIT;\n        rep(i,0,H) rep(j,0,W) cin >> board[i+1][j+1];\n        rep(i,0,H) rep(j,0,W) board[i+1][j+1] += board[i+1][j];\n        rep(j,0,W) rep(i,0,H) board[i+1][j+1] += board[i][j+1];\n\n        E = getsum(0, 0, H, W);\n        pii ans = solve(0, 0, H, W);\n        printf(\"%lld %lld\\n\", ans.first, S - (E - ans.second));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstruct State {\n    int num, demand;    // (テ」ツつーテ」ツδォテ」ツδシテ」ツδ療ヲツ閉ー, テヲツ慊?・ツ、ツァテヲツ環妥・ツ按カテゥツ慊?ィツヲツ?テヲツ慊?・ツーツ湘・ツ個?)\n    State() {}\n    State(int num, int demand) : num(num), demand(demand) {}\n\n    /*\n    bool operator>(const State& st) const {\n        return num != st.num ? (num > st.num) : (demand < st.demand);\n    }\n    */\n};\n\nbool is_better(State s1, State s2) {\n    return s1.num != s2.num ? (s1.num > s2.num) : (s1.demand > s2.demand);\n}\n\nconst int INF = 1 << 28;\n\nint u[40][40], cum_u[40][40];\nState table[40][40][40][40];\n\nbool used[40][40][40][40];\n\nint h, w, s, all_demand;\n\nint calc_sum(int t, int b, int l, int r) {\n    int res = cum_u[b][r];\n    if (l > 0) res -= cum_u[b][l - 1];\n    if (t > 0) res -= cum_u[t - 1][r];\n    if (l > 0 && t > 0) res += cum_u[t - 1][l - 1];\n    return res;\n}\n\nState solve(int to, int bo, int le, int ri) {\n    if (used[to][bo][le][ri]) {\n        // cerr << \"テ」ツ?禿」ツ?ョテゥツ?佚・ツ淞淌・ツ??」ツ?ョテゥツ慊?ィツヲツ?ゥツ?湘」ツ?ッ\" << calc_sum(to, bo, le, ri) << endl;\n        return table[to][bo][le][ri];\n    }\n    used[to][bo][le][ri] = true;\n\n    /*\n    cerr << \"(to, bo, le, ri) \" << to << \", \" << bo << \", \" << le << \", \" << ri << endl;\n    */\n    int x = calc_sum(to, bo, le, ri);\n    if (all_demand - s > x) {\n        return table[to][bo][le][ri] = State(-INF, -INF);\n    }\n    // cerr << \"(to, bo, le, ri) \" << to << \", \" << bo << \", \" << le << \", \" << ri << endl;\n    State res = State(1, x);\n    for (int r = to; r + 1 <= bo; r++) {\n        State st;\n        auto res1 = solve(to, r, le, ri),\n             res2 = solve(r + 1, bo, le, ri);\n        st = State(res1.num + res2.num, min(res1.demand, res2.demand));\n        if (all_demand - s > st.demand) continue;\n        if (is_better(st, res)) {\n            res = st;\n        }\n    }\n    for (int c = le; c + 1 <= ri; c++) {\n        State st;\n        auto res1 = solve(to, bo, le, c),\n             res2 = solve(to, bo, c + 1, ri);\n        st = State(res1.num + res2.num, min(res1.demand, res2.demand));\n        if (all_demand - s > st.demand) continue;\n        if (is_better(st, res)) {\n            res = st;\n        }\n    }\n    return table[to][bo][le][ri] = res;\n}\n\nint main() {\n    while (cin >> h >> w >> s, h | w | s) {\n        memset(cum_u, 0, sizeof(cum_u));\n        memset(used, 0, sizeof(used));\n        for (int r1 = 0; r1 < 40; r1++) {\n            for (int c1 = 0; c1 < 40; c1++) {\n                for (int r2 = 0; r2 < 40; r2++) {\n                    for (int c2 = 0; c2 < 40; c2++) {\n                        table[r1][c1][r2][c2] = State(-INF, INF);\n                    }\n                }\n            }\n        }\n\n        for (int r = 0; r < h; r++) {\n            for (int c = 0; c < w; c++) {\n                cin >> u[r][c];\n            }\n        }\n\n        for (int r = 0; r < h; r++) {\n            for (int c = 0; c < w; c++) {\n                cum_u[r][c] = u[r][c];\n                if (c > 0) cum_u[r][c] += cum_u[r][c - 1];\n            }\n            if (r == 0) continue;\n            for (int c = 0; c < w; c++) {\n                cum_u[r][c] += cum_u[r - 1][c];\n            }\n        }\n\n        all_demand = cum_u[h - 1][w - 1];\n\n        auto res = solve(0, h - 1, 0, w - 1);\n        cout << res.num << \" \" << s - (all_demand - res.demand) << endl;\n\n        /*\n        cerr << \"debug\" << endl;\n        int r1, r2, c1, c2;\n\n        while (cin >> r1 >> r2 >> c1 >> c2, r1 >= 0 && c1 >= 0) {\n            auto res = solve(r1, r2, c1, c2);\n            cout << \"テゥツ慊?ィツヲツ?ゥツ?湘」ツ?ョテ・ツ青暗ィツィツ暗」ツ?ッ\" << calc_sum(r1, r2, c1, c2) << endl;\n            cout << \"num: \" << res.num << \" \" << \"demand: \" << res.demand << endl;\n        }\n        */\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define DP(a,b,c,d) ((dpn[a][b][c][d]<<16)+(dpm[a][b][c][d]))\nusing namespace std;\n\nint sum[32][32][33][33];\nint dpn[32][32][33][33];\nint dpm[32][32][33][33];\nint S;\n\nvoid dp(int X,int Y,int W,int H){\n\tint w,h;\n\tif(sum[X][Y][W][H]<S) return;\n\tdpn[X][Y][W][H] = 1;\n\tdpm[X][Y][W][H] = sum[X][Y][W][H]-S;\n//\tif(sum[X][Y][W][H]<2*S) return;\n\tfor(h=1;h<H;h++){\n\t\tif(dpn[X][Y][W][h] && dpn[X][Y+h][W][H-h])\n//\t\t\tprintf(\"dp(%d,%d,%d,%d) %d<%d+%d\\n\",X,Y,W,H,DP(X,Y,W,H), DP(X,Y,W,h), DP(X,Y+h,W,H-h));\n\t\t\tif(DP(X,Y,W,H) < DP(X,Y,W,h) + DP(X,Y+h,W,H-h) - max(dpm[X][Y][W][h],dpm[X][Y+h][W][H-h])){\n\t\t\t\tdpn[X][Y][W][H] = dpn[X][Y][W][h]+dpn[X][Y+h][W][H-h];\n\t\t\t\tdpm[X][Y][W][H] = min(dpm[X][Y][W][h],dpm[X][Y+h][W][H-h]);\n\t\t\t}\n\t}\n\tfor(w=1;w<W;w++){\n\t\tif(dpn[X][Y][w][H] && dpn[X+w][Y][W-w][H])\n//\t\t\tprintf(\"dp(%d,%d,%d,%d) %d<%d+%d\\n\",X,Y,W,H,DP(X,Y,W,H), DP(X,Y,w,H), DP(X+w,Y,W-w,H));\n\t\t\tif(DP(X,Y,W,H) < DP(X,Y,w,H) + DP(X+w,Y,W-w,H) - max(dpm[X][Y][w][H],dpm[X+w][Y][W-w][H])){\n\t\t\t\tdpn[X][Y][W][H] = dpn[X][Y][w][H]+dpn[X+w][Y][W-w][H];\n\t\t\t\tdpm[X][Y][W][H] = min(dpm[X][Y][w][H],dpm[X+w][Y][W-w][H]);\n\t\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,H,W,x,y,h,w,s;\n\twhile(cin>>H>>W>>s,H){\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tmemset(dpn, 0, sizeof(dpn));\n\t\tmemset(dpm, 0, sizeof(dpm));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t\tcin>>sum[j][i][1][1];\n\t\tfor(h=1;h<=H;h++)\n\t\t\tfor(w=1;w<=W;w++)\n\t\t\t\tfor(y=0;y<=H-h;y++)\n\t\t\t\t\tfor(x=0;x<=W-w;x++)\n\t\t\t\t\t\tif(w !=1)sum[x][y][w][h]=sum[x][y][w-1][h]+sum[x+w-1][y][1][h];\n\t\t\t\t\t\telse if(h!=1)sum[x][y][w][h]=sum[x][y][w][h-1]+sum[x][y+h-1][w][1];\n\t\tS=sum[0][0][W][H] - s;\n//\t\tcout<<\"S=\"<<S<<endl;\n\t\tfor(h=1;h<=H;h++)\n\t\t\tfor(w=1;w<=W;w++)\n\t\t\t\tfor(y=0;y<=H-h;y++)\n\t\t\t\t\tfor(x=0;x<=W-w;x++)\n\t\t\t\t\t\tdp(x,y,w,h);\n//\t\tfor(h=1;h<=H;h++)\n//\t\t\tfor(w=1;w<=W;w++)\n//\t\t\t\tfor(y=0;y<=H-h;y++)\n//\t\t\t\t\tfor(x=0;x<=W-w;x++)\n//\t\t\t\t\t\tprintf(\"(%d,%d) %d*%d = %d,%d,%d\\n\",x,y,w,h,sum[x][y][w][h],dpn[x][y][w][h],dpm[x][y][w][h]);\n\t\t\n\t\tcout<<dpn[0][0][W][H]<<' '<<dpm[0][0][W][H]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n\n#define REP(i, a, b) for(int i = int(a); i < int(b); i++)\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main() {\n    int h, w, s;\n    while (cin >> h >> w >> s, h + w + s) {\n\tvector<vector<int>> U(h, vector<int>(w));\n\tint sum = 0;\n\tREP (i, 0, h) {\n\t    REP (j, 0, w) {\n\t\tcin >> U[i][j];\n\t\tsum += U[i][j];\n\t    }\n\t}\n\tvector<vector<int>> vsum(h + 1, vector<int>(w + 1, 0));\n\tREP (i, 0, h) {\n\t    REP (j, 0, w) {\n\t\tvsum[i + 1][j + 1] += vsum[i + 1][j] + U[i][j];\n\t    }\n\t}\n\tREP (j, 0, w + 1) {\n\t    REP (i, 0, h) {\n\t\tvsum[i + 1][j] += vsum[i][j];\n\t    }\n\t}\n\t//const int inf = 1 << 29;\n\t\n\tvector<vector<vector<vector<pii>>>> dp(h, vector<vector<vector<pii>>>(w, vector<vector<pii>>(h, vector<pii>(w, {-1, -1}))));\n\tvector<vector<vector<vector<bool>>>> memo(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n\n\tfunction<bool(int,int,int,int)> rec = [&](int h1, int w1, int h2, int w2) -> bool{\n\t    if (h1 == h2 && w1 == w2) {\n\t\tdp[h1][w1][h2][w2] = make_pair(1, s - (sum - U[h1][w1]));\n\t\treturn (sum - U[h1][w1] <= s);\n\t    }\n\t    if (dp[h1][w1][h2][w2].first != -1) return memo[h1][w1][h2][w2];\n\t    int tmp = vsum[h2 + 1][w2 + 1] - vsum[h2 + 1][w1] - vsum[h1][w2 + 1] + vsum[h1][w1];\n\t    bool ok = (sum - tmp <= s);\n\t    pii ans(1, s - (sum - tmp));\n\t    REP (i, h1, h2){\n\t\tbool res1 = rec(h1, w1, i, w2);\n\t\tbool res2 = rec(i + 1, w1, h2, w2);\n\t\tif (res1 && res2){\n\t\t    ok = true;\n\t\t    pii div1 = dp[h1][w1][i][w2];\n\t\t    pii div2 = dp[i + 1][w1][h2][w2];\n\t\t    if (ans.first < div1.first + div2.first) {\n\t\t\tans.first = div1.first + div2.first;\n\t\t\tans.second = min(div1.second, div2.second);\n\t\t    } else if (ans.first == div1.first + div2.first) {\n\t\t\tans.second = max(ans.second, min(div1.second, div2.second));\n\t\t    }\n\t\t}\n\t    }\n\t    REP (i, w1, w2) {\n\t\tbool res1 = rec(h1, w1, h2, i);\n\t\tbool res2 = rec(h1, i + 1, h2, w2);\n\t\tif (res1 && res2){\n\t\t    ok = true;\n\t\t    pii div1 = dp[h1][w1][h2][i];\n\t\t    pii div2 = dp[h1][i + 1][h2][w2];\n\t\t    if (ans.first < div1.first + div2.first) {\n\t\t\tans.first = div1.first + div2.first;\n\t\t\tans.second = min(div1.second, div2.second);\n\t\t    }else if (ans.first == div1.first + div2.first) {\n\t\t\tans.second = max(ans.second, min(div1.second, div2.second));  \n\t\t    }\n\t\t}\n\t    }\n\t    memo[h1][w1][h2][w2] = ok;\n\t    dp[h1][w1][h2][w2] = ans;\n\t    return ok;\n\t};\n\t\n\trec(0, 0, h - 1, w - 1);\n\tpii ans = dp[0][0][h - 1][w - 1];\n\tcout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint h,w,s;\nint u[33][33];\n\nint sum[33][33];\nint U;\n\npi dp[33][33][33][33];\n\nvoid init()\n{\n    memset(sum,0,sizeof(sum));\n    U=0;\n    rep(i,33)rep(j,33)rep(k,33)rep(l,33) dp[i][j][k][l]=pi(-1,-1);\n\n}\n\ninline int SUM(int lx, int ly, int rx, int ry)\n{\n    return sum[ry][rx] - sum[ly-1][rx] - sum[ry][lx-1] + sum[ly-1][rx-1];\n}\n\npi dfs(int lx, int ly, int rx, int ry)\n{\n    if(dp[lx][ly][rx][ry].fi>=0) return dp[lx][ly][rx][ry];\n\n    pi ret(1,s-U+SUM(lx,ly,rx,ry));\n\n    // ????????????\n    for(int i=lx; i<rx; ++i)\n    {\n        if(U-SUM(lx,ly,i,ry)<=s && U-SUM(i+1,ly,rx,ry)<=s)\n        {\n            pi A = dfs(lx,ly,i,ry), B = dfs(i+1,ly,rx,ry);\n            ret = max(ret, pi(A.fi+B.fi, min(A.se,B.se)));\n        }\n    }\n\n    // ?¨??????????\n    for(int i=ly; i<ry; ++i)\n    {\n        if(U-SUM(lx,ly,rx,i)<=s && U-SUM(lx,i+1,rx,ry)<=s)\n        {\n            pi A = dfs(lx,ly,rx,i), B = dfs(lx,i+1,rx,ry);\n            ret = max(ret, pi(A.fi+B.fi, min(A.se,B.se)));\n        }\n    }\n\n    return dp[lx][ly][rx][ry] = ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d %d\", &h, &w, &s),h)\n    {\n        init();\n\n        rep(i,h)rep(j,w)\n        {\n            scanf(\" %d\", &u[i+1][j+1]);\n            U+=u[i+1][j+1];\n        }\n\n        sum[1][1]=u[1][1];\n        for(int i=2; i<=w; ++i) sum[1][i] = sum[1][i-1]+u[1][i];\n        for(int i=2; i<=h; ++i) sum[i][1] = sum[i-1][1]+u[i][1];\n        for(int i=2; i<=h; ++i)for(int j=2; j<=w; ++j) sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + u[i][j];\n\n        pi a = dfs(1,1,w,h);\n        printf(\"%d %d\\n\", a.fi, a.se);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\npii dp[32][32][32][32];\nsigned main() {\n    while (1) {\n        REP(i, 32) REP(j, 32) REP(k, 32) REP(l, 32) dp[i][j][k][l] = {INF, INF};\n\n        int h, w, s;\n        cin >> h >> w >> s;\n        vector<vector<int>> u(h, vector<int>(w));\n        cin >> u;\n\n        int S = 0;\n        FORE(r, u) FORE(c, r) S += c;\n        int mn = S - s;\n\n        auto rec = [&](auto f, int y1, int x1, int y2, int x2) -> pii {\n            auto &MEMO = dp[y1][x1][y2][x2];\n            if (MEMO.first != INF) return MEMO;\n\n            int ps = 0;\n            REPF(x, x1, x2) {\n                REPF(y, y1, y2) {\n                    ps += u[y][x];\n                }\n            }\n\n            pii ret = {1, ps};\n            REPF(x, x1 + 1, x2) {\n                pii a = f(f, y1, x1, y2, x);\n                pii b = f(f, y1, x, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            REPF(y, y1 + 1, y2) {\n                pii a = f(f, y1, x1, y, x2);\n                pii b = f(f, y, x1, y2, x2);\n                if (a.second < mn || b.second < mn) continue;\n                chmax(ret, pii{a.first + b.first, min(a.second, b.second)});\n            }\n            return MEMO = ret;\n        };\n\n        auto ans = rec(rec, 0, 0, h, w);\n        cout << ans.first << \" \" << s - (S - ans.second) << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State { int cnt, marg; };\nbool operator>(const State& a, const State& b) {\n    return tie(a.cnt, a.marg) > tie(b.cnt, b.marg);\n}\n\nint h, w;\n\nint area(int hi, int hl, int wi, int wl, vector<vector<int>>& S) {\n    if (hi > 0 && wi > 0) {\n        return S[hi+hl-1][wi+wl-1] - S[hi+hl-1][wi-1] - S[hi-1][wi+wl-1] + S[hi-1][wi-1];\n    }\n    if (hi > 0) {\n        return S[hi+hl-1][wi+wl-1] - S[hi-1][wi+wl-1];\n    }\n    if (wi > 0) {\n        return S[hi+hl-1][wi+wl-1] - S[hi+hl-1][wi-1];\n    }\n    return S[hi+hl-1][wi+wl-1];\n}\n\nconst int INF = 1<<29;\nState dp[33][33][33][33];\n\nint main()\n{\n    while (1) {\n        fill(dp[0][0][0], dp[32][32][32]+33, State{ 0, 0 });\n        int s; cin >> h >> w >> s;\n        if (!h) break;\n\n        vector<vector<int>> U(h, vector<int>(w));\n        loop (h, i) loop (w, j) cin >> U[i][j];\n        vector<vector<int>> S = U;\n        loop (h, i) loop (w-1, j) S[i][j+1] += S[i][j];\n        loop (w, j) loop (h-1, i) S[i+1][j] += S[i][j];\n        int sum = S[h-1][w-1];\n\n        for (int hl = 1; hl <= h; hl++) for (int wl = 1; wl <= w; wl++)\n        loop (h, hi) loop (w, wi) {\n            if (hi + hl > h || wi + wl > w) continue;\n\n            State crr;\n            int marg = s - (sum - area(hi, hl, wi, wl, S));\n            if (marg >= 0) crr = { 1, marg };\n            else crr = { 0, 0 };\n\n            for (int i = 1; hi + i < h && hl - i > 0; i++) {\n                auto a = dp[hi][i][wi][wl];\n                auto b = dp[hi+i][hl-i][wi][wl];\n                auto s = State{ a.cnt + b.cnt, min(a.marg, b.marg) };\n                if (s > crr) crr = s;\n            }\n            for (int i = 1; wi + i < w && wl - i > 0; i++) {\n                auto a = dp[hi][hl][wi][i];\n                auto b = dp[hi][hl][wi+i][wl-i];\n                auto s = State{ a.cnt + b.cnt, min(a.marg, b.marg) };\n                if (s > crr) crr = s;\n            }\n            dp[hi][hl][wi][wl] = crr;\n        }\n\n        auto ans = dp[0][h][0][w];\n        cout << ans.cnt << \" \" << ans.marg << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int MAX_HW = 32;\nint h, w, s;\nint cost[MAX_HW][MAX_HW][MAX_HW][MAX_HW];\npair<int, int> dp[MAX_HW][MAX_HW][MAX_HW][MAX_HW];\n\npair<int, int> solve(int x1, int y1, int x2, int y2, const int sum)\n{\n  if (dp[y1][x1][y2][x2].first != -1)\n    return dp[y1][x1][y2][x2];\n\n  pair<int, int> res(1, s-sum+cost[y1][x1][y2][x2]);\n  for (int x = x1; x < x2; ++x) {\n    if (cost[y1][x1][y2][x] < sum-s || cost[y1][x+1][y2][x2] < sum-s)\n      continue;\n    pair<int, int> g1 = solve(x1, y1, x, y2, sum);\n    pair<int, int> g2 = solve(x+1, y1, x2, y2, sum);\n    if (res.first < g1.first+g2.first) {\n      res.first = g1.first+g2.first;\n      res.second = min(g1.second, g2.second);\n    } else if (res.first == g1.first+g2.first) {\n      res.second = max(res.second, min(g1.second, g2.second));\n    }\n  }\n\n  for (int y = y1; y < y2; ++y) {\n    if (cost[y1][x1][y][x2] < sum-s || cost[y+1][x1][y2][x2] < sum-s)\n      continue;\n    pair<int, int> g1 = solve(x1, y1, x2, y, sum);\n    pair<int, int> g2 = solve(x1, y+1, x2, y2, sum);\n    if (res.first < g1.first+g2.first) {\n      res.first = g1.first+g2.first;\n      res.second = min(g1.second, g2.second);\n    } else if (res.first == g1.first+g2.first) {\n      res.second = max(res.second, min(g1.second, g2.second));\n    }\n  }\n  return dp[y1][x1][y2][x2] = res;\n}\n\nint main()\n{\n  while (scanf(\"%d %d %d\", &h, &w, &s)) {\n    if ((h|w|s) == 0)\n      break;\n\n    int sum = 0;\n    vector<vector<int> > u(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n\tscanf(\"%d\", &u[i][j]);\n\tsum += u[i][j];\n      }\n    }\n\n    memset(cost, 0, sizeof(cost));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n\tfor (int y = i; y < h; ++y) {\n\t  for (int x = j; x < w; ++x)\n\t    cost[i][j][y][x] = u[y][x];\n\t}\n      }\n    }\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n\t// hor\n\tfor (int y = i; y < h; ++y) {\n\t  for (int x = j+1; x < w; ++x)\n\t    cost[i][j][y][x] += cost[i][j][y][x-1];\n\t}\n\t// ver\n\tfor (int x = j; x < w; ++x) {\n\t  for (int y = i+1; y < h; ++y)\n\t    cost[i][j][y][x] += cost[i][j][y-1][x];\n\t}\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    pair<int, int> ans = solve(0, 0, w-1, h-1, sum);\n    printf(\"%d %d\\n\", ans.first, ans.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\n#define MAX_HW 32\n\nusing namespace std;\n\nint H, W, S;\nint usum;\nint u[MAX_HW][MAX_HW];\n\ntypedef pair<int, int> P;// ??°???????????°???????????????\nP dp[MAX_HW+1][MAX_HW+1][MAX_HW+1][MAX_HW+1];\nP unknown = P(-1,-1);\n\nint calc_sum(int x1, int y1, int x2, int y2){\n\tint res = 0;\n\tfor (int i = y1; i < y2; i++)\n\t{\n\t\tfor (int j = x1; j < x2; j++)\n\t\t{\n\t\t\tres += u[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nP dfs(int sx, int sy, int ex, int ey){\n\tif(dp[sy][sx][ey][ex] != unknown) return dp[sy][sx][ey][ex];\n\tP res;\n\tres.first = 1;\n\tres.second = S-(usum - calc_sum(sx, sy, ex, ey));\n\tfor (int i = sx+1; i < ex; i++)\n\t{\n\t\tif((usum - calc_sum(sx, sy, i, ey) <= S) && (usum - calc_sum(i, sy, ex, ey) <= S)){\n\t\t\tP r1 = dfs(sx, sy, i, ey);\n\t\t\tP r2 = dfs(i, sy, ex, ey);\n\t\t\tif(res.first < r1.first + r2.first){\n\t\t\t\tres.first = r1.first + r2.first;\n\t\t\t\tres.second = min(r1.second, r2.second);\n\t\t\t}else if(res.first == r1.first + r2.first && res.second < min(r1.second, r2.second)){\n\t\t\t\tres.second = min(r1.second, r2.second);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = sy+1; i < ey; i++)\n\t{\n\t\tif((usum - calc_sum(sx, sy, ex, i) <= S) && (usum - calc_sum(sx, i, ex, ey) <= S)){\n\t\t\tP r1 = dfs(sx, sy, ex, i);\n\t\t\tP r2 = dfs(sx, i, ex, ey);\n\t\t\tif(res.first < r1.first + r2.first){\n\t\t\t\tres.first = r1.first + r2.first;\n\t\t\t\tres.second = min(r1.second, r2.second);\n\t\t\t}else if(res.first == r1.first + r2.first && res.second < min(r1.second, r2.second)){\n\t\t\t\tres.second = min(r1.second, r2.second);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[sy][sx][ey][ex] = res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> H >> W >> S;\n\t\tif(H == 0) break;\n\t\tusum = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tcin >> u[i][j];\n\t\t\t\tusum += u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= H; i++)\n\t\t{\n\t\t\tfor (int k = i; k <= H; k++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= W; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = j; l <= W; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k][l] = unknown;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tP ans = dfs(0, 0, W, H);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\nint h,w,s;\nint map[32][32];\nint all;\npair<int,int> memo[32][32][33][33];\n\npair<int,int> rec(int y1,int x1,int y2,int x2,int sum){\n  pair<int,int> res,hoge1,hoge2;\n  int a=1,b=0;\n  int tmp;\n  bool flag = false;\n\n  if(memo[y1][x1][y2][x2].first>=0)return memo[y1][x1][y2][x2];\n\n  tmp = 0;\n  for(int i=x1+1;i<x2;i++){\n\n    for(int j=y1;j<y2;j++)tmp += map[j][i-1];\n\n    if( all-tmp <= s && all-(sum-tmp) <= s){\n      flag = true;\n      hoge1 = rec(y1,x1,y2,i,tmp);\n      hoge2 = rec(y1,i,y2,x2,sum-tmp);\n      if(hoge1.first+hoge2.first > a){\n\ta = hoge1.first + hoge2.first;\n\tb = max(hoge1.second,hoge2.second);\n      }else if(hoge1.first + hoge2.first == a && max(hoge1.second,hoge2.second) < b){\n\tb = max(hoge1.second,hoge2.second);\n      }\n    }\n    if(all-(sum-tmp) >s)break;\n  }\n\n  tmp = 0;\n  for(int i=y1+1;i<y2;i++){\n\n    for(int j=x1;j<x2;j++)tmp += map[i-1][j];\n\n    if( all-tmp <= s && all-(sum-tmp) <= s){\n      flag = true;\n      hoge1 = rec(y1,x1,i,x2,tmp);\n      hoge2 = rec(i,x1,y2,x2,sum-tmp);\n      if(hoge1.first+hoge2.first > a){\n\ta = hoge1.first + hoge2.first;\n\tb = max(hoge1.second,hoge2.second);\n      }else if(hoge1.first + hoge2.first == a && max(hoge1.second,hoge2.second) < b){\n\tb = max(hoge1.second,hoge2.second);\n      }\n    }\n    if(all-(sum-tmp) >s)break;\n  }\n\n  if(!flag){\n    res.first = 1;\n    res.second = all - sum;\n  }else{\n    res.first = a;\n    res.second = b;\n  }\n  memo[y1][x1][y2][x2] = res;\n  return res;\n}\n\n\nint main(){\n  pair<int,int> ans;\n  while(1){\n    cin >> h >> w >> s;\n    if(!h && !w && !s)break;\n\n    all = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> map[i][j];\n\tall += map[i][j];\n      }\n    }\n \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<=h;k++){\n\t  for(int l=0;l<=w;l++){\n\t    memo[i][j][k][l].first = -1;\n\t    memo[i][j][k][l].second = -1;\n\t  }\n\t}\n      }\n    }\n\n    ans = rec(0,0,h,w,all);\n    cout << ans.first << \" \" << s - ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint H, W, S;\nint board[40][40];\npair<int, int> memo[40][40][40][40];\nint dp[40][40];\nint sum;\n\nvoid makeDP() {\n    for (int i = 0; i < 40; i++) {\n        for (int j = 0; j < 40; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + board[i][j];\n        }\n    }\n}\n\nint sumRec(int lx, int ly, int hx, int hy) {\n    return dp[hy][hx] - dp[hy][lx-1] - dp[ly-1][hx] + dp[ly-1][lx-1];\n}\n\n// first:グループ数 second:予備力\npair<int, int> dfs(int lx, int ly, int hx, int hy) {\n    if (memo[lx][ly][hx][hy].first >= 0) return memo[lx][ly][hx][hy];\n    pair<int, int> ans = make_pair(1, S - (sum - sumRec(lx, ly, hx, hy)));\n    // 横に分ける\n    for (int y = ly; y < hy; y++) {\n        if (sum - sumRec(lx, ly, hx, y) > S) continue;\n        if (sum - sumRec(lx, y+1, hx, hy) > S) continue;\n        auto a = dfs(lx, ly, hx, y);\n        auto b = dfs(lx, y+1, hx, hy);\n        ans = max(ans, make_pair(a.first+b.first, min(a.second, b.second)));\n    }\n    // 縦に分ける\n    for (int x = lx; x < hx; x++) {\n        if (sum - sumRec(lx, ly, x, hy) > S) continue;\n        if (sum - sumRec(x+1, ly, hx, hy) > S) continue;\n        auto a = dfs(lx, ly, x, hy);\n        auto b = dfs(x+1, ly, hx, hy);\n        ans = max(ans, make_pair(a.first+b.first, min(a.second, b.second)));\n    }\n    return memo[lx][ly][hx][hy] = ans;\n}\n\nint main(void) {\n    while (cin >> H >> W >> S) {\n        if (H == 0 && W == 0 && S == 0) break;\n        sum = 0;\n        for (int h = 1; h <= H; h++) {\n            for (int w = 1; w <= W; w++) {\n                cin >> board[h][w];\n                sum += board[h][w];\n            }\n        }\n        for (int i = 0; i < 40; i++) {\n            for (int j = 0; j < 40; j++) {\n                for (int k = 0; k < 40; k++) {\n                    for (int l = 0; l < 40; l++) memo[i][j][k][l] = make_pair(-1, -1);\n                }\n            }\n        }\n        makeDP();\n        auto ans = dfs(1, 1, W, H);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 100000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint memo1[33][33][33][33], memo2[33][33][33][33];\n\nint h, w, s;\nint u[33][33];\nint sum[33][33];\n\nP solve(int h1, int h2, int w1, int w2){\n\tif(memo1[h1][h2][w1][w2]!=0){\n\t\treturn P(memo1[h1][h2][w1][w2], memo2[h1][h2][w1][w2]);\n\t}\n\tif(sum[h2][w2]-sum[h1-1][w2]-sum[h2][w1-1]+sum[h1-1][w1-1]<s){\n\t\treturn P(-INF, -INF);\n\t}\n\tmemo1[h1][h2][w1][w2]=1;\n\tmemo2[h1][h2][w1][w2]=sum[h2][w2]-sum[h1-1][w2]-sum[h2][w1-1]+sum[h1-1][w1-1]-s;\n\tfor(int i=h1; i<h2; i++){\n\t\tP p1=solve(h1, i, w1, w2), p2=solve(i+1, h2, w1, w2);\n\t\tif(memo1[h1][h2][w1][w2]<p1.first+p2.first){\n\t\t\tmemo1[h1][h2][w1][w2]=p1.first+p2.first;\n\t\t\tmemo2[h1][h2][w1][w2]=min(p1.second, p2.second);\n\t\t}else if(memo1[h1][h2][w1][w2]==p1.first+p2.first){\n\t\t\tmemo2[h1][h2][w1][w2]=max(memo2[h1][h2][w1][w2], min(p1.second, p2.second));\n\t\t}\n\t}\n\tfor(int j=w1; j<w2; j++){\n\t\tP p1=solve(h1, h2, w1, j), p2=solve(h1, h2, j+1, w2);\n\t\tif(memo1[h1][h2][w1][w2]<p1.first+p2.first){\n\t\t\tmemo1[h1][h2][w1][w2]=p1.first+p2.first;\n\t\t\tmemo2[h1][h2][w1][w2]=min(p1.second, p2.second);\n\t\t}else if(memo1[h1][h2][w1][w2]==p1.first+p2.first){\n\t\t\tmemo2[h1][h2][w1][w2]=max(memo2[h1][h2][w1][w2], min(p1.second, p2.second));\n\t\t}\n\t}\n\treturn P(memo1[h1][h2][w1][w2], memo2[h1][h2][w1][w2]);\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin>>h>>w>>s;\n\t\tif(h==0 && w==0 && s==0) return 0;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin>>u[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=h; i++){\n\t\t\tfor(int j=0; j<=w; j++){\n\t\t\t\tif(i==0 || j==0){\n\t\t\t\t\tsum[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+u[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts=sum[h][w]-s;\n\t\tfor(int i=0; i<=h; i++){\n\t\t\tfor(int j=i; j<=h; j++){\n\t\t\t\tfor(int k=0; k<=w; k++){\n\t\t\t\t\tfor(int l=k; l<=w; l++){\n\t\t\t\t\t\tmemo1[i][j][k][l]=0, memo2[i][j][k][l]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tP p=solve(1, h, 1, w);\n\t\tcout<<p.first<<\" \"<<p.second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_HW = 35;\n\n\nint H, W, S, v[MAX_HW][MAX_HW], E[MAX_HW][MAX_HW];\nP dp[MAX_HW][MAX_HW][MAX_HW][MAX_HW];\n\nint calc(int Y1, int X1, int Y2, int X2){\n  int ret = E[Y2][X2];\n  if(X1 - 1 >= 0) ret -= E[Y2][X1 - 1];\n  if(Y1 - 1 >= 0) ret -= E[Y1 - 1][X2];\n  if(X1 - 1 >= 0 && Y1 - 1 >= 0) ret += E[Y1 - 1][X1 - 1];\n  return ret;\n}\n\nP dfs(int Y1, int X1, int Y2, int X2){\n  if(dp[Y1][X1][Y2][X2] != P(-1, -1)) return dp[Y1][X1][Y2][X2];\n  P ret = P(1, calc(Y1, X1, Y2, X2));\n  FOR(y, Y1, Y2 + 1){\n    int a = calc(Y1, X1, y, X2), b = calc(y + 1, X1, Y2, X2);\n    if(E[H - 1][W - 1] - a > S || E[H - 1][W - 1] - b > S) continue;\n    P aa = dfs(Y1, X1, y, X2), bb = dfs(y + 1, X1, Y2, X2);\n    ret = max(ret, P(aa.first + bb.first, min(aa.second, bb.second)));\n  }\n  FOR(x, X1, X2 + 1){\n    int a = calc(Y1, X1, Y2, x), b = calc(Y1, x + 1, Y2, X2);\n    if(E[H - 1][W - 1] - a > S || E[H - 1][W - 1] - b > S) continue;\n    P aa = dfs(Y1, X1, Y2, x), bb = dfs(Y1, x + 1, Y2, X2);\n    ret = max(ret, P(aa.first + bb.first, min(aa.second, bb.second)));\n  }\n  return dp[Y1][X1][Y2][X2] = ret;\n}\n\nint main() {\n  while(cin >>H >>W >>S && H){\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    memset(E, 0, sizeof(E));\n    E[0][0] = v[0][0];\n    FOR(i, 1, H) E[i][0] = E[i - 1][0] + v[i][0];\n    FOR(i, 1, W) E[0][i] = E[0][i - 1] + v[0][i];\n    FOR(y, 1, H)\n      FOR(x, 1, W)\n      E[y][x] = v[y][x] + E[y - 1][x] + E[y][x - 1] - E[y - 1][x - 1];\n    REP(i, MAX_HW) REP(j, MAX_HW) REP(k, MAX_HW) REP(l, MAX_HW) dp[i][j][k][l] = P(-1, -1);\n    P ans = dfs(0, 0, H - 1, W - 1);\n    cout <<ans.first <<\" \" <<(S - E[H - 1][W - 1] + ans.second) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nauto chmax = [](auto&& l, auto r) { return l < r ? l = r, 1 : 0; };\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int h, w, s;\n  while (cin >> h >> w >> s, h) {\n    vector<vector<int>> c(h + 1, vector<int>(w + 1));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> c[i][j];\n      }\n    }\n    for (int i = 0; i < h; ++i) {\n      for (int j = w; j--; ) {\n        c[i][j] += c[i][j + 1];\n      }\n    }\n    for (int j = 0; j < w; ++j) {\n      for (int i = h; i--; ) {\n        c[i][j] += c[i + 1][j];\n      }\n    }\n    s = c[0][0] - s;\n    auto f = [](int x) {\n      return x * (x - 1) / 2;\n    };\n    auto $ = [&](int li, int ri, int lj, int rj) {\n      return (li + f(ri)) * f(w + 1) + (lj + f(rj));\n    };\n    auto sum = [&](int li, int ri, int lj, int rj) {\n      return c[li][lj] - c[li][rj] - c[ri][lj] + c[ri][rj];\n    };\n    vector<pair<int, int>> dp(f(h + 1) * f(w + 1));\n    for (int li = h; li--; ) {\n      for (int ri = li + 1; ri <= h; ++ri) {\n        for (int lj = w; lj--; ) {\n          for (int rj = lj + 1; rj <= w; ++rj) {\n            if (sum(li, ri, lj, rj) >= s) {\n              dp[$(li, ri, lj, rj)] = {1, sum(li, ri, lj, rj) - s};\n            }\n            for (int mi = li + 1; mi < ri; ++mi) {\n              auto p = dp[$(li, mi, lj, rj)], q = dp[$(mi, ri, lj, rj)];\n              chmax(dp[$(li, ri, lj, rj)], make_pair(p.first + q.first, min(p.second, q.second)));\n            }\n            for (int mj = lj + 1; mj < rj; ++mj) {\n              auto p = dp[$(li, ri, lj, mj)], q = dp[$(li, ri, mj, rj)];\n              chmax(dp[$(li, ri, lj, rj)], make_pair(p.first + q.first, min(p.second, q.second)));\n            }\n          }\n        }\n      }\n    }\n    int x, y;\n    tie(x, y) = dp[$(0, h, 0, w)];\n    cout << x << ' ' << y << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nint area_demand(const std::vector<std::vector<int>>& state, const int left, const int right, const int bottom, const int top) {\n\treturn state[top][right] - state[top][left - 1] - state[bottom - 1][right] + state[bottom - 1][left - 1];\n}\nstd::pair<int, int> cal_max(std::vector<std::vector<int>>& state, const int min_limit, const int left, const int right, const int bottom, const int top, std::vector<std::vector<std::vector<std::vector<std::pair<int, int>>>>> &memo) {\n\tif (memo[left][right - left][bottom][top - bottom].first > 0) return memo[left][right - left][bottom][top - bottom];\n\tint max_count = 1;\n\tint min_demand = area_demand(state, left, right, bottom, top);\n\tfor (auto v = left; v < right; ++v) if (area_demand(state, left, v, bottom, top) >= min_limit && area_demand(state, v + 1, right, bottom, top) >= min_limit) {\n\t\tauto l = cal_max(state, min_limit, left, v, bottom, top, memo);\n\t\tauto r = cal_max(state, min_limit, v + 1, right, bottom, top, memo);\n\t\tif (l.first + r.first > max_count) {\n\t\t\tmax_count = l.first + r.first;\n\t\t\tmin_demand = std::min(l.second, r.second);\n\t\t}\n\t\telse if (l.first + r.first == max_count) {\n\t\t\tmin_demand = std::max(min_demand, std::min(l.second, r.second));\n\t\t}\n\t}\n\tfor (auto h = bottom; h < top; ++h) if (area_demand(state, left, right, bottom, h) >= min_limit && area_demand(state, left, right, h + 1, top) >= min_limit) {\n\t\tauto b = cal_max(state, min_limit, left, right, bottom, h, memo);\n\t\tauto t = cal_max(state, min_limit, left, right, h + 1, top, memo);\n\t\tif (b.first + t.first > max_count) {\n\t\t\tmax_count = b.first + t.first;\n\t\t\tmin_demand = std::min(b.second, t.second);\n\t\t}\n\t\telse if (b.first + t.first == max_count) {\n\t\t\tmin_demand = std::max(min_demand, std::min(b.second, t.second));\n\t\t}\n\t}\n\treturn memo[left][right - left][bottom][top - bottom] = std::make_pair(max_count, min_demand);\n}\nint main(){\n\tstd::vector<std::vector<std::vector<std::vector<std::pair<int, int>>>>> memo(33, std::vector<std::vector<std::vector<std::pair<int, int>>>>(33, std::vector<std::vector<std::pair<int, int>>>(33, std::vector<std::pair<int, int>>(33))));\n\twhile (true) {\n\t\tint h, w, s; std::cin >> h >> w >> s; if (h == 0) break;\n\t\tstd::vector<std::vector<int>> state(h + 1, std::vector<int>(w + 1, 0));\n\t\tfor (auto i = 1; i <= h; ++i) for (auto j = 1; j <= w; ++j) {\n\t\t\tstd::cin >> state[i][j];\n\t\t\tstate[i][j] += state[i - 1][j] + state[i][j - 1] - state[i - 1][j - 1];\n\t\t}\n\t\tfor (auto left = 1; left <= w; ++left) {\n\t\t\tfor (auto right = left; right <= w; ++right) {\n\t\t\t\tfor (auto bottom = 1; bottom <= h; ++bottom) {\n\t\t\t\t\tstd::fill(memo[left][right - left][bottom].begin(), memo[left][right - left][bottom].end(), std::make_pair(0, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto res = cal_max(state, state.back().back() - s, 1, w, 1, h, memo);\n\t\tstd::cout << res.first << ' ' << s + res.second - state.back().back() << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*\nint pr[100010];\n//int inv[100010];\n*/ \nint beki(int wa,int rr,int warukazu){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa%warukazu;\n\tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n\tint zx=beki(wa,rr/2,warukazu);\n\treturn (zx*zx)%warukazu;\n}\n  /*\nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint a[35][35];\nint r[35][35]={0};\n\nint souwa(int ax,int ay,int bx,int by){\n\treturn r[bx][by]-r[ax-1][by]-r[bx][ay-1]+r[ax-1][ay-1];\n}\n\nint d;\n\npa memo[35][35][35][35];\n\npa saiki(int ax,int ay,int bx,int by){\n\tif(memo[ax][ay][bx][by].first>=0) return memo[ax][ay][bx][by];\n\tpa z=mp(-inf,-inf),z1,z2,zz;\n\tfor(int i=ax;i<bx;i++){\n\t\tz1=saiki(ax,ay,i,by),z2=saiki(i+1,ay,bx,by);\n\t\tzz=mp(z1.first+z2.first,min(z1.second,z2.second));\n\t\tz=max(z,zz);\n\t\t\n\t}\n\tfor(int j=ay;j<by;j++){\n\t\t\t\tz1=saiki(ax,ay,bx,j),z2=saiki(ax,j+1,bx,by);\n\t\tzz=mp(z1.first+z2.first,min(z1.second,z2.second));\n\t\tz=max(z,zz);\n\t}\n\tif(souwa(ax,ay,bx,by)>=d) if(z<mp(1ll,(souwa(ax,ay,bx,by)-d)))z=mp(1ll,(souwa(ax,ay,bx,by)-d));\n//\tif(ax==2 && ay==1)cout<<ax<<\" \"<<ay<<\" \"<<bx<<\" \"<<by<<\" \"<<z.first<<\" \"<<z.second<<endl;\n\tmemo[ax][ay][bx][by]=z;\n\treturn z;\n}\n\n\nsigned main(){\n\tint h,w,s;\n\tcin>>h>>w>>s;\n\tint sum=0;\n\t\n\t\n\tfor(int i=0;i<35;i++)for(int i2=0;i2<35;i2++)for(int i3=0;i3<35;i3++)for(int i4=0;i4<35;i4++){\n\t\tmemo[i][i3][i2][i4]=mp(-1,9);\n\t}\n\t\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tcin>>a[i][j];\n\t\tsum += a[i][j];\n\t\tr[i][j]=r[i-1][j]+r[i][j-1]+a[i][j]-r[i-1][j-1];\n\t}\n\t d=sum-s;\n\t\n\tpa z=saiki(1,1,h,w);\n\t\n\tcout<<z.first<<\" \"<<z.second<<endl;\n\t \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W, S;\nint U[34][34];\nint V[34][34];\n\nint M_gr[34][34][34][34];\nint M_ep[34][34][34][34];\n\nint ans_gr, ans_ep;\n\nint R;\n\nint sum_area(int si, int sj, int ei, int ej) {\n    --si; --sj;\n    return V[ei][ej] - V[si][ej] - V[ei][sj] + V[si][sj];\n}\n\nbool f(int si, int sj, int ei, int ej, int& gr, int& ep) {\n    if (M_gr[si][sj][ei][ej] == -2) {\n        return false;\n    } else if (M_gr[si][sj][ei][ej] != -1) {\n        gr = M_gr[si][sj][ei][ej];\n        ep = M_ep[si][sj][ei][ej];\n        return true;\n    }\n\n    int g, p;\n    g = p = -1;\n    for (int i = si; i < ei; i++) {\n        int g1, g2, p1, p2;\n        bool ok1, ok2;\n        ok1 = f(si   , sj, i , ej, g1, p1);\n        ok2 = f(i + 1, sj, ei, ej, g2, p2);\n        if ((ok1 && ok2)\n                && ((g1 + g2 == g && p < min(p1, p2))\n                    || (g1 + g2 > g))) {\n            g = g1 + g2;\n            p = min(p1, p2);\n        }\n    }\n\n    for (int j = sj; j < ej; j++) {\n        int g1, g2, p1, p2;\n        bool ok1, ok2;\n        ok1 = f(si, sj   , ei, j , g1, p1);\n        ok2 = f(si, j + 1, ei, ej, g2, p2);\n        if ((ok1 && ok2)\n                && ((g1 + g2 == g && p < min(p1, p2))\n                    || (g1 + g2 > g))) {\n            g = g1 + g2;\n            p = min(p1, p2);\n        }\n    }\n\n    if (g != -1 && p != -1) {\n        gr = g; ep = p;\n        M_gr[si][sj][ei][ej] = g;\n        M_ep[si][sj][ei][ej] = p;\n        return true;\n    }\n\n    int s = sum_area(si, sj, ei, ej);\n    if (s >= R) { // sufficient\n        gr = 1; ep = s - R;\n        M_gr[si][sj][ei][ej] = 1;\n        M_ep[si][sj][ei][ej] = s - R;\n        return true;\n    }\n\n    M_gr[si][sj][ei][ej] = M_ep[si][sj][ei][ej] = -2;\n    return false;\n}\n\nvoid solve() {\n    for (int i = 0; i < 34; i++) {\n        for (int j = 0; j < 34; j++) {\n            for (int k = 0; k < 34; k++) {\n                for (int l = 0; l < 34; l++) {\n                    M_gr[i][j][k][l] = M_ep[i][j][k][l] = -1;\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i < 34; i++) {\n        for (int j = 1; j < 34; j++) {\n            V[i][j] = V[i][j - 1] + U[i][j];\n        }\n    }\n    for (int j = 1; j < 34; j++) {\n        for (int i = 1; i < 34; i++) {\n            V[i][j] += V[i - 1][j];\n        }\n    }\n    R = sum_area(1, 1, H, W) - S;\n    f(1, 1, H, W, ans_gr, ans_ep);\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &H, &W, &S);\n        if (!H && !W && !S) { break;}\n        for (int i = 0; i < 34; i++) {\n            for (int j = 0; j < 34; j++) {\n                U[i][j] = V[i][j] = 0;\n            }\n        }\n        for (int i = 1; i <= H; i++) {\n            for (int j = 1; j <= W; j++) {\n                scanf(\"%d\", &U[i][j]);\n            }\n        }\n        solve();\n        printf(\"%d %d\\n\", ans_gr, ans_ep);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, S;\nvector< vector<int> > A;\nbool m1[40][40][40][40];\nP m2[40][40][40][40];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, S-(getM(0, 0, W, H) - getM(x1, y1, x2, y2)));\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tif (a1.first < 0 || a2.first < 0) continue;\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tif (a1.first < 0 || a2.first < 0) continue;\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> S, H || W || S) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[0][0][0]+40*40*40*40, false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h,w,s,all;\nint u[35][35] = {0};\nint f[35][35] = {0};\n// ツδ?δつ可サ, DP\nP dp[35][35][35][35];\n\n// [x1,x2] && [y1,y2] ツづ個療個暗ヲツづ個堕債和ツづーツ計ツ算ツつキツづゥ.\nint sum(int x1, int y1, int x2, int y2){\n\tx2++; y2++;\n\treturn f[y2-1][x2-1] - f[y2-1][x1-1] - f[y1-1][x2-1] + f[y1-1][x1-1];\n}\n\n// ツ渉可甘コツ可サ.\nvoid init(){\n\tfor(int i=0 ; i < 35 ; i++ ){\n\t\tfor(int j=0 ; j < 35 ; j++ ){\n\t\t\tfor(int k=0 ; k < 35 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 35 ; l++ ){\n\t\t\t\t\tdp[i][j][k][l].first = dp[i][j][k][l].second = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ツδ?δつ可サツ催?帰, P.first := ツ催?妥・ツグツδ仰ーツプツ青? P.second := ツ催?妥・ツ予ツ氾オツ療?\nP dfs(int lx, int ly, int rx, int ry){\n\tif( dp[lx][ly][rx][ry].first != 0 ) return dp[lx][ly][rx][ry];\n\t\n\tP res = P( 1 , s - (all - sum(lx,ly,rx,ry)) );\n\t\n\t// ツ青?閉スツづ可閉ェツ環?\n\tfor(int y=ly ; y < ry ; y++ ){\n\t\tif( all - s > sum(lx,ly,rx,y) ) continue;\n\t\tif( all - s > sum(lx,y+1,rx,ry) ) continue;\n\t\tP a = dfs( lx , ly  , rx , y );\n\t\tP b = dfs( lx , y+1 , rx , ry );\n\t\tP now = P( a.first + b.first , min(a.second,b.second) );\n\t\tres = max( res , now );\n\t}\n\t\n\t// ツ青つ陳シツづ可閉ェツ環?\n\tfor(int x=lx ; x < rx ; x++ ){\n\t\tif( all - s > sum(lx,ly,x,ry) ) continue;\n\t\tif( all - s > sum(x+1,ly,rx,ry) ) continue;\n\t\tP a = dfs(lx,ly,x,ry);\n\t\tP b = dfs(x+1,ly,rx,ry);\n\t\tP now = P( a.first + b.first , min(a.second,b.second) );\n\t\tres = max( res , now );\n\t}\n\treturn dp[lx][ly][rx][ry] = res;\n}\n\nint main(){\n\twhile( cin >> h >> w >> s, h || w || s ){\n\t\t//ツ禿シツ療?+ ツ療敖静渉和ツ可サ\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tfor(int x = 1 ; x <= w ; x++ ){\n\t\t\t\tcin >> u[y][x];\n\t\t\t\tf[y][x] = u[y][x] + f[y][x-1];\n\t\t\t}\n\t\t}\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tfor(int x = 1 ; x <= w ; x++ ){\n\t\t\t\tf[y][x] += f[y-1][x];\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tall = sum(1,1,w,h);\n\t\tP ans = dfs( 1 , 1 , w , h );\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\ntypedef pair<int,int> P;\n\nint H, W, S;\nint u[35][35];\nint mustGrp, sumGrp;\nbool visit[32][32][32][32];\nP dp[32][32][32][32];\n\nbool is_update(P base, P n1, P n2) {\n  if (base.first < (n1.first + n2.first)) return true;\n  if (base.first == (n1.first + n2.first)) {\n    if (base.second < min(n1.second ,n2.second)) return true;\n  }\n  return false;\n}\n\nP f(int mnx, int mny, int mxx, int mxy) {\n  if (visit[mnx][mny][mxx][mxy])\n    return dp[mnx][mny][mxx][mxy];\n  \n  visit[mnx][mny][mxx][mxy] = true;\n  P ret(1,0), lhs, rhs;\n  for (int i = mny; i <= mxy; ++i)\n    for (int j = mnx; j <= mxx; ++j)\n      ret.second += u[i][j];\n  // printf(\"%d %d - %d %d : %d\\n\", mnx, mny, mxx, mxy, ret.second);\n  // select horizonal\n  for (int i = mny; i <= mxy - 1; ++i) {\n    lhs = f(mnx, mny, mxx, i);\n    rhs = f(mnx, i+1, mxx, mxy);\n    if (lhs.second < mustGrp) continue;        \n    if (rhs.second < mustGrp) continue;\n    if (is_update(ret, lhs, rhs))\n      ret = P(lhs.first + rhs.first, min(lhs.second ,rhs.second));\n  }\n  // select vertical\n  for (int i = mnx; i <= mxx - 1; ++i) {\n    lhs = f(mnx, mny, i, mxy);\n    rhs = f(i+1, mny, mxx, mxy);\n    if (lhs.second < mustGrp) continue;\n    if (rhs.second < mustGrp) continue;\n    if (is_update(ret, lhs, rhs))\n      ret = P(lhs.first + rhs.first, min(lhs.second ,rhs.second));\n  }\n  return dp[mnx][mny][mxx][mxy] = ret;\n}\n\nvoid solve() {\n  sumGrp = 0;\n  rep(i,H) rep(j,W) sumGrp += u[i][j];\n  mustGrp = sumGrp - S; // assume\n  memset(visit, 0, sizeof visit);\n  P res = f(0, 0, W - 1, H - 1);\n  printf(\"%d %d\\n\", res.first, res.second - mustGrp);\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &H, &W, &S), H | W) {\n    rep(i,H) rep(j,W) scanf(\"%d\", u[i]+j);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint H,W,S;\nint grid[32][32];\nint sum[33][33];\nP memo[33][33][33][33];\n\n//[x1,x2) - [y1,y2)\nint count(int x1,int y1,int x2,int y2){\n  return sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\nP dfs(int x1,int y1,int x2,int y2){\n  P &memory = memo[x1][y1][x2][y2];\n  if(memory != P(-1,-1)) return memory;\n  if(S - (count(0,0,W,H) - count(x1,y1,x2,y2)) < 0) return P(-INF,-INF);\n  P res(1, S - (count(0,0,W,H) - count(x1,y1,x2,y2)));\n  for(int vy = y1+1; vy < y2; vy++){\n    P p1 = dfs(x1,y1,x2,vy);\n    P p2 = dfs(x1,vy,x2,y2);\n    P score = P(p1.first+p2.first, min(p1.second, p2.second));\n    res = max(res, score);\n  }\n  for(int vx = x1+1; vx < x2; vx++){\n    P p1 = dfs(x1,y1,vx,y2);\n    P p2 = dfs(vx,y1,x2,y2);\n    P score = P(p1.first+p2.first, min(p1.second, p2.second));\n    res = max(res, score);\n  }\n  return memory = res;\n}\nint main(){\n  while(cin>>H>>W>>S,H){\n    memset(sum,0,sizeof(sum));\n    memset(memo,-1,sizeof(memo));\n    REP(y,H)REP(x,W)cin>>grid[y][x];\n    REP(y,H)REP(x,W)sum[y+1][x+1] = sum[y+1][x] + sum[y][x+1] - sum[y][x] + grid[y][x];\n    P ans = dfs(0,0,W,H);\n    printf(\"%d %d\\n\",ans.first, ans.second);\n  }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint h, w, s;\nint sum[32][32];\nint grp[32][32][32][32];\nint pow[32][32][32][32];\n\nint getS(int sx, int sy, int gx, int gy){\n\tint res = sum[gx][gy];\n\tif(sx>0) res -= sum[sx-1][gy];\n\tif(sy>0) res -= sum[gx][sy-1];\n\tif(sx>0&&sy>0) res += sum[sx-1][sy-1];\n\treturn res;\n}\n\npair<int,int> search(int sx, int sy, int gx, int gy){\n\tif(grp[sx][sy][gx][gy]!=-1) return make_pair(grp[sx][sy][gx][gy], pow[sx][sy][gx][gy]);\n\tpair<int, int> res = make_pair(1, s-(sum[h-1][w-1]-getS(sx,sy,gx,gy)));\n\tfor(int i=sx;i<gx;i++){\n\t\tif(sum[h-1][w-1]-getS(sx, sy, i, gy) > s) continue;\n\t\tif(sum[h-1][w-1]-getS(i+1, sy, gx, gy) > s) continue;\n\t\tpair<int,int> p1 = search(sx, sy, i, gy);\n\t\tpair<int,int> p2 = search(i+1, sy, gx, gy);\n\t\tres = max(res, make_pair(p1.first+p2.first, min(p1.second, p2.second)));\n\t}\n\tfor(int i=sy;i<gy;i++){\n\t\tif(sum[h-1][w-1]-getS(sx, sy, gx, i) > s) continue;\n\t\tif(sum[h-1][w-1]-getS(sx, i+1, gx, gy) > s) continue;\n\t\tpair<int,int> p1 = search(sx, sy, gx, i);\n\t\tpair<int,int> p2 = search(sx, i+1, gx, gy);\n\t\tres = max(res, make_pair(p1.first+p2.first, min(p1.second, p2.second)));\n\t}\n\tgrp[sx][sy][gx][gy] = res.first;\n\tpow[sx][sy][gx][gy] = res.second;\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> h >> w >> s, h){\n\t\tmemset(grp, -1, sizeof(grp));\n\t\tmemset(pow, -1, sizeof(pow));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> sum[i][j];\n\t\t\t\tif(i-1>=0) sum[i][j] += sum[i-1][j];\n\t\t\t\tif(j-1>=0) sum[i][j] += sum[i][j-1];\n\t\t\t\tif(i-1>=0&&j-1>=0) sum[i][j] -= sum[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\tpair<int, int> res = search(0, 0, h-1, w-1);\n\t\tcout << res.first << \" \" << res.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n\ntypedef pair<int,int> P;\nint h,w,s,all,t[32][32];\nint i,j;\nint rec[32][32][32][32]; //長方形の合計[ly][lx][hy][hx]\nP dp[32][32][32][32]; //メモ化\n\n//全ての(lx,ly)〜(hx,hy)の長方形合計を計算\nvoid mkRec(){\n  memset(rec,0,sizeof(rec));\n\n  rep(i,h){\n    rep(j,w){\n      rec[i][j][i][j] = t[i][j];\n\n      for(int y=i-1;y>=0;y--)\n        rec[y][j][i][j] = rec[y+1][j][i][j] + t[y][j];\n\n      for(int y=i;y>=0;y--){\n        int sum = 0;\n        for(int x=j;x>=0;x--){\n          sum += rec[y][x][i][x];\n          rec[y][x][i][j] = sum;\n        }\n      }\n    }\n  }\n}\n\n//戻り型 : P. first : 最大グループ数. second : 最大予備力\nP dfs(int lx,int ly,int hx,int hy){\n  if(dp[ly][lx][hy][hx].first != 0) return dp[ly][lx][hy][hx];\n\n  P res = P(1,s-(all-rec[ly][lx][hy][hx]));\n\n  //水平分割\n  for(int i=ly;i<hy;i++){\n    if(all - rec[ly][lx][i][hx] > s ||\n       all - rec[i+1][lx][hy][hx] > s) continue;\n    P a = dfs(lx,ly,hx,i);\n    P b = dfs(lx,i+1,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  //垂直分割\n  for(int j=lx;j<hx;j++){\n    if(all - rec[ly][lx][hy][j] > s ||\n       all - rec[ly][j+1][hy][hx] > s) continue;\n    P a = dfs(lx,ly,j,hy);\n    P b = dfs(j+1,ly,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  return dp[ly][lx][hy][hx] = res;\n}\n\nint main(void){\n  while(scanf(\"%d%d%d\",&h,&w,&s),h||w||s){\n    all = 0;\n    rep(i,h){\n      rep(j,w){\n        scanf(\"%d\",&t[i][j]);\n        all += t[i][j];\n      }\n    }\n\n    mkRec();\n\n    memset(dp,0,sizeof(dp));\n    P p = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",p.first,p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint m[34][34] = {0};\n\ntypedef pair<int, int> Ans;\n\n#define INF 1e9\n\nint H, W, S;\nint P;\nAns memo[32][32][32][32];\nbool memo2[32][32][32][32];\nAns f(int x1, int y1, int x2, int y2) {\n  if (memo2[x1][y1][x2][y2]) return memo[x1][y1][x2][y2];\n\n  int power = m[y2][x2] - m[y1][x2] - m[y2][x1] + m[y1][x1];\n  if (P-power <= S) {\n    Ans ret = Ans(1, S-(P-power));\n    for (int x = x1+1; x < x2; ++x) {\n      Ans a1 = f(x1, y1, x, y2);\n      Ans a2 = f(x, y1, x2, y2);\n      if (a1.first < 0 || a2.first < 0) continue;\n      Ans a = Ans(a1.first+a2.first, min(a1.second, a2.second));\n      if (a.first > ret.first || (a.first == ret.first && a.second > ret.second)) ret = a;\n    }\n    for (int y = y1+1; y < y2; ++y) {\n      Ans a1 = f(x1, y1, x2, y);\n      Ans a2 = f(x1, y, x2, y2);\n      if (a1.first < 0 || a2.first < 0) continue;\n      Ans a = Ans(a1.first+a2.first, min(a1.second, a2.second));\n      if (a.first > ret.first || (a.first == ret.first && a.second > ret.second)) ret = a;\n    }\n    memo2[x1][y1][x2][y2] = true;\n    return memo[x1][y1][x2][y2] = ret;\n  }\n  else {\n    return Ans(-1, 0);\n  }\n}\nint main() {\n  while ( cin >> H >> W >> S, H || W || S ) {\n    fill(&memo2[0][0][0][0], &memo2[0][0][0][0]+32*32*32*32, false);\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        cin >> m[y+1][x+1];\n      }\n    }\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x < W; ++x) {\n        m[y][x+1] += m[y][x];\n      }\n    }\n    for (int x = 1; x <= W; ++x) {\n      for (int y = 1; y < H; ++y) {\n        m[y+1][x] += m[y][x];\n      }\n    }\n    P = m[H][W] - m[0][W] - m[H][0] + m[0][0];\n\n    Ans ans = f(0, 0, W, H);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\ntypedef pair<int,int> P;\n\nint h,w,s,all,t[32][32];\nint rec[32][32][32][32]; //[ly][lx][hy][hx]\nP dp[32][32][32][32];\n\nvoid mkRec(){\n  memset(rec,0,sizeof(rec));\n\n  rep(i,h){\n    rep(j,w){\n      rec[i][j][i][j] = t[i][j];\n\n      for(int y=i-1;y>=0;y--)\n        rec[y][j][i][j] = rec[y+1][j][i][j] + t[y][j];\n\n      for(int y=i;y>=0;y--){\n        int sum = 0;\n        for(int x=j;x>=0;x--){\n          sum += rec[y][x][i][x];\n          rec[y][x][i][j] = sum;\n        }\n      }\n    }\n  }\n}\n\nP dfs(int lx,int ly,int hx,int hy){\n  if(dp[ly][lx][hy][hx].first != 0) return dp[ly][lx][hy][hx];\n\n  P res = P(1,s-(all-rec[ly][lx][hy][hx]));\n\n  for(int i=ly;i<hy;i++){\n    if(all - rec[ly][lx][i][hx] > s ||\n       all - rec[i+1][lx][hy][hx] > s) continue;\n    P a = dfs(lx,ly,hx,i);\n    P b = dfs(lx,i+1,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  for(int j=lx;j<hx;j++){\n    if(all - rec[ly][lx][hy][j] > s ||\n       all - rec[ly][j+1][hy][hx] > s) continue;\n    P a = dfs(lx,ly,j,hy);\n    P b = dfs(j+1,ly,hx,hy);\n    P cal = P(a.first+b.first,min(a.second,b.second));\n    res = max(res,cal);\n  }\n\n  return dp[ly][lx][hy][hx] = res;\n}\n\nint main(void){\n  while(scanf(\"%d%d%d\",&h,&w,&s),h||w||s){\n    all = 0;\n    rep(i,h){\n      rep(j,w){\n        scanf(\"%d\",&t[i][j]);\n        all += t[i][j];\n      }\n    }\n\n    mkRec();\n\n    memset(dp,0,sizeof(dp));\n    P p = dfs(0,0,w-1,h-1);\n    printf(\"%d %d\\n\",p.first,p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dp[40][40][40][40],dp2[40][40][40][40],vi[40][40][40][40];\nint u[40][40],su[40][40];\nint h,w,s,a;\nint sum(int si,int sj,int ti,int tj){\n  //ti--;tj--;\n  return su[ti][tj]-su[ti][sj]-su[si][tj]+su[si][sj];\n}\nvoid dfs(int si,int sj,int ti,int tj){\n  if(vi[si][sj][ti][tj]) return;\n  vi[si][sj][ti][tj]=1;\n  int val=sum(si,sj,ti,tj);\n  int res=1,res2=s-(a-val);\n  //cout<<si<<\" \"<<sj<<\" \"<<ti<<\" \"<<tj<<endl;\n  //cout<<res2<<\" \"<<a<<\" \"<<val<<endl;\n\n  if(res2<0) return;\n  for(int i=si+1;i<ti;i++){\n    dfs(si,sj,i,tj);\n    dfs(i,sj,ti,tj);\n    if(dp[si][sj][i][tj]<0||dp[i][sj][ti][tj]<0) continue;\n    if(dp[si][sj][i][tj]+dp[i][sj][ti][tj]==res){\n      res2=max(res2,min(dp2[si][sj][i][tj],dp2[i][sj][ti][tj]));\n    }\n    if(dp[si][sj][i][tj]+dp[i][sj][ti][tj]>res){\n      res=dp[si][sj][i][tj]+dp[i][sj][ti][tj];\n      res2=min(dp2[si][sj][i][tj],dp2[i][sj][ti][tj]);\n    }\n  }\n  for(int j=sj+1;j<tj;j++){\n    dfs(si,sj,ti,j);\n    dfs(si,j,ti,tj);\n    if(dp[si][sj][ti][j]<0||dp[si][j][ti][tj]<0) continue;\n    if(dp[si][sj][ti][j]+dp[si][j][ti][tj]==res){\n      res2=max(res2,min(dp2[si][sj][ti][j],dp2[si][j][ti][tj]));\n    }\n    if(dp[si][sj][ti][j]+dp[si][j][ti][tj]>res){\n      res=dp[si][sj][ti][j]+dp[si][j][ti][tj];\n      res2=min(dp2[si][sj][ti][j],dp2[si][j][ti][tj]);\n    }\n  }\n  \n  //cout<<si<<\" \"<<sj<<\" \"<<ti<<\" \"<<tj<<endl;\n  //cout<<res<<\" \"<<res2<<endl;\n  \n  dp[si][sj][ti][tj]=res;\n  dp2[si][sj][ti][tj]=res2;\n}\nint main(){\n  while(cin>>h>>w>>s,h||w||s){\n    memset(dp,-1,sizeof(dp));\n    memset(dp2,-1,sizeof(dp2));\n    memset(u,0,sizeof(u));\n    memset(su,0,sizeof(su));\n    memset(vi,0,sizeof(vi));\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>u[i][j];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)\n\tsu[i+1][j+1]=su[i+1][j]+u[i][j];\n      for(int j=0;j<w;j++)\n\tsu[i+1][j+1]+=su[i][j+1];\n    }\n    a=su[h][w];\n    dfs(0,0,h,w);\n    cout<<dp[0][0][h][w]<<\" \"<<dp2[0][0][h][w]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nconst pii INIT = pii(-1,-1);\nint board[33][33];\nint acc[33][33];\npii memo[33][33][33][33];\nint H, W, E, S;\n\nint getsum(int p, int q, int x, int y){\n  return board[x][y] - board[p][y] - board[x][q] + board[p][q];\n}\n\npii solve(int l, int t, int r, int b){\n  pii& ans = memo[l][t][r][b];\n  if(ans != INIT) return ans;\n\n  int sum = getsum(l,t,r,b);\n  if(sum < E - S) return ans = pii(0, 0);\n  \n  ans = pii(1, S - E + sum);\n  \n  for(int i = l+1; i < r; ++i){\n    pii ra = solve(l,t,i,b);\n    pii rb = solve(i,t,r,b);\n    pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n    ans = max(ans, temp);\n  }\n\n  for(int i = t+1; i < b; ++i){\n    pii ra = solve(l,t,r,i);\n    pii rb = solve(l,i,r,b);\n    pii temp = pii(ra.first + rb.first, min(ra.second, rb.second));\n    ans = max(ans, temp);\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> H >> W >> S, H){\n    memset(board, 0, sizeof(board));\n    for(int i = 0; i < 33; ++i)\n      for(int j = 0; j < 33; ++j)\n\tfor(int k = 0; k < 33; ++k)\n\t  for(int l = 0; l < 33; ++l)\n\t    memo[i][j][k][l] = INIT;\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tcin >> board[i+1][j+1];\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tboard[i+1][j+1] += board[i+1][j];\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\tboard[i+1][j+1] += board[i][j+1];\n\n    E = getsum(0,0,H,W);\n    pii ans = solve(0,0,H,W);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint dp[33][33][33][33];\nint dp2[33][33][33][33];\nint tb[32][32];\nint sum[33][33];\n\npair<int,int> mg(pair<int,int> l,pair<int,int> r){\n  return make_pair(l.first+r.first,min(l.second,r.second));\n}\n\npair<int,int> dfs(int t,int l, int b, int r, int nd) {\n  if(dp[t][l][b][r] >= 0) return make_pair(dp[t][l][b][r], dp2[t][l][b][r]);\n  int sm = sum[b][r] - sum[t][r] - sum[b][l] + sum[t][l];\n  if (sm >= nd) {\n    pair<int,int> res(1,sm-nd);\n    for(int i=t+1;i<b;++i){\n      auto fst = dfs(t,l,i,r,nd);\n      auto snd = dfs(i,l,b,r,nd);\n      if(fst.first==0||snd.first==0)continue;\n      res=max(res,mg(fst,snd));\n    }\n    for(int i=l+1;i<r;++i){\n      auto fst = dfs(t,l,b,i,nd);\n      auto snd = dfs(t,i,b,r,nd);\n      if(fst.first==0||snd.first==0)continue;\n      res=max(res,mg(fst,snd));\n    }\n    dp[t][l][b][r] = res.first;\n    dp2[t][l][b][r] = res.second;\n    return res;\n  } else {\n    dp[t][l][b][r] = 0;\n    dp2[t][l][b][r] = 0;\n    return make_pair(0,0);\n  }\n}\n\nint main() {\n  while(1){\n    int h,w,s;\n    cin>>h>>w>>s;\n    if(!h)break;\n    REP(i,h+1)REP(j,w+1)REP(k,h+1)REP(l,w+1){\n      dp[i][j][k][l]=-1;\n      dp2[i][j][k][l]=-1;\n    }\n    REP(i,h)REP(j,w)cin>>tb[i][j];\n    int sm=0;\n    REP(i,h)REP(j,w)sm+=tb[i][j];\n    int nd=sm-s;\n    REP(i,w+1)sum[0][i]=0;\n    REP(i,h){\n      sum[i+1][0]=0;\n      REP(j,w){\n        sum[i+1][j+1]=tb[i][j]+sum[i][j+1]+sum[i+1][j]-sum[i][j];\n      }\n    }\n    auto res = dfs(0,0,h,w,nd);\n    cout << res.first << ' ' << res.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\n#define int long long\n\ntypedef pair<int, int> P;\n\nint H, W, T;\nvector< vector<int> > A;\nbool m1[33][33][33][33];\nP m2[33][33][33][33];\nint m[50][50];\n\nvoid setM(int x, int y, int val) {\n\tm[y+1][x+1] = val;\n}\nint getM(int x1, int y1, int x2, int y2) {\n\treturn m[y2][x2] - m[y2][x1] - m[y1][x2] + m[y1][x1];\n}\nvoid initM() {\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y+1][x] += m[y][x];\n\t}\n\tREP(x, W+1) REP(y, H+1) {\n\t\tm[y][x+1] += m[y][x];\n\t}\n}\n\n// [x1, x2) && [y1, y2)\nP solve(int x1, int y1, int x2, int y2) {\n\tif (m1[x1][y1][x2][y2]) return m2[x1][y1][x2][y2];\n\n\tP res(1, getM(x1, y1, x2, y2)-T);\n\tif (res.second < 0) {\n\t\tres = P(-inf, -inf);\n\t}\n\telse {\n\t\t// [y1, y) [y, y2)\n\t\tFOR(y, y1+1, y2) {\n\t\t\tP a1 = solve(x1, y1, x2, y);\n\t\t\tP a2 = solve(x1, y, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t\t// [x1, x) [x, x2)\n\t\tFOR(x, x1+1, x2) {\n\t\t\tP a1 = solve(x1, y1, x, y2);\n\t\t\tP a2 = solve(x, y1, x2, y2);\n\t\t\tP a = P(a1.first+a2.first, min(a1.second, a2.second));\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n//\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << res.first << \" \" << res.second << endl;\n\treturn m1[x1][y1][x2][y2] = true, m2[x1][y1][x2][y2] = res;\n}\n\nsigned main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> T, H || W || T) {\n\t\tfill(m[0], m[50], 0);\n\t\tfill(m1[0][0][0], m1[0][0][0]+33*33*33, false);\n\t\tA = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tREP(y, H) REP(x, W) {\n\t\t\tcin >> A[y][x];\n\t\t\tsetM(x, y, A[y][x]);\n\t\t}\n\t\tinitM();\n\t\tint sum = 0;\n\t\tREP(y, H) REP(x, W) sum += A[y][x];\n\t\tT = sum - T;\n\t\tassert(T >= 0);\n\t\tP ans = solve(0, 0, W, H);\n\t\tassert(ans.first >= 0 && ans.second >= 0);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define f first\n#define s second\n#define INF (1<<29)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h,w,s,u[34][34];\nP memo[34][34][34][34];\n\nP rec(int x1,int y1,int x2,int y2){\n\t\n\tif(memo[x1][y1][x2][y2]!=P(0,INF))return memo[x1][y1][x2][y2];\n\tif(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])>s)return P(0,INF);\n\tP res=P(1,s-(u[h-1][w-1]-(u[y2-1][x2-1]-u[y2-1][x1-1]-u[y1-1][x2-1]+u[y1-1][x1-1])));\n\t\n\tfor(int i=y1+1;i<y2;i++){\n\t\tP a=rec(x1,y1,x2,i);\n\t\tP b=rec(x1,i,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\tfor(int i=x1+1;i<x2;i++){\n\t\tP a=rec(x1,y1,i,y2);\n\t\tP b=rec(i,y1,x2,y2);\n\t\tres=max(res,P(a.f+b.f,min(a.s,b.s)));\n\t}\n\t\n\treturn memo[x1][y1][x2][y2]=res;\n}\n\nint main(void){\n\t\n\twhile(cin >> h >> w >> s,h++|w++|s){\n\t\t\n\t\tfill(u[0],u[34],0);\n\t\t\n\t\tfor(int i=0;i<34;i++)\n\t\t\tfor(int j=0;j<34;j++)\n\t\t\t\tfor(int k=0;k<34;k++)\n\t\t\t\t\tfor(int l=0;l<34;l++)memo[i][j][k][l]=P(0,INF);\n\t\t\n\t\tfor(int i=1;i<h;i++)\n\t\t\tfor(int j=1;j<w;j++)cin >> u[i][j];\n\t\t\n\t\tfor(int i=1;i<h;i++)\n\t\t\tfor(int j=1;j<w;j++)\n\t\t\t\tu[i][j]+=u[i-1][j]+u[i][j-1]-u[i-1][j-1];\n\t\t\n\t\tP ans=rec(1,1,w,h);\n\t\tcout << ans.f << \" \" << ans.s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int g;\n    int e;\n    Data(){\n        g = e = -1;\n    }\n    Data(int g0, int e0){\n        g = g0;\n        e = e0;\n    }\n    bool operator<(const Data& d) const{\n        return g < d.g || (g == d.g && e < d.e);\n    }\n};\n\nbool check[32][32][33][33];\nData memo[32][32][33][33];\n\nData solve(int y, int x, int h, int w, int s)\n{\n    if(check[y][x][h][w])\n        return memo[y][x][h][w];\n\n    int tmp = 0;\n    for(int i=y; i<y+h; ++i){\n        for(int j=x; j<x+w; ++j){\n            tmp += memo[i][j][1][1].e;\n        }\n    }\n    if(tmp < s)\n        return Data();\n\n    Data ret(1, tmp);\n    for(int i=1; i<h; ++i){\n        Data d1 = solve(y, x, i, w, s);\n        Data d2 = solve(y+i, x, h-i, w, s);\n        if(d1.g == -1 || d2.g == -1)\n            continue;\n        Data d3(d1.g + d2.g, min(d1.e, d2.e));\n        ret = max(ret, d3);\n    }\n    for(int i=1; i<w; ++i){\n        Data d1 = solve(y, x, h, i, s);\n        Data d2 = solve(y, x+i, h, w-i, s);\n        if(d1.g == -1 || d2.g == -1)\n            continue;\n        Data d3(d1.g + d2.g, min(d1.e, d2.e));\n        ret = max(ret, d3);\n    }\n\n    check[y][x][h][w] = true;\n    memo[y][x][h][w] = ret;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int h, w, s;\n        cin >> h >> w >> s;\n        if(h == 0)\n            return 0;\n\n        for(int i=0; i<32; ++i){\n            for(int j=0; j<32; ++j){\n                for(int k=0; k<33; ++k){\n                    for(int l=0; l<33; ++l){\n                        check[i][j][k][l] = false;\n                        memo[i][j][k][l] = Data();\n                    }\n                }\n            }\n        }\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                memo[i][j][1][1].g = 1;\n                cin >> memo[i][j][1][1].e;\n                s -= memo[i][j][1][1].e;\n            }\n        }\n        s *= -1;\n\n        Data d = solve(0, 0, h, w, s);\n        cout << d.g << ' ' << (d.e-s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint h, w, s;\nint allsum;\nint u[32][32];\nint psum[33][33];\nint sum[32][32][32][32];\nP dp[32][32][32][32];\n\nP dfs(int ly, int lx, int hy, int hx){\n    if(dp[ly][lx][hy][hx].first != 0){\n        return dp[ly][lx][hy][hx];\n    }\n\n    P res = P(1, s - (allsum - sum[ly][lx][hy][hx]));\n\n    for(int i=ly; i<hy; i++){\n        if(allsum - sum[ly][lx][i][hx] > s) continue;\n        if(allsum - sum[i+1][lx][hy][hx] > s) continue;\n\n\n        P a = dfs(ly, lx, i, hx);\n        P b = dfs(i+1, lx, hy, hx);\n        P ab = P(a.first + b.first , min(a.second, b.second));\n        res = max(res, ab);\n    }\n\n    for(int i=lx; i<hx; i++){\n        if(allsum - sum[ly][lx][hy][i] > s) continue;\n        if(allsum - sum[ly][i+1][hy][hx] > s) continue;\n\n        P a = dfs(ly, lx, hy, i);\n        P b = dfs(ly, i+1, hy, hx);\n        P ab = P(a.first + b.first , min(a.second, b.second));\n        res = max(res, ab);\n    }\n\n    return dp[ly][lx][hy][hx] = res;\n}\n\nint main(){\n    while(1){\n        allsum = 0;\n        memset(psum, 0, sizeof(psum));\n        memset(sum, 0, sizeof(sum));\n        memset(dp, 0, sizeof(dp));\n\n        cin>>h>>w>>s;\n        if(h == 0) return 0;\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin>>u[i][j];\n                allsum += u[i][j];\n            }\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                psum[i+1][j+1] = psum[i+1][j] + u[i][j];\n            }\n        }\n\n        for(int i=0; i<w; i++){\n            for(int j=0; j<h; j++){\n                psum[j+1][i+1] += psum[j][i+1];\n            }\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=i; j<h; j++){\n                for(int k=0; k<w; k++){\n                    for(int l=k; l<w; l++){\n                        sum[i][k][j][l] = psum[j+1][l+1] - psum[i][l+1] - psum[j+1][k] + psum[i][k];\n                    }\n                }\n            }\n        }\n\n        P ans = dfs(0, 0, h-1, w-1);\n\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h,w,s,u[33][33]={},a[33][33][33][33]={},t,b[33][33][33][33]={};\nint Usum(int i,int j,int k,int l){\n    int R=0;\n    R=u[j+l][i+k]-u[j][i+k]-u[j+l][i]+u[j][i];\n    return R;\n}\n\nint main(){\n    while (cin >> h >> w >> s && h!=0){\n        for (int i=1; i<=w; i++){\n            for (int j=1; j<=h; j++){\n                cin >> u[i][j];\n                u[i][j] += u[i-1][j];\n                u[i][j] += u[i][j-1];\n                u[i][j] -= u[i-1][j-1];\n            }\n        }\n        t=u[w][h]-s;\n        for (int i=1; i<=h; i++){\t\t\t\t\t\t//??????\n            for (int j=0; j<=h-i; j++){\t\t\t\t\t//???\n                for (int k=1; k<=w; k++){               //???\n                    for (int l=0; l<=w-k; l++){\t\t\t//???\n                        if (Usum(j,l,i,k)>=t){\n\t\t\t\t\t\t\ta[j][l][i][k]=1;\n\t\t\t\t\t\t}\n                        else a[j][l][i][k]=-100000000;\n                        for (int m=1; m<i; m++){\n                            if (a[j][l][i][k]<a[j][l][m][k]+a[j+m][l][i-m][k]){\n\t\t\t\t\t\t\t\ta[j][l][i][k]=a[j][l][m][k]+a[j+m][l][i-m][k];\n\t\t\t\t\t\t\t\tif (b[j][l][m][k]<b[j+m][l][i-m][k]) b[j][l][i][k]=b[j][l][m][k];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j+m][l][i-m][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[j][l][i][k]==a[j][l][m][k]+a[j+m][l][i-m][k] && b[j][l][i][k]<b[j][l][m][k] && b[j][l][i][k]<b[j+m][l][i-m][k]){\n\t\t\t\t\t\t\t\tif (b[j][l][m][k]<b[j+m][l][i-m][k]) b[j][l][i][k]=b[j][l][m][k];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j+m][l][i-m][k];\n\t\t\t\t\t\t\t}\n                        }\n                        for (int m=1; m<k; m++){\n                            if (a[j][l][i][k]<a[j][l][i][m]+a[j][l+m][i][k-m]){\n\t\t\t\t\t\t\t\ta[j][l][i][k]=a[j][l][i][m]+a[j][l+m][i][k-m];\n\t\t\t\t\t\t\t\tif (b[j][l][i][m]<b[j][l+m][i][k-m]) b[j][l][i][k]=b[j][l][i][m];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j][l+m][i][k-m];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[j][l][i][k]==a[j][l][i][m]+a[j][l+m][i][k-m] && b[j][l][i][k]<b[j][l][i][m] && b[j][l][i][k]<b[j][l+m][i][k-m]){\n\t\t\t\t\t\t\t\tif (b[j][l][i][m]<b[j][l+m][i][k-m]) b[j][l][i][k]=b[j][l][i][m];\n\t\t\t\t\t\t\t\telse b[j][l][i][k]=b[j][l+m][i][k-m];\n\t\t\t\t\t\t\t}\n                        }\n\t\t\t\t\t\tif (a[j][l][i][k]==1) b[j][l][i][k]=Usum(j,l,i,k)-t;\n                    }\n                }\n            }\n        }\n        cout << a[0][0][h][w] << \" \" << b[0][0][h][w] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n)       reps (i, 0, n)\n#define reps(i, m, n)   for (int i = m; i < int(n); ++i)\n\ntypedef pair<int, int> pi;\n\nint h, w, s, all, u[33][33], sum[33][33];\npi memo[33][33][33][33];\n\npi dp(int ax, int ay, int bx, int by)\n{\n    pi &best = memo[ay][ax][by][bx];\n    if (best.first != -1) return best;\n    int ss = sum[by][bx] - sum[ay][bx] - sum[by][ax] + sum[ay][ax];\n    best = pi(1, ss);\n    reps (x, ax + 1, bx) {\n        pi p = dp(ax, ay, x, by);\n        pi q = dp(x, ay, bx, by);\n        int m = all - p.second;\n        int n = all - q.second;\n        if (m > s || n > s) continue;\n        best = max(best, pi(p.first + q.first, min(p.second, q.second)));\n    }\n    reps (y, ay + 1, by) {\n        pi p = dp(ax, ay, bx, y);\n        pi q = dp(ax, y, bx, by);\n        int m = all - p.second;\n        int n = all - q.second;\n        if (m > s || n > s) continue;\n        best = max(best, pi(p.first + q.first, min(p.second, q.second)));\n    }\n    return best;\n}\n\nint main()\n{\n    while (cin >> h >> w >> s, h) {\n        rep (i, h) rep (j, w) cin >> u[i][j];\n        fill_n(*sum, 33*33, 0);\n        fill_n(***memo, 33*33*33*33, pi(-1, -1));\n        rep (i, h) rep (j, w)\n            sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + u[i][j];\n        all = sum[h][w];\n        pi ans = dp(0, 0, w, h);\n        cout << ans.first << \" \" << s + ans.second - all << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define INF 100000000\n#define mp make_pair\n#define pii pair<int,int>\n\nint h,w,s;\nint board[55][55];\nint box[55][55];\n\n\nvoid boxset(){\n\tfor(int i=1;i<=h;i++)box[i][1] = board[i-1][0] + box[i-1][1];\n\tfor(int i=1;i<=w;i++)box[1][i] = board[0][i-1] + box[1][i-1];\n\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tbox[i][j] = box[i-1][j] + box[i][j-1] - box[i-1][j-1] + board[i-1][j-1];\n\t}\n}\n\nint boxget(int y1,int x1,int y2,int x2){\n\treturn box[y2][x2] - box[y1][x2] - box[y2][x1] + box[y1][x1];\n}\n\n\n//pair<int,int> : 分割数,区画内の和の最小値\n\npii marge(pii a, pii b){\n\treturn mp(a.first + b.first,  min(a.second, b.second));\n}\n\npii memo[33][33][33][33];\npii saiki(int y1,int x1,int y2,int x2){\n\tif(memo[y1][x1][y2][x2].first!=0) return memo[y1][x1][y2][x2];\n\t\n\tpii cand = mp(1, boxget(y1,x1,y2,x2));\n\t\n\tpii a1,b1,a2,b2;\n\t\n\t//左右分割\n\tfor(int i=y1+1; i<y2; i++){\n\t\tpii a = saiki(y1, x1, i, x2);\n\t\tpii b = saiki(i, x1, y2, x2);\n\t\t\n\t\tcand = max(marge(a,b), cand);\n\t}\n\t\n\t//上下分割\n\tfor(int i=x1+1; i<x2; i++){\n\t\tpii a = saiki(y1, x1, y2, i);\n\t\tpii b = saiki(y1, i, y2, x2);\n\t\tcand = max(marge(a,b), cand);\n\t}\n\t\n\tif(boxget(0,0,h,w) - cand.second > s)cand = mp(-INF,0);\n\treturn memo[y1][x1][y2][x2] = cand;\n}\n\nint main(){\n\t\n\twhile(1){\n\t\t//入力\n\t\tcin>>h>>w>>s;\n\t\tif(h==0)break;\n\t\t\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>board[i][j];\n\t\t\tfor(int k=0;k<h;k++)for(int p=0;p<w;p++)memo[i][j][k][p] = mp(0,0);\n\t\t}\n\t\t\n\t\t//二次元累積和計算\n\t\tboxset();\n\t\t\n\t\tpii ans = saiki(0,0,h,w);\n\t\tprintf(\"%d %d\\n\",ans.first, ans.second + s - boxget(0,0,h,w));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define ALL(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\nP dp[32][32][32][32];\t\t//dp[大きさ-1][初め]=分割数,最小値(q以上が無理なら-1,-1)\nint sum[32][32][32][32];\nint main(){\n\twhile(true){\n\t\tint h,w,s,u[32][32]={},su=0;\n\t\tcin >> h >> w >> s;\n\t\tif(h==0) break;\n\t\trep(i,h) rep(j,w){\n\t\t\tcin >> u[i][j];\n\t\t\tsum[0][0][i][j]=u[i][j];\n\t\t\tsu+=u[i][j];\n\t\t}\n\t\ts=su-s;\t\t\t\t//s以上に\n\t\trep(i,h) rep(j,w){\n\t\t\tif(u[i][j]>=s) dp[0][0][i][j]=P(1,u[i][j]);\n\t\t\telse dp[0][0][i][j]=P(-1,-1);\n\t\t}\n\t\trep1(i,h){\t\t\t\t//縦の大きさ\n\t\t\trep1(j,w){\t\t\t//横の大きさ\n\t\t\t\tif(i==1 && j==1) continue;\n\t\t\t\trep(k,h-i+1){\t\t//縦の初め\n\t\t\t\t\trep(l,w-j+1){\t//横の初め\n\t\t\t\t\t\tif(i!=1) sum[i-1][j-1][k][l]=sum[0][j-1][k][l]+sum[i-2][j-1][k+1][l];\n\t\t\t\t\t\telse sum[i-1][j-1][k][l]=sum[i-1][0][k][l]+sum[i-1][j-2][k][l+1];\n\t\t\t\t\t\t//cout << sum[i-1][j-1][k][l] << endl;\n\t\t\t\t\t\tif(sum[i-1][j-1][k][l]<s) dp[i-1][j-1][k][l]=P(-1,-1);\n\t\t\t\t\t\telse dp[i-1][j-1][k][l]=P(1,sum[i-1][j-1][k][l]);\n\t\t\t\t\t\trep1(m,i-1){\t//ちぎった方の大きさ\n\t\t\t\t\t\t\tP one=dp[m-1][j-1][k][l],two=dp[i-1-m][j-1][k+m][l];\n\t\t\t\t\t\t\tif(one.fs==-1 || two.fs==-1) continue;\n\t\t\t\t\t\t\tdp[i-1][j-1][k][l]=max(dp[i-1][j-1][k][l],P(one.fs+two.fs,min(one.sc,two.sc)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep1(m,j-1){\t//ちぎった方の大きさ\n\t\t\t\t\t\t\tP one=dp[i-1][m-1][k][l],two=dp[i-1][j-1-m][k][l+m];\n\t\t\t\t\t\t\tif(one.fs==-1 || two.fs==-1) continue;\n\t\t\t\t\t\t\tdp[i-1][j-1][k][l]=max(dp[i-1][j-1][k][l],P(one.fs+two.fs,min(one.sc,two.sc)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tcout << endl;\n\t\t\t\t}\n//\t\t\t\tcout << endl;\n\t\t\t}\n//\t\t\tcout << endl;\n\t\t}\n/*\t\twhile(true){\n\t\t\tint x,y,xx,yy;\n\t\t\tcin >> x >> y >> xx >> yy;\n\t\t\tcout << sum[x-1][y-1][xx][yy] << endl;\n\t\t}\n*/\n\t\tcout << dp[h-1][w-1][0][0].fs << \" \" << dp[h-1][w-1][0][0].sc-s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H, W, S;\n//?????????\nint dp1[32][32][33][33];    //????????°\nint dp2[32][32][33][33];    //?????????\nbool done[32][32][33][33];\nint field[33][33];\n\nint area(int t, int l, int b, int r){\n    return field[b][r] - field[t][r] - field[b][l] + field[t][l];\n}\n\nvoid dfs(int t,int l, int b, int r){\n    if(done[t][l][b][r]) return;\n    \n    int split = 1;\n    int res = S-(area(0, 0, H, W)-area(t, l, b, r));\n    \n    for(int h=t+1; h<b; h++){\n        if(area(t, l, h, r) >= area(0, 0, H, W)-S && area(h, l, b, r) >= area(0, 0, H, W)-S){\n            dfs(t, l, h, r);\n            dfs(h, l, b, r);\n            if(dp1[t][l][h][r] + dp1[h][l][b][r] > split){\n                split = dp1[t][l][h][r] + dp1[h][l][b][r];\n                res = min(dp2[t][l][h][r], dp2[h][l][b][r]);\n            }else if(dp1[t][l][h][r] + dp1[h][l][b][r] == split){\n                res = max(res, min(dp2[t][l][h][r], dp2[h][l][b][r]));\n            }\n        }\n    }\n    for(int w=l+1; w<r; w++){\n        if(area(t, l, b, w) >= area(0, 0, H, W)-S && area(t, w, b, r) >= area(0, 0, H, W)-S){\n            dfs(t, l, b, w);\n            dfs(t, w, b, r);\n            if(dp1[t][l][b][w] + dp1[t][w][b][r] > split){\n                split = dp1[t][l][b][w] + dp1[t][w][b][r];\n                res = min(dp2[t][l][b][w], dp2[t][w][b][r]);\n            }else if(dp1[t][l][b][w] + dp1[t][w][b][r] == split){\n                res = max(res, min(dp2[t][l][b][w], dp2[t][w][b][r]));\n            }\n        }\n    }\n    done[t][l][b][r] = true;\n    dp1[t][l][b][r] = split;\n    dp2[t][l][b][r] = res;\n}\n\nint main(){\n    while(cin >> H >> W >> S, H|W|S){\n        memset(field, 0, sizeof(field));\n        memset(dp1, -1, sizeof(dp1));\n        memset(dp2, -1, sizeof(dp2));\n        memset(done, 0, sizeof(done));\n        \n        for(int i=1; i<=H; i++)\n            for(int j=1; j<=W; j++)\n                cin >> field[i][j];\n        \n        for(int i=0; i<H; i++)\n            for(int j=0; j<=W; j++)\n                field[i+1][j] += field[i][j];\n        for(int i=0; i<W; i++)\n            for(int j=0; j<=H; j++)\n                field[j][i+1] += field[j][i];\n        \n        dfs(0, 0, H, W);\n        \n        cout << dp1[0][0][H][W] << \" \" << dp2[0][0][H][W] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\n\nP dp[32][32][32][32]; //dp[a][b][c][d]...(a,b),(a,d),(c,b),(c,d)で囲まれた長方形の分割数と予備力\nint rui[33][33]; //2次元累積和\nint u[32][32];\nint h,w,s;\n\nP operator+(const P& lhs, const P& rhs)\n{\n\treturn P(lhs.first+rhs.first,min(lhs.second,rhs.second));\n}\n\n//tate*yokoの場合を計算する\nvoid memo(int tate,int yoko)\n{\n\tfor(int i=0;i<h-tate+1;i++)\n\t{\n\t\tfor(int j=0;j<w-yoko+1;j++)\n\t\t{\n\t\t\t//dp[i][j][i+tate-1][j+yoko-1]\n\t\t\t//単体で何とかなるか確かめる\n\t\t\tint yutori=(rui[i+tate][j+yoko]-rui[i+tate][j]-rui[i][j+yoko]+rui[i][j])-(rui[h][w]-s);\n\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<tate<<\" \"<<yoko<<\" \"<<yutori<<endl;\n\t\t\tif(yutori<0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tdp[i][j][i+tate-1][j+yoko-1]=P(1,yutori);\n\t\t\t//縦に分ける\n\t\t\tfor(int k=1;k<tate;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][i+tate-1][j+yoko-1]=max(dp[i][j][i+tate-1][j+yoko-1],dp[i][j][i+k-1][j+yoko-1]+dp[i+k][j][i+tate-1][j+yoko-1]);\n\t\t\t\t//cerr<<(dp[i][j][i+k-1][j+yoko-1]+dp[i+k][j][i+tate-1][j+yoko-1]).first<<endl;\n\t\t\t}\n\t\t\t//横に分ける\n\t\t\tfor(int k=1;k<yoko;k++)\n\t\t\t\tdp[i][j][i+tate-1][j+yoko-1]=max(dp[i][j][i+tate-1][j+yoko-1],dp[i][j][i+tate-1][j+k-1]+dp[i][j+k][i+tate-1][j+yoko-1]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin>>h>>w>>s;\n\t\tif(h==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>u[i][j];\n\t\t}\n\t\t//累積和の計算\n\t\trui[0][0]=0;\n\t\tfor(int i=1;i<w+1;i++)\n\t\t\trui[0][i]=0;\n\t\tfor(int i=1;i<h+1;i++)\n\t\t\trui[i][0]=0;\n\t\tfor(int i=1;i<h+1;i++)\n\t\t{\n\t\t\tfor(int j=1;j<w+1;j++)\n\t\t\t\trui[i][j]=rui[i][j-1]+u[i-1][j-1];\n\t\t}\n\t\tfor(int j=1;j<w+1;j++)\n\t\t{\n\t\t\tfor(int i=1;i<h+1;i++)\n\t\t\t\trui[i][j]+=rui[i-1][j];\n\t\t}\n\t\t//ここまで累積和\n\t\tfill(dp[0][0][0],dp[32][0][0],P(-999,-1e8+1));\n\t\tfor(int i=1;i<h+1;i++)\n\t\t{\n\t\t\tfor(int j=1;j<w+1;j++)\n\t\t\t\tmemo(i,j);\n\t\t}\n\t\tcout<<dp[0][0][h-1][w-1].first<<\" \"<<dp[0][0][h-1][w-1].second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rng(x1, y1, x2, y2) (sum[y2][x2] + sum[y1][x1] - sum[y2][x1] - sum[y1][x2])\nusing namespace std;\nint H, W, ra, o, a[40][40], sum[40][40], dp[40][40][40][40];\nint solve(int x1, int y1, int x2, int y2) {\n\tif (dp[y1][x1][y2][x2] != -1) return dp[y1][x1][y2][x2];\n\tint rng_ = rng(x1, y1, x2, y2);\n\tint ret = 1000000 + rng_;\n\tfor (int i = x1 + 1; i < x2; i++) {\n\t\tint petl = rng(x1, y1, i, y2);\n\t\tint petr = rng(i, y1, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, i, y2);\n\t\t\tint resr = solve(i, y1, x2, y2);\n\t\t\tint res = (resl + resr) / 1000000 * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\tfor (int i = y1 + 1; i < y2; i++) {\n\t\tint petl = rng(x1, y1, x2, i);\n\t\tint petr = rng(x1, i, x2, y2);\n\t\tif (min(petl, petr) >= o) {\n\t\t\tint resl = solve(x1, y1, x2, i);\n\t\t\tint resr = solve(x1, i, x2, y2);\n\t\t\tint res = (resl + resr) / 1000000 * 1000000 + min(resl % 1000000, resr % 1000000);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\treturn dp[y1][x1][y2][x2] = ret;\n}\nint main() {\n\twhile (cin >> H >> W >> ra, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) dp[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = sum[H][W] - ra;\n\t\tint ret = solve(0, 0, W, H);\n\t\tcout << ret / 1000000 << ' ' << ret % 1000000 - o << endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint m[40][40],d[40][40][40][40],e[40][40][40][40],h,w,n;\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\nint f(int a,int b,int c,int d){return m[a][b]+m[c][d]-m[c][b]-m[a][d];}\nint main(){\n\tint i,j,k,l,a;\n\twhile(scanf(\"%d %d %d\",&h,&w,&n),h){\n\t\tfor(i=0;i<40*40;i++){\n\t\t\tfor(j=0;j<40*40;j++)d[i/40][i%40][j/40][j%40]=-1e9;\n\t\t\tfor(j=0;j<40*40;j++)e[i/40][i%40][j/40][j%40]=0;\n\t\t\tm[i/40][i%40]=0;\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\" %d\",&a);\n\t\t\t\tm[i+1][j+1]=m[i+1][j]+m[i][j+1]-m[i][j]+a;//printf(\"%d \",m[i+1][j+1]);\n\t\t\t}//printf(\"\\n\");\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tfor(k=0;k+i<=h;k++){\n\t\t\t\t\tfor(l=0;l+j<=w;l++){//printf(\"%d,\",f(k,l,k+i,l+j));\n\t\t\t\t\t\tif(m[h][w]-f(k,l,k+i,l+j)<=n){\n\t\t\t\t\t\t\tif(d[k][l][k+i][l+j]<2){\n\t\t\t\t\t\t\t\td[k][l][k+i][l+j]=1;\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MAX(e[k][l][k+i][l+j],m[h][w]-f(k,l,k+i,l+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(a=k+1;a<k+i;a++){\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]<    d[k][l][a][l+j]+d[a][l][k+i][l+j]){\n\t\t\t\t\t\t\t\td[k][l][k+i][l+j]=    d[k][l][a][l+j]+d[a][l][k+i][l+j];\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MAX(e[k][l][a][l+j],e[a][l][k+i][l+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]==                         d[k][l][a][l+j]+d[a][l][k+i][l+j]){\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MIN(e[k][l][k+i][l+j],MAX(e[k][l][a][l+j],e[a][l][k+i][l+j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(a=l+1;a<l+j;a++){\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]<d[k][l][k+i][a]+d[k][a][k+i][l+j]){\n\t\t\t\t\t\t\t\td[k][l][k+i][l+j]=d[k][l][k+i][a]+d[k][a][k+i][l+j];\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MAX(e[k][l][k+i][a],e[k][a][k+i][l+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]==d[k][l][k+i][a]+d[k][a][k+i][l+j]){\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MIN(e[k][l][k+i][l+j],MAX(e[k][l][k+i][a],e[k][a][k+i][l+j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}//printf(\"%d %d:\",d[k][l][k+i][l+j],e[k][l][k+i][l+j]);\n\t\t\t\t\t}//printf(\"\\n\");\n\t\t\t\t}//printf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",d[0][0][h][w],n-e[0][0][h][w]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint m[40][40],d[40][40][40][40],e[40][40][40][40],h,w,n;\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\nint f(int a,int b,int c,int d){return m[a][b]+m[c][d]-m[c][b]-m[a][d];}\nint main(){\n\tint i,j,k,l,a;\n\twhile(scanf(\"%d %d %d\",&h,&w,&n),h){\n\t\tfor(i=0;i<40*40;i++){\n\t\t\tfor(j=0;j<40*40;j++)d[i/40][i%40][j/40][j%40]=-1e9;\n\t\t\tfor(j=0;j<40*40;j++)e[i/40][i%40][j/40][j%40]=-1e9;\n\t\t\tm[i/40][i%40]=0;\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\" %d\",&a);\n\t\t\t\tm[i+1][j+1]=m[i+1][j]+m[i][j+1]-m[i][j]+a;//printf(\"%d \",m[i+1][j+1]);\n\t\t\t}//printf(\"\\n\");\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tfor(k=0;k+i<=h;k++){\n\t\t\t\t\tfor(l=0;l+j<=w;l++){//printf(\"%d,\",f(k,l,k+i,l+j));\n\t\t\t\t\t\tif(m[h][w]-f(k,l,k+i,l+j)<=n){\n\t\t\t\t\t\t\td[k][l][k+i][l+j]=MAX(d[k][l][k+i][l+j],1);\n\t\t\t\t\t\t\te[k][l][k+i][l+j]=MAX(e[k][l][k+i][l+j],n-(m[h][w]-f(k,l,k+i,l+j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(a=k+1;a<k+i;a++){\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]<d[k][l][a][l+j]+d[a][l][k+i][l+j]){\n\t\t\t\t\t\t\t\td[k][l][k+i][l+j]=d[k][l][a][l+j]+d[a][l][k+i][l+j];\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MIN(e[k][l][a][l+j],e[a][l][k+i][l+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]==d[k][l][a][l+j]+d[a][l][k+j][l+j]){\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MAX(e[k][l][k+i][l+j],MIN(e[k][l][a][l+j],e[a][l][k+i][l+j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(a=l+1;a<l+j;a++){\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]<d[k][l][k+i][a]+d[k][a][k+i][l+j]){\n\t\t\t\t\t\t\t\td[k][l][k+i][l+j]=d[k][l][k+i][a]+d[k][a][k+i][l+j];\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MIN(e[k][l][k+i][a],e[k][a][k+i][l+j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( d[k][l][k+i][l+j]==d[k][l][k+i][a]+d[k][a][k+i][l+j]){\n\t\t\t\t\t\t\t\te[k][l][k+i][l+j]=MAX(e[k][l][k+i][l+j],MIN(e[k][l][k+i][a],e[k][a][k+i][l+j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}//printf(\"%d %d:\",d[k][l][k+i][l+j],e[k][l][k+i][l+j]);\n\t\t\t\t\t}//printf(\"\\n\");\n\t\t\t\t}//printf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",d[0][0][h][w],e[0][0][h][w]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) (x)<(y)?(x):(y)\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\ntypedef struct{\n    int group;\n    int spare;\n}Data;\nint h,w,s,all,t[32][32];\nint rec[32][32][32][32];\nData dp[32][32][32][32];\nData max(Data x,Data y){\n    if(x.group<y.group) return y;\n    else if(x.group==y.group){\n        if(x.spare<y.spare) return y;\n        else return x;\n    }\n    else return x;\n}\nvoid mkRec(){\n    memset(rec,0,sizeof(rec));\n    rep(i,h){\n        rep(j,w){\n            rec[i][j][i][j]=t[i][j];\n            for(int y=i-1;y>=0;y--)\n                rec[y][j][i][j]=rec[y+1][j][i][j]+t[y][j];\n            for(int y=i;y>=0;y--){\n                int sum=0;\n                for(int x=j;x>=0;x--){\n                    sum+=rec[y][x][i][x];\n                    rec[y][x][i][j]=sum;\n                }\n            }\n        }\n    }\n}\nData dfs(int lx,int ly,int hx,int hy){\n    if(dp[ly][lx][hy][hx].group!=0) return dp[ly][lx][hy][hx];\n    Data res={1,s-(all-rec[ly][lx][hy][hx])};\n    for(int i=ly;i<hy;i++){\n        if(all-rec[ly][lx][i][hx]>s ||\n           all-rec[i+1][lx][hy][hx]>s) continue;\n        Data a=dfs(lx,ly,hx,i);\n        Data b=dfs(lx,i+1,hx,hy);\n        Data cal={a.group+b.group,min(a.spare,b.spare)};\n        res=max(res,cal);\n    }\n    for(int j=lx;j<hx;j++){\n        if(all-rec[ly][lx][hy][j]>s ||\n           all-rec[ly][j+1][hy][hx]>s) continue;\n        Data a=dfs(lx,ly,j,hy);\n        Data b=dfs(j+1,ly,hx,hy);\n        Data cal={a.group+b.group,min(a.spare,b.spare)};\n        res=max(res,cal);\n    }\n    return dp[ly][lx][hy][hx]=res;\n}\nint main(){\n    while(1){\n        scanf(\"%d%d%d\",&h,&w,&s);\n        all=0;\n        if(h+w+s==0) break;\n        rep(i,h){\n            rep(j,w){\n                scanf(\"%d\",&t[i][j]);\n                all+=t[i][j];\n            }\n        }\n        mkRec();\n        memset(dp,0,sizeof(dp));\n        Data d=dfs(0,0,w-1,h-1);\n        printf(\"%d %d\\n\",d.group,d.spare);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1176: Planning Rolling Blackouts\n// 2018.1.9 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint S;\nint sum;\nint u[34][34], s[34][34];\nint memo[34][34][34][34][2];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid calc(int h, int w)\n{\n\tint i, j;\n\tmemset(s, 0, sizeof(s));\n\tfor (i = 0; i <  h; i++) for (j = 0; j <  w; j++) s[i+1][j+1]  = u[i][j];\n\tfor (i = 0; i <= h; i++) for (j = 0; j <  w; j++) s[i  ][j+1] += s[i][j];\n\tfor (i = 0; i <  h; i++) for (j = 0; j <= w; j++) s[i+1][j  ] += s[i][j];\n}\n\nint rect(int i1, int j1, int i2, int j2)\n{\n    return s[i2+1][j2+1] - s[i2+1][j1] - s[i1][j2+1] + s[i1][j1];\n}\n\nvoid rec(int *xx, int *yy, int i1, int j1, int i2, int j2)\n{\n\tint i, j, x, y, x1, y1, x2, y2;\n\n\tif (memo[i1][j1][i2][j2][0]) {\n\t\t*xx = memo[i1][j1][i2][j2][0], *yy = memo[i1][j1][i2][j2][1]; return;\n\t}\n    \n\tx = 1, y = S - sum + rect(i1, j1, i2, j2);\n\n\tfor (j = j1; j < j2; j++) {\n\t\tif (S - sum + rect(i1, j1,  i2, j ) < 0) continue;\n\t\tif (S - sum + rect(i1, j+1, i2, j2) < 0) continue;\n\t\trec(&x1, &y1, i1, j1 , i2, j );\n\t\trec(&x2, &y2, i1, j+1, i2, j2);\n\t\tif (x1+x2 > x) {\n\t\t\tx = x1+x2;\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y1 < y ) y  = y1;\n\t\t} else if (x1+x2 == x) {\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y1 > y ) y  = y1;\n\t\t}\n    }\n\n\tfor (i = i1; i < i2; i++) {\n\t\tif (S - sum + rect(i1 , j1, i , j2) < 0) continue;\n\t\tif (S - sum + rect(i+1, j1, i2, j2) < 0) continue;\n\t\trec(&x1, &y1, i1 , j1, i,  j2);\n\t\trec(&x2, &y2, i+1, j1, i2, j2);\n\t\tif (x1+x2 > x) {\n\t\t\tx = x1+x2;\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y1 < y ) y  = y1;\n\t\t} else if (x1+x2 == x) {\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y1 > y ) y  = y1;\n\t\t}\n\t}\n\t*xx = memo[i1][j1][i2][j2][0] = x, *yy = memo[i1][j1][i2][j2][1] = y;\n}\n\nint main(void)\n{\n\tint h, w, t, i, j, ans1, ans2;\n\n\twhile (h = in()) {\n\t\tw = in(), S = in();\n\t\tsum = 0; for (i = 0; i < h; i++) for (j = 0; j < w; j++) u[i][j] = t = in(), sum += t;\n        calc(h, w);\n\t\tmemset(memo, 0, sizeof(memo));\n        rec(&ans1, &ans2, 0, 0, h - 1, w - 1);\n        printf(\"%d %d\\n\", ans1, ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1176: Planning Rolling Blackouts\n// 2018.1.9 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint S, sum;\nint u[34][34], s[34][34];\nint memo[34][34][34][34][2];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n//\twhile (c < '0') c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid calc(int h, int w)\n{\n\tint r, c;\n\tmemset(s, 0, sizeof(s));\n\tfor (r = 0; r <  h; r++) for (c = 0; c <  w; c++) s[r+1][c+1]  = u[r][c];\n\tfor (r = 0; r <= h; r++) for (c = 0; c <  w; c++) s[r  ][c+1] += s[r][c];\n\tfor (r = 0; r <  h; r++) for (c = 0; c <= w; c++) s[r+1][c  ] += s[r][c];\n}\n\nint rect(int r1, int c1, int r2, int c2)\n{\n    return s[r2+1][c2+1] - s[r2+1][c1] - s[r1][c2+1] + s[r1][c1];\n}\n\nvoid rec(int *xx, int *yy, int r1, int c1, int r2, int c2)\n{\n\tint r, c, x, y, x1, y1, x2, y2;\n\n\tif (memo[r1][c1][r2][c2][0]) {\n\t\t*xx = memo[r1][c1][r2][c2][0], *yy = memo[r1][c1][r2][c2][1]; return;\n\t}\n    \n\tx = 1, y = S - sum + rect(r1, c1, r2, c2);\n\n\tfor (r = r1; r < r2; r++) {\n\t\tif (S - sum + rect(r1 , c1, r , c2) < 0) continue;\n\t\tif (S - sum + rect(r+1, c1, r2, c2) < 0) continue;\n\t\trec(&x1, &y1, r1 , c1, r,  c2);\n\t\trec(&x2, &y2, r+1, c1, r2, c2);\n\t\tif (x < x1+x2) {\n\t\t\tx = x1+x2;\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y  > y1) y  = y1;\n\t\t} else if (x == x1+x2) {\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y  < y1) y  = y1;\n\t\t}\n\t}\n\tfor (c = c1; c < c2; c++) {\n\t\tif (S - sum + rect(r1, c1,  r2, c ) < 0) continue;\n\t\tif (S - sum + rect(r1, c+1, r2, c2) < 0) continue;\n\t\trec(&x1, &y1, r1, c1 , r2, c );\n\t\trec(&x2, &y2, r1, c+1, r2, c2);\n\t\tif (x < x1+x2) {\n\t\t\tx = x1+x2;\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y  > y1) y  = y1;\n\t\t} else if (x == x1+x2) {\n\t\t\tif (y1 > y2) y1 = y2;\n\t\t\tif (y  < y1) y  = y1;\n\t\t}\n    }\n\n\t*xx = memo[r1][c1][r2][c2][0] = x, *yy = memo[r1][c1][r2][c2][1] = y;\n}\n\nint main(void)\n{\n\tint h, w, r, c, ans1, ans2;\n\n\twhile (h = in()) {\n\t\tw = in(), S = in();\n\t\tsum = 0; for (r = 0; r < h; r++) for (c = 0; c < w; c++) sum += u[r][c] = in();\n\t\tmemset(memo, 0, sizeof(memo));\n        calc(h, w);\n        rec(&ans1, &ans2, 0, 0, h - 1, w - 1);\n        printf(\"%d %d\\n\", ans1, ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void print(int[][] array){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tfor(int j = 0; j < array[i].length; j++){\n\t\t\t\tSystem.out.printf(\"%03d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static int calc_area(final int s_x, final int s_y, final int g_x, final int g_y, int[][] sums){\n\t\tif(s_x == 0 && s_y == 0){\n\t\t\treturn sums[g_y][g_x];\n\t\t}else if(s_x == 0){\n\t\t\treturn sums[g_y][g_x] - sums[s_y - 1][g_x];\n\t\t}else if(s_y == 0){\n\t\t\treturn sums[g_y][g_x] - sums[g_y][s_x - 1];\n\t\t}else{\n\t\t\treturn sums[g_y][g_x] - sums[g_y][s_x - 1] - sums[s_y - 1][g_x] + sums[s_y - 1][s_x - 1];\n\t\t}\n\t}\n\t\n\tpublic static int dfs(final int s_x, final int s_y, final int g_x, final int g_y, final int max, final int sup, int[][] sums, int[][][][] memo, int[][][][] min){\n\t\tif(memo[s_y][s_x][g_y][g_x] >= 0){\n\t\t\treturn memo[s_y][s_x][g_y][g_x];\n\t\t}\n\t\t\n\t\t//System.out.println(s_x + \" \" + s_y + \" \" + g_x + \" \" + g_y);\n\t\t\n\t\tfinal int this_area = calc_area(s_x, s_y, g_x, g_y, sums);\n\t\tfinal int diff = max - sup;\n\t\t\n\t\tif(diff > this_area){\n\t\t\treturn memo[s_y][s_x][g_y][g_x] = 0;\n\t\t}else if(s_x == g_x && s_y == g_y){\n\t\t\tmin[s_y][s_x][g_y][g_x] = max - this_area;\n\t\t\treturn memo[s_y][s_x][g_y][g_x] = 1;\n\t\t}\n\t\t//System.out.println(s_x + \" \" + s_y + \" \" + g_x + \" \" + g_y + \" =>\" + calc_area(s_x, s_y, g_x, g_y, sums) + \" , \" + diff);\n\t\t\n\t\tint ret = 0;\n\t\t\n\t\tfor(int sp_x = s_x + 1; sp_x <= g_x; sp_x++){\n\t\t\tfinal int left_ret  = dfs(s_x , s_y, sp_x - 1, g_y, max, sup, sums, memo, min);\n\t\t\tfinal int right_ret = dfs(sp_x, s_y, g_x     , g_y, max, sup, sums, memo, min);\n\t\t\t\n\t\t\t//System.out.println(\"h : \" + s_x + \" \" + sp_x + \" \" + g_x + \" ( \" + s_y  + \", \" + g_y + \" ) =>\" + left_ret + \" , \" + right_ret);\n\t\t\t\n\t\t\tif(left_ret == 0 || right_ret == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int new_group = left_ret + right_ret;\n\t\t\tfinal int new_min = Math.max(min[s_y][s_x][g_y][sp_x - 1], min[s_y][sp_x][g_y][g_x]);\n\t\t\tif(ret <= new_group){\n\t\t\t\tif(ret < new_group || min[s_y][s_x][g_y][g_x] > new_min){\n\t\t\t\t\tmin[s_y][s_x][g_y][g_x] = new_min;\n\t\t\t\t\tret = new_group;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int sp_y = s_y + 1; sp_y <= g_y; sp_y++){\n\t\t\tfinal int up_ret   = dfs(s_x, s_y , g_x, sp_y - 1, max, sup, sums, memo, min);\n\t\t\tfinal int down_ret = dfs(s_x, sp_y, g_x, g_y     , max, sup, sums, memo, min);\n\t\t\t\n\t\t\t//System.out.println(\"v : \" + s_y + \" \" + sp_y + \" \" + g_y + \" ( \" + s_x + \",\" + g_x + \" ) =>\" + up_ret + \" , \" + down_ret);\n\t\t\t\n\t\t\tif(up_ret == 0 || down_ret == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int new_group = up_ret + down_ret;\n\t\t\tfinal int new_min = Math.max(min[s_y][s_x][sp_y - 1][g_x], min[sp_y][s_x][g_y][g_x]);\n\t\t\tif(ret <= new_group){\n\t\t\t\tif(ret < new_group || min[s_y][s_x][g_y][g_x] > new_min){\n\t\t\t\t\tmin[s_y][s_x][g_y][g_x] = new_min;\n\t\t\t\t\tret = new_group;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(ret <= 0){\n\t\t\tmin[s_y][s_x][g_y][g_x] = max - this_area;\n\t\t\treturn memo[s_y][s_x][g_y][g_x] = 1;\n\t\t}else{\n\t\t\treturn memo[s_y][s_x][g_y][g_x] = ret;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && s == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] input = new int[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tinput[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 1; j < w; j++){\n\t\t\t\t\tinput[i][j] += input[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int i = 1; i < h; i++){\n\t\t\t\t\tinput[i][j] += input[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//print(input);\n\t\t\t\n\t\t\tint[][][][] memo = new int[h][w][h][w];\n\t\t\tint[][][][] min  = new int[h][w][h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\t\tfor(int l = 0; l < w; l++){\n\t\t\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t\t\t\tmin[i][j][k][l] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, 0, w - 1, h - 1, input[h-1][w-1], s, input, memo, min) + \" \" + (s - min[0][0][h-1][w-1]));\n\t\t\t\n\t\t\t//print(min[0][0]);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n    Scanner sc=new Scanner(System.in);\n    static int h;\n    static int w;\n    static int mandatory;\n    static int[][][][] sumArr;\n    static int [][]arr;\n    static int[][][][] Divdone;\n    static int[][][][] Remdone;\n\t\n\tprivate void cal(){\n\t\t\n\t\twhile(true){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\t\n\t\tint reserve=sc.nextInt();\n\t\t\n\t\tif(h==0 && w==0 && reserve==0)\n\t\t\tbreak;\n\t\t\n\t\tarr=new int[h][w];\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tarr[i][j]=sc.nextInt();\n\t\t\n\t\tsumArr=new int[h][w][h][w];\n\t\tDivdone=new int[h][w][h][w];\n\t\tRemdone=new int[h][w][h][w];\n\t\t\n\t       for(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t    for(int p=0;p<w;p++){\n\t\t\t\t\t    sumArr[i][j][k][p]=-1;\n\t\t\t\t\t    Divdone[i][j][k][p]=-1;\n\t\t\t\t\t    Remdone[i][j][k][p]=-1;\n\t\t\t\t    }\n\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t\tfor(int p=0;p<w;p++){\n\t\t\t\t\t\tint temp=0;\n\t\t\t\t\t\tif(i<=k && j<=p)\n\t\t\t\t\t\t\tfor(int z=i;z<=k;z++)\n\t\t\t\t\t\t\t\tfor(int x=j;x<=p;x++)\n\t\t\t\t\t\t\t\t\ttemp+=arr[z][x];\n\t\t\t\t\t\tsumArr[i][j][k][p]=temp;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\tmandatory=sumArr[0][0][h-1][w-1]-reserve;\n\t\t\n\t\tint[] tmp=new int[2];\n\t\ttmp=cut(0,0,h-1,w-1);\n\t\tSystem.out.println(tmp[0]+\" \"+tmp[1]);\n\t\t\n\t\t\n\n\t\t}\n\t\t\n\t}\n\n\n\tpublic int[] cut(int a,int b,int c, int d){\n\t\tint maxDiv=1;\n\t\tint rem=0;\n\t\tif(Divdone[a][b][c][d]==-1 && Remdone[a][b][c][d]==-1){\n\t\t   \t    \n\t\tfor(int i=a;i<c;i++){\n\t\t\tif(sumArr[a][b][i][d]>=mandatory && sumArr[i+1][b][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][i][d]==-1 && Remdone[a][b][i][d]==-1){\n\t\t\t\t\tint[] temp1=cut(a,b,i,d);\n\t\t\t\t\tDivdone[a][b][i][d]=temp1[0];\n\t\t\t\t\tRemdone[a][b][i][d]=temp1[1];\n\t\t\t\t}\n\t\t\t\tif(Divdone[i+1][b][c][d]==-1 && Remdone[i+1][b][c][d]==-1){\n\t\t\t\t\tint[] temp2=cut(i+1,b,c,d);\n\t\t\t\t\tDivdone[i+1][b][c][d]=temp2[0];\n\t\t\t\t\tRemdone[i+1][b][c][d]=temp2[1];\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][i][d]+Divdone[i+1][b][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d])>rem){\n\t\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfor(int i=b;i<d;i++)\n\t\t\tif(sumArr[a][b][c][i]>=mandatory && sumArr[a][i+1][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][c][i]==-1 && Remdone[a][b][c][i]==-1){\n\t\t\t\t\tint[] temp1=cut(a,b,c,i);\n\t\t\t\t\tDivdone[a][b][c][i]=temp1[0];\n\t\t\t\t\tRemdone[a][b][c][i]=temp1[1];\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][i+1][c][d]==-1 && Remdone[a][i+1][c][d]==-1){\n\t\t\t\t\tint[] temp2=cut(a,i+1,c,d);\n\t\t\t\t\tDivdone[a][i+1][c][d]=temp2[0];\n\t\t\t\t\tRemdone[a][i+1][c][d]=temp2[1];\n\t\t\t\t}\t\t\t\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][c][i]+Divdone[a][i+1][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d])>rem){\n\t\t\t\t    rem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\treturn maxDiv==1? new int[]{1,sumArr[a][b][c][d]-mandatory}:new int[]{maxDiv,rem};}\n\t\t\telse\n\t\t\t    return new int[]{Divdone[a][b][c][d],Remdone[a][b][c][d]};\n\t\t\t\n\t\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] argv){\n\t\tnew Main().cal();\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[2];\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = new int[] { -1, -1 };\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tint H;\n\tint W;\n\tint S;\n\tint[][] map;\n\tint[][] sum;\n\tPair[][][][] dp;\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tH = nextInt();\n\t\t\tW = nextInt();\n\t\t\tS = nextInt();\n\t\t\tif (H == 0) break;\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tsum = new int[H + 1][W + 1];\n\t\t\tdp = new Pair[H][H + 1][W][W + 1];\n\t\t\tfor(int r = 0; r < H; r++){\n\t\t\t\tfor(int c = 0; c < W; c++){\n\t\t\t\t\tmap[r][c] = nextInt();\n\t\t\t\t\tsum[r + 1][c + 1] = sum[r + 1][c] + sum[r][c + 1] - sum[r][c] + map[r][c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(recur(0, H, 0, W));\n\t\t}\n\t}\n\tpublic Pair recur(int r1, int r2, int c1, int c2){\n\t\tint s = sum[r2][c2] - sum[r2][c1] - sum[r1][c2] + sum[r1][c1];\n\t\tif(sum[H][W] - s > S) return null;\n\t\tif(dp[r1][r2][c1][c2] != null) return dp[r1][r2][c1][c2];\n\t\t\n\t\t//System.err.printf(\"%d %d %d %d\\n\", r1, r2, c1, c2);\n\t\tPair ans = new Pair(1, S - (sum[H][W] - s));\n\t\tfor(int r = r1 + 1; r < r2; r++){\n\t\t\tPair a = recur(r1, r, c1, c2);\n\t\t\tPair b = recur(r, r2, c1, c2);\n\t\t\tif(a != null && b != null){\n\t\t\t\tans = ans.max(a.add(b));\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tfor(int c = c1 + 1; c < c2; c++){\n\t\t\tPair a = recur(r1, r2, c1, c);\n\t\t\tPair b = recur(r1, r2, c, c2);\n\t\t\tif(a != null && b != null){\n\t\t\t\tans = ans.max(a.add(b));\n\t\t\t}\n\t\t}\n\t\t//System.err.println(\"---\");\n\t\treturn dp[r1][r2][c1][c2] = ans;\n\t}\n\t\n\tclass Pair implements Comparable<Pair>{\n\t\tfinal int group;\n\t\tfinal int yojo;\n\t\tpublic Pair(int group, int yojo){\n\t\t\tthis.group = group;\n\t\t\tthis.yojo = yojo;\n\t\t}\n\t\t\n\t\tpublic Pair max(Pair p){\n\t\t\tif(this.compareTo(p) <= 0){\n\t\t\t\treturn this;\n\t\t\t}else{\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int compareTo(Pair p){\n\t\t\tif(group == p.group){\n\t\t\t\treturn Integer.compare(p.yojo, yojo);\n\t\t\t}else{\n\t\t\t\treturn Integer.compare(p.group, group);\n\t\t\t}\n\t\t}\n\t\tpublic Pair add(Pair p){\n\t\t\treturn new Pair(group + p.group, Math.min(yojo, p.yojo));\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn group + \" \" + yojo;\n\t\t}\n\t}\n\t\n\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\n\tpublic static int nextInt() {\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static long nextLong() {\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static String next() {\n\t\tint c;\n\t\twhile (!isAlNum(c = read())) {\n\t\t}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char) c);\n\t\twhile (isAlNum(c = read())) {\n\t\t\tbuild.append((char) c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\n\tprivate static int read() {\n\t\tif (bufferLength < 0)\n\t\t\tthrow new RuntimeException();\n\t\tif (bufferIndex >= bufferLength) {\n\t\t\ttry {\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufferLength <= 0)\n\t\t\t\treturn (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\n\tprivate static boolean isAlNum(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tstatic int[][] u = null;\n\tstatic Pair[] memo = new Pair[1<<20];\n\tstatic int need = 0;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint h = io.nextInt();\n\t\t\tint w = io.nextInt();\n\t\t\tint s = io.nextInt();\n\t\t\tif (h == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tu = new int[h+1][w+1];\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tu[i][j] = io.nextInt();\n\t\t\t\t\tsum += u[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tu[i][j] += u[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\t\tu[i][j] += u[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed = sum - s;\n\t\t\tArrays.fill(memo, null);\n\t\t\tPair ans = dfs(pack(0,0,h-1,w-1));\n\t\t\tio.println(ans.groups + \" \" + (s - sum + ans.maxmin));\n\t\t}\n\t\tio.flush();\n\t}\n\tstatic final Pair NEGINF = new Pair(-1,-1);\n\tprivate static Pair dfs(int pack) {\n\t\tif (memo[pack] != null) {\n\t\t\treturn memo[pack];\n\t\t}\n\t\tint i1 = pack & 0x1F;\n\t\tint j1 = pack >> 5 & 0x1F;\n\t\tint i2 = pack >> 10 & 0x1F;\n\t\tint j2 = pack >> 15 & 0x1F;\n\t\tint sum = u[i2+1][j2+1] - u[i1][j2+1] - u[i2+1][j1] + u[i1][j1];\n//\t\tSystem.out.println(i1 + \",\" + j1 + \",\" + i2 + \",\" + j2 + \": \" + sum);\n\t\tif (sum < need) {\n//\t\t\tSystem.out.println(i1 + \",\" + j1 + \",\" + i2 + \",\" + j2 + \": -INF\");\n\t\t\treturn memo[pack] = NEGINF;\n\t\t}\n\t\tPair p = new Pair(1,sum);\n\t\tfor(int i=i1;i<i2;i++) {\n\t\t\tp = p.max(dfs(pack(i1,j1,i,j2)).add(dfs(pack(i+1,j1,i2,j2))));\n\t\t}\n\t\tfor(int j=j1;j<j2;j++) {\n\t\t\tp = p.max(dfs(pack(i1,j1,i2,j)).add(dfs(pack(i1,j+1,i2,j2))));\n\t\t}\n//\t\tSystem.out.println(i1 + \",\" + j1 + \",\" + i2 + \",\" + j2 + \": \" + p);\n\t\treturn memo[pack] = p;\n\t}\n\tstatic int pack(int i1,int j1,int i2,int j2) {\n\t\treturn i1 | j1 << 5 | i2 << 10 | j2 << 15;\n\t}\n\tstatic class Pair {\n\t\tint groups, maxmin;\n\t\tpublic Pair(int groups,int maxmin) {\n\t\t\tthis.groups = groups;\n\t\t\tthis.maxmin = maxmin;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + groups + \",\" + maxmin + \")\";\n\t\t}\n\t\tpublic Pair max(Pair p) {\n\t\t\tif (groups > p.groups) {\n\t\t\t\treturn this;\n\t\t\t}else if(groups < p.groups) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\tif (maxmin >= p.maxmin) {\n\t\t\t\treturn this;\n\t\t\t}else{\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\tpublic Pair add(Pair p) {\n\t\t\treturn new Pair(groups + p.groups, Math.min(maxmin, p.maxmin));\n\t\t}\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    Scanner sc=new Scanner(System.in);\n    static int h;\n    static int w;\n    static int mandatory;\n    static int[][][][] sumArr;\n    static int [][]arr;\n    static int[][][][] Divdone;\n    static int[][][][] Remdone;\n\t\n\tprivate void cal(){\n\t\t\n\t\twhile(true){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\t\n\t\tint reserve=sc.nextInt();\n\t\t\n\t\tif(h==0)\n\t\t\tbreak;\n\t\t\n\t\tarr=new int[h][w];\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tarr[i][j]=sc.nextInt();\n\t\t\n\t\tsumArr=new int[h][w][h][w];\n\t\tDivdone=new int[h][w][h][w];\n\t\tRemdone=new int[h][w][h][w];\n\t\t\n\t       for(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t    for(int p=0;p<w;p++){\n\t\t\t\t\t    sumArr[i][j][k][p]=-1;\n\t\t\t\t\t    Divdone[i][j][k][p]=-1;\n\t\t\t\t\t    Remdone[i][j][k][p]=-1;\n\t\t\t\t    }\n\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t\tfor(int p=0;p<w;p++){\n\t\t\t\t\t\tint temp=0;\n\t\t\t\t\t\tif(i<=k && j<=p)\n\t\t\t\t\t\t\tfor(int z=i;z<=k;z++)\n\t\t\t\t\t\t\t\tfor(int x=j;x<=p;x++)\n\t\t\t\t\t\t\t\t\ttemp+=arr[z][x];\n\t\t\t\t\t\tsumArr[i][j][k][p]=temp;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\tmandatory=sumArr[0][0][h-1][w-1]-reserve;\n\t\t\n\t\tint[] tmp=new int[2];\n\t\ttmp=cut(0,0,h-1,w-1);\n\t\tSystem.out.println(tmp[0]+\" \"+tmp[1]);\n\t\t\n\t\t\n\n\t\t}\n\t\t\n\t}\n\n\n\tpublic int[] cut(int a,int b,int c, int d){\n\t\tint maxDiv=1;\n\t\tint rem=0;\n\t\tif(Divdone[a][b][c][d]==-1 && Remdone[a][b][c][d]==-1){\n\t\t   \t    \n\t\tfor(int i=a;i<c;i++){\n\t\t\tif(sumArr[a][b][i][d]>=mandatory && sumArr[i+1][b][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][i][d]==-1 && Remdone[a][b][i][d]==-1){\n\t\t\t\t\tint[] temp1=cut(a,b,i,d);\n\t\t\t\t\tDivdone[a][b][i][d]=temp1[0];\n\t\t\t\t\tRemdone[a][b][i][d]=temp1[1];\n\t\t\t\t}\n\t\t\t\tif(Divdone[i+1][b][c][d]==-1 && Remdone[i+1][b][c][d]==-1){\n\t\t\t\t\tint[] temp2=cut(i+1,b,c,d);\n\t\t\t\t\tDivdone[i+1][b][c][d]=temp2[0];\n\t\t\t\t\tRemdone[i+1][b][c][d]=temp2[1];\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][i][d]+Divdone[i+1][b][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d])>rem){\n\t\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfor(int i=b;i<d;i++)\n\t\t\tif(sumArr[a][b][c][i]>=mandatory && sumArr[a][i+1][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][c][i]==-1 && Remdone[a][b][c][i]==-1){\n\t\t\t\t\tint[] temp1=cut(a,b,c,i);\n\t\t\t\t\tDivdone[a][b][c][i]=temp1[0];\n\t\t\t\t\tRemdone[a][b][c][i]=temp1[1];\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][i+1][c][d]==-1 && Remdone[a][i+1][c][d]==-1){\n\t\t\t\t\tint[] temp2=cut(a,i+1,c,d);\n\t\t\t\t\tDivdone[a][i+1][c][d]=temp2[0];\n\t\t\t\t\tRemdone[a][i+1][c][d]=temp2[1];\n\t\t\t\t}\t\t\t\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][c][i]+Divdone[a][i+1][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d])>rem){\n\t\t\t\t    rem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\treturn maxDiv==1? new int[]{1,sumArr[a][b][c][d]-mandatory}:new int[]{maxDiv,rem};}\n\t\t\telse\n\t\t\t    return new int[]{Divdone[a][b][c][d],Remdone[a][b][c][d]};\n\t\t\t\n\t\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] argv){\n\t\tnew Main().cal();\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int h, w, s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\th = ir.nextInt();\n\t\t\tw = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[] { -1, -1 };\n\t\tint t = sum[h][w] - sum(lh, lw, rh, rw, sum);\n\t\tif (t <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = ret;\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4thJun\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().doIt();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\tvoid doIt(){\n\t\tnew AOJ1169();\n\t}\n\t\n\tclass AOJ1169{\n\t\tint s,W,H,sum;\n\t\tint[][] a,aa;\n\t\tAOJ1169(){\n\t\t\twhile(true){\n\t\t\t\tH=sc.nextInt();\tW=sc.nextInt();\ts=sc.nextInt();\n\t\t\t\tif((H|W)==0)\tbreak;\n\t\t\t\ta=new int[W+1][H+1];\taa=new int[W+1][H+1];\n\t\t\t\tfor(int y=1; y<=H; y++){\n\t\t\t\t\tfor(int x=1; x<=W; x++)\ta[x][y]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\taa[1][1]=a[1][1];\n\t\t\t\tfor(int i=2; i<=W; i++)\taa[i][1]=aa[i-1][1]+a[i][1];\n\t\t\t\tfor(int i=2; i<=H; i++)\taa[1][i]=aa[1][i-1]+a[1][i];\n\t\t\t\tfor(int x=2; x<=W; x++){\n\t\t\t\t\tfor(int y=2; y<=H; y++)\taa[x][y]=aa[x-1][y]+aa[x][y-1]+a[x][y]-aa[x-1][y-1];\n\t\t\t\t}\n\t\t\t\tsum=aa[W][H];\n\t\t\t\tpair[][][][] dp=new pair[W+1][H+1][W+1][H+1];\n\t\t\t\t\n//\t\t\t\tfor(int y=1; y<=H; y++){\n//\t\t\t\t\tfor(int x=1; x<=W; x++)\tSystem.out.printf(\"%4d\",aa[x][y]);\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.print(\"ANS=\");\n\t\t\t\tSystem.out.println(solve(dp,new pair(0,INF),1,1,W,H));\n\t\t\t}\n\t\t}\n\t\tpair solve(pair[][][][] dp,pair p,int lx,int ly,int rx,int ry){\n\t\t\tif(dp[lx][ly][rx][ry]!=null)\treturn dp[lx][ly][rx][ry];\n\t\t\telse{\n\t\t\t\tint region=aa[rx][ry]-(aa[lx-1][ry]+aa[rx][ly-1])+aa[lx-1][ly-1];\n\t\t\t\tpair r1=new pair(),r2=new pair(),ret=new pair(p.depth+1,s-(sum-region));\n\t\t\t\tfor(int x=lx; x<rx; x++){\n\t\t\t\t\tint rr1=aa[x][ry]-(aa[lx-1][ry]+aa[x][ly-1])+aa[lx-1][ly-1];\n\t\t\t\t\tint rr2=aa[rx][ry]-(aa[x][ry]+aa[rx][ly-1])+aa[x][ly-1];\n\t\t\t\t\tif(sum-rr1<=s && sum-rr2<=s){\n\t\t\t\t\t\tr1=solve(dp,p,lx,ly,x,ry);\n\t\t\t\t\t\tdp[lx][ly][x][ry]=r1;\n\t\t\t\t\t\tr2=solve(dp,p,x+1,ly,rx,ry);\n\t\t\t\t\t\tdp[x+1][ly][rx][ry]=r2;\n\t\t\t\t\t\tret=pmax(ret,new pair(r1.depth+r2.depth-p.depth,min(r1.margin,r2.margin)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int y=ly; y<ry; y++){\n\t\t\t\t\tint rr1=aa[rx][y]-(aa[lx-1][y]+aa[rx][ly-1])+aa[lx-1][ly-1];\n\t\t\t\t\tint rr2=aa[rx][ry]-(aa[lx-1][ry]+aa[rx][y])+aa[lx-1][y];\n\t\t\t\t\tif(sum-rr1<=s && sum-rr2<=s){\n\t\t\t\t\t\tr1=solve(dp,p,lx,ly,rx,y);\n\t\t\t\t\t\tdp[lx][ly][rx][y]=r1;\n\t\t\t\t\t\tr2=solve(dp,p,lx,y+1,rx,ry);\n\t\t\t\t\t\tdp[lx][y+1][rx][ry]=r2;\n\t\t\t\t\t\tret=pmax(ret,new pair(r1.depth+r2.depth-p.depth,min(r1.margin,r2.margin)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tpair pmax(pair r1, pair r2) {\n\t\t\tif(r1.depth<r2.depth)\treturn r2;\n\t\t\tif(r1.depth>r2.depth)\treturn r1;\n\t\t\tif(r1.margin<r2.margin)\treturn r2;\n\t\t\tif(r1.margin>r2.margin)\treturn r1;\n\t\t\treturn r1;\n\t\t}\n\t\tclass pair{\n\t\t\tint depth,margin;\n\t\t\tpair(int d,int m){this.depth=d; this.margin=m;}\n\t\t\tpair(int d){this.depth=d; this.margin=0;}\n\t\t\tpair(){this.depth=-1;this.margin=-1;}\n\t\t\tpair(pair p){this.depth=p.depth; this.margin=p.margin;}\n\t\t\t@Override public pair clone(){\treturn new pair(this);}\n\t\t\t@Override public String toString(){return this.depth+\" \"+this.margin;}\n\t\t}\n\t}\n\n\t\n\tvoid AOJ2200(){\n\t\tint c=0;\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\tif((N|M)==0)\tbreak;\n\t\t\tint[][] L=new int[N+1][N+1],S=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tL[i][j]=INF;\tS[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),t=sc.nextInt();\n\t\t\t\tif(sc.next().equals(\"L\")){\n\t\t\t\t\tL[x][y]=min(L[x][y], t);\tL[y][x]=min(L[y][x], t);\n\t\t\t\t}else{\n\t\t\t\t\tS[x][y]=min(S[x][y], t);\tS[y][x]=min(S[y][x], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\tfor(int k=1; k<=N; k++){\n\t\t\t\t\t\tL[j][k]=min(L[j][k],L[j][i]+L[i][k]);\n\t\t\t\t\t\tS[j][k]=min(S[j][k],S[j][i]+S[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i=1; i<=N; i++){\n//\t\t\t\tfor(int j=1; j<=N; j++){\n//\t\t\t\t\tSystem.out.print(L[i][j]+\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tint R=sc.nextInt();\n\t\t\tint[] d=new int[R];\n\t\t\tfor(int i=0; i<R; i++)\td[i]=sc.nextInt();\n\t\t\tLinkedList<C2200> open=new LinkedList<C2200>();\n\t\t\t//PriorityQueue<C2200> open=new PriorityQueue<C2200>();\n\t\t\topen.add(new C2200(0,d[0],0));\n\t\t\tint[][] close=new int[R][N+1];\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\tfor(int j=0; j<=N; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tint ans=INF;\n\t\t\tclose[0][d[0]]=0;\n\t\t\t\n\t\t\tSystem.err.print(++c+\" \");\n\t\t\tSystem.err.print(\"R \"+R+\" N \"+N+\" M\"+M+\" ANS=\");\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2200 now=open.poll();\n\t\t\t\tif(now.now==R-1){\n\t\t\t\t\tans=min(ans,now.time);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//System.err.println(\"STEP\"+now.now+\" NOW\"+d[now.now]+\" BOAT\"+now.boat+\" TIME\"+now.time+\" NEXT\"+d[now.now+1]);\n\t\t\t\tboolean goal=now.now+1==R-1;\n\t\t\t\tif(now.boat==d[now.now]){\t// S\n\t\t\t\t\tif(S[d[now.now]][d[now.now+1]]<INF){\n\t\t\t\t\t\tint nt=now.time+S[d[now.now]][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][d[now.now+1]]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, d[now.now+1], nt));\n\t\t\t\t\t\t\tclose[now.now+1][d[now.now+1]]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\t// S > L\n\t\t\t\t\tif(now.boat==d[now.now] && S[d[now.now]][i]<INF && L[i][d[now.now+1]]<INF && d[now.now]!=i && d[now.now+1]!=i){\n\t\t\t\t\t\tint nt=now.time+S[d[now.now]][i]+L[i][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][i]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, i, nt));\n\t\t\t\t\t\t\tclose[now.now+1][i]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// L > S > L\n\t\t\t\t\tif(L[d[now.now]][now.boat]<INF && S[now.boat][i]<INF && L[i][d[now.now+1]]<INF && d[now.now]!=i && d[now.now+1]!=i && now.boat!=i){\n\t\t\t\t\t\tint nt=now.time+L[d[now.now]][now.boat]+S[now.boat][i]+L[i][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][i]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, i, nt));\n\t\t\t\t\t\t\tclose[now.now+1][i]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L[d[now.now]][now.boat]<INF){\n\t\t\t\t\tif(S[now.boat][d[now.now+1]]<INF){\t// L > S\n\t\t\t\t\t\tint nt=now.time+L[d[now.now]][now.boat]+S[now.boat][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][d[now.now+1]]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, d[now.now+1], nt));\n\t\t\t\t\t\t\tclose[now.now+1][d[now.now+1]]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(L[d[now.now]][d[now.now+1]]<INF){\t// L\n\t\t\t\t\tint nt=now.time+L[d[now.now]][d[now.now+1]];\n\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\telse if(close[now.now+1][now.boat]>nt){\n\t\t\t\t\t\topen.add(new C2200(now.now+1, now.boat, nt));\n\t\t\t\t\t\tclose[now.now+1][now.boat]=nt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2200 implements Comparable<C2200>{\n\t\tint now,boat,time;\n\t\tC2200(int n,int b,int t){this.now=n; this.boat=b; this.time=t;}\n\t\t@Override public int compareTo(C2200 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\tif(this.now<o.now)\treturn -1;\n\t\t\tif(this.now>o.now)\treturn 1;\n\t\t\tif(this.boat<o.boat)\treturn -1;\n\t\t\tif(this.boat>o.boat)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ2021(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt(),K=sc.nextInt(),A=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] d=new int[N][N];\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<L; i++)\tl[i]=sc.nextInt();\n\t\t\tl[L]=H;\n\t\t\tfor(int i=0; i<K; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),t=sc.nextInt();\n\t\t\t\td[x][y]=t;\td[y][x]=t;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tfor(int k=0; k<N; k++)\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C2021> open=new PriorityQueue<C2021>();\n\t\t\topen.add(new C2021(A,M,0));\n\t\t\tint[][] close=new int[N][M+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<=M; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[A][M]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2021 now=open.poll();\n\t\t\t\tfor(int i=0; i<=L; i++){\n\t\t\t\t\tif(now.now==l[i])\tcontinue;\n\t\t\t\t\tif(d[now.now][l[i]]>M)\tcontinue;\n\t\t\t\t\tint t=now.time+d[now.now][l[i]],r=now.remain-d[now.now][l[i]];\n\t\t\t\t\tif(r<0){\n\t\t\t\t\t\tt+=-1*r;\n\t\t\t\t\t\tr=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(close[l[i]][r]<=t)\tcontinue;\n\t\t\t\t\tif(l[i]==H){\n\t\t\t\t\t\tans=min(ans,t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C2021(l[i],r,t));\n\t\t\t\t\tclose[l[i]][r]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"Help!\":ans));\n\t\t}\n\t}\n\tclass C2021 implements Comparable<C2021>{\n\t\tint now,remain,time;\n\t\tC2021(int n,int r,int t){this.now=n; this.remain=r; this.time=t;}\n\t\t@Override public int compareTo(C2021 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\t//System.out.println(\"L: \"+line);\n\t\t\ttry{\n\t\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString().charAt(n));\n\t\t\t}catch(Exception e){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans=expr();}\n\t\tprivate String expr(){\n\t\t\tString res=term();\n\t\t\tif(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tString res=fact();\n\t\t\t//if(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res.length()>n)\treturn res;\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0 && sb.length()<=n)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int h, w, s;\n  int[][] u;\n\n  int[][][][] wa;\n  Node[][][][] memo;\n  boolean[][][][] done;\n  int sum;\n\n  class Node implements Comparable<Node> {\n    int num;\n    int yobi;\n\n    @Override\n    public int compareTo(Node node) {\n      if (num != node.num) {\n        return Integer.compare(num, node.num);\n      }\n      return Integer.compare(yobi, node.yobi);\n    }\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  Node dfs(int leftY, int leftX, int rightY, int rightX) {\n    if (done[leftY][leftX][rightY][rightX]) {\n      return memo[leftY][leftX][rightY][rightX];\n    }\n    Node max = new Node();\n    max.num = 1;\n    max.yobi = s - (sum - wa[leftY][leftX][rightY][rightX]);\n    // yoko\n    for (int i = leftY + 1; i < rightY; ++i) {\n      int left = s - (sum - wa[leftY][leftX][i][rightX]);\n      int right = s - (sum - wa[i][leftX][rightY][rightX]);\n      if (left < 0 || right < 0) {\n        continue;\n      }\n      Node nextL = dfs(leftY, leftX, i, rightX);\n      Node nextR = dfs(i, leftX, rightY, rightX);\n      Node next = new Node();\n      next.num = nextL.num + nextR.num;\n      next.yobi = Math.min(nextL.yobi, nextR.yobi);\n      max = Util.max(max, next);\n    }\n    // tate\n    for (int i = leftX + 1; i < rightX; ++i) {\n      int left = s - (sum - wa[leftY][leftX][rightY][i]);\n      int right = s - (sum - wa[leftY][i][rightY][rightX]);\n      if (left < 0 || right < 0) {\n        continue;\n      }\n      Node nextL = dfs(leftY, leftX, rightY, i);\n      Node nextR = dfs(leftY, i, rightY, rightX);\n      Node next = new Node();\n      next.num = nextL.num + nextR.num;\n      next.yobi = Math.min(nextL.yobi, nextR.yobi);\n      max = Util.max(max, next);\n    }\n    done[leftY][leftX][rightY][rightX] = true;\n    return memo[leftY][leftX][rightY][rightX] = max;\n  }\n\n  void run() {\n    for (; ; ) {\n      h = ni();\n      w = ni();\n      s = ni();\n      if (h == 0) {\n        break;\n      }\n      u = new int[h][w];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          u[i][j] = ni();\n        }\n      }\n      sum = Stream.of(u).mapToInt(a -> IntStream.of(a).sum()).sum();\n      wa = new int[h][w][h + 1][w + 1];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          for (int k = i; k < h; ++k) {\n            int sum = 0;\n            for (int l = j; l < w; ++l) {\n              sum += u[k][l];\n              int add = wa[i][j][k][l + 1];\n              wa[i][j][k + 1][l + 1] = sum + add;\n            }\n          }\n        }\n      }\n      memo = new Node[h][w][h + 1][w + 1];\n      done = new boolean[h][w][h + 1][w + 1];\n      Node ans = dfs(0, 0, h, w);\n      System.out.println(ans.num + \" \" + ans.yobi);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [][] sumdata;\n\tint sum,c;\n\tint [][][][] group, y;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(h == 0 && w == 0 && c == 0) break;\n\t\t\tint [][]data = new int[h][w];\n\t\t\tsumdata = new int[h+2][w+2];\n\t\t\tgroup = new int[h][w][h][w];\n\t\t\ty = new int[h][w][h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t\tsumdata[i+1][j+1] = data[i][j] + sumdata[i][j+1] + sumdata[i+1][j] - sumdata[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = sumdata[h][w];\n\t\t\t//System.out.println(sum);\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tgroup[i][j][i][j] = 1;\n\t\t\t\t\ty[i][j][i][j] = getY(data[i][j]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0; i < h; i++){\n//\t\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\t\tSystem.out.printf(\"%2d \",y[i][j][i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\n\t\t\tint [] res = dfs(0,0,w-1,h-1);\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(res[0] + \" \" + res[1]);\n\t\t}\n\t}\n\tprivate int[] dfs(int sx, int sy, int ex, int ey) {\n\t\tint [] res = new int[2];\n\t\tif(group [sy][sx][ey][ex] > 0){\n\t\t\tres[0] = group[sy][sx][ey][ex];\n\t\t\tres[1] = y [sy][sx][ey][ex];\n\t\t\treturn res;\n\t\t}\n\t\tres[0] = 1;\n\t\tres[1] = getY(getSeg(sx+1,sy+1,ex+1,ey+1));\n\t\tfor(int i=sy; i < ey; i++){\n\t\t\t//System.out.println(\"pass2\");\n\t\t\tint [] temp = dfs(sx,sy,ex,i);\n\t\t\tint [] temp2 = dfs(sx,i+1,ex,ey);\n\t\t\tif(temp[1] < 0 || temp2[1] < 0) continue;\n\t\t\tint gsum = temp[0] + temp2[0];\n\t\t\tint ysum = Math.min(temp[1],temp2[1]);\n\t\t\t//System.out.println(\"ygsum= \"+gsum + \" \" + ysum);\n\t\t\tif(res[0] < gsum){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t\telse if(res[0] == gsum && res[1] < ysum ){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=sx; i < ex; i++){\n\t\t\t//System.out.println(\"pass1 = \" + sx + \" \" + sy + \" \" + ex + \" \" + ey + \" i= \" + i);\n\t\t\tint [] temp = dfs(sx,sy,i,ey);\n\t\t\tint [] temp2 = dfs(i+1,sy,ex,ey);\n\t\t\tif(temp[1] < 0 || temp2[1] < 0) continue;\n\t\t\tint gsum = temp[0] + temp2[0];\n\t\t\tint ysum = Math.min(temp[1],temp2[1]);\n\t\t\tif(res[0] < gsum){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t\telse if(res[0] == gsum && res[1] < ysum ){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t}\n\t\tgroup[sy][sx][ey][ex] = res[0];\n\t\ty[sy][sx][ey][ex] = res[1];\n\t\t//System.out.println(res[0] + \" \" + res[1]);\n\t\treturn res;\n\t}\n\tprivate int getY(int a) {\n\t\tint res = c - (sum - a);\n\t\treturn res;\n\t}\n\tprivate int getSeg(int sx, int sy, int ex, int ey) {\n\t\tint res = sumdata[ey][ex] - sumdata[ey][sx-1] - sumdata[sy-1][ex] + sumdata[sy-1][sx-1];\n\t\treturn res;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main{\n    Scanner sc=new Scanner(System.in);\n    static int h;\n    static int w;\n    static int mandatory;\n    static int[][][][] sumArr;\n    static int [][]arr;\n    static int[][][][] Divdone;\n    static int[][][][] Remdone;\n\t\n\tprivate void cal(){\n\t\t\n\t\twhile(true){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\t\n\t\tint reserve=sc.nextInt();\n\t\t\n\t\tif(h==0)\n\t\t\tbreak;\n\t\t\n\t\tarr=new int[h][w];\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tarr[i][j]=sc.nextInt();\n\t\t\n\t\tsumArr=new int[h][w][h][w];\n\t\tDivdone=new int[h][w][h][w];\n\t\tRemdone=new int[h][w][h][w];\n\t\t\n\t       for(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t    for(int p=0;p<w;p++){\n\t\t\t\t\t    sumArr[i][j][k][p]=-1;\n\t\t\t\t\t    Divdone[i][j][k][p]=-1;\n\t\t\t\t\t    Remdone[i][j][k][p]=-1;\n\t\t\t\t    }\n\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t\tfor(int p=0;p<w;p++){\n\t\t\t\t\t\tint temp=0;\n\t\t\t\t\t\tif(i<=k && j<=p)\n\t\t\t\t\t\t\tfor(int z=i;z<=k;z++)\n\t\t\t\t\t\t\t\tfor(int x=j;x<=p;x++)\n\t\t\t\t\t\t\t\t\ttemp+=arr[z][x];\n\t\t\t\t\t\tsumArr[i][j][k][p]=temp;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\tmandatory=sumArr[0][0][h-1][w-1]-reserve;\n\t\t\n\t\tPoint tmp=cut(0,0,h-1,w-1);\n\t\tSystem.out.println(tmp.x+\" \"+tmp.y);\n\t\t\n\t\t\n\n\t\t}\n\t\t\n\t}\n\n\n\tpublic Point cut(int a,int b,int c, int d){\n\t\tint maxDiv=1;\n\t\tint rem=0;\n\t\tif(Divdone[a][b][c][d]==-1 && Remdone[a][b][c][d]==-1){\n\t\tfor(int i=a;i<c;i++){\n\t\t\tif(sumArr[a][b][i][d]>=mandatory && sumArr[i+1][b][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][i][d]==-1 && Remdone[a][b][i][d]==-1){\n\t\t\t\t\tPoint temp1=cut(a,b,i,d);\n\t\t\t\t\tDivdone[a][b][i][d]=temp1.x;\n\t\t\t\t\tRemdone[a][b][i][d]=temp1.y;\n\t\t\t\t}\n\t\t\t\tif(Divdone[i+1][b][c][d]==-1 && Remdone[i+1][b][c][d]==-1){\n\t\t\t\t\tPoint temp2=cut(i+1,b,c,d);\n\t\t\t\t\tDivdone[i+1][b][c][d]=temp2.x;\n\t\t\t\t\tRemdone[i+1][b][c][d]=temp2.y;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][i][d]+Divdone[i+1][b][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d])>rem){\n\t\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfor(int i=b;i<d;i++)\n\t\t\tif(sumArr[a][b][c][i]>=mandatory && sumArr[a][i+1][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][c][i]==-1 && Remdone[a][b][c][i]==-1){\n\t\t\t\t\tPoint temp1=cut(a,b,c,i);\n\t\t\t\t\tDivdone[a][b][c][i]=temp1.x;\n\t\t\t\t\tRemdone[a][b][c][i]=temp1.y;\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][i+1][c][d]==-1 && Remdone[a][i+1][c][d]==-1){\n\t\t\t\t\tPoint temp2=cut(a,i+1,c,d);\n\t\t\t\t\tDivdone[a][i+1][c][d]=temp2.x;\n\t\t\t\t\tRemdone[a][i+1][c][d]=temp2.y;\n\t\t\t\t}\t\t\t\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][c][i]+Divdone[a][i+1][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d])>rem){\n\t\t\t\t    rem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\treturn maxDiv==1? new Point(1,sumArr[a][b][c][d]-mandatory):new Point(maxDiv,rem);}\n\t\t\telse\n\t\t\t    return new Point(Divdone[a][b][c][d],Remdone[a][b][c][d]);\n\t\t\t\n\t\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] argv){\n\t\tnew Main().cal();\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\nimport java.util.function.IntPredicate;\n\npublic class Main {\n\n    static int H, W, S;\n    static int[][] U;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        while(true) {\n            H = sc.nextInt();\n            W = sc.nextInt();\n            S = sc.nextInt();\n            if( H == 0 ) break;\n\n            U = new int[H][];\n            for (int i = 0; i < H; i++) {\n                U[i] = sc.nextIntArray(W);\n            }\n\n            System.out.println(solve());\n        }\n    }\n\n    // [左上, 右下]を最大に分割したときの予備力\n    static int[][][] MEMO;\n\n    static String solve() {\n        MEMO = new int[H*W][H*W][];\n        accumlate(H, W, U);\n        int total = get(0, 0, H-1, W-1, U);\n        int P = total - S; // 最低でもこれだけ抑制する\n\n        int[] ret = dfs(0, 0, H-1, W-1, P);\n        return ret[0] + \" \" + ret[1];\n    }\n\n    static int[] dfs(int h1, int w1, int h2, int w2, int P) {\n        int hw1 = h1*W + w1;\n        int hw2 = h2*W + w2;\n        if( MEMO[hw1][hw2] != null ) {\n            return MEMO[hw1][hw2];\n        }\n\n        int p = get(h1, w1, h2, w2, U);\n        if( p < P ) {\n            // この分割だと困る\n            MEMO[hw1][hw2] = new int[]{0, 0};\n            return MEMO[hw1][hw2];\n        }\n\n        // 分割できない場合で初期化\n        int g = 1;\n        int y = p - P;\n\n        if( h2 - h1 >= 1 ) {\n            for (int m = h1; m < h2; m++) {\n                int[] a = dfs(h1, w1, m, w2, P);\n                int[] b = dfs(m+1, w1, h2, w2, P);\n                if( a[0] != 0 && b[0] != 0 ) {\n                    int ng = a[0] + b[0];\n                    int ny = Math.min(a[1], b[1]);\n                    if( ng > g ) {\n                        g = ng;\n                        y = ny;\n                    } else if( ng == g ) {\n                        y = Math.max(y, ny);\n                    }\n                }\n            }\n        }\n        if( w2 - w1 >= 1 ) {\n            for (int m = w1; m < w2; m++) {\n                int[] a = dfs(h1, w1, h2, m, P);\n                int[] b = dfs(h1, m+1, h2, w2, P);\n                if( a[0] != 0 && b[0] != 0 ) {\n                    int ng = a[0] + b[0];\n                    int ny = Math.min(a[1], b[1]);\n                    if( ng > g ) {\n                        g = ng;\n                        y = ny;\n                    } else if( ng == g ) {\n                        y = Math.max(y, ny);\n                    }\n                }\n            }\n        }\n        MEMO[hw1][hw2] = new int[]{g, y};\n        return MEMO[hw1][hw2];\n    }\n\n    static void accumlate(int h, int w, int[][] c) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 1; j < w; j++) {\n                c[i][j] += c[i][j-1];\n            }\n        }\n        for (int j = 0; j < w; j++) {\n            for (int i = 1; i < h; i++) {\n                c[i][j] += c[i-1][j];\n            }\n        }\n    }\n\n    // 左上が (h1, w1), 左下が(h2, w2), 閉区間\n    static int get(int h1, int w1, int h2, int w2, int[][] c) {\n        // d c\n        // b a\n        int abcd = c[h2][w2];\n\n        int cd;\n        if( h1 > 0 ) {\n            cd = c[h1-1][w2];\n        } else {\n            cd = 0;\n        }\n\n        int bd;\n        if( w1 > 0 ) {\n            bd = c[h2][w1-1];\n        } else {\n            bd = 0;\n        }\n\n        int d;\n        if( w1 > 0 && h1 > 0 ) {\n            d = c[h1-1][w1-1];\n        } else {\n            d = 0;\n        }\n\n        return abcd - cd - bd + d;\n    }\n\n    static int maximize(int lo, int hi, IntPredicate p) {\n        while(lo < hi) {\n            int x = ((hi - lo) >>> 1) + lo;\n            if( p.test(x) ) {\n                lo = x + 1;\n            } else {\n                hi = x;\n            }\n        }\n        return lo - 1;\n    }\n\n    static int minimize(int lo, int hi, IntPredicate p) {\n        while(lo < hi) {\n            int x = ((hi - lo) >>> 1) + lo;\n            if( p.test(x) ) {\n                hi = x;\n            } else {\n                lo = x + 1;\n            }\n        }\n        return lo;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4thJun\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().doIt();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\tvoid doIt(){\n\t\tnew AOJ1169();\n\t}\n\t\n\tclass AOJ1169{\n\t\tint s,W,H,sum;\n\t\tint[][] a,aa;\n\t\tAOJ1169(){\n\t\t\twhile(true){\n\t\t\t\tH=sc.nextInt();\tW=sc.nextInt();\ts=sc.nextInt();\n\t\t\t\tif((H|W)==0)\tbreak;\n\t\t\t\ta=new int[W+1][H+1];\taa=new int[W+1][H+1];\n\t\t\t\t//int[][][][] dp=new int[W+1][H+1][W+1][H+1];\n\t\t\t\tfor(int y=1; y<=H; y++){\n\t\t\t\t\tfor(int x=1; x<=W; x++){\n\t\t\t\t\t\ta[x][y]=sc.nextInt();\n\t\t\t\t\t\t//dp[x][y][x][y]=a[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taa[1][1]=a[1][1];\n\t\t\t\t//dp[1][1][1][1]=a[1][1];\n\t\t\t\tfor(int i=2; i<=W; i++){\n\t\t\t\t\taa[i][1]=aa[i-1][1]+a[i][1];\n\t\t\t\t\t//dp[1][1][i][1]=aa[i][1];\n\t\t\t\t}\n\t\t\t\tfor(int i=2; i<=H; i++){\n\t\t\t\t\taa[1][i]=aa[1][i-1]+a[1][i];\n\t\t\t\t\t//dp[1][1][1][i]=aa[1][i];\n\t\t\t\t}\n\t\t\t\tfor(int x=2; x<=W; x++){\n\t\t\t\t\tfor(int y=2; y<=H; y++){\n\t\t\t\t\t\taa[x][y]=aa[x-1][y]+aa[x][y-1]+a[x][y]-aa[x-1][y-1];\n\t\t\t\t\t\t//dp[1][1][x][y]=aa[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum=aa[W][H];\n\t\t\t\tpair[][][][] dp=new pair[W+1][H+1][W+1][H+1];\n\t\t\t\t\n//\t\t\t\tfor(int y=1; y<=H; y++){\n//\t\t\t\t\tfor(int x=1; x<=W; x++)\tSystem.out.printf(\"%4d\",aa[x][y]);\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpair ans=solve(dp,new pair(0,INF),1,1,W,H);\n\t\t\t\t//System.out.print(\"ANS=\");\n\t\t\t\tSystem.out.println(ans.depth+\" \"+ans.margin);\n\t\t\t\tdp[1][1][W][H]=new pair(0,-1);\n\t\t\t}\n\t\t}\n\t\tpair solve(pair[][][][] dp,pair p,int lx,int ly,int rx,int ry){\n\t\t\tif(dp[lx][ly][rx][ry]!=null)\treturn dp[lx][ly][rx][ry];\n\t\t\telse{\n\t\t\t\tint region=aa[rx][ry]-(aa[lx-1][ry]+aa[rx][ly-1])+aa[lx-1][ly-1];\n\t\t\t\tpair r1=new pair(),r2=new pair(),ret=new pair(p.depth+1,s-(sum-region));\n\t\t\t\tfor(int x=lx; x<rx; x++){\n\t\t\t\t\tint rr1=aa[x][ry]-(aa[lx-1][ry]+aa[x][ly-1])+aa[lx-1][ly-1];\n\t\t\t\t\tint rr2=aa[rx][ry]-(aa[x][ry]+aa[rx][ly-1])+aa[x][ly-1];\n\t\t\t\t\tif(sum-rr1<=s && sum-rr2<=s){\n\t\t\t\t\t\tr1=solve(dp,p,lx,ly,x,ry);\n\t\t\t\t\t\tdp[lx][ly][x][ry]=r1.clone();\n\t\t\t\t\t\tr2=solve(dp,p,x+1,ly,rx,ry);\n\t\t\t\t\t\tdp[x+1][ly][rx][ry]=r2.clone();\n\t\t\t\t\t\tret=pmax(ret,new pair(r1.depth+r2.depth-p.depth,min(r1.margin,r2.margin)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int y=ly; y<ry; y++){\n\t\t\t\t\tint rr1=aa[rx][y]-(aa[lx-1][y]+aa[rx][ly-1])+aa[lx-1][ly-1];\n\t\t\t\t\tint rr2=aa[rx][ry]-(aa[lx-1][ry]+aa[rx][y])+aa[lx-1][y];\n\t\t\t\t\tif(sum-rr1<=s && sum-rr2<=s){\n\t\t\t\t\t\tr1=solve(dp,p,lx,ly,rx,y);\n\t\t\t\t\t\tdp[lx][ly][rx][y]=r1.clone();\n\t\t\t\t\t\tr2=solve(dp,p,lx,y+1,rx,ry);\n\t\t\t\t\t\tdp[lx][y+1][rx][ry]=r2.clone();\n\t\t\t\t\t\tret=pmax(ret,new pair(r1.depth+r2.depth-p.depth,min(r1.margin,r2.margin)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tpair pmax(pair r1, pair r2) {\n\t\t\tif(r1.depth<r2.depth)\treturn r2;\n\t\t\tif(r1.depth>r2.depth)\treturn r1;\n\t\t\tif(r1.margin<r2.margin)\treturn r2;\n\t\t\tif(r1.margin>r2.margin)\treturn r1;\n\t\t\treturn r1;\n\t\t}\n\t\tclass pair implements Comparable<pair>{\n\t\t\tint depth,margin;\n\t\t\tpair(int d,int m){this.depth=d; this.margin=m;}\n\t\t\tpair(int d){this.depth=d; this.margin=0;}\n\t\t\tpair(){this.depth=-1;this.margin=-1;}\n\t\t\tpair(pair p){this.depth=p.depth; this.margin=p.margin;}\n\t\t\t@Override public pair clone(){\treturn new pair(this);}\n\t\t\t@Override public int compareTo(pair o) {\n\t\t\t\tif(this.depth<o.depth)\treturn -1;\n\t\t\t\tif(this.depth>o.depth)\treturn 1;\n\t\t\t\tif(this.margin<o.margin)\treturn -1;\n\t\t\t\tif(this.margin>o.margin)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public String toString(){return \"D:\"+this.depth+\" M:\"+this.margin;}\n\t\t}\n\t}\n\n\t\n\tvoid AOJ2200(){\n\t\tint c=0;\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\tif((N|M)==0)\tbreak;\n\t\t\tint[][] L=new int[N+1][N+1],S=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tL[i][j]=INF;\tS[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),t=sc.nextInt();\n\t\t\t\tif(sc.next().equals(\"L\")){\n\t\t\t\t\tL[x][y]=min(L[x][y], t);\tL[y][x]=min(L[y][x], t);\n\t\t\t\t}else{\n\t\t\t\t\tS[x][y]=min(S[x][y], t);\tS[y][x]=min(S[y][x], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\tfor(int k=1; k<=N; k++){\n\t\t\t\t\t\tL[j][k]=min(L[j][k],L[j][i]+L[i][k]);\n\t\t\t\t\t\tS[j][k]=min(S[j][k],S[j][i]+S[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i=1; i<=N; i++){\n//\t\t\t\tfor(int j=1; j<=N; j++){\n//\t\t\t\t\tSystem.out.print(L[i][j]+\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tint R=sc.nextInt();\n\t\t\tint[] d=new int[R];\n\t\t\tfor(int i=0; i<R; i++)\td[i]=sc.nextInt();\n\t\t\tLinkedList<C2200> open=new LinkedList<C2200>();\n\t\t\t//PriorityQueue<C2200> open=new PriorityQueue<C2200>();\n\t\t\topen.add(new C2200(0,d[0],0));\n\t\t\tint[][] close=new int[R][N+1];\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\tfor(int j=0; j<=N; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tint ans=INF;\n\t\t\tclose[0][d[0]]=0;\n\t\t\t\n\t\t\tSystem.err.print(++c+\" \");\n\t\t\tSystem.err.print(\"R \"+R+\" N \"+N+\" M\"+M+\" ANS=\");\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2200 now=open.poll();\n\t\t\t\tif(now.now==R-1){\n\t\t\t\t\tans=min(ans,now.time);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//System.err.println(\"STEP\"+now.now+\" NOW\"+d[now.now]+\" BOAT\"+now.boat+\" TIME\"+now.time+\" NEXT\"+d[now.now+1]);\n\t\t\t\tboolean goal=now.now+1==R-1;\n\t\t\t\tif(now.boat==d[now.now]){\t// S\n\t\t\t\t\tif(S[d[now.now]][d[now.now+1]]<INF){\n\t\t\t\t\t\tint nt=now.time+S[d[now.now]][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][d[now.now+1]]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, d[now.now+1], nt));\n\t\t\t\t\t\t\tclose[now.now+1][d[now.now+1]]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\t// S > L\n\t\t\t\t\tif(now.boat==d[now.now] && S[d[now.now]][i]<INF && L[i][d[now.now+1]]<INF && d[now.now]!=i && d[now.now+1]!=i){\n\t\t\t\t\t\tint nt=now.time+S[d[now.now]][i]+L[i][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][i]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, i, nt));\n\t\t\t\t\t\t\tclose[now.now+1][i]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// L > S > L\n\t\t\t\t\tif(L[d[now.now]][now.boat]<INF && S[now.boat][i]<INF && L[i][d[now.now+1]]<INF && d[now.now]!=i && d[now.now+1]!=i && now.boat!=i){\n\t\t\t\t\t\tint nt=now.time+L[d[now.now]][now.boat]+S[now.boat][i]+L[i][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][i]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, i, nt));\n\t\t\t\t\t\t\tclose[now.now+1][i]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L[d[now.now]][now.boat]<INF){\n\t\t\t\t\tif(S[now.boat][d[now.now+1]]<INF){\t// L > S\n\t\t\t\t\t\tint nt=now.time+L[d[now.now]][now.boat]+S[now.boat][d[now.now+1]];\n\t\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\t\telse if(close[now.now+1][d[now.now+1]]>nt){\n\t\t\t\t\t\t\topen.add(new C2200(now.now+1, d[now.now+1], nt));\n\t\t\t\t\t\t\tclose[now.now+1][d[now.now+1]]=nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(L[d[now.now]][d[now.now+1]]<INF){\t// L\n\t\t\t\t\tint nt=now.time+L[d[now.now]][d[now.now+1]];\n\t\t\t\t\tif(goal)\tans=min(ans,nt);\n\t\t\t\t\telse if(close[now.now+1][now.boat]>nt){\n\t\t\t\t\t\topen.add(new C2200(now.now+1, now.boat, nt));\n\t\t\t\t\t\tclose[now.now+1][now.boat]=nt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2200 implements Comparable<C2200>{\n\t\tint now,boat,time;\n\t\tC2200(int n,int b,int t){this.now=n; this.boat=b; this.time=t;}\n\t\t@Override public int compareTo(C2200 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\tif(this.now<o.now)\treturn -1;\n\t\t\tif(this.now>o.now)\treturn 1;\n\t\t\tif(this.boat<o.boat)\treturn -1;\n\t\t\tif(this.boat>o.boat)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ2021(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt(),K=sc.nextInt(),A=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] d=new int[N][N];\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<L; i++)\tl[i]=sc.nextInt();\n\t\t\tl[L]=H;\n\t\t\tfor(int i=0; i<K; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),t=sc.nextInt();\n\t\t\t\td[x][y]=t;\td[y][x]=t;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tfor(int k=0; k<N; k++)\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C2021> open=new PriorityQueue<C2021>();\n\t\t\topen.add(new C2021(A,M,0));\n\t\t\tint[][] close=new int[N][M+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<=M; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[A][M]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2021 now=open.poll();\n\t\t\t\tfor(int i=0; i<=L; i++){\n\t\t\t\t\tif(now.now==l[i])\tcontinue;\n\t\t\t\t\tif(d[now.now][l[i]]>M)\tcontinue;\n\t\t\t\t\tint t=now.time+d[now.now][l[i]],r=now.remain-d[now.now][l[i]];\n\t\t\t\t\tif(r<0){\n\t\t\t\t\t\tt+=-1*r;\n\t\t\t\t\t\tr=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(close[l[i]][r]<=t)\tcontinue;\n\t\t\t\t\tif(l[i]==H){\n\t\t\t\t\t\tans=min(ans,t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C2021(l[i],r,t));\n\t\t\t\t\tclose[l[i]][r]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"Help!\":ans));\n\t\t}\n\t}\n\tclass C2021 implements Comparable<C2021>{\n\t\tint now,remain,time;\n\t\tC2021(int n,int r,int t){this.now=n; this.remain=r; this.time=t;}\n\t\t@Override public int compareTo(C2021 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\t//System.out.println(\"L: \"+line);\n\t\t\ttry{\n\t\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString().charAt(n));\n\t\t\t}catch(Exception e){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans=expr();}\n\t\tprivate String expr(){\n\t\t\tString res=term();\n\t\t\tif(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tString res=fact();\n\t\t\t//if(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res.length()>n)\treturn res;\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0 && sb.length()<=n)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    \n\tprivate static StringTokenizer st;\n\n    public static void main ( String [] args ) throws IOException\n    {\n\n\tint h,w,s;\n\n\twhile(true){\n\t\n\t\tst = new StringTokenizer(br.readLine());\n\t\th = Integer.parseInt(st.nextToken());\n\t\tw = Integer.parseInt(st.nextToken());\n\t\ts = Integer.parseInt(st.nextToken());\n\t\tif( h == 0 && w == 0 && s == 0)\tbreak;\n\t    new Main().cal(h,w,s);\n\t}\n\t\n    }\n\n\nint min;\nint[][] area;\nint[][][][] sumArea;\nint[][] basicSum;\nint[][][][] grouparray;\nint[][][][] minDep;\n\n    private void cal(int h, int w, int s) throws IOException \n    {\n\tint areaSum = 0;\n\tarea = new int[h][w];\n\tgrouparray = new int[h][w][h][w];\n\tminDep =new int[h][w][h][w];\n\tfor(int i=0; i < h; i++){\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int j=0; j < w; j++){\n\t\t\tarea[i][j] = Integer.parseInt(st.nextToken());\n\t\t\tareaSum += area[i][j];\n\t\t}\n\t}\n\tcalBasicSum(h,w);\n\tcalSum(h,w);\n\n\t//cal max\n\tmin = areaSum - s;\n\tint[] out = grouping(0,0,h-1,w-1);\n\n\tSystem.out.println(out[0]+\" \"+(out[1]-min));\n\n    }\n\n\n    private int[] grouping(int hs, int ws, int hl, int wl){\n\tint[] ret = new int[2];\n\tif( grouparray[hs][ws][hl][wl] != -1 ){\n\t\tret[0] = grouparray[hs][ws][hl][wl];\n\t\tret[1] = minDep[hs][ws][hl][wl];\n\t\treturn ret;\n\t}\n\tgrouparray[hs][ws][hl][wl] = 0;\n\tret[0] = 1;\n\tret[1] = sumArea[hs][ws][hl][wl];\n\tint[] tmp = new int[2];\n\tint grptmp;\n\tint tempDep;\n\n\t//&#44032;&#47196;&#47196; &#51900;&#44060;&#44592;\n\tfor(int i = hs; i < hl; i++){\n\t\tif(sumArea[hs][ws][i][wl] < min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(sumArea[i+1][ws][hl][wl] < min){\n\t\t\tbreak;\n\t\t}\n\t\ttmp = grouping(hs, ws, i, wl);\n\t\tgrptmp = tmp[0];\n\t\ttempDep = tmp[1];\n\n\t\ttmp = grouping(i+1, ws, hl, wl);\n\t\tgrptmp += tmp[0];\n\t\tif( tempDep < tmp[1] ){ tmp[1] = tempDep; }\n\n\t\tif( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }\n\t\tif( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }\n\t}\n\t//&#49464;&#47196;&#47196; &#51900;&#44060;&#44592;\n\tfor(int i = ws; i < wl; i++){\n\t\tif(sumArea[hs][ws][hl][i] < min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(sumArea[hs][i+1][hl][wl] < min){\n\t\t\tbreak;\n\t\t}\n\t\ttmp = grouping(hs, ws, hl, i);\n\t\tgrptmp = tmp[0];\n\t\ttempDep = tmp[1];\n\n\t\ttmp = grouping(hs, i+1, hl, wl);\n\t\tgrptmp += tmp[0];\n\n\t\tif( tempDep < tmp[1] ){ tmp[1] = tempDep; }\n\n\t\tif( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }\n\t\tif( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }\n\n\t}\n\n\tgrouparray[hs][ws][hl][wl] = ret[0];\n\tminDep[hs][ws][hl][wl] = ret[1];\n\treturn ret;\n\t\n    }\n\n\n   private void calBasicSum(int h, int w){\n\tbasicSum = new int[h][w];\n\tbasicSum[0][0] = area[0][0];\n\tfor(int j = 1; j < w; j++){\n\t\tbasicSum[0][j] = basicSum[0][j-1] + area[0][j];\n\t}\n\tfor(int i = 1; i < h; i++){\n\t\tbasicSum[i][0] = basicSum[i-1][0] + area[i][0];\n\t}\n\tfor(int i = 1; i < h; i++){\n\t\tfor(int j=1; j < w; j++){\n\t\t\tbasicSum[i][j] = basicSum[i][j-1] + basicSum[i-1][j] + area[i][j] - basicSum[i-1][j-1];\n\t\t}\n\t}\n   }\n\n   private void calSum(int h, int w ){\n\tsumArea = new int[h][w][h][w];\n\n\tfor(int i = 0; i < h; i++){\n\tfor(int j = 0; j < w; j++){\n\t\tfor(int l = i; l < h; l++){\n\t\tfor(int k = j; k < w; k++){\n\t\t\tgrouparray[i][j][l][k] = -1;\n\t\t\tif( i == 0 && j ==0 ){\n\t\t\t\tsumArea[0][0][l][k] = basicSum[l][k];\n\t\t\t}\n\t\t\telse if( i == 0 ){\n\t\t\t\tsumArea[0][j][l][k] = basicSum[l][k] - basicSum[l][j-1];\n\t\t\t}\n\t\t\telse if( j == 0 ){\n\t\t\t\tsumArea[i][0][l][k] = basicSum[l][k] - basicSum[i-1][k];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsumArea[i][j][l][k] = basicSum[l][k] - basicSum[l][j-1] - basicSum[i-1][k] + basicSum[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\t}\n   }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [][] sumdata;\n\tint sum,c;\n\tint [][][][][] memo;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(h == 0 && w == 0 && c == 0) break;\n\t\t\tint [][]data = new int[h][w];\n\t\t\tsumdata = new int[h+2][w+2];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t\tsumdata[i+1][j+1] = data[i][j] + sumdata[i][j+1] + sumdata[i+1][j] - sumdata[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = sumdata[h][w];\n\t\t\t//System.out.println(sum);\n//\t\t\tfor(int i=0; i < h+2; i++){\n//\t\t\t\tfor(int j = 0; j < w + 2; j++){\n//\t\t\t\t\tSystem.out.printf(\"%2d \",sumdata[i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\tmemo = new int[h][w][h][w][2];\n\t\t\tint [] res = dfs(0,0,w-1,h-1);\n\t\t\tSystem.out.println(res[0] + \" \" + res[1]);\n\t\t}\n\t}\n\tprivate int[] dfs(int sx, int sy, int ex, int ey) {\n\t\t\n\t\tint [] res = new int[2];\n\t\tif(memo [sy][sx][ey][ex][0] > 0){\n\t\t\tres[0] = memo [sy][sx][ey][ex][0];\n\t\t\tres[1] = memo [sy][sx][ey][ex][1];\n\t\t\treturn res;\n\t\t}\n\t\tif(sx == ex && sy == ey){\n\t\t\tres[0] = 1;\n\t\t\tres[1] = getY(getSeg(sx+1,sy+1,ex+1,ey+1));\n\t\t\treturn res;\n\t\t}\n\t\tres[0] = 1;\n\t\tres[1] = getY(getSeg(sx+1,sy+1,ex+1,ey+1));\n\t\tfor(int i=sy; i < ey; i++){\n\t\t\tint [] temp = dfs(sx,sy,ex,i);\n\t\t\tint [] temp2 = dfs(sx,i+1,ex,ey);\n\t\t\tif(temp[1] < 0 || temp2[1] < 0) continue;\n\t\t\tint gsum = temp[0] + temp2[0];\n\t\t\tint ysum = Math.min(temp[1],temp2[1]);\n\t\t\t//System.out.println(\"ygsum= \"+gsum + \" \" + ysum);\n\t\t\tif(res[0] < gsum){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t\telse if(res[0] == gsum && res[1] < ysum ){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=sx; i < ex; i++){\n\t\t\tint [] temp = dfs(sx,sy,i,ey);\n\t\t\tint [] temp2 = dfs(i+1,sy,ex,ey);\n\t\t\tif(temp[1] < 0 || temp2[1] < 0) continue;\n\t\t\tint gsum = temp[0] + temp2[0];\n\t\t\tint ysum = Math.min(temp[1],temp2[1]);\n\t\t\tif(res[0] < gsum){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t\telse if(res[0] == gsum && res[1] < ysum ){\n\t\t\t\tres[0] = gsum;\n\t\t\t\tres[1] = ysum;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"res= \" + res[0] + \" \" + res[1]);\n\t\tmemo [sy][sx][ey][ex][0] = res[0];\n\t\tmemo [sy][sx][ey][ex][1] = res[1];\n\t\treturn res;\n\t}\n\tprivate int getY(int a) {\n\t\tint res = c - (sum - a);\n\t\treturn res;\n\t}\n\tprivate int getSeg(int sx, int sy, int ex, int ey) {\n\t\t//System.out.println(sx + \" \" + sy + \" \" + ex + \" \" + ey);\n\t\tint res = sumdata[ey][ex] - sumdata[ey][sx-1] - sumdata[sy-1][ex] + sumdata[sy-1][sx-1];\n\t\treturn res;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[] { -1, -1 };\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = ret;\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    \n\tprivate static StringTokenizer st;\n\n    public static void main ( String [] args ) throws IOException\n    {\n\n\tint h,w,s;\n\n\twhile(true){\n\t\n\t\tst = new StringTokenizer(br.readLine());\n\t\th = Integer.parseInt(st.nextToken());\n\t\tw = Integer.parseInt(st.nextToken());\n\t\ts = Integer.parseInt(st.nextToken());\n\t\tif( h == 0 && w == 0 && s == 0)\tbreak;\n\t    new Main().cal(h,w,s);\n\t}\n\t\n    }\n\n\nint min;\nint[][] area;\nint[][][][] sumArea;\nint[][] basicSum;\nint[][][][] grouparray;\nint[][][][] minDep;\n\n    private void cal(int h, int w, int s) throws IOException \n    {\n\tint areaSum = 0;\n\tarea = new int[h][w];\n\tgrouparray = new int[h][w][h][w];\n\tminDep =new int[h][w][h][w];\n\tfor(int i=0; i < h; i++){\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int j=0; j < w; j++){\n\t\t\tarea[i][j] = Integer.parseInt(st.nextToken());\n\t\t\tareaSum += area[i][j];\n\t\t}\n\t}\n\tcalBasicSum(h,w);\n\tcalSum(h,w);\n\n\t//cal max\n\tmin = areaSum - s;\n\tint[] out = grouping(0,0,h-1,w-1);\n\n\tSystem.out.println(out[0]+\" \"+(out[1]-min));\n\n    }\n\n\n    private int[] grouping(int hs, int ws, int hl, int wl){\n\tint[] ret = new int[2];\n\tif( grouparray[hs][ws][hl][wl] != -1 ){\n\t\tret[0] = grouparray[hs][ws][hl][wl];\n\t\tret[1] = minDep[hs][ws][hl][wl];\n\t\treturn ret;\n\t}\n\tgrouparray[hs][ws][hl][wl] = 0;\n\tret[0] = 1;\n\tret[1] = sumArea[hs][ws][hl][wl];\n\tint[] tmp = new int[2];\n\tint grptmp;\n\tint tempDep;\n\n\tfor(int i = hs; i < hl; i++){\n\t\tif(sumArea[hs][ws][i][wl] < min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(sumArea[i+1][ws][hl][wl] < min){\n\t\t\tbreak;\n\t\t}\n\t\ttmp = grouping(hs, ws, i, wl);\n\t\tgrptmp = tmp[0];\n\t\ttempDep = tmp[1];\n\n\t\ttmp = grouping(i+1, ws, hl, wl);\n\t\tgrptmp += tmp[0];\n\t\tif( tempDep < tmp[1] ){ tmp[1] = tempDep; }\n\n\t\tif( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }\n\t\tif( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }\n\t}\n\tfor(int i = ws; i < wl; i++){\n\t\tif(sumArea[hs][ws][hl][i] < min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(sumArea[hs][i+1][hl][wl] < min){\n\t\t\tbreak;\n\t\t}\n\t\ttmp = grouping(hs, ws, hl, i);\n\t\tgrptmp = tmp[0];\n\t\ttempDep = tmp[1];\n\n\t\ttmp = grouping(hs, i+1, hl, wl);\n\t\tgrptmp += tmp[0];\n\n\t\tif( tempDep < tmp[1] ){ tmp[1] = tempDep; }\n\n\t\tif( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }\n\t\tif( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }\n\n\t}\n\n\tgrouparray[hs][ws][hl][wl] = ret[0];\n\tminDep[hs][ws][hl][wl] = ret[1];\n\treturn ret;\n\t\n    }\n\n\n   private void calBasicSum(int h, int w){\n\tbasicSum = new int[h][w];\n\tbasicSum[0][0] = area[0][0];\n\tfor(int j = 1; j < w; j++){\n\t\tbasicSum[0][j] = basicSum[0][j-1] + area[0][j];\n\t}\n\tfor(int i = 1; i < h; i++){\n\t\tbasicSum[i][0] = basicSum[i-1][0] + area[i][0];\n\t}\n\tfor(int i = 1; i < h; i++){\n\t\tfor(int j=1; j < w; j++){\n\t\t\tbasicSum[i][j] = basicSum[i][j-1] + basicSum[i-1][j] + area[i][j] - basicSum[i-1][j-1];\n\t\t}\n\t}\n   }\n\n   private void calSum(int h, int w ){\n\tsumArea = new int[h][w][h][w];\n\n\tfor(int i = 0; i < h; i++){\n\tfor(int j = 0; j < w; j++){\n\t\tfor(int l = i; l < h; l++){\n\t\tfor(int k = j; k < w; k++){\n\t\t\tgrouparray[i][j][l][k] = -1;\n\t\t\tif( i == 0 && j ==0 ){\n\t\t\t\tsumArea[0][0][l][k] = basicSum[l][k];\n\t\t\t}\n\t\t\telse if( i == 0 ){\n\t\t\t\tsumArea[0][j][l][k] = basicSum[l][k] - basicSum[l][j-1];\n\t\t\t}\n\t\t\telse if( j == 0 ){\n\t\t\t\tsumArea[i][0][l][k] = basicSum[l][k] - basicSum[i-1][k];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsumArea[i][j][l][k] = basicSum[l][k] - basicSum[l][j-1] - basicSum[i-1][k] + basicSum[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\t}\n   }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\t\n\tint NOT_YET = -1;\n\n\tint MAX = 33;\n\tint[][][][][] dp = new int[2][MAX][MAX][MAX][MAX];\n\t\n\tint allSum;\n\tint H, W, S;\n\tint[][] U;\n\tint[][] sum;\n\t\n\tint total(int lx, int ly, int rx, int ry) {\n\t\treturn sum[ry][rx] + sum[ly][lx] - sum[ry][lx] - sum[ly][rx];\n\t}\n\t\n\tint calc(int lx, int ly, int rx, int ry) {\n\t\tif (dp[0][ly][lx][ry][rx] != NOT_YET) return dp[0][ly][lx][ry][rx];\n\t\t\n\t\tint ans = 0, rest = 0;\n\t\tif (allSum - total(lx, ly, rx, ry) <= S) {\n\t\t\tans = 1;\n\t\t\trest = S + total(lx, ly, rx, ry) - allSum;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor (int y = ly + 1; y < ry; y++) {\n\t\t\tint num = calc(lx, ly, rx, y) + calc(lx, y, rx, ry);\n\t\t\tint nrest = Math.min(dp[1][ly][lx][y][rx], dp[1][y][lx][ry][rx]);\n\t\t\tif (num > ans || (num == ans && rest < nrest)) {\n\t\t\t\tans = num;\n\t\t\t\trest = nrest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int x = lx + 1; x < rx; x++) {\n\t\t\tint num = calc(lx, ly, x, ry) + calc(x, ly, rx, ry);\n\t\t\tint nrest = Math.min(dp[1][ly][lx][ry][x], dp[1][ly][x][ry][rx]);\n\t\t\tif (num > ans || (num == ans && rest < nrest)) {\n\t\t\t\tans = num;\n\t\t\t\trest = nrest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][ly][lx][ry][rx] = ans;\n\t\tdp[1][ly][lx][ry][rx] = rest;\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tH = in.nextInt(); \n\t\t\tW = in.nextInt();\n\t\t\tS = in.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tU = in.nextIntMap(H, W);\n\t\t\tsum = new int[H+1][W+1];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tsum[i+1][j+1] = sum[i][j+1] + sum[i+1][j] - sum[i][j] + U[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tallSum = sum[H][W];\n\t\t\t\n\t\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tfor (int k = 0; k < MAX; k++) {\n\t\t\t\t\t\tArrays.fill(dp[0][i][j][k], NOT_YET);\n\t\t\t\t\t\tArrays.fill(dp[1][i][j][k], NOT_YET);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcalc(0, 0, W, H);\n\t\t\tSystem.out.println(dp[0][0][0][H][W] + \" \" + dp[1][0][0][H][W]);\n\t\t}\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner sc=new Scanner(System.in);\n\tstatic int h;\n\tstatic int w;\n\tstatic int mandatory;\n\tstatic int[][][][] sumArr;\n\tstatic int [][]arr;\n\tstatic int[][][][] Divdone;\n\tstatic int[][][][] Remdone;\n\t\n\tprivate void cal(){\n\t\t\n\t\twhile(true){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\t\n\t\tint reserve=sc.nextInt();\n\t\t\n\t\tif(h==0)\n\t\t\tbreak;\n\t\t\n\t\tarr=new int[h][w];\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tarr[i][j]=sc.nextInt();\n\t\t\n\t\tsumArr=new int[h][w][h][w];\n\t\tDivdone=new int[h][w][h][w];\n\t\tRemdone=new int[h][w][h][w];\n\t\t\n\t       for(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t    for(int p=0;p<w;p++){\n\t\t\t\t\t    sumArr[i][j][k][p]=-1;\n\t\t\t\t\t    Divdone[i][j][k][p]=-1;\n\t\t\t\t\t    Remdone[i][j][k][p]=-1;\n\t\t\t\t    }\n\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t\tfor(int p=0;p<w;p++){\n\t\t\t\t\t\tint temp=0;\n\t\t\t\t\t\tif(i<=k && j<=p)\n\t\t\t\t\t\t\tfor(int z=i;z<=k;z++)\n\t\t\t\t\t\t\t\tfor(int x=j;x<=p;x++)\n\t\t\t\t\t\t\t\t\ttemp+=arr[z][x];\n\t\t\t\t\t\tsumArr[i][j][k][p]=temp;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\tmandatory=sumArr[0][0][h-1][w-1]-reserve;\n\t\t\n\t\tPoint tmp=cut(0,0,h-1,w-1);\n\t\tSystem.out.println(tmp.x+\" \"+tmp.y);\n\t\t\n\t\t\n\n\t\t}\n\t\t\n\t}\n\t\n\tpublic Point cut(int a,int b,int c, int d){\n\t\tint maxDiv=1;\n\t\tint rem=0;\n\t\t\n\t\tfor(int i=a;i<c;i++){\n\t\t\tif(sumArr[a][b][i][d]>=mandatory && sumArr[i+1][b][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][i][d]==-1 && Remdone[a][b][i][d]==-1){\n\t\t\t\t\tPoint temp1=cut(a,b,i,d);\n\t\t\t\t\tDivdone[a][b][i][d]=temp1.x;\n\t\t\t\t\tRemdone[a][b][i][d]=temp1.y;\n\t\t\t\t}\n\t\t\t\tif(Divdone[i+1][b][c][d]==-1 && Remdone[i+1][b][c][d]==-1){\n\t\t\t\t\tPoint temp2=cut(i+1,b,c,d);\n\t\t\t\t\tDivdone[i+1][b][c][d]=temp2.x;\n\t\t\t\t\tRemdone[i+1][b][c][d]=temp2.y;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][i][d]+Divdone[i+1][b][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d])>rem){\n\t\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfor(int i=b;i<d;i++)\n\t\t\tif(sumArr[a][b][c][i]>=mandatory && sumArr[a][i+1][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][c][i]==-1 && Remdone[a][b][c][i]==-1){\n\t\t\t\t\tPoint temp1=cut(a,b,c,i);\n\t\t\t\t\tDivdone[a][b][c][i]=temp1.x;\n\t\t\t\t\tRemdone[a][b][c][i]=temp1.y;\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][i+1][c][d]==-1 && Remdone[a][i+1][c][d]==-1){\n\t\t\t\t\tPoint temp2=cut(a,i+1,c,d);\n\t\t\t\t\tDivdone[a][i+1][c][d]=temp2.x;\n\t\t\t\t\tRemdone[a][i+1][c][d]=temp2.y;\n\t\t\t\t}\t\t\t\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][c][i]+Divdone[a][i+1][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d])>rem){\n\t\t\t\t    rem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn maxDiv==1? new Point(1,sumArr[a][b][c][d]-mandatory):new Point(maxDiv,rem);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] argv){\n\t\tnew Main().cal();\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    \n\tprivate static StringTokenizer st;\n\n    public static void main ( String [] args ) throws IOException\n    {\n\n\tint h,w,s;\n\n\twhile(true){\n\t\n\t\tst = new StringTokenizer(br.readLine());\n\t\th = Integer.parseInt(st.nextToken());\n\t\tw = Integer.parseInt(st.nextToken());\n\t\ts = Integer.parseInt(st.nextToken());\n\t\tif( h == 0 && w == 0 && s == 0)\tbreak;\n\t    new Main().cal(h,w,s);\n\t}\n\t\n    }\n\n\nint max;\nint[][] area;\n\n    private void cal(int h, int w, int s) throws IOException \n    {\n\tint areaSum = 0;\n\tarea = new int[h][w];\n\tfor(int i=0; i < h; i++){\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int j=0; j < w; j++){\n\t\t\tarea[i][j] = Integer.parseInt(st.nextToken());\n\t\t\tareaSum += area[i][j];\n\t\t}\n\t}\n\t\n\t//cal max\n\tmax = areaSum - s;\n\tint[] out = grouping(0, 0, h, w);\n\tSystem.out.println(out[0]+\" \"+(out[1] - max));\n\t\n    }\n\n\n   private int[] grouping(int hs, int ws, int h, int w){\n\tif( hs == h || ws == w ){\n\t\tint[] temp = {0, 0};\n\t\treturn temp;\n\t}\n\tint h1, h2, h3;\n\tint w1, w2, w3;\n\tint sum1, sum2, sum3;\n\tint grpNum;\n\tint[] ret = {1, calSum(hs, ws, h, w)};\n\tint tmpdep = 0;\n\tboolean didit = false;\n\n\tfor(int i = h; i >= hs; i--){\n\tfor(int j = w; j >= ws; j--){\n\t\tdidit = false;\n\t\th1 = i;\n\t\tw1 = j;\n\t\tif( h1 == h && w1 == w ){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( (sum1 = calSum(hs, ws, h1, w1)) >= max ){\n\t\tif( (sum2 = calSum(h1, ws, h, w)) >= max || sum2 == 0 ){\n\t\tif( (sum3 = calSum(hs, w1, h1, w)) >= max || sum3 == 0 ){\n\t\t\ttmpdep = sum1;\n\t\t\tgrpNum = 1;\n\n\t\t\tint[] tmp = grouping(h1, ws, h, w);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t \t}\n\n\t\t\ttmp = grouping(hs, w1, h1, w);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t\t}\n\n\t\t\tif( grpNum > ret[0] ) { ret[0] = grpNum; ret[1] = tmp[1]; }\n\t\t\tif( grpNum == ret[0] && tmpdep < ret[1] ) ret[1] = tmpdep;\n\t\t}\n\t\tdidit = true;\n\t\t}\n\t\t}\n\n\n\t\tif( (sum1 = calSum(hs, ws, h1, w1)) >= max ){\n\t\tif( (sum2 = calSum(h1, ws, h, w1)) >= max || sum2 == 0 ){\n\t\tif( (sum3 = calSum(hs, w1, h, w)) >= max || sum3 == 0){\n\t\t\ttmpdep = sum1;\n\t\t\tgrpNum =1;\n\n\t\t\tint[] tmp = grouping(h1, ws, h, w1);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t\t}\n\n\t\t\ttmp = grouping(hs, w1, h, w);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t\t}\n\n\t\t\tif( grpNum > ret[0] ) { ret[0] = grpNum; ret[1] = tmp[1]; }\n\t\t\tif( grpNum == ret[0] && tmpdep > ret[1] ) ret[1] = tmpdep;\n\t\t}\n\t\tdidit = true;\n\t\t}\n\t\t}\n\n\t\tif(!didit)\tbreak;\n\n\t}\n\t}\n\treturn ret;\n   }\n\n   private int calSum(int hs, int  ws, int  h, int w){\n\tint tmpsum=0;\n\tfor(int i = hs; i < h; i++){\n\t\tfor(int j = ws; j < w; j++){\n\t\t\ttmpsum += area[i][j];\n\t\t}\n\t}\n\treturn tmpsum;\n   }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Planning Rolling Blackouts\npublic class Main{\n\n\tint h, w, s, S;\n\tint[][] a, sum;\n\tint[][][][] group, rest;\n\t\n\tint get(int i, int j, int k, int l){\n\t\treturn sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1];\n\t}\n\t\n\tvoid dfs(int i, int j, int k, int l){\n\t\tif(group[i][j][k][l]!=-1)return;\n\t\tif(s<S-get(i, j, k, l))return;\n//\t\tif(group[i][j][k][l]<1){\n\t\t\tgroup[i][j][k][l] = 1;\n\t\t\trest[i][j][k][l] = s-S+get(i, j, k, l);\n//\t\t}\n//\t\telse if(group[i][j][k][l]==1){\n//\t\t\trest[i][j][k][l] = Math.max(rest[i][j][k][l], 0);\n//\t\t}\n\t\tfor(int ni=i;ni<k;ni++){\n\t\t\tdfs(i, j, ni, l); dfs(ni+1, j, k, l);\n\t\t\tif(group[i][j][ni][l]==-1||group[ni+1][j][k][l]==-1)continue;\n\t\t\tif(group[i][j][k][l]<group[i][j][ni][l]+group[ni+1][j][k][l]){\n\t\t\t\tgroup[i][j][k][l] = group[i][j][ni][l]+group[ni+1][j][k][l];\n\t\t\t\trest[i][j][k][l] = Math.min(rest[i][j][ni][l], rest[ni+1][j][k][l]);\n\t\t\t}\n\t\t\telse if(group[i][j][k][l]==group[i][j][ni][l]+group[ni+1][j][k][l])\n\t\t\t\trest[i][j][k][l]=Math.max(rest[i][j][k][l], Math.min(rest[i][j][ni][l], rest[ni+1][j][k][l]));\n\t\t}\n\t\tfor(int nj=j;nj<l;nj++){\n\t\t\tdfs(i, j, k, nj); dfs(i, nj+1, k, l);\n\t\t\tif(group[i][j][k][nj]==-1||group[i][nj+1][k][l]==-1)continue;\n\t\t\tif(group[i][j][k][l]<group[i][j][k][nj]+group[i][nj+1][k][l]){\n\t\t\t\tgroup[i][j][k][l] = group[i][j][k][nj]+group[i][nj+1][k][l];\n\t\t\t\trest[i][j][k][l] = Math.min(rest[i][j][k][nj], rest[i][nj+1][k][l]);\n\t\t\t}\n\t\t\telse if(group[i][j][k][l]==group[i][j][k][nj]+group[i][nj+1][k][l])\n\t\t\t\trest[i][j][k][l]=Math.max(rest[i][j][k][l], Math.min(rest[i][j][k][nj], rest[i][nj+1][k][l]));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th = sc.nextInt(); w = sc.nextInt(); s = sc.nextInt();\n\t\t\tif((h|w|s)==0)break;\n\t\t\ta = new int[h+1][w+1]; sum = new int[h+1][w+1];\n\t\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tsum[i][j] = sum[i-1][j] + sum[i][j-1] + a[i][j] - sum[i-1][j-1];\n\t\t\t}\n\t\t\tgroup = new int[h+1][w+1][h+1][w+1]; rest = new int[h+1][w+1][h+1][w+1];\n\t\t\tfor(int i=0;i<=h;i++)for(int j=0;j<=w;j++)for(int k=0;k<=h;k++)for(int l=0;l<=w;l++)group[i][j][k][l]=rest[i][j][k][l]=-1;\n\t\t\tS = get(1, 1, h, w);\n\t\t\tdfs(1,1,h,w);\n\t\t\tSystem.out.println(group[1][1][h][w]+\" \"+rest[1][1][h][w]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w, s;\n\tint map[][];\n\tint all;\n\tPair mem[][][][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\ts = sc.nextInt();\n\t\t\tif((h|w|s) == 0) break;\n\t\t\tmap = new int[h+1][w+1];\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tmap[i][j] = sc.nextInt() + map[i-1][j] + map[i][j-1] - map[i-1][j-1];\n\t\t\t}\n\t\t\tmem = new Pair[w][h][w+1][h+1];\n\t\t\tfor(Pair[][][] a: mem) for(Pair[][] b: a) for(Pair[] c: b) fill(c, new Pair(-1, 0));\n\t\t\tall = demand(0,0,w,h);\n//\t\t\tfor(int[] a: map) debug(a);\n//\t\t\tdebug(all);\n\t\t\tPair p = solve(0,0,w,h);\n\t\t\tSystem.out.println(p.s + \" \" + (s-p.f));\n\t\t}\n\t}\n\t\n\tPair solve(int x1, int y1, int x2, int y2) {\n\t\tif(mem[x1][y1][x2][y2].f != -1) return mem[x1][y1][x2][y2];\n\t\tint ss = all - demand( x1, y1, x2, y2 );\n\t\tPair p;\n\t\tif( ss > s ) {\n\t\t\tp = new Pair(-2, 0);\n\t\t}\n\t\telse p = new Pair(ss, 1);\n//\t\tdebug(x1, y1, x2, y2, p.f, p.s, demand(x1, y1, x2, y2));\n\t\tfor(int i=x1+1;i<x2;i++) {\n\t\t\tPair p1 = solve(x1, y1, i, y2);\n\t\t\tPair p2 = solve(i, y1, x2, y2);\n\t\t\tif( p1.f == -2 || p2.f == -2 ) continue;\n\t\t\tif( p.s < p1.s + p2.s ){\n\t\t\t\tp.f = max(p1.f, p2.f);\n\t\t\t\tp.s = p1.s + p2.s;\n\t\t\t}\n\t\t\telse if (p.s == p1.s + p2.s && max(p1.f, p2.f) < p.f)\n\t\t\t\tp.f = max(p1.f, p2.f);\n\t\t}\n\t\t\n\t\tfor(int i=y1+1;i<y2;i++) {\n\t\t\tPair p1 = solve(x1, y1, x2, i);\n\t\t\tPair p2 = solve(x1, i, x2, y2);\n\t\t\tif( p1.f == -2 || p2.f == -2 ) continue;\n\t\t\tif( p.s < p1.s + p2.s ){\n\t\t\t\tp.f = max(p1.f, p2.f);\n\t\t\t\tp.s = p1.s + p2.s;\n\t\t\t} \n\t\t\telse if (p.s == p1.s + p2.s && max(p1.f, p2.f) < p.f)\n\t\t\t\tp.f = max(p1.f, p2.f);\n\t\t}\n\t\t\n//\t\tdebug(\"  \", x1, y1, x2, y2, p.f, p.s);\n\t\treturn mem[x1][y1][x2][y2] = p;\n\t}\n\t\n\tint demand(int x1, int y1, int x2, int y2) {\n\t\treturn map[y2][x2] - map[y2][x1] - map[y1][x2] + map[y1][x1];\n\t}\n\t\n\tclass Pair {\n\t\tint f, s;\n\t\tPair(int f, int s) {\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint n = nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] cir = new int[n][4];\n\t\t\tint[] above = new int[n];// テ、ツクツ甘」ツ?ォテゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツつ凝・ツ??ァツ崢、\n\n\t\t\tint[] bitDP = new int[1 << n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = nextInt();\n\t\t\t\tint y = nextInt();\n\t\t\t\tint r = nextInt();\n\t\t\t\tint c = nextInt();\n\t\t\t\tcir[i][0] = x;\n\t\t\t\tcir[i][1] = y;\n\t\t\t\tcir[i][2] = r;\n\t\t\t\tcir[i][3] = c;\n\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t// テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??ァツ崢、テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ョテ・ツ按、テ・ツョツ?\n\t\t\t\t\tint jx = cir[j][0] - x;\n\t\t\t\t\tint jy = cir[j][1] - y;\n\t\t\t\t\tint jr = cir[j][2];\n\t\t\t\t\tdouble dist = Math.sqrt(jx * jx + jy * jy);\n\t\t\t\t\tif (dist < r + jr) {\n\t\t\t\t\t\tabove[i] += (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int bit = 0; bit < bitDP.length; bit++) {\n\t\t\t\t// テ・ツ按ーテゥツ?氾」ツ?療」ツ??」ツつ凝ゥツ?キテァツァツサテ」ツ??\n\t\t\t\tif (bit != 0 && bitDP[bit] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t// テ・ツ??テ」ツ?ィjテ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ\n\t\t\t\t\tif ((bit & (1 << i)) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t// テ・ツ??テ」ツ?ィjテ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ\n\t\t\t\t\t\tif ((bit & ((1 << i) + (1 << j))) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// iテ」ツ?ィjテ」ツ?ョテ、ツクツ甘」ツ?ォティツシツ嘉」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??」ツ?古・ツ?ィテゥツδィテ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツつ?\n\t\t\t\t\t\tif ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ティツ可イテ」ツ?古、ツクツ?ァツキツ津」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\t\t\t\t\t\tif (cir[i][3] == cir[j][3]) {\n\t\t\t\t\t\t\tint newbit = bit + (1 << i) + (1 << j);\n\t\t\t\t\t\t\tbitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);\n\t\t\t\t\t\t\tmax = Math.max(max, bitDP[newbit]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Planning Rolling Blackouts\npublic class Main{\n\n\tint h, w, s, S;\n\tint[][] a, sum;\n\tint[][][][] group, rest;\n\t\n\tint get(int i, int j, int k, int l){\n\t\treturn sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1];\n\t}\n\t\n\tvoid dfs(int i, int j, int k, int l){\n\t\tif(group[i][j][k][l]!=-1)return;\n\t\tif(s<S-get(i, j, k, l))return;\n\t\tif(group[i][j][k][l]<1){\n\t\t\tgroup[i][j][k][l] = 1;\n\t\t\trest[i][j][k][l] = s-S+get(i, j, k, l);\n\t\t}\n\t\telse if(group[i][j][k][l]==1){\n\t\t\trest[i][j][k][l] = Math.max(rest[i][j][k][l], 0);\n\t\t}\n\t\tfor(int ni=i;ni<k;ni++){\n\t\t\tdfs(i, j, ni, l); dfs(ni+1, j, k, l);\n\t\t\tif(group[i][j][ni][l]==-1||group[ni+1][j][k][l]==-1)continue;\n\t\t\tif(group[i][j][k][l]<group[i][j][ni][l]+group[ni+1][j][k][l]){\n\t\t\t\tgroup[i][j][k][l] = group[i][j][ni][l]+group[ni+1][j][k][l];\n\t\t\t\trest[i][j][k][l] = Math.min(rest[i][j][ni][l], rest[ni+1][j][k][l]);\n\t\t\t}\n\t\t\telse if(group[i][j][k][l]==group[i][j][ni][l]+group[ni+1][j][k][l])\n\t\t\t\trest[i][j][k][l]=Math.max(rest[i][j][k][l], Math.min(rest[i][j][ni][l], rest[ni+1][j][k][l]));\n\t\t}\n\t\tfor(int nj=j;nj<l;nj++){\n\t\t\tdfs(i, j, k, nj); dfs(i, nj+1, k, l);\n\t\t\tif(group[i][j][k][nj]==-1||group[i][nj+1][k][l]==-1)continue;\n\t\t\tif(group[i][j][k][l]<group[i][j][k][nj]+group[i][nj+1][k][l]){\n\t\t\t\tgroup[i][j][k][l] = group[i][j][k][nj]+group[i][nj+1][k][l];\n\t\t\t\trest[i][j][k][l] = Math.min(rest[i][j][k][nj], rest[i][nj+1][k][l]);\n\t\t\t}\n\t\t\telse if(group[i][j][k][l]==group[i][j][k][nj]+group[i][nj+1][k][l])\n\t\t\t\trest[i][j][k][l]=Math.max(rest[i][j][k][l], Math.min(rest[i][j][k][nj], rest[i][nj+1][k][l]));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th = sc.nextInt(); w = sc.nextInt(); s = sc.nextInt();\n\t\t\tif((h|w|s)==0)break;\n\t\t\ta = new int[h+1][w+1]; sum = new int[h+1][w+1];\n\t\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tsum[i][j] = sum[i-1][j] + sum[i][j-1] + a[i][j] - sum[i-1][j-1];\n\t\t\t}\n\t\t\tgroup = new int[h+1][w+1][h+1][w+1]; rest = new int[h+1][w+1][h+1][w+1];\n\t\t\tfor(int i=0;i<=h;i++)for(int j=0;j<=w;j++)for(int k=0;k<=h;k++)for(int l=0;l<=w;l++)group[i][j][k][l]=rest[i][j][k][l]=-1;\n\t\t\tS = get(1, 1, h, w);\n\t\t\tdfs(1,1,h,w);\n\t\t\tSystem.out.println(group[1][1][h][w]+\" \"+rest[1][1][h][w]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug =　false;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[] { -1, -1 };\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = ret;\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint w, h, s;\n\tint[][] sum;\n\tint sumAll;\n\t\n\tint sum(int x1, int y1, int x2, int y2) {\n\t\treturn sum[y2][x2] - sum[y2][x1-1] - sum[y1-1][x2] + sum[y1-1][x1-1];\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt(); w = sc.nextInt(); s = sc.nextInt();\n\t\t\t\n\t\t\tif( (h|w|s) == 0 ) break;\n\t\t\tsum = new int[h+1][w+1];\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) \n\t\t\t\tsum[i][j] = sc.nextInt() + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t\t\t\n\t\t\tsumAll = sum[h][w];\n\t\t\t\n\t\t\tmem = new P[w+1][h+1][w+1][h+1];\n\t\t\tP ans = solve(1, 1, w, h);\n//\t\t\tdebug(ans.sub);\n\t\t\tSystem.out.println(ans.max + \" \" + ( s - ( sumAll - ans.sub) ) );\n\t\t}\n\t}\n\t\n\tP[][][][] mem;\n\tP solve(int x1, int y1, int x2, int y2) {\n\t\tif(mem[x1][y1][x2][y2] != null) return mem[x1][y1][x2][y2];\n\t\tif( sum(x1, y1, x2, y2) < sumAll - s ) return mem[x1][y1][x2][y2] = new P(-1, -1);\n\t\t\n\t\tint max = 1; int sub = sum(x1, y1, x2, y2);\n\t\t\n\t\tfor(int x=x1;x<x2;x++) {\n\t\t\tP l = solve(x1, y1, x, y2), r = solve(x+1, y1, x2, y2);\n\t\t\tif(l.max <= 0 && r.max <= 0) continue;\n\t\t\t\n\t\t\tif(max < l.max + r.max) {\n\t\t\t\tmax = l.max + r.max;\n\t\t\t\tsub = min(l.sub, r.sub);\n\t\t\t}\n\t\t\telse if ( max == l.max + r.max ) {\n\t\t\t\tsub = max(sub, min(l.sub, r.sub));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=y1;y<y2;y++) {\n\t\t\tP u = solve(x1, y1, x2, y), d = solve(x1, y+1, x2, y2);\n\t\t\tif(u.max <= 0 && d.max <= 0) continue;\n\t\t\t\n\t\t\tif(max < u.max + d.max) {\n\t\t\t\tmax = u.max + d.max;\n\t\t\t\tsub = min(u.sub, d.sub);\n\t\t\t}\n\t\t\telse if ( max == u.max + d.max ) {\n\t\t\t\tsub = max(sub, min(u.sub, d.sub));\n\t\t\t}\n\t\t}\n//\t\tdebug(x1, y1, x2, y2, max, sub);\n\t\treturn mem[x1][y1][x2][y2] = new P(max, sub);\n\t}\n\t\n\tclass P {\n\t\tint max, sub;\n\t\tP(int max, int sub) {\n\t\t\tthis.max = max;\n\t\t\tthis.sub = sub;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.setIn(new FileInputStream(\"src/aoj1176/input.txt\"));\n\t\t\t//System.setOut(new PrintStream(new FileOutputStream(\"src/aoj1172/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tint [][] table;\n\tint R, C, S, K;\n\n\tint psum[][];\n\tint range(int r1, int c1, int r2, int c2) {\n\t\treturn psum[r2][c2] - psum[r1][c2] - psum[r2][c1] + psum[r1][c1];\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tfor (;sc.hasNext();) {\n\t\t\tR = sc.nextInt();\n\t\t\tC = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\ttable = new int[R][C];\n\n\t\t\tpsum = new int[R+1][C+1];\n\t\t\tfor (int r = 0; r < R; r++)\n\t\t\t\tfor (int c = 0; c < C; c++)\n\t\t\t\t\ttable[r][c] = sc.nextInt();\n\n\t\t\tfor (int r = 0; r < R; r++)\n\t\t\t\tfor (int c = 0; c < C; c++)\n\t\t\t\t\tpsum[r+1][c+1] = psum[r+1][c] + psum[r][c+1] - psum[r][c] + table[r][c];\n\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tfinal long mask = (1L << 31) - 1;\n\tlong dp[][][][];\n\tlong dp(int r1, int c1, int r2, int c2) {\n\t\tif (dp[r1][c1][r2][c2] != 0)\n\t\t\treturn dp[r1][c1][r2][c2];\n\t\tlong best_g = 1;\n\t\tlong best_k = range(r1, c1, r2, c2);\n\n\t\tlong res = (best_g << 31) + best_k;\n\t\tfor (int r = r1 + 1; r < r2; r++) {\n\t\t\tlong p1 = dp(r1, c1, r, c2);\n\t\t\tlong p2 = dp(r, c1, r2, c2);\n\n\t\t\tlong cur_g = (p1 + p2) >> 31;\n\t\t\tlong cur_k = min(p1 & mask, p2 & mask);\n\t\t\tif (cur_k >= K)\n\t\t\t\tres = max(res, (cur_g << 31) + cur_k);\n\t\t}\n\n\t\tfor (int c = c1 + 1; c < c2; c++) {\n\t\t\tlong p1 = dp(r1, c1, r2, c);\n\t\t\tlong p2 = dp(r1, c, r2, c2);\n\n\t\t\tlong cur_g = (p1 + p2) >> 31;\n\t\t\tlong cur_k = min(p1 & mask, p2 & mask);\n\t\t\tif (cur_k >= K)\n\t\t\t\tres = max(res, (cur_g << 31) + cur_k);\n\t\t}\n\n\t\treturn dp[r1][c1][r2][c2] = res;\n\t}\n\tvoid solve(){\n\t\tint total = range(0,0,R,C);\n\t\tK = total - S;\n\t\tdp = new long[R][C][R+1][C+1];\n\t\tlong res = dp(0,0,R,C);\n\n\t\tlong best_g = res >> 31;\n\t\tlong best_k = res & ((1 << 31) - 1);\n\t\tSystem.out.println(best_g + \" \" + (S - total + best_k));\n\t\treturn;\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int h, w, s, allSum, limit;\n    static int[][] u;\n\n    static int[][][][] memo;\n    static int[][][][][] dpMemo;\n    static int[][] ss;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            h = sc.nextInt();\n            w = sc.nextInt();\n            s = sc.nextInt();\n            if ((h | w | s) == 0) {\n                break;\n            }\n            u = new int[h][w];\n            ss = new int[h][w];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    u[i][j] = sc.nextInt();\n                }\n            }\n\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (i == 0) {\n                        if (j == 0) {\n                            ss[i][j] = u[i][j];\n                            continue;\n                        }\n                        ss[i][j] = ss[i][j - 1] + u[i][j];\n                        continue;\n                    }\n                    if (j == 0) {\n                        ss[i][j] = ss[i - 1][j] + u[i][j];\n                        continue;\n                    }\n                    ss[i][j] = ss[i - 1][j] + ss[i][j - 1] - ss[i - 1][j - 1] + u[i][j];\n                }\n            }\n            // arrayDump(u);\n            // arrayDump(ss);\n            memo = new int[h][w][h][w];\n            dpMemo = new int[h][w][h][w][2];\n            allSum = ss[h - 1][w - 1];\n            limit = allSum - s;\n            // System.out.println(\"limit: \" + limit);\n            int[] res = dp(0, 0, h - 1, w - 1);\n            // int k = 1;\n            // for (int i = 0; i < h - k; i++) {\n            //     for (int j = 0; j < w - k; j++) {\n            //         // System.out.print(areaSum(i, j, i + k, j + k) + \" \");\n            //         System.out.print(dp(i, j, i + k, j + k) + \" \");\n            //     }\n            //     System.out.println();\n            // }\n            // System.out.println();\n            System.out.println(res[0] + \" \" + res[1]);\n        }\n    }\n\n    public static int[] dp(int y1, int x1, int y2, int x2) {\n        if (dpMemo[y1][x1][y2][x2][0] != 0) {\n            return dpMemo[y1][x1][y2][x2];\n        }\n        int as = areaSum(y1, x1, y2, x2);\n        if (as < limit) {\n            return new int[]{-1, Integer.MAX_VALUE};\n        }\n        int max = 1;\n        int subs = as - limit;\n        for (int i = y1; i < y2; i++) {\n            int[] as1 = dp(y1, x1, i, x2);\n            int[] as2 = dp(i + 1, x1, y2, x2);\n            if (as1[0] == -1 || as2[0] == -1) {\n                continue;\n            }\n            int asum = as1[0] + as2[0];\n            int asub = Math.min(as1[1], as2[1]);\n            if (max < asum || (max == asum && subs < asub)) {\n                max = asum;\n                subs = asub;\n            }\n        }\n        for (int i = x1; i < x2; i++) {\n            int[] as1 = dp(y1, x1, y2, i);\n            int[] as2 = dp(y1, i + 1, y2, x2);\n            if (as1[0] == -1 || as2[0] == -1) {\n                continue;\n            }\n            int asum = as1[0] + as2[0];\n            int asub = Math.min(as1[1], as2[1]);\n            if (max < asum || (max == asum && subs < asub)) {\n                max = asum;\n                subs = asub;\n            }\n        }\n        dpMemo[y1][x1][y2][x2][0] = max;\n        dpMemo[y1][x1][y2][x2][1] = subs;\n        return dpMemo[y1][x1][y2][x2];\n    }\n\n    public static int areaSum(int y1, int x1, int y2, int x2) {\n        if (memo[y1][x1][y2][x2] == 0) {\n            if (y1 == 0 && x1 == 0) {\n                memo[y1][x1][y2][x2] = ss[y2][x2];\n            } else if (y1 == 0) {\n                memo[y1][x1][y2][x2] = ss[y2][x2] - ss[y2][x1 - 1];\n            } else if (x1 == 0) {\n                memo[y1][x1][y2][x2] = ss[y2][x2] - ss[y1 - 1][x2];\n            } else {\n                memo[y1][x1][y2][x2] = ss[y2][x2] - ss[y1 - 1][x2] - ss[y2][x1 - 1] + ss[y1 - 1][x1 - 1];\n            }\n        }\n        return memo[y1][x1][y2][x2];\n    }\n\n    public static void arrayDump(int[][] a) {\n        for (int i = 0, l = a.length; i < l; i++) {\n            for (int j = 0, l2 = a[0].length; j < l2; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner sc=new Scanner(System.in);\n\tstatic int h;\n\tstatic int w;\n\tstatic int mandatory;\n\tstatic int[][][][] sumArr;\n\tstatic int [][]arr;\n\tstatic int[][][][] Divdone;\n\tstatic int[][][][] Remdone;\n\t\n\tprivate void cal(){\n\t\t\n\t\twhile(true){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\t\n\t\tint reserve=sc.nextInt();\n\t\t\n\t\tif(h==0)\n\t\t\tbreak;\n\t\t\n\t\tarr=new int[h][w];\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tarr[i][j]=sc.nextInt();\n\t\t\n\t\tsumArr=new int[h][w][h][w];\n\t\tDivdone=new int[h][w][h][w];\n\t\tRemdone=new int[h][w][h][w];\n\t\t\n\t       for(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t    for(int p=0;p<w;p++){\n\t\t\t\t\t    sumArr[i][j][k][p]=-1;\n\t\t\t\t\t    Divdone[i][j][k][p]=-1;\n\t\t\t\t\t    Remdone[i][j][k][p]=-1;\n\t\t\t\t    }\n\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t\tfor(int p=0;p<w;p++){\n\t\t\t\t\t\tint temp=0;\n\t\t\t\t\t\tif(i<=k && j<=p)\n\t\t\t\t\t\t\tfor(int z=i;z<=k;z++)\n\t\t\t\t\t\t\t\tfor(int x=j;x<=p;x++)\n\t\t\t\t\t\t\t\t\ttemp+=arr[z][x];\n\t\t\t\t\t\tsumArr[i][j][k][p]=temp;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\tmandatory=sumArr[0][0][h-1][w-1]-reserve;\n\t\t\n\t\tPoint tmp=cut(0,0,h-1,w-1);\n\t\tSystem.out.println(tmp.x+\" \"+tmp.y);\n\t\t\n\t\t\n\n\t\t}\n\t\t\n\t}\n\t\n\tpublic Point cut(int a,int b,int c, int d){\n\t\tint maxDiv=1;\n\t\tint rem=0;\n\t\t\n\t\tfor(int i=a;i<c;i++){\n\t\t\tif(sumArr[a][b][i][d]>=mandatory && sumArr[i+1][b][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][i][d]==-1 && Remdone[a][b][i][d]==-1){\n\t\t\t\t\tPoint temp1=cut(a,b,i,d);\n\t\t\t\t\tDivdone[a][b][i][d]=temp1.x;\n\t\t\t\t\tRemdone[a][b][i][d]=temp1.y;\n\t\t\t\t}\n\t\t\t\tif(Divdone[i+1][b][c][d]==-1 && Remdone[i+1][b][c][d]==-1){\n\t\t\t\t\tPoint temp2=cut(i+1,b,c,d);\n\t\t\t\t\tDivdone[i+1][b][c][d]=temp2.x;\n\t\t\t\t\tRemdone[i+1][b][c][d]=temp2.y;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][i][d]+Divdone[i+1][b][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d])>rem){\n\t\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfor(int i=b;i<d;i++)\n\t\t\tif(sumArr[a][b][c][i]>=mandatory && sumArr[a][i+1][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][c][i]==-1 && Remdone[a][b][c][i]==-1){\n\t\t\t\t\tPoint temp1=cut(a,b,c,i);\n\t\t\t\t\tDivdone[a][b][c][i]=temp1.x;\n\t\t\t\t\tRemdone[a][b][c][i]=temp1.y;\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][i+1][c][d]==-1 && Remdone[a][i+1][c][d]==-1){\n\t\t\t\t\tPoint temp2=cut(a,i+1,c,d);\n\t\t\t\t\tDivdone[a][i+1][c][d]=temp2.x;\n\t\t\t\t\tRemdone[a][i+1][c][d]=temp2.y;\n\t\t\t\t}\t\t\t\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][c][i]+Divdone[a][i+1][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d])>rem){\n\t\t\t\t    rem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn maxDiv==1? new Point(1,sumArr[a][b][c][d]-mandatory):new Point(maxDiv,rem);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] argv){\n\t\tnew Main().cal();\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class AOJ1176 {\n\n\tint H;\n\tint W;\n\tint S;\n\tint[][] map;\n\tint[][] sum;\n\tPair[][][][] dp;\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tH = nextInt();\n\t\t\tW = nextInt();\n\t\t\tS = nextInt();\n\t\t\tif (H == 0) break;\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tsum = new int[H + 1][W + 1];\n\t\t\tdp = new Pair[H][H + 1][W][W + 1];\n\t\t\tfor(int r = 0; r < H; r++){\n\t\t\t\tfor(int c = 0; c < W; c++){\n\t\t\t\t\tmap[r][c] = nextInt();\n\t\t\t\t\tsum[r + 1][c + 1] = sum[r + 1][c] + sum[r][c + 1] - sum[r][c] + map[r][c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(recur(0, H, 0, W));\n\t\t}\n\t}\n\tpublic Pair recur(int r1, int r2, int c1, int c2){\n\t\tint s = sum[r2][c2] - sum[r2][c1] - sum[r1][c2] + sum[r1][c1];\n\t\tif(sum[H][W] - s > S) return null;\n\t\tif(dp[r1][r2][c1][c2] != null) return dp[r1][r2][c1][c2];\n\t\t\n\t\t//System.err.printf(\"%d %d %d %d\\n\", r1, r2, c1, c2);\n\t\tPair ans = new Pair(1, S - (sum[H][W] - s));\n\t\tfor(int r = r1 + 1; r < r2; r++){\n\t\t\tPair a = recur(r1, r, c1, c2);\n\t\t\tPair b = recur(r, r2, c1, c2);\n\t\t\tif(a != null && b != null){\n\t\t\t\tans = ans.max(a.add(b));\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tfor(int c = c1 + 1; c < c2; c++){\n\t\t\tPair a = recur(r1, r2, c1, c);\n\t\t\tPair b = recur(r1, r2, c, c2);\n\t\t\tif(a != null && b != null){\n\t\t\t\tans = ans.max(a.add(b));\n\t\t\t}\n\t\t}\n\t\t//System.err.println(\"---\");\n\t\treturn dp[r1][r2][c1][c2] = ans;\n\t}\n\t\n\tclass Pair implements Comparable<Pair>{\n\t\tfinal int group;\n\t\tfinal int yojo;\n\t\tpublic Pair(int group, int yojo){\n\t\t\tthis.group = group;\n\t\t\tthis.yojo = yojo;\n\t\t}\n\t\t\n\t\tpublic Pair max(Pair p){\n\t\t\tif(this.compareTo(p) <= 0){\n\t\t\t\treturn this;\n\t\t\t}else{\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int compareTo(Pair p){\n\t\t\tif(group == p.group){\n\t\t\t\treturn Integer.compare(p.yojo, yojo);\n\t\t\t}else{\n\t\t\t\treturn Integer.compare(p.group, group);\n\t\t\t}\n\t\t}\n\t\tpublic Pair add(Pair p){\n\t\t\treturn new Pair(group + p.group, Math.min(yojo, p.yojo));\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn group + \" \" + yojo;\n\t\t}\n\t}\n\t\n\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tout = new PrintWriter(System.out);\n\t\tnew AOJ1176().solve();\n\t\tout.flush();\n\t}\n\n\tpublic static int nextInt() {\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static long nextLong() {\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static String next() {\n\t\tint c;\n\t\twhile (!isAlNum(c = read())) {\n\t\t}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char) c);\n\t\twhile (isAlNum(c = read())) {\n\t\t\tbuild.append((char) c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\n\tprivate static int read() {\n\t\tif (bufferLength < 0)\n\t\t\tthrow new RuntimeException();\n\t\tif (bufferIndex >= bufferLength) {\n\t\t\ttry {\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufferLength <= 0)\n\t\t\t\treturn (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\n\tprivate static boolean isAlNum(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int[][] cost;\n\tpublic static int allcost;\n\tpublic static int[][][][] dp;\n\tpublic static int[][][][] max;\n\tpublic static int[][][][] min;\n\tpublic static int h, w, s;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = in.nextInt();\n\t\t\tw = in.nextInt();\n\t\t\ts = in.nextInt();\n\t\t\tif(h == 0) return;\n\t\t\tcost = new int[h][w];\n\t\t\tdp = new int[h][w][h][w];\n\t\t\tmax = new int[h][w][h][w];\n\t\t\tmin = new int[h][w][h][w];\n\t\t\tallcost = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tcost[i][j] = in.nextInt();\n\t\t\t\t\tallcost += cost[i][j];\n\t\t\t\t\tdp[i][j][i][j] = cost[i][j];\n\t\t\t\t\tmax[i][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w-1; j++){\n\t\t\t\t\tfor(int k=j+1; k<w; k++){\n\t\t\t\t\t\tdp[i][j][i][k] = dp[i][j][i][k-1] + cost[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tmin[i][j][i][j] = s - allcost + cost[i][j];\n\t\t\t\t\tfor(int k=j; k<w; k++){\n\t\t\t\t\t\tfor(int l=i+1; l<h; l++){\n\t\t\t\t\t\t\tdp[i][j][l][k] = dp[i][j][l-1][k] + dp[l][j][l][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(0, 0, w-1, h-1);\n\t\t\tSystem.out.println(max[0][0][h-1][w-1]+\" \"+min[0][0][h-1][w-1]);\n\t\t}\n\t}\n\t\n\tpublic static int dfs(int x1, int y1, int x2, int y2){\n\t\tif(max[y1][x1][y2][x2] != 0) return min[y1][x1][y2][x2];\n\t\tif(s - allcost + dp[y1][x1][y2][x2] < 0){\n\t\t\tmax[y1][x1][y2][x2] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tint mincand = s;\n\t\tint maxcand = 0;\n\t\tfor(int x=x1; x<x2; x++){\n\t\t\tint tmp = Math.min(dfs(x1, y1, x, y2), dfs(x+1, y1, x2, y2));\n\t\t\tif(tmp < 0) continue;\n\t\t\tif(maxcand == max[y1][x1][y2][x] + max[y1][x+1][y2][x2]){\n\t\t\t\tmincand = Math.max(mincand, tmp);\n\t\t\t}else if(maxcand < max[y1][x1][y2][x] + max[y1][x+1][y2][x2]){\n\t\t\t\tmaxcand = max[y1][x1][y2][x] + max[y1][x+1][y2][x2];\n\t\t\t\tmincand = tmp;\n\t\t\t}\n\t\t}\n\t\tfor(int y=y1; y<y2; y++){\n\t\t\tint tmp = Math.min(dfs(x1, y1, x2, y), dfs(x1, y+1, x2, y2));\n\t\t\tif(tmp < 0) continue;\n\t\t\tif(maxcand == max[y1][x1][y][x2] + max[y+1][x1][y2][x2]){\n\t\t\t\tmincand = Math.max(mincand, tmp);\n\t\t\t}else if(maxcand < max[y1][x1][y][x2] + max[y+1][x1][y2][x2]){\n\t\t\t\tmaxcand = max[y1][x1][y][x2] + max[y+1][x1][y2][x2];\n\t\t\t\tmincand = tmp;\n\t\t\t}\n\t\t}\n\t\tif(maxcand == 0){\n\t\t\tmaxcand = 1;\n\t\t\tmincand = s - allcost + dp[y1][x1][y2][x2];\n\t\t}\n\t\tmax[y1][x1][y2][x2] = maxcand;\n\t\treturn min[y1][x1][y2][x2] = mincand;\n\t}\n\t\n\tpublic static String dump(int[][] map, int h, int w){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[2];\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = new int[] { -1, -1 };\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[] { -1, -1 };\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = ret;\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class blackout2 {\n    Scanner sc=new Scanner(System.in);\n    static int h;\n    static int w;\n    static int mandatory;\n    static int[][][][] sumArr;\n    static int [][]arr;\n    static int[][][][] Divdone;\n    static int[][][][] Remdone;\n\t\n\tprivate void cal(){\n\t\t\n\t\twhile(true){\n\t\th=sc.nextInt();\n\t\tw=sc.nextInt();\n\t\t\n\t\tint reserve=sc.nextInt();\n\t\t\n\t\tif(h==0)\n\t\t\tbreak;\n\t\t\n\t\tarr=new int[h][w];\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tarr[i][j]=sc.nextInt();\n\t\t\n\t\tsumArr=new int[h][w][h][w];\n\t\tDivdone=new int[h][w][h][w];\n\t\tRemdone=new int[h][w][h][w];\n\t\t\n\t       for(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t    for(int p=0;p<w;p++){\n\t\t\t\t\t    sumArr[i][j][k][p]=-1;\n\t\t\t\t\t    Divdone[i][j][k][p]=-1;\n\t\t\t\t\t    Remdone[i][j][k][p]=-1;\n\t\t\t\t    }\n\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tfor(int k=0;k<h;k++)\n\t\t\t\t\tfor(int p=0;p<w;p++){\n\t\t\t\t\t\tint temp=0;\n\t\t\t\t\t\tif(i<=k && j<=p)\n\t\t\t\t\t\t\tfor(int z=i;z<=k;z++)\n\t\t\t\t\t\t\t\tfor(int x=j;x<=p;x++)\n\t\t\t\t\t\t\t\t\ttemp+=arr[z][x];\n\t\t\t\t\t\tsumArr[i][j][k][p]=temp;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\tmandatory=sumArr[0][0][h-1][w-1]-reserve;\n\t\t\n\t\tint[] tmp=new int[2];\n\t\ttmp=cut(0,0,h-1,w-1);\n\t\tSystem.out.println(tmp[0]+\" \"+tmp[1]);\n\t\t\n\t\t\n\n\t\t}\n\t\t\n\t}\n\n\n\tpublic int[] cut(int a,int b,int c, int d){\n\t\tint maxDiv=1;\n\t\tint rem=0;\n\t\tif(Divdone[a][b][c][d]==-1 && Remdone[a][b][c][d]==-1){\n\t\t   \t    \n\t\tfor(int i=a;i<c;i++){\n\t\t\tif(sumArr[a][b][i][d]>=mandatory && sumArr[i+1][b][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][i][d]==-1 && Remdone[a][b][i][d]==-1){\n\t\t\t\t\tint[] temp1=cut(a,b,i,d);\n\t\t\t\t\tDivdone[a][b][i][d]=temp1[0];\n\t\t\t\t\tRemdone[a][b][i][d]=temp1[1];\n\t\t\t\t}\n\t\t\t\tif(Divdone[i+1][b][c][d]==-1 && Remdone[i+1][b][c][d]==-1){\n\t\t\t\t\tint[] temp2=cut(i+1,b,c,d);\n\t\t\t\t\tDivdone[i+1][b][c][d]=temp2[0];\n\t\t\t\t\tRemdone[i+1][b][c][d]=temp2[1];\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][i][d]+Divdone[i+1][b][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][i][d]+Divdone[i+1][b][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][i][d],Remdone[i+1][b][c][d])>rem){\n\t\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfor(int i=b;i<d;i++)\n\t\t\tif(sumArr[a][b][c][i]>=mandatory && sumArr[a][i+1][c][d]>=mandatory){\n\t\t\t\tif(Divdone[a][b][c][i]==-1 && Remdone[a][b][c][i]==-1){\n\t\t\t\t\tint[] temp1=cut(a,b,c,i);\n\t\t\t\t\tDivdone[a][b][c][i]=temp1[0];\n\t\t\t\t\tRemdone[a][b][c][i]=temp1[1];\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][i+1][c][d]==-1 && Remdone[a][i+1][c][d]==-1){\n\t\t\t\t\tint[] temp2=cut(a,i+1,c,d);\n\t\t\t\t\tDivdone[a][i+1][c][d]=temp2[0];\n\t\t\t\t\tRemdone[a][i+1][c][d]=temp2[1];\n\t\t\t\t}\t\t\t\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]>maxDiv){\n\t\t\t\t\tmaxDiv=Divdone[a][b][c][i]+Divdone[a][i+1][c][d];\n\t\t\t\t\trem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t\t}\n\t\t\t\tif(Divdone[a][b][c][i]+Divdone[a][i+1][c][d]==maxDiv && \n\t\t\t\t   Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d])>rem){\n\t\t\t\t    rem=Math.min(Remdone[a][b][c][i],Remdone[a][i+1][c][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\treturn maxDiv==1? new int[]{1,sumArr[a][b][c][d]-mandatory}:new int[]{maxDiv,rem};}\n\t\t\telse\n\t\t\t    return new int[]{Divdone[a][b][c][d],Remdone[a][b][c][d]};\n\t\t\t\n\t\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] argv){\n\t\tnew blackout2().cal();\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w, s;\n\tint[][] table;\n\tint[][][][] dp;\n\tint[][][][] dem;\n\tint max_dem;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\ts = sc.nextInt();\n\t\t\tif( (h|w|s) == 0 ) break;\n\t\t\ttable = new int[h+1][w+1];\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\ttable[i][j] = sc.nextInt() + table[i-1][j] + table[i][j-1] - table[i-1][j-1];\n\t\t\t}\n\t\t\tdp = new int[w][h][w][h];\n\t\t\tdem = new int[w][h][w][h];\n\t\t\tfor(int[][][] a: dp) for(int[][] b: a) for(int[] c: b) fill(c, -1);\n\t\t\tmax_dem = 0;\n//\t\t\tdebug(table);\n\t\t\tSystem.out.println( dfs(0,0,w-1,h-1) + \" \" + dem[0][0][w-1][h-1] );\n\t\t\t\n//\t\t\tfor(int i=0;i<w;i++) for(int j=0;j<h;j++) debug(dem[i][j]);\n\t\t}\n\t}\n\t\n\tint demand(int x, int y, int w, int h) {\n\t\treturn table[y][x] - table[y][w+1] - table[h+1][x] + table[h+1][w+1];\n\t}\n\n\tint dfs(int x, int y, int w, int h) {\n\t\tif( dp[x][y][w][h] >= 0 ) return dp[x][y][w][h];\n//\t\tdebug(x, y, w, h);\n//\t\tdebug(table[this.h][this.w] - demand(x, y, w, h), demand(x,y,w,h));\n\t\tif( table[this.h][this.w] - demand(x, y, w, h) > s ) {\n\t\t\tdem[x][y][w][h] = INF;\n\t\t\treturn dp[x][y][w][h] = 0;\n\t\t}\n\t\t\n\t\tint gr = 1;\n\t\tint demand = -1;\n\t\tfor(int i=x;i<w;i++) {\n\t\t\tint f = dfs(x,y,i,h), s = dfs(i+1,y,w,h);\n\t\t\tif( f*s == 0 ) continue;\n\t\t\tif( gr < (f+s) ) {\n\t\t\t\tgr = f + s;\n\t\t\t\tdemand = min( dem[x][y][i][h], dem[i+1][y][w][h] );\n\t\t\t}\n\t\t\telse if( gr == (f+s)) {\n\t\t\t\tdemand = max( demand, min( dem[x][y][i][h], dem[i+1][y][w][h] ));\n\t\t\t}\n//\t\t\tdebug(x,y,w,h,demand,demand(x,y,i,h),demand(i+1,y,w,h));\n\t\t}\n\t\tfor(int i=y;i<h;i++) {\n\t\t\tint f = dfs(x,y,w,i), s = dfs(x,i+1,w,h);\n\t\t\tif( f*s == 0 ) continue;\n\t\t\tif( gr < (f+s) ) {\n\t\t\t\tgr = f + s;\n\t\t\t\tdemand = min( dem[x][y][w][i], dem[x][i+1][w][h] );\n\t\t\t}\n\t\t\telse if( gr == (f+s)) {\n\t\t\t\tdemand = max( demand, min( dem[x][y][w][i], dem[x][i+1][w][h] ));\n\t\t\t}\n//\t\t\tdebug(x,y,w,h,demand,demand(x,y,w,i),demand(x,i+1,w,h));\n\t\t}\n\t\tdem[x][y][w][h] = (demand > -1)? demand: s - ( table[this.h][this.w] - demand(x, y, w, h) );\n//\t\tdebug(demand(x,y,w,h),dem[x][y][w][h]);\n\t\treturn dp[x][y][w][h] = gr;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    \n\tprivate static StringTokenizer st;\n\n    public static void main ( String [] args ) throws IOException\n    {\n\n\tint h,w,s;\n\n\twhile(true){\n\t\n\t\tst = new StringTokenizer(br.readLine());\n\t\th = Integer.parseInt(st.nextToken());\n\t\tw = Integer.parseInt(st.nextToken());\n\t\ts = Integer.parseInt(st.nextToken());\n\t\tif( h == 0 && w == 0 && s == 0)\tbreak;\n\t    new Main().cal(h,w,s);\n\t}\n\t\n    }\n\n\nint max;\nint[][] area;\n\n    private void cal(int h, int w, int s) throws IOException \n    {\n\tint areaSum = 0;\n\tarea = new int[h][w];\n\tfor(int i=0; i < h; i++){\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int j=0; j < w; j++){\n\t\t\tarea[i][j] = Integer.parseInt(st.nextToken());\n\t\t\tareaSum += area[i][j];\n\t\t}\n\t}\n\t\n\t//cal max\n\tmax = areaSum - s;\n\tint[] out = grouping(0, 0, h, w);\n\tSystem.out.println(out[0]+\" \"+(out[1] - max));\n\t\n    }\n\n\n   private int[] grouping(int hs, int ws, int h, int w){\n\tif( hs == h || ws == w ){\n\tif( hs == h )\n\t\tint[] temp = {0, 0};\n\t\treturn temp;\n\t}\n\tint h1, h2, h3;\n\tint w1, w2, w3;\n\tint sum1, sum2, sum3;\n\tint grpNum;\n\tint[] ret = {1, calSum(hs, ws, h, w)};\n\tint tmpdep = 0;\n\tboolean didit = false;\n\n\tfor(int i = h; i >= hs; i--){\n\tfor(int j = w; j >= ws; j--){\n\t\tdidit = false;\n\t\th1 = i;\n\t\tw1 = j;\n\t\tif( h1 == h && w1 == w ){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( (sum1 = calSum(hs, ws, h1, w1)) >= max ){\n\t\tif( (sum2 = calSum(h1, ws, h, w)) >= max || sum2 == 0 ){\n\t\tif( (sum3 = calSum(hs, w1, h1, w)) >= max || sum3 == 0 ){\n\t\t\ttmpdep = sum1;\n\t\t\tgrpNum = 1;\n\n\t\t\tint[] tmp = grouping(h1, ws, h, w);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t \t}\n\n\t\t\ttmp = grouping(hs, w1, h1, w);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t\t}\n\n\t\t\tif( grpNum > ret[0] ) { ret[0] = grpNum; ret[1] = tmp[1]; }\n\t\t\tif( grpNum == ret[0] && tmpdep < ret[1] ) ret[1] = tmpdep;\n\t\t}\n\t\tdidit = true;\n\t\t}\n\t\t}\n\n\n\t\tif( (sum1 = calSum(hs, ws, h1, w1)) >= max ){\n\t\tif( (sum2 = calSum(h1, ws, h, w1)) >= max || sum2 == 0 ){\n\t\tif( (sum3 = calSum(hs, w1, h, w)) >= max || sum3 == 0){\n\t\t\ttmpdep = sum1;\n\t\t\tgrpNum =1;\n\n\t\t\tint[] tmp = grouping(h1, ws, h, w1);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t\t}\n\n\t\t\ttmp = grouping(hs, w1, h, w);\n\t\t\tgrpNum += tmp[0];\n\t\t\tif( tmpdep > tmp[1] && tmp[1] != 0 ){\n\t\t\t\ttmpdep = tmp[1];\n\t\t\t}\n\n\t\t\tif( grpNum > ret[0] ) { ret[0] = grpNum; ret[1] = tmp[1]; }\n\t\t\tif( grpNum == ret[0] && tmpdep > ret[1] ) ret[1] = tmpdep;\n\t\t}\n\t\tdidit = true;\n\t\t}\n\t\t}\n\n\t\tif(!didit)\tbreak;\n\n\t}\n\t}\n\treturn ret;\n   }\n\n   private int calSum(int hs, int  ws, int  h, int w){\n\tint tmpsum=0;\n\tfor(int i = hs; i < h; i++){\n\t\tfor(int j = ws; j < w; j++){\n\t\t\ttmpsum += area[i][j];\n\t\t}\n\t}\n\treturn tmpsum;\n   }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[] { -1, -1 };\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = ret;\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int s;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\ts = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[][] sum = getSumArray(a);\n\t\t\tint[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];\n\t\t\tint[] ret = dfs(0, 0, h, w, sum, dp);\n\t\t\tout.println(ret[0] + \" \" + (s - ret[1]));\n\t\t}\n\t}\n\n\tstatic int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {\n\t\tif (dp[lh][lw][rh][rw] != null)\n\t\t\treturn dp[lh][lw][rh][rw];\n\t\tint[] ret = new int[] { -1, -1 };\n\t\tint t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);\n\t\tif (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {\n\t\t\tret[0] = 1;\n\t\t\tret[1] = t;\n\t\t} else\n\t\t\treturn dp[lh][lw][rh][rw] = ret;\n\t\tfor (int i = lh + 1; i < rh; i++) {\n\t\t\tint[] p = dfs(i, lw, rh, rw, sum, dp);\n\t\t\tint[] q = dfs(lh, lw, i, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = lw + 1; i < rw; i++) {\n\t\t\tint[] p = dfs(lh, lw, rh, i, sum, dp);\n\t\t\tint[] q = dfs(lh, i, rh, rw, sum, dp);\n\t\t\tif (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {\n\t\t\t\tif (p[0] + q[0] > ret[0]) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t} else if (ret[1] > Math.max(p[1], q[1])) {\n\t\t\t\t\tret[0] = p[0] + q[0];\n\t\t\t\t\tret[1] = Math.max(p[1], q[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[lh][lw][rh][rw] = ret;\n\t}\n\n\tstatic int sum(int a, int b, int c, int d, int[][] s) {\n\t\treturn s[c][d] - s[c][b] - s[a][d] + s[a][b];\n\t}\n\n\tpublic static int[][] getSumArray(int[][] a) {\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] ret = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i + 1][j + 1] = a[i][j];\n\t\tfor (int i = 0; i <= h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tret[i][j + 1] += ret[i][j];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j <= w; j++)\n\t\t\t\tret[i + 1][j] += ret[i][j];\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing Number = System.Int64;\n//using static System.Math;\n//using static MathEx;\n//using P = System.Collections.Generic.KeyValuePair<int, int>;\n\n\nnamespace Program\n{\n    public class Solver\n    {\n\n\n        public void Solve()\n        {\n            for (;;)\n            {\n                var n = sc.Integer();\n                var m = sc.Integer();\n                var s = sc.Integer();\n                if (n == 0) return;\n\n                var dp = new int[n, m, n, m];\n                for (int i = 0; i < n; i++)\n                    for (int j = 0; j < m; j++)\n                        for (int k = 0; k < n; k++)\n                            for (int l = 0; l < m; l++)\n                                dp[i, j, k, l] = -1000000000;\n                var mat = Enumerate(n, x => sc.Integer(m));\n                var sum = mat.SelectMany(x => x).Sum();\n\n                var A = Enumerate(n + 1, x => new int[m + 1]);\n                for (int i = 0; i < n; i++)\n                    for (int j = 0; j < m; j++)\n                        A[i + 1][j + 1] = A[i][j + 1] + A[i + 1][j] + mat[i][j] - A[i][j];\n\n                Func<int, int, int, int, int> rec = null;\n                rec = (x, y, xx, yy) =>\n                  {\n                      if (dp[x, y, xx, yy] >= 0) return dp[x, y, xx, yy];\n                      var v = A[xx + 1][yy + 1] - A[xx + 1][y] - A[x][yy + 1] + A[x][y];\n                      if (sum - v > s) return dp[x, y, xx, yy] = -100000000;\n\n                      var ret = 1000000 + v;\n                      for (int i = x + 1; i <= xx; i++)\n                      {\n                          var l = rec(x, y, i - 1, yy);\n                          var r = rec(i, y, xx, yy);\n                          if (l < 0 || r < 0) continue;\n                          var a = l / 1000000;\n                          var b = l % 1000000;\n                          var c = r / 1000000;\n                          var d = r % 1000000;\n                          ret = Math.Max(ret, (a + c) * 1000000 + Math.Min(b, d));\n                      }\n                      for (int i = y + 1; i <= yy; i++)\n                      {\n                          var l = rec(x, y, xx, i - 1);\n                          var r = rec(x, i, xx, yy);\n                          if (l < 0 || r < 0) continue;\n                          var a = l / 1000000;\n                          var b = l % 1000000;\n                          var c = r / 1000000;\n                          var d = r % 1000000;\n                          ret = Math.Max(ret, (a + c) * 1000000 + Math.Min(b, d));\n                      }\n\n\n                      return dp[x, y, xx, yy] = ret;\n                  };\n                var ans = rec(0, 0, n - 1, m - 1);\n                IO.Printer.Out.WriteLine(\"{0} {1}\", ans / 1000000, -(sum - ans % 1000000 - s));\n\n\n\n            }\n        }\n        /*\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        char rc => sc.Char();\n\n        [System.Diagnostics.Conditional(\"DEBUG\")]\n        void put(params object[] a) => Debug.WriteLine(string.Join(\" \", a));\n\n        //*/\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static void Swap<T>(ref T a, ref T b)\n        {\n            var tmp = a;\n            a = b;\n            b = tmp;\n        }\n    }\n}\n\n#region main\n\nstatic class Ex\n{\n    //public static string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    //public static string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n\n    public static void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n\n#endregion\n#region Ex\n\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter\n    {\n        static Printer()\n        {\n            Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false };\n        }\n\n        public static Printer Out { get; set; }\n\n        public override IFormatProvider FormatProvider\n        {\n            get { return CultureInfo.InvariantCulture; }\n        }\n\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true))\n        {\n        }\n\n        public Printer(Stream stream, Encoding encoding) : base(stream, encoding)\n        {\n        }\n\n        public void Write<T>(string format, T[] source)\n        {\n            base.Write(format, source.OfType<object>().ToArray());\n        }\n\n        public void WriteLine<T>(string format, T[] source)\n        {\n            base.WriteLine(format, source.OfType<object>().ToArray());\n        }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream)\n        {\n            str = stream;\n        }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof;\n\n        public bool IsEndOfStream\n        {\n            get { return isEof; }\n        }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr < len) return buf[ptr++];\n            ptr = 0;\n            if ((len = str.Read(buf, 0, 1024)) > 0) return buf[ptr++];\n            isEof = true;\n            return 0;\n        }\n\n        public char Char()\n        {\n            byte b;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0;\n            byte b;\n            var ng = false;\n            do b = read(); while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-')\n            {\n                ng = true;\n                b = read();\n            }\n            for (; ; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                ret = ret * 10 + b - '0';\n            }\n        }\n\n        public int Integer()\n        {\n            return (isEof) ? int.MinValue : (int)Long();\n        }\n\n        public double Double()\n        {\n            var s = Scan();\n            return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN;\n        }\n\n        static T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n)\n        {\n            return enumerate(n, Char);\n        }\n\n        public string[] Scan(int n)\n        {\n            return enumerate(n, Scan);\n        }\n\n        public double[] Double(int n)\n        {\n            return enumerate(n, Double);\n        }\n\n        public int[] Integer(int n)\n        {\n            return enumerate(n, Integer);\n        }\n\n        public long[] Long(int n)\n        {\n            return enumerate(n, Long);\n        }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef rect(x, y, w, h)\n  #p ['rect', x, y, w, h]\n  $sums[y + h][x + w] - $sums[y + h][x] - $sums[y][x + w] + $sums[y][x]\nend\n\ndef count_div(x0, y0, w, h, ar = rect(x0, y0, w, h))\n  return $cache[y0][x0][h][w] if ! $cache[y0][x0][h][w].nil?\n\n  min_s = ar\n  max_gn = 1\n\n  for dy in (1...h)\n    ar0 = rect(x0, y0, w, dy)\n    next if ar0 < $limit\n    ar1 = rect(x0, y0 + dy, w, h - dy)\n    next if ar1 < $limit\n\n    gn0, s0 = count_div(x0, y0, w, dy, ar0)\n    gn1, s1 = count_div(x0, y0 + dy, w, h - dy, ar1)\n\n    gn = gn0 + gn1\n    s = (s0 < s1) ? s0 : s1\n\n    if max_gn < gn || (max_gn == gn && min_s < s)\n      max_gn = gn\n      min_s = s\n    end    \n  end\n\n  for dx in (1...w)\n    ar0 = rect(x0, y0, dx, h)\n    next if ar0 < $limit\n    ar1 = rect(x0 + dx, y0, w - dx, h)\n    next if ar1 < $limit\n\n    gn0, s0 = count_div(x0, y0, dx, h, ar0)\n    gn1, s1 = count_div(x0 + dx, y0, w - dx, h, ar1)\n\n    gn = gn0 + gn1\n    s = (s0 < s1) ? s0 : s1\n\n    if max_gn < gn || (max_gn == gn && min_s < s)\n      max_gn = gn\n      min_s = s\n    end    \n  end\n\n  $cache[y0][x0][h][w] = [max_gn, min_s]\nend\n\n### main\n\nloop do\n  h, w, sup = gets.split.map(&:to_i)\n  break if (h | w | sup) == 0\n\n  $dms = h.times.map{gets.split.map(&:to_i)}\n\n  $sums = (h + 1).times.map{(w + 1).times.map{0}}\n  for y in (0...h)\n    for x in (0...w)\n      $sums[y + 1][x + 1] =\n        $dms[y][x] + $sums[y + 1][x] + $sums[y][x + 1] - $sums[y][x]\n    end\n  end\n  #p $sums; exit\n\n  $limit = $sums[h][w] - sup\n  #p $limit\n  \n  $cache = h.times.map{w.times.map{(h + 1).times.map{(w + 1).times.map{nil}}}}\n\n  max_gn, min_s = count_div(0, 0, w, h)\n  puts [max_gn, min_s - $limit].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tac = Array.new(size + 1)\n\t\tac[0] = 0\n\t\t(1..size).each do |i|\n\t\t\tac[i] = ac[i-1] + self[i-1]\n\t\tend\n\t\tac\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\nend\n\ndef compute(y1, y2, x1, x2)\n\t$accum[y2][x2] - $accum[y1-1][x2] - $accum[y2][x1-1] + $accum[y1-1][x1-1]\nend\n\ndef b_split(y1, y2, x1, x2)\n\tcache = $b_memo[[y1,y2,x1,x2]]\n\treturn cache if cache\n\tk, save = 1, compute(y1, y2, x1, x2)\n\treturn nil if save < $min_save\n\treturn [k, save] if y1 == y2 && x1 == x2\n\n\t(y1..y2-1).each do |y|\n\t\tk1, s1 = v_split(y1, y, x1, x2) || next\n\t\tk2, s2 = b_split(y+1, y2, x1, x2) || next\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\n\t(x1..x2-1).each do |x|\n\t\tk1, s1 = h_split(y1, y2, x1, x) || next\n\t\tk2, s2 = b_split(y1, y2, x+1, x2) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\n\t# p [y1, y2, x1, x2]\n\t# p [k, save]\n\t$b_memo[[y1,y2,x1,x2]] = [k, save]\nend\n\ndef v_split(y1, y2, x1, x2)\n\tcache = $v_memo[[y1,y2,x1,x2]]\n\treturn cache if cache\n\tk, save = 1, compute(y1, y2, x1, x2)\n\treturn nil if save < $min_save\n\treturn [k, save] if y1 == y2 && x1 == x2\n\n\t(x1..x2-1).each do |x|\n\t\tk1, s1 = h_split(y1, y2, x1, x) || next\n\t\tk2, s2 = b_split(y1, y2, x+1, x2) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\n\t# p [y1, y2, x1, x2]\n\t# p [k, save]\n\t$v_memo[[y1,y2,x1,x2]] = [k, save]\nend\n\ndef h_split(y1, y2, x1, x2)\n\tcache = $h_memo[[y1,y2,x1,x2]]\n\treturn cache if cache\n\tk, save = 1, compute(y1, y2, x1, x2)\n\treturn nil if save < $min_save\n\treturn [k, save] if y1 == y2 && x1 == x2\n\n\t(y1..y2-1).each do |y|\n\t\tk1, s1 = v_split(y1, y, x1, x2) || next\n\t\tk2, s2 = b_split(y+1, y2, x1, x2) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\t# p [y1, y2, x1, x2]\n\t# p [k, save]\n\t$h_memo[[y1,y2,x1,x2]] = [k, save]\nend\n\nloop do\n\th, w, s = gets.split.map(&:to_i)\n\tbreak if h == 0\n\ta = (1..h).map { gets.split.map(&:to_i) }\n\t$accum = a.accum_2d\n\td = $accum[h][w]\n\tp $min_save = d - s\n\t\n\t$b_memo = Hash.new\n\t$h_memo = Hash.new\n\t$v_memo = Hash.new\n\tk, min_save = b_split(1, h, 1, w)\t\n\t\n\tp k\n\tp s - (d - min_save)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tac = Array.new(size + 1)\n\t\tac[0] = 0\n\t\t(1..size).each do |i|\n\t\t\tac[i] = ac[i-1] + self[i-1]\n\t\tend\n\t\tac\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\nend\n\ndef compute(y1, y2, x1, x2)\n\t$accum[y2][x2] - $accum[y1-1][x2] - $accum[y2][x1-1] + $accum[y1-1][x1-1]\nend\n\ndef encode(y1, y2, x1, x2)\n\t(y1 << 18) + (y2 << 12) + (x1 << 6) + x2\nend\n\ndef decode(code)\n\ty1 = (code >> 18) & 0b111111\n\ty2 = (code >> 12) & 0b111111\n\tx1 = (code >> 6) & 0b111111\n\tx2 = (code >> 0) & 0b111111\n\treturn [y1, y2, x1, x2]\nend\n\ndef b_split(code)\n\ty1, y2, x1, x2 = decode(code)\n\tcache = $b_memo[code]\n\treturn cache if cache\n\tk, save = 1, compute(y1, y2, x1, x2)\n\treturn $b_memo[code] = nil if save < $min_save\n\treturn $b_memo[code] = [k, save] if y1 == y2 && x1 == x2\n\n\t(y1..y2-1).each do |y|\n\t\tk1, s1 = v_split(encode(y1, y, x1, x2)) || next\n\t\tk2, s2 = b_split(encode(y+1, y2, x1, x2)) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\n\t(x1..x2-1).each do |x|\n\t\tk1, s1 = h_split(encode(y1, y2, x1, x)) || next\n\t\tk2, s2 = b_split(encode(y1, y2, x+1, x2)) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\n\t$b_memo[code] = [k, save]\nend\n\ndef v_split(code)\n\ty1, y2, x1, x2 = decode(code)\n\tcache = $v_memo[code]\n\treturn cache if cache\n\tk, save = 1, compute(y1, y2, x1, x2)\n\treturn $v_memo[code] = nil if save < $min_save\n\treturn $v_memo[code] = [k, save] if y1 == y2 && x1 == x2\n\n\t(x1..x2-1).each do |x|\n\t\tk1, s1 = h_split(encode(y1, y2, x1, x)) || next\n\t\tk2, s2 = b_split(encode(y1, y2, x+1, x2)) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\n\t$v_memo[code] = [k, save]\nend\n\ndef h_split(code)\n\ty1, y2, x1, x2 = decode(code)\n\tcache = $h_memo[code]\n\treturn cache if cache\n\tk, save = 1, compute(y1, y2, x1, x2)\n\treturn $h_memo[code] = nil if save < $min_save\n\treturn $h_memo[code] = [k, save] if y1 == y2 && x1 == x2\n\n\t(y1..y2-1).each do |y|\n\t\tk1, s1 = v_split(encode(y1, y, x1, x2)) || next\n\t\tk2, s2 = b_split(encode(y+1, y2, x1, x2)) || break\n\t\tk3 = k1 + k2\n\t\ts3 = (s1 < s2 ? s1 : s2)\n\t\tif k3 > k\n\t\t\tk, save = k3, s3\n\t\telsif k3 == k\n\t\t\tsave = s3 if s3 > save\n\t\tend\n\tend\n\t$h_memo[code] = [k, save]\nend\n\nloop do\n\th, w, s = gets.split.map(&:to_i)\n\tbreak if h == 0\n\ta = (1..h).map { gets.split.map(&:to_i) }\n\t$accum = a.accum_2d\n\td = $accum[h][w]\n\t$min_save = d - s\n\t\n\t$b_memo = Hash.new\n\t$h_memo = Hash.new\n\t$v_memo = Hash.new\n\tk, min_save = b_split(encode(1, h, 1, w))\t\n\t\n\t\n\tprintf(\"%d %d\\n\", k, s - (d - min_save))\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tac = Array.new(size + 1)\n\t\tac[0] = 0\n\t\t(1..size).each do |i|\n\t\t\tac[i] = ac[i-1] + self[i-1]\n\t\tend\n\t\tac\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\nend\t\t\n\ndef encode(i1, i2, j1, j2)\n    (i1 << 18) + (i2 << 12) + (j1 << 6) + j2\nend\n\ndef f(i1, i2, j1, j2)\n    key = encode(i1, i2, j1, j2)\n    cache = $memo[key]\n    return cache if cache\n\n    x = $a[i2][j2] - $a[i2][j1-1] - $a[i1-1][j2] + $a[i1-1][j1-1]\n    return nil if x < $target\n\n    if i1 == i2 && j1 == j2\n        return $memo[key] = [1, x - $target]\n    end\n\n    best_num = 1\n    best_afford = x - $target\n\n    if i1 < i2\n        (i1+1..i2).each do |i|\n            n1, a1 = f(i1, i-1, j1, j2)\n            next unless n1\n            n2, a2 = f(i, i2, j1, j2)\n            next unless n2\n            if n1 + n2 > (best_num || 0)\n                best_num = n1 + n2\n                best_afford = [a1, a2].min\n            elsif n1 + n2 == best_num\n                m = [a1, a2].min\n                best_afford = m if m > best_afford\n            end\n        end\n    end\n\n    if j1 < j2\n        (j1+1..j2).each do |j|\n            n1, a1 = f(i1, i2, j1, j-1)\n            next unless n1\n            n2, a2 = f(i1, i2, j, j2)\n            next unless n2\n            if n1 + n2 > (best_num || 0)\n                best_num = n1 + n2\n                best_afford = [a1, a2].min\n            elsif n1 + n2 == best_num\n                m = [a1, a2].min\n                best_afford = m if m > best_afford\n            end\n        end\n    end\n\n    $memo[key] = [best_num, best_afford]\nend\n\nloop do\n    h, w, s = gets.split.map(&:to_i)\n    break if h == 0\n    $a = (1..h).map {gets.split.map(&:to_i)}.accum_2d\n    $target = $a[-1][-1] - s\n    $memo = {}\n\n    puts f(1, h, 1, w) * ' '\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    int h, w, s;\n    while (readf(\"%d %d %d\\n\", &h, &w, &s), h || w || s) {\n        int[][] u = new int[][h];\n        foreach (i; 0 .. h) {\n            u[i] = readln.chomp.split(\" \").map!(to!int).array;\n        }\n\n        int[][] z = new int[][](h + 1, w + 1);\n        foreach (i; 0 .. w + 1) z[0][i] = 0;\n        foreach (i; 1 .. h + 1) {\n            int x = 0;\n            foreach (j; 1 .. w + 1) {\n                x += u[i - 1][j - 1];\n                z[i][j] = z[i - 1][j] + x;\n            }\n        }\n\n        int f(int sy, int sx, int gy, int gx) {\n            return z[gy][gx] - z[sy][gx] - z[gy][sx] + z[sy][sx];\n        }\n\n        struct A {\n            int c, r;\n            const int opCmp(const ref A a) const {\n                if (c == a.c) {\n                    return r - a.r;\n                }\n                return c - a.c;\n            }\n            string toString() {\n                return text(c, \" \", r);\n            }\n        }\n\n        int L = z[h][w] - s;\n\n        auto cache = new A[][][][](h, w, h + 1, w + 1);\n        A dfs(int sy, int sx, int gy, int gx) {\n            //[sy, sx, gy, gx].writeln;\n            if (cache[sy][sx][gy][gx].c > 0) \n                return cache[sy][sx][gy][gx];\n            auto ret = A(1, f(sy, sx, gy, gx) - L);\n            foreach (int y; sy .. gy) {\n                int z1 = f(sy, sx, y, gx);\n                if (z1 < L) continue;\n                int z2 = f(y, sx, gy, gx);\n                if (z2 < L) continue;\n                auto a = dfs(sy, sx, y, gx);\n                auto b = dfs(y, sx, gy, gx);\n                ret = max(ret, A(a.c + b.c, min(a.r, b.r)));\n            }\n            foreach (int x; sx .. gx) {\n                int z1 = f(sy, sx, gy, x);\n                if (z1 < L) continue;\n                int z2 = f(sy, x, gy, gx);\n                if (z2 < L) continue;\n                auto a = dfs(sy, sx, gy, x);\n                auto b = dfs(sy, x, gy, gx);\n                ret = max(ret, A(a.c + b.c, min(a.r, b.r)));\n            }\n            return cache[sy][sx][gy][gx] = ret;\n        }\n\n        dfs(0, 0, h, w).writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nbool solve() {\n    auto s = readln.split.map!(to!int);\n    auto H = s[0];\n    auto W = s[1];\n    auto S = s[2];\n    if (H == 0 || W == 0) return false;\n    auto A = H.iota.map!(_ => readln.split.map!(to!int).array).array;\n\n    auto B = new int[][](H+1, W+1);\n    foreach (i; 0..H) foreach (j; 0..W) B[i+1][j+1] = A[i][j];\n    foreach (i; 0..H+1) foreach (j; 0..W) B[i][j+1] += B[i][j];\n    foreach (j; 0..W+1) foreach (i; 0..H) B[i+1][j] += B[i][j];\n\n    int sum(int r1, int c1, int r2, int c2) {\n        return B[r2+1][c2+1] - B[r2+1][c1] - B[r1][c2+1] + B[r1][c1];\n    }\n\n    int total_cost = B[H][W];\n\n    auto mem = new Tuple!(int, int)[][][][](H, W, H, W);\n    foreach (i; 0..H) foreach (j; 0..W) foreach (k; 0..H) mem[i][j][k][] = tuple(-1, -1);\n\n    Tuple!(int, int) solve(int r1, int c1, int r2, int c2) {\n        if (mem[r1][c1][r2][c2][0] >= 0) return mem[r1][c1][r2][c2];\n        int rest = total_cost - sum(r1, c1, r2, c2);\n        if (rest > S) return tuple(-1, -1);\n\n        auto ret = tuple(1, rest);\n\n        foreach (i; r1..r2) {\n            auto ret1 = solve(r1, c1, i, c2);\n            auto ret2 = solve(i+1, c1, r2, c2);\n            if (ret1[0] == -1 || ret2[0] == -1) continue;\n            int a = ret1[0] + ret2[0];\n            int b = max(ret1[1], ret2[1]);\n            if (a > ret[0] || (a == ret[0] && b < ret[1])) {\n                ret = tuple(a, b);\n            }\n        }\n\n        foreach (j; c1..c2) {\n            auto ret1 = solve(r1, c1, r2, j);\n            auto ret2 = solve(r1, j+1, r2, c2);\n            if (ret1[0] == -1 || ret2[0] == -1) continue;\n            int a = ret1[0] + ret2[0];\n            int b = max(ret1[1], ret2[1]);\n            if (a > ret[0] || (a == ret[0] && b < ret[1])) {\n                ret = tuple(a, b);\n            }\n        }\n\n        mem[r1][c1][r2][c2] = ret;\n        return ret;\n    }\n\n    auto ans = solve(0, 0, H-1, W-1);\n    writeln(ans[0], \" \", S - ans[1]);\n\n    return true;\n}\n\nvoid main() {\n    while (solve) {}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass Ruiwa():\n    def __init__(self, a):\n        self.H = h = len(a)\n        self.W = w = len(a[0])\n        self.R = r = a\n        for i in range(h):\n            for j in range(1,w):\n                r[i][j] += r[i][j-1]\n\n        for i in range(1,h):\n            for j in range(w):\n                r[i][j] += r[i-1][j]\n\n    def search(self, x1, y1, x2, y2):\n        x2 -= 1\n        y2 -= 1\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        r = self.R\n        rr = r[y2][x2]\n        if x1 > 0 and y1 > 0:\n            return rr - r[y1-1][x2] - r[y2][x1-1] + r[y1-1][x1-1]\n        if x1 > 0:\n            rr -= r[y2][x1-1]\n        if y1 > 0:\n            rr -= r[y1-1][x2]\n\n        return rr\n\ndef main():\n    rr = []\n\n    def f(h,w,s):\n        a = [LI() for _ in range(h)]\n        rui = Ruiwa(a)\n        ss = rui.R[-1][-1] - s\n\n        fm = {}\n        def _f(x1,y1,x2,y2):\n            key = (x1,y1,x2,y2)\n            if key in fm:\n                return fm[key]\n            t = rui.search(x1,y1,x2,y2)\n            if t < ss:\n                fm[key] = (-1,-1)\n                return (-1,-1)\n            r = (1, t)\n            for x in range(x1+1,x2):\n                r1 = _f(x1,y1,x,y2)\n                if r1[0] < 0:\n                    continue\n                r2 = _f(x,y1,x2,y2)\n                if r2[0] < 0:\n                    continue\n                tr = (r1[0]+r2[0], min(r1[1], r2[1]))\n                if r < tr:\n                    r = tr\n            for y in range(y1+1,y2):\n                r1 = _f(x1,y,x2,y2)\n                if r1[0] < 0:\n                    continue\n                r2 = _f(x1,y1,x2,y)\n                if r2[0] < 0:\n                    continue\n                tr = (r1[0]+r2[0], min(r1[1], r2[1]))\n                if r < tr:\n                    r = tr\n            fm[key] = r\n            return r\n\n        r,rs = _f(0,0,w,h)\n\n        return '{} {}'.format(r, rs - ss)\n\n    while 1:\n        n,m,s = LI()\n        if n == 0 and m == 0 and s == 0:\n            break\n        rr.append(f(n,m,s))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#教室内の位置は右*中央\n#問題は「Eleven Lover」(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2182&lang=jp)\n#本当は問題「Planning Rolling Blackouts」(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1176&lang=jp)\n#を解こうとしたのですが、小区間での分割をひたすら統合する解法までは立ったものの実装力がなかったので一旦やめました\nwhile(True):\n    #今回はinputの数字を文字列として一桁ずつ扱った方が嬉しいのでint()しません\n    s = input()\n    m = len(s)\n    #0を弾くやつ\n    if s == \"0\":\n        quit()\n    #pdfに書いていた方針と全く同じやり方をします\n    #配列dpをA_i,jとしてとります\n    dp = [[0 for j in range(11)] for i in range(m)]\n    for i in range(m):\n        n = int(s[i])\n        #ここで、どこかの桁が0になってる時に注意します\n        #というのも、問題文中に「0から始まる数は11の倍数に含めない」としてあるからです\n        #したがって0が出た時はそこまでの数字を10倍する効果しか持たないことになります\n        if n == 0:\n            tmp = dp[i-1][1:]\n            tmp.reverse()\n            #dp[i][0]=dp[i-1][0]\n            #dp[i][k]=dp[i-1][11-k] (if k >= 1)となります(これがtmp.reverse()の意図)\n            dp[i] = [dp[i-1][0]]+tmp\n        else:\n            #やるだけ\n            tmp = dp[i-1][1:]\n            tmp.reverse()\n            #10倍なのでA[i][k] (k>=1)をリバース(上と同じ)\n            tmp = [dp[i-1][0]]+tmp\n            #i桁目の数字を見てその分A_i,jをずらします\n            #添字に注意\n            dp[i] = tmp[-n:]+tmp[:-n]\n            dp[i][n] += 1 #インクリメントも忘れずに\n    #あとはdp[k][0]を足すだけ\n    print(sum([i[0] for i in dp]))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef main(h, w, s):\n    u = [None] * h\n    acc = [None] * (h + 1)\n    acc[0] = [0] * (w + 1)\n    for i in range(h):\n        x = list(map(int, input().split()))\n        acc[i + 1] = [0] + x\n        u[i] = x\n    for i in range(h):\n        acci1 = acc[i + 1]\n        for j in range(w):\n            acci1[j + 1] += acci1[j]\n    for i in range(h):\n        acci = acc[i]\n        acci1 = acc[i + 1]\n        for j in range(w):\n            acci1[j + 1] += acci[j + 1]\n    dp = defaultdict(int)\n    allsum = acc[-1][-1]\n    def accsum(l, r, d, u):\n        return acc[u + 1][r + 1] - acc[u + 1][l] - acc[d][r + 1] + acc[d][l]\n    for wm in range(w):\n        for hm in range(h):\n            for l in range(w - wm):\n                r = l + wm\n                for d in range(h - hm):\n                    u = d + hm\n                    ac = accsum(l, r, d, u)\n                    res = [1, s - (allsum - ac)]\n                    for mw in range(l, r):\n                        tmp1 = dp[(l, mw, d, u)]\n                        tmp2 = dp[(mw + 1, r, d, u)]\n                        if tmp1[1] >= 0 and tmp2[1] >= 0:\n                            tmp = [tmp1[0] + tmp2[0], min(tmp1[1], tmp2[1])]\n                            if tmp[0] > res[0]:\n                                res = tmp\n                            elif tmp[0] == res[0] and tmp[1] > res[1]:\n                                res = tmp\n                    for mh in range(d, u):\n                        tmp1 = dp[(l, r, d, mh)]\n                        tmp2 = dp[(l, r, mh + 1, u)]\n                        if tmp1[1] >= 0 and tmp2[1] >= 0:\n                            tmp = [tmp1[0] + tmp2[0], min(tmp1[1], tmp2[1])]\n                            if tmp[0] > res[0]:\n                                res = tmp\n                            elif tmp[0] == res[0] and tmp[1] > res[1]:\n                                res = tmp\n                    dp[(l, r, d, u)] = res\n    print(*dp[(0, w - 1, 0, h - 1)])\n\nif __name__ == '__main__':\n    while 1:\n        h, w, s = map(int, input().split())\n        if h == w == s == 0:\n            break\n        main(h, w, s)\n\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(x1, y1, x2, y2):\n    return S[y2-1][x2-1] - S[y1-1][x2-1] - S[y2-1][x1-1] + S[y1-1][x1-1]\n\nINF = 10**18\ndef dfs(x1, y1, x2, y2):\n    key = (x1, y1, x2, y2)\n    if key in memo:\n        return memo[key]\n    val = calc(x1, y1, x2, y2)\n    if val < rest:\n        memo[key] = (0, -1)\n        return (0, -1)\n    res = (1, val)\n    for i in xrange(x1+1, x2):\n        k1, r1 = dfs(x1, y1, i, y2)\n        k2, r2 = dfs(i, y1, x2, y2)\n        if r1 >= 0 and r2 >= 0:\n            res = max(res, (k1+k2, min(r1, r2)))\n    for i in xrange(y1+1, y2):\n        k1, r1 = dfs(x1, y1, x2, i)\n        k2, r2 = dfs(x1, i, x2, y2)\n        if r1 >= 0 and r2 >= 0:\n            res = max(res, (k1+k2, min(r1, r2)))\n    memo[key] = res\n    return res\n\nwhile 1:\n    h, w, s = map(int, raw_input().split())\n    if h == 0:\n        break\n    U = [map(int, raw_input().split()) for i in xrange(h)]\n    S = [[0]*(w+1) for i in xrange(h+1)]\n    su = sum(sum(e) for e in U)\n    rest = su-s\n    memo = {}\n    for i in xrange(h):\n        tmp = 0\n        for j in xrange(w):\n            tmp += U[i][j]\n            S[i][j] = S[i-1][j] + tmp\n    k, r = dfs(0, 0, w, h)\n    print k, r - rest"
  }
]