[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll C(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\nint N;\nvi G[MAX_N];\nll dp[2010][2010][3];\nint ts[2010];\n\nvoid loop(int v) {\n\n\tint n = sz(G[v]);\n\tts[v] = 1;\n\trep(i, 0, n) {\n\t\tint to = G[v][i]; \n\t\tloop(to);\n\t\tts[v] += ts[to];\n\t}\n\n\tint m = ts[v];\n\n\tvector<vl> tdp[2] = {vector<vl>(m + 1, vl(3, 0)), vector<vl>(m + 1, vl(3, 0))};\n\ttdp[0][1][0] = 1;\n\tint now = 0, nex = 1;\n\tint cnt = 1;\n\trep(i, 0, n) {\n\t\tint to = G[v][i];\n\n\t\trep(j, 0, cnt + ts[to] + 1) {\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttdp[nex][j][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\trep(j, 0, cnt + 1) {\n\t\t\trep(k, 0, ts[to] + 1) {\n\t\t\t\trep(l, 0, 3) ADD(tdp[nex][j + k][0], tdp[now][j][0] * dp[to][k][l] % mod);\n\t\t\t\trep(l, 0, 3) ADD(tdp[nex][j + k][1], tdp[now][j][1] * dp[to][k][l] % mod);\n\t\t\t\trep(l, 0, 3) ADD(tdp[nex][j + k][2], tdp[now][j][2] * dp[to][k][l] % mod);\n\n\t\t\t\tif(k < ts[to]) {\n\t\t\t\t\tADD(tdp[nex][j + k][1], tdp[now][j][0] * dp[to][k + 1][0] % mod * 2 % mod);\n\t\t\t\t\tADD(tdp[nex][j + k][1], tdp[now][j][0] * dp[to][k + 1][1] % mod);\n\t\t\t\t\tADD(tdp[nex][j + k][2], tdp[now][j][1] * dp[to][k + 1][0] % mod);\n\t\t\t\t\tADD(tdp[nex][j + k][2], tdp[now][j][1] * dp[to][k + 1][1] % mod * fiv[2] % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt += ts[to];\n\t\tswap(now, nex);\n\t}\n\trep(j, 0, m + 1) \n\t\trep(k, 0, 3) {\n\t\t\tdp[v][j][k] = tdp[now][j][k];\n\t\t}\n}\n\nvoid solve() {\n\tcin >> N;\n\tC_init(N);\n\trep(i, 0, N - 1) {\n\t\tint a; cin >> a; a--;\n\t\tG[a].pb(i + 1);\n\t}\n\tloop(0);\n\n\tll res = 0;\n\trep(j, 0, N + 1) {\n\t\trep(k, 0, 3) {\n\t\t\tif((N - j) % 2 == 0) ADD(res, dp[0][j][k] * fac[j] % mod);\n\t\t\telse ADD(res, mod - dp[0][j][k] * fac[j] % mod);\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\n\nint n, sz[MAXN], p[MAXN];\nvector<int> gph[MAXN];\n\nlint dp[MAXN][MAXN][2];\nlint fact[MAXN];\nlint aux[MAXN][3], nxt[MAXN][3];\n\nint main(){\n\tfact[0] = 1;\n\tfor(int i=1; i<MAXN; i++) fact[i] = fact[i-1] * i % mod;\n\tcin >> n;\n\tfor(int i=2; i<=n; i++){\n\t\tcin >> p[i];\n\t\tgph[p[i]].push_back(i);\n\t}\n\tfor(int i=n; i; i--){\n\t\tmemset(aux, 0, sizeof(aux));\n\t\taux[0][0] = 1;\n\t\tfor(auto &j : gph[i]){\n\t\t\tmemset(nxt, 0, sizeof(nxt));\n\t\t\tfor(int k=0; k<=sz[j]; k++){\n\t\t\t\tfor(int l=0; l<=sz[i]; l++){\n\t\t\t\t\tfor(int m=0; m<3; m++){\n\t\t\t\t\t\tnxt[k + l][m] += dp[j][k][0] * aux[l][m] % mod;\n\t\t\t\t\t\tif(m < 2) nxt[k + l + 1][m+1] += dp[j][k][1] * aux[l][m] % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[i] += sz[j];\n\t\t\tfor(int j=0; j<=sz[i]; j++){\n\t\t\t\tfor(int k=0; k<3; k++) aux[j][k] = nxt[j][k] % mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=sz[i]; j++){\n\t\t\tdp[i][j][0] = aux[j][0] + aux[j][1] * 2 + aux[j][2] * 2;\n\t\t\tdp[i][j][1] = aux[j][0] + aux[j][1];\n\t\t\tdp[i][j][0] %= mod;\n\t\t\tdp[i][j][1] %= mod;\n\t\t}\n\t\tsz[i]++;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tlint cur = dp[1][i][0] * fact[n - i] % mod;\n\t\tif(i & 1) cur = mod - cur;\n\t\tret += cur;\n\t}\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "..."
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = (int) 1e9 + 7;\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\nvoid ssub(int &a, int b)\n{\n    a -= b;\n    if (a < 0) a += MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint sub(int a, int b)\n{\n    ssub(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\nint fpow(int x, int n)\n{\n    if (n == 0) return 1;\n    int a = fpow(x, n >> 1);\n    a = mul(a, a);\n    if (n & 1) a = mul(a, x);\n    return a;\n}\nint rev(int x)\n{\n    return fpow(x, MOD - 2);\n}\n\nint rev2;\nint divi2(int a)\n{\n    return mul(a, rev2);\n}\n\nconst int N = 2005;\nvector <int> ch[N];\nint _C[N][N];\nint fact[N];\n\nint C(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    return _C[n][k];\n}\n\nstruct Ans\n{\n    vector <int> dp, dpEnd, dpOnly;\n\n    Ans() : dp({0, 0}), dpEnd({0, 0}), dpOnly({0, 1}) {}\n\n    Ans operator + (const Ans &A) const // root from this\n    {\n        Ans ans;\n        ans.dpOnly[1] = 0;\n        ans.dp.resize((int) dp.size() + (int) A.dp.size() - 1, 0);\n        ans.dpEnd.resize((int) dpEnd.size() + (int) A.dpEnd.size() - 1, 0);\n        ans.dpOnly.resize((int) dpOnly.size() + (int) A.dpOnly.size() - 1, 0);\n\n        for (int i = 1; i < (int) dp.size(); i++)\n            for (int j = 1; j < (int) A.dp.size(); j++)\n            {\n                int ox = dp[i], oEnd = dpEnd[i], oOnly = dpOnly[i], ax = A.dp[j], aEnd = A.dpEnd[j], aOnly = A.dpOnly[j];\n                int aAll = add(ax, add(aEnd, aOnly) );\n                                \n                sadd(ans.dp[i + j], mul(ox, aAll) );\n                sadd(ans.dpEnd[i + j], mul(oEnd, aAll) );\n                sadd(ans.dpOnly[i + j], mul(oOnly, aAll) );\n\n                sadd(ans.dp[i + j - 1], mul(oEnd, divi2(aEnd) ) );\n                sadd(ans.dpEnd[i + j - 1], mul(oOnly, mul(2, aOnly) ) );\n                sadd(ans.dpEnd[i + j - 1], mul(oOnly, aEnd) );\n                sadd(ans.dp[i + j - 1], mul(oEnd, aOnly) );\n            }\n        return ans;\n    }\n\n    int pvi()\n    {\n        int ans = 0;\n        for (int i = 1; i < (int) dp.size(); i++)\n        {\n            int cur = add(dp[i], add(dpEnd[i], dpOnly[i] ) );\n            cur = mul(cur, fact[i] );\n            if ( ( (int) dp.size() - i) % 2) \n                sadd(ans, cur);\n            else ssub(ans, cur);\n        }\n        return ans;\n    }\n    void eprint(int id)\n    {\n        eprintf(\"---\\nv = %d\\n\", id);\n        for (int i = 1; i < (int) dp.size(); i++)\n        {\n            eprintf(\"%d : dp %d, dpEnd %d, dpOnly %d\\n\", i, dp[i], dpEnd[i], dpOnly[i] );\n        }\n    }\n};\n\n\nAns dfs(int v)\n{\n    Ans cur = Ans();\n    for (int to : ch[v] )\n    {\n        eprintf(\"%d -> %d\\n\", v, to);\n//        cur.eprint(10 + v);\n        cur = cur + dfs(to);\n    }\n//    cur.eprint(v);\n    return cur;\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n    for (int i = 0; i < N; i++)\n    {\n        _C[i][i] = _C[i][0] = 1;\n        for (int j = 1; j < i; j++)\n            _C[i][j] = add(_C[i - 1][j], _C[i - 1][j - 1] );\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N; i++)\n        fact[i] = mul(fact[i - 1], i);\n\n    rev2 = rev(2);\n\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        x--;\n        ch[x].push_back(i);\n    }\n\n    Ans ans = dfs(0);\n    int answer = ans.pvi();\n    printf(\"%d\\n\", answer);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nvector<int> g[2100];\nint sz[2100];\nlong long dp[2][2100][2100];\nlong long dp2[3][2100][4100];\nlong long fact[3100];\nvoid solve(int a){\n//\t\tprintf(\"%d\\n\",a);fflush(stdout);\n\tint n=g[a].size();\n\tdp2[0][0][0]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tsolve(g[a][i]);\n\t\tint T=sz[a];\n\t\tsz[a]+=sz[g[a][i]];\n\t\tint to=g[a][i];\n\t\tfor(int j=0;j<=sz[a]+10;j++){\n\t\t\tdp2[0][i+1][j]=dp2[1][i+1][j]=dp2[2][i+1][j]=0;\n\t\t}\n\t\tfor(int j=0;j<=T;j++){\n\n\t\t\tfor(int k=0;k<=sz[g[a][i]]+1;k++){\n\t\t\t\tdp2[0][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[0][i][j]*dp[0][to][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[1][i+1][j+k]+dp2[0][i][j]*dp[1][to][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[1][i+1][j+k]+dp2[1][i][j]*dp[0][to][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[2][i+1][j+k]+dp2[1][i][j]*dp[1][to][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[2][i+1][j+k]+dp2[2][i][j]*dp[0][to][k])%mod;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//\tprintf(\"AA\\n\");fflush(stdout);\n\tfor(int i=0;i<=sz[a];i++){\n\t\tdp[0][a][i]=(dp2[0][n][i]+dp2[1][n][i]*2+dp2[2][n][i]*2)%mod;\n\t\tdp[1][a][i+1]=(dp2[0][n][i]+dp2[1][n][i])%mod;\n\t//\tprintf(\"%d %d: %lld %lld\\n\",a,i,dp[0][a][i],dp[1][a][i]);\n\n\t}\n\t//\tprintf(\"%d %d: %lld %lld\\n\",a,sz[a]+1,dp[0][a][sz[a]+1],dp[1][a][sz[a]+1]);\n\tsz[a]++;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p;scanf(\"%d\",&p);\n\t\tp--;\n\t//\tprintf(\"%d %d\\n\",i+1,p);fflush(stdout);\n\t\tg[p].push_back(i+1);\n\t}\n\tsolve(0);\n\tlong long ret=0;\n\tfact[0]=1;\n\tfor(int i=1;i<3100;i++)fact[i]=fact[i-1]*i%mod;\n\n\tfor(int i=0;i<=a;i++){\n\t//\tprintf(\"%d: %lld\\n\",i,dp[0][0][i]);\n\t\tif(i%2==0)ret=(ret+dp[0][0][i]*fact[a-i]%mod)%mod;\n\t\telse ret=(ret+mod-dp[0][0][i]*fact[a-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\n#define int ll\nconst int mod = 1e9+7;\nconst int N = 2007;\nconst int inv2 = (mod+1)/2;\n\nint n;\n\nVI G[N];\n\nint sub[N];\nint dp[2][N][N][3][2]; //[korzen][ile skladowych][stopien korzenia][parzystosc liczby krawedzi]\nint c[N];\n\nvoid dfs(int v)\n{\n\tsub[v] = 1;\n\n\tdp[c[v]][v][1][0][0] = 1;\n\n\tfor(auto u:G[v])\n\t{\n\t\tdfs(u);\n\n\t\tfor(int degv = 2; degv >= 0; --degv)\n\t\t{\n\t\t\tfor(int sv = sub[v]; sv >= 1; --sv)\n\t\t\t{\n\t\t\t\tfor(int pv = 0; pv < 2; ++pv)\n\t\t\t\t{\n\t\t\t\t\tfor(int degu = 2; degu >= 0; --degu)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int su = sub[u]; su >= 1; --su)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int pu = 0; pu < 2; ++pu)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(degv<=1 && degu<=1) //uzywam krawedzi\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint ndeg = degv+1;\n\t\t\t\t\t\t\t\t\tint np = (pv+pu+1)%2;\n\t\t\t\t\t\t\t\t\tint ns = sv+su-1;\n\t\t\t\t\t\t\t\t\tint mult = 1;\n\n\t\t\t\t\t\t\t\t\tif(degv==0 && degu==0)\n\t\t\t\t\t\t\t\t\t\tmult *= 2;\n\t\t\t\t\t\t\t\t\telse if(degv==1 && degu==1)\n\t\t\t\t\t\t\t\t\t\tmult *= inv2;\n\n\t\t\t\t\t\t\t\t\tdp[c[v]^1][v][ns][ndeg][np] += mult*dp[c[v]][v][sv][degv][pv]%mod*dp[c[u]][u][su][degu][pu]%mod;\n\t\t\t\t\t\t\t\t\tdp[c[v]^1][v][ns][ndeg][np] %= mod;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t//nie uzywam krawedzi\n\n\t\t\t\t\t\t\t\tint ndeg = degv;\n\t\t\t\t\t\t\t\tint np = (pv+pu)%2;\n\t\t\t\t\t\t\t\tint ns = sv+su;\n\n\t\t\t\t\t\t\t\tdp[c[v]^1][v][ns][ndeg][np] += dp[c[v]][v][sv][degv][pv]*dp[c[u]][u][su][degu][pu]%mod;\n\t\t\t\t\t\t\t\tdp[c[v]^1][v][ns][ndeg][np] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[c[v]][v][sv][degv][pv] = 0;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\tc[v] ^= 1;\n\t\tsub[v] += sub[u];\n\t}\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 2; i <= n; ++i)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tG[x].pb(i);\n\t}\n\n\tdfs(1);\n\n\tint fact = 1;\n\tint ans = 0;\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfact = fact*i%mod;\n\n\t\tfor(int deg = 0; deg < 3; ++deg)\n\t\t{\n\t\t\tans -= fact*dp[c[1]][1][i][deg][1]%mod;\n\t\t\tans += fact*dp[c[1]][1][i][deg][0]%mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\n\tans += mod;\n\tans %= mod;\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[2020],NC[2020];\nvector<int> E[2020];\nint C[2020];\n\nll dp[2020][2020][3];\nll mo=1000000007;\n\nll fact[2020];\nll dp2[2020][3];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(i=1;i<N;i++) {\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tE[P[i]].push_back(i);\n\t}\n\t\n\tfact[0]=1;\n\tFOR(i,N) fact[i+1]=fact[i]*(i+1)%mo;\n\t\n\t\n\t\n\tfor(i=N-1;i>=0;i--) {\n\t\tC[i]=1;\n\t\tdp[i][1][0]=1;\n\t\t\n\t\tFORR(e,E[i]) {\n\t\t\t\n\t\t\tfor(x=1;x<=C[i];x++) for(y=1;y<=C[e];y++) {\n\t\t\t\t// not con\n\t\t\t\t(dp2[x+y][0]+=dp[i][x][0]*(dp[e][y][0]+2*dp[e][y][1]+2*dp[e][y][2]))%=mo;\n\t\t\t\t(dp2[x+y][1]+=dp[i][x][1]*(dp[e][y][0]+2*dp[e][y][1]+2*dp[e][y][2]))%=mo;\n\t\t\t\t(dp2[x+y][2]+=dp[i][x][2]*(dp[e][y][0]+2*dp[e][y][1]+2*dp[e][y][2]))%=mo;\n\t\t\t\t// con\n\t\t\t\t(dp2[x+y-1][1]+=dp[i][x][0]*(dp[e][y][0]+dp[e][y][1]))%=mo;\n\t\t\t\t(dp2[x+y-1][2]+=dp[i][x][1]*(dp[e][y][0]+dp[e][y][1]))%=mo;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tC[i]+=C[e];\n\t\t\tFOR(j,C[i]+2) FOR(x,3) dp[i][j][x]=dp2[j][x], dp2[j][x]=0;\n\t\t}\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=N;i++) {\n\t\tif((N-i)%2==0) ret+=(dp[0][i][0]+2*dp[0][i][1]+2*dp[0][i][2])*fact[i]%mo;\n\t\telse ret-=(dp[0][i][0]+2*dp[0][i][1]+2*dp[0][i][2])*fact[i]%mo;\n\t}\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nvector<llint> G[2005];\nllint size[2005];\nllint dp[2005][2005][3];\nllint dp2[2005][2005][3];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint dfs(int v)\n{\n\tsize[v] = 1;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tsize[v] += dfs(G[v][i]);\n\t}\n\t\n\tllint m = G[v].size();\n\tfor(int i = 0; i <= m; i++){\n\t\tfor(int j = 0; j <= size[v]; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tdp2[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tdp2[0][0][0] = 1;\n\t\n\tllint sum = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tllint u = G[v][i];\n\t\tfor(int j = 0; j <= sum; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tfor(int s = 0; s <= size[u]; s++){\n\t\t\t\t\tfor(int t = 0; t < 3; t++){\n\t\t\t\t\t\tllint mul = 1;\n\t\t\t\t\t\tif(t == 1) mul = 2;\n\t\t\t\t\t\t(dp2[i+1][j+s][k] += dp2[i][j][k] * dp[u][s][t] % mod * mul % mod) %= mod;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(k < 2 && t != 2){\n\t\t\t\t\t\t\t(dp2[i+1][j+s+1][k+1] += dp2[i][j][k] * dp[u][s][t] % mod) %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum += size[u];\n\t}\n\t\n\tfor(int j = 0; j <= size[v]; j++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tdp[v][j][k] = dp2[m][j][k];\n\t\t\tif(k == 2) dp[v][j][k] *= 2, dp[v][j][k] %= mod;\n\t\t}\n\t}\n\t\n\treturn size[v];\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tmake_fact();\n\t\n\tcin >> n;\n\tllint p;\n\tfor(int i = 2; i <= n; i++){\n\t\tcin >> p;\n\t\tG[p].push_back(i);\n\t}\n\t\n\tdfs(1);\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tllint sum = 0;\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tif(j == 1) dp[1][i][j] *= 2, dp[1][i][j] %= mod;\n\t\t\tsum += dp[1][i][j], sum %= mod;\n\t\t}\n\t\tllint tmp = fact[n-i] * sum % mod;\n\t\tif(i % 2) ans += mod - tmp, ans %= mod;\n\t\telse ans += tmp, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 16;\ntemplate <typename T, T mod = MOD<T>>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>>;\nusing mll = ModInt<ll, MOD<ll>>;\nusing Poly = std::vector<mll>;\nPoly operator*(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = d1 + d2;\n    Poly ans(d, 0);\n    for (int i = 0; i <= d1; i++) {\n        for (int j = 0; j < d2; j++) { ans[i + j] += p1[i] * p2[j]; }\n    }\n    return ans;\n}\nPoly operator*(const ll s, const Poly& p2)\n{\n    const int d = p2.size() - 1;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d; i++) { ans[i] = p2[i] * d; }\n    return ans;\n}\nPoly operator+(const Poly& p1, const Poly& p2)\n{\n    const int d = p1.size() - 1;\n    assert(p2.size() == d + 1);\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d; i++) { ans[i] = p1[i] + p2[i]; }\n    return ans;\n}\n\nint main()\n{\n    int N;\n    std::cin >> N;\n    std::vector<std::vector<int>> g(N);\n    for (int i = 1, p; i < N; i++) { std::cin >> p, g[p - 1].push_back(i); }\n    // vi以下のパス分割全体で、根viの次数がj, 連結成分数k\n    // 2^{連結成分数}/2^{孤立点数} の和\n    std::vector<std::vector<Poly>> dp(N, std::vector<std::vector<mll>>(3, Poly{1}));\n    auto dfs = [&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) { self(self, to); }\n        Poly p0{1}, p1{1}, p2{1};\n        for (const int to : g[s]) {\n            const Poly z = dp[to][0] + dp[to][1] + dp[to][2];\n            const Poly o = 2 * dp[to][0] + dp[to][1];\n            p0 = p0 * z;\n            p1 = p1 * z + p0 * o;\n            p2 = p2 * z + p1 * o;\n        }\n        dp[s][0] = p0 * Poly{0, 1};\n        dp[s][1] = p1;\n        for (int i = 1; i < p2.size(); i++) { p2[i - 1] = p2[i] * (MOD<ll> + 1) / 2; }\n        dp[s][2] = p2;\n    };\n    dfs(dfs, 0);\n    mll p = 1, ans = 0;\n    const Poly f = dp[0][0] + dp[0][1] + dp[0][2];\n    for (int i = 0; i <= N; i++) {\n        ans += (i % 2 == 0 ? p * f[i] : (-p) * f[i]);\n        p *= (i + 1);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2010\n#define mod 1000000007\nusing namespace std;\nstruct edge{\n\tint r,nxt;\n}e[maxn<<1];\nint head[maxn],esz,fac[maxn],dp[maxn][maxn][3],n;\nvoid addedge(int u,int v){\n\te[++esz].r=v;e[esz].nxt=head[u];head[u]=esz;\n}\nint dfs(int u){\n\tdp[u][0][0]=1;\n\tint sz=1,s;\n\tfor(int t=head[u],v;t;t=e[t].nxt){\n\t\ts=dfs(v=e[t].r);\n\t\tfor(int i=sz-1;i>=0;--i)\n\t\t\tfor(int j=s-1;j>=0;--j){\n\t\t\t\tint A=(1ll*dp[v][j][0]+dp[v][j][1]+dp[v][j][2])%mod;\n\t\t\t\tdp[u][i+j+1][1]=(dp[u][i+j+1][1]+1ll*dp[u][i][0]*(2ll*dp[v][j][0]+dp[v][j][1]))%mod;\n\t\t\t\tdp[u][i+j+1][2]=(dp[u][i+j+1][2]+1ll*dp[u][i][1]*(dp[v][j][0]+1ll*dp[v][j][1]*(mod+1)/2%mod))%mod;\n\t\t\t\tif(j==0){\n\t\t\t\t\tdp[u][i][0]=1ll*dp[u][i][0]*A%mod;\n\t\t\t\t\tdp[u][i][1]=1ll*dp[u][i][1]*A%mod;\n\t\t\t\t\tdp[u][i][2]=1ll*dp[u][i][2]*A%mod;\n\t\t\t\t} else {\n\t\t\t\t\tdp[u][i+j][0]=(dp[u][i+j][0]+1ll*dp[u][i][0]*A)%mod;\n\t\t\t\t\tdp[u][i+j][1]=(dp[u][i+j][1]+1ll*dp[u][i][1]*A)%mod;\n\t\t\t\t\tdp[u][i+j][2]=(dp[u][i+j][2]+1ll*dp[u][i][2]*A)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tsz+=s;\n\t}\n\treturn sz;\n}\nint main(){\n\tscanf(\"%d\",&n),fac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tfor(int i=2,x;i<=n;++i) \n\t\tscanf(\"%d\",&x),addedge(x,i);\n\tdfs(1);\n\tint ans=0;\n\tfor(int i=0;i<n;++i)\n\t\tans=(ans+1ll*(i&1?-1:1)*fac[n-i]*(1ll*dp[1][i][0]+dp[1][i][1]+dp[1][i][2])%mod+mod)%mod;\n\tprintf(\"%d\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<limits.h>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stdio.h>\n#include<sstream>\n#include<list>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<initializer_list>\n#include<map>\n#include<set>\n#include<utility>\n#include<tuple>\nusing namespace std;\n#define ull unsigned long long\n#define llong long long\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define all(t) t.begin(), t.end()\n\nstring akiba(string s) {\n\tvector<string> can = {\n\t\t\"KIHBR\",\n\t\t\"KIHBRA\",\n\t\t\"KIHBAR\",\n\t\t\"KIHBARA\",\n\t\t\"KIHABR\",\n\t\t\"KIHABRA\",\n\t\t\"KIHABARA\",\n\t\t\"AKIHBR\",\n\t\t\"AKIHBRA\",\n\t\t\"AKIHBAR\",\n\t\t\"AKIHABR\",\n\t\t\"AKIHABRA\",\n\t\t\"AKIHABAR\",\n\t\t\"AKIHABARA\" };\n\tauto it = find(all(can), s);\n\tif (it != can.end())return \"YES\";\n\telse return \"NO\";\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tcout << akiba(s) << endl;\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define r(i,n) for(int i=0;i<n;i++)\nconst ll MN=2005;ll md=1e9+7;ll n,sz[MN],p[MN];vector<ll>g[MN];ll d[MN][MN][2];ll f[MN];ll a[MN][3],x[MN][3];\nint main(){f[0]=1;\nfor(ll i=1;i<MN;i++)f[i]=f[i-1]*i%md;\ncin>>n;for(ll i=2;i<=n;i++){cin>>p[i];g[p[i]].push_back(i);}\nfor(ll i=n;i;i--){memset(a,0,sizeof(a));a[0][0]=1;for(auto &j:g[i]){memset(x,0,sizeof(x)); \nr(k,sz[j]+1)r(l,sz[i]+1)r(m,3){x[k+l][m]+=d[j][k][0]*a[l][m]%md;if(m<2) x[k+l+1][m+1]+=d[j][k][1]*a[l][m]%md;}\nsz[i]+=sz[j];\nr(j,sz[i]+1)r(k,3){a[j][k]=x[j][k]%md;}}\nr(j,sz[i]+1){\nd[i][j][0]=a[j][0]+a[j][1]*2+a[j][2]*2;\nd[i][j][1]=a[j][0]+a[j][1];d[i][j][0]%=md;d[i][j][1]%=md;}\nsz[i]++;}\nll rt=0;r(i,n+1){ll cr=d[1][i][0]*f[n-i]%md;if(i & 1) cr=md-cr;rt+=cr;}\ncout<<rt%md<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nvector<int> G[MAX_N];\nmod dp[MAX_N][MAX_N][3][2];\nint sub[MAX_N];\n\nvoid dfs(int u, int p){\n    dp[u][0][0][0] = 1;\n    sub[u] = 1;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            rep(i,sub[u]){\n                rep(j,3){\n                    dp[u][i][j][1] = 0;\n                }\n            }\n            rep(i, sub[u]){\n                rep(j, sub[v]){\n                    rep(k, 3){\n                        dp[u][i+j][k][1] += dp[u][i][k][0] * (dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0]) * comb(sub[u]+1-i, sub[v] - j);\n                    }\n                    dp[u][i+j+1][1][1] += dp[u][i][0][0] * (dp[v][j][0][0] * 2 + dp[v][j][1][0]) * comb(sub[u]-i, sub[v]-j-1);\n                    dp[u][i+j+1][2][1] += dp[u][i][1][0] * (dp[v][j][0][0] + dp[v][j][1][0] * inv[2]) * comb(sub[u]-i, sub[v]-j-1);\n                }\n            }\n            sub[u] += sub[v];\n            rep(i,sub[u]){\n                rep(j,3){\n                    dp[u][i][j][0] = dp[u][i][j][1];\n                }\n            }\n        }\n    }\n    // rep(i,sub[u]){\n    //     rep(j,3){\n    //         cout << u << \" \" << i << \" \" << j << \" \" << dp[u][i][j][0] << \"\\n\";\n    //     }\n    // }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int b;\n        cin >> b;\n        --b;\n        G[b].pb(i+1), G[i+1].pb(b);\n    }\n    make();\n    dfs(0, -1);\n    mod ans = 0;\n    rep(i,n+1){\n        if(i % 2){\n            ans -= (dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) * comb(n, i);\n        }else{\n            ans += (dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) * comb(n, i);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int MN = 2005;\nint mod = 1e9 + 7;\nint n,sz[MN],p[MN];\nvector<int>gph[MN];\nint dp[MN][MN][2];\nint f[MN];\nint a[MN][3], nxt[MN][3];\nint main(){\nf[0]=1;\nfor(int i=1;i<MN;i++)f[i]=f[i-1]*i%mod;\ncin >> n;\nfor(int i=2;i<=n;i++){cin>>p[i];gph[p[i]].push_back(i);} \nfor(int i=n;i;i--){\nmemset(a,0,sizeof(a));\na[0][0]=1;\nfor(auto &j:gph[i]){\nmemset(nxt,0,sizeof(nxt)); \nrep(k,sz[j]+1)rep(l,sz[i]+1)rep(m,3){\nnxt[k+l][m]+=dp[j][k][0]*a[l][m]%mod;\nif(m<2) nxt[k+l+1][m+1]+=dp[j][k][1]*a[l][m] % mod;\n}\nsz[i]+=sz[j];  \nrep(j,sz[i]+1)rep(k,3){a[j][k]=nxt[j][k]%mod;}  \n}\nrep(j,sz[i]+1){\ndp[i][j][0]=a[j][0]+a[j][1]*2+a[j][2]*2;\ndp[i][j][1]=a[j][0]+a[j][1];dp[i][j][0]%=mod;dp[i][j][1]%=mod;}\nsz[i]++;}\nint ret=0;  \nfor(int i=0; i<=n; i++){\nint cur = dp[1][i][0]*f[n-i]%mod;\nif(i & 1) cur=mod-cur;\nret+=cur;}\ncout<<ret%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\n\nvector< int > g[100000];\nvector< vector< int64 > > dp[100000];\n\nvoid rec(int idx) {\n  vector< vector< int64 > > sub(3, vector< int64 >(1));\n  sub[0][0] = 1;\n  for(auto &to : g[idx]) {\n    rec(to);\n    auto &ch = dp[to];\n    vector< int64 > sub1(ch[0].size() + 1);\n    for(int i = 0; i < ch[0].size(); i++) {\n      (sub1[i + 1] += ch[0][i] * 2) %= mod;\n      (sub1[i + 1] += ch[1][i]) %= mod;\n    }\n    vector< vector< int64 > > beet(3, vector< int64 >(sub[0].size() + ch[0].size()));\n    for(int k = 0; k < 3; k++) {\n      for(int i = 0; i < sub[k].size(); i++) {\n        for(int j = 0; j <= ch[0].size(); j++) {\n          if(j < ch[0].size()) {\n            for(int l = 0; l < 3; l++) {\n              (beet[k][i + j] += sub[k][i] * ch[l][j] % mod) %= mod;\n            }\n          }\n          if(k == 0) (beet[1][i + j] += sub[k][i] * sub1[j]) %= mod;\n          if(k == 1) (beet[2][i + j] += sub[k][i] * sub1[j] % mod * inv2) %= mod;\n        }\n      }\n    }\n    for(int k = 0; k < 3; k++) ch[k].clear();\n    sub.swap(beet);\n  }\n  dp[idx].swap(sub);\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int p;\n    cin >> p;\n    g[--p].emplace_back(i);\n  }\n\n  int64 fact[2002];\n  fact[0] = 1;\n  for(int i = 1; i < 2002; i++) {\n    (fact[i] = fact[i - 1] * i) %= mod;\n  }\n\n  rec(0);\n\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    int64 add = 0;\n    for(int j = 0; j < 3; j++) (add += dp[0][j][i]) %= mod;\n    (add *= fact[N - i]) %= mod;\n    if(i & 1) (ret += mod - add) %= mod;\n    else (ret += add) %= mod;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[2*MAX_N],fac[2*MAX_N],finv[2*MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<2*MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nvector<int> G[MAX_N];\nmod dp[MAX_N][MAX_N][3][2];\nint sub[MAX_N];\n\nvoid dfs(int u, int p){\n    dp[u][0][0][0] = 1;\n    sub[u] = 1;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            rep(i,sub[u]){\n                rep(j,3){\n                    dp[u][i][j][1] = 0;\n                }\n            }\n            rep(i, sub[u]){\n                rep(j, sub[v]){\n                    rep(k, 3){\n                        dp[u][i+j][k][1] += dp[u][i][k][0] * (dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0]);\n                    }\n                    dp[u][i+j+1][1][1] += dp[u][i][0][0] * (dp[v][j][0][0] * 2 + dp[v][j][1][0]);\n                    dp[u][i+j+1][2][1] += dp[u][i][1][0] * (dp[v][j][0][0] + dp[v][j][1][0] * inv[2]);\n                }\n            }\n            sub[u] += sub[v];\n            rep(i,sub[u]){\n                rep(j,3){\n                    dp[u][i][j][0] = dp[u][i][j][1];\n                }\n            }\n        }\n    }\n    // rep(i,sub[u]){\n    //     rep(j,3){\n    //         cout << u << \" \" << i << \" \" << j << \" \" << dp[u][i][j][0] << \"\\n\";\n    //     }\n    // }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int b;\n        cin >> b;\n        --b;\n        G[b].pb(i+1), G[i+1].pb(b);\n    }\n    make();\n    dfs(0, -1);\n    mod ans = 0;\n    rep(i,n+1){\n        if(i % 2){\n            ans -= (dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) * fac[n-i];\n        }else{\n            ans += (dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) * fac[n-i];\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nconst int half = 5e8 + 4;\n\nint n;\nint sz[N]; // number of edges\nint prd[N];\nint f[N][N][3]; // (i, j, k) subtree i, number of edges: j, number of edges connect to i: k\nint g[N][N][3]; // knapsack\nvector<int> G[N];\n\n// a fixed set of edges has number of edges: i and number of components: j\n// number of ways *= (2 ^ j) * (n - i)! * ((-1) ^ i)\n\nvoid add(int &x, int y) {\n\tx = (x + y) >= mod ? (x + y - mod) : (x + y);\n}\n\nvoid dfs(int u) {\n\tfor (auto v : G[u]) dfs(v);\n\tint id = 0;\n\tg[0][0][0] = 1;\n\tfor (auto v : G[u]) {\n\t\t++id;\n\t\t// reset\n\t\tfor (int i = 0; i <= sz[u] + sz[v] + 1; ++i) {\n\t\t\tfor (int j = 0; j <= 2; ++j) g[id][i][j] = 0;\n\t\t}\n\t\tfor (int i = 0; i <= sz[u]; ++i) {\n\t\t\tfor (int j = 0; j <= sz[v]; ++j) {\n\t\t\t\tfor (int k = 0; k <= 2; ++k) {\n\t\t\t\t\t// do not use u-v edge\n\t\t\t\t\tfor (int l = 0; l <= 2; ++l) {\n\t\t\t\t\t\tadd(g[id][i + j][k], 1LL * g[id - 1][i][k] * f[v][j][l] % mod); \n\t\t\t\t\t}\n\t\t\t\t\t// use u-v edge\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\tadd(g[id][i + j + 1][k + 1], 2LL * g[id - 1][i][k] * f[v][j][0] % mod);\n\t\t\t\t\t\tadd(g[id][i + j + 1][k + 1], 1LL * g[id - 1][i][k] * f[v][j][1] % mod);\n\t\t\t\t\t}\n\t\t\t\t\tif (k == 1) {\n\t\t\t\t\t\tadd(g[id][i + j + 1][k + 1], 1LL * g[id - 1][i][k] * f[v][j][0] % mod);\n\t\t\t\t\t\tadd(g[id][i + j + 1][k + 1], 1LL * g[id - 1][i][k] * f[v][j][1] % mod * half % mod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsz[u] += sz[v] + 1;\n\t}\n\t// cout << \"At \" << u << '\\n';\n\tfor (int i = 0; i <= sz[u]; ++i) {\n\t\tfor (int j = 0; j <= 2; ++j) {\n\t\t\tf[u][i][j] = g[id][i][j];\n\t\t\t// cout << f[u][i][j] << ' ' << i << ' ' << j << '\\n';\n \t\t}\n \t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint p; cin >> p, G[p].push_back(i);\n\t}\n\tdfs(1);\n\tprd[0] = 1; \n\tfor (int i = 1; i <= n; ++i) prd[i] = 1LL * prd[i - 1] * i % mod;\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint tmp = 0;\n\t\tfor (int j = 0; j <= 2; ++j) add(tmp, f[1][i][j]);\n\t\t// inclusion-exclusion\n\t\tif (i & 1) tmp = mod - tmp;\n\t\tadd(res, 1LL * tmp * prd[n - i] % mod);\n\t}\n\tcout << res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int N,K;\n    cin>>N>>K;\n    map<int,int> A;\n \n    for(int i = 0;i < N;i++) {\n        int a;\n        cin>>a;\n        A[a]++;\n    }\n \n    vector<int> V;\n    for(map<int,int>::iterator it = A.begin();it != A.end();it++) {\n        V.push_back(it ->second);\n    }\n \n    sort(V.begin(),V.end(),greater<int>());\n    long long int sum = 0;\n    for(int i = K;i < V.size();i++) {\n        sum += V[i+1];\n    }\n \n    cout<<sum<<endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\n// 根がi, 連成j個, 根があと何個つながれるか(0/1/2), ペアの偶奇\nint dp[MAX_N][2][MAX_N][3][2];\nint sb[MAX_N];\n\nvector<int> G[MAX_N];\n\nint add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\nint sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nint mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nint comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nint dfs(int u, int p){\n    sb[u]++;\n    dp[u][0][1][2][0] = 1;\n    int mx = 1;\n    each(v, G[u]){\n        if(v != p){\n            sb[u] += dfs(v, u);\n            srep(i,1,mx+1){\n                // k = 0 のとき\n                // くっつかない\n                for(int j = sb[v]; j >= 1; j--){\n                    rep(l,2){\n                        rep(m,2){\n                            dp[u][1][i+j][0][l^m] = add(dp[u][1][i+j][0][l^m], mul(dp[u][0][i][0][l], mul(add(dp[v][0][j][0][m], dp[v][0][j][1][m]) + dp[v][0][j][2][m], comb(i+j, i))));\n                        }\n                    }\n                }\n                // k = 1\n                // くっつく\n                for(int j = sb[v]; j >= 1; j--){\n                    rep(l,2){\n                        rep(m,2){\n                            dp[u][1][i+j-1][0][l^m^1] = add(dp[u][1][i+j-1][0][l^m^1], mul(dp[u][0][i][1][l], mul(dp[v][0][j][2][m], comb(i+j-1, i))));\n                            dp[u][1][i+j-1][0][l^m^1] = add(dp[u][1][i+j-1][0][l^m^1], mul(dp[u][0][i][1][l], mul(mul(dp[v][0][j][1][m], inv[2]), comb(i+j-1, i))));\n                        }\n                    }\n                }\n                // くっつかない\n                for(int j = sb[v]; j >= 1; j--){\n                    rep(l,2){\n                        rep(m,2){\n                            dp[u][1][i+j][1][l^m] = add(dp[u][1][i+j][1][l^m], mul(dp[u][0][i][1][l], mul(dp[v][0][j][0][m], comb(i+j, i))));\n                            dp[u][1][i+j][1][l^m] = add(dp[u][1][i+j][1][l^m], mul(dp[u][0][i][1][l], mul(mul(mul(dp[v][0][j][1][m], inv[2]), i), comb(i+j, i+1))));\n                            dp[u][1][i+j][1][l^m] = add(dp[u][1][i+j][1][l^m], mul(dp[u][0][i][1][l], mul(mul(dp[v][0][j][1][m], inv[2]), comb(i+j, i))));\n                            dp[u][1][i+j][1][l^m] = add(dp[u][1][i+j][1][l^m], mul(dp[u][0][i][1][l], mul(mul(dp[v][0][j][2][m], i), comb(i+j, i+1))));\n                        }\n                    }\n                }\n                // k = 2\n                // くっつく\n                for(int j = sb[v]; j >= 1; j--){\n                    rep(l,2){\n                        rep(m,2){\n                            dp[u][1][i+j-1][1][l^m^1] = add(dp[u][1][i+j-1][1][l^m^1], mul(dp[u][0][i][2][l], mul(2 * dp[v][0][j][2][m], comb(i+j-1, i))));\n                            dp[u][1][i+j-1][1][l^m^1] = add(dp[u][1][i+j-1][1][l^m^1], mul(dp[u][0][i][2][l], mul(dp[v][0][j][1][m], comb(i+j-1, i))));\n                        }\n                    }\n                }\n                // くっつかない\n                for(int j = sb[v]; j >= 1; j--){\n                    rep(l,2){\n                        rep(m,2){\n                            dp[u][1][i+j][2][l^m] = add(dp[u][1][i+j][2][l^m], mul(dp[u][0][i][2][l], mul(dp[v][0][j][0][m], comb(i+j, i))));\n                            dp[u][1][i+j][2][l^m] = add(dp[u][1][i+j][2][l^m], mul(dp[u][0][i][2][l], mul(mul(dp[v][0][j][1][m], i), comb(i+j, i+1))));\n                            dp[u][1][i+j][2][l^m] = add(dp[u][1][i+j][2][l^m], mul(dp[u][0][i][2][l], mul(mul(dp[v][0][j][2][m], i-1), comb(i+j, i+1))));\n                        }\n                    }\n                }\n            }\n            swap(dp[u][0], dp[u][1]);\n            rep(j,mx+1){\n                rep(k,2){\n                    rep(l,2){\n                        dp[u][1][j][k][l] = 0;\n                    }\n                }\n            }\n            mx += sb[v];\n        }\n    }\n    // rep(j,mx){\n    //     rep(k,3){\n    //         rep(l,2){\n    //             cout << u << \" \" << j << \" \" << k << \" \" << l << \" \" << dp[u][0][j][k][l] << \"\\n\";\n    //         }\n    //     }\n    // }\n    return sb[u];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a;\n        cin >> a;\n        G[a-1].pb(i+1);\n    }\n    make();\n    dfs(0, -1);\n    int ans = 0;\n    rep(i,n){\n        rep(j,3){\n            ans = add(ans, dp[0][0][i+1][j][0]);\n            ans = sub(ans, dp[0][0][i+1][j][1]);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nvector <int> G[N];\nint n, dp[N][N][3], g[N][3], c[N], ans;\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod; if (a < 0) a += mod;\n}\n\nvoid dfs(int u){\n    c[u] = 0;\n    dp[u][0][0] = 1;\n    for (auto v : G[u]){\n        dfs(v);\n        for (int i = 0; i <= c[u]+c[v]+1; i++) g[i][0] = g[i][1] = g[i][2] = 0;\n        for (int i = 0; i <= c[u]; i++) for (int j = 0; j <= c[v]; j++){\n            add(g[i+j][0], 1LL * dp[u][i][0] * dp[v][j][0] % mod);\n            add(g[i+j][1], 1LL * dp[u][i][1] * dp[v][j][0] % mod);\n            add(g[i+j+1][1], 1LL * dp[u][i][0] * dp[v][j][1] % mod);\n            add(g[i+j][2], 1LL * dp[u][i][2] * dp[v][j][0] % mod);\n            add(g[i+j+1][2], 1LL * dp[u][i][1] * dp[v][j][1] % mod);\n        }\n        for (int i = 0; i <= c[u]+c[v]+1; i++) dp[u][i][0] = g[i][0], dp[u][i][1] = g[i][1], dp[u][i][2] = g[i][2];\n        c[u] += c[v] + 1;\n    }\n    for (int i = 0; i <= c[u]; i++){\n        int a = dp[u][i][0], b = dp[u][i][1], c = dp[u][i][2];\n        dp[u][i][0] = a; add(dp[u][i][0], 2LL * b % mod); add(dp[u][i][0], 2LL * c % mod);\n        dp[u][i][1] = a; add(dp[u][i][1], b);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int i = 2; i <= n; i++){\n        int x; cin >> x;\n        G[x].push_back(i);\n    }\n    dfs(1); int f = 1;\n    for (int i = n-1; i >= 0; i--){\n        f = 1LL * f * (n - i) % mod;\n        if (i&1) add(ans, -1LL * f * dp[1][i][0] % mod);\n        else add(ans, 1LL * f * dp[1][i][0] % mod);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst long long mod = 1000000007;\nconst long long inv2 = (mod + 1) / 2;\nvector<int> G[2020];\n\nvector<long long> mul(vector<long long> &a, vector<long long> &b)\n{\n\tvector<long long> r(a.size()+b.size()-1);\n\tfor (int i=0;i<a.size();i++) for (int j=0;j<b.size();j++){\n\t\tr[i+j] = (r[i+j] + a[i] * b[j]) % mod;\n\t}\n\treturn move(r);\n}\n\nvector<long long> add(vector<long long> &a, vector<long long> &b, int sig = 1)\n{\n\tvector<long long> r(max(a.size(),b.size()));\n\tfor (int i=0;i<a.size();i++) r[i] = a[i];\n\tfor (int i=0;i<b.size();i++) r[i] = (r[i] + b[i] * sig % mod + mod) % mod;\n\treturn move(r);\n}\n\nvector<vector<long long> > go(int x)\n{\n\tvector<vector<long long> > r(3,vector<long long>(2,0));\n\tr[0][1] = 1;\n\n\tfor (auto &y : G[x]){\n\t\tauto q = go(y);\n\t\tauto s = q[0];\n\t\ts = add(s,q[1]);\n\t\ts = add(s,q[2]);\n\n\t\tvector<vector<long long> > nr(3);\n\t\tfor (int k=0;k<3;k++) nr[k] = mul(r[k],s);\n\t\tlong long coeff[2][2] = {2,1,1,inv2};\n\t\tfor (int i=0;i<2;i++) for (int j=0;j<2;j++){\n\t\t\tauto t = mul(r[i],q[j]);\n\t\t\tt.erase(t.begin());\n\t\t\tnr[i+1] = add(nr[i+1],t,-coeff[i][j]);\n\t\t}\n\t\tr = move(nr);\n\t}\n\n\treturn move(r);\n}\n\nint main()\n{\n\tint N; scanf (\"%d\",&N);\n\tfor (int i=2;i<=N;i++){\n\t\tint p; scanf (\"%d\",&p);\n\t\tG[p].push_back(i);\n\t}\n\n\tauto r = go(1);\n\n\tlong long ans = 0, f = 1;\n\tfor (int i=1;i<=N;i++){\n\t\tf = f * i % mod;\n\t\tans = (ans + (r[0][i] + r[1][i] + r[2][i]) * f) % mod;\n\t}\n\tprintf (\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long N, B[1 << 18];\nlong long sz[2009];\nlong long dp[2009][4009][2];\nlong long dr[2009][4009][3];\nlong long fact[2009];\nlong long power[2009];\nvector<int> X[1 << 18];\n\nlong long Div(long long a) {\n\tif (a % 2 == 1) a += mod;\n\treturn a / 2;\n}\n\nvoid dfs(int pos) {\n\tsz[pos] = 1;\n\tfor (int i : X[pos]) {\n\t\tdfs(i);\n\t\tsz[pos] += sz[i];\n\t}\n\n\t// DP の計算\n\tfor (int i = 0; i <= X[pos].size(); i++) {\n\t\tfor (int j = 0; j <= sz[pos]; j++) {\n\t\t\tdr[i][j][0] = 0; dr[i][j][1] = 0; dr[i][j][2] = 0;\n\t\t}\n\t}\n\n\tdr[0][0][0] = 1; int S = 0;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tint to = X[pos][i];\n\t\tfor (int j = 0; j <= S; j++) {\n\t\t\tfor (int k = 0; k <= sz[to]; k++) {\n\t\t\t\tdr[i + 1][j + k][0] += dr[i][j][0] * dp[to][k][0];\n\t\t\t\tdr[i + 1][j + k][1] += dr[i][j][1] * dp[to][k][0];\n\t\t\t\tdr[i + 1][j + k][2] += dr[i][j][2] * dp[to][k][0];\n\t\t\t\tdr[i + 1][j + k][1] += dr[i][j][0] * dp[to][k][1];\n\t\t\t\tdr[i + 1][j + k][2] += dr[i][j][1] * dp[to][k][1];\n\t\t\t\tdr[i + 1][j + k][0] %= mod;\n\t\t\t\tdr[i + 1][j + k][1] %= mod;\n\t\t\t\tdr[i + 1][j + k][2] %= mod;\n\t\t\t}\n\t\t}\n\t\tS += sz[to];\n\t}\n\n\tfor (int i = 0; i <= S; i++) {\n\t\tdp[pos][i + X[pos].size() - 0][0] += Div(dr[X[pos].size()][i][0]);\n\t\tdp[pos][i + X[pos].size() - 0][1] += dr[X[pos].size()][i][0];\n\t\tif (X[pos].size() >= 1) {\n\t\t\tdp[pos][i + X[pos].size() - 1][0] -= dr[X[pos].size()][i][1];\n\t\t\tdp[pos][i + X[pos].size() - 1][1] -= dr[X[pos].size()][i][1];\n\t\t}\n\t\tif (X[pos].size() >= 2) {\n\t\t\tdp[pos][i + X[pos].size() - 2][0] += dr[X[pos].size()][i][2];\n\t\t}\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[pos][i][0] = (dp[pos][i][0] + mod * mod) % mod;\n\t\tdp[pos][i][1] = (dp[pos][i][1] + mod * mod) % mod;\n\t\tdp[pos][i][2] = (dp[pos][i][2] + mod * mod) % mod;\n\t}\n}\n\nvoid init() {\n\tpower[0] = 1; fact[0] = 1;\n\tfor (int i = 1; i <= 2000; i++) power[i] = (2LL * power[i - 1]) % mod;\n\tfor (int i = 1; i <= 2000; i++) fact[i] = (1LL * i * fact[i - 1]) % mod;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 2; i <= N; i++) cin >> B[i];\n\tfor (int i = 2; i <= N; i++) X[B[i]].push_back(i);\n\n\tinit();\n\tdfs(1);\n\t\n\tlong long Answer = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tlong long v1 = dp[1][i - 1][0];\n\t\tlong long v2 = fact[i];\n\t\tlong long v3 = power[i];\n\t\tAnswer += (v1 * v2 % mod) * v3 % mod;\n\t\tAnswer %= mod;\n\t}\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\nconst int N=2010;\nconst int mod=1000000007;\nconst int inv2=(mod+1)/2;\n\nvi e[2010];\n\nint dp[2010][2010][3],size[2010];\nint fac[2010],pow2[2010];\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nvoid dfs(int k)\n{\n\tdp[k][1][0]=1;size[k]=1;\n\tfor (vi::iterator p=e[k].begin();p!=e[k].end();p++)\n\t{\n\t\tdfs(*p);\n\t\tfor (int j=size[k];j;j--)\n\t\t\tfor (int x=2;x>=0;x--)\n\t\t\t{\n\t\t\t\tfor (int l=1;l<=size[*p];l++)\n\t\t\t\t{\n\t\t\t\t\tif (x<2)\n\t\t\t\t\t\tfor (int y=0;y<2;y++)\n\t\t\t\t\t\t\tdp[k][j+l-1][x+1]=(ll(dp[k][j][x])*dp[*p][l][y]+dp[k][j+l-1][x+1])%mod;\n\t\t\t\t\tfor (int y=0;y<=2;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[k][j+l][x]=(ll(dp[k][j][x])*dp[*p][l][y]%mod*(y==0 ? inv2 : 1)+dp[k][j+l][x])%mod;\n\t\t\t\t\t\t\t//if (k==2) printf(\"%d %d %d %d %d\\n\",dp[2][2][0],j,x,l,y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[k][j][x]=0;\n\t\t\t}\n\t\tsize[k]+=size[*p];\n\t}\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tint x;scanf(\"%d\",&x);e[x].pb(i);\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdfs(1);\n\tfac[0]=1;for (int i=1;i<=n;i++) fac[i]=ll(fac[i-1])*i%mod;\n\tpow2[0]=1;for (int i=1;i<=n;i++) pow2[i]=pow2[i-1]*2%mod;\n\tint ans=0;//printf(\"%d\\n\",dp[2][2][0]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=2;j++)\n\t\t{\n\t\t\tint t=ll(fac[i])*pow2[i]%mod*dp[1][i][j]%mod*(j==0 ? inv2 : 1)%mod;\n\t\t\t//printf(\"%d %d %d %d\\n\",i,j,t,dp[1][i][j]);\n\t\t\tif ((n-i)&1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint a[200010], b[200010];\nint n, bs;\nint mn[800010], tag[800010];\nvoid build(int p, int l, int r) {\n\tif(l == r) {\n\t\tmn[p] = b[l]; tag[p] = 0;\n\t\treturn ;\n\t}\n\tint mid = (l + r)>>1;\n\tbuild(p<<1, l, mid); build(p<<1|1, mid + 1, r);\n\tmn[p] = min(mn[p<<1], mn[p<<1|1]);\n}\ninline void pd(int p) {\n\ttag[p<<1]+= tag[p]; mn[p<<1]+= tag[p];\n\ttag[p<<1|1]+= tag[p]; mn[p<<1|1]+= tag[p];\n\ttag[p] = 0;\n}\nvoid add(int p, int l, int r, int x, int y) {\n\tif(x > y) return ;\n\tif(x <= l && r <= y) {\n\t\t++tag[p];\n\t\t++mn[p];\n\t\treturn ;\n\t}\n\tint mid = (l + r)>>1;\n\tpd(p); \n\tif(x <= mid) add(p<<1, l, mid, x, y);\n\tif(mid + 1 <= y) add(p<<1|1, mid + 1, r, x, y);\n\tmn[p] = min(mn[p<<1], mn[p<<1|1]);\n}\nint query(int p, int l, int r, int x, int y) {\n\tif(x <= l && r <= y) return mn[p];\n\tint mid = (l + r)>>1;\n\tint s1 = 0x7fffffff, s2 = 0x7fffffff;\n\tpd(p);\n\tif(x <= mid) s1 = query(p<<1, l, mid, x, y);\n\tif(mid + 1 <= y) s2 = query(p<<1|1, mid + 1, r, x, y);\n\treturn min(s1, s2);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tmemcpy(b, a, sizeof(b)); sort(b+1, b+n+1); bs = unique(b+1, b+n+1) - b - 1;\n\tbuild(1, 1, bs);\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint p = lower_bound(b+1, b+bs+1, a[i]) - b;\n\t\tans+= query(1, 1, bs, p, bs) - a[i];\n\t\tadd(1, 1, bs, 1, p - 1);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = (int) 1e9 + 7;\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\nvoid ssub(int &a, int b)\n{\n    a -= b;\n    if (a < 0) a += MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint sub(int a, int b)\n{\n    ssub(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\nint fpow(int x, int n)\n{\n    if (n == 0) return 1;\n    int a = fpow(x, n >> 1);\n    a = mul(a, a);\n    if (n & 1) a = mul(a, x);\n    return a;\n}\nint rev(int x)\n{\n    return fpow(x, MOD - 2);\n}\n\nint rev2;\nint divi2(int a)\n{\n    return mul(a, rev2);\n}\n\nconst int N = 2005;\nvector <int> ch[N];\nint _C[N][N];\nint fact[N];\n\nint C(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    return _C[n][k];\n}\n\nstruct Ans\n{\n    vector <int> dp, dpEnd, dpOnly;\n\n    Ans() : dp({0, 0}), dpEnd({0, 0}), dpOnly({0, 1}) {}\n\n    Ans operator + (const Ans &A) const // root from this\n    {\n        Ans ans;\n        ans.dpOnly[1] = 0;\n        ans.dp.resize((int) dp.size() + (int) A.dp.size() - 1, 0);\n        ans.dpEnd.resize((int) dpEnd.size() + (int) A.dpEnd.size() - 1, 0);\n        ans.dpOnly.resize((int) dpOnly.size() + (int) A.dpOnly.size() - 1, 0);\n\n        for (int i = 1; i < (int) dp.size(); i++)\n            for (int j = 1; j < (int) A.dp.size(); j++)\n            {\n                int ox = dp[i], oEnd = dpEnd[i], oOnly = dpOnly[i], ax = A.dp[j], aEnd = A.dpEnd[j], aOnly = A.dpOnly[j];\n                int aAll = add(ax, add(aEnd, aOnly) );\n                                \n                sadd(ans.dp[i + j], mul(ox, aAll) );\n                sadd(ans.dpEnd[i + j], mul(oEnd, aAll) );\n                sadd(ans.dpOnly[i + j], mul(oOnly, aAll) );\n\n                sadd(ans.dp[i + j - 1], mul(oEnd, divi2(aEnd) ) );\n                sadd(ans.dpEnd[i + j - 1], mul(oOnly, mul(2, aOnly) ) );\n                sadd(ans.dpEnd[i + j - 1], mul(oOnly, aEnd) );\n                sadd(ans.dp[i + j - 1], mul(oEnd, aOnly) );\n            }\n        return ans;\n    }\n\n    int pvi()\n    {\n        int ans = 0;\n        for (int i = 1; i < (int) dp.size(); i++)\n        {\n            int cur = add(dp[i], add(dpEnd[i], dpOnly[i]));\n            cur = mul(cur, fact[i] );\n            if ( ( (int) dp.size() - i) % 2) \n                sadd(ans, cur);\n            else ssub(ans, cur);\n        }\n        return ans;\n    }\n    void eprint(int id)\n    {\n        eprintf(\"---\\nv = %d\\n\", id);\n        for (int i = 1; i < (int) dp.size(); i++)\n        {\n            eprintf(\"%d : dp %d, dpEnd %d, dpOnly %d\\n\", i, dp[i], dpEnd[i], dpOnly[i] );\n        }\n    }\n};\n\n\nAns dfs(int v)\n{\n    Ans cur = Ans();\n    for (int to : ch[v] )\n    {\n        eprintf(\"%d -> %d\\n\", v, to);\n//        cur.eprint(10 + v);\n        cur = cur + dfs(to);\n    }\n//    cur.eprint(v);\n    return cur;\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n    for (int i = 0; i < N; i++)\n    {\n        _C[i][i] = _C[i][0] = 1;\n        for (int j = 1; j < i; j++)\n            _C[i][j] = add(_C[i - 1][j], _C[i - 1][j - 1] );\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N; i++)\n        fact[i] = mul(fact[i - 1], i);\n\n    rev2 = rev(2);\n\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        x--;\n        ch[x].push_back(i);\n    }\n\n    Ans ans = dfs(0);\n    int answer = ans.pvi();\n    printf(\"%d\\n\", answer);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[2000];\nint B[2000];\nint fact[2001];\nvector<int> dp[2000][2];\nvector<int> dp2[2][3];\n\nvector<int> merge(vector<int> &a, vector<int> &b) {\n  vector<int> o(a.size()+b.size()-1, 0);\n  rep(i, a.size()) {\n    rep(j, b.size()) {\n      o[i+j] = (o[i+j] + 1LL*a[i]*b[j])%MOD;\n    }\n  }\n  return o;\n}\nvoid add(vector<int> &to, vector<int> src) {\n  if (to.size() < src.size()) to.resize(src.size(), 0);\n  rep(i, src.size()) to[i] = (to[i]+src[i]) % MOD;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=2000; i++) fact[i] = (1LL*i*fact[i-1])%MOD;\n\n  cin >> N;\n  for (int i=1; i<N; i++) {\n    int p;\n    cin >> p;\n    p--;\n    G[p].pb(i);\n  }\n  for (int x=N-1; x>=0; x--) {\n    dp2[0][0] = {1};\n    dp2[0][1] = {0};\n    dp2[0][2] = {0};\n    for (int t : G[x]) {\n      rep(k, 3) dp2[1][k].clear();\n      rep(k, 3) add(dp2[1][k], merge(dp2[0][k], dp[t][0]));\n      rep(k, 2) add(dp2[1][k+1], merge(dp2[0][k], dp[t][1]));\n      swap(dp2[0], dp2[1]);\n    }\n    add(dp[x][1], dp2[0][0]);\n    add(dp[x][1], dp2[0][1]);\n    dp[x][1].insert(dp[x][1].begin(), 0); // s++\n\n    add(dp[x][0], dp2[0][0]);\n    for (int &x : dp2[0][1]) x = (2LL*x) % MOD;\n    for (int &x : dp2[0][2]) x = (2LL*x) % MOD;\n    add(dp[x][0], dp2[0][1]);\n    add(dp[x][0], dp2[0][2]);\n  }\n  int sum = 0;\n  for (int s=0; s<dp[0][0].size(); s++) {\n    int e = dp[0][0][s];\n    if (s%2) e = (MOD-e) % MOD;\n    sum = (sum + 1LL*e*fact[N-s])%MOD;\n  }\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n\ntypedef ModInt<MOD> Mint;\n\nint N;\nVI G[2011];\nint sz[2011];\nMint dp[2011][2011][3];\nMint buf[2][2011][3];\nMint (*cur)[3] = buf[0];\nMint (*nxt)[3] = buf[1];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint p;\n\tscanf(\"%d\", &p);\n\tp--;\n\tG[p].push_back(i+1);\n    }\n    \n    for (int v=N; v--;) {\n\tsz[v] = 1;\n\tmemset(cur, 0, sizeof buf[0]);\n\tcur[1][0] = 1;\n\tEACH (e, G[v]) {\n\t    memset(nxt, 0, sizeof buf[0]);\n\t    for (int a=1; a<=sz[v]; a++) {\n\t\tfor (int b=0; b<3; b++) {\n\t\t    for (int c=1; c<=sz[*e]; c++) {\n\t\t\tfor (int d=0; d<3; d++) {\n\t\t\t    Mint tmp = cur[a][b] * dp[*e][c][d];\n\t\t\t    nxt[a+c][b] += tmp + (d? tmp: 0);\n\t\t\t    if (b < 2 && d < 2) nxt[a+c-1][b+1] += tmp;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    sz[v] += sz[*e];\n\t    swap(cur, nxt);\n\t}\n\n\tREP (a, sz[v] + 1) REP (b, 3) dp[v][a][b] = cur[a][b];\n    }\n\n    Mint ans = 0;\n    Mint f = 1;\n    REP (a, N+1) {\n\tREP (b, 3) {\n\t    Mint tmp = dp[0][a][b];\n\t    if (b) tmp += tmp;\n\t    tmp *= f;\n\t    if ((N-a)%2) ans -= tmp;\n\t    else ans += tmp;\n\t}\n\tf *= a+1;\n    }\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\n\nvector< int > g[100000];\nvector< vector< int64 > > dp[100000];\n\nvoid rec(int idx) {\n  vector< vector< int64 > > sub(3, vector< int64 >(1));\n  sub[0][0] = 1;\n  for(auto &to : g[idx]) {\n    rec(to);\n    auto &ch = dp[to];\n    vector< int64 > sub1(ch[0].size() + 1);\n    for(int i = 0; i < ch[0].size(); i++) {\n      (sub1[i + 1] += ch[0][i] * 2) %= mod;\n      (sub1[i + 1] += ch[1][i]) %= mod;\n    }\n\n    vector< vector< int64 > > beet(3, vector< int64 >(sub[0].size() + ch[0].size()));\n    for(int k = 0; k < 3; k++) {\n      for(int i = 0; i < sub[k].size(); i++) {\n        for(int j = 0; j <= ch[0].size(); j++) {\n          if(j < ch[0].size()) {\n            for(int l = 0; l < 3; l++) {\n              (beet[k][i + j] += sub[k][i] * ch[l][j] % mod) %= mod;\n            }\n          }\n          if(k == 0) (beet[1][i + j] += sub[k][i] * sub1[j]) %= mod;\n          if(k == 1) (beet[2][i + j] += sub[k][i] * sub1[j] % mod * inv2) %= mod;\n        }\n      }\n    }\n\n    sub.swap(beet);\n  }\n  dp[idx].swap(sub);\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int p;\n    cin >> p;\n    g[--p].emplace_back(i);\n  }\n\n  int64 fact[2002];\n  fact[0] = 1;\n  for(int i = 1; i < 2002; i++) {\n    (fact[i] = fact[i - 1] * i) %= mod;\n  }\n\n  rec(0);\n\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    int64 add = 0;\n    for(int j = 0; j < 3; j++) (add += dp[0][j][i]) %= mod;\n    (add *= fact[N - i]) %= mod;\n    if(i & 1) (ret += mod - add) %= mod;\n    else (ret += add) %= mod;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\n\nint n, siz[MAXN], g[MAXN][3], f[MAXN][MAXN][3];\nvector <int> adj[MAXN];\n\ninline void DFS(int x)\n{\n\tsiz[x] = 1, f[x][1][0] = 1;\n\tfor (auto y : adj[x])\n\t{\n\t\tDFS(y), mcpy(g, f[x]), mset(f[x], 0);\n\t\tfor (int dx = 0; dx <= 2; dx ++)\n\t\t\tfor (int dy = 0; dy <= 2; dy ++)\n\t\t\t\tfor (int dz = 0; dz <= 1; dz ++)\n\t\t\t\t\tif (!dz || (dx < 2 && dy < 2))\n\t\t\t\t\t\tfor (int i = 1; i <= siz[x]; i ++)\n\t\t\t\t\t\t\tfor (int j = 1; j <= siz[y]; j ++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint cur = 1;\n\t\t\t\t\t\t\t\tif (dz)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcur = mod - 1;\n\t\t\t\t\t\t\t\t\tif (!dx && !dy)\n\t\t\t\t\t\t\t\t\t\tcur = (cur << 1) % mod;\n\t\t\t\t\t\t\t\t\tif (dx && dy)\n\t\t\t\t\t\t\t\t\t\tcur = cur >> 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tf[x][i + j - dz][dx + dz] = (1LL * g[i][dx] * f[y][j][dy] % mod * cur + f[x][i + j - dz][dx + dz]) % mod;\n\t\t\t\t\t\t\t}\n\t\tsiz[x] += siz[y];\n\t}\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read();\n\tfor (int i = 2; i <= n; i ++)\n\t\tadj[Read()].pb(i);\n\tDFS(1);\n\tint ret = 0;\n\tfor (int i = 0, cur = 1; i <= n; i ++, cur = 1LL * cur * i % mod)\n\t\tfor (int j = 0; j <= 2; j ++)\n\t\t\tret = (1LL * f[1][i][j] * cur + ret) % mod;\n\treturn printf(\"%d\\n\", ret), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 16;\ntemplate <typename T, T mod = MOD<T>>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>>;\nusing mll = ModInt<ll, MOD<ll>>;\nusing Poly = std::vector<mll>;\nPoly operator*(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = d1 + d2;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d1; i++) {\n        for (int j = 0; j <= d2; j++) { ans[i + j] += p1[i] * p2[j]; }\n    }\n    return ans;\n}\nPoly operator*(const ll s, const Poly& p2)\n{\n    const int d = p2.size() - 1;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d; i++) { ans[i] = p2[i] * d; }\n    return ans;\n}\nPoly operator+(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = std::max(d1, d2);\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d1; i++) { ans[i] += p1[i]; }\n    for (int i = 0; i <= d2; i++) { ans[i] += p2[i]; }\n    return ans;\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\nint main()\n{\n    int N;\n    std::cin >> N;\n    std::vector<std::vector<int>> g(N);\n    for (int i = 1, p; i < N; i++) { std::cin >> p, g[p - 1].push_back(i); }\n    // vi以下のパス分割全体で、根viの次数がj, 連結成分数k\n    // 2^{連結成分数}/2^{孤立点数} の和\n    std::vector<std::vector<Poly>> dp(N, std::vector<std::vector<mll>>(3));\n    auto dfs = [&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) { self(self, to); }\n        Poly p0{1}, p1{0}, p2{0};\n        for (const int to : g[s]) {\n            const Poly z = dp[to][0] + dp[to][1] + dp[to][2];\n            const Poly o = 2 * dp[to][0] + dp[to][1];\n            auto p0_ = p0, p1_ = p1, p2_ = p2;\n            p0 = p0_ * z;\n            p1 = p1_ * z + p0_ * o;\n            p2 = p2_ * z + p1_ * o;\n        }\n        dp[s][0] = p0 * Poly{0, 1};\n        dp[s][1] = p1;\n        for (int i = 1; i < p2.size(); i++) { p2[i - 1] = p2[i] * (MOD<ll> + 1) / 2; }\n        p2[p2.size() - 1] = 0;\n        dp[s][2] = p2;\n    };\n    dfs(dfs, 0);\n    //    show(dp);\n    mll p = 1, ans = 0;\n    const Poly f = dp[0][0] + dp[0][1] + dp[0][2];\n    for (int i = 0; i <= N; i++) {\n        ans += (i % 2 == 0 ? p * f[i] : (-p) * f[i]);\n        p *= (i + 1);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 2010;\nconst ll MOD = 1000000007;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\ninline ll qpow(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b & 1LL) res = res * a % MOD;\n\t\tb >>= 1, a = a * a % MOD;\n\t}\n\treturn res;\n}\n\nint e, st[MAXN], to[MAXN];\nint nxt[MAXN];\ninline void Add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint n, fa[MAXN], size[MAXN];\nll dp[MAXN][MAXN][3], inv2;\nll tmp[MAXN][3];\nll fac[MAXN], ans;\n\ninline void update(ll &cur, ll val) {\n\tcur = cur+val;\n\tif(cur >= MOD) cur -= MOD;\n}\n\nvoid dfs(int u) {\n\tint i, j, k;\n\tdp[u][1][0] = 1, size[u] = 1;\n\tfor(i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tdfs(v), size[u] += size[v];\n\t}\n\tif(size[u] == 1) return;\n\tfor(i = st[u]; i; i = nxt[i]) {\n\t\tfor(k = size[u]; k >= 1; k--) {\n\t\t\ttmp[k][0] = dp[u][k][0];\n\t\t\ttmp[k][1] = dp[u][k][1];\n\t\t\ttmp[k][2] = dp[u][k][2];\n\t\t\tdp[u][k][0] = dp[u][k][1] = dp[u][k][2] = 0;\n\t\t}\n\t\tint v = to[i];\n\t\tfor(k = size[u]-size[v]+1; k >= 1; k--) {\n\t\t\tfor(j = size[v]; j >= 1; j--) {\n\t\t\t\tif(j+k-1 != size[u]) {\n\t\t\t\t\tupdate(dp[u][j+k][0], dp[v][j][0]*tmp[k][0]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][1], dp[v][j][0]*tmp[k][1]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][2], dp[v][j][0]*tmp[k][2]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][0], dp[v][j][1]*tmp[k][0]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][1], dp[v][j][1]*tmp[k][1]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][2], dp[v][j][1]*tmp[k][2]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][0], dp[v][j][2]*tmp[k][0]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][1], dp[v][j][2]*tmp[k][1]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][2], dp[v][j][2]*tmp[k][2]%MOD);\n\t\t\t\t}\n\t\t\t\tupdate(dp[u][j+k-1][2], dp[v][j][0]*tmp[k][1]%MOD);\n\t\t\t\tupdate(dp[u][j+k-1][2], dp[v][j][1]*tmp[k][1]%MOD*inv2%MOD);\n\t\t\t\tupdate(dp[u][j+k-1][1], dp[v][j][0]*tmp[k][0]%MOD*2%MOD);\n\t\t\t\tupdate(dp[u][j+k-1][1], dp[v][j][1]*tmp[k][0]%MOD);\n\t\t\t}\n\t\t}\n\t\t/*if(u == 1) {\n\t\t\tprintf(\":\");\n\t\t\tfor(k = 1; k <= size[u]; k++)\n\t\t\t\tprintf(\"(%lld,%lld,%lld) \", dp[u][k][0], dp[u][k][1], dp[u][k][2]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\t/*for(k = 1; k <= size[u]; k++)\n\t\tprintf(\"(%lld,%lld,%lld) \", dp[u][k][0], dp[u][k][1], dp[u][k][2]);\n\tprintf(\"\\n\");*/\n}\n\nint main() {\n\tint i;\n\n\tn = read();\n\tfor(i = 2; i <= n; i++) Add(read(), i);\n\n\tinv2 = qpow(2, MOD-2);\n\tdfs(1);\n\t//printf(\"%lld\\n\", dp[4][1][0]);\n\t//printf(\"%lld\\n\", dp[3][1][1]);\n\t//printf(\"%lld\\n\", dp[3][2][0]);\n\n\tfac[0] = 1;\n\tfor(i = 1; i <= n; i++) fac[i] = fac[i-1]*i%MOD;\n\tfor(i = 0; i < n; i++) {\n\t\tint f = i & 1 ? MOD-1 : 1;\n\t\tupdate(ans, f*fac[n-i]%MOD*((dp[1][n-i][0]+dp[1][n-i][1]+dp[1][n-i][2])%MOD)%MOD);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;typedef long long ll;\n#define r(i,n) for(int i=0;i<n;i++)\nconst ll MN=2005;ll md=1e9+7;ll n,sz[MN],p[MN];vector<ll>g[MN];ll d[MN][MN][2];ll f[MN];ll a[MN][3],x[MN][3];\nint main(){f[0]=1;for(ll i=1;i<MN;i++)f[i]=f[i-1]*i%md;cin>>n;for(ll i=2;i<=n;i++){cin>>p[i];g[p[i]].push_back(i);}for(ll i=n;i;i--){memset(a,0,sizeof(a));a[0][0]=1;for(auto &j:g[i]){memset(x,0,sizeof(x)); r(k,sz[j]+1)r(l,sz[i]+1)r(m,3){x[k+l][m]+=d[j][k][0]*a[l][m]%md;if(m<2) x[k+l+1][m+1]+=d[j][k][1]*a[l][m]%md;}sz[i]+=sz[j];r(j,sz[i]+1)r(k,3){a[j][k]=x[j][k]%md;}}r(j,sz[i]+1){d[i][j][0]=a[j][0]+a[j][1]*2+a[j][2]*2;d[i][j][1]=a[j][0]+a[j][1];d[i][j][0]%=md;d[i][j][1]%=md;}sz[i]++;}ll rt=0;r(i,n+1){ll cr=d[1][i][0]*f[n-i]%md;if(i & 1) cr=md-cr;rt+=cr;}cout<<rt%md<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int N,K;\n    cin>>N>>K;\n    map<int,int> A;\n \n    for(int i = 0;i < N;i++) {\n        int a;\n        cin>>a;\n        A[a]++;\n    }\n \n    vector<int> V;\n    for(map<int,int>::iterator it = A.begin();it != A.end();it++) {\n        V.push_back(it ->second);\n    }\n \n    sort(V.begin(),V.end(),greater<int>());\n    long long int sum = 0;\n    for(int i = K;i < V.size();i++) {\n        sum += V[i+];\n    }\n \n    cout<<sum<<endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;typedef long long l;\n#define r(i,n) for(int i=0;i<n;i++)\nconst l MN=2005;l md=1e9+7;l n,sz[MN],p[MN];vector<l>g[MN];l d[MN][MN][2];l f[MN];l a[MN][3],x[MN][3];\nint main(){f[0]=1;for(l i=1;i<MN;i++)f[i]=f[i-1]*i%md;cin>>n;for(l i=2;i<=n;i++){cin>>p[i];g[p[i]].push_back(i);}for(l i=n;i;i--){memset(a,0,sizeof(a));a[0][0]=1;for(auto &j:g[i]){memset(x,0,sizeof(x));r(k,sz[j]+1)r(l,sz[i]+1)r(m,3){x[k+l][m]+=d[j][k][0]*a[l][m]%md;if(m<2) x[k+l+1][m+1]+=d[j][k][1]*a[l][m]%md;}sz[i]+=sz[j];r(j,sz[i]+1)r(k,3){a[j][k]=x[j][k]%md;}}r(j,sz[i]+1){d[i][j][0]=a[j][0]+a[j][1]*2+a[j][2]*2;d[i][j][1]=a[j][0]+a[j][1];d[i][j][0]%=md;d[i][j][1]%=md;}sz[i]++;}l rt=0;r(i,n+1){l cr=d[1][i][0]*f[n-i]%md;if(i&1) cr=md-cr;rt+=cr;}cout<<rt%md<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int Nmax = 2005;\ntypedef long long ll;\n\nint n, i, j, x;\nvector<int> v[Nmax];\nint dp[Nmax][Nmax][3], fact[Nmax], D[Nmax][3], w[Nmax];\n\nvoid add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\nint inm(int x, int y) { return (ll)x*y%Mod; }\n\nvoid Merge(int node, int son)\n{\n    int i, j, dg, dgr;\n    for(i=0; i <= w[node] + w[son]; ++i)\n        for(j=0; j<3; ++j)\n            D[i][j] = 0;\n\n    for(i=0; i<=w[node]; ++i)\n        for(j=0; j<=w[son]; ++j)\n            for(dg=0; dg<3; ++dg)\n                for(dgr=0; dgr<3; ++dgr)\n                    if(dp[node][i][dg] && dp[son][j][dgr])\n                    {\n                        add_to( D[i+j][dg], inm(dp[node][i][dg], dp[son][j][dgr] * (dgr ? 2 : 1)) );\n\n                        if(dg < 2 && dgr < 2)\n                            add_to( D[i+j-1][dg+1], inm(dp[node][i][dg], dp[son][j][dgr]) );\n                    }\n\n    w[node] += w[son];\n    for(i=0; i<=w[node]; ++i)\n        for(j=0; j<3; ++j)\n            dp[node][i][j] = D[i][j];\n}\n\nvoid solve(int node)\n{\n    w[node] = 1; dp[node][1][0] = 1;\n    for(auto son : v[node])\n    {\n        solve(son);\n        Merge(node, son);\n    }\n}\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n  //  freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n;\n    for(i=2; i<=n; ++i)\n    {\n        cin >> x;\n        v[x].push_back(i);\n    }\n\n    fact[0] = 1;\n    for(i=1; i<=n; ++i) fact[i] = inm(fact[i-1], i);\n\n    solve(1);\n\n    int ans = 0;\n    for(i=0; i<=n; ++i)\n        for(j=0; j<3; ++j)\n            if( (n-i) % 2 == 0 ) add_to(ans, inm( dp[1][i][j] * (j ? 2 : 1), fact[i] ) );\n                else add_to(ans, Mod - inm( dp[1][i][j] * (j ? 2 : 1), fact[i] ) );\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nvector<int> edges[2000];\n\nint64_t dp[2001][2001][4], sub[2001][4];\nint sz[2001];\n\nvoid dfs(int i1){\n    sz[i1] = 1;\n    dp[i1][0][0] = 1;\n    for(int i2 : edges[i1]){\n        dfs(i2);\n        memset(sub, 0, sizeof(sub));\n        for(int j1=0; j1<sz[i1]; j1++){\n            for(int j2=0; j2<sz[i2]; j2++){\n                for(int k1=0; k1<4; k1++){\n                    for(int k2=0; k2<4; k2++){\n                        int64_t res = dp[i1][j1][k1] * dp[i2][j2][k2] % MOD;\n                        add(sub[j1+j2][k1], res);\n                        if(nth_bit(k1, 0) == 0 && nth_bit(k2, 1) == 0){\n                            add(sub[j1+j2+1][k1+1], res);\n                        }\n                        if(nth_bit(k1, 1) == 0 && nth_bit(k2, 0) == 0){\n                            add(sub[j1+j2+1][k1+2], res);\n                        }\n                    }\n                }\n            }\n        }\n        sz[i1] += sz[i2];\n        for(int j=0; j<sz[i1]; j++) for(int k=0; k<4; k++) dp[i1][j][k] = sub[j][k];\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i=1; i<N; i++){\n        int p;\n        cin >> p;\n        edges[p-1].push_back(i);\n    }\n\n    dfs(0);\n\n    create_mod_tables(2000);\n    int64_t ans = 0;\n    for(int j=0; j<N; j++){\n        int64_t res = 0;\n        for(int k=0; k<4; k++) add(res, dp[0][j][k]);\n        mul(res, fact[N-j]);\n        add(ans, j%2 ? (MOD - res) : res);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int N,K;\n    cin>>N>>K;\n    map<int,int> A;\n \n    for(int i = 0;i < N;i++) {\n        int a;\n        cin>>a;\n        A[a]++;\n    }\n \n    vector<int> V;\n    for(map<int,int>::iterator it = A.begin();it != A.end();it++) {\n        V.push_back(it ->second);\n    }\n \n    sort(V.begin(),V.end(),greater<int>());\n    long long int sum = 0;\n    for(int i = K;i < V.size();i++) {\n        sum += V[i+1];\n    }\n \n    cout<<sum<<endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nvector<int> G[MAX_N];\n// i:隣の空きが 0, 1, 2\nint dp[MAX_N][MAX_N][3][2];\nint st[MAX_N], fac[MAX_N], inv2;\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t}\n}\n\ninline int mod_pow(int a, ll b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\ninline int add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nvoid dfs(int u)\n{\n    st[u] = 1;\n    dp[u][1][2][0] = 1;\n    each(v,G[u]){\n        dfs(v);\n        for(int i = st[u]; i >= 1; i--){\n            for(int j = st[v]; j >= 1; j--){\n                dp[u][i+j][2][1] = add(dp[u][i+j][2][1], mul(dp[u][i][2][0], (ll)(dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j][1][1] = add(dp[u][i+j][1][1], mul(dp[u][i][1][0], (ll)(dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j][0][1] = add(dp[u][i+j][0][1], mul(dp[u][i][0][0], (ll)(dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j-1][1][1] = add(dp[u][i+j-1][1][1], mul(mul(dp[u][i][2][0], dp[v][j][2][0]), 2));\n                dp[u][i+j-1][1][1] = add(dp[u][i+j-1][1][1], mul(dp[u][i][2][0], dp[v][j][1][0]));\n                dp[u][i+j-1][0][1] = add(dp[u][i+j-1][0][1], mul(dp[u][i][1][0], dp[v][j][2][0]));\n                dp[u][i+j-1][0][1] = add(dp[u][i+j-1][0][1], mul(mul(dp[u][i][1][0], dp[v][j][1][0]), inv2));\n            }\n        }\n        st[u] += st[v];\n        srep(i,1,st[u]+1){\n            rep(j,3){\n                dp[u][i][j][0] = dp[u][i][j][1];\n                dp[u][i][j][1] = 0;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int p;\n        cin >> p;\n        G[p-1].pb(i+1);\n    }\n    make();\n    inv2 = mod_pow(2, MOD-2);\n    dfs(0);\n    int ans = 0;\n    srep(i,1,n+1){\n        if((n-i)%2){\n            ans = sub(ans, mul((ll)(dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) % MOD, fac[i]));\n        }else{\n            ans = add(ans, mul((ll)(dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) % MOD, fac[i]));\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvvi g;\nvl F;\nvvl DP,dp[3];\n\nint dfs(int v){\n\tint S=1;\n\tdp[0][v][0]++;\n\tvp b;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tb.push_back({dfs(u),u});\n\t}\n\tsort(b.rbegin(),b.rend());\n\tfor(int i=0;i<b.size();i++){\n\t\tint T=b[i].first,u=b[i].second;\n\t\tS+=T;\n\t\tvl a[3];\n\t\ta[0]=a[1]=a[2]=vl(n);\n\t\ta[0][0]++;\n\t\tif(!i){\n\t\t\ta[0]=DP[u];\n\t\t\tfor(int j=1;j<S;j++) a[1][j]=(dp[0][u][j-1]*2+dp[1][u][j-1])%mod;\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++) for(int k=1;k<S;k++) for(int l=max(0,k-T);l<=k;l++){\n\t\t\t\t(a[j][k]+=dp[j][v][l]*DP[u][k-l])%=mod;\n\t\t\t\tif(j&&l<k) (a[j][k]+=dp[j-1][v][l]*(dp[0][u][k-l-1]*(3-j)+dp[1][u][k-l-1]*(j==1?1:mod/2+1)%mod))%=mod;\n\t\t\t}\n\t\t}\n\t\tdp[0][v]=a[0];\n\t\tdp[1][v]=a[1];\n\t\tdp[2][v]=a[2];\n\t}\n\tfor(int i=0;i<3;i++) for(int j=0;j<S;j++) (DP[v][j]+=dp[i][v][j])%=mod;\n\treturn S;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tF=vl(n+1,1);\n\tDP=dp[0]=dp[1]=dp[2]=vvl(n,vl(n));\n\tfor(int i=1;i<n;i++){\n\t\tint v;\n\t\tcin>>v;\n\t\tg[v-1].push_back(i);\n\t}\n\tdfs(0);\n\tll res=0;\n\tfor(int i=1;i<=n;i++) F[i]=F[i-1]*i%mod;\n\tfor(int i=0;i<n;i++){\n\t\tll tmp=F[n-i]*DP[0][i]%mod;\n\t\tif(i%2==1) tmp=(mod-tmp)%mod;\n\t\t(res+=tmp)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2020;\nconst int mod = 1000000007;\nusing Arr = array<array<int, 5>, N>;\n\nvoid add(int &x, int y) {\n   x += y;\n   if (x >= mod) x -= mod;\n}\n\nint mul(int x, int y) {\n   return (long long) x * y % mod;\n}\n\nvector<int> g[N];\nint sz[N];\nArr f[N];\n\nArr mrg(Arr x, Arr y, int sx, int sy) {\n   Arr z = {};\n   for (int ny = 1; ny <= sy; ++ny) {\n      array<int, 2> cnt = {};\n      for (int i = 0; i < 5; ++i) {\n         add(cnt[i > 2], y[ny][i]);\n      }\n      for (int nx = 1; nx <= sx; ++nx) {\n         for (int i = 0; i < 3; ++i) {\n            add(z[nx + ny][i], mul(x[nx][i], cnt[0]));\n            if (i < 2) {\n               add(z[nx + ny - 1][i + 1], mul(x[nx][i], cnt[1]));\n            }\n         }\n         for (int i = 3; i < 5; ++i) {\n            add(z[nx + ny][i], mul(x[nx][i], cnt[0]));\n            if (i < 4) {\n               add(z[nx + ny - 1][i + 1], mul(x[nx][i], cnt[1]));\n            }\n         }\n      }\n   }\n   return z;\n}\n\nvoid dfs(int u) {\n   f[u][1][3] = mod - 1;\n   f[u][1][0] = 1;\n   sz[u] = 1;\n   for (int v : g[u]) {\n      dfs(v);\n      f[u] = mrg(f[u], f[v], sz[u], sz[v]);\n      sz[u] += sz[v];\n   }\n   for (int nu = 1; nu <= sz[u]; ++nu) {\n      for (int i = 1; i < 3; ++i) {\n         f[u][nu][i] = mul(f[u][nu][i], 2);\n      }\n   }\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int n;\n   cin >> n;\n   for (int i = 2; i <= n; ++i) {\n      int p;\n      cin >> p;\n      g[p].push_back(i);\n   }\n   dfs(1);\n   int ans = 0;\n   int fact = 1;\n   for (int i = 1; i <= n; ++i) {\n      fact = mul(fact, i);\n      int ways = 0;\n      for (int j = 0; j < 3; ++j) {\n         add(ways, f[1][i][j]);\n      }\n      add(ans, mul(fact, ways));\n   }\n   cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int MN = 2005;\nint mod = 1e9 + 7;\nint n,sz[MN],p[MN];\nvector<int>gph[MN];\nint dp[MN][MN][2];\nint f[MN];\nint a[MN][3], nxt[MN][3];\nsigned main(){\nf[0]=1;\nfor(int i=1;i<MN;i++)f[i]=f[i-1]*i%mod;\ncin >> n;\nfor(int i=2;i<=n;i++){cin>>p[i];gph[p[i]].push_back(i);} \nfor(int i=n;i;i--){\nmemset(a,0,sizeof(a));\na[0][0]=1;\nfor(auto &j:gph[i]){\nmemset(nxt,0,sizeof(nxt)); \nrep(k,sz[j]+1)rep(l,sz[i]+1)rep(m,3){\nnxt[k+l][m]+=dp[j][k][0]*a[l][m]%mod;\nif(m<2) nxt[k+l+1][m+1]+=dp[j][k][1]*a[l][m] % mod;\n}\nsz[i]+=sz[j];  \nrep(j,sz[i]+1)rep(k,3){a[j][k]=nxt[j][k]%mod;}  \n}\nrep(j,sz[i]+1){\ndp[i][j][0]=a[j][0]+a[j][1]*2+a[j][2]*2;\ndp[i][j][1]=a[j][0]+a[j][1];dp[i][j][0]%=mod;dp[i][j][1]%=mod;}\nsz[i]++;}\nint ret=0;  \nfor(int i=0; i<=n; i++){\nint cur = dp[1][i][0]*f[n-i]%mod;\nif(i & 1) cur=mod-cur;\nret+=cur;}\ncout<<ret%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\n\nint n, sz[MAXN], p[MAXN];\nvector<int> gph[MAXN];\n\nlint dp[MAXN][MAXN][2];\nlint fact[MAXN];\nlint aux[MAXN][3], nxt[MAXN][3];\n\nint main(){\n\tfact[0] = 1;\n\tfor(int i=1; i<MAXN; i++) fact[i] = fact[i-1] * i % mod;\n\tcin >> n;\n\tfor(int i=2; i<=n; i++){\n\t\tcin >> p[i];\n\t\tgph[p[i]].push_back(i);\n\t}\n\tfor(int i=n; i; i--){\n\t\tmemset(aux, 0, sizeof(aux));\n\t\taux[0][0] = 1;\n\t\tfor(auto &j : gph[i]){\n\t\t\tmemset(nxt, 0, sizeof(nxt));\n\t\t\tfor(int k=0; k<=sz[j]; k++){\n\t\t\t\tfor(int l=0; l<=sz[i]; l++){\n\t\t\t\t\tfor(int m=0; m<3; m++){\n\t\t\t\t\t\tnxt[k + l][m] += dp[j][k][0] * aux[l][m] % mod;\n\t\t\t\t\t\tif(m < 2) nxt[k + l + 1][m+1] += dp[j][k][1] * aux[l][m] % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[i] += sz[j];\n\t\t\tmemcpy(aux, nxt, sizeof(aux));\n\t\t}\n\t\tfor(int j=0; j<=sz[i]; j++){\n\t\t\tdp[i][j][0] = aux[j][0] + aux[j][1] * 2 + aux[j][2] * 2;\n\t\t\tdp[i][j][1] = aux[j][0] + aux[j][1];\n\t\t\tdp[i][j][0] %= mod;\n\t\t\tdp[i][j][1] %= mod;\n\t\t}\n\t\tsz[i]++;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tlint cur = dp[1][i][0] * fact[n - i] % mod;\n\t\tif(i & 1) cur = mod - cur;\n\t\tret += cur;\n\t}\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nvector<int> g[2100];\nint sz[2100];\nlong long dp[3][2100][2100];\nlong long dp2[4][2100][4100];\nlong long fact[3100];\nvoid solve(int a){\n//\t\tprintf(\"%d\\n\",a);fflush(stdout);\n\tint n=g[a].size();\n\tdp2[0][0][0]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tsolve(g[a][i]);\n\t}\n\tfor(int i=0;i<g[a].size();i++){\n\t\tint T=sz[a];\n\t\tsz[a]+=sz[g[a][i]];\n\t\tint to=g[a][i];\n\t\tfor(int j=0;j<=sz[a]+10;j++){\n\t\t\tdp2[0][i+1][j]=dp2[1][i+1][j]=dp2[2][i+1][j]=dp2[3][i+1][j]=0;\n\t\t}\n\t\tfor(int j=0;j<=T;j++){\n\t\t//\tif(a==1&&j<2)printf(\"%d %d: %lld %lld %lld\\n\",i,j,dp2[0][i][j],dp2[1][i][j],dp2[2][i][j]);\n\n\t\t\tfor(int k=0;k<=sz[g[a][i]]+1;k++){\n\t\t\t\tdp2[0][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[0][i][j]*dp[0][to][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[1][i+1][j+k]+dp2[0][i][j]*dp[1][to][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[1][i+1][j+k]+dp2[1][i][j]*dp[0][to][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[2][i+1][j+k]+dp2[2][i][j]*dp[0][to][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[2][i+1][j+k]+dp2[0][i][j]*dp[2][to][k])%mod;\n\t\t\t\tdp2[3][i+1][j+k]=(dp2[3][i+1][j+k]+dp2[1][i][j]*dp[2][to][k])%mod;\n\t\t\t\tdp2[3][i+1][j+k]=(dp2[3][i+1][j+k]+dp2[2][i][j]*dp[1][to][k])%mod;\n\t\t\t\tdp2[3][i+1][j+k]=(dp2[3][i+1][j+k]+dp2[3][i][j]*dp[0][to][k])%mod;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t//if(a==1)printf(\"%d %d: %lld %lld %lld\\n\",4,0,dp2[0][4][0],dp2[1][4][0],dp2[2][4][0]);\n\t//if(a==1)printf(\"%d %d: %lld %lld %lld\\n\",4,1,dp2[0][4][1],dp2[1][4][1],dp2[2][4][1]);\n\n\t//\tprintf(\"AA\\n\");fflush(stdout);\n\tfor(int i=0;i<=sz[a];i++){\n\t\tdp[0][a][i]=(dp2[0][n][i]+dp2[1][n][i]+dp2[2][n][i]+dp2[3][n][i])%mod;\n\t\tdp[1][a][i+1]=(dp2[0][n][i]+dp2[1][n][i])%mod;\n\t\tdp[2][a][i+1]=(dp2[0][n][i]+dp2[2][n][i])%mod;\n//\t\tif(i<=1)printf(\"%d %d: %lld %lld\\n\",a,i,dp[0][a][i],dp[1][a][i]);\n\n\t}\n//\tif(sz[a]+1==1)printf(\"%d %d: %lld %lld\\n\",a,sz[a]+1,dp[0][a][sz[a]+1],dp[1][a][sz[a]+1]);\n\tsz[a]++;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p;scanf(\"%d\",&p);\n\t\tp--;\n\t//\tprintf(\"%d %d\\n\",i+1,p);fflush(stdout);\n\t\tg[p].push_back(i+1);\n\t}\n\tsolve(0);\n\tlong long ret=0;\n\tfact[0]=1;\n\tfor(int i=1;i<3100;i++)fact[i]=fact[i-1]*i%mod;\n\n\tfor(int i=0;i<=a;i++){\n\t//\tprintf(\"%d: %lld\\n\",i,dp[0][0][i]);\n\t\tif(i%2==0)ret=(ret+dp[0][0][i]*fact[a-i]%mod)%mod;\n\t\telse ret=(ret+mod-dp[0][0][i]*fact[a-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint g[2100];\nint sz[2100];\nlong long dp[2][2100];\nlong long dp2[3][2100][2100];\nlong long fact[3100];\nvoid solve(int a){\n\tint n=g[a].size()\n\tdp2[0][0][0]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tsolve(g[a][i]);\n\t\tint T=sz[a];\n\t\tsz[a]+=sz[g[a][i]];\n\t\tfor(int j=0;j<=sz[a];j++){\n\t\t\tdp2[0][i+1][j]=dp2[1][i+1][j]=dp2[2][i+1][j]=0;\n\t\t}\n\t\tfor(int j=0;j<=F;j++){\n\t\t\tfor(int k=0;k<=sz[g[a][i]];k++){\n\t\t\t\tdp2[0][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[0][i][j]*dp[0][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[0][i][j]*dp[1][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[1][i][j]*dp[0][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[1][i][j]*dp[1][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[2][i][j]*dp[0][k])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=sz[g[a][i]];i++){\n\t\tdp[0][i]=(dp2[0][n][i]+dp2[1][n][i]*2+dp2[2][n][i])%mod;\n\t\tdp[1][i+1]=dp2[1][n][i]%mod;\n\t}\n\tsz[a]++;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p;scanf(\"%d\",&p);\n\t\tp--;\n\t\tg[p].push_back(i+1);\n\t}\n\tsolve(0);\n\tlong long ret=0;\n\tfact[0]=1;\n\tfor(int i=1;i<3100;i++)fact[i]=fact[i-1]*i%mod;\n\n\tfor(int i=0;i<=a;i++){\n\t\tif(i%2==0)ret=(ret+dp[0][i]*fact[a-i]%mod)%mod;\n\t\telse ret=(ret+mod-dp[0][i]*fact[a-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=2010;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nint siz[N],fa[N];\nint f0[N][N],f1[N][N],f2[N][N];\nint F0[N],F1[N],F2[N];\nint main()\n{\n\tint n=gi(),i,j,k,t,ans=0,s,fac;\n\tconst int mod=1e9+7,inv2=(mod+1)>>1;\n\tfor (i=2;i<=n;i++) fa[i]=gi();\n\tfor (i=1;i<=n;i++) siz[i]=1,f0[i][1]=1;\n\tfor (k=n;k>1;k--) {\n\t\tt=fa[k];\n\t\tfor (i=0;i<=siz[k]+siz[t];i++) F0[i]=F1[i]=F2[i]=0;\n\t\tfor (i=1;i<=siz[t];i++)\n\t\t\tfor (j=1;j<=siz[k];j++) {\n\t\t\t\ts=((LL)f0[k][j]+f1[k][j]+f2[k][j])%mod;\n\t\t\t\t\n\t\t\t\tF2[i+j]=(F2[i+j]+1LL*f2[t][i]*s)%mod;\n\t\t\t\tF2[i+j-1]=(F2[i+j-1]+1LL*f1[t][i]*f1[k][j]%mod*inv2+1LL*f1[t][i]*f0[k][j])%mod;\n\n\t\t\t\tF1[i+j]=(F1[i+j]+1LL*f1[t][i]*s)%mod;\n\t\t\t\tF1[i+j-1]=(F1[i+j-1]+1LL*f0[t][i]*(f1[k][j]+2LL*f0[k][j]))%mod;\n\n\t\t\t\tF0[i+j]=(F0[i+j]+1LL*f0[t][i]*s)%mod;\n\t\t\t}\n\t\tfor (i=siz[t]+=siz[k];~i;i--) f0[t][i]=F0[i],f1[t][i]=F1[i],f2[t][i]=F2[i];\n\t}\n\tfor (i=fac=1;i<=n;i++) {\n\t\tfac=1LL*fac*i%mod;\n\t\tans=(ans+((n^i)&1?-1:1)*fac*((LL)f0[1][i]+f1[1][i]+f2[1][i]))%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    int st = (int)(s[0]-'a');\n    vs ss;\n    string nw;\n    nw.pb(s[0]);\n    srep(i,1,n){\n        if((int)(s[i]-'a') < st){\n            cout << \"No\\n\";\n            return 0;\n        }else if((int)(s[i]-'a') == st){\n            ss.pb(nw);\n            nw.clear();\n            nw.pb(s[0]);\n        }else{\n            nw.pb(s[i]);\n        }\n    }\n    ss.pb(nw);\n    string pos = ss.back();\n    rrep(i,len(ss)-1){\n        if(ss[i] > pos){\n            cout << \"No\\n\";\n            return 0;\n        }else{\n            pos = ss[i] + pos;\n        }\n    }\n    cout << \"Yes\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2007;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nll fct[MAXN];\n\nusing arr = array<ll, MAXN>;\nusing varr = array<arr, 2>;\n\nvector <int> e[MAXN];\n\narr f[MAXN];\nint sz[MAXN];\narr fnt[MAXN];\narr fclosed[MAXN];\n\nll pw(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = pw(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll rev2 = pw(2);\n\n\narr mrg(int s1, const arr& a1, int s2, const arr& a2, int off = 0) {\n    arr r;\n    r.fill(0);\n    for (int i = 0; i < s1; ++i) {\n        for (int j = 0; j < min(s2, MAXN - 1 - s1 - off); ++j) {\n            r[i + j + off] = (r[i + j + off] + a1[i] * a2[j]) % MOD;\n        }\n    }\n\n    return r;\n}\n\n\n\narr ad(const arr& a1, const arr& a2) {\n    arr r;\n    r.fill(0);\n    for (int i = 0; i < MAXN; ++i) {\n        r[i] = (a1[i] + a2[i]) % MOD;\n    }\n\n    return r;\n}\n\narr d2(const arr& a1) {\n    arr r;\n    r.fill(0);\n    for (int i = 0; i < MAXN; ++i) {\n        r[i] = (a1[i] * rev2) % MOD;\n    }\n\n    return r;\n}\n\n\narr m2(const arr& other) {\n    return ad(other, other);\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n;\n    cin >> n;\n    for (int i = 2; i <= n; ++i) {\n        int x;\n        cin >> x;\n        e[x].push_back(i);\n    }\n\n    for (int i = n; i >= 1; --i) {\n        sz[i] = 1;\n        auto& cf = f[i];\n        auto& cfnt = fnt[i];\n        auto& cclosed = fclosed[i];\n\n        cfnt[0] = 1;\n\n        for (int u : e[i]) {\n            arr tot_sum = ad(f[u], fnt[u]);\n            arr c_sum = ad(tot_sum, fclosed[u]);\n            arr m_sum = ad(m2(fnt[u]), f[u]);\n            \n            arr nf = mrg(sz[i], cf, sz[u], c_sum);\n            nf = ad(nf, mrg(sz[i], cfnt, sz[u], m_sum, 1));\n\n            arr ncf = mrg(sz[i], cfnt, sz[u], c_sum);\n\n            arr nclosed = mrg(sz[i], cclosed, sz[u], c_sum);\n            nclosed = ad(nclosed, d2(mrg(sz[i], cf, sz[u], m_sum, 1)));\n\n            cf = nf;\n            cfnt = ncf;\n            cclosed = nclosed;\n\n\n            sz[i] += sz[u];\n        }\n\n    }\n\n    ll ans = 0;\n    ll mul = 1;\n    \n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    auto tot = f[1];\n\n    for (int i = 0; i <= n; ++i) {\n        tot[i] = (tot[i] + fnt[1][i] + fclosed[1][i]) % MOD;\n    }\n\n\n    for (int i = 0; i < n; ++i) {\n        ll vl = (tot[i] * fct[n - i]) % MOD;\n\n        if (i & 1) {\n            ans -= vl;\n        } else {\n            ans += vl;\n        }\n\n        ans %= MOD;\n    }\n\n    if (ans < 0) {\n        ans += MOD;\n    }\n\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int N,K;\n    cin>>N>>K;\n    map<int,int> A;\n \n    for(int i = 0;i < N;i++) {\n        int a;\n        cin>>a;\n        A[a]++;\n    }\n \n    vector<int> V;\n    for(map<int,int>::iterator it = A.begin();it != A.end();it++) {\n        V.push_back(it ->second);\n    }\n \n    sort(V.begin(),V.end(),greater<int>());\n    long long int sum = 0;\n    for(int i = K;i < V.size();i++) {\n        sum += V[i];\n    }\n \n    cout<<sum<<endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int INV2 = (MOD + 1) / 2;\n\nint n;\nint par[MAXN];\n\nint fac[MAXN + 1];\n\nint sz[MAXN];\nint ways[MAXN][MAXN + 1][3]; // ways[i][j][k] = the number of ways to make directed paths in the subtree of i with total length j, with the root connected to k childs\n\nvoid run() {\n\tfac[0] = 1; FORE(i, 1, MAXN) fac[i] = (ll)fac[i - 1] * i%MOD;\n\n\tscanf(\"%d\", &n); par[0] = -1; FOR(i, 1, n) scanf(\"%d\", &par[i]), --par[i];\n\n\tREP(i, n) sz[i] = 1;\n\tmemset(ways, 0, sizeof(ways));\n\tREP(i, n) ways[i][0][0] = 1;\n\tfor (int a = n - 1; a >= 0; --a) if(par[a]!=-1) {\n\t\tint b = par[a];\n\t\tfor (int bk = 2; bk >= 0; --bk) for (int bj = sz[b] - 1; bj >= 0; --bj) if (ways[b][bj][bk] != 0) {\n\t\t\tint bways = ways[b][bj][bk]; ways[b][bj][bk] = 0;\n\t\t\tREPE(ak, 2) REPE(aj, sz[a] - 1) if (ways[a][aj][ak] != 0) REP(use, 2) {\n\t\t\t\tif (use == 1 && (ak == 2 || bk == 2)) continue;\n\t\t\t\tint aways = ways[a][aj][ak], nbk = bk + use, nbj = bj + aj + use, mlt = use == 0 ? 1 : ak == 1 && bk == 1 ? INV2 : ak == 1 || bk == 1 ? 1 : 2;\n\t\t\t\tways[b][nbj][nbk] = (ways[b][nbj][nbk] + (ll)bways*aways%MOD*mlt) % MOD;\n\t\t\t}\n\t\t}\n\t\tsz[b] += sz[a];\n\t\t//REPE(j, sz[b] - 1) REPE(k, 2) if (ways[b][j][k] != 0) printf(\"ways[%d][%d][%d]=%d\\n\", b + 1, j, k, ways[b][j][k]);\n\t}\n\t//REP(i, n) REPE(j, sz[i] - 1) REPE(k, 2) if (ways[i][j][k] != 0) printf(\"ways[%d][%d][%d]=%d\\n\", i + 1, j, k, ways[i][j][k]);\n\n\tint ret = 0;\n\tREPE(j, sz[0] - 1) REPE(k, 2) if (ways[0][j][k] != 0) {\n\t\tint cur = (ll)ways[0][j][k] * fac[n - j] % MOD;\n\t\tif (j % 2 == 1) cur = cur == 0 ? 0 : MOD - cur;\n\t\tret = (ret + cur) % MOD;\n\t}\n\tprintf(\"%d\\n\", ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nvector <int> G[N];\nint n, dp[N][N][3], g[N][3], c[N], ans;\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod; if (a < 0) a += mod;\n}\n\nvoid dfs(int u){\n    c[u] = 0;\n    dp[u][0][0] = 1;\n    for (auto v : G[u]){\n        dfs(v);\n        for (int i = 0; i <= c[u]+c[v]+1; i++) g[i][0] = g[i][1] = g[i][2] = 0;\n        for (int i = 0; i <= c[u]; i++) for (int j = 0; j <= c[v]; j++){\n            add(g[i+j][0], 1LL * dp[u][i][0] * dp[v][j][0] % mod);\n            add(g[i+j][1], 1LL * dp[u][i][1] * dp[v][j][0] % mod);\n            add(g[i+j+1][1], 1LL * dp[u][i][0] * dp[v][j][1] % mod);\n            add(g[i+j][2], 1LL * dp[u][i][2] * dp[v][j][0] % mod);\n            add(g[i+j+1][2], 1LL * dp[u][i][1] * dp[v][j][1] % mod);\n        }\n        for (int i = 0; i <= c[u]+c[v]+1; i++) dp[u][i][0] = g[i][0], dp[u][i][1] = g[i][1], dp[u][i][2] = g[i][2];\n        c[u] += c[v] + 1;\n    }\n    for (int i = 0; i <= c[u]; i++){\n        int a = dp[u][i][0], b = dp[u][i][1], c = dp[u][i][2];\n        dp[u][i][0] = a; add(dp[u][i][0], 2LL * b % mod); add(dp[u][i][0], 2LL * c % mod);\n        dp[u][i][1] = a; add(dp[u][i][1], b);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int i = 2; i <= n; i++){\n        int x; cin >> x;\n        G[x].push_back(i);\n    }\n    dfs(1); int f = 1;\n    for (int i = n-1; i >= 0; i--){\n        f = 1LL * f * (n - i) % mod;\n        if (i&1) add(ans, -1LL * f * dp[1][i][0] % mod);\n        else add(ans, 1LL * f * dp[1][i][0] % mod);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint a[200010], b[200010];\nint n, bs;\nint mn[800010], tag[800010];\nvoid build(int p, int l, int r) {\n\tif(l == r) {\n\t\tmn[p] = b[l]; tag[p] = 0;\n\t\treturn ;\n\t}\n\tint mid = (l + r)>>1;\n\tbuild(p<<1, l, mid); build(p<<1|1, mid + 1, r);\n\tmn[p] = min(mn[p<<1], mn[p<<1|1]);\n}\ninline void pd(int p) {\n\ttag[p<<1]+= tag[p]; mn[p<<1]+= tag[p];\n\ttag[p<<1|1]+= tag[p]; mn[p<<1|1]+= tag[p];\n\ttag[p] = 0;\n}\nvoid add(int p, int l, int r, int x, int y) {\n\tif(x > y) return ;\n\tif(x <= l && r <= y) {\n\t\t++tag[p];\n\t\t++mn[p];\n\t\treturn ;\n\t}\n\tint mid = (l + r)>>1;\n\tpd(p); \n\tif(x <= mid) add(p<<1, l, mid, x, y);\n\tif(mid + 1 <= y) add(p<<1|1, mid + 1, r, x, y);\n\tmn[p] = min(mn[p<<1], mn[p<<1|1]);\n}\nint query(int p, int l, int r, int x, int y) {\n\tif(x <= l && r <= y) return mn[p];\n\tint mid = (l + r)>>1;\n\tint s1 = 0x7fffffff, s2 = 0x7fffffff;\n\tpd(p);\n\tif(x <= mid) s1 = query(p<<1, l, mid, x, y);\n\tif(mid + 1 <= y) s2 = query(p<<1|1, mid + 1, r, x, y);\n\treturn min(s1, s2);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tmemcpy(b, a, sizeof(b)); sort(b+1, b+n+1); bs = unique(b+1, b+n+1) - b - 1;\n\tbuild(1, 1, bs);\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint p = lower_bound(b+1, b+bs+1, a[i]) - b;\n\t\tans+= query(1, 1, bs, p, bs) - a[i];\n\t\tadd(1, 1, bs, 1, p - 1);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 2001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nvoid AD(array<int,4>& a, array<int,4> b) {\n    F0R(i,4) AD(a[i],b[i]);\n}\n\nint N, p[MX], fac[MX], ans;\nvector<array<int,4>> dp[MX];\n\nvoid comb(vector<array<int,4>>& a, vector<array<int,4>> b) {\n    vector<array<int,4>> c(sz(a)+sz(b));\n    F0R(i,sz(a)) F0R(j,sz(b)) {\n        F0R(I,4) F0R(J,4) AD(c[i+j][I],mul(a[i][I],b[j][J]));\n        AD(c[i+j+1][1],mul(a[i][0],b[j][0])); AD(c[i+j+1][2],mul(a[i][0],b[j][0]));\n        AD(c[i+j+1][1],mul(a[i][0],b[j][1])); \n        AD(c[i+j+1][2],mul(a[i][0],b[j][2])); \n        \n        AD(c[i+j+1][3],mul(a[i][1],b[j][0])); AD(c[i+j+1][3],mul(a[i][1],b[j][2]));\n        AD(c[i+j+1][3],mul(a[i][2],b[j][0])); AD(c[i+j+1][3],mul(a[i][2],b[j][1]));\n    }\n    swap(a,c);\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N);\n    FOR(i,2,N+1) re(p[i]);\n    FOR(i,1,N+1) dp[i].pb({1,0,0,0});\n    FORd(i,2,N+1) comb(dp[p[i]],dp[i]);\n    fac[0] = 1;\n    FOR(i,1,N+1) fac[i] = mul(i,fac[i-1]);\n    // pr(dp[1]);\n    F0R(i,N) {\n        int prod = 0; F0R(j,4) AD(prod,dp[1][i][j]);\n        MUL(prod,fac[N-i]);\n        if (i&1) SUB(ans,prod);\n        else AD(ans,prod);\n    }\n    pr(ans);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nusing namespace std;\ntypedef vector<ll> vec;\nconst int MAX_N=2000;\nint N;\nconst ll MOD=1e9+7;\nvector<int> G[MAX_N];\nvec dp[MAX_N][3];\nll minv2;\nll mpw(ll n,ll m){\n\tll ret=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tret*=n;\n\t\t\tret%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\nvoid add(ll &a,ll b){\n\ta+=b;\n\tif(a>=MOD){\n\t\ta-=MOD;\n\t}\n}\nvoid dfs(int v,int p){\n\tREP(i,3){\n\t\tint a=0;\n\t\tif(i==0)a=1;\n\t\tdp[v][i].push_back(a);\n\t}\n\tfor(auto e:G[v]){\n\t\tif(e!=p){\n\t\t\tdfs(e,v);\n\t\t\tint n=(int)dp[v][0].size(),m=(int)dp[e][0].size();\n\t\t\tvec tmp[3];\n\t\t\tREP(i,3){\n\t\t\t\ttmp[i].resize(n+m);\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tREP(d1,3){\n\t\t\t\t\tREP(j,m){\n\t\t\t\t\t\tREP(d2,3){\n\t\t\t\t\t\t\tint c2,d3;\n\t\t\t\t\t\t\tc2=i+j+1;\n\t\t\t\t\t\t\td3=d1;\n\t\t\t\t\t\t\tadd(tmp[d3][c2],dp[v][d1][i]*dp[e][d2][j]%MOD);\n\t\t\t\t\t\t\tif(d1==2 || d2==2)continue;\n\t\t\t\t\t\t\td3=d1+1;\n\t\t\t\t\t\t\tll x;\n\t\t\t\t\t\t\tc2--;\n\t\t\t\t\t\t\tif(d1==0 && d2==0){\n\t\t\t\t\t\t\t\tx=2;\n\t\t\t\t\t\t\t}else if(d1==0 || d2==0){\n\t\t\t\t\t\t\t\tx=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tx=minv2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tadd(tmp[d3][c2],dp[v][d1][i]*dp[e][d2][j]%MOD*x%MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,3){\n\t\t\t\tdp[v][i]=tmp[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\t\t\t\nint main(){\n\tminv2=mpw(2,MOD-2);\n\tcin>>N;\n\tREP(i,N-1){\n\t\tint b;\n\t\tcin>>b;\n\t\tb--;\n\t\tG[i+1].push_back(b);\n\t\tG[b].push_back(i+1);\n\t}\n\tdfs(0,-1);\n\tll ans=0,x=1,sgn=1;\n\tREP(i,N-1)sgn*=-1;\n\tREP(i,N){\n\t\tx*=(i+1);\n\t\tx%=MOD;\n\t\tREP(j,3){\n\t\t\tadd(ans,(sgn*(dp[0][j][i]*x)%MOD+MOD)%MOD);\n\t\t}\n\t\tsgn*=-1;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n/*#if !defined(YCM) && 0\n#define _FORTIFY_SOURCE 0\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"avx,tune=native\")\n#include <stdio.h>\n#endif*/\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n    //freopen(\"/home/alexandero/ClionProjects/ACM/output.txt\", \"w\", stdout);\n    //freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cout << \"Case #\" << testNum++ << \": \";\n        //cerr << testNum << endl;\n        solve(true);\n        //cerr << testNum - 1 << endl;\n    }\n    cout.flush();\n#ifdef AIM1\n    while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& a) {\n    sort(all(a));\n    a.erase(unique(all(a)), a.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n    cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n    cur = max(cur, val);\n}\n\nvoid precalc() {}\n\n#define int li\nconst int mod = 1000000007;\n\nconst int C = 2010;\nint c[C][C];\nvector<vector<vector<vector<int>>>> dp;\nvector<vector<int>> g;\nvector<int> cnt;\n\nvoid add(int& cur, int val) {\n    cur += val;\n    cur %= mod;\n}\n\nint rev2;\n\nusing DP = vector<vector<vector<int>>>;\n\nvoid dfs(int v) {\n    cnt[v] = 1;\n    dp[v].assign(1, vector<vector<int>>(2, vector<int>(3, 0)));\n    dp[v][0][0][0] = 1;\n    DP new_dp;\n    int children = 0;\n    for (int to : g[v]) {\n        dfs(to);\n        new_dp.assign(cnt[v] + cnt[to], vector<vector<int>>(2, vector<int>(3, 0)));\n\n        for (int cur_diff = 0; cur_diff < dp[v].size(); ++cur_diff) {\n            for (int cur_k = 0; cur_k < 2; ++cur_k) {\n                for (int cur_deg = 0; cur_deg <= 2; ++cur_deg) {\n                    int cur_dp = dp[v][cur_diff][cur_k][cur_deg];\n                    if (!cur_dp) continue;\n                    for (int new_diff = 0; new_diff < dp[to].size(); ++new_diff) {\n                        for (int new_k = 0; new_k < 2; ++new_k) {\n                            for (int new_deg = 0; new_deg <= 2; ++new_deg) {\n                                int to_dp = dp[to][new_diff][new_k][new_deg];\n                                if (!to_dp) continue;\n                                add(new_dp[cur_diff + new_diff][cur_k ^ new_k][cur_deg], cur_dp * to_dp);\n                                if (cur_deg == 2 || new_deg == 2) {\n                                    continue;\n                                }\n                                int dp_deg = cur_deg + 1;\n                                int dp_k = (cur_k ^ new_k ^ 1);\n                                int dp_diff = cur_diff + new_diff + 1;\n                                int val = cur_dp * to_dp % mod;\n                                if (new_deg && cur_deg) {\n                                    val = val * rev2 % mod;\n                                } else if (cur_deg == 0 && new_deg == 0) {\n                                    val = val * 2 % mod;\n                                }\n                                add(new_dp[dp_diff][dp_k][dp_deg], val);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cnt[v] += cnt[to];\n        dp[v].swap(new_dp);\n        ++children;\n    }\n}\n\nvoid solve(bool read) {\n    for (int i = 0; i < C; ++i) {\n        c[i][i] = c[i][0] = 1;\n        for (int j = 1; j < i; ++j) {\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n        }\n    }\n    rev2 = binpow(2LL, mod - 2, mod);\n    int n;\n    cin >> n;\n    g.resize(n);\n    cnt.assign(n, 0);\n    dp.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int p;\n        cin >> p;\n        --p;\n        g[p].push_back(i);\n    }\n    dfs(0);\n\n    vector<int> fact(2 * n + 5, 1);\n    for (int i = 1; i < fact.size(); ++i) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n\n    int ans = 0;\n    for (int diff = 0; diff < n; ++diff) {\n        int cur_fact = fact[n - diff];\n        for (int par_k = 0; par_k < 2; ++par_k) {\n\n            /*for (int j = 0; j < 3; ++j) {\n                if (dp[0][diff][par_k][j] > 0) {\n                    cout << diff << \" \" << par_k << \" \" << j << \" \" << dp[0][diff][par_k][j] << endl;\n                }\n            }*/\n\n            //cout << diff << \" \" << par_k << \" \" << cur_fact * (dp[0][diff][par_k][0] + dp[0][diff][par_k][1] + dp[0][diff][par_k][2]) << endl;\n\n            add(ans, cur_fact * (dp[0][diff][par_k][0] + dp[0][diff][par_k][1] + dp[0][diff][par_k][2]));\n            cur_fact = -cur_fact;\n        }\n    }\n    if (ans < 0) {\n        ans += mod;\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int MN=2005;int md=1e9+7;int n,sz[MN],p[MN];vector<int>g[MN];int d[MN][MN][2];int f[MN];int a[MN][3],x[MN][3];\nsigned main(){f[0]=1;\nfor(int i=1;i<MN;i++)f[i]=f[i-1]*i%md;\ncin>>n;for(int i=2;i<=n;i++){cin>>p[i];g[p[i]].push_back(i);}\nfor(int i=n;i;i--){memset(a,0,sizeof(a));a[0][0]=1;for(auto &j:g[i]){memset(x,0,sizeof(x)); \nrep(k,sz[j]+1)rep(l,sz[i]+1)rep(m,3){\nx[k+l][m]+=d[j][k][0]*a[l][m]%md;\nif(m<2) x[k+l+1][m+1]+=d[j][k][1]*a[l][m]%md;}\nsz[i]+=sz[j];  \nrep(j,sz[i]+1)rep(k,3){a[j][k]=x[j][k]%md;}}\nrep(j,sz[i]+1){\nd[i][j][0]=a[j][0]+a[j][1]*2+a[j][2]*2;\nd[i][j][1]=a[j][0]+a[j][1];d[i][j][0]%=md;d[i][j][1]%=md;}\nsz[i]++;}\nint ret=0;rep(i,n+1){int cur=d[1][i][0]*f[n-i]%md;if(i & 1) cur=md-cur;ret+=cur;}\ncout<<ret%md<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, fac[2018], vol[2018], dp[2018][2018][2][3], old[2018][2][3];\nconst int mod = 1e9 + 7;\nvector < int > v[2018];\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\n/*\ndp[i][j][parity][0/1/2]\n\nparity of the number of edges chosen to be part of a path\n[0/1/2] the number of edges adjacent to i (the root) already chosen\nj is the number of different paths (including 1-length ones)?\nmultiplied by 2^the number of paths of non-zero length that are present already\n*/\nconst int inv2 = (mod + 1) / 2;\nvoid dfs (int nod)\n{\n    vol[nod] = 1, dp[nod][1][0][0] = 1;\n    for (auto it : v[nod])\n    {\n        dfs (it);\n        for (int i=0; i<=vol[nod]; i++)\n            for (int j=0; j<2; j++)\n                for (int k=0; k<3; k++)\n                    old[i][j][k] = dp[nod][i][j][k], dp[nod][i][j][k] = 0;\n        for (int i=0; i<=vol[nod]; i++)\n            for (int p1=0; p1<2; p1++)\n                for (int k1=0; k1<3; k1++)\n                    if (old[i][p1][k1])\n                        for (int j=0; j<=vol[it]; j++)\n                            for (int p2=0; p2<2; p2++)\n                                for (int k2=0; k2<3; k2++)\n                                    if (dp[it][j][p2][k2])\n                                    {\n                                        int curr = mul (old[i][p1][k1], dp[it][j][p2][k2]);\n                                        for (int e=0; e<2 && e + k2 < 3 && e + k1 < 3; e++)\n                                        {\n                                            ///e=0/1 whether I chose or not the edge between it and nod\n                                            int newSize = i + j - e;\n                                            if (k1 > 0 && k2 > 0 && e == 1)\n                                                curr = mul (curr, inv2);\n                                            if (k1 == 0 && k2 == 0 && e == 1)\n                                                curr = add (curr, curr);\n                                            adto (dp[nod][newSize][p1 ^ p2 ^ e][e + k1], curr);\n                                        }\n                                    }\n        vol[nod] += vol[it];\n    }\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=2; i<=N; i++)\n{\n    int t;\n    scanf (\"%d\", &t);\n    v[t].push_back (i);\n}\ndfs (1);\nfac[0] = 1;\nfor (int i=1; i<=N; i++)\n    fac[i] = mul (fac[i - 1], i);\nint ans = 0;\nfor (int p=0; p<2; p++)\n{\n    int curr = 0;\n    for (int i=1; i<=N; i++)\n        for (int j=0; j<3; j++)\n            adto (curr, mul (dp[1][i][p][j], fac[i]));\n    if (p == 0) adto (ans, curr);\n    else ans = subtract (ans, curr);\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\n#ifndef HOGEPACHI_ASSERT\n#define NDEBUG\n#endif\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\n//! メルセンヌ・ツイスタ !//\nstd::mt19937 mt{std::random_device{}()};\n//! Debug出力 !//\n#define SHOW(...) (std::cerr << \"(\" << #__VA_ARGS__ << \") = (\"), HogeHogeSansuu(__VA_ARGS__), std::cerr << \")\" << std::endl\nstruct has_debugPrint_impl\n{\n    template <class T>\n    static auto check(T&& x) -> decltype(x.debugPrint(), std::true_type{});\n    template <class T>\n    static auto check(...) -> std::false_type;\n};\ntemplate <class T>\nclass has_debugPrint : public decltype(has_debugPrint_impl::check<T>(std::declval<T>()))\n{\n};\ntemplate <bool>\nstruct HogeHogeDump\n{\n    template <typename T>\n    static void dump(const T& x) { x.debugPrint(); }\n};\ntemplate <>\nstruct HogeHogeDump<false>\n{\n    template <typename T>\n    static void dump(const T& x) { std::cerr << x; }\n};\nvoid HogeHogeSansuu() { ; }\ntemplate <typename T>\nvoid HogeHogeSansuu(const T& x) { HogeHogeDump<has_debugPrint<T>::value>::dump(x); }\ntemplate <typename T, typename... Args>\nvoid HogeHogeSansuu(const T& x, Args... args) { HogeHogeDump<has_debugPrint<T>::value>::dump(x), std::cerr << \",\", HogeHogeSansuu(args...); }\n//! chminとchmax !//\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\n//! Rep関数 !//\ntemplate <typename T, typename F>\nvoid For(const T s, const T t, const F f)\n{\n    for (T i = s; i != t; i += T(s < t ? 1 : -1)) { f(i); }\n}\ntemplate <typename T, typename F>\nvoid Rep(const T N, const F f) { For<T, F>(0, N, f); }\ntemplate <typename T, typename F>\nvoid RRep(const T N, const F f) { For<T, F>(N - 1, -1, f); }\n//! Vec関数 !//\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\n//! ビット演算 !//\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//! 累積和 !//\ntemplate <typename T>\nstruct Accum\n{\n    template <typename InIt>\n    Accum(const InIt first, const InIt last) : accum(std::size_t(std::distance(first, last))) { std::partial_sum(first, last, accum.begin()); }\n    T sum(const std::size_t i) const { return i == 0 ? T(0) : accum[i - 1]; }\n    T sum(const std::size_t l, const std::size_t r) const { return sum(r) - sum(l); }\n    std::vector<T> accum;\n};\ntemplate <typename T>\nstruct Accum2D\n{\n    Accum2D(const std::vector<std::vector<T>>& t) : accum{t}\n    {\n        for (std::size_t i = 0; i < accum.size(); i++) {\n            for (std::size_t j = 1; j < accum[i].size(); j++) { accum[i][j] += accum[i][j - 1]; }\n        }\n        for (std::size_t i = 1; i < accum.size(); i++) {\n            for (std::size_t j = 0; j < accum[i].size(); j++) { accum[i][j] += accum[i - 1][j]; }\n        }\n    }\n    T sum(const std::size_t y, const std::size_t x) const { return y == 0 or x == 0 ? T(0) : accum[y - 1][x - 1]; }\n    T sum(const std::size_t ymin, const std::size_t ysup, const std::size_t xmin, const std::size_t xsup) const { return sum(ysup, xsup) - sum(ymin, xmin); }\n    std::vector<std::vector<T>> accum;\n};\n//! 座標圧縮 !//\ntemplate <typename T>\nstruct Zip\n{\n    template <typename InIt>\n    Zip(const InIt first, const InIt last) : unzip(std::size_t(std::distance(first, last)))\n    {\n        std::copy(first, last, unzip), std::sort(unzip.begin(), unzip.end()), unzip.erase(std::unique(unzip.begin(), unzip.end()), unzip.end());\n        for (std::size_t i = 0; i < unzip.size(); i++) { zip[unzip[i]] = i; }\n    }\n    std::vector<T> unzip;\n    std::map<T, std::size_t> zip;\n};\n//! STLの出力関数 !//\ntemplate <typename T, std::size_t N>\nstd::ostream& operator<<(std::ostream& os, const std::array<T, N>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::deque<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multimap<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multiset<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::map<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& v) { return (os << \"<\" << v.first << \",\" << v.second << \">\"); }\ntemplate <typename T1, typename T2, typename T3>\nstd::ostream& operator<<(std::ostream& os, const std::priority_queue<T1, T2, T3>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::queue<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.front() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::set<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::stack<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multimap<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multiset<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_map<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_set<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    void debugPrint() const\n    {\n        std::cerr << \"[\\n\";\n        for (std::size_t i = 0; i < V; i++) {\n            for (const std::size_t to : edge[i]) { std::cerr << i << \"->\" << to << \"\\n\"; }\n        }\n        std::cerr << \"]\\n\";\n    }\n    const std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nusing mll = ModInt<MOD<uint>>;\nconstexpr ll D2 = (MOD<uint> + 1) / 2;\nstruct Poly\n{\n    Poly(const std::size_t N = 0, const mll init = 0) : p(N, init) {}\n    Poly(const std::initializer_list<mll>& l) : p(l) {}\n    Poly(const std::vector<mll>& v) : p{v} {}\n    std::size_t size() const { return p.size(); }\n    const mll& operator[](const std::size_t i) const { return p[i]; }\n    mll& operator[](const std::size_t i) { return p[i]; }\n    Poly operator+(const Poly& p2) const\n    {\n        const std::size_t N1 = p.size(), N2 = p2.size(), N = std::max(N1, N2);\n        Poly ans(N, 0);\n        for (std::size_t i = 0; i < N1; i++) { ans[i] += p[i]; }\n        for (std::size_t i = 0; i < N2; i++) { ans[i] += p2[i]; }\n        return ans;\n    }\n    Poly operator*(const Poly& p2) const\n    {\n        const std::size_t N1 = p.size(), N2 = p2.size(), N = N1 + N2 - 1;\n        if (N1 == 0 or N2 == 0) { return Poly(0); }\n        Poly ans(N, 0);\n        for (std::size_t i = 0; i < N1; i++) {\n            for (std::size_t j = 0; j < N2; j++) { ans[i + j] += p[i] * p2[j]; }\n        }\n        return ans;\n    }\n    Poly operator*(const mll v) const\n    {\n        Poly ans = p;\n        for (std::size_t i = 0; i < p.size(); i++) { ans[i] *= v; }\n        return ans;\n    }\n    Poly operator<<(const std::size_t l) const\n    {\n        Poly ans(p.size() + l);\n        for (std::size_t i = 0; i < p.size(); i++) { ans[i + l] = p[i]; }\n        return ans;\n    }\n    Poly operator>>(const std::size_t l) const\n    {\n        if (l >= p.size()) { return Poly(0); }\n        Poly ans(p.size() - l);\n        for (std::size_t i = 0; i < p.size() - l; i++) { ans[i] = p[i + l]; }\n        return ans;\n    }\n    std::vector<mll> p;\n};\nint main()\n{\n    int N;\n    std::cin >> N;\n    Graph G(N);\n    for (int i = 1, p; i < N; i++) { std::cin >> p, p--, G.addEdge(p, i); }\n    std::vector<Poly> dp1(N), dp2(N), dp3(N);\n    auto dfs = [&](auto&& self, const int s, const int p) -> void {\n        Poly p1{1}, p2, p3;\n        for (const int to : G[s]) {\n            if (to == p) { continue; }\n            self(self, to, s);\n            const Poly q1 = dp1[to] + dp2[to] + dp3[to], q2 = dp2[to] + dp1[to] * mll(2);\n            p3 = p3 * q1 + p2 * q2, p2 = p2 * q1 + p1 * q2, p1 = p1 * q1;\n        }\n        dp1[s] = (p1 << 1) * mll(D2), dp2[s] = p2, dp3[s] = p3 >> 1;\n    };\n    dfs(dfs, 0, -1);\n    std::vector<mll> coeff(N + 1, (N % 2 == 0 ? 1 : -1));\n    for (int i = 1; i <= N; i++) { coeff[i] = coeff[i - 1] * i * 2; }\n    mll ans = 0;\n    const Poly sum = dp1[0] + dp2[0] + dp3[0];\n    for (int i = 0; i <= N; i++) { ans += coeff[i] * sum[i] * (i % 2 == 0 ? 1 : -1); }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    return fact[n]*inv[n-k]%mod;\n}\n\nint inv2=(mod+1)/2;\n\nint N;\nvint G[2222];\n\nint dp[2222][2222][3];\nint sz[2222];\nint tmp[2222][3];\n\nvoid dfs(int v){\n    sz[v]=1;\n    dp[v][1][0]=1;\n\n    for(auto u:G[v]){\n        dfs(u);\n\n        rep(i,sz[v]+sz[u]+1)rep(j,3)tmp[i][j]=0;\n\n        for(int i=1;i<=sz[v];i++){\n            for(int j=1;j<=sz[u];j++){\n                //0 0\n                add(tmp[i+j][0],dp[v][i][0]*dp[u][j][0]%mod);\n                add(tmp[i+j-1][1],dp[v][i][0]*dp[u][j][0]*2%mod);\n\n                //0 1\n                add(tmp[i+j][0],dp[v][i][0]*dp[u][j][1]%mod);\n                add(tmp[i+j-1][1],dp[v][i][0]*dp[u][j][1]%mod);\n\n                //0 2\n                add(tmp[i+j][0],dp[v][i][0]*dp[u][j][2]%mod);\n\n                //1 0\n                add(tmp[i+j][1],dp[v][i][1]*dp[u][j][0]%mod);\n                add(tmp[i+j-1][2],dp[v][i][1]*dp[u][j][0]%mod);\n\n                //1 1\n                add(tmp[i+j][1],dp[v][i][1]*dp[u][j][1]%mod);\n                add(tmp[i+j-1][2],dp[v][i][1]*dp[u][j][1]%mod*inv2%mod);\n\n                //1 2\n                add(tmp[i+j][1],dp[v][i][1]*dp[u][j][2]%mod);\n\n                //2 0\n                add(tmp[i+j][2],dp[v][i][2]*dp[u][j][0]%mod);\n\n                //2 1\n                add(tmp[i+j][2],dp[v][i][2]*dp[u][j][1]%mod);\n\n                //2 2\n                add(tmp[i+j][2],dp[v][i][2]*dp[u][j][2]%mod);\n            }\n        }\n\n        sz[v]+=sz[u];\n        rep(i,sz[v]+1)rep(j,3)dp[v][i][j]=tmp[i][j];\n    }\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=1;i<N;i++){\n        int b;cin>>b;\n        b--;\n        G[b].pb(i);\n    }\n\n    dfs(0);\n    int ans=0;\n    for(int i=1;i<=N;i++){\n        int ei=0;\n        rep(j,3)add(ei,dp[0][i][j]);\n        ei=ei*fact[i]%mod;\n\n        if((N-i)&1){\n            ans=(ans-ei+mod)%mod;\n        }\n        else{\n            ans=(ans+ei)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 2010;\nconst ll MOD = 1000000007;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\ninline ll qpow(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b & 1LL) res = res * a % MOD;\n\t\tb >>= 1, a = a * a % MOD;\n\t}\n\treturn res;\n}\n\nint e, st[MAXN], to[MAXN];\nint nxt[MAXN];\ninline void Add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint n, fa[MAXN], size[MAXN];\nll dp[MAXN][MAXN][3], inv2;\nll tmp[MAXN][3];\nll fac[MAXN], ans;\n\ninline void update(ll &cur, ll val) {\n\tcur = cur+val;\n\tif(cur >= MOD) cur -= MOD;\n}\n\nvoid dfs(int u) {\n\tint i, j, k;\n\tdp[u][1][0] = 1, size[u] = 1;\n\tfor(i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tdfs(v), size[u] += size[v];\n\t}\n\tif(size[u] == 1) return;\n\tfor(i = st[u]; i; i = nxt[i]) {\n\t\tfor(k = size[u]; k >= 1; k--) {\n\t\t\ttmp[k][0] = dp[u][k][0];\n\t\t\ttmp[k][1] = dp[u][k][1];\n\t\t\ttmp[k][2] = dp[u][k][2];\n\t\t\tdp[u][k][0] = dp[u][k][1] = dp[u][k][2] = 0;\n\t\t}\n\t\tint v = to[i];\n\t\tfor(k = size[u]; k >= 1; k--) {\n\t\t\tfor(j = min(size[v], size[u]-k+1); j >= 1; j--) {\n\t\t\t\tif(j+k-1 != size[u]) {\n\t\t\t\t\tupdate(dp[u][j+k][0], dp[v][j][0]*tmp[k][0]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][1], dp[v][j][0]*tmp[k][1]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][2], dp[v][j][0]*tmp[k][2]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][0], dp[v][j][1]*tmp[k][0]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][1], dp[v][j][1]*tmp[k][1]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][2], dp[v][j][1]*tmp[k][2]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][0], dp[v][j][2]*tmp[k][0]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][1], dp[v][j][2]*tmp[k][1]%MOD);\n\t\t\t\t\tupdate(dp[u][j+k][2], dp[v][j][2]*tmp[k][2]%MOD);\n\t\t\t\t}\n\t\t\t\tupdate(dp[u][j+k-1][2], dp[v][j][0]*tmp[k][1]%MOD);\n\t\t\t\tupdate(dp[u][j+k-1][2], dp[v][j][1]*tmp[k][1]%MOD*inv2%MOD);\n\t\t\t\tupdate(dp[u][j+k-1][1], dp[v][j][0]*tmp[k][0]%MOD*2%MOD);\n\t\t\t\tupdate(dp[u][j+k-1][1], dp[v][j][1]*tmp[k][0]%MOD);\n\t\t\t}\n\t\t}\n\t\t/*if(u == 1) {\n\t\t\tprintf(\":\");\n\t\t\tfor(k = 1; k <= size[u]; k++)\n\t\t\t\tprintf(\"(%lld,%lld,%lld) \", dp[u][k][0], dp[u][k][1], dp[u][k][2]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\t/*for(k = 1; k <= size[u]; k++)\n\t\tprintf(\"(%lld,%lld,%lld) \", dp[u][k][0], dp[u][k][1], dp[u][k][2]);\n\tprintf(\"\\n\");*/\n}\n\nint main() {\n\tint i;\n\n\tn = read();\n\tfor(i = 2; i <= n; i++) Add(read(), i);\n\n\tinv2 = qpow(2, MOD-2);\n\tdfs(1);\n\t//printf(\"%lld\\n\", dp[4][1][0]);\n\t//printf(\"%lld\\n\", dp[3][1][1]);\n\t//printf(\"%lld\\n\", dp[3][2][0]);\n\n\tfac[0] = 1;\n\tfor(i = 1; i <= n; i++) fac[i] = fac[i-1]*i%MOD;\n\tfor(i = 0; i < n; i++) {\n\t\tint f = i & 1 ? MOD-1 : 1;\n\t\tupdate(ans, f*fac[n-i]%MOD*((dp[1][n-i][0]+dp[1][n-i][1]+dp[1][n-i][2])%MOD)%MOD);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 16;\ntemplate <typename T, T mod = MOD<T>>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>>;\nusing mll = ModInt<ll, MOD<ll>>;\nusing Poly = std::vector<mll>;\nPoly operator*(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = d1 + d2;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d1; i++) {\n        for (int j = 0; j <= d2; j++) { ans[i + j] += p1[i] * p2[j]; }\n    }\n    return ans;\n}\nPoly operator*(const ll s, const Poly& p2)\n{\n    const int d = p2.size() - 1;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d; i++) { ans[i] = p2[i] * s; }\n    return ans;\n}\nPoly operator+(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = std::max(d1, d2);\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d1; i++) { ans[i] += p1[i]; }\n    for (int i = 0; i <= d2; i++) { ans[i] += p2[i]; }\n    return ans;\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\nint main()\n{\n    int N;\n    std::cin >> N;\n    std::vector<std::vector<int>> g(N);\n    for (int i = 1, p; i < N; i++) { std::cin >> p, g[p - 1].push_back(i); }\n    // vi以下のパス分割全体で、根viの次数がj, 連結成分数k\n    // 2^{連結成分数}/2^{孤立点数} の和\n    std::vector<std::vector<Poly>> dp(N, std::vector<std::vector<mll>>(3));\n    auto dfs = [&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) { self(self, to); }\n        Poly p0{1}, p1{0}, p2{0};\n        for (const int to : g[s]) {\n            const Poly z = dp[to][0] + dp[to][1] + dp[to][2];\n            const Poly o = 2 * dp[to][0] + dp[to][1];\n            auto p0_ = p0, p1_ = p1, p2_ = p2;\n            p0 = p0_ * z, p1 = p1_ * z + p0_ * o, p2 = p2_ * z + p1_ * o;\n        }\n        // show(s);\n        // show(p0), show(p1), show(p2);\n        dp[s][0] = p0 * Poly{0, 1};\n        dp[s][1] = p1;\n        for (int i = 1; i < p2.size(); i++) { p2[i - 1] = p2[i] * (MOD<ll> + 1) / 2; }\n        p2[p2.size() - 1] = 0;\n        dp[s][2] = p2;\n    };\n    dfs(dfs, 0);\n    //    show(dp);\n    mll p = 1, ans = 0;\n    const Poly f = dp[0][0] + dp[0][1] + dp[0][2];\n    for (int i = 0; i <= N; i++) {\n        ans += ((N - i) % 2 == 0 ? p * f[i] : (-p) * f[i]);\n        p *= (i + 1);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 12:32:46       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n, -1);\n  vector<vector<int>> g(n);\n  for (int i = 1; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n    g[p[i]].push_back(i);\n  }\n  vector<vector<vector<Mint>>> dp(n, vector<vector<Mint>>(3));\n  vector<int> sz(n, 1);\n  for (int i = n - 1; i >= 0; i--) {\n    vector<vector<Mint>> cur(3, vector<Mint>(1));\n    cur[0][0] = 1;\n    for (int j : g[i]) {\n      vector<vector<Mint>> aux(3, vector<Mint>(sz[i] + sz[j]));\n      for (int x = 0; x < sz[i]; x++) {\n        for (int y = 0; y < sz[j]; y++) {\n          for (int di = 0; di < 3; di++) {\n            for (int dj = 0; dj < 3; dj++) {\n              for (int tj = 0; tj < 2 && dj + tj < 3 && di + tj < 3; tj++) {\n                aux[di + tj][x + y + tj] += cur[di][x] * dp[j][dj][y] * (dj > 0 && tj == 0 ? 2 : 1);\n              }\n            }\n          }\n        }\n      }\n      swap(cur, aux);\n      sz[i] += sz[j];\n    }\n    dp[i] = cur;\n  }\n  vector<Mint> fact(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  Mint ans = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    Mint cur = dp[0][0][i] + dp[0][1][i] * 2 + dp[0][2][i] * 2;\n    ans += cur * fact[n - i] * (i % 2 == 0 ? 1 : -1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nvector<int> ch[2020];\n\ni64 modpow(i64 a, int p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 ret = modpow(a, p / 2);\n\tret = ret * ret % MOD;\n\n\tif (p % 2 == 1) ret = ret * a % MOD;\n\treturn ret;\n}\n\ni64 fact[2020], facti[2020];\n\nvector<vector<i64>> join(vector<vector<i64>> &data, vector<i64> &ext0, vector<i64> &ext1)\n{\n\tvector<vector<i64>> ret(3, vector<i64>(data[0].size() + ext0.size() - 1, 0LL));\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < data[0].size(); ++j) {\n\t\t\tfor (int k = 0; k < ext0.size(); ++k) {\n\t\t\t\tADD(ret[i][j + k], data[i][j] * ext0[k]);\n\n\t\t\t\tif (i == 0) ADD(ret[i + 1][j + k], data[i][j] * ext1[k]);\n\t\t\t\telse if (i == 1) ADD(ret[i + 1][j + k], data[i][j] * ext1[k]  % MOD * facti[2]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<vector<i64>> solve(int p)\n{\n\tvector<vector<i64>> ret(3, vector<i64>());\n\tret[0].push_back(1LL);\n\tret[1].push_back(0LL);\n\tret[2].push_back(0LL);\n\tfor (int q : ch[p]) {\n\t\tauto ans = solve(q);\n\n\t\t// extend\n\t\tvector<i64> ext0(ans[0].size() + 1, 0LL), ext1(ans[0].size() + 1, 0LL);\n\t\tfor (int i = 0; i < ans[0].size(); ++i) {\n\t\t\tADD(ext0[i], ans[0][i]);\n\t\t\tADD(ext0[i], ans[1][i]);\n\t\t\tADD(ext0[i], ans[2][i]);\n\t\t\tADD(ext1[i + 1], ans[0][i] * 2);\n\t\t\tADD(ext1[i + 1], ans[1][i]);\n\t\t\t// ADD(ext1[i], ans[2][i]);\n\t\t}\n\t\tret = join(ret, ext0, ext1);\n\t}\n\t/*\n\tprintf(\"%d\\n\", p);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < ret[0].size(); ++j) printf(\"%lld \", ret[i][j]);\n\t\tputs(\"\");\n\t}\n\tputs(\"---\");\n\t*/\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfact[0] = facti[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfacti[i] = modpow(fact[i]);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\t--p;\n\t\tch[p].push_back(i);\n\t}\n\n\tauto ans = solve(0);\n\n\ti64 ret = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\ti64 val = 0;\n\t\tADD(val, ans[0][i]);\n\t\tADD(val, ans[1][i]);\n\t\tADD(val, ans[2][i]);\n\n\t\tif (i % 2 == 1) val = MOD - val % MOD;\n\t\tADD(ret, val * fact[N - i]);\n\t}\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#//Code by 27.\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\n#include<fstream>\n#include<stdlib.h>\n#include<set>\n#include<climits>\n#include<cmath> \n#include<memory.h> \n#include<sstream>\n#include<time.h>\nusing namespace std;\nconst long long BIGER=1000000000000000;\nconst int BIG=1000000000;\nconst int MOD=1000000007;\nint n;\nint b[10001];\nbool f[2005][2005];\nbool used[2005];\nint a[10001];\nint g=0;\nint ypa(int k)\n{\n\tif(k==n+1)\n\t{\n\t\t//for(int i=1;i<=n;i++)printf(\"%d \",a[i]);\n\t\t//puts(\"\");\n\t\tg++;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(f[a[k-1]][i]!=1&&used[i]!=1)\n\t\t{\n\t\t\tused[i]=1;\n\t\t\ta[k]=i;\n\t\t\typa(k+1);\n\t\t\tused[i]=0;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tcin>>b[i];\n\t\tf[b[i]][i]=1;\n\t\tf[i][b[i]]=1;\n\t}\n\typa(1);\n\tcout<<g;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nconst int mod = 1e9 + 7;\n\nint n;\nvector <int> G[N];\nint dp[N][N][3];\nint f[N][3];\nint nchild[N];\n\nvoid add(int &x, int y) {\n\tx += y; while(x >= y) x -= mod; while(x < 0) x += mod;\n}\n\nvoid dfs(int u) {\n\tdp[u][0][0] = 1;\n\n\tfor (int &v : G[u]) {\n\t\tdfs(v);\n\t\tmemset(f, 0, sizeof f);\n\n\t\tfor (int ncut_u = 0; ncut_u <= nchild[u]; ++ncut_u) {\n\t\t\tfor (int deg_u = 0; deg_u <= 2; ++deg_u) {\n\t\t\t\tfor (int ncut_v = 0; ncut_v <= nchild[v]; ++ncut_v) {\n\t\t\t\t\tfor (int deg_v = 0; deg_v <= 2; ++deg_v) {\n\t\t\t\t\t\tif (!dp[u][ncut_u][deg_u] || !dp[v][ncut_v][deg_v]) continue;\n\n\t\t\t\t\t\tint mul = 1LL * dp[u][ncut_u][deg_u] * dp[v][ncut_v][deg_v] % mod;\n\n\t\t\t\t\t\t// cut\n\t\t\t\t\t\tadd(f[ncut_u + ncut_v + 1][deg_u], (deg_v == 1 ? 2LL : 1LL) * mul % mod);\n\n\t\t\t\t\t\t// concatenate\n\t\t\t\t\t\tif (deg_u <= 1 && deg_v <= 1) {\n\t\t\t\t\t\t\tadd(f[ncut_u + ncut_v][deg_u + 1], mul);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnchild[u] += nchild[v];\n\t\tfor (int ncut_u = 0; ncut_u <= nchild[u]; ++ncut_u) {\n\t\t\tfor (int deg_u = 0; deg_u <= 2; ++deg_u) {\n\t\t\t\tdp[u][ncut_u][deg_u] = f[ncut_u][deg_u]; // update the values of dp[]\n\t\t\t}\n\t\t}\n\t}\n\n\t++nchild[u];\n\tfor (int ncut_u = 0; ncut_u < nchild[u]; ++ncut_u) {\n\t\tfor (int deg_u = 0; deg_u <= 2; ++deg_u) {\n\t\t\tif (deg_u == 2) {\n\t\t\t\tadd(dp[u][ncut_u][deg_u], dp[u][ncut_u][deg_u]); // x 2\n\t\t\t}\n\t\t\tif (u == 1 && deg_u == 1) {\n\t\t\t\tadd(dp[u][ncut_u][deg_u], dp[u][ncut_u][deg_u]); // x 2\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint p; cin >> p; G[p].push_back(i);\n\t}\n\n\tdfs(1);\n\n\tint fact = 1;\n\tint res = 0;\n\tfor (int ncut = 0; ncut <= n - 1; ++ncut) {\n\t\tint npair = n - 1 - ncut;\n\t\tint cur = 0;\n\t\tfor (int deg = 0; deg <= 2; ++deg) add(cur, dp[1][ncut][deg]);\n\n\t\tfact = 1LL * fact * (ncut + 1) % mod; // (ncut + 1)!\n\t\tcur = 1LL * cur * fact % mod;\n\n\t\tif (npair % 2 == 0) add(res, cur); else add(res, -cur);\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nvector<int> g[2100];\nint sz[2100];\nlong long dp[2][2100];\nlong long dp2[3][2100][2100];\nlong long fact[3100];\nvoid solve(int a){\n\tint n=g[a].size();\n\tdp2[0][0][0]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tsolve(g[a][i]);\n\t\tint T=sz[a];\n\t\tsz[a]+=sz[g[a][i]];\n\t\tfor(int j=0;j<=sz[a];j++){\n\t\t\tdp2[0][i+1][j]=dp2[1][i+1][j]=dp2[2][i+1][j]=0;\n\t\t}\n\t\tfor(int j=0;j<=T;j++){\n\t\t\tfor(int k=0;k<=sz[g[a][i]];k++){\n\t\t\t\tdp2[0][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[0][i][j]*dp[0][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[0][i][j]*dp[1][k])%mod;\n\t\t\t\tdp2[1][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[1][i][j]*dp[0][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[1][i][j]*dp[1][k])%mod;\n\t\t\t\tdp2[2][i+1][j+k]=(dp2[0][i+1][j+k]+dp2[2][i][j]*dp[0][k])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=sz[g[a][i]];i++){\n\t\tdp[0][i]=(dp2[0][n][i]+dp2[1][n][i]*2+dp2[2][n][i])%mod;\n\t\tdp[1][i+1]=dp2[1][n][i]%mod;\n\t}\n\tsz[a]++;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p;scanf(\"%d\",&p);\n\t\tp--;\n\t\tg[p].push_back(i+1);\n\t}\n\tsolve(0);\n\tlong long ret=0;\n\tfact[0]=1;\n\tfor(int i=1;i<3100;i++)fact[i]=fact[i-1]*i%mod;\n\n\tfor(int i=0;i<=a;i++){\n\t\tif(i%2==0)ret=(ret+dp[0][i]*fact[a-i]%mod)%mod;\n\t\telse ret=(ret+mod-dp[0][i]*fact[a-i]%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<lint, lint> pi;\nconst int MAXN = 2005, N = MAXN;\nconst int mod = 1e9 + 7, inv2 = (mod + 1) / 2;\nint dp[MAXN][3][MAXN], odp[3][MAXN], sz[MAXN];\nvector<int> adj[N];\nvoid sadd(int &x, int y) {\n\tx += y;\n\twhile (x >= mod) x -= mod;\n}\nvoid dfs(int v, int p = -1) {\n\tdp[v][0][1] = 1;\n\tsz[v] = 1;\n\tfor (int u : adj[v]) {\n\t\tif (u != p) {\n\t\t\tdfs(u, v);\n\t\t\tmemcpy(odp, dp[v], sizeof dp[v]);\n\t\t\tmemset(dp[v], 0, sizeof dp[v]);\n\t\t\tfor (int dv = 0; dv <= 2; ++dv) {\n\t\t\t\tfor (int du = 0; du <= 2; ++du) {\n\t\t\t\t\tfor (int use = 0; use <= 1; ++use) {\n\t\t\t\t\t\tif (use == 1 && (du > 1 || dv > 1)) continue;\n\t\t\t\t\t\tfor (int cv = 1; cv <= sz[v]; ++cv)\n\t\t\t\t\t\t\tfor (int cu = 1; cu <= sz[u]; ++cu) {\n\t\t\t\t\t\t\t\tint ways = (use == 1 ? mod - 1 : 1);\n\t\t\t\t\t\t\t\tif (use) {\n\t\t\t\t\t\t\t\t\tif (du == 0 && dv == 0) \n\t\t\t\t\t\t\t\t\t\tways = (long long) ways * 2 % mod;\n\t\t\t\t\t\t\t\t\tif (du == 1 && dv == 1)\n\t\t\t\t\t\t\t\t\t\tways = (long long) ways * inv2 % mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsadd(dp[v][dv + use][cv + cu - use], \n\t\t\t\t\t\t\t\t\t\todp[dv][cv] * (long long) dp[u][du][cu] % mod * ways % mod);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[v] += sz[u];\n\t\t}\n\t}\n\t\n}\nint f[N];\nint main(){\n\tf[0] =1 ;\n\tfor (int j = 1; j < N; ++j) f[j] = (long long) f[j - 1] * j % mod;\n\tint n;\n\tcin >> n;\n\tfor (int j = 1; j < n; ++j) {\n\t\tint p;\n\t\tcin >> p;\n\t\tadj[--p].push_back(j);\n\t}\n\tdfs(0);\n\tint res = 0;\n\tfor (int j = 0; j < N; ++j)\n\n\t\tfor (int d = 0; d <= 2; ++d) if (dp[0][d][j]) {\n\t\t\tsadd(res, dp[0][d][j] * (long long) f[j] % mod);\n\t\t//\tcout << \" hi \" << d << ' ' << j << ' ' << dp[0][d][j] << endl;\n\t\t}\n\tcout << res << endl;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nvector<int> G[MAX_N];\n// i:隣の空きが 0, 1, 2\nint dp[MAX_N][MAX_N][3][2];\nint st[MAX_N];\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nint comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nvoid dfs(int u)\n{\n    st[u] = 1;\n    dp[u][1][2][0] = 1;\n    each(v,G[u]){\n        dfs(v);\n        for(int i = st[u]; i >= 1; i--){\n            for(int j = st[v]; j >= 1; j--){\n                dp[u][i+j][2][1] = add(dp[u][i+j][2][1], mul(dp[u][i][2][0], (ll)(dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j][1][1] = add(dp[u][i+j][1][1], mul(dp[u][i][1][0], (ll)(dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j][0][1] = add(dp[u][i+j][0][1], mul(dp[u][i][0][0], (ll)(dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j-1][1][1] = add(dp[u][i+j-1][1][1], mul(mul(dp[u][i][2][0], dp[v][j][2][0]), 2));\n                dp[u][i+j-1][1][1] = add(dp[u][i+j-1][1][1], mul(dp[u][i][2][0], dp[v][j][1][0]));\n                dp[u][i+j-1][0][1] = add(dp[u][i+j-1][0][1], mul(dp[u][i][1][0], dp[v][j][2][0]));\n                dp[u][i+j-1][0][1] = add(dp[u][i+j-1][0][1], mul(mul(dp[u][i][1][0], dp[v][j][1][0]), inv[2]));\n            }\n        }\n        st[u] += st[v];\n        rep(i,st[u]+1){\n            rep(j,3){\n                dp[u][i][j][0] = dp[u][i][j][1];\n                dp[u][i][j][1] = 0;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int p;\n        cin >> p;\n        G[p-1].pb(i+1);\n    }\n    make();\n    dfs(0);\n    int ans = 0;\n    srep(i,1,n+1){\n        if((n-i)%2){\n            ans = sub(ans, mul((ll)(dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) % MOD, fac[i]));\n        }else{\n            ans = add(ans, mul((ll)(dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) % MOD, fac[i]));\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nvector<int> G[MAX_N];\n// i:隣の空きが 0, 1, 2\nint dp[MAX_N][MAX_N][3][2];\nint st[MAX_N], fac[MAX_N], inv2;\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t}\n}\n\ninline int mod_pow(int a, ll b)\n{\n    int res = 1;\n    while(b){\n        if(b & 1){\n            res = (ll)res * a % MOD;\n        }\n        a = (ll)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\ninline int add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nvoid dfs(int u)\n{\n    st[u] = 1;\n    dp[u][1][2][0] = 1;\n    each(v,G[u]){\n        dfs(v);\n        for(int i = st[u]; i >= 1; i--){\n            for(int j = st[v]; j >= 1; j--){\n                dp[u][i+j][2][1] = add(dp[u][i+j][2][1], mul(dp[u][i][2][0], ((ll)dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j][1][1] = add(dp[u][i+j][1][1], mul(dp[u][i][1][0], ((ll)dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j][0][1] = add(dp[u][i+j][0][1], mul(dp[u][i][0][0], ((ll)dp[v][j][0][0] + dp[v][j][1][0] + dp[v][j][2][0])%MOD));\n                dp[u][i+j-1][1][1] = add(dp[u][i+j-1][1][1], mul(mul(dp[u][i][2][0], dp[v][j][2][0]), 2));\n                dp[u][i+j-1][1][1] = add(dp[u][i+j-1][1][1], mul(dp[u][i][2][0], dp[v][j][1][0]));\n                dp[u][i+j-1][0][1] = add(dp[u][i+j-1][0][1], mul(dp[u][i][1][0], dp[v][j][2][0]));\n                dp[u][i+j-1][0][1] = add(dp[u][i+j-1][0][1], mul(mul(dp[u][i][1][0], dp[v][j][1][0]), inv2));\n            }\n        }\n        st[u] += st[v];\n        srep(i,1,st[u]+1){\n            rep(j,3){\n                dp[u][i][j][0] = dp[u][i][j][1];\n                dp[u][i][j][1] = 0;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int p;\n        cin >> p;\n        G[p-1].pb(i+1);\n    }\n    make();\n    inv2 = mod_pow(2, MOD-2);\n    dfs(0);\n    int ans = 0;\n    srep(i,1,n+1){\n        if((n-i)%2){\n            ans = sub(ans, mul(((ll)dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) % MOD, fac[i]));\n        }else{\n            ans = add(ans, mul(((ll)dp[0][i][0][0] + dp[0][i][1][0] + dp[0][i][2][0]) % MOD, fac[i]));\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvvi g;\nvl F;\nvvl DP,dp[3];\n\nint dfs(int v){\n\tint S=1;\n\tdp[0][v][0]++;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tint T=dfs(u);\n\t\tS+=T;\n\t\tvl a[3];\n\t\ta[0]=a[1]=a[2]=vl(n);\n\t\ta[0][0]++;\n\t\tif(!i){\n\t\t\ta[0]=DP[u];\n\t\t\tfor(int j=1;j<S;j++) a[1][j]=(dp[0][u][j-1]*2+dp[1][u][j-1])%mod;\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++) for(int k=1;k<S;k++) for(int l=max(0,k-T);l<=k;l++){\n\t\t\t\t(a[j][k]+=dp[j][v][l]*DP[u][k-l])%=mod;\n\t\t\t\tif(j&&l<k) (a[j][k]+=dp[j-1][v][l]*(dp[0][u][k-l-1]*(3-j)+dp[1][u][k-l-1]*(j==1?1:mod/2+1)%mod))%=mod;\n\t\t\t}\n\t\t}\n\t\tdp[0][v]=a[0];\n\t\tdp[1][v]=a[1];\n\t\tdp[2][v]=a[2];\n\t}\n\tfor(int i=0;i<3;i++) for(int j=0;j<S;j++) (DP[v][j]+=dp[i][v][j])%=mod;\n\treturn S;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tF=vl(n+1,1);\n\tDP=dp[0]=dp[1]=dp[2]=vvl(n,vl(n));\n\tfor(int i=1;i<n;i++){\n\t\tint v;\n\t\tcin>>v;\n\t\tg[v-1].push_back(i);\n\t}\n\tdfs(0);\n\tll res=0;\n\tfor(int i=1;i<=n;i++) F[i]=F[i-1]*i%mod;\n\tfor(int i=0;i<n;i++){\n\t\tll tmp=F[n-i]*DP[0][i]%mod;\n\t\tif(i%2==1) tmp=(mod-tmp)%mod;\n\t\t(res+=tmp)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\nconst int N=2010;\nconst int mod=1000000007;\nconst int inv2=(mod+1)/2;\n\nvi e[2010];\n\nint dp[2010][2010][3],size[2010];\nint fac[2010],pow2[2010];\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nvoid dfs(int k)\n{\n\tdp[k][1][0]=1;size[k]=1;\n\tfor (vi::iterator p=e[k].begin();p!=e[k].end();p++)\n\t{\n\t\tdfs(*p);\n\t\tfor (int j=size[k];j;j--)\n\t\t\tfor (int x=2;x>=0;x--)\n\t\t\t{\n\t\t\t\tfor (int l=1;l<=size[*p];l++)\n\t\t\t\t{\n\t\t\t\t\tif (x<2)\n\t\t\t\t\t\tfor (int y=0;y<2;y++)\n\t\t\t\t\t\t\tdp[k][j+l-1][x+1]=(ll(dp[k][j][x])*dp[*p][l][y]+dp[k][j+l-1][x+1])%mod;\n\t\t\t\t\tfor (int y=0;y<=2;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[k][j+l][x]=(ll(dp[k][j][x])*dp[*p][l][y]%mod*(y==0 ? inv2 : 1)+dp[k][j+l][x])%mod;\n\t\t\t\t\t\t\t//if (k==2) printf(\"%d %d %d %d %d\\n\",dp[2][2][0],j,x,l,y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[k][j][x]=0;\n\t\t\t}\n\t\tsize[k]+=size[*p];\n\t}\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tint x;scanf(\"%d\",&x);e[x].pb(i);\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdfs(1);\n\tfac[0]=1;for (int i=1;i<=n;i++) fac[i]=ll(fac[i-1])*i%mod;\n\tpow2[0]=1;for (int i=1;i<=n;i++) pow2[i]=pow2[i-1]*2%mod;\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=2;j++)\n\t\t{\n\t\t\tint t=ll(fac[i])*pow2[i]%mod*dp[1][i][j]%mod*(j==0 ? inv2 : 1)%mod;\n\t\t\tif ((n-i)&1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define P 1000000007\n#define N 2010\nint n;\nint a[N];\nvector<int> A[N];\nint f[N][N][3];\nint g[N][3];\nint s[N];\n\nvoid ff(int x) {\n\ts[x] ++;\n\tf[x][0][0] = 1;\n\tfor (vector<int>::iterator i = A[x].begin(); i != A[x].end(); i ++) {\n\t\tff(*i);\n\t\tfor (int j = 0; j < s[x]; j ++)\n\t\t\tfor (int jj = 0; jj < 3; jj ++) {\n\t\t\t\tg[j][jj] = f[x][j][jj];\n\t\t\t\tf[x][j][jj] = 0;\n\t\t\t}\n\t\t\n\t\tfor (int j = 0; j < s[x]; j ++)\n\t\t\tfor (int jj = 0; jj < 3; jj ++)\n\t\t\t\tfor (int k = 0; k < s[*i]; k ++)\n\t\t\t\t\tfor (int kk = 0; kk < 3; kk ++) {\n\t\t\t\t\t\t// no delete\n\t\t\t\t\t\tint s = (ll)g[j][jj]*f[*i][k][kk]%P;\n\t\t\t\t\t\tint pp = jj;\n\t\t\t\t\t\tif (kk == 1) s = s*2%P;\n\t\t\t\t\t\t(f[x][j+k][pp] += s) %= P;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// delete\n\t\t\t\t\t\tif (jj == 2 || kk == 2) continue;\n\t\t\t\t\t\ts = (ll)g[j][jj]*f[*i][k][kk]%P;\n\t\t\t\t\t\tif (jj && kk) {s = s*2%P; pp = 2;}\n\t\t\t\t\t\tif (jj && !kk) {s = s*2%P; pp = 2;}\n\t\t\t\t\t\tif (!jj && kk) {pp = 1;}\n\t\t\t\t\t\tif (!jj && !kk) {pp = 1;}\n\t\t\t\t\t\t(f[x][j+k+1][pp] += s) %= P;\n\t\t\t\t\t}\n\t\ts[x] += s[*i];\n\t}\n}\n\nint F[N];\n\nint main() {\n\tF[0] = 1;\n\tfor (int i = 1; i < N; i ++) F[i] = (ll)F[i-1]*i%P;\n\tcin >> n;\n\ta[0] = -1;\n\tfor (int i = 1; i < n; i ++) {\n\t\tcin >> a[i];\n\t\ta[i] --;\n\t\tA[a[i]].pb(i);\n\t}\n\tmemset(f, 0, sizeof f);\n\tff(0);\n\tint S = 0;\n\tfor (int i = 0; i < s[0]; i ++)\n\t\tfor (int ii = 0; ii < 3; ii ++) {\n\t\t\tint s = f[0][i][ii];\n\t\t\tif (ii == 1) s = s*2%P;\n\t\t\tif (i%2) s = (P-s)%P;\n\t\t\ts = (ll)s*F[n-i]%P;\n\t\t\tS = (S+s)%P;\n\t\t}\n\tcout << S << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvvi g;\nvl F;\nvvl DP,dp[3];\n\nint dfs(int v){\n\tint S=1;\n\tdp[0][v][0]++;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tS+=dfs(u);\n\t\tvl a[3];\n\t\ta[0]=a[1]=a[2]=vl(n);\n\t\ta[0][0]++;\n\t\tif(!i){\n\t\t\ta[0]=DP[u];\n\t\t\tfor(int j=1;j<S;j++) a[1][j]=(dp[0][u][j-1]*2+dp[1][u][j-1])%mod;\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++) for(int k=1;k<S;k++) for(int l=0;l<=k;l++){\n\t\t\t\t(a[j][k]+=dp[j][v][l]*DP[u][k-l])%=mod;\n\t\t\t\tif(j&&l<k) (a[j][k]+=dp[j-1][v][l]*(dp[0][u][k-l-1]*(3-j)+dp[1][u][k-l-1]*(j==1?1:mod/2+1)%mod))%=mod;\n\t\t\t}\n\t\t}\n\t\tdp[0][v]=a[0];\n\t\tdp[1][v]=a[1];\n\t\tdp[2][v]=a[2];\n\t}\n\tfor(int i=0;i<3;i++) for(int j=0;j<S;j++) (DP[v][j]+=dp[i][v][j])%=mod;\n\treturn S;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tF=vl(n+1,1);\n\tDP=dp[0]=dp[1]=dp[2]=vvl(n,vl(n));\n\tfor(int i=1;i<n;i++){\n\t\tint v;\n\t\tcin>>v;\n\t\tg[v-1].push_back(i);\n\t}\n\tdfs(0);\n\tll res=0;\n\tfor(int i=1;i<=n;i++) F[i]=F[i-1]*i%mod;\n\tfor(int i=0;i<n;i++){\n\t\tll tmp=F[n-i]*DP[0][i]%mod;\n\t\tif(i%2==1) tmp=(mod-tmp)%mod;\n\t\t(res+=tmp)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int N = 2000;\nconst int MOD = (int)1e9 + 7;\n\nint n, fact[N + 1], size[N], dp[N][3][N];\nstd::vector<int> children[N];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nvoid dfs(int u)\n{\n    static int tmp[3][N];\n\n    size[u] = 1;\n    dp[u][0][0] = 1;\n    for (auto v : children[u]) {\n        dfs(v);\n        int ns = size[u] + size[v];\n        for (int t = 0; t < 3; ++ t) {\n            memset(tmp[t], 0, sizeof(int) * ns);\n        }\n        for (int t = 0; t < 3; ++ t) {\n            for (int x = 0; x < size[u]; ++ x) {\n                if (!dp[u][t][x]) {\n                    continue;\n                }\n                for (int y = 0; y < size[v]; ++ y) {\n                    for (int tt = 0; tt < 3; ++ tt) {\n                        if (!dp[v][tt][y]) {\n                            continue;\n                        }\n                        auto pd = 1LL * dp[u][t][x] * dp[v][tt][y] % MOD;\n                        if (t < 2 && tt < 2) {\n                            update(tmp[t + 1][x + y + 1], pd);\n                        }\n                        if (tt == 0) {\n                            pd = 500000004LL * pd % MOD;\n                        }\n                        update(tmp[t][x + y], pd);\n                    }\n                }\n            }\n        }\n        for (int t = 0; t < 3; ++ t) {\n            memcpy(dp[u][t], tmp[t], sizeof(int) * ns);\n        }\n        size[u] += size[v];\n    }\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"A.in\", \"r\", stdin);\n#endif\n    scanf(\"%d\", &n);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++ i) {\n        fact[i] = 2LL * fact[i - 1] * i % MOD;\n    }\n    for (int i = 1, p; i < n; ++ i) {\n        scanf(\"%d\", &p);\n        children[p - 1].push_back(i);\n    }\n    memset(dp, 0, sizeof(dp));\n    dfs(0);\n    int result = 0;\n    for (int i = 0; i < n; ++ i) {\n        int add = 1LL * fact[n - i] * (500000004LL * dp[0][0][i] % MOD + dp[0][1][i] + dp[0][2][i]) % MOD;\n        if (i & 1) {\n            add = MOD - add;\n        }\n        update(result, add);\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nconst ll INF = LLONG_MAX / 2;\nconst int MOD = 1e9 + 7;\n\nint N;\nll sz[2010], dp[2010][2010][2];\nvector<int> G[2010];\n\nvoid dfs_sz(int u) {\n\tsz[u] = 1;\n\tfor (int v: G[u]) dfs_sz(v), sz[u] += sz[v];\n}\n\nvoid dfs(int u) {\n\tint n = 1;\n\tvector<vector<int> > a(n + 1, vector<int>(3));\n\ta[0][0] = 1;\n\tfor (int v: G[u]) {\n\t\tdfs(v);\n\t\tvector<vector<int> > _a(n + sz[v] + 1, vector<int>(3));\n\t\trep(x, n + 1) rep(y, 3) if (a[x][y])\n\t\t\trep(dx, sz[v] + 1) rep(dy, 2) if (dp[v][dx][dy]) {\n\t\t\t\tint _x = x + dx, _y = y + dy;\n\t\t\t\tif (_x > n + sz[v]) continue;\n\t\t\t\tif (_y > 2) continue;\n\t\t\t\t_a[_x][_y] = (_a[_x][_y] + (ll)a[x][y] * dp[v][dx][dy]) % MOD;\n\t\t\t}\n\t\ta = _a;\n\t\tn += sz[v];\n\t}\n\trep(x, n + 1) {\n\t\tdp[u][x][0] = (dp[u][x][0] + a[x][0]) % MOD;\n\t\tdp[u][x + 1][1] = (dp[u][x + 1][1] - a[x][0]) % MOD;\n\t\tdp[u][x][0] = (dp[u][x][0] + a[x][1] * 2) % MOD;\n\t\tdp[u][x + 1][1] = (dp[u][x + 1][1] - a[x][1]) % MOD;\n\t\tdp[u][x][0] = (dp[u][x][0] + a[x][2] * 2) % MOD;\n\t}\n}\n\nll F[2010];\n\nint main() {\n\tF[0] = 1;\n\trep(x, 2001) F[x + 1] = F[x] * (x + 1) % MOD;\n\tcin >> N;\n\tfor (int u = 1; u < N; u++) {\n\t\tint p; cin >> p, p--;\n\t\tG[p].pb(u);\n\t}\n\tdfs_sz(0), dfs(0);\n\t/*\n\trep(u, N) {\n\t\trep(x, N + 1) cout << u << ' ' << x << ' ' << dp[u][x][0] << endl;\n\t}\n\trep(x, N + 1) cout << x << ' ' << dp[0][x][0] << endl;\n\t*/\n\tint ans = 0;\n\trep(x, N + 1) {\n\t\tans = (ans + (ll)dp[0][x][0] * F[N - x]) % MOD;\n\t}\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vector<int> &v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 2050;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nusing dp = vector<vector<modint>>;\n\ndp merge(dp &a, dp &b) {\n\tint l1 = a.size();\n\tint l2 = b.size();\n\tdp res(l1 + l2 - 1);\n\trep(i, l1 + l2 - 1)res[i].resize(3, 0);\n\trep1(i, l1-1)rep1(j, l2-1) {\n\t\trep(k, 3)rep(l, 3) {\n\t\t\t//don't connect\n\t\t\tres[i + j][k] += a[i][k]*b[j][l];\n\t\t\t//connect\n\t\t\tif (k<2&&l<2) {\n\t\t\t\tmodint z = 1;\n\t\t\t\tif (k == 0 && l == 0)z = 2;\n\t\t\t\tif (k > 0 && l > 0)z = z / (modint)2;\n\t\t\t\tres[i + j-1][k +1] += z*a[i][k] * b[j][l];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> G[2000];\n\ndp dfs(int id, int fr) {\n\tdp res(2,vector<modint>(3,0));\n\tres[1][0] = 1;\n\tfor (int to : G[id]) {\n\t\tif (to == fr)continue;\n\t\tdp nex = dfs(to, id);\n\t\tres = merge(res, nex);\n\t}\n\t/*cout << \"hello \" << id << endl;\n\trep1(i, res.size() - 1) {\n\t\trep(j, 3) {\n\t\t\tcout << i << \" \" << j << \" \" << res[i][j] << endl;\n\t\t}\n\t}*/\n\treturn res;\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n-1) {\n\t\tint p; cin >> p; p--;\n\t\tG[p].push_back(i);\n\t}\n\tdp res = dfs(0, -1);\n\tmodint ans = 0;\n\trep1(i, (int)res.size()-1) {\n\t\trep(j, 3) {\n\t\t\t//cout << i << \" \" << j << \" \" << res[i][j] << endl;\n\t\t\tmodint s = res[i][j] * fact[i];\n\t\t\tif ((n - i) % 2)s = -s;\n\t\t\tans += s;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\tinit_f(); //init();\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\t//while(cin>>w>>h,w)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 16;\ntemplate <typename T, T mod = MOD<T>>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>>;\nusing mll = ModInt<ll, MOD<ll>>;\nusing Poly = std::vector<mll>;\nPoly operator*(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = d1 + d2;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d1; i++) {\n        for (int j = 0; j <= d2; j++) { ans[i + j] += p1[i] * p2[j]; }\n    }\n    return ans;\n}\nPoly operator*(const ll s, const Poly& p2)\n{\n    const int d = p2.size() - 1;\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d; i++) { ans[i] = p2[i] * d; }\n    return ans;\n}\nPoly operator+(const Poly& p1, const Poly& p2)\n{\n    const int d1 = p1.size() - 1, d2 = p2.size() - 1, d = std::max(d1, d2);\n    Poly ans(d + 1, 0);\n    for (int i = 0; i <= d1; i++) { ans[i] += p1[i]; }\n    for (int i = 0; i <= d2; i++) { ans[i] += p2[i]; }\n    return ans;\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\nint main()\n{\n    int N;\n    std::cin >> N;\n    std::vector<std::vector<int>> g(N);\n    for (int i = 1, p; i < N; i++) { std::cin >> p, g[p - 1].push_back(i); }\n    // vi以下のパス分割全体で、根viの次数がj, 連結成分数k\n    // 2^{連結成分数}/2^{孤立点数} の和\n    std::vector<std::vector<Poly>> dp(N, std::vector<std::vector<mll>>(3));\n    auto dfs = [&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) { self(self, to); }\n        Poly p0{1}, p1{0}, p2{0};\n        for (const int to : g[s]) {\n            const Poly z = dp[to][0] + dp[to][1] + dp[to][2];\n            const Poly o = 2 * dp[to][0] + dp[to][1];\n            auto p0_ = p0.p1_ = p1, p2_ = p2;\n            p0 = p0_ * z;\n            p1 = p1_ * z + p0_ * o;\n            p2 = p2_ * z + p1_ * o;\n        }\n        dp[s][0] = p0 * Poly{0, 1};\n        dp[s][1] = p1;\n        for (int i = 1; i < p2.size(); i++) { p2[i - 1] = p2[i] * (MOD<ll> + 1) / 2; }\n        p2[p2.size() - 1] = 0;\n        dp[s][2] = p2;\n    };\n    dfs(dfs, 0);\n    //    show(dp);\n    mll p = 1, ans = 0;\n    const Poly f = dp[0][0] + dp[0][1] + dp[0][2];\n    for (int i = 0; i <= N; i++) {\n        ans += (i % 2 == 0 ? p * f[i] : (-p) * f[i]);\n        p *= (i + 1);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = (int) 1e9 + 7;\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\nvoid ssub(int &a, int b)\n{\n    a -= b;\n    if (a < 0) a += MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint sub(int a, int b)\n{\n    ssub(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\nint fpow(int x, int n)\n{\n    if (n == 0) return 1;\n    int a = fpow(x, n >> 1);\n    a = mul(a, a);\n    if (n & 1) a = mul(a, x);\n    return a;\n}\nint rev(int x)\n{\n    return fpow(x, MOD - 2);\n}\n\nint rev2;\nint divi2(int a)\n{\n    return mul(a, rev2);\n}\n\nconst int N = 2005;\nvector <int> ch[N];\nint _C[N][N];\nint fact[N];\n\nint C(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    return _C[n][k];\n}\n\nstruct Ans\n{\n    vector <int> dp, dpEnd, dpOnly;\n\n    Ans() : dp({0, 0}), dpEnd({0, 0}), dpOnly({0, 1}) {}\n\n    Ans operator + (const Ans &A) const // root from this\n    {\n        Ans ans;\n        ans.dpOnly[1] = 0;\n        ans.dp.resize((int) dp.size() + (int) A.dp.size() - 1, 0);\n        ans.dpEnd.resize((int) dpEnd.size() + (int) A.dpEnd.size() - 1, 0);\n        ans.dpOnly.resize((int) dpOnly.size() + (int) A.dpOnly.size() - 1, 0);\n\n        for (int i = 1; i < (int) dp.size(); i++)\n            for (int j = 1; j < (int) A.dp.size(); j++)\n            {\n                int ox = dp[i], oEnd = dpEnd[i], oOnly = dpOnly[i], ax = A.dp[j], aEnd = A.dpEnd[j], aOnly = A.dpOnly[j];\n                int aAll = add(ax, add(aEnd, aOnly) );\n                                \n                sadd(ans.dp[i + j], mul(ox, aAll) );\n                sadd(ans.dpEnd[i + j], mul(oEnd, aAll) );\n                sadd(ans.dpOnly[i + j], mul(oOnly, aAll) );\n\n                sadd(ans.dp[i + j - 1], mul(oEnd, divi2(aEnd) ) );\n                sadd(ans.dpEnd[i + j - 1], mul(oOnly, mul(2, aOnly) ) );\n                sadd(ans.dpEnd[i + j - 1], mul(oOnly, aEnd) );\n                sadd(ans.dp[i + j - 1], mul(oEnd, aOnly) );\n            }\n        return ans;\n    }\n\n    int pvi()\n    {\n        int ans = 0;\n        for (int i = 1; i < (int) dp.size(); i++)\n        {\n            int cur = dp[i] + dpEnd[i] + dpOnly[i];\n            cur = mul(cur, fact[i] );\n            if ( ( (int) dp.size() - i) % 2) \n                sadd(ans, cur);\n            else ssub(ans, cur);\n        }\n        return ans;\n    }\n    void eprint(int id)\n    {\n        eprintf(\"---\\nv = %d\\n\", id);\n        for (int i = 1; i < (int) dp.size(); i++)\n        {\n            eprintf(\"%d : dp %d, dpEnd %d, dpOnly %d\\n\", i, dp[i], dpEnd[i], dpOnly[i] );\n        }\n    }\n};\n\n\nAns dfs(int v)\n{\n    Ans cur = Ans();\n    for (int to : ch[v] )\n    {\n        eprintf(\"%d -> %d\\n\", v, to);\n//        cur.eprint(10 + v);\n        cur = cur + dfs(to);\n    }\n//    cur.eprint(v);\n    return cur;\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n    for (int i = 0; i < N; i++)\n    {\n        _C[i][i] = _C[i][0] = 1;\n        for (int j = 1; j < i; j++)\n            _C[i][j] = add(_C[i - 1][j], _C[i - 1][j - 1] );\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N; i++)\n        fact[i] = mul(fact[i - 1], i);\n\n    rev2 = rev(2);\n\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        x--;\n        ch[x].push_back(i);\n    }\n\n    Ans ans = dfs(0);\n    int answer = ans.pvi();\n    printf(\"%d\\n\", answer);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "g"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\null gin[N_MAX];\n\nconst ull inv2 = 500000004LL;\null dp[2000][2000]/*[2]*/[5];\n\null dfs (ull v) {\n\tull tmp[2000]/*[2]*/[5];\n\tdp[v][0]/*[0]*/[0] = 1;\n\n\tull left = 1;\n\tfor (ull i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tull right = dfs(u);\n\n\t\t// printf(\"%llu->%llu (%lld += %lld)..\\n\", v, u, left, right);\n\t\tfflush(stdout);\n\n\t\tfor (sll j = 0; j < left + right; j++) {\n\t\t\t// for (sll k = 0; k < 2; k++) {\n\t\t\t\tfor (sll l = 0; l < 5; l++) {\n\t\t\t\t\ttmp[j]/*[k]*/[l] = 0;\n\t\t\t\t}\n\t\t\t// }\n\t\t}\n\n\t\tfor (sll jl = 0; jl < left; jl++) {\n\t\t\tfor (sll jr = 0; jr < right; jr++) {\n\t\t\t\tsll j = jl + jr;\n\t\t\t\t// for (ull kl = 0; kl < 2; kl++) {\n\t\t\t\t// \tfor (ull kr = 0; kr < 2; kr++) {\n\t\t\t\t// \t\tull k = kl ^ kr;\n\n\t\t\t\t\t\tull l0 = dp[v][jl]/*[kl]*/[0];\n\t\t\t\t\t\tull l1 = dp[v][jl]/*[kl]*/[1];\n\t\t\t\t\t\tull l2 = dp[v][jl]/*[kl]*/[2];\n\t\t\t\t\t\tull l3 = dp[v][jl]/*[kl]*/[3];\n\t\t\t\t\t\tull l4 = dp[v][jl]/*[kl]*/[4];\n\t\t\t\t\t\tull r0 = dp[u][jr]/*[kr]*/[0];\n\t\t\t\t\t\tull r1 = dp[u][jr]/*[kr]*/[1];\n\t\t\t\t\t\tull r2 = dp[u][jr]/*[kr]*/[2];\n\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[0] += l0 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[0] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k ^ 1]*/[1] += (l0 * r0 % MOD) * 2;\n\t\t\t\t\t\ttmp[j]/*[k ^ 1]*/[1] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[1] += l0 * (r1) % MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[1] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[3] += l0 * r0 % MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[3] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[4] += l0 * (r1) % MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[4] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[1] += l1 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[1] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[2] += l2 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[2] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[3] += l3 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[3] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k ^ 1]*/[2] += (l3 * r0 % MOD) * 2;\n\t\t\t\t\t\ttmp[j]/*[k ^ 1]*/[2] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[2] += l3 * r1 % MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[2] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[4] += l4 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1]/*[k]*/[4] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[2] += l4 * r0 % MOD;\n\t\t\t\t\t\ttmp[j]/*[k]*/[2] %= MOD;\n\t\t\t\t\t\ttmp[j]/*[k ^ 1]*/[2] += (l4 * r1 % MOD) * inv2 % MOD;\n\t\t\t\t\t\ttmp[j]/*[k ^ 1]*/[2] %= MOD;\n\n\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\n\t\tleft += right;\n\t\tfor (sll j = 0; j < left; j++) {\n\t\t\t// for (sll k = 0; k < 2; k++) {\n\t\t\t\tfor (sll l = 0; l < 5; l++) {\n\t\t\t\t\tdp[v][j]/*[k]*/[l] = tmp[j]/*[k]*/[l];\n\t\t\t\t\t// printf(\"%lld:%lld:%lld:%lld : %lld\\n\", v, j, k, l, dp[v][j][k][l]);\n\t\t\t\t}\n\t\t\t// }\n\t\t}\n\t}\n\n\t// printf(\"%lld done\\n\", v);\n\tfflush(stdout);\n\n\treturn left;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i < n; i++) {\n\t\txy[i - 1] = (hwll){a[i], i};\n\t}\n\tqsort(xy, n - 1, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i < n) {\n\t\tgin[i] = j;\n\t\twhile (j < n - 1 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\tgin[i] = j;\n\n\tdfs(0);\n\n\tull frac = 1;\n\tfor (j = 0; j < n; j++) {\n\t\tfrac *= (j + 1);\n\t\tfrac %= MOD;\n\t\tull item = 0;\n\t\t// for (li = 0; li < 3; li++) {\n\t\t// \titem = (item + (dp[0][j][0][li] + MOD - dp[0][j][1][li])) % MOD;\n\t\t// }\n\t\t// for (ki = 0; ki < 2; ki++) {\n\t\t\tfor (li = 0; li < 3; li++) {\n\t\t\t\titem = (item + dp[0][j]/*[ki]*/[li]) % MOD;\n\t\t\t}\n\t\t// }\n\t\t// printf(\"%llu : %llu\\n\", j, item);\n\t\titem = (item * frac) % MOD;\n\t\t// result = (result + (item * frac % MOD)) % MOD;\n\t\tif ((n - 1 - j) % 2) {\n\t\t\tresult = (result + MOD - item) % MOD;\n\t\t} else {\n\t\t\tresult = (result + item) % MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\tprintf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\tfor (i = 1; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define swap(type,a,b) {type x=a; a=b; b=x;}\n\nint main(void){\n        int i,j,k,num,sa,data[200000],tesu,han;\n        tesu=0;\n        scanf(\"%d\",&num);\n\n        for(i=0;i<num;i++)      scanf(\"%d\",&data[i]);\n\n        for(i=0;i<num-1;i++){\n                for(j=num-1;j>i;j--){\n                        sa=data[j-1]-data[j];\n                        if(sa == 1){\n                                data[j]++;\n                                tesu++;\n                        }\n                        if(data[j-1] > data[j]){\n                                swap(int,data[j],data[j-1])\n                                tesu++;\n                        }\n                }\n        }\n\n\n        printf(\"%d\\n\",tesu);\n\n        return 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\null gin[N_MAX];\n\nconst ull inv2 = 500000004LL;\null dp[2000][2000][2][5];\n\null dfs (ull v) {\n\tull tmp[2000][2][5];\n\tdp[v][0][0][0] = 1;\n\n\tull left = 1;\n\tfor (ull i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tull right = dfs(u);\n\n\t\t// printf(\"%llu->%llu (%lld += %lld)..\\n\", v, u, left, right);\n\t\tfflush(stdout);\n\n\t\tfor (sll j = 0; j < left + right; j++) {\n\t\t\tfor (sll k = 0; k < 2; k++) {\n\t\t\t\tfor (sll l = 0; l < 5; l++) {\n\t\t\t\t\ttmp[j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (sll jl = 0; jl < left; jl++) {\n\t\t\tfor (sll jr = 0; jr < right; jr++) {\n\t\t\t\tsll j = jl + jr;\n\t\t\t\tfor (ull kl = 0; kl < 2; kl++) {\n\t\t\t\t\tfor (ull kr = 0; kr < 2; kr++) {\n\t\t\t\t\t\tull k = kl ^ kr;\n\n\t\t\t\t\t\tull l0 = dp[v][jl][kl][0];\n\t\t\t\t\t\tull l1 = dp[v][jl][kl][1];\n\t\t\t\t\t\tull l2 = dp[v][jl][kl][2];\n\t\t\t\t\t\tull l3 = dp[v][jl][kl][3];\n\t\t\t\t\t\tull l4 = dp[v][jl][kl][4];\n\t\t\t\t\t\tull r0 = dp[u][jr][kr][0];\n\t\t\t\t\t\tull r1 = dp[u][jr][kr][1];\n\t\t\t\t\t\tull r2 = dp[u][jr][kr][2];\n\n\t\t\t\t\t\ttmp[j + 1][k][0] += l0 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1][k][0] %= MOD;\n\t\t\t\t\t\ttmp[j][k ^ 1][1] += (l0 * r0 % MOD) * 2;\n\t\t\t\t\t\ttmp[j][k ^ 1][1] %= MOD;\n\t\t\t\t\t\ttmp[j][k][1] += l0 * (r1) % MOD;\n\t\t\t\t\t\ttmp[j][k][1] %= MOD;\n\t\t\t\t\t\ttmp[j][k][3] += l0 * r0 % MOD;\n\t\t\t\t\t\ttmp[j][k][3] %= MOD;\n\t\t\t\t\t\ttmp[j][k][4] += l0 * (r1) % MOD;\n\t\t\t\t\t\ttmp[j][k][4] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1][k][1] += l1 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1][k][1] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1][k][2] += l2 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1][k][2] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1][k][3] += l3 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1][k][3] %= MOD;\n\t\t\t\t\t\ttmp[j][k ^ 1][2] += (l3 * r0 % MOD) * 2;\n\t\t\t\t\t\ttmp[j][k ^ 1][2] %= MOD;\n\t\t\t\t\t\ttmp[j][k][2] += l3 * r1 % MOD;\n\t\t\t\t\t\ttmp[j][k][2] %= MOD;\n\n\t\t\t\t\t\ttmp[j + 1][k][4] += l4 * (r0 + r1 + r2) % MOD;\n\t\t\t\t\t\ttmp[j + 1][k][4] %= MOD;\n\t\t\t\t\t\ttmp[j][k][2] += l4 * r0 % MOD;\n\t\t\t\t\t\ttmp[j][k][2] %= MOD;\n\t\t\t\t\t\ttmp[j][k ^ 1][2] += (l4 * r1 % MOD) * inv2 % MOD;\n\t\t\t\t\t\ttmp[j][k ^ 1][2] %= MOD;\n\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tleft += right;\n\t\tfor (sll j = 0; j < left; j++) {\n\t\t\tfor (sll k = 0; k < 2; k++) {\n\t\t\t\tfor (sll l = 0; l < 5; l++) {\n\t\t\t\t\tdp[v][j][k][l] = tmp[j][k][l];\n\t\t\t\t\t// printf(\"%lld:%lld:%lld:%lld : %lld\\n\", v, j, k, l, dp[v][j][k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"%lld done\\n\", v);\n\tfflush(stdout);\n\n\treturn left;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i < n; i++) {\n\t\txy[i - 1] = (hwll){a[i], i};\n\t}\n\tqsort(xy, n - 1, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i < n) {\n\t\tgin[i] = j;\n\t\twhile (j < n - 1 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\tgin[i] = j;\n\n\tdfs(0);\n\n\tull frac = 1;\n\tfor (j = 0; j < n; j++) {\n\t\tfrac *= (j + 1);\n\t\tfrac %= MOD;\n\t\tull item = 0;\n\t\t// for (li = 0; li < 3; li++) {\n\t\t// \titem = (item + (dp[0][j][0][li] + MOD - dp[0][j][1][li])) % MOD;\n\t\t// }\n\t\tfor (ki = 0; ki < 2; ki++) {\n\t\t\tfor (li = 0; li < 3; li++) {\n\t\t\t\titem = (item + dp[0][j][ki][li]) % MOD;\n\t\t\t}\n\t\t}\n\t\t// printf(\"%llu : %llu\\n\", j, item);\n\t\titem = (item * frac) % MOD;\n\t\t// result = (result + (item * frac % MOD)) % MOD;\n\t\tif ((n - 1 - j) % 2) {\n\t\t\tresult = (result + MOD - item) % MOD;\n\t\t} else {\n\t\t\tresult = (result + item) % MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\tprintf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\tfor (i = 1; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int mod = (int) 1e9 + 7;\n\n    ArrayList<Integer>[] g;\n\n\n    int[][] go(int v) {\n        int[][] dp = new int[3][1];\n        dp[0][0] = 1;\n        for (int to : g[v]) {\n            int[][] child = go(to);\n            int maxK = child[0].length;\n            int[][] ndp = new int[3][dp[0].length + maxK];\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < dp[i].length; j++) {\n                    int cur = dp[i][j];\n                    if (cur == 0) {\n                        continue;\n                    }\n                    for (int i2 = 0; i2 < 2; i2++) {\n                        for (int j2 = 0; j2 < child[i2].length; j2++) {\n                            int chWays = child[i2][j2];\n                            if (chWays == 0) {\n                                continue;\n                            }\n                            int nextI = i + i2;\n                            if (nextI >= 3) {\n                                continue;\n                            }\n                            int nextJ = j + j2;\n                            ndp[nextI][nextJ] = (int) ((ndp[nextI][nextJ] + cur * 1L * chWays) % mod);\n                        }\n                    }\n                }\n            }\n            dp = ndp;\n        }\n        int[][] res = new int[2][dp[0].length + 1];\n        for (int j = 0; j < dp[0].length; j++) {\n            {\n                int cur0 = dp[0][j];\n                res[0][j] += cur0;\n                if (res[0][j] >= mod) {\n                    res[0][j] -= mod;\n                }\n                res[1][j + 1] += cur0;\n                if (res[1][j + 1] >= mod) {\n                    res[1][j + 1] -= mod;\n                }\n            }\n            {\n                res[0][j] += dp[1][j] + dp[1][j];\n                while (res[0][j] >= mod) {\n                    res[0][j] -= mod;\n                }\n                res[1][j + 1] += dp[1][j];\n                if (res[1][j + 1] >= mod) {\n                    res[1][j + 1] -= mod;\n                }\n            }\n            {\n                res[0][j] += dp[2][j] + dp[2][j];\n                while (res[0][j] >= mod) {\n                    res[0][j] -= mod;\n                }\n            }\n        }\n        return res;\n    }\n\n    private void solve() {\n        int n = in.nextInt();\n        g = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n        }\n        for (int i = 1; i < n; i++) {\n            g[in.nextInt() - 1].add(i);\n        }\n        int[][] go = go(0);\n        long[] fact = new long[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i < fact.length; i++) {\n            fact[i] = fact[i - 1] * i % mod;\n        }\n        long result = 0;\n        for (int i = 0; i < go[0].length; i++) {\n            if (go[0][i] == 0) {\n                continue;\n            }\n            long ways = go[0][i] * fact[n - i] % mod;\n            if (i % 2 == 1) {\n                ways = mod - ways;\n            }\n            result += ways;\n        }\n        out.println(result % mod);\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"CF17_Exhibition_A.in\"));\n            out = new PrintWriter(new File(\"CF17_Exhibition_A.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int mod = (int) 1e9 + 7;\n\n    ArrayList<Integer>[] g;\n\n\n    long[][] go(int v) {\n        long[][] dp = new long[3][1];\n        dp[0][0] = 1;\n        for (int to : g[v]) {\n            long[][] child = go(to);\n            int maxK = child[0].length;\n            long[][] ndp = new long[3][dp[0].length + maxK];\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < dp[i].length; j++) {\n                    long cur = dp[i][j];\n                    if (cur == 0) {\n                        continue;\n                    }\n                    for (int i2 = 0; i2 < 2; i2++) {\n                        for (int j2 = 0; j2 < child[i2].length; j2++) {\n                            long chWays = child[i2][j2];\n                            if (chWays == 0) {\n                                continue;\n                            }\n                            int nextI = i + i2;\n                            if (nextI >= 3) {\n                                continue;\n                            }\n                            int nextJ = j + j2;\n                            ndp[nextI][nextJ] = (int) ((ndp[nextI][nextJ] + cur * chWays) % mod);\n                        }\n                    }\n                }\n            }\n            dp = ndp;\n        }\n        long[][] res = new long[2][dp[0].length + 1];\n        for (int j = 0; j < dp[0].length; j++) {\n            {\n                long cur0 = dp[0][j];\n                res[0][j] += cur0;\n                if (res[0][j] >= mod) {\n                    res[0][j] -= mod;\n                }\n                res[1][j + 1] += cur0;\n                if (res[1][j + 1] >= mod) {\n                    res[1][j + 1] -= mod;\n                }\n            }\n            {\n                res[0][j] += dp[1][j] + dp[1][j];\n                while (res[0][j] >= mod) {\n                    res[0][j] -= mod;\n                }\n                res[1][j + 1] += dp[1][j];\n                if (res[1][j + 1] >= mod) {\n                    res[1][j + 1] -= mod;\n                }\n            }\n            {\n                res[0][j] += dp[2][j] + dp[2][j];\n                while (res[0][j] >= mod) {\n                    res[0][j] -= mod;\n                }\n            }\n        }\n        return res;\n    }\n\n    private void solve() {\n        int n = in.nextInt();\n        g = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n        }\n        for (int i = 1; i < n; i++) {\n            g[in.nextInt() - 1].add(i);\n        }\n        long[][] go = go(0);\n        long[] fact = new long[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i < fact.length; i++) {\n            fact[i] = fact[i - 1] * i % mod;\n        }\n        long result = 0;\n        for (int i = 0; i < go[0].length; i++) {\n            if (go[0][i] == 0) {\n                continue;\n            }\n            long ways = go[0][i] * fact[n - i] % mod;\n            if (i % 2 == 1) {\n                ways = mod - ways;\n            }\n            result += ways;\n        }\n        out.println(result % mod);\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"CF17_Exhibition_A.in\"));\n            out = new PrintWriter(new File(\"CF17_Exhibition_A.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing static System.Console;\nnamespace Program\n{\n    public class Solver\n    {\n        Random rnd = new Random();\n        public void Solve()\n        {\n            var n = ri;\n            var G = Enumerate(n, x => new List<int>());\n            for (int i = 1; i < n; i++)\n            {\n                var p = ri - 1;\n                G[p].Add(i);\n            }\n            Func<int, int, KeyValuePair<int, long[,]>> dfs = null;\n            dfs = (prev, cur) =>\n            {\n                var size = 1;\n                //dp[sz,deg] = sz 個の連結成分からなり、次数が deg\n                var ret = new long[2, 3];\n                ret[1, 2] = 1;\n                foreach (var t in G[cur])\n                {\n                    var sz = size;\n                    var res = dfs(cur, t);\n                    size += res.Key;\n                    ret = merge(new int[] { sz, res.Key }, ret, res.Value);\n                }\n                return new KeyValuePair<int, long[,]>(size, ret);\n            };\n            var dp = dfs(-1, 0).Value;\n            long ans = 0;\n            var fact = new long[n + 1];\n            fact[0] = 1;\n            for (int i = 0; i < n; i++)\n                fact[i + 1] = fact[i] * (i + 1) % MOD;\n            for (int i = 0; i <= n; i++)\n                for (int d = 0; d <= 2; d++)\n                {\n                    //Console.WriteLine($\"{i} {d} {dp[i, d]}\");\n                    var v = dp[i, d] * fact[i] % MOD;\n                    if (d != 2) v *= 2;\n                    if ((n - i) % 2 == 0) ans += v;\n                    else ans -= v;\n                    ans %= MOD;\n                }\n            Console.WriteLine((ans + MOD) % MOD);\n\n        }\n        const long MOD = (long)1e9 + 7;\n\n        //merge b to a\n        long[,] merge(int[] sz, long[,] a, long[,] b)\n        {\n            var ret = new long[sz[0] + sz[1] + 1, 3];\n            for (int i = 0; i <= sz[0]; i++)\n                for (int j = 0; j <= sz[1]; j++)\n                    for (int d = 0; d <= 2; d++)\n                        for (int e = 0; e <= 2; e++)\n                        {\n                            var add = a[i, d] * b[j, e] % MOD;\n                            if (add == 0) continue;\n                            //Console.WriteLine($\"{i} {j} {d} {e} {u} {v} {a[i, d, u]} {b[j, e, v]}\");\n                            update(ref ret[i + j, d], add * (e == 2 ? 1 : 2));\n                            if (d != 0 && e != 0)\n                            {\n                                //Console.WriteLine($\"@ i:{i} j:{j} d:{d} e:{e} u:{u} v:{v} a:{a[i, d, u]} b:{b[j, e, v]}\");\n                                update(ref ret[i + j - 1, d - 1], add);\n                            }\n\n                        }\n\n            return ret;\n        }\n        void update(ref long u, long v)\n        {\n            u += v;\n            u %= MOD;\n        }\n\n        const long INF = 1L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter\n    {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char()\n        {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing static System.Console;\nnamespace Program\n{\n    public class Solver\n    {\n        Random rnd = new Random();\n        public void Solve()\n        {\n            var n = ri;\n            var G = Enumerate(n, x => new List<int>());\n            for (int i = 1; i < n; i++)\n            {\n                var p = ri - 1;\n                G[p].Add(i);\n            }\n            Func<int, int, KeyValuePair<int, long[,]>> dfs = null;\n            dfs = (prev, cur) =>\n            {\n                var size = 1;\n                //dp[sz,deg] = sz 個の連結成分からなり、次数が deg\n                var ret = new long[2, 3];\n                ret[1, 2] = 1;\n                foreach (var t in G[cur])\n                {\n                    var sz = size;\n                    var res = dfs(cur, t);\n                    size += res.Key;\n                    ret = merge(new int[] { sz, res.Key }, ret, res.Value);\n                }\n                return new KeyValuePair<int, long[,]>(size, ret);\n            };\n            var dp = dfs(-1, 0).Value;\n            long ans = 0;\n            var fact = new long[n + 1];\n            fact[0] = 1;\n            for (int i = 0; i < n; i++)\n                fact[i + 1] = fact[i] * (i + 1) % MOD;\n            for (int i = 0; i <= n; i++)\n                for (int d = 0; d <= 2; d++)\n                {\n                    Console.WriteLine($\"{i} {d} {dp[i, d]}\");\n                    var v = dp[i, d] * fact[i] % MOD;\n                    if (d != 2) v *= 2;\n                    if ((n - i) % 2 == 0) ans += v;\n                    else ans -= v;\n                    ans %= MOD;\n                }\n            Console.WriteLine((ans + MOD) % MOD);\n\n        }\n        const long MOD = (long)1e9 + 7;\n\n        //merge b to a\n        long[,] merge(int[] sz, long[,] a, long[,] b)\n        {\n            var ret = new long[sz[0] + sz[1] + 1, 3];\n            for (int i = 0; i <= sz[0]; i++)\n                for (int j = 0; j <= sz[1]; j++)\n                    for (int d = 0; d <= 2; d++)\n                        for (int e = 0; e <= 2; e++)\n                        {\n                            var add = a[i, d] * b[j, e] % MOD;\n                            if (add == 0) continue;\n                            //Console.WriteLine($\"{i} {j} {d} {e} {u} {v} {a[i, d, u]} {b[j, e, v]}\");\n                            update(ref ret[i + j, d], add * (e == 2 ? 1 : 2));\n                            if (d != 0 && e != 0)\n                            {\n                                //Console.WriteLine($\"@ i:{i} j:{j} d:{d} e:{e} u:{u} v:{v} a:{a[i, d, u]} b:{b[j, e, v]}\");\n                                update(ref ret[i + j - 1, d - 1], add);\n                            }\n\n                        }\n\n            return ret;\n        }\n        void update(ref long u, long v)\n        {\n            u += v;\n            u %= MOD;\n        }\n\n        const long INF = 1L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter\n    {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char()\n        {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.8.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.modint;\nalias Mint = ModInt!(10^^9 + 7);\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 1..n) {\n        int p;\n        sc.read(p); p--;\n        g[p] ~= i;\n    }\n\n    int[] sz = new int[n];\n    Mint[4][][] dp = new Mint[4][][n];\n    void dfs(int p) {\n        sz[p] = 1;        \n        foreach (d; g[p]) {\n            dfs(d);\n            sz[p] += sz[d];\n        }\n        dp[p] = new Mint[4][](sz[p]+1);\n        auto ndp = dp[p];\n        ndp[0][0] = Mint(1);\n        int msz = 1;\n        foreach (d; g[p]) {\n            foreach_reverse (kl; 0..msz+sz[d]+1) {\n                foreach_reverse (fg; 0..4) {\n                    Mint sm = 0;\n                    foreach_reverse (k; 0..min(kl+1, msz+1)) {\n                        auto l = kl-k;\n                        if (sz[d] < l) break;\n                        foreach_reverse (f; 0..4) {\n                            if (~fg & f) continue;\n                            auto g = fg^f;\n                            sm += ndp[k][f] * dp[d][l][g];\n                        }\n                    }\n                    ndp[kl][fg] = sm;\n                }\n            }\n            msz += sz[d];\n        }\n//        writeln(\"fl \", p, \" \", ndp);\n        foreach_reverse (i; 0..sz[p]+1) {\n            ndp[i][0] += ndp[i][1] + ndp[i][2] + ndp[i][3];\n            if (i) ndp[i][1] = ndp[i-1][1] + ndp[i-1][0];\n            else ndp[i][1] = Mint(0);\n            if (i) ndp[i][2] = ndp[i-1][2] + ndp[i-1][0];\n            else ndp[i][2] = Mint(0);\n            ndp[i][3] = Mint(0);\n        }\n    }\n    dfs(0);\n//    writeln(dp.map!(x => x.to!string).join(\"\\n\"));\n\n    auto fact = factTable!Mint(10000);\n    Mint ans = 0;\n    foreach (i; 0..n+1) {\n        Mint freq = (i % 2) ? Mint(-1) : Mint(1);\n        ans += freq * dp[0][i][0] * fact[n-i];\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n\nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n//     import dcomp.int128;\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/stackpayload.d */\n// module dcomp.container.stackpayload;\n\nstruct StackPayload(T, size_t MIN = 4) {\n    import core.exception : RangeError;\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private T* _data;\n    private uint len, cap;\n     \n    bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n    ref inout(T) front() inout { return _data[0]; }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    \n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n     \n    inout(T)[] data() inout {\n        return (_data) ? _data[0..len] : null;\n    }\n\n    static struct RangeT(A) {\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    alias Range = RangeT!(StackPayload!T);\n    alias ConstRange = RangeT!(const StackPayload!T);\n    alias ImmutableRange = RangeT!(immutable StackPayload!T);\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/ldc/inline.d */\n// module dcomp.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir)\n        R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1; v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/int128.d */\n \n\n// module dcomp.int128;\n\nversion(LDC) {\n//     import dcomp.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.8.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.modint;\nalias Mint = ModInt!(10^^9 + 7);\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 1..n) {\n        int p;\n        sc.read(p); p--;\n        g[p] ~= i;\n    }\n\n    int[] sz = new int[n];\n    Mint[4][][] dp = new Mint[4][][n];\n    void dfs(int p) {\n        sz[p] = 1;        \n        foreach (d; g[p]) {\n            dfs(d);\n            sz[p] += sz[d];\n        }\n        dp[p] = new Mint[4][](sz[p]+1);\n        auto ndp = dp[p];\n        ndp[0][0] = Mint(1);\n        int msz = 1;\n        foreach (d; g[p]) {\n            foreach_reverse (kl; 0..msz+sz[d]+1) {\n                foreach_reverse (fg; 0..4) {\n                    Mint sm = 0;\n                    foreach_reverse (k; 0..msz+1) {\n                        auto l = kl-k;\n                        if (!(0 <= l && l <= sz[d])) continue;\n                        foreach_reverse (f; 0..4) {\n                            if (~fg & f) continue;\n                            auto g = fg^f;\n                            sm += ndp[k][f] * dp[d][l][g];\n                        }\n                    }\n                    ndp[kl][fg] = sm;\n                }\n            }\n            msz += sz[d];\n        }\n//        writeln(\"fl \", p, \" \", ndp);\n        foreach_reverse (i; 0..sz[p]+1) {\n            ndp[i][0] += ndp[i][1] + ndp[i][2] + ndp[i][3];\n            if (i) ndp[i][1] = ndp[i-1][1] + ndp[i-1][0];\n            else ndp[i][1] = Mint(0);\n            if (i) ndp[i][2] = ndp[i-1][2] + ndp[i-1][0];\n            else ndp[i][2] = Mint(0);\n            ndp[i][3] = Mint(0);\n        }\n    }\n    dfs(0);\n//    writeln(dp.map!(x => x.to!string).join(\"\\n\"));\n\n    auto fact = factTable!Mint(10000);\n    Mint ans = 0;\n    foreach (i; 0..n+1) {\n        Mint freq = (i % 2) ? Mint(-1) : Mint(1);\n        ans += freq * dp[0][i][0] * fact[n-i];\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n\nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n//     import dcomp.int128;\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/stackpayload.d */\n// module dcomp.container.stackpayload;\n\nstruct StackPayload(T, size_t MIN = 4) {\n    import core.exception : RangeError;\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private T* _data;\n    private uint len, cap;\n     \n    bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n    ref inout(T) front() inout { return _data[0]; }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    \n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n     \n    inout(T)[] data() inout {\n        return (_data) ? _data[0..len] : null;\n    }\n\n    static struct RangeT(A) {\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    alias Range = RangeT!(StackPayload!T);\n    alias ConstRange = RangeT!(const StackPayload!T);\n    alias ImmutableRange = RangeT!(immutable StackPayload!T);\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/ldc/inline.d */\n// module dcomp.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir)\n        R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1; v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/int128.d */\n \n\n// module dcomp.int128;\n\nversion(LDC) {\n//     import dcomp.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nvector <int> G[N];\nint n, dp[N][N][3], g[N][3], c[N], ans;\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod; if (a < 0) a += mod;\n}\n\nvoid dfs(int u){\n    c[u] = 0;\n    dp[u][0][0] = 1;\n    for (auto v : G[u]){\n        dfs(v);\n        for (int i = 0; i <= c[u]+c[v]+1; i++) g[i][0] = g[i][1] = g[i][2] = 0;\n        for (int i = 0; i <= c[u]; i++) for (int j = 0; j <= c[v]; j++){\n            add(g[i+j][0], 1LL * dp[u][i][0] * dp[v][j][0] % mod);\n            add(g[i+j][1], 1LL * dp[u][i][1] * dp[v][j][0] % mod);\n            add(g[i+j+1][1], 1LL * dp[u][i][0] * dp[v][j][1] % mod);\n            add(g[i+j][2], 1LL * dp[u][i][2] * dp[v][j][0] % mod);\n            add(g[i+j+1][2], 1LL * dp[u][i][1] * dp[v][j][1] % mod);\n        }\n        for (int i = 0; i <= c[u]+c[v]+1; i++) dp[u][i][0] = g[i][0], dp[u][i][1] = g[i][1], dp[u][i][2] = g[i][2];\n        c[u] += c[v] + 1;\n    }\n    for (int i = 0; i <= c[u]; i++){\n        int a = dp[u][i][0], b = dp[u][i][1], c = dp[u][i][2];\n        dp[u][i][0] = a; add(dp[u][i][0], 2LL * b % mod); add(dp[u][i][0], 2LL * c % mod);\n        dp[u][i][1] = a; add(dp[u][i][1], b);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int i = 2; i <= n; i++){\n        int x; cin >> x;\n        G[x].push_back(i);\n    }\n    dfs(1); int f = 1;\n    for (int i = n-1; i >= 0; i--){\n        f = 1LL * f * (n - i) % mod;\n        if (i&1) add(ans, -1LL * f * dp[1][i][0] % mod);\n        else add(ans, 1LL * f * dp[1][i][0] % mod);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nnumAns = 0\n\nclass Node:\n    def __init__(self,init):\n        self.addr = None\n        self.boss = init\n        self.subordinate = []\n    def printBoss(self):\n        print(self.boss)\n    def showTree(self,tmp_node):\n        print(self.addr,self.boss,self.subordinate)\n        for sub in self.subordinate:\n            # print(\"-\",end=\"\")\n            tmp_node[sub-1].showTree(tmp_node)\n    def findTree(self,N,relation,tmp_node):\n        relation.append(self.addr)\n\n        if N == len(relation):\n            global numAns\n            numAns = (numAns+1) % 1000000007\n            \n            relation.pop()\n            return\n\n        list = [True for i in range(N)]\n        list[int(self.addr)-1] = False\n        if self.boss is not None:\n            list[int(self.boss)-1] = False\n        for sub in self.subordinate:\n            list[int(sub)-1] = False\n        for rel in relation:\n            list[int(rel)-1] = False\n        \n        for i in range(len(list)):\n            if list[i] is True:\n                tmp_node[i].findTree(N,relation,tmp_node)\n        relation.pop()\n                \n        \ndef input_boss(boss):\n    N = input()\n    for i in range(int(N)-1):\n        boss.append(input())\n    return N\n\ndef make_tree(nodes,boss):\n    for num in boss:\n        nodes.append(Node(num))\n\n    nodes.insert(0,Node(None))\n    nodes[0].addr = 1\n\n    for i in range(1,len(nodes)):\n        nodes[i].addr = i+1\n        tmp_boss = int(nodes[i].boss)-1\n        nodes[tmp_boss].subordinate.append(i+1)\n    \n    # for node in nodes:\n    #     print(node.addr,node.boss,node.subordinate)\n\nif __name__ == '__main__':\n\n    boss =[]\n    \n    N = input_boss(boss)\n\n    nodes = []\n    make_tree(nodes,boss)\n\n    # nodes[0].showTree(nodes)\n    for i in range(len(nodes)):\n        relation = []\n        nodes[i].findTree(int(N),relation,nodes)\n    \n    print(numAns)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nnumAns = 0\n\nclass Node:\n    def __init__(self,init):\n        self.addr = None\n        self.boss = init\n        self.subordinate = []\n    def printBoss(self):\n        print(self.boss)\n    def showTree(self,tmp_node):\n        print(self.addr,self.boss,self.subordinate)\n        for sub in self.subordinate:\n            # print(\"-\",end=\"\")\n            tmp_node[sub-1].showTree(tmp_node)\n    def findTree(self,N,relation,tmp_node):\n        relation.append(self.addr)\n\n        if N == len(relation):\n            global numAns\n            numAns += 1\n            relation.pop()\n            return\n\n        list = [True for i in range(N)]\n        list[int(self.addr)-1] = False\n        if self.boss is not None:\n            list[int(self.boss)-1] = False\n        for sub in self.subordinate:\n            list[int(sub)-1] = False\n        for rel in relation:\n            list[int(rel)-1] = False\n        \n        for i in range(len(list)):\n            if list[i] is True:\n                tmp_node[i].findTree(N,relation,tmp_node)\n        relation.pop()\n                \n        \ndef input_boss(boss):\n    N = input()\n    for i in range(int(N)-1):\n        boss.append(input())\n    return N\n\ndef make_tree(nodes,boss):\n    for num in boss:\n        nodes.append(Node(num))\n\n    nodes.insert(0,Node(None))\n    nodes[0].addr = 1\n\n    for i in range(1,len(nodes)):\n        nodes[i].addr = i+1\n        tmp_boss = int(nodes[i].boss)-1\n        nodes[tmp_boss].subordinate.append(i+1)\n    \n    # for node in nodes:\n    #     print(node.addr,node.boss,node.subordinate)\n\nif __name__ == '__main__':\n\n    boss =[]\n    \n    N = input_boss(boss)\n\n    nodes = []\n    make_tree(nodes,boss)\n\n    # nodes[0].showTree(nodes)\n    for i in range(len(nodes)):\n        relation = []\n        nodes[i].findTree(int(N),relation,nodes)\n    \n    print(numAns)"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\n\nfn dfs(ch: &[Vec<usize>], v: usize) -> Vec<[ModInt; 3]> {\n    let mut dp = vec![[ModInt::new(0); 3]; 2];\n    dp[1][0] = ModInt::new(1);\n    for &w in &ch[v] {\n        let sub = dfs(ch, w);\n        let sub_sz = sub.len() - 1;\n        let cur_sz = dp.len() - 1;\n        let mut next_dp = vec![[ModInt::new(0); 3]; cur_sz + sub_sz + 1];\n        for i in 1..sub_sz + 1 {\n            for j in 1..cur_sz + 1 {\n                // add one edge\n                for k in 0..2 {\n                    next_dp[i + j - 1][1] += sub[i][k] * dp[j][0];\n                    next_dp[i + j - 1][2] += sub[i][k] * dp[j][1];\n                }\n                // don't add an edge\n                for k in 0..3 {\n                    for l in 0..3 {\n                        next_dp[i + j][l] += sub[i][k] * dp[j][l]\n                            * if k >= 1 { 2 } else { 1 };\n                    }\n                }\n            }\n        }\n        dp = next_dp;\n    }\n    dp\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        b: [usize1; n - 1],\n    }\n    let mut ch = vec![vec![]; n];\n    for i in 1..n {\n        ch[b[i - 1]].push(i);\n    }\n    const W: usize = 3000;\n    let mut invtbl = vec![ModInt::new(0); W];\n    for i in 1..W {\n        invtbl[i] = ModInt::new(i as i64).inv();\n    }\n    let (fac, _invfac) = fact_init(W);\n    let dp = dfs(&ch, 0);\n    let mut tot = ModInt::new(0);\n    let mut factor = ModInt::new(1);\n    for i in (0..n + 1).rev() {\n        let mut t = ModInt::new(0);\n        for k in 0..3 {\n            t += dp[i][k] * fac[i]\n                * if k >= 1 { 2 } else { 1 };\n        }\n        tot += t * factor;\n        factor = -factor;\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]