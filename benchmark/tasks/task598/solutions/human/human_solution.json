[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,first,last) for(int i=first;i<=last;++i)\n#define DOW(i,first,last) for(int i=first;i>=last;--i)\nusing namespace std;\nlong long Random(long long a)\n{\n\treturn (1ll*rand()*rand()+rand())%a;\n}\nlong long Random(long long f,long long e)\n{\n\treturn f+Random(e-f+1);\n}\ndouble Sqr(double a)\n{\n\treturn a*a;\n}\nconst double PI=3.14159265358979323846264338327950288419716939;\nstruct Point\n{\n\tdouble x,y;\n\tPoint(double fx=0,double fy=0)\n\t{\n\t\tx=fx;\n\t\ty=fy;\n\t}\n\tvoid Read()\n\t{\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid Write()\n\t{\n\t\tprintf(\"%.9lf %.9lf\",x,y);\n\t}\n\tdouble operator ^(Point const b)const\n\t{\n\t\treturn x*b.x+y*b.y;\n\t}\n\tdouble operator |(Point const b)const\n\t{\n\t\treturn x*b.y-b.x*y;\n\t}\n\tdouble operator ==(Point const b)const\n\t{\n\t\treturn sqrt((x-b.x)*(x-b.x)+(y-b.y)*(y-b.y));\n\t}\n\tPoint operator *(double const b)const\n\t{\n\t\treturn Point(x*b,y*b);\n\t}\n\tPoint operator +(Point const b)const\n\t{\n\t\treturn Point(x+b.x,y+b.y);\n\t}\n\tPoint operator -(Point const b)const\n\t{\n\t\treturn Point(x-b.x,y-b.y);\n\t}\n\tbool operator !=(Point const b)const\n\t{\n\t\tif(1e-5<=fabs(x-b.x))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif(1e-5<=fabs(y-b.y))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nPoint Symmetrical(Point a,Point m=Point(0,0))\n{\n\treturn Point(m.x*2-a.x,m.y*2-a.y);\n}\n/**\n *      /\n *   a /\n *    m\n *   / b\n *  /\n *\n *    a\n *\n * ---m-----\n *\n *    b\n * return b;\n */\nstruct Vector\n{\n\tPoint a,b;\n\tVector(Point f=Point(0,0),Point e=Point(0,0))\n\t{\n\t\ta=f;\n\t\tb=e;\n\t}\n\tdouble operator ^(Vector const c)const\n\t{\n\t\treturn (a.x-b.x)*(c.a.x-c.b.x)+(c.a.y-c.b.y)*(a.y-b.y);\n\t}\n\tdouble operator |(Vector const c)const\n\t{\n\t\treturn (a.x-b.x)*(c.a.y-c.b.y)-(c.a.x-c.b.x)*(a.y-b.y);\n\t}\n};\nstruct Circle\n{\n\tPoint core;\n\tdouble radius;\n\tCircle(Point c=Point(0,0),double r=0)\n\t{\n\t\tcore=c;\n\t\tradius=r;\n\t}\n};\nPoint ProjectivePoint(Point a,Vector b)\n{\n\tdouble c=Vector(b.a,a)^Vector(b.a,b.b);\n\tc/=(b.a==b.b)*(b.a==b.b);\n\treturn (b.b-b.a)*c+b.a;\n}\n/**\n *     *\n *     |\n *     |\n * *---m-----*\n *\n *         *\n *         |\n *         |\n * *----*  m\n * return m;\n */\ndouble PointToVector(Point a,Vector b)\n{\n\tPoint c=ProjectivePoint(a,b);\n\tif(\n\t\t(\n\t\t\t(b.a.x<=c.x)==(c.x<=b.b.x)\n\t\t)\n\t\t&&\n\t\t(\n\t\t\t(b.a.y<=c.y)==(c.y<=b.b.y)\n\t\t)\n\t)\n\t{\n\t\treturn a==c;\n\t}\n\treturn min(a==b.a,a==b.b);\n}\n/**\n *   *\n *   |\n * *------*\n *\n *           *\n *          /\n *  *------*\n * return min_dis;\n */\nbool InRectangle(Point a,Point b,Point c)\n{\n\treturn\n\tmin(b.x,c.x)<=a.x&&a.x<=max(b.x,c.x)\n\t&&\n\tmin(b.y,c.y)<=a.y&&a.y<=max(b.y,c.y);\n}\n/**\n *   a\n *  b---*\n *  |   |\n *  *---c\n *  return 0;\n *\n *  b---*\n *  |a  |\n *  *---c\n *  return 1;\n */\nbool RectangleIntersection(Point a0,Point a1,Point b0,Point b1)\n{\n\tint zx=fabs(a0.x+a1.x-b0.x-b1.x);\n\tint zy=fabs(a0.y+a1.y-b0.y-b1.y);\n\tint x=fabs(a0.x-a1.x)+fabs(b0.x-b1.x);\n\tint y=fabs(a0.y-a1.y)+fabs(b0.y-b1.y);\n\tif(zx<=x&&zy<=y)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n/**\n *  *---*\n *  |   |\n *  *---*\n *\n *    *--*\n *    |  |\n *    |  |\n *    *--*\n * return 0;\n *\n *  *---*\n *  | *-+*\n *  *-+-*|\n *    |  |\n *    *--*\n * return 1;\n */\nbool Intersect(Vector a,Vector b)\n{\n\tdouble a_aa=a|Vector(a.a,b.a);\n\tdouble a_ab=a|Vector(a.a,b.b);\n\tdouble b_aa=b|Vector(b.a,a.a);\n\tdouble b_ab=b|Vector(b.a,a.b);\n\tif((a_aa==0||a_ab==0||((a_aa<0)^(a_ab<0)))&&(b_aa==0||b_ab==0||((b_aa<0)^(b_ab<0))))\n\t{\n\t\treturn RectangleIntersection(a.a,a.b,b.a,b.b);\n\t}\n\treturn 0;\n}\n/**\n *      *\n *     /\n *    /*\n *   /  \\\n *  /    \\\n * *      *\n * return 0;\n *\n *      *\n *  *  /\n *   \\/\n *   /\\\n *  /  \\\n * *    *\n * return 1;\n */\nPoint QueryIntersect(Vector a,Vector b)\n{\n\tVector u(a.a,b.a);\n\tVector v(b.a,b.b);\n\tVector w(a.a,a.b);\n\tdouble c=(w|u)/(v|w);\n\treturn Point(b.a.x+(b.b.x-b.a.x)*c,b.a.y+(b.b.y-b.a.y)*c);\n}\n/**\n *        *\n * *     /\n *  \\   /\n *   \\ /\n *    m\n *   / \\\n *  *   \\\n *       *\n * return m;\n */\ndouble VectorToVector(Vector a,Vector b)\n{\n\tif(Intersect(a,b))\n\t{\n\t\treturn 0.0;\n\t}\n\treturn min\n\t(\n\t\tmin(PointToVector(a.a,b),PointToVector(a.b,b)),\n\t\tmin(PointToVector(b.a,a),PointToVector(b.b,a))\n\t);\n}\n/**\n *   *----*\n *     |\n * *--------*\n *\n * *-----*\n *        \\\n *         *-----*\n * return min_dis;\n */\ndouble TriangleArea(Point a,Point b,Point c)\n{\n\tdouble al=b==c;\n\tdouble bl=a==c;\n\tdouble cl=a==b;\n\tdouble p=(al+bl+cl)/2;\n\treturn sqrt(p*(p-al)*(p-bl)*(p-cl));\n}\n/**\n *       a\n *      /|\n *     / |\n *    /  |\n *   c---b\n * return area;\n */\nCircle Circumscribed(Point a,Point b,Point c)\n{\n\tdouble a1=2*(b.x-a.x);\n\tdouble b1=2*(b.y-a.y);\n\tdouble c1=Sqr(b.x)+Sqr(b.y)-Sqr(a.x)-Sqr(a.y);\n\tdouble a2=2*(c.x-b.x);\n\tdouble b2=2*(c.y-b.y);\n\tdouble c2=Sqr(c.x)+Sqr(c.y)-Sqr(b.x)-Sqr(b.y);\n\tPoint core=Point\n\t(\n\t\t((c1*b2)-(c2*b1))/((a1*b2)-(a2*b1)),\n\t\t((a1*c2)-(a2*c1))/((a1*b2)-(a2*b1))\n\t);\n\treturn Circle(core,core==a);\n}\n/**\n *       a\n *  p   /|\n *     / |\n *    /  |\n *   c---b\n * (dis(p,a)=dis(p,b)=dis(p,c))\n * return p;\n */\nCircle Inscribed(Point a,Point b,Point c)\n{\n\tdouble al=b==c;\n\tdouble bl=a==c;\n\tdouble cl=a==b;\n\treturn Circle(Point((al*a.x+bl*b.x+cl*c.x)/(al+bl+cl),(al*a.y+bl*b.y+cl*c.y)/(al+bl+cl)),TriangleArea(a,b,c)/(al+bl+cl)*2);\n}\n/**\n *       a\n *      /|\n *     / |\n *    / p|\n *   c---b\n * (dis(p,ac)=dis(p,ab)=dis(p,bc))\n * return p;\n */\nint PolygonPoint(Point a,Point point[],int n)\n{\n\tpoint[n+1]=point[1];\n\tbool now=0;\n\tREP(i,1,n)\n\t{\n\t\tif(Intersect(Vector(a,Point(1e6,a.y)),Vector(point[i],point[i+1])))\n\t\t{\n\t\t\tif(\n\t\t\t\t(PointToVector(a,Vector(point[i],point[i+1]))<=1e-5))\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif((a.y<point[i].y)^(a.y<point[i+1].y))\n\t\t\t{\n\t\t\t\tnow^=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(now==0)\n\t{\n\t\treturn 0;\n\t}\n\treturn 2;\n}\n/**\n *       *---*\n *      /     \\\n *     *   a   *\n *      \\     /\n *       *---*\n * return 2;\n *\n *       *---*\n *      /     \\\n *     *       * a\n *      \\     /\n *       *---*\n * return 0;\n *\n *       *---*\n *      /     \\\n *     *       *\n *      \\     /\n *       *-a-*\n * return 1;\n */\ndouble Area(Point point[],int n)\n{\n\tdouble result=0;\n\tREP(i,2,n)\n\t{\n\t\tresult+=point[i-1]|point[i];\n\t}\n\tresult+=point[n]|point[1];\n\treturn fabs(result)/2.0;\n}\n/**\n *       *---*\n *      /   /\n *     *   *---*\n *      \\     /\n *       *---*\n * return area;\n */\ndouble Perimeter(Point point[],int n)\n{\n\tdouble result=0;\n\tREP(i,2,n)\n\t{\n\t\tresult+=(point[i-1]==point[i]);\n\t}\n\treturn result+(point[1]==point[n]);\n}\n/**\n *       *---*\n *      /   /\n *     *   *---*\n *      \\     /\n *       *---*\n * return perimeter;\n */\nbool CheckConvexHull(Point point[],int n)\n{\n\tdouble first=0,c;\n\tpoint[++n]=point[1];\n\tREP(i,1,n-1)\n\t{\n\t\tif(!first)\n\t\t{\n\t\t\tfirst=Vector(point[i],point[i+1])|Vector(point[i+1],point[i+2]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc=(Vector(point[i],point[i+1])|Vector(point[i+1],point[i+2]));\n\t\t\tif(c!=0&&((first<0)^(c<0)))\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n/**\n *       *---*\n *      /   /\n *     *   *---*\n *      \\     /\n *       *---*\n * return 0;\n *\n *       *---*\n *      /     \\\n *     *       *\n *      \\     /\n *       *---*\n * return 1;\n */\nPoint f_point;\nbool Cmp(Point a,Point b)\n{\n\tdouble c=Vector(f_point,a)|Vector(f_point,b);\n\tif(0<c)\n\t{\n\t\treturn 1;\n\t}\n\tif(c==0&&(f_point==a)<(f_point==b))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint GetConvexHull(Point point[],Point st[],int n)\n{\n\tREP(i,2,n)\n\t{\n\t\tif(point[i].y<point[1].y||point[i].y==point[1].y&&point[i].x<point[1].x)\n\t\t{\n\t\t\tswap(point[i],point[1]);\n\t\t}\n\t}\n\tf_point=point[1];\n\tsort(point+2,point+1+n,Cmp);\n\tint top=1;\n\tst[1]=point[1];\n\tREP(i,2,n)\n\t{\n\t\twhile(1<top&&(Vector(st[top-1],st[top])|Vector(st[top],point[i]))<=0)\n\t\t{\n\t\t\t--top;\n\t\t}\n\t\tst[++top]=point[i];\n\t}\n\treturn top;\n}\n/**\n *       *   *\n *\n *     *   *   *\n *\n *       *   *\n *         |\n *         V\n *       *---*\n *      /     \\\n *     *   *   *\n *      \\     /\n *       *---*\n */\ndouble GetDiam(Point point[],int n)\n{\n\tdouble result=0;\n\tif(n==2)\n\t{\n\t\treturn point[1]==point[2];\n\t}\n\tpoint[++n]=point[1];\n\tint top=2;\n\tREP(i,1,n)\n\t{\n\t\twhile(\n\t\t\t(Vector(point[i],point[top])|Vector(point[top],point[i+1]))\n\t\t\t>\n\t\t\t(Vector(point[i],point[top+1])|Vector(point[top+1],point[i+1]))\n\t\t\t)\n\t\t{\n\t\t\ttop++;\n\t\t\tif(top==n+1)\n\t\t\t{\n\t\t\t\ttop=1;\n\t\t\t}\n\t\t}\n\t\tresult=max(result,max(point[i]==point[top],point[i+1]==point[top]));\n\t}\n\treturn result;\n}\n/**\n *       *---*\n *      / \\   \\\n *     *   \\   *\n *      \\   \\ /\n *       *---*\n * return max_dis;\n */\nPoint a,b,c;\nint main()\n{\n\ta.Read();\n\tb.Read();\n\tc.Read();\n\tCircle cir=Inscribed(a,b,c);\n\tcir.core.Write();\n\tprintf(\" %.9lf\\n\",cir.radius);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rep1(i,n) for(int i = 1; i <= n; ++i)\n#define double long double\n#define F first\n#define S second\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nusing ll = long long;\nusing pi = pair<int,int>;\nconst double EPS = 1e-10;\nstruct Point {\n  double x;\n  double y;\n\n  Point() : x(0.0),y(0.0){}\n  Point(double _x,double _y) :x(_x),y(_y){}\n\n  Point operator+(const Point& other) const { return { x + other.x , y + other.y }; }\n  Point operator-(const Point& other) const { return { x - other.x , y - other.y }; }\n  bool operator==(const Point& other) const { return (abs(x - other.x) < EPS && abs(y - other.y) < EPS ); }\n\n  double dot(const Point& other) const { return x * other.x + y * other.y; }\n  double cross(const Point& other) const { return x * other.y - y * other.x; }\n  double length() const { return sqrt(x * x + y * y); }\n};\n// A とB のなす角θ cosθ, sinθ を返す\ndouble Cos(const Point A, const Point B) { return A.dot(B) / (A.length()*B.length()); }\ndouble Sin(const Point A, const Point B) { return A.cross(B) / (A.length()*B.length()); }\n\nstruct Line {\n  Point s;\n  Point t;\n  Point v;\n  \n  Line() : s({0,0}), t({0,0}) {}\n  Line(Point s, Point t) : s(s), t(t) { v = t - s; }\n\n  double length() { return sqrt(v.x*v.x + v.y*v.y); }\n};\n\ndouble Dist(const Point &A, const Point &B) { return (A -B).length(); }\n\n// A とB のなす角θ cosθ, sinθ を返す\ndouble Cos(const Line A, const Line B) { return (A.v).dot(B.v) / ((A.v).length()*(B.v).length()); }\ndouble Sin(const Line A, const Line B) { return (A.v).cross(B.v) / ((A.v).length()*(B.v).length()); }\n\nPoint CrossPoint(const Line a, const Line b) {\n  if( abs(Sin(a, b)) < EPS) {\n    cout << \"Pararell\" << \"\\n\";\n    return Point(0,0);\n  }\n  if(abs(a.v.x) < EPS) {\n    double alpha2 = b.v.y / b.v.x;\n    double beta2 = b.s.y - alpha2 * b.s.x;\n    double resX = a.s.x;\n    double resY = alpha2 * resX + beta2;\n    return Point(resX, resY);\n  }\n  else if( abs(b.v.x) < EPS) {\n    double alpha1 = a.v.y / a.v.x;\n    double beta1 = a.s.y - alpha1 * a.s.x;\n    double resX = b.s.x;\n    double resY = alpha1 * resX + beta1;\n    return Point(resX, resY);\n  }\n  else {\n    double alpha1 = a.v.y / a.v.x;\n    double beta1 = a.s.y - alpha1 * a.s.x;\n    double alpha2 = b.v.y / b.v.x;\n    double beta2 = b.s.y - alpha2 * b.s.x;\n    double resX = (beta2 - beta1) / (alpha1 - alpha2);\n    double resY = alpha1 * resX + beta1;\n    return Point(resX, resY);\n  }\n}\n\nLine OrthogonalLine(const Line &a, const Point &s) {\n  Point t(s.x + a.v.y, s.y - a.v.x);\n  return Line(s, t);\n\n}\n\nLine Bisector(Line &a,  Line &b) {\n  double l = min(a.length(), b.length());\n  Line v(Point(0,0), Point(1,0));\n  Point c = a.s;\n  c.x += l * Cos(v, a);\n  c.y += l * Sin(v, a);\n  Point d = b.s;\n  d.x += l * Cos(v, b);\n  d.y += l * Sin(v, b);\n  \n  Line ac = OrthogonalLine(a, c);\n  Line bd = OrthogonalLine(b, d);\n  \n  Point t = CrossPoint(ac, bd);\n  return Line(a.s, t);\n}\n\ndouble DistPointLine(const Line &a, const Point &c) {\n  double Z = (a.v.x)*(a.v.x) + (a.v.y)*(a.v.y);\n  double dy = ( (c.x - a.t.x)*(a.v.x)*(a.v.y) + a.t.y*(a.v.x)*(a.v.x) + c.y*(a.v.y)*(a.v.y) )/Z;\n  double dx;\n  if(abs(a.v.x) > EPS) {\n    dx = c.x - (a.v.y)*(dy - c.y) / (a.v.x);\n  }\n  else {\n    dx = a.t.x + (a.v.x)*(dy - a.t.y) / (a.v.y);\n  }\n  return Dist(c, Point(dx, dy));\n}\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() : p({0,0}), r(0) {}\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nCircle InscribedCircle(const Point &a, const Point &b, const Point &c) {\n  Line ab(a, b), ac(a, c);\n  Line bisA = Bisector(ab, ac);\n  Line bc(b, c), ba(b, a);\n  Line bisB = Bisector(bc, ba);  \n\n\n  \n  Point d = CrossPoint(bisA, bisB);\n  return Circle(d, DistPointLine(ab, d));\n}\n\nint main()\n{\n  Point p1,p2,p3;\n  cin >> p1.x >> p1.y;\n  cin >> p2.x >> p2.y;\n  cin >> p3.x >> p3.y;\n  Circle c = InscribedCircle(p1, p2, p3);\n  printf(\"%.10Lf %.10Lf %.10Lf\\n\", c.p.x, c.p.y, c.r);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nusing CP = complex<long double>;\n\nconst long double EPS = 1e-10;     // 許容する誤差ε\n#define EQ(a, b) (abs((a)-(b)) < EPS)   // 2つのスカラーが等しいかどうか\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))    // 2つのベクトルが等しいかどうか\n\n// double length = abs(a);     // ベクトルaの絶対値\n// double distance = abs(a-b);     // 2点a,b間の距離\n// CP b = a/abs(a);    // ベクトルaの単位ベクトル\n// CP n1 = a*CP(0,+1); CP n2 = a*CP(0,-1);  // ベクトルaの法線ベクトル\n// CP un1 = (a*CP(0,+1)/abs(a)); CP un2 = (a*CP(0,-1)/abs(a));  // ベクトルaの単位法線ベクトル\n\n// 内積(dot product) : a・b = |a||b|cosΘ\nlong double dot(CP a, CP b) {\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\nlong double cross(CP a, CP b) {\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// 2直線の直交判定 : a⊥b ⇔ dot(a,b) = 0\nint is_orthogonal(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n\n// 2直線の平行判定 : a//b ⇔ cross(a,b) = 0\nint is_parallel(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(CP a, CP b, CP c) {\n    return EQ(cross(b-a, c-a), 0.0);\n}\n\n// 点cが線分a,b上にあるかないか\nint is_point_on_lines(CP a, CP b, CP c) {\n    // |a-c|+|c-b| <= |a-b|なら線分上\n    return (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_lines(CP a1, CP a2, CP b1, CP b2) {\n    if(is_parallel(a1, a2, b1, b2)) {\n        // 平行なので線分の重なり判定\n        return is_point_on_lines(a1, a2, b1) || is_point_on_lines(a1, a2, b2) ||\n               is_point_on_lines(b1, b2, a1) || is_point_on_lines(b1, b2, a2);\n    }\n    return (cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < EPS) &&\n           (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nCP intersection_lines(CP a1, CP a2, CP b1, CP b2) {\n    CP b = b2-b1;\n    long double d1 = abs(cross(b, a1-b1));\n    long double d2 = abs(cross(b, a2-b1));\n    long double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_line(CP a1, CP a2, CP b1, CP b2) {\n    return !EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算(平行ではない前提)\nCP intersection_line(CP a1, CP a2, CP b1, CP b2) {\n    CP a = a2-a1; CP b = b2-b1;\n    return a1 + a*cross(b, b1-a1)/cross(b, a);\n}\n\n// 点a,bを通る直線と点cとの距離\nlong double distance_line_p(CP a, CP b, CP c) {\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\nlong double distance_lines_p(CP a, CP b, CP c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a1,a2を端点とする線分と点b1,b2を端点とする線分の最短距離\nlong double distance_lines_lines(CP a1, CP a2, CP b1, CP b2) {\n    long double res = 1e18;\n    if(is_intersected_lines(a1, a2, b1, b2)) return 0.0L;\n    res = min(res, distance_lines_p(a1, a2, b1));\n    res = min(res, distance_lines_p(a1, a2, b2));\n    res = min(res, distance_lines_p(b1, b2, a1));\n    res = min(res, distance_lines_p(b1, b2, a2));\n    return res;\n}\n\n// s,tを通る直線に対する点pの射影\nCP projection(CP s, CP t, CP p) {\n    if(EQV(s, t)) return s;\n    CP base = t-s;\n    return s + base*(dot(p-s, base)/norm(base));\n}\n\n// s,tを通る直線に対する点pの反射\nCP reflection(CP s, CP t, CP p) {\n    CP tmp = projection(s, t, p) - p;\n    return p + tmp*2.0L;\n}\n\n// 角度Θ回転\nCP translate(CP v, long double theta) {\n    CP res = v * CP(cosl(theta), sinl(theta));\n    return res;\n}\n\n// n多角形の面積計算\nlong double polygon_area(const vector<CP> &v) {\n    int n = v.size();\n    long double res = 0;\n    for(int i = 0; i < n; ++i) {\n        res += cross(v[(i+n-1)%n], v[(i+n)%n]);\n    }\n    return fabsl(res)/2.0L;\n}\n\n// n多角形の凸性判定\nint is_convex(const vector<CP> &v) {\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        if(cross(v[(i+1)%n]-v[i], v[(i+2)%n]-v[(i+1)%n]) < -EPS) return 0;\n    }\n    return 1;\n}\n\n// 凸包\nvector<CP> convex_hull(vector<CP> &v) {\n    // x座標→y座標で頂点をソート\n    auto lmd = [&](const CP &l, const CP &r) {\n        if(l.imag() != r.imag()) return l.imag() < r.imag();\n        return l.real() < r.real();\n        return l.imag() < r.imag();\n    };\n    vector<CP> res;     // 凸包を構成する頂点\n    int n = v.size();\n    sort(v.begin(), v.end(), lmd);\n    int k = 0;\n    res.resize(n*2);\n    // 下側凸包\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    // 上側凸包\n    for(int i = n-2, t = k; i >= 0; --i) {\n        while(k > t && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n\n// 凸多角形の直径\nlong double convex_diameter(vector<CP> &v) {\n    vector<CP> cv = convex_hull(v);\n    int n = cv.size();\n    if(n == 2) return abs(cv[0]-cv[1]);     // 凸包が潰れている例外処理\n    int i = 0, j = 0;   // x軸方向に最も遠い点対\n    for(int k = 0; k < n; ++k) {\n        if(cv[k].real() < cv[i].real()) i = k;\n        if(cv[k].real() > cv[j].real()) j = k;\n    }\n    long double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si) {     // 180度回転で終了\n        res = max(res, abs(cv[i]-cv[j]));\n        if(cross(cv[(i+1)%n]-cv[i], cv[(j+1)%n]-cv[j]) < 0) {\n            (++i) %= n;\n        }else {\n            (++j) %= n;\n        }\n    }\n    return res;\n}\n\n// 凸多角形を点s,tを通る直線で切断(左側が取得できる)\nvector<CP> convex_cut(const vector<CP> &v, const CP &s, const CP &t) {\n    vector<CP> res;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        CP nows = v[i], nowt = v[(i+1)%n];\n        if(cross(t-s, nows-s) >= -EPS) res.emplace_back(nows);\n        if(cross(t-s, nows-s)*cross(t-s, nowt-s) < 0) {\n            res.emplace_back(intersection_line(s, t, nows, nowt));\n        }\n    }\n    return res;\n}\n\n// n多角形に対する点pの包含関係(自己交差多角形は例外)\nint contain_polygon_point(const vector<CP> &v, CP p) {\n    int contain = 0, on_segment = 0;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        on_segment |= is_point_on_lines(v[i], v[(i+1)%n], p);   // 辺上判定\n        CP s = v[i]-p, t = v[(i+1)%n]-p;\n        if(s.imag() > t.imag()) swap(s, t);     // 下側を基準にする\n        if(s.imag()*t.imag() <= 0 && t.imag() > 0 && cross(s, t) > 0) {\n            contain = !contain;     // 交差回数が奇数なら内側\n        }\n    }\n    if(on_segment) return 1;    // 辺上\n    if(contain) return 2;       // 内側\n    return 0;       // 外側\n}\n\n// 最近点対距離\nlong double closest_pair(vector<CP> &v, int l = -1, \n                         int r = -1, bool reqsqrt = 0) {\n    if(l == r && l == -1) {\n        l = 0; r = v.size(); reqsqrt = 1;\n        // x座標→y座標で昇順ソート\n        auto lmd = [&](const CP &l, const CP &r) {\n            if(l.real() != r.real()) return l.real() < r.real();\n            return l.imag() < r.imag();\n        };\n        sort(v.begin(), v.end(), lmd);\n    }\n    if(r-l < 2) return 1e18;    // 2点存在しない\n    if(r-l == 2) {      // ちょうど2点の時\n        if(v[l].imag() > v[l+1].imag()) swap(v[l], v[l+1]);\n        if(reqsqrt) return abs(v[l]-v[l+1]);\n        return norm(v[l]-v[l+1]);\n    }\n    // 2点以上に関して分割統治法\n    int mid = (l+r)/2;\n    long double x = v[mid].real();  // 分断する線のx座標\n    // 左半分，右半分について再帰，同一領域内の最小距離resを求める\n    long double res = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    auto f = [](CP pl, CP pr) { return pl.imag() < pr.imag(); };\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, f);\n    vector<CP> tmp;\n    // 異なる領域の2点について最小距離res未満で探索\n    for(int i = l; i < r; ++i) {\n        long double dx = abs(v[i].real()-x);\n        int tsize = tmp.size();\n        if(dx*dx >= res) continue;\n        for(int j = 0; j < tsize; ++j) {\n            CP delta = v[i]-tmp[tsize-1-j];\n            if(delta.imag()*delta.imag() >= res) break;\n            res = min(res, norm(delta));\n        }\n        tmp.emplace_back(v[i]);\n    }\n    if(reqsqrt) res = sqrtl(res);\n    return res;\n}\n\n// 円の表現\nstruct Circle {\n    CP o;\n    long double r;\n    Circle(long double _x = 0.0L, long double _y = 0.0L,\n           long double _r = 0.0L)\n        : o(CP(_x, _y)), r(_r) {}\n    Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n};\n\n// 2円の位置関係\nint is_cross_circles(Circle l, Circle r) {\n    long double distlr = abs(l.o-r.o);\n    if(l.r+r.r+EPS < distlr) return 4;         // 交点無し外側\n    if(r.r+distlr+EPS < l.r) return -2;          // 交点無し内側(R in L)\n    if(l.r+distlr+EPS < r.r) return 2;          // 交点無し内側(L in R)\n    if(abs(l.r+r.r-distlr) < EPS) return 3;    // 外接\n    if(abs(l.r+distlr-r.r) < EPS) return -1;     // 内接(R in L)\n    if(abs(r.r+distlr-l.r) < EPS) return 1;     // 内接(L in R)\n    return 0;                                   // 2点で交わる\n}\n\n// 三角形の内接円\nCircle inscribed_circle(CP A, CP B, CP C) {\n    if(cross(B-A, C-A) < 0) swap(B, C);\n    long double a = abs(B-C), b = abs(C-A), c = abs(A-B);\n    long double alpha = acos((b*b+c*c-a*a)/(2.0L*b*c));\n    long double beta = acos((c*c+a*a-b*b)/(2.0L*c*a));\n    // AとxABを通る直線とBとxBCを通る直線の交点が内心\n    CP I = intersection_line(A, A+translate(B-A, alpha/2.0L), B, B+translate(C-B, beta/2.0L));\n    // ABとIの最短距離が内心半径\n    long double Ir = distance_lines_p(A, B, I);\n    return Circle(I, Ir);\n}\n\n// 3点の位置関係を判定\nint calc_clockwise(CP p0, CP p1, CP p2) {\n    CP x = p1-p0, y = p2-p0;\n    if(cross(x, y) > EPS) return 1;     // \"COUNTER_CLOCKWISE\"\n    if(cross(x, y) < -EPS) return -1;   // \"CLOCKWISE\"\n    if(dot(x, y) < 0) return 2;         // \"ONLINE_BACK\"\n    if(norm(x) < norm(y)) return -2;    // \"ONLINE_FRONT\"\n    return 0;                           // \"ON_SEGMENT\" \n}\n\nint main() {\n    long double a, b; cin >> a >> b;\n    long double c, d; cin >> c >> d;\n    long double e, f; cin >> e >> f;\n    CP x(a, b), y(c, d), z(e, f);\n    Circle I = inscribed_circle(x, y, z);\n    cout << fixed << setprecision(14);\n    cout << I.o.real() << \" \" << I.o.imag() << \" \" << I.r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// diff from complex\n// norm()\n// absolute() \n\n#include<iostream>\n#include<cstdio>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\n#define EPS (1e-12)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n//#define double long double\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n    Point operator / ( Point p ) { return Point((x*p.x+y*p.y)/(p.x*p.x+p.y*p.y), (y*p.x-x*p.y)/(p.x*p.x+p.y*p.y)); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble arg(Vector p){ return atan2(p.y, p.x); }\n\nPoint project( Segment s, Point p ){\n    Vector base = s.p2 - s.p1;\n    double t = dot(p - s.p1, base)/norm(base);\n    return s.p1 + base*t;\n}\n\nPoint reflect( Segment s, Point p ){\n    return p + (project(s, p) - p)*2.0;\n}\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\nbool isOrthogonal( Vector a, Vector b ){\n     return equals( dot(a, b), 0.0 );\n}\n\nbool isOrthogonal( Point a1, Point a2, Point b1, Point b2 ){\n    return isOrthogonal( a1 - a2, b1 - b2 );\n}\n\nbool isOrthogonal( Segment s1, Segment s2 ){\n    return equals( dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// verified by 920, 833, uoa2062\nPoint getCrossPoint(Segment s1, Segment s2){\n    assert( isIntersect(s1, s2) );\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1/(d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\n// 0 <= a <= 360\ndouble getAngleTheta(Point p){\n    double polar = atan2(p.y, p.x);\n    double rad = (dle(0, polar))? polar : 2*PI+polar;\n    return rad*180.0/acos(-1);\n}\n// 0 <= a <= 2pi\ndouble getAngle(Point p){\n    double polar = atan2(p.y, p.x);\n    return (dle(0, polar))? polar : 2*PI+polar;\n}\n\n// smaller angle of (a->b->c), in -pi to pi, negative when clockwise\n// no in a line\ndouble getAngle(Point a, Point b, Point c){\n    return arg((a-b)/(c-b));\n}\n\nint isIntersect(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    if ( c1.r + c2.r < d ) return CIRCLE_NON; // no overlap\n    if ( d + c2.r < c1.r ) return CIRCLE_IN;  // c1 includes c2\n    if ( d + c1.r < c2.r ) return CIRCLE_OUT;  // c2 includes c1\n    return CIRCLE_CROSS;\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\n// 10514\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n\t\tmin(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n  assert( !(c1.c == c2.c) );\n    assert( isIntersect( c1, c2 ) );\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l ){\n    assert( isIntersect( c, l ) );\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1)/abs(l.p2 - l.p1);\n    double base = sqrt(c.r*c.r - norm(pr-c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    for ( int i = 0; i < P.size(); i++ ){\n\tPoint a = P[i], b = P[(i+1)%P.size()];\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t    u.push_back(getCrossPointLines(Segment(a, b), l));\n\t}\n    }\n    return u;\n}\n\nbool yxCmp( const Point &p1, const Point &p2 ) {\n    return (p1.y == p2.y) ? p1.x < p2.x : p1.y < p2.y;\n}\n\nclass PolarAngleCmp{\n    public:\n    Point o;\n    PolarAngleCmp( Point o): o(o){}\n    bool operator()( const Point &p1,  const Point &p2) const {\n\tVector a = Vector(p1.x-o.x, p1.y-o.y); // p1 - o\n\tVector b = Vector(p2.x-o.x, p2.y-o.y); // p2 - o\n\tdouble c = cross(a, b);\n\tif ( fabs(c) < EPS ) return abs(a) < abs(b);\n\treturn c > 0;\n    }\n};\n\n// AOJ 1298\nPolygon grahamScan( Polygon s ){\n if ( s.size() < 3 ) return s;\n    Polygon h;\n    Point lm = *min_element(s.begin(), s.end(), yxCmp);\n    sort(s.begin(), s.end(), PolarAngleCmp(lm));\n\n    for ( int i = 0; i <= 2; i++ ) h.push_back(s[i]);\n    for ( int i = 3; i < s.size(); i++ ){\n\twhile( h.size() >= 2 && ccw(h[h.size()-2], h.back(), s[i]) != COUNTER_CLOCKWISE )\n\t    h.pop_back();\n\th.push_back(s[i]);\n    }\n    return h;\n}\n// AOJ 1298\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if ( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    int n;\n    for ( int i = 2; i < s.size(); i++ ){\n\tfor ( int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; n--){\n\t    u.pop_back();\n\t}\n\tu.push_back(s[i]);\n    }\n\n    for ( int i = s.size()-3; i >= 0; i-- ){\n\tfor ( int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; n--){\n\t    l.pop_back();\n\t}\n\tl.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for ( int i = u.size()-2; i >= 1; i-- ) l.push_back(u[i]);\n    return l;\n}\n\n/*\n * Area of Triangle\n * if area < 0 --> ClockWise\n * else if --> Anti- ClockWise\n * Solved 10112\n */\ndouble getArea(Point p1, Point p2, Point p3){\n  return abs(0.5 * ((p3.y-p1.y)*(p2.x-p1.x)-(p2.y-p1.y)*(p3.x-p1.x)));\n}\n/**\n * Area of polygon\n * if area < 0 --> ClockWise\n * else if --> Anti- ClockWise\n * Solved 10406 need veri\n */\ndouble getArea(Polygon p){\n    double sum = 0.0;\n    for(int i = 0; i < p.size(); i++){\n\tsum += cross(p[i], p[(i+1)%p.size()]);\n    }\n    return abs(sum/2);\n}\n\n\n// verified 1283\nSegment shift(Segment s, double d ){\n    Vector v = polar(d, arg(s.p2 - s.p1)+PI/2 );\n    Segment m = Segment(s.p1 + v, s.p2 + v );\n    return m;\n}\n\n// it does not work if p is on edges of pol\nbool isInside(Polygon g, Point p){\n  int n = g.size();\n  double a = 0.0;\n  for ( int i = 0; i < n; i++ ){\n    if ( isOnSegment(g[i], g[(i+1)%n], p) ) return true;\n    a += getAngle(g[i], p, g[(i+1)%g.size()]);\n  }\n  return equals(fabs(a), 2*PI);\n}\n\n/*\n IN 2\n ON 1\n OUT 0\n */\nint contains(Polygon g, Point p){\n  int n = g.size();\n  bool x = false;\n  for ( int i = 0; i < n; i++ ){\n    Point a = g[i] - p, b = g[(i+1)%n] - p;\n    if ( a.y > b.y ) swap(a, b);\n    if ( a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n    if ( abs(cross(a, b)) < EPS && dot(a, b) < EPS ) return 1;\n  }\n  return (x?2:0);\n}\n\nvoid check( int a ){\n  assert( -10000 <= a && a <= 10000);\n}\n\n\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint{\npublic:\n  Point p;\n  int seg;\n  int st;\n  EndPoint(){}\n  EndPoint(Point p, int seg, int st):p(p), seg(seg), st(st){}\n\n  bool operator < ( const EndPoint &ep ) const{\n    if ( p.y == ep.p.y ){\n      return st < ep.st;\n    } else return p.y < ep.p.y;\n  }\n};\n\nint getNumOfCommonTangentLines(Circle c1, Circle c2){\n  Point base = c2.c - c1.c;\n  double l = abs(base);\n  int cnt = 0;\n  if ( abs(c1.r - c2.r) < l  ){\n    cnt += 2;\n    if ( c1.r + c2.r < l ){\n      cnt += 2;\n    }\n  }\n  if ( (equals(l, abs(c1.r - c2.r)) || equals(c1.r + c2.r, l) ) && !equals(l, 0) ) {\n    cnt++;\n  }\n  return cnt;\n}\n\ndouble getCommonArea(Circle c2, Circle c1){\n  int numc = getNumOfCommonTangentLines(c1, c2);\n  // それらが離れている場合（共通接線の数が 4 の場合）4\n  // それらが外接する場合（共通接線の数が 3 の場合）3\n  // それらが交わる場合（共通接線の数が 2 の場合）2\n  // それらが内接する場合（共通接線の数が 1 の場合）1\n  // 一方がもう一方を内包する場合（共通接線がない場合）0\n  if ( numc == 4 || numc == 3 ) return 0;\n  if ( numc == 1 || numc == 0) return min(acos(-1)*c1.r*c1.r, acos(-1)*c2.r*c2.r);\n\n  double ans = 0;\n  double d = abs(c1.c - c2.c);\n  for ( int i = 0; i < 2; i++ ){\n    {\n      double th = abs( acosl((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d)));\n      if ( th < acos(-1)/2 ){\n\tans += c1.r*c1.r*th - abs(sinl(2*th)*c1.r* c1.r/2);\n      } else {\n\tans += c1.r*c1.r*th + abs(sinl(2*th)*c1.r* c1.r/2);\n      }\n    }\n    swap(c1, c2);\n  }\n  return ans;\n}\n\nCircle getIncircle(Point pa, Point pb, Point pc){\n  Vector v1 = pb - pa;\n  Vector v2 = pc - pa;\n  Vector v3 = pc - pb;\n  Vector v4 = pa - pb;\n  Vector c1 = polar(10000.0, (arg(v1) + arg(v2))/2);\n  Vector c2 = polar(10000.0, (arg(v3) + arg(v4))/2);\n  Point x = getCrossPointLines(Segment(pa, pa + c1), Segment(pb, pb + c2));\n  double r = getDistanceLP(Segment(pa, pb), x);\n  return Circle(x, r);\n}\n\nCircle getIncircleByFormulas(Point pa, Point pb, Point pc){\n  double a =  abs(pc - pb);\n  double b =  abs(pc - pa);\n  double c =  abs(pa - pb);\n  double cx = (a*pa.x + b*pb.x + c*pc.x)/(a + b + c);\n  double cy = (a*pa.y + b*pb.y + c*pc.y)/(a + b + c);\n  double s = (a + b + c )/2;\n  double r = sqrtl(s*(s - a)*(s - b)*(s - c))/s;\n  return Circle(Point(cx, cy), r);\n}\n\nCircle getExcircle(Point pa, Point pb, Point pc){\n  Vector v1 = (pb - pa);\n  Vector v2 = (pc - pa);\n  Vector v1r = Vector(-v1.y, v1.x);\n  Vector v2r = Vector(-v2.y, v2.x);\n  Point c1 = pa + v1/2;\n  Point c2 = pa + v2/2;\n  Point x = getCrossPointLines(Segment(c1, c1 + v1r), Segment(c2, c2 + v2r));\n  double r = getDistance(pa, x);\n  return Circle(x, r);\n}\n\nCircle getExcircleByFormulas(Point pa, Point pb, Point pc){\n  double a =  abs(pc - pb);\n  double b =  abs(pc - pa);\n  double c =  abs(pa - pb);\n  double x1 = pa.x;\n  double y1 = pa.y;\n  double x2 = pb.x;\n  double y2 = pb.y;\n  double x3 = pc.x;\n  double y3 = pc.y;\n  Point u;\n  u.x = ((y1-y3)*(y1*y1 -y2*y2 +x1*x1 -x2*x2) -(y1-y2)*(y1*y1 -y3*y3 +x1*x1 -x3*x3)) / (2*(y1-y3)*(x1-x2)-2*(y1-y2)*(x1-x3));\n  u.y = ((x1-x3)*(x1*x1 -x2*x2 +y1*y1 -y2*y2) -(x1-x2)*(x1*x1 -x3*x3 +y1*y1 -y3*y3)) / (2*(x1-x3)*(y1-y2)-2*(x1-x2)*(y1-y3));\n  //  double r = a*b*c/sqrtl((a + b + c)*(-a + b + c)*(a - b + c)*(a + b -c));\n  double r = getDistance(u, pa);\n  return Circle(u, r);\n}\n\n\nint main(){\n  double xa, ya, xb, yb, xc, yc;\n  cin >> xa >> ya >> xb >> yb >> xc >> yc;\n  Point pa = Point(xa, ya);\n  Point pb = Point(xb, yb);\n  Point pc = Point(xc, yc);\n\n  {\n    Circle cf = getIncircleByFormulas(pa, pb, pc);\n    Circle c = getIncircle(pa, pb, pc);\n    //    printf(\"%.20Lf %.20Lf %.20Lf\\n\", cf.c.x, cf.c.y, cf.r); // higher\n    printf(\"%.12lf %.12lf %.12lf\\n\", c.c.x, c.c.y, c.r);\n  }\n  {\n    Circle cf = getExcircleByFormulas(pa, pb, pc);\n    Circle c = getExcircle(pa, pb, pc);\n    //    printf(\"%.20Lf %.20Lf %.20Lf\\n\", cf.c.x, cf.c.y, cf.r);\n    //    printf(\"%.20Lf %.20Lf %.20Lf\\n\", c.c.x, c.c.y, c.r); // higher\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n\nusing namespace std;\n\n//BEGIN\nconst double EPS = 1e-10;\nconst double PI = acos(-1);\n\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const double& k) const { return Point(x * k, y * k); }\n\tPoint operator/(const double& k) const { return Point(x / k, y / k); }\n\n\tfriend istream& operator>>(istream& is, Point& p) {\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\tbool operator==(const Point& p) const { return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS); }\n\tbool operator<(const Point& p) const { return (x != p.x ? x < p.x : y < p.y); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\n\tfriend istream& operator>>(istream& is, Segment& s) {\n\t\tis >> s.p1 >> s.p2;\n\t\treturn is;\n\t}\n};\n\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectSS(Segment s1, Segment s2) {\n\treturn intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersectCS(Circle c, Segment s) {\n\tif (norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n\tdouble d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n\tif (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n\tif ((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS)) return 1;\n\tPoint h = project(s, c.c);\n\tif (dot(s.p1 - h, s.p2 - h) < 0) return 2;\n\treturn 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble r = c1.r + c2.r;\n\tif (equals(d, r)) return 3;\n\tif (d > r) return 4;\n\tif (equals(d + c2.r, c1.r)) return 1;\n\tif (d + c2.r < c1.r) return 0;\n\treturn 2;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n\t\t\t   getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n\tdouble a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n\tdouble b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n\tif (abs(a) < EPS && abs(b) < EPS) return l2.p1;\n\treturn l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\nvector<Point> getCrossPointCL(Circle c, Line l) {\n\tvector<Point> ps;\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tif (equals(getDistanceLP(l, c.c), c.r)) return vector<Point>{pr, pr};\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\tps.push_back(pr + e * base); ps.push_back(pr - e * base);\n\treturn ps;\n}\n\nvector<Point> getCrossPointCS(Circle c, Segment s) {\n\tLine l(s);\n\tvector<Point> ps = getCrossPointCL(c, l);\n\tif (intersectCS(c, s) == 2) return ps;\n\tif (dot(l.p1 - ps[0], l.p2 - ps[0]) < 0) ps[1] = ps[0];\n\telse ps[0] = ps[1];\n\treturn ps;\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nPoint polar(double r, double a) { return Point(cos(a) * r, sin(a) * r); }\n\nvector<Point> getCrossPointCC(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tvector<Point> ps;\n\tps.push_back(c1.c + polar(c1.r, t + a)); ps.push_back(c1.c + polar(c1.r, t - a));\n\treturn ps;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n\treturn getCrossPointCC(c, Circle(p, sqrt(norm(c.c - p) - c.r * c.r)));\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n\tvector<Line> ls;\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble g = abs(c1.c - c2.c);\n\tif (equals(g, 0)) return ls;\n\tPoint u = (c2.c - c1.c) / g;\n\tPoint v = Point(-u.y, u.x);\n\tfor (int s = 1; s >= -1; s -= 2) {\n\t\tdouble h = (c1.r + s * c2.r) / g;\n\t\tif (equals(1, h * h)) ls.push_back(Line(c1.c + u * c1.r, c1.c + (u + v) * c1.r));\n\t\telse if (1 - h * h > 0) {\n\t\t\tPoint uu = u * h, vv = v * sqrt(1 - h * h);\n\t\t\tls.push_back(Line(c1.c + (uu + vv) * c1.r, c2.c - (uu + vv) * c2.r * s));\n\t\t\tls.push_back(Line(c1.c + (uu - vv) * c1.r, c2.c - (uu - vv) * c2.r * s));\n\t\t}\n\t}\n\treturn ls;\n}\n\nCircle getInscribedCircle(Point p1, Point p2, Point p3) {\n\tCircle ca;\n\tdouble a = abs(p2 - p3), b = abs(p3 - p1), c = abs(p1 - p2);\n\tca.c = (p1 * a + p2 * b + p3 * c) / (a + b + c);\n\tca.r = getDistanceLP(Line(p1, p2), ca.c);\n\treturn ca;\n}\n\nCircle getCircumscribedCircle(Point p1, Point p2, Point p3) {\n\tCircle ca;\n\tPoint m = (p1 + p2) / 2, n = (p2 + p3) / 2;\n\tca.c = getCrossPointLL(Line(m, m + Point((p2 - p1).y, (p1 - p2).x)),\n\t\t\t\t\t\t   Line(n, n + Point((p3 - p2).y, (p2 - p3).x)));\n\tca.r = abs(ca.c - p1);\n\treturn ca;\n}\n\n// IN:2,ON:1,OUT:0\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tif (ccw(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]) == CLOCKWISE) return false;\n\treturn true;\n}\n\nPolygon convexHull(Polygon p) {\n\tint n = p.size();\n\tsort(p.begin(), p.end(),\n\t\t [](const Point& a, const Point& b) {return (a.y != b.y ? a.y < b.y : a.x < b.x); });\n\tPolygon a(2 * n);\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k > 1 && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; --i) {\n\t\twhile (k > t && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\ta.resize(k - 1);\n\treturn a;\n}\n\ndouble area(Polygon p) {\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\tres += cross(p[i], p[(i + 1) % p.size()]) / 2.0;\n\treturn res;\n}\n\ndouble area(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tint num = intersectCC(c1, c2);\n\tif (num >= 3) return 0;\n\tif (num <= 1) return c2.r * c2.r * PI;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble res = 0;\n\tfor (int i = 0; i < 2; ++i) {\n\t\tdouble th = 2 * acos((d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d * c1.r));\n\t\tres += (th - sin(th)) * c1.r * c1.r / 2;\n\t\tswap(c1, c2);\n\t}\n\treturn res;\n}\n\ndouble area(Polygon p, Circle c) {\n\tif (p.size() < 3) return 0;\n\tfunction<double(Circle, Point, Point)> dfs = [&](Circle c, Point a, Point b) {\n\t\tVector va = c.c - a, vb = c.c - b;\n\t\tdouble f = cross(va, vb), res = 0;\n\t\tif (equals(f, 0.0)) return res;\n\t\tif (max(abs(va), abs(vb)) < c.r + EPS) return f;\n\t\tVector d(dot(va, vb), cross(va, vb));\n\t\tif (getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n\t\t\treturn c.r * c.r * arg(d);\n\t\tauto u = getCrossPointCS(c, Segment(a, b));\n\t\tif (u.empty()) return res;\n\t\tif (u.size() > 1 && dot(u[1] - u[0], a - u[0]) > 0) swap(u[0], u[1]);\n\t\tu.emplace(u.begin(), a);\n\t\tu.emplace_back(b);\n\t\tfor (int i = 1; i < (int)u.size(); ++i) res += dfs(c, u[i - 1], u[i]);\n\t\treturn res;\n\t};\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i) res += dfs(c, p[i], p[(i + 1) % p.size()]);\n\treturn res / 2;\n}\n\ndouble convexDiameter(Polygon p) {\n\tint n = p.size();\n\tif (n == 2) return abs(p[0] - p[1]);\n\tint i = 0, j = 0;\n\tfor (int k = 0; k < n; ++k) {\n\t\tif (p[i] < p[k]) i = k;\n\t\tif (!(p[j] < p[k])) j = k;\n\t}\n\tdouble res = 0;\n\tint ti = i, tj = j;\n\twhile (i != tj || j != ti) {\n\t\tres = max(res, abs(p[i] - p[j]));\n\t\tif (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0)\n\t\t\ti = (i + 1) % n;\n\t\telse j = (j + 1) % n;\n\t}\n\treturn res;\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\tfor (int i = 0; i < (int)p.size(); ++i) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE) q.push_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n\t\t\tq.push_back(getCrossPointLL(Line(a, b), l));\n\t}\n\treturn q;\n}\n\ndouble closestPair(vector<Point> ps) {\n\tsort(ps.begin(), ps.end());\n\tvector<Point> a(ps.size());\n\tfunction<double(int, int)> solve = [&](int l, int r) {\n\t\tif (r - l < 2) return 1e18;\n\t\tint mid = (l + r) >> 1;\n\t\tdouble x = ps[mid].x;\n\t\tdouble d = min(solve(l, mid), solve(mid, r));\n\t\tinplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r,\n\t\t\t\t\t  [](const Point& a, const Point& b) {return a.y < b.y; });\n\t\tint ptr = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tif (abs(ps[i].x - x) >= d) continue;\n\t\t\tfor (int j = 0; j < ptr; ++j) {\n\t\t\t\tPoint luz = ps[i] - a[ptr - j - 1];\n\t\t\t\tif (luz.y >= d) break;\n\t\t\t\td = min(d, abs(luz));\n\t\t\t}\n\t\t\ta[ptr++] = ps[i];\n\t\t}\n\t\treturn d;\n\t};\n\treturn solve(0, ps.size());\n}\n\nint manhattanIntersection(vector<Segment> ss) {\n\tconst int INF = numeric_limits<int>::max();\n\tconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\n\tint n = ss.size();\n\tvector<EndPoint> ep;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ss[i].p1.y == ss[i].p2.y) {\n\t\t\tif (ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, LEFT));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, RIGHT));\n\t\t} else {\n\t\t\tif (ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, BOTTOM));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, TOP));\n\t\t}\n\t}\n\tsort(ep.begin(), ep.end());\n\tset<int> st;\n\tst.insert(INF);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (ep[i].st == TOP) st.erase(ep[i].p.x);\n\t\telse if (ep[i].st == BOTTOM) st.insert(ep[i].p.x);\n\t\telse if (ep[i].st == LEFT) {\n\t\t\tauto b = st.lower_bound(ss[ep[i].seg].p1.x);\n\t\t\tauto e = st.upper_bound(ss[ep[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n//END\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CGL1A() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = project(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\n*/\nvoid CGL1B() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = reflect(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\n*/\nvoid CGL1C() {\n\tPoint p0, p1, p2; cin >> p0 >> p1;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tcin >> p2;\n\t\tint a = ccw(p0, p1, p2);\n\t\tif (a == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\";\n\t\telse if (a == CLOCKWISE) cout << \"CLOCKWISE\";\n\t\telse if (a == ONLINE_BACK) cout << \"ONLINE_BACK\";\n\t\telse if (a == ONLINE_FRONT) cout << \"ONLINE_FRONT\";\n\t\telse cout << \"ON_SEGMENT\";\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\n*/\nvoid CGL2A() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tVector p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tif (isParallel(p1 - p0, p3 - p2)) cout << 2;\n\t\telse if (isOrthogonal(p1 - p0, p3 - p2)) cout << 1;\n\t\telse cout << 0;\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\n*/\nvoid CGL2B() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << (intersectSS(s1, s2) ? 1 : 0) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\n*/\nvoid CGL2C() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tPoint a = getCrossPointSS(s1, s2);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2020-03-27\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\n*/\nvoid CGL2D() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tprintf(\"%.10f\\n\", getDistanceSS(s1, s2));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\n*/\nvoid CGL3A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.1f\\n\", area(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A\n*/\nvoid CGL3B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tcout << (isConvex(p) ? 1 : 0) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B\n*/\nvoid CGL3C() {\n\tint n; cin >> n;\n\tPolygon g(n);\n\tfor (auto& a : g) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tcout << contains(g, p) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C\n*/\nvoid CGL4A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tPolygon t = convexHull(p);\n\tcout << t.size() << endl;\n\tfor (auto a : t) cout << a.x << \" \" << a.y << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_A\n*/\nvoid CGL4B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", convexDiameter(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B\n*/\nvoid CGL4C() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tprintf(\"%.10f\\n\", area(convexCut(p, l)));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C\n*/\nvoid CGL5A() {\n\tint n; cin >> n;\n\tvector<Point> ps(n);\n\tfor (auto& a : ps) cin >> a;\n\tprintf(\"%.10f\\n\", closestPair(ps));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/5/CGL_5_A\n*/\nvoid CGL6A() {\n\tint n; cin >> n;\n\tvector<Segment> ss(n);\n\tfor (auto& a : ss) cin >> a;\n\tcout << manhattanIntersection(ss) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/6/CGL_6_A\n*/\nvoid CGL7A() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tcout << intersectCC(c1, c2) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\n*/\nvoid CGL7B() {\n\tPoint p1, p2, p3; cin >> p1 >> p2 >> p3;\n\tCircle c = getInscribedCircle(p1, p2, p3);\n\tprintf(\"%.10f %.10f %.10f\\n\", c.c.x, c.c.y, c.r);\n}\n/*\n\tcreated: 2020-07-01\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_B\n */\nvoid CGL7C() {\n\tPoint p1, p2, p3; cin >> p1 >> p2 >> p3;\n\tCircle c = getCircumscribedCircle(p1, p2, p3);\n\tprintf(\"%.10f %.10f %.10f\\n\", c.c.x, c.c.y, c.r);\n}\n/*\n\tcreated: 2020-07-01\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_C\n */\nvoid CGL7D() {\n\tCircle c; cin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tauto a = getCrossPointCL(c, l);\n\t\tsort(a.begin(), a.end());\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D\n*/\nvoid CGL7E() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = getCrossPointCC(c1, c2);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E\n*/\nvoid CGL7F() {\n\tPoint p; cin >> p;\n\tCircle c; cin >> c.c >> c.r;\n\tauto a = tangentCP(c, p);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f\\n%.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F\n*/\nvoid CGL7G() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = tangentCC(c1, c2);\n\tvector<Point> ps;\n\tfor (auto e : a) ps.push_back(getCrossPointCL(c1, e)[0]);\n\tsort(ps.begin(), ps.end());\n\tfor (auto e : ps) printf(\"%.10f %.10f\\n\", e.x, e.y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G\n*/\nvoid CGL7H() {\n\tint n; cin >> n;\n\tCircle c; c.c = Point(0, 0); cin >> c.r;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", area(p, c));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_H\n*/\nvoid CGL7I() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tprintf(\"%.10f\\n\", area(c1, c2));\n}\n/*\n\tcreated: 2020-07-01\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_I\n */\n\nint main() {\n\t//CGL1A();\n\t//CGL1B();\n\t//CGL1C();\n\t//CGL2A();\n\t//CGL2B();\n\t//CGL2C();\n\t//CGL2D();\n\t//CGL3A();\n\t//CGL3B();\n\t//CGL3C();\n\t//CGL4A();\n\t//CGL4B();\n\t//CGL4C();\n\t//CGL5A();\n\t//CGL6A();\n\t//CGL7A();\n\tCGL7B();\n\t//CGL7C();\n\t//CGL7D();\n\t//CGL7E();\n\t//CGL7F();\n\t//CGL7G();\n\t//CGL7H();\n\t//CGL7I();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n#define double long double\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nconst double PI = asinl(1) * 2;\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n// intercsect of circles\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();\n        n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;\n        n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();\n        n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;\n        n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double res=0;\n  for(int k=0;k<2;k++){\n    double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d*c1.r);\n    double th=acosl(rc)*2;\n    res+=(th-sinl(th))*c1.r*c1.r/2;\n    swap(c1,c2);\n  }\n  return res;\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n\n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }\n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n  return G;\n}\n\nint manhattan_intersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n\n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }\n  }\n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n\n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }\n  }\n\n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Point A,B,C;\n  cin>>A>>B>>C;\n\n  if(cross(B-A,C-A)<0) swap(B,C);\n\n  double a=abs(B-C),b=abs(A-C),c=abs(A-B);\n\n  double thA=acos((b*b+c*c-a*a)/(2*b*c));\n  double thB=acos((a*a+c*c-b*b)/(2*a*c));\n\n  Line lA(A,A+translate(B-A,thA/2));\n  Line lB(B,B+translate(C-B,thB/2));\n\n  auto I=getCrossPointLL(lA,lB);\n  cout<<I<<' '<<getDistanceSP(Segment(A,B),I)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nnamespace geom {\n  constexpr double eps = 1e-8;\n\n  /* point */\n  struct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(this->x + p.x, this->y + p.y); }\n    Point operator-(const Point& p) const { return Point(this->x - p.x, this->y - p.y); }\n    Point operator*(double d) const { return Point(x * d, y * d); }\n    Point operator/(double d) const { return Point(x / d, y / d); }\n    Point operator-() const { return Point(-this->x, -this->y); }\n    Point& operator+=(const Point& p) { return *this = *this + p; }\n    Point& operator-=(const Point& p) { return *this = *this - p; }\n    Point& operator*=(double d) { return *this = *this * d; }\n    Point& operator/=(double d) { return *this = *this / d; }\n    friend Point operator*(double d, const Point& p) { return Point(p.x * d, p.y * d); }\n    bool operator==(const Point& p) const { return x == p.x && y == p.y; }\n    bool operator!=(const Point& p) const { return !(*this == p); }\n    bool operator<(const Point& p) const { return x == p.x ? y < p.y : x < p.x; }\n    bool operator<=(const Point& p) const { return *this == p || *this < p; }\n    bool operator>(const Point& p) const { return !(*this <= p); }\n    bool operator>=(const Point& p) const { return !(*this < p); }\n    double length() const { return std::sqrt(x * x + y * y); }\n    double length2() const { return x * x + y * y; }\n    Point unit() const { return *this / length(); }\n    double distance(const Point& p) const { return sqrt(pow(x - p.x, 2.0) + pow(y - p.y, 2.0)); }\n    friend std::ostream& operator<<(std::ostream& o, const Point& p) {\n      o << '(' << p.x << ',' << p.y << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Point& p) {\n      i >> p.x >> p.y;\n      return i;\n    }\n  };\n  \n  /* vector */\n  using Vector = Point;\n  double cross_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n  }\n  double inner_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  enum struct ccw_t {\n    COUNTER_CLOCKWISE,\n    CLOCKWISE,\n    ONLINE_BACK,\n    ONLINE_FRONT,\n    ON_SEGMENT\n  };\n  ccw_t ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if (cross_product(v1, v2) > eps) return ccw_t::COUNTER_CLOCKWISE;\n    if (cross_product(v1, v2) < -eps) return ccw_t::CLOCKWISE;\n    if (inner_product(v1, v2) < -eps) return ccw_t::ONLINE_BACK;\n    if (v1.length2() < v2.length2()) return ccw_t::ONLINE_FRONT;\n    return ccw_t::ON_SEGMENT;\n  }\n\n  /* line */\n  struct Line {\n    Point p1, p2;\n    Line() {}\n    Line(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n    Line(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n    Vector to_vector() const { return p2 - p1; }\n    Point projection(const Point& p) const {\n      Vector v12(p2 - p1);\n      double det = v12.length2();\n      double a = v12.y * p1.x - v12.x * p1.y, b = v12.y * p.y + v12.x * p.x;\n      double x = v12.y * a + v12.x * b, y = v12.y * b - v12.x * a;\n      return Point(x / det, y / det);\n    }\n    Point reflection(const Point& p) const {\n      Point proj = projection(p);\n      return proj + proj - p;\n    }\n    double distance(const Point& p) const {\n      return projection(p).distance(p);\n    }\n    bool is_parallel(const Line& l) const {\n      return abs(cross_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    bool is_orthogonal(const Line& l) const {\n      return abs(inner_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    Point intersection(const Line& l) const {\n      Point p0(this->p1), p1(this->p2), p2(l.p1), p3(l.p2);\n      Vector v01(p1 - p0), v23(p3 - p2);\n      double det = cross_product(v01, v23);\n      double a = v01.y * p0.x - v01.x * p0.y, b = v23.y * p2.x - v23.x * p2.y;\n      double x = v01.x * b - v23.x * a;\n      double y = v01.y * b - v23.y * a;\n      return Point(x / det, y / det);\n    }\n    friend std::ostream& operator<<(std::ostream& o, const Line& l) {\n      o << '(' << l.p1 << ',' << l.p2 << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Line& l) {\n      i >> l.p1 >> l.p2;\n      return i;\n    }\n  };\n\n  /* segment */\n  using Segment = Line;\n  bool is_intersect_segments(const Segment& s1, const Segment& s2) {\n    Vector v2 = s2.to_vector(), p1(s1.p1 - s2.p1), p2(s1.p2 - s2.p1);\n    if (cross_product(v2, p1) * cross_product(v2, p2) > eps) return false;\n    Vector v1 = s1.to_vector(), p3(s2.p1 - s1.p1), p4(s2.p2 - s1.p1);\n    if (cross_product(v1, p3) * cross_product(v1, p4) > eps) return false;\n    if (inner_product(s2.p1 - s1.p1, s2.p2 - s1.p1) < eps) return true;\n    if (inner_product(s2.p1 - s1.p2, s2.p2 - s1.p2) < eps) return true;\n    if (inner_product(s1.p1 - s2.p1, s1.p2 - s2.p1) < eps) return true;\n    if (inner_product(s1.p1 - s2.p2, s1.p2 - s2.p2) < eps) return true;\n    return false;\n  }\n  bool is_intersect_segment_line(const Segment s, const Line& l) {\n    if (l.is_parallel(s)) return false;\n    Vector vst = l.to_vector();\n    Point ps = l.p1;\n    return cross_product(vst, s.p1 - ps) * cross_product(vst, s.p2 - ps) < eps;\n  }\n  double segment_distance(const Segment& s, const Point& p) {\n    Point proj = s.projection(p);\n    if (ccw(s.p1, proj, s.p2) == ccw_t::ONLINE_FRONT) return p.distance(proj);\n    return min(p.distance(s.p1), p.distance(s.p2));\n  }\n  double segment_distance(const Segment& s1, const Segment& s2) {\n    if (is_intersect_segments(s1, s2)) return 0.0;\n    return min({\n      segment_distance(s1, s2.p1), segment_distance(s1, s2.p2),\n      segment_distance(s2, s1.p1), segment_distance(s2, s1.p2)\n      });\n  }\n\n  /* polygon */\n  using Polygon = std::vector<Point>;\n  double area(const Polygon& poly) {\n    if (poly.size() <= 2) return 0;\n    Point b(DBL_MAX, DBL_MAX);\n    for (const Point& p : poly) {\n      b.x = min(b.x, p.x); b.y = min(b.y, p.y);\n    }\n    b.x -= 1.0; b.y -= 1.0;\n    int n = (int)poly.size();\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n      area += cross_product(poly[i] - b, poly[(i + 1) % n] - b) * 0.5;\n    }\n    return area;\n  }\n  bool is_convex(const Polygon& poly) {\n    if (poly.size() <= 2) return false;\n    int n = (int)poly.size();\n    for (int i = 0; i < n; i++) {\n      if (ccw(poly[i], poly[(i + 1) % n], poly[(i + 2) % n]) == ccw_t::CLOCKWISE) {\n        return false;\n      }\n    }\n    return true;\n  }\n  enum struct poly_t {\n    EXTERNAL = 0,\n    ON_SEGMENT = 1,\n    INTERNAL = 2\n  };\n  poly_t is_inside(const Point& p, const Polygon& poly) {\n    int n = (int)poly.size();\n    double rad = 0.0;\n    for (int i = 0; i < n; i++) {\n      const Point& p1 = poly[i];\n      const Point& p2 = poly[(i + 1) % n];\n      double d1 = p.distance(p1), d2 = p.distance(p2);\n      if (segment_distance(Segment(p1, p2), p) < eps) return poly_t::ON_SEGMENT;\n      Vector v1(p1 - p), v2(p2 - p);\n      double r = atan2(cross_product(v1, v2), inner_product(v1, v2));\n      rad += r;\n    }\n    return rad < eps ? poly_t::EXTERNAL : poly_t::INTERNAL;\n  }\n\n  /* convex hull */\n  using Hull = Polygon;\n  Hull convex_hull(std::vector<Point> points, bool strict = true) {\n    double e = strict ? eps : -eps;\n    std::sort(points.begin(), points.end());\n    int n = (int)points.size(), k = 0;\n    Hull hull(2 * n);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    hull.resize(k - 1);\n    return hull;\n  }\n  double convex_diameter(const Hull& hull) {\n    int n = (int)hull.size();\n    if (n == 2) return hull.front().distance(hull.back());\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n      if (hull[k] < hull[i]) i = k;\n      if (hull[j] < hull[k]) j = k;\n    }\n    double d = 0.0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n      d = max(d, hull[i].distance(hull[j]));\n      if (cross_product(hull[(i + 1) % n] - hull[i], hull[(j + 1) % n] - hull[j]) < 0.0) {\n        i = (i + 1) % n;\n      }\n      else {\n        j = (j + 1) % n;\n      }\n    }\n    return d;\n  }\n  std::pair<Hull, Hull> convex_cut(const Hull& hull, const Line& l) {\n    int n = (int)hull.size(), i = -1, j = -1;\n    Point pi, pj;\n    for (int k = 0; k < n; k++) {\n      Segment s(hull[k], hull[(k + 1) % n]);\n      if (is_intersect_segment_line(s, l)) {\n        if (cross_product(l.to_vector(), s.to_vector()) < 0) {\n          i = k;\n          pi = l.intersection(s);\n        }\n        else {\n          j = k;\n          pj = l.intersection(s);\n        }\n      }\n    }\n    if (i < 0) {\n      // no cut: 左か右か判定\n      if (cross_product(l.to_vector(), hull.front() - l.p1) > 0) {\n        // left\n        return std::make_pair(hull, Hull());\n      }\n      else {\n        return std::make_pair(Hull(), hull);\n      }\n    }\n    Hull left({ pi, pj }), right({ pj, pi });\n    for (int k = (j + 1) % n, e = (i + 1) % n; k != e; k = (k + 1) % n) {\n      if(left.back().distance(hull[k]) > eps) left.push_back(hull[k]);\n    }\n    for (int k = (i + 1) % n, e = (j + 1) % n; k != e; k = (k + 1) % n) {\n      if(right.back().distance(hull[k]) > eps) right.push_back(hull[k]);\n    }\n    if (left.front().distance(left.back()) < eps) left.pop_back();\n    if (right.front().distance(right.back()) < eps) right.pop_back();\n    return std::make_pair(left, right);\n  }\n\n  /* closest pair : 逐次構成法 */\n  double closest_pair_incremental(std::vector<Point> ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // shuffle\n    int n = (int)ps.size();\n    for (int i = n - 1; i >= 1; i--) {\n      int j = (int)rnd(i);\n      std::swap(ps[i], ps[j]);\n    }\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x);\n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid generator\n    double delta = ps[0].distance(ps[1]);\n    auto generate_grid = [&](int sz, double delta) {\n      ll h = (int)ceil((y_max - y_min) / delta);\n      ll w = (int)ceil((x_max - x_min) / delta);\n      Grid grid;\n      for (int i = 0; i < sz; i++) {\n        double x = ps[i].x, y = ps[i].y;\n        ll ix = (ll)floor((x - x_min) / delta);\n        ll iy = (ll)floor((y - y_min) / delta);\n        grid[iy * w + ix].push_back(ps[i]);\n      }\n      return std::make_tuple(h, w, std::move(grid)); \n    };\n    // 幅 delta のグリッド構築\n    ll h, w;\n    Grid grid;\n    tie(h, w, grid) = generate_grid(2, delta);\n    for (int k = 2; k < n; k++) {\n      // d_i = d(p_i, S_i) を計算\n      double x = ps[k].x, y = ps[k].y;\n      ll ix = (ll)floor((x - x_min) / delta);\n      ll iy = (ll)floor((y - y_min) / delta);\n      // 近傍のみ調べればいい\n      double ndelta = delta;\n      for (ll i = max(iy - 1, 0LL); i <= min(iy + 1, h - 1); i++) {\n        for (ll j = max(ix - 1, 0LL); j <= min(ix + 1, w - 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            ndelta = std::min(ndelta, ps[k].distance(p));\n          }\n        }\n      }\n      if (ndelta < delta) {\n        // update grid\n        delta = ndelta;\n        tie(h, w, grid) = generate_grid(k + 1, delta);\n      }\n      else {\n        // insert point\n        grid[iy * w + ix].push_back(ps[k]);\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair : 篩法 */\n  double closest_pair_sieve(const std::vector<Point>& ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // init grid\n    Grid grid;\n    for (const Point& p : ps) grid[0].push_back(p);\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x); \n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid updator\n    auto update_grid = [&](const Grid& grid, double delta, bool erase_mode = true) {\n      int erased = 0;\n      ll h = (ll)ceil((y_max - y_min) / delta);\n      ll w = (ll)ceil((x_max - x_min) / delta);\n      Grid ngrid;\n      for (auto it = grid.begin(); it != grid.end(); ++it) {\n        for (const Point& p : it->second) {\n          ll ix = (ll)floor((p.x - x_min) / delta);\n          ll iy = (ll)floor((p.y - y_min) / delta);\n          ngrid[iy * w + ix].push_back(p);\n        }\n      }\n      if (erase_mode) {\n        // 孤立点の除去\n        auto it = ngrid.begin();\n        while (it != ngrid.end()) {\n          if (it->second.size() >= 2) { ++it; continue; }\n          ll pos = it->first, iy = pos / w, ix = pos % w;\n          // 8 近傍に点がなければ、削除する\n          bool found = [&]() {\n            for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n              for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n                if (i == iy && j == ix) continue;\n                if (ngrid.count(i * w + j)) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          } ();\n          if (!found) {\n            it = ngrid.erase(ngrid.find(pos));\n            erased++;\n          }\n          else ++it;\n        }\n      }\n      return make_tuple(erased, h, w, std::move(ngrid));\n    };\n    // elimination phase\n    int n = (int)ps.size(), erased;\n    ll h = 1, w = 1;\n    double delta = DBL_MAX;\n    while (n) {\n      // ランダムに点を選ぶ\n      auto it = std::next(grid.begin(), rnd((int)grid.size()));\n      ll pos = it->first;\n      auto& cands = it->second;\n      int i = rnd((int)cands.size());\n      Point selected = cands[i];\n      // 一旦消す\n      cands.erase(cands.begin() + i);\n      // pos 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            delta = min(delta, selected.distance(p));\n          }\n        }\n      }\n      // 元に戻す\n      cands.push_back(selected);\n      // 幅 delta / 8 で grid を作成\n      delta /= 8;\n      tie(erased, h, w, grid) = update_grid(grid, delta);\n      n -= erased;\n    }\n    delta *= 8;\n    // 最終的な delta で最近点対探索\n    // reset grid\n    for (const Point& p : ps) grid[0].push_back(p);\n    tie(erased, h, w, grid) = update_grid(grid, delta, false);\n    // find closest points\n    delta = DBL_MAX;\n    for (auto it = grid.begin(); it != grid.end(); ++it) {\n      ll pos = it->first;\n      auto& cands = it->second;\n      // 自身の近傍\n      for (int i = 0; i < (int)cands.size() - 1; i++) {\n        for (int j = i + 1; j < cands.size(); j++) {\n          delta = min(delta, cands[i].distance(cands[j]));\n        }\n      }\n      // 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (i == iy && j == ix) continue;\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p1 : cands) {\n            for (const auto& p2 : grid[i * w + j]) {\n              delta = min(delta, p1.distance(p2));\n            }\n          }\n        }\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair: 分割統治法 */\n  double closest_pair_impl(std::vector<Point>& ps, int l, int r) {\n    static const auto cmp_y = [](const Point& a, const Point& b) { return a.y < b.y; };\n    int n = r - l, m = (l + r) >> 1;\n    if (n <= 1) return DBL_MAX;\n    double x = ps[m].x;\n    double d = min(closest_pair_impl(ps, l, m), closest_pair_impl(ps, m, r));\n    std::inplace_merge(ps.begin() + l, ps.begin() + m, ps.begin() + r, cmp_y);\n    std::vector<Point> b;\n    for (int i = 0; i < n; i++) {\n      if (abs(ps[i + l].x - x) >= d) continue;\n      for (int j = (int)b.size() - 1; j >= 0; j--) {\n        double dx = ps[i + l].x - b[j].x, dy = ps[i + l].y - b[j].y;\n        if (dy >= d) break;\n        d = min(d, sqrt(dx * dx + dy * dy));\n      }\n      b.push_back(ps[i + l]);\n    }\n    return d;\n  }\n  double closest_pair(std::vector<Point> ps) {\n    std::sort(ps.begin(), ps.end());\n    return closest_pair_impl(ps, 0, (int)ps.size());\n  }\n\n  /* circle */\n  struct Circle {\n    double x, y, r;\n    Circle() {}\n    Circle(double x, double y, double r) : x(x), y(y), r(r) {}\n    friend std::ostream& operator<<(std::ostream& o, const Circle& c) {\n      o << '(' << c.x << ',' << c.y << ',' << c.r << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Circle& c) {\n      i >> c.x >> c.y >> c.r;\n      return i;\n    }\n    int tangent_lines(const Circle& c) const {\n      double d = center().distance(c.center());\n      if (abs(r + c.r - d) < eps) return 3;\n      if (abs(abs(r - c.r) - d) < eps) return 1;\n      if (r + c.r < d) return 4;\n      if (d < abs(r - c.r)) return 0;\n      return 2;\n    }\n    Point center() const {\n      return Point(x, y);\n    }\n  };\n  Circle inscribed_circle(const Point& A, const Point& B, const Point& C) {\n    Vector AB(B - A), BC(C - B), CA(A - C);\n    Vector u = (B - A).unit() + (C - A).unit();\n    Vector v = (B - A).unit() + (B - C).unit();\n    Vector w = B - A;\n    double c = cross_product(u, v);\n    double s = (v.y * w.x - v.x * w.y) / c;\n    double t = (u.x * w.y - u.y * w.x) / c;\n    Point O = A + s * u;\n    double S = abs(cross_product(AB, -CA) * 0.5);\n    double r = 2.0 * S / (AB.length() + BC.length() + CA.length());\n    return Circle(O.x, O.y, r);\n  }\n}\n\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using namespace geom;\n\n  Point A, B, C;\n  cin >> A >> B >> C;\n\n  cout << fixed << setprecision(15);\n\n  Circle c = inscribed_circle(A, B, C);\n  cout << c.x << ' ' << c.y << ' ' << c.r << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nstruct POINT {\n    double x;\n    double y;\n};\n\ndouble Dist(const POINT &a, const POINT &b){\n    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) );  \n}\n\ndouble Square(const POINT &a, const POINT &b, const POINT &c){    //3点を頂点に持つ\"平行四辺形の\"面積\n    return fabs( (a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x) );\n}\n\n\nint main(){\n    POINT zP[3];\n    for (int i = 0; i < 3; i++){\n        scanf(\"%lf %lf\", &zP[i].x, &zP[i].y);\n    }\n    double xAns,yAns,rAns;\n    xAns = ( Dist(zP[1], zP[2]) * zP[0].x + Dist(zP[2], zP[0]) * zP[1].x + Dist(zP[0], zP[1]) * zP[2].x )\n           / ( Dist(zP[1], zP[2]) + Dist(zP[2], zP[0]) + Dist(zP[0], zP[1]) );\n    yAns = ( Dist(zP[1], zP[2]) * zP[0].y + Dist(zP[2], zP[0]) * zP[1].y + Dist(zP[0], zP[1]) * zP[2].y )\n           / ( Dist(zP[1], zP[2]) + Dist(zP[2], zP[0]) + Dist(zP[0], zP[1]) );\n    rAns = Square(zP[1], zP[2], zP[0]) / ( Dist(zP[1], zP[2]) + Dist(zP[2], zP[0]) + Dist(zP[0], zP[1]) );\n    printf(\"%lf %lf %lf\", xAns, yAns, rAns);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a, i##end = b; i <= i##end; ++i)\n#define per(i, a, b) for (int i = a, i##end = b; i >= i##end; --i)\n#define rep0(i, a) for (int i = 0, i##end = a; i < i##end; ++i)\n#define per0(i, a) for (int i = (int)a-1; ~i; --i)\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define chkmax(a, b) a = max(a, b)\n#define chkmin(a, b) a = min(a, b)\n#define x first\n#define y second\n#define enter putchar('\\n')\n\ntypedef long long ll;\ntypedef double DB;\n\nconst DB eps = 1e-12;\nconst DB PI = acos(-1);\n\nint sgn(DB x) { return fabs(x) < eps ? 0 : (x > 0 ? 1 : -1); }\n\nstruct Point {\n\tDB x, y;\n\tPoint(DB x = 0, DB y = 0) : x(x), y(y) {}\n\tPoint operator + (Point a) { return Point(x + a.x, y + a.y); }\n\tPoint operator - (Point a) { return Point(x - a.x, y - a.y); }\n\tPoint operator - () { return Point(-x, -y); }\n\tfriend Point operator * (DB k, Point a) { return Point(k * a.x, k * a.y); }\n\tPoint operator / (DB k) { return Point(x / k, y / k); }\n\tDB operator % (Point a) { return x * a.x + y * a.y; }\n\tDB operator / (Point a) { return x * a.y - y * a.x; }\n\toperator DB() { return sqrt(x*x + y*y); }\n\tbool operator < (const Point &a) const { int d1 = sgn(x-a.x), d2 = sgn(y-a.y); return d1 < 0 || (d1 == 0 && d2 < 0); }\n};\n\nstruct Circle { Point P; DB r; };\n\nPoint Proj(Point P, Point P1, Point P2) {\n\tPoint v = P2-P1; DB t = (P-P1)%v / (v%v);\n\treturn P1 + t*v;\n}\n\nPoint GetLineInter(Point P1, Point P2, Point Q1, Point Q2) {\n\tPoint v = P2-P1, w = Q2-Q1; DB t = (Q1-P1)/w / (v/w);\n\treturn P1 + t*v;\n}\n\nint Direct1(Point P, Point P1, Point P2) { return sgn((P1-P)%(P2-P)); }\nint Direct2(Point P, Point P1, Point P2) { return sgn((P1-P)/(P2-P)); }\n\nPoint A, B, C;\n\nCircle GetInnerCir(Point A, Point B, Point C) {\n\tPoint v1 = B-A, v2 = C-A, v3 = C-B;\n\t/*\n\tprintf(\"%.10lf %.10lf\\n\", v1.x, v1.y);\n\tprintf(\"%.10lf\\n\", DB(v1));\n\t*/\n\tv1 = v1/DB(v1), v2 = v2/DB(v2), v3 = v3/DB(v3);\n\t//printf(\"%.10lf %.10lf\\n\", v1.x, v1.y);\n\tPoint A0 = A+1e4*(v1+v2), B0 = B+1e4*(v3-v1), P = GetLineInter(A, A0, B, B0);\n\treturn (Circle){P, DB(P-Proj(P, A, B))};\n}\n\nint main() {\n\tscanf(\"%lf%lf%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y, &C.x, &C.y);\n\tCircle X = GetInnerCir(A, B, C);\n\tprintf(\"%.10lf %.10lf %.10lf\\n\", X.P.x, X.P.y, X.r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nnamespace geo{\n    using real_num = double;\n    constexpr real_num eps = 1e-9;\n    constexpr real_num PI = 3.14159265358979323846264338327950;\n\n    inline int sgn(real_num x){\n        if(x < -eps) return -1;\n        if(x > eps) return 1;\n        return 0;\n    }\n \n    inline bool eq(real_num x, real_num y){\n        return sgn(x-y) == 0;\n    }\n \n    inline bool ge(real_num x, real_num y){\n        return sgn(x-y) == 1;\n    }\n \n    inline bool le(real_num x, real_num y){\n        return sgn(x-y) == -1;\n    }\n \n    inline bool geq(real_num x, real_num y){\n        return sgn(x-y) >= 0;\n    }\n \n    inline bool leq(real_num x, real_num y){\n        return sgn(x-y) <= 0;\n    }\n\n    struct Point{\n        real_num x, y;\n        Point(real_num x=0, real_num y=0): x(x), y(y){}\n \n        Point operator+(const Point &p){\n            return {x+p.x, y+p.y};\n        }\n \n        Point operator-(const Point &p){\n            return {x-p.x, y-p.y};\n        }\n \n        Point operator*(const real_num k){\n            return {k*x, k*y};\n        }\n \n        Point operator/(const real_num k){\n            return {x/k, y/k};\n        }\n \n        real_num operator*(const Point &p){\n            return x*p.x + y*p.y;\n        }\n \n        real_num operator^(const Point &p){\n            return x*p.y - y*p.x;\n        }\n \n        bool operator==(const Point &p){\n            return eq(x, p.x) && eq(y, p.y);\n        }\n \n        bool operator<(const Point &p) const{\n            if(eq(x, p.x)) return le(y, p.y);\n            return le(x, p.x);\n        }\n    };\n\n    using Vec = Point;\n    using Points = vector<Point>;\n    using Polygon = vector<Point>;\n\n    real_num norm(Point p){\n        return p.x*p.x+p.y*p.y;\n    }\n \n    real_num abs(Point p){\n        return sqrt(norm(p));\n    }\n \n    real_num arg(Point p){\n        return atan2(p.y, p.x);\n    }\n \n    Point rot(Point p, real_num t){\n        return {p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)};\n    }\n \n    Point proj(Point a, Vec v, Point p){\n        real_num t=v*(p-a)/norm(v);\n        return a+v*t;\n    }\n \n    Point refl(Point a, Vec v, Point p){\n        return proj(a, v, p)*2-p;\n    }\n\n    constexpr int CCW_COUNTER_CLOCKWISE = 1;\n    constexpr int CCW_CLOCKWISE = -1;\n    constexpr int CCW_ONLINE_BACK = -2; // C->A->B\n    constexpr int CCW_ONLINE_FRONT = 2; // A->B->C\n    constexpr int CCW_ON_SEGMENT = 0; // A->C->B\n \n    inline int ccw(Point a, Point b, Point c){\n        Vec v = b-a, w = c-a;\n        if(ge(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n        if(le(v^w, 0)) return CCW_CLOCKWISE;\n        if(le(v*w, 0)) return CCW_ONLINE_BACK;\n        if(le((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n        return CCW_ON_SEGMENT;\n    }\n\n    bool is_parallel(Vec v, Vec w){\n        return eq(v^w, 0);\n    }\n\n    bool is_orthogonal(Vec v, Vec w){\n        return eq(v*w, 0);\n    }\n\n    bool has_intersection_ls(Point p, Vec v, Point a, Point b){\n        return sgn(v^(a-p)) * sgn(v^(b-p)) <= 0;\n    }\n\n    bool has_intersection_ss(Point a, Point b, Point c, Point d){\n        return ccw(a, b, c)*ccw(a, b, d) <= 0 && ccw(c, d, a)*ccw(c, d, b) <= 0;\n    }\n\n    Point intersection_ll(Point a, Vec v, Point b, Vec w){\n        real_num t = ((b-a)^w) / (v^w);\n        return a + v*t;\n    }\n\n    real_num distance_lp(Point a, Vec v, Point p){\n        return abs(v^(p-a)/abs(v));\n    }\n\n    real_num distance_sp(Point a, Point b, Point p){\n        if(le((b-a)*(p-a), 0)) return abs(p-a);\n        if(le((a-b)*(p-b), 0)) return abs(p-b);\n        return distance_lp(a, b-a, p);\n    }\n\n    real_num distance_ll(Point a, Vec v, Point b, Vec w){\n        if(is_parallel(v, w)) return distance_lp(a, v, b);\n        return 0;\n    }\n\n    real_num distance_ls(Point p, Vec v, Point a, Point b){\n        if(has_intersection_ls(p, v, a, b)) return 0;\n        return min(distance_lp(p, v, a), distance_lp(p, v, b));\n    }\n\n    real_num distance_ss(Point a, Point b, Point c, Point d){\n        if(has_intersection_ss(a, b, c, d)) return 0;\n        return min({distance_sp(a, b, c), distance_sp(a, b, d),\n                distance_sp(c, d, a), distance_sp(c, d, b)});\n    }\n\n    real_num area(Polygon &p){\n        real_num ret = 0;\n        rep(i, p.size()) ret += p[i] ^ p[(i+1)%p.size()] / 2;\n        return abs(ret);\n    }\n\n    bool is_convex(Polygon &p){\n        int n = p.size();\n        bool flag1 = false, flag2 = false;\n        rep(i, n){\n            int tmp = ccw(p[(i+n-1)%n], p[i], p[(i+1)%n]);\n            if(tmp == CCW_COUNTER_CLOCKWISE){\n                if(flag2) return false;\n                flag1=true;\n            }\n            else if(tmp == CCW_CLOCKWISE){\n                if(flag1) return false;\n                flag2 = true;\n            }\n        }\n        return true;\n    }\n\n    int point_in_polygon(Point a, Polygon &p){\n        int n = p.size(), wn = 0;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(distance_sp(p[i], p[j], a) == 0) return 1;\n            else if(p[i].y <= a.y && a.y < p[j].y){\n                wn += (ccw(a, p[i], p[j]) == CCW_COUNTER_CLOCKWISE);\n            }\n            else if(p[j].y <= a.y && a.y < p[i].y){\n                wn -= (ccw(a, p[i], p[j]) == CCW_CLOCKWISE);\n            }\n        }\n        return wn == 0 ? 0 : 2;\n    }\n\n    Polygon convex_hull(Points p){\n        int n = p.size();\n        sort(p.begin(), p.end());\n        Polygon ch(2*n);\n        int k = 0;\n        rep(i, n){\n            while(k>1 && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        for(int i=n-2, t=k; i>=0; --i){\n            while(k>t && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        ch.resize(k-1);\n        return ch;\n    }\n\n    pair<real_num, pii> farthest_pair(Polygon &p){\n        int n = p.size();\n        if(n == 2){\n            return {abs(p[0]-p[1]), {0, 1}};\n        }\n        int i = 0, j = 0;\n        rep(k, n){\n            if(le(p[k].x, p[i].x)) i = k;\n            if(ge(p[k].x, p[j].x)) j = k;\n        }\n        real_num d = 0;\n        int a = i, b = j, si = i, sj = j;\n        while(i != sj || j != si){\n            if(chmax(d, abs(p[i]-p[j]))) a = i, b = j;\n            if(le((p[(i+1)%n]-p[i]) ^ (p[(j+1)%n]-p[j]), 0)){\n                i = (i+1) % n;\n            }\n            else j = (j+1) % n;\n        }\n        return {d, {a, b}};\n    }\n\n    real_num convex_cut(Polygon &p, Point a, Vec v){\n        int n = p.size();\n        Polygon q;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(geq(v^(p[i]-a), 0)) q.push_back(p[i]);\n            if(has_intersection_ls(a, v, p[i], p[j]) && !is_parallel(v, p[j]-p[i])){\n                q.push_back(intersection_ll(a, v, p[i], p[j]-p[i]));\n            }\n        }\n        return area(q);\n    }\n\n    pair<real_num, pii> closest_pair_rec(vector<pair<Point, int>> &p, int l, int r){\n        if(r-l <= 1) return {INF, {p.size(), p.size()}};\n\n        int m = (l+r) / 2;\n        real_num x = p[m].fi.x;\n        auto d = min(closest_pair_rec(p, l, m), closest_pair_rec(p, m, r));\n        auto cmp = [](pair<Point, int> a, pair<Point, int> b){return a.fi.y < b.fi.y;};\n        inplace_merge(p.begin()+l, p.begin()+m, p.begin()+r, cmp);\n\n        vector<pair<Point, int>> q;\n        For(i, l, r){\n            if(ge(abs(p[i].fi.x-x), d.fi)) continue;\n            rrep(j, q.size()){\n                real_num dx = p[i].fi.x - q[j].fi.x;\n                real_num dy = p[i].fi.y - q[j].fi.y;\n                if(geq(dy, d.fi)) break;\n                chmin(d, {abs(p[i].fi-q[j].fi), {p[i].se, q[j].se}});\n            }\n            q.push_back(p[i]);\n        }\n        return d;\n    }\n\n    pair<real_num, pii> closest_pair(Points &p){\n        vector<pair<Point, int>> pid(p.size());\n        rep(i, p.size()) pid[i] = {p[i], i};\n        sort(pid.begin(), pid.end());\n        return closest_pair_rec(pid, 0, p.size());\n    }\n\n    int has_intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        if(r1 < r2){\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        real_num d = abs(c1-c2), r = r1 + r2;\n        if(ge(d, r)) return 4;\n        if(eq(d, r)) return 3;\n        if(eq(d+r2, r1)) return 1;\n        if(le(d+r2, r1)) return 0;\n        return 2;\n    }\n\n    bool has_intersection_cl(Point c, real_num r, Point a, Vec v){\n        return leq(distance_lp(a, v, c), r);\n    }\n\n    bool has_intersection_cs(Point c, real_num r, Point a, Point b){\n        return leq(distance_sp(a, b, c), r) && geq(max(abs(a-c), abs(b-c)), r);\n    }\n\n    Points intersection_cl(Point c, real_num r, Point a, Vec v){   \n        Points ps;\n        if(!has_intersection_cl(c, r, a, v)) return ps;\n        Point p = proj(a, v, c);\n        real_num t = sqrt(max((real_num)0.0, (r*r-norm(p-c)) / norm(v)));\n        ps.push_back(p + v*t);\n        if(!eq(t, 0)) ps.push_back(p - v*t);\n        return ps;\n    }\n\n    Points intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        Points ps;\n        Vec v = c2-c1, w = {v.y*-1, v.x};\n        real_num d = abs(v);\n        real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n        real_num y = sqrt(max(r1*r1-x*x, (real_num)0.0));\n        ps.push_back(c1 + v*x/d + w*y/d);\n        if(has_intersection_cc(c1, r1, c2, r2)!=2) return ps;\n        ps.push_back(c1 + v*x/d - w*y/d);\n        return ps;\n    }\n\n    real_num commn_area_cc(Point c1, real_num r1, Point c2, real_num r2){\n        int flag = has_intersection_cc(c1, r1, c2, r2);\n        if(flag >= 3) return 0;\n        if(flag <= 1){\n            real_num r = min(r1, r2);\n            return PI*r*r;\n        }\n        real_num d = abs(c1-c2);\n        real_num ret = 0;\n        rep(i, 2) {\n            real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n            real_num t = acos(x/r1)* 2;\n            ret += (t-sin(t))*r1*r1/2;\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        return ret;\n    }\n\n    Points tangent(Point c, real_num r, Point p){\n        Points ps;\n        real_num d = abs(p-c);\n        real_num t = acos(r/d);\n        ps.push_back(c + rot(p-c, t)*r/d);\n        ps.push_back(c + rot(p-c, -t)*r/d);\n        return ps;\n    }\n\n    Points common_tangent(Point c1, real_num r1, Point c2, real_num r2){       \n        Points ps;\n        int flag = has_intersection_cc(c1, r1,c2, r2);\n        if(flag >= 2){\n            real_num d = abs(c2-c1);\n            real_num t = acos(abs(r1-r2)/d);\n            if(le(r1, r2)) t = PI-t;\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 4){\n            real_num d = abs(c2-c1);\n            real_num L = d*r1/(r1+r2);\n            real_num t = acos(r1/L);\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 3 || flag == 1){\n            Polygon tg = intersection_cc(c1, r1, c2, r2);\n            ps.push_back(tg[0]);\n        }\n        return ps;\n    }\n\n    Point get_o(Point a, Point b, Point c){\n        Point M = (a+b)/2, N = (a+c)/2;\n        Vec v = {-(b-a).y, (b-a).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(M, v, N, w);\n    }\n\n    Point get_i(Point a, Point b, Point c){\n        real_num A = abs(b-c), B = abs(c-a), C = abs(a-b);\n        return (a*A+b*B+c*C)/(A+B+C);\n    }\n\n    Point get_h(Point a, Point b, Point c){\n        Vec v = {-(c-b).y, (c-b).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(a, v, b, w);\n    }\n\n    pair<Point, real_num> minimum_bounding_circle(Points &p){\n        Point C;\n        real_num r;\n        if(p.size() == 1) C = p[0], r = 0;\n        else if(p.size() == 2) C = (p[0]+p[1])/2, r = abs(p[0]-C);\n        else{\n            r = INF;\n            Points ch = convex_hull(p);\n            int K = ch.size();\n            auto check = [&](Point tc, real_num tr){\n                rep(i, K){\n                    if(ge(abs(ch[i]-tc), tr)) return false;\n                }\n                return true;\n            };\n            rep(i, K)For(j, i+1, K){\n                Point tc = (ch[i]+ch[j])/2;\n                real_num tr = abs(ch[i]-tc);\n                if(check(tc, tr) && chmin(r, tr)) C = tc;\n                For(k, j+1, K){\n                    int ccw_flag = ccw(ch[i], ch[j], ch[k]);\n                    if(ccw_flag != CCW_COUNTER_CLOCKWISE && ccw_flag != CCW_CLOCKWISE) continue;\n                    tc = get_o(ch[i], ch[j], ch[k]);\n                    tr = abs(ch[i]-tc);\n                    if(check(tc, tr) && chmin(r, tr)) C=tc;\n                }\n            }\n        }\n        return {C, r};\n    }\n}\n\nusing namespace geo;\n\nint main(){\n    Points p(3);\n    rep(i, 3) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    auto c = get_i(p[0], p[1], p[2]);\n    printf(\"%.10lf %.10lf %.10lf\\n\", c.x, c.y, distance_sp(p[0], p[1], c));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 1000000000000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n\nstruct Point{\n\tPoint(long double arg_x,long double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (long double a){ return Point(a*x,a*y); }\n\tPoint operator / (long double a){ return Point(x/a,y/a); }\n\n\tlong double abs(){ return sqrt(norm()); }\n\tlong double norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tlong double x,y;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(){\n\n\t}\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Info{\n\tInfo(Point arg_point,long double arg_slope){\n\t\tpoint = arg_point;\n\t\tslope = arg_slope;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\treturn slope < arg.slope;\n\t}\n\n\tPoint point;\n\tlong double slope;\n};\n\n\nlong double calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\n\nlong double calc_slope(Line A){\n\n\tif(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n\t\treturn DBL_MAX;\n\n\t}else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n\t\treturn 0;\n\n\t}else{\n\n\t\treturn (A.p[1].y-A.p[0].y)/(A.p[1].x-A.p[0].x);\n\t}\n}\n\n//交点を求める関数\nPoint calc_Cross_Point(long double x1,long double x2,long double x3,long double x4,long double y1,long double y2,long double y3,long double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\nint func(long double x1,long double y1,long double x2, long double y2, long double xp, long double yp){\n\tlong double naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nlong double calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\nlong double norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\nlong double abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\nlong double cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nlong double dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n//線分ではなく直線と点の距離\nlong double getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\n//点と線分の距離\nlong double getDistanceSP(Line l,Point p){\n\tif(dot(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0])) < 0.0)return calc_len(calc_minus(p,l.p[0]));\n\tif(dot(calc_minus(l.p[0],l.p[1]),calc_minus(p,l.p[1])) < 0.0)return calc_len(calc_minus(p,l.p[1]));\n\treturn getDistanceLP(l,p);\n}\n\n//線分と線分の距離\nlong double getDistance(Line A,Line B){\n\tif(is_Cross(A,B))return 0.0;\n\treturn min(min(getDistanceSP(A,B.p[0]),getDistanceSP(A,B.p[1])),\n\t\t\tmin(getDistanceSP(B,A.p[0]),getDistanceSP(B,A.p[1])));\n}\n\nPoint calc_Cross_Point(Line A,Line B){\n\n\tif(getDistanceSP(B,A.p[0]) < EPS){\n\n\t\treturn A.p[0];\n\n\t}else if(getDistanceSP(B,A.p[1]) < EPS){\n\n\t\treturn A.p[1];\n\n\t}else if(getDistanceSP(A,B.p[0]) < EPS){\n\n\t\treturn B.p[0];\n\n\t}else if(getDistanceSP(A,B.p[1]) < EPS){\n\n\t\treturn B.p[1];\n\t}\n\n\treturn calc_Cross_Point(A.p[0],A.p[1],B.p[0],B.p[1]);\n}\n\n\nint main(){\n\n\tPoint point[3];\n\n\tfor(int i = 0; i < 3; i++){\n\n\t\tscanf(\"%Lf %Lf\",&point[i].x,&point[i].y);\n\t}\n\n\tlong double len_01 = calc_dist(point[0],point[1]);\n\tlong double len_02 = calc_dist(point[0],point[2]);\n\tlong double len_12 = calc_dist(point[1],point[2]);\n\n\t//辺12をlen_01:len_02に内分する点\n\tPoint mid1 = Point((len_01*point[2].x+len_02*point[1].x)/(len_01+len_02),(len_01*point[2].y+len_02*point[1].y)/(len_01+len_02));\n\n\t//辺02をlen_01:len_12に内分する点\n\tPoint mid2 =  Point((len_12*point[0].x+len_01*point[2].x)/(len_01+len_12),(len_12*point[0].y+len_01*point[2].y)/(len_01+len_12));\n\n\tLine base_line1 = Line(point[0],mid1);\n\tLine base_line2 = Line(point[1],mid2);\n\n\tPoint center =  calc_Cross_Point(base_line1,base_line2);\n\n\tlong double r = getDistanceSP(Line(point[0],point[1]),center); //辺との距離\n\n\tprintf(\"%.10Lf %.10Lf %.10Lf\\n\",center.x,center.y,r);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// basis\nnamespace geometry {\n    using real_number = long double;\n\n    constexpr real_number EPS = 1e-8;\n    const real_number PI = acos(-1);\n}\n\n// point\nnamespace geometry {\n    class point : public std::complex< real_number > {\n        public:\n        point() = default;\n\n        using std::complex< real_number >::complex;\n        point(const complex< real_number > &c) : std::complex< real_number >::complex(c) {}\n\n        real_number dot(const point &b) const {\n            return real() * b.real() + imag() * b.imag();\n        }\n        real_number cross(const point &b) const {\n            return real() * b.imag() - imag() * b.real();\n        }\n    };\n\n    using points = std::vector< point >;\n}\n\n// polygon\nnamespace geometry {\n    using polygon = std::vector< point >;\n    using polygons = std::vector< polygon >;\n}\n\n// line\nnamespace geometry { \n    class line {\n        public:\n        point a, b;\n\n        line() = default;\n        line(point a, point b) : a(a), b(b) {}\n\n        line(real_number A, real_number B, real_number C) { // Ax + By = C\n            if (fabs(A) < EPS) a = point(0, C / B), b = point(1, C / B);\n            else if (fabs(B) < EPS) b = point(C / A, 0), b = point(C / A, 1);\n            else a = point(0, C / B), b = point(C / A, 0);\n        }\n    };\n\n    using lines = std::vector< line >;\n}\n\n// segment\nnamespace geometry {\n    class segment : public line {\n        segment() = default;\n\n        using line::line;\n    };\n\n    using segments = std::vector< segment >;\n}\n\n// circle\nnamespace geometry {\n    class circle {\n        public:\n        using radius = real_number;\n        point p;\n        radius r;\n\n        circle(point p, radius r) : p(p), r(r) {}\n    };\n\n    using circles = std::vector< circle >;\n}\n\n// angle\nnamespace geometry {\n    real_number get_angle(const point &a, const point &b, const point &c) {\n        const point v(b - a), w(c - b);\n        real_number alpha = std::atan2(v.imag(), v.real());\n        real_number beta  = std::atan2(w.imag(), w.real());\n        if (alpha > beta) std::swap(alpha, beta);\n        real_number theta = (beta - alpha);\n        return std::min(theta, 2 * acos(-1) - theta);\n    }\n}\n\nnamespace geometry {\n    int ccw(const point &a, const point &b, const point &c) {\n        const point v(b - a), w(c - a);\n        if (v.cross(w) > EPS) return +1;\n        if (v.cross(w) < -EPS) return -1;\n        if (v.dot(w) < 0) return +2;\n        if (norm(v) < norm(w)) return -2;\n        return 0;\n    }\n}\n\nnamespace geometry {\n    point projection(const line &l, const point &p) {\n        real_number t = point(p - l.a).dot(point(l.a - l.b)) / norm(l.a - l.b);\n        return point(l.a + (l.a - l.b) * t);\n    }\n\n    point projection(const segment &s, const point &p) {\n        real_number t = point(p - s.a).dot(point(s.a - s.b)) / norm(s.a - s.b);\n        return point(s.a + (s.a - s.b) * t);\n    }\n}\n\nnamespace geometry {\n    // a-b-c\n    line angle_bisector(const point &a, const point &b, const point &c) {\n        const point v(a - b), w(c - b);\n        const point p((a * abs(w) + c * abs(v)) / (abs(w) + abs(v)));\n        return line(b, p);\n    }\n}\n\nnamespace geometry {\n    bool is_intersect(const segment &s, const point &p) {\n        return ccw(s.a, s.b, p) == 0;\n    }\n}\n\nnamespace geometry {\n    real_number distance(const segment &s, const point &p) {\n        point r = projection(s, p);\n        if (is_intersect(s, r)) return abs(r - p);\n        return std::min(abs(s.a - p), abs(s.b - p));\n    }\n\n    real_number distance(const point &p1, const point &p2) {\n        return abs(p1 - p2);\n    }\n}\n\nnamespace geometry {\n    point cross_point(const line &s, const line &t) {\n        real_number a = point(s.b - s.a).cross(point(t.b - t.a));\n        real_number b = point(s.b - s.a).cross(point(s.b - t.a));\n        if (fabs(a) < EPS && fabs(b) < EPS) return t.a;\n        return point(t.a + (t.b - t.a) * b / a);\n    }\n}\n\nnamespace geometry {\n    real_number area(const polygon &p) {\n        real_number res = 0;\n        for (int i = 0; i < p.size(); ++i) {\n            res += p[i].cross(p[(i + 1) % p.size()]);\n        }\n        return res / real_number(2);\n    }\n}\n\nnamespace geometry {\n    circle inscribed_circle(const point &a, const point &b, const point &c) {\n        real_number A = abs(b - c), B = abs(c - a), C = abs(a - b);\n        point x((a * A + b * B + c * C) / (A + B + C));\n        //real_number r = real_number(2) * area({a, b, c}) / (A + B + C);\n        real_number r = distance(segment(a, b), x);\n        return circle(x, r); \n    }\n\n    circle circumscribed_circle(const point &a, const point &b, const point &c) {\n        point m1((a + b) / real_number(2)), m2((b + c) / real_number(2));\n        point v((b - a).imag(), (a - b).real()), w((b - c).imag(), (c - b).real()); \n        line s(m1, point(m1 + v)), t(m2, point(m2 + w));\n\n        point x = cross_point(s, t);\n        return circle(x, distance(a, x));\n    }\n}\n\nint main() {\n    using namespace geometry;\n    points ps(3);\n\n    for (auto &p: ps) {\n        real_number x, y;\n        std::cin >> x >> y;\n        p = point(x, y);\n    }\n\n    circle c = inscribed_circle(ps[0], ps[1], ps[2]);\n\n    std::cout << std::fixed << std::setprecision(20);\n    std::cout << c.p.real() << \" \" << c.p.imag() << \" \" << c.r << std::endl;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n#3辺の長さ\na = math.sqrt(((x1-x2)**2)+((y1-y2)**2))\nb = math.sqrt(((x3-x2)**2)+((y3-y2)**2))\nc = math.sqrt(((x1-x3)**2)+((y1-y3)**2))\ns = (a+b+c)/2\n\nr = math.sqrt(s*(s-a)*(s-b)*(s-c))/s #ヘロンの公式\nxa, ya = x1+(x2-x1)*c/(b+c), y1+(y2-y1)*c/(b+c) #二等分線とaの交点\nxb, yb = x2+(x3-x2)*a/(a+c), y2+(y3-y2)*a/(a+c)\n\nif (xa-x3) != 0 and (xb-x1) != 0:\n    a1, b1 = (ya-y3)/(xa-x3), -((ya-y3)/(xa-x3))*x3+y3 #二等分線の方程式\n    a2, b2 = (yb-y1)/(xb-x1), -((yb-y1)/(xb-x1))*x1+y1\n    cx = (b2-b1)/(a1-a2)\n    cy = a1 * cx + b1\n\nif xa-x3 == 0:\n    cx = x3\n    a2, b2 = (yb-y1)/(xb-x1), -((yb-y1)/(xb-x1))*x1+y1\n    cy = a2 * cx + b2\n\nif xb-x1 == 0:\n    cx = x1\n    a1, b1 = (ya-y3)/(xa-x3), -((ya-y3)/(xa-x3))*x3+y3\n    cy = a1 * cx + b1\n\nprint(cx, cy, r)\n"
  }
]